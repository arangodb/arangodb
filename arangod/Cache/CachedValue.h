////////////////////////////////////////////////////////////////////////////////
/// DISCLAIMER
///
/// Copyright 2014-2017 ArangoDB GmbH, Cologne, Germany
/// Copyright 2004-2014 triAGENS GmbH, Cologne, Germany
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// Copyright holder is ArangoDB GmbH, Cologne, Germany
///
/// @author Daniel H. Larkin
////////////////////////////////////////////////////////////////////////////////

#ifndef ARANGODB_CACHE_CACHED_VALUE_H
#define ARANGODB_CACHE_CACHED_VALUE_H

#include "Basics/Common.h"

#include <stdint.h>
#include <atomic>

namespace arangodb {
namespace cache {

////////////////////////////////////////////////////////////////////////////////
/// @brief This is the beginning of a cache data entry.
///
/// It will be allocated using new uint8_t[] with the correct size for header,
/// key and value. The key and value reside directly behind the header entries
/// contained in this struct. The reference count is used to lend CachedValues
/// to clients.
////////////////////////////////////////////////////////////////////////////////
struct CachedValue {
  // key size must fit in 3 bytes
  static constexpr uint32_t maxKeySize = 0xFFFFFFUL;
  // value size must fit in 4 bytes
  static constexpr uint64_t maxValueSize = 0xFFFFFFFFULL;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Reference count (to avoid premature deletion)
  //////////////////////////////////////////////////////////////////////////////
  std::atomic<uint32_t> refCount;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Size of the key in bytes
  //////////////////////////////////////////////////////////////////////////////
  uint32_t keySize;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Size of the value in bytes
  //////////////////////////////////////////////////////////////////////////////
  uint64_t valueSize;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Returns a pointer offset to the key
  //////////////////////////////////////////////////////////////////////////////
  uint8_t const* key() const;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Returns a pointer offset to the value
  //////////////////////////////////////////////////////////////////////////////
  uint8_t const* value() const;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Returns the allocated size of bytes including the key and value
  //////////////////////////////////////////////////////////////////////////////
  uint64_t size() const;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Utility method to compare underlying key to external key
  //////////////////////////////////////////////////////////////////////////////
  bool sameKey(void const* k, uint32_t kSize) const;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Increase reference count
  //////////////////////////////////////////////////////////////////////////////
  void lease();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Decrease reference count
  //////////////////////////////////////////////////////////////////////////////
  void release();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Checks whether value can be freed (i.e. no references to it)
  //////////////////////////////////////////////////////////////////////////////
  bool isFreeable();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Create a copy of this CachedValue object
  //////////////////////////////////////////////////////////////////////////////
  CachedValue* copy() const;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Construct a CachedValue object from a given key and value
  //////////////////////////////////////////////////////////////////////////////
  static CachedValue* construct(void const* k, uint32_t kSize, void const* v,
                                uint64_t vSize);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief Custom deleter to handle casting issues
  //////////////////////////////////////////////////////////////////////////////
  static void operator delete(void* ptr);
};

// ensure that header size is what we expect
static_assert(sizeof(CachedValue) == 16, "Expected sizeof(CachedValue) == 16.");

};  // end namespace cache
};  // end namespace arangodb

#endif
