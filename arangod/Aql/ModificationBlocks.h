////////////////////////////////////////////////////////////////////////////////
/// DISCLAIMER
///
/// Copyright 2014-2016 ArangoDB GmbH, Cologne, Germany
/// Copyright 2004-2014 triAGENS GmbH, Cologne, Germany
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// Copyright holder is ArangoDB GmbH, Cologne, Germany
///
/// @author Jan Steemann
////////////////////////////////////////////////////////////////////////////////

#ifndef ARANGOD_AQL_MODIFICATION_BLOCKS_H
#define ARANGOD_AQL_MODIFICATION_BLOCKS_H 1

#include "Basics/Common.h"
#include "Aql/ExecutionBlock.h"
#include "Aql/ExecutionNode.h"
#include "Aql/ModificationNodes.h"
#include "Utils/AqlTransaction.h"
#include "VocBase/shaped-json.h"

struct TRI_df_marker_s;
struct TRI_doc_mptr_copy_t;
struct TRI_json_t;

namespace arangodb {
namespace aql {
struct Collection;

class ExecutionEngine;

class ModificationBlock : public ExecutionBlock {
 public:
  ModificationBlock(ExecutionEngine*, ModificationNode const*);

  virtual ~ModificationBlock();

  //////////////////////////////////////////////////////////////////////////////
  /// @brief getSome
  //////////////////////////////////////////////////////////////////////////////

  AqlItemBlock* getSome(size_t atLeast, size_t atMost) override final;

 protected:
  //////////////////////////////////////////////////////////////////////////////
  /// @brief the actual work horse
  //////////////////////////////////////////////////////////////////////////////

  virtual AqlItemBlock* work(std::vector<AqlItemBlock*>&) = 0;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief extract a key from the AqlValue passed
  //////////////////////////////////////////////////////////////////////////////

  int extractKey(AqlValue const&, TRI_document_collection_t const*,
                 std::string&);

  //////////////////////////////////////////////////////////////////////////////
  /// @brief constructs a master pointer from the marker passed
  //////////////////////////////////////////////////////////////////////////////

  void constructMptr(TRI_doc_mptr_copy_t*, TRI_df_marker_s const*) const;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief check whether a shard key value has changed
  //////////////////////////////////////////////////////////////////////////////

  bool isShardKeyChange(struct TRI_json_t const*, struct TRI_json_t const*,
                        bool) const;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief check whether a shard key was set when it must not be set
  //////////////////////////////////////////////////////////////////////////////

  bool isShardKeyError(struct TRI_json_t const*) const;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief process the result of a data-modification operation
  //////////////////////////////////////////////////////////////////////////////

  void handleResult(int, bool, std::string const* errorMessage = nullptr);

 protected:
  //////////////////////////////////////////////////////////////////////////////
  /// @brief output register ($OLD)
  //////////////////////////////////////////////////////////////////////////////

  RegisterId _outRegOld;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief output register ($NEW)
  //////////////////////////////////////////////////////////////////////////////

  RegisterId _outRegNew;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief collection
  //////////////////////////////////////////////////////////////////////////////

  Collection const* _collection;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief whether or not we're a DB server in a cluster
  //////////////////////////////////////////////////////////////////////////////

  bool _isDBServer;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief whether or not the collection uses the default sharding attributes
  //////////////////////////////////////////////////////////////////////////////

  bool _usesDefaultSharding;

  //////////////////////////////////////////////////////////////////////////////
  /// @brief temporary string buffer for extracting system attributes
  //////////////////////////////////////////////////////////////////////////////

  arangodb::basics::StringBuffer _buffer;
};

class RemoveBlock : public ModificationBlock {
 public:
  RemoveBlock(ExecutionEngine*, RemoveNode const*);

  ~RemoveBlock();

 protected:
  //////////////////////////////////////////////////////////////////////////////
  /// @brief the actual work horse for removing data
  //////////////////////////////////////////////////////////////////////////////

  AqlItemBlock* work(std::vector<AqlItemBlock*>&) override final;
};

class InsertBlock : public ModificationBlock {
 public:
  InsertBlock(ExecutionEngine*, InsertNode const*);

  ~InsertBlock();

 protected:
  //////////////////////////////////////////////////////////////////////////////
  /// @brief the actual work horse for inserting data
  //////////////////////////////////////////////////////////////////////////////

  AqlItemBlock* work(std::vector<AqlItemBlock*>&) override final;
};

class UpdateBlock : public ModificationBlock {
 public:
  UpdateBlock(ExecutionEngine*, UpdateNode const*);

  ~UpdateBlock();

 protected:
  //////////////////////////////////////////////////////////////////////////////
  /// @brief the actual work horse for updating data
  //////////////////////////////////////////////////////////////////////////////

  AqlItemBlock* work(std::vector<AqlItemBlock*>&) override final;
};

class ReplaceBlock : public ModificationBlock {
 public:
  ReplaceBlock(ExecutionEngine*, ReplaceNode const*);

  ~ReplaceBlock();

 protected:
  //////////////////////////////////////////////////////////////////////////////
  /// @brief the actual work horse for replacing data
  //////////////////////////////////////////////////////////////////////////////

  AqlItemBlock* work(std::vector<AqlItemBlock*>&) override final;
};

class UpsertBlock : public ModificationBlock {
 public:
  UpsertBlock(ExecutionEngine*, UpsertNode const*);

  ~UpsertBlock();

 protected:
  //////////////////////////////////////////////////////////////////////////////
  /// @brief the actual work horse for updating data
  //////////////////////////////////////////////////////////////////////////////

  AqlItemBlock* work(std::vector<AqlItemBlock*>&) override final;
};

}  // namespace arangodb::aql
}  // namespace arangodb

#endif
