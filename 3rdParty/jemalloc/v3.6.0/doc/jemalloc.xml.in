<?xml version='1.0' encoding='UTF-8'?>
<?xml-stylesheet type="text/xsl"
        href="http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
        "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
]>

<refentry>
  <refentryinfo>
    <title>User Manual</title>
    <productname>jemalloc</productname>
    <releaseinfo role="version">@jemalloc_version@</releaseinfo>
    <authorgroup>
      <author>
        <firstname>Jason</firstname>
        <surname>Evans</surname>
        <personblurb>Author</personblurb>
      </author>
    </authorgroup>
  </refentryinfo>
  <refmeta>
    <refentrytitle>JEMALLOC</refentrytitle>
    <manvolnum>3</manvolnum>
  </refmeta>
  <refnamediv>
    <refdescriptor>jemalloc</refdescriptor>
    <refname>jemalloc</refname>
    <!-- Each refname causes a man page file to be created.  Only if this were
         the system malloc(3) implementation would these files be appropriate.
    <refname>malloc</refname>
    <refname>calloc</refname>
    <refname>posix_memalign</refname>
    <refname>aligned_alloc</refname>
    <refname>realloc</refname>
    <refname>free</refname>
    <refname>mallocx</refname>
    <refname>rallocx</refname>
    <refname>xallocx</refname>
    <refname>sallocx</refname>
    <refname>dallocx</refname>
    <refname>nallocx</refname>
    <refname>mallctl</refname>
    <refname>mallctlnametomib</refname>
    <refname>mallctlbymib</refname>
    <refname>malloc_stats_print</refname>
    <refname>malloc_usable_size</refname>
    <refname>allocm</refname>
    <refname>rallocm</refname>
    <refname>sallocm</refname>
    <refname>dallocm</refname>
    <refname>nallocm</refname>
    -->
    <refpurpose>general purpose memory allocation functions</refpurpose>
  </refnamediv>
  <refsect1 id="library">
    <title>LIBRARY</title>
    <para>This manual describes jemalloc @jemalloc_version@.  More information
    can be found at the <ulink
    url="http://www.canonware.com/jemalloc/">jemalloc website</ulink>.</para>
  </refsect1>
  <refsynopsisdiv>
    <title>SYNOPSIS</title>
    <funcsynopsis>
      <funcsynopsisinfo>#include &lt;<filename class="headerfile">stdlib.h</filename>&gt;
#include &lt;<filename class="headerfile">jemalloc/jemalloc.h</filename>&gt;</funcsynopsisinfo>
      <refsect2>
        <title>Standard API</title>
        <funcprototype>
          <funcdef>void *<function>malloc</function></funcdef>
          <paramdef>size_t <parameter>size</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>void *<function>calloc</function></funcdef>
          <paramdef>size_t <parameter>number</parameter></paramdef>
          <paramdef>size_t <parameter>size</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>int <function>posix_memalign</function></funcdef>
          <paramdef>void **<parameter>ptr</parameter></paramdef>
          <paramdef>size_t <parameter>alignment</parameter></paramdef>
          <paramdef>size_t <parameter>size</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>void *<function>aligned_alloc</function></funcdef>
          <paramdef>size_t <parameter>alignment</parameter></paramdef>
          <paramdef>size_t <parameter>size</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>void *<function>realloc</function></funcdef>
          <paramdef>void *<parameter>ptr</parameter></paramdef>
          <paramdef>size_t <parameter>size</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>void <function>free</function></funcdef>
          <paramdef>void *<parameter>ptr</parameter></paramdef>
        </funcprototype>
      </refsect2>
      <refsect2>
        <title>Non-standard API</title>
        <funcprototype>
          <funcdef>void *<function>mallocx</function></funcdef>
          <paramdef>size_t <parameter>size</parameter></paramdef>
          <paramdef>int <parameter>flags</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>void *<function>rallocx</function></funcdef>
          <paramdef>void *<parameter>ptr</parameter></paramdef>
          <paramdef>size_t <parameter>size</parameter></paramdef>
          <paramdef>int <parameter>flags</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>size_t <function>xallocx</function></funcdef>
          <paramdef>void *<parameter>ptr</parameter></paramdef>
          <paramdef>size_t <parameter>size</parameter></paramdef>
          <paramdef>size_t <parameter>extra</parameter></paramdef>
          <paramdef>int <parameter>flags</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>size_t <function>sallocx</function></funcdef>
          <paramdef>void *<parameter>ptr</parameter></paramdef>
          <paramdef>int <parameter>flags</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>void <function>dallocx</function></funcdef>
          <paramdef>void *<parameter>ptr</parameter></paramdef>
          <paramdef>int <parameter>flags</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>size_t <function>nallocx</function></funcdef>
          <paramdef>size_t <parameter>size</parameter></paramdef>
          <paramdef>int <parameter>flags</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>int <function>mallctl</function></funcdef>
          <paramdef>const char *<parameter>name</parameter></paramdef>
          <paramdef>void *<parameter>oldp</parameter></paramdef>
          <paramdef>size_t *<parameter>oldlenp</parameter></paramdef>
          <paramdef>void *<parameter>newp</parameter></paramdef>
          <paramdef>size_t <parameter>newlen</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>int <function>mallctlnametomib</function></funcdef>
          <paramdef>const char *<parameter>name</parameter></paramdef>
          <paramdef>size_t *<parameter>mibp</parameter></paramdef>
          <paramdef>size_t *<parameter>miblenp</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>int <function>mallctlbymib</function></funcdef>
          <paramdef>const size_t *<parameter>mib</parameter></paramdef>
          <paramdef>size_t <parameter>miblen</parameter></paramdef>
          <paramdef>void *<parameter>oldp</parameter></paramdef>
          <paramdef>size_t *<parameter>oldlenp</parameter></paramdef>
          <paramdef>void *<parameter>newp</parameter></paramdef>
          <paramdef>size_t <parameter>newlen</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>void <function>malloc_stats_print</function></funcdef>
          <paramdef>void <parameter>(*write_cb)</parameter>
            <funcparams>void *, const char *</funcparams>
          </paramdef>
          <paramdef>void *<parameter>cbopaque</parameter></paramdef>
          <paramdef>const char *<parameter>opts</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>size_t <function>malloc_usable_size</function></funcdef>
          <paramdef>const void *<parameter>ptr</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>void <function>(*malloc_message)</function></funcdef>
          <paramdef>void *<parameter>cbopaque</parameter></paramdef>
          <paramdef>const char *<parameter>s</parameter></paramdef>
        </funcprototype>
        <para><type>const char *</type><varname>malloc_conf</varname>;</para>
      </refsect2>
      <refsect2>
      <title>Experimental API</title>
        <funcprototype>
          <funcdef>int <function>allocm</function></funcdef>
          <paramdef>void **<parameter>ptr</parameter></paramdef>
          <paramdef>size_t *<parameter>rsize</parameter></paramdef>
          <paramdef>size_t <parameter>size</parameter></paramdef>
          <paramdef>int <parameter>flags</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>int <function>rallocm</function></funcdef>
          <paramdef>void **<parameter>ptr</parameter></paramdef>
          <paramdef>size_t *<parameter>rsize</parameter></paramdef>
          <paramdef>size_t <parameter>size</parameter></paramdef>
          <paramdef>size_t <parameter>extra</parameter></paramdef>
          <paramdef>int <parameter>flags</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>int <function>sallocm</function></funcdef>
          <paramdef>const void *<parameter>ptr</parameter></paramdef>
          <paramdef>size_t *<parameter>rsize</parameter></paramdef>
          <paramdef>int <parameter>flags</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>int <function>dallocm</function></funcdef>
          <paramdef>void *<parameter>ptr</parameter></paramdef>
          <paramdef>int <parameter>flags</parameter></paramdef>
        </funcprototype>
        <funcprototype>
          <funcdef>int <function>nallocm</function></funcdef>
          <paramdef>size_t *<parameter>rsize</parameter></paramdef>
          <paramdef>size_t <parameter>size</parameter></paramdef>
          <paramdef>int <parameter>flags</parameter></paramdef>
        </funcprototype>
      </refsect2>
    </funcsynopsis>
  </refsynopsisdiv>
  <refsect1 id="description">
    <title>DESCRIPTION</title>
    <refsect2>
      <title>Standard API</title>

      <para>The <function>malloc<parameter/></function> function allocates
      <parameter>size</parameter> bytes of uninitialized memory.  The allocated
      space is suitably aligned (after possible pointer coercion) for storage
      of any type of object.</para>

      <para>The <function>calloc<parameter/></function> function allocates
      space for <parameter>number</parameter> objects, each
      <parameter>size</parameter> bytes in length.  The result is identical to
      calling <function>malloc<parameter/></function> with an argument of
      <parameter>number</parameter> * <parameter>size</parameter>, with the
      exception that the allocated memory is explicitly initialized to zero
      bytes.</para>

      <para>The <function>posix_memalign<parameter/></function> function
      allocates <parameter>size</parameter> bytes of memory such that the
      allocation's base address is an even multiple of
      <parameter>alignment</parameter>, and returns the allocation in the value
      pointed to by <parameter>ptr</parameter>.  The requested
      <parameter>alignment</parameter> must be a power of 2 at least as large
      as <code language="C">sizeof(<type>void *</type>)</code>.</para>

      <para>The <function>aligned_alloc<parameter/></function> function
      allocates <parameter>size</parameter> bytes of memory such that the
      allocation's base address is an even multiple of
      <parameter>alignment</parameter>.  The requested
      <parameter>alignment</parameter> must be a power of 2.  Behavior is
      undefined if <parameter>size</parameter> is not an integral multiple of
      <parameter>alignment</parameter>.</para>

      <para>The <function>realloc<parameter/></function> function changes the
      size of the previously allocated memory referenced by
      <parameter>ptr</parameter> to <parameter>size</parameter> bytes.  The
      contents of the memory are unchanged up to the lesser of the new and old
      sizes.  If the new size is larger, the contents of the newly allocated
      portion of the memory are undefined.  Upon success, the memory referenced
      by <parameter>ptr</parameter> is freed and a pointer to the newly
      allocated memory is returned.  Note that
      <function>realloc<parameter/></function> may move the memory allocation,
      resulting in a different return value than <parameter>ptr</parameter>.
      If <parameter>ptr</parameter> is <constant>NULL</constant>, the
      <function>realloc<parameter/></function> function behaves identically to
      <function>malloc<parameter/></function> for the specified size.</para>

      <para>The <function>free<parameter/></function> function causes the
      allocated memory referenced by <parameter>ptr</parameter> to be made
      available for future allocations.  If <parameter>ptr</parameter> is
      <constant>NULL</constant>, no action occurs.</para>
    </refsect2>
    <refsect2>
      <title>Non-standard API</title>
      <para>The <function>mallocx<parameter/></function>,
      <function>rallocx<parameter/></function>,
      <function>xallocx<parameter/></function>,
      <function>sallocx<parameter/></function>,
      <function>dallocx<parameter/></function>, and
      <function>nallocx<parameter/></function> functions all have a
      <parameter>flags</parameter> argument that can be used to specify
      options.  The functions only check the options that are contextually
      relevant.  Use bitwise or (<code language="C">|</code>) operations to
      specify one or more of the following:
        <variablelist>
          <varlistentry>
            <term><constant>MALLOCX_LG_ALIGN(<parameter>la</parameter>)
            </constant></term>

            <listitem><para>Align the memory allocation to start at an address
            that is a multiple of <code language="C">(1 &lt;&lt;
            <parameter>la</parameter>)</code>.  This macro does not validate
            that <parameter>la</parameter> is within the valid
            range.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><constant>MALLOCX_ALIGN(<parameter>a</parameter>)
            </constant></term>

            <listitem><para>Align the memory allocation to start at an address
            that is a multiple of <parameter>a</parameter>, where
            <parameter>a</parameter> is a power of two.  This macro does not
            validate that <parameter>a</parameter> is a power of 2.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term><constant>MALLOCX_ZERO</constant></term>

            <listitem><para>Initialize newly allocated memory to contain zero
            bytes.  In the growing reallocation case, the real size prior to
            reallocation defines the boundary between untouched bytes and those
            that are initialized to contain zero bytes.  If this macro is
            absent, newly allocated memory is uninitialized.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><constant>MALLOCX_ARENA(<parameter>a</parameter>)
            </constant></term>

            <listitem><para>Use the arena specified by the index
            <parameter>a</parameter> (and by necessity bypass the thread
            cache).  This macro has no effect for huge regions, nor for regions
            that were allocated via an arena other than the one specified.
            This macro does not validate that <parameter>a</parameter>
            specifies an arena index in the valid range.</para></listitem>
          </varlistentry>
        </variablelist>
      </para>

      <para>The <function>mallocx<parameter/></function> function allocates at
      least <parameter>size</parameter> bytes of memory, and returns a pointer
      to the base address of the allocation.  Behavior is undefined if
      <parameter>size</parameter> is <constant>0</constant>, or if request size
      overflows due to size class and/or alignment constraints.</para>

      <para>The <function>rallocx<parameter/></function> function resizes the
      allocation at <parameter>ptr</parameter> to be at least
      <parameter>size</parameter> bytes, and returns a pointer to the base
      address of the resulting allocation, which may or may not have moved from
      its original location.  Behavior is undefined if
      <parameter>size</parameter> is <constant>0</constant>, or if request size
      overflows due to size class and/or alignment constraints.</para>

      <para>The <function>xallocx<parameter/></function> function resizes the
      allocation at <parameter>ptr</parameter> in place to be at least
      <parameter>size</parameter> bytes, and returns the real size of the
      allocation.  If <parameter>extra</parameter> is non-zero, an attempt is
      made to resize the allocation to be at least <code
      language="C">(<parameter>size</parameter> +
      <parameter>extra</parameter>)</code> bytes, though inability to allocate
      the extra byte(s) will not by itself result in failure to resize.
      Behavior is undefined if <parameter>size</parameter> is
      <constant>0</constant>, or if <code
      language="C">(<parameter>size</parameter> + <parameter>extra</parameter>
      &gt; <constant>SIZE_T_MAX</constant>)</code>.</para>

      <para>The <function>sallocx<parameter/></function> function returns the
      real size of the allocation at <parameter>ptr</parameter>.</para>

      <para>The <function>dallocx<parameter/></function> function causes the
      memory referenced by <parameter>ptr</parameter> to be made available for
      future allocations.</para>

      <para>The <function>nallocx<parameter/></function> function allocates no
      memory, but it performs the same size computation as the
      <function>mallocx<parameter/></function> function, and returns the real
      size of the allocation that would result from the equivalent
      <function>mallocx<parameter/></function> function call.  Behavior is
      undefined if <parameter>size</parameter> is <constant>0</constant>, or if
      request size overflows due to size class and/or alignment
      constraints.</para>

      <para>The <function>mallctl<parameter/></function> function provides a
      general interface for introspecting the memory allocator, as well as
      setting modifiable parameters and triggering actions.  The
      period-separated <parameter>name</parameter> argument specifies a
      location in a tree-structured namespace; see the <xref
      linkend="mallctl_namespace" xrefstyle="template:%t"/> section for
      documentation on the tree contents.  To read a value, pass a pointer via
      <parameter>oldp</parameter> to adequate space to contain the value, and a
      pointer to its length via <parameter>oldlenp</parameter>; otherwise pass
      <constant>NULL</constant> and <constant>NULL</constant>.  Similarly, to
      write a value, pass a pointer to the value via
      <parameter>newp</parameter>, and its length via
      <parameter>newlen</parameter>; otherwise pass <constant>NULL</constant>
      and <constant>0</constant>.</para>

      <para>The <function>mallctlnametomib<parameter/></function> function
      provides a way to avoid repeated name lookups for applications that
      repeatedly query the same portion of the namespace, by translating a name
      to a &ldquo;Management Information Base&rdquo; (MIB) that can be passed
      repeatedly to <function>mallctlbymib<parameter/></function>.  Upon
      successful return from <function>mallctlnametomib<parameter/></function>,
      <parameter>mibp</parameter> contains an array of
      <parameter>*miblenp</parameter> integers, where
      <parameter>*miblenp</parameter> is the lesser of the number of components
      in <parameter>name</parameter> and the input value of
      <parameter>*miblenp</parameter>.  Thus it is possible to pass a
      <parameter>*miblenp</parameter> that is smaller than the number of
      period-separated name components, which results in a partial MIB that can
      be used as the basis for constructing a complete MIB.  For name
      components that are integers (e.g. the 2 in
      <link
      linkend="arenas.bin.i.size"><mallctl>arenas.bin.2.size</mallctl></link>),
      the corresponding MIB component will always be that integer.  Therefore,
      it is legitimate to construct code like the following: <programlisting
      language="C"><![CDATA[
unsigned nbins, i;
size_t mib[4];
size_t len, miblen;

len = sizeof(nbins);
mallctl("arenas.nbins", &nbins, &len, NULL, 0);

miblen = 4;
mallctlnametomib("arenas.bin.0.size", mib, &miblen);
for (i = 0; i < nbins; i++) {
	size_t bin_size;

	mib[2] = i;
	len = sizeof(bin_size);
	mallctlbymib(mib, miblen, &bin_size, &len, NULL, 0);
	/* Do something with bin_size... */
}]]></programlisting></para>

      <para>The <function>malloc_stats_print<parameter/></function> function
      writes human-readable summary statistics via the
      <parameter>write_cb</parameter> callback function pointer and
      <parameter>cbopaque</parameter> data passed to
      <parameter>write_cb</parameter>, or
      <function>malloc_message<parameter/></function> if
      <parameter>write_cb</parameter> is <constant>NULL</constant>.  This
      function can be called repeatedly.  General information that never
      changes during execution can be omitted by specifying "g" as a character
      within the <parameter>opts</parameter> string.  Note that
      <function>malloc_message<parameter/></function> uses the
      <function>mallctl*<parameter/></function> functions internally, so
      inconsistent statistics can be reported if multiple threads use these
      functions simultaneously.  If <option>--enable-stats</option> is
      specified during configuration, &ldquo;m&rdquo; and &ldquo;a&rdquo; can
      be specified to omit merged arena and per arena statistics, respectively;
      &ldquo;b&rdquo; and &ldquo;l&rdquo; can be specified to omit per size
      class statistics for bins and large objects, respectively.  Unrecognized
      characters are silently ignored.  Note that thread caching may prevent
      some statistics from being completely up to date, since extra locking
      would be required to merge counters that track thread cache operations.
      </para>

      <para>The <function>malloc_usable_size<parameter/></function> function
      returns the usable size of the allocation pointed to by
      <parameter>ptr</parameter>.  The return value may be larger than the size
      that was requested during allocation.  The
      <function>malloc_usable_size<parameter/></function> function is not a
      mechanism for in-place <function>realloc<parameter/></function>; rather
      it is provided solely as a tool for introspection purposes.  Any
      discrepancy between the requested allocation size and the size reported
      by <function>malloc_usable_size<parameter/></function> should not be
      depended on, since such behavior is entirely implementation-dependent.
      </para>
    </refsect2>
    <refsect2>
      <title>Experimental API</title>
      <para>The experimental API is subject to change or removal without regard
      for backward compatibility.  If <option>--disable-experimental</option>
      is specified during configuration, the experimental API is
      omitted.</para>

      <para>The <function>allocm<parameter/></function>,
      <function>rallocm<parameter/></function>,
      <function>sallocm<parameter/></function>,
      <function>dallocm<parameter/></function>, and
      <function>nallocm<parameter/></function> functions all have a
      <parameter>flags</parameter> argument that can be used to specify
      options.  The functions only check the options that are contextually
      relevant.  Use bitwise or (<code language="C">|</code>) operations to
      specify one or more of the following:
        <variablelist>
          <varlistentry>
            <term><constant>ALLOCM_LG_ALIGN(<parameter>la</parameter>)
            </constant></term>

            <listitem><para>Align the memory allocation to start at an address
            that is a multiple of <code language="C">(1 &lt;&lt;
            <parameter>la</parameter>)</code>.  This macro does not validate
            that <parameter>la</parameter> is within the valid
            range.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><constant>ALLOCM_ALIGN(<parameter>a</parameter>)
            </constant></term>

            <listitem><para>Align the memory allocation to start at an address
            that is a multiple of <parameter>a</parameter>, where
            <parameter>a</parameter> is a power of two.  This macro does not
            validate that <parameter>a</parameter> is a power of 2.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term><constant>ALLOCM_ZERO</constant></term>

            <listitem><para>Initialize newly allocated memory to contain zero
            bytes.  In the growing reallocation case, the real size prior to
            reallocation defines the boundary between untouched bytes and those
            that are initialized to contain zero bytes.  If this macro is
            absent, newly allocated memory is uninitialized.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><constant>ALLOCM_NO_MOVE</constant></term>

            <listitem><para>For reallocation, fail rather than moving the
            object.  This constraint can apply to both growth and
            shrinkage.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><constant>ALLOCM_ARENA(<parameter>a</parameter>)
            </constant></term>

            <listitem><para>Use the arena specified by the index
            <parameter>a</parameter> (and by necessity bypass the thread
            cache).  This macro has no effect for huge regions, nor for regions
            that were allocated via an arena other than the one specified.
            This macro does not validate that <parameter>a</parameter>
            specifies an arena index in the valid range.</para></listitem>
          </varlistentry>
        </variablelist>
      </para>

      <para>The <function>allocm<parameter/></function> function allocates at
      least <parameter>size</parameter> bytes of memory, sets
      <parameter>*ptr</parameter> to the base address of the allocation, and
      sets <parameter>*rsize</parameter> to the real size of the allocation if
      <parameter>rsize</parameter> is not <constant>NULL</constant>.  Behavior
      is undefined if <parameter>size</parameter> is <constant>0</constant>, or
      if request size overflows due to size class and/or alignment
      constraints.</para>

      <para>The <function>rallocm<parameter/></function> function resizes the
      allocation at <parameter>*ptr</parameter> to be at least
      <parameter>size</parameter> bytes, sets <parameter>*ptr</parameter> to
      the base address of the allocation if it moved, and sets
      <parameter>*rsize</parameter> to the real size of the allocation if
      <parameter>rsize</parameter> is not <constant>NULL</constant>.  If
      <parameter>extra</parameter> is non-zero, an attempt is made to resize
      the allocation to be at least <code
      language="C">(<parameter>size</parameter> +
      <parameter>extra</parameter>)</code> bytes, though inability to allocate
      the extra byte(s) will not by itself result in failure.  Behavior is
      undefined if <parameter>size</parameter> is <constant>0</constant>, if
      request size overflows due to size class and/or alignment constraints, or
      if <code language="C">(<parameter>size</parameter> +
      <parameter>extra</parameter> &gt;
      <constant>SIZE_T_MAX</constant>)</code>.</para>

      <para>The <function>sallocm<parameter/></function> function sets
      <parameter>*rsize</parameter> to the real size of the allocation.</para>

      <para>The <function>dallocm<parameter/></function> function causes the
      memory referenced by <parameter>ptr</parameter> to be made available for
      future allocations.</para>

      <para>The <function>nallocm<parameter/></function> function allocates no
      memory, but it performs the same size computation as the
      <function>allocm<parameter/></function> function, and if
      <parameter>rsize</parameter> is not <constant>NULL</constant> it sets
      <parameter>*rsize</parameter> to the real size of the allocation that
      would result from the equivalent <function>allocm<parameter/></function>
      function call.  Behavior is undefined if <parameter>size</parameter> is
      <constant>0</constant>, or if request size overflows due to size class
      and/or alignment constraints.</para>
    </refsect2>
  </refsect1>
  <refsect1 id="tuning">
    <title>TUNING</title>
    <para>Once, when the first call is made to one of the memory allocation
    routines, the allocator initializes its internals based in part on various
    options that can be specified at compile- or run-time.</para>

    <para>The string pointed to by the global variable
    <varname>malloc_conf</varname>, the &ldquo;name&rdquo; of the file
    referenced by the symbolic link named <filename
    class="symlink">/etc/malloc.conf</filename>, and the value of the
    environment variable <envar>MALLOC_CONF</envar>, will be interpreted, in
    that order, from left to right as options.  Note that
    <varname>malloc_conf</varname> may be read before
    <function>main<parameter/></function> is entered, so the declaration of
    <varname>malloc_conf</varname> should specify an initializer that contains
    the final value to be read by jemalloc.  <varname>malloc_conf</varname> is
    a compile-time setting, whereas <filename
    class="symlink">/etc/malloc.conf</filename> and <envar>MALLOC_CONF</envar>
    can be safely set any time prior to program invocation.</para>

    <para>An options string is a comma-separated list of option:value pairs.
    There is one key corresponding to each <link
    linkend="opt.abort"><mallctl>opt.*</mallctl></link> mallctl (see the <xref
    linkend="mallctl_namespace" xrefstyle="template:%t"/> section for options
    documentation).  For example, <literal>abort:true,narenas:1</literal> sets
    the <link linkend="opt.abort"><mallctl>opt.abort</mallctl></link> and <link
    linkend="opt.narenas"><mallctl>opt.narenas</mallctl></link> options.  Some
    options have boolean values (true/false), others have integer values (base
    8, 10, or 16, depending on prefix), and yet others have raw string
    values.</para>
  </refsect1>
  <refsect1 id="implementation_notes">
    <title>IMPLEMENTATION NOTES</title>
    <para>Traditionally, allocators have used
    <citerefentry><refentrytitle>sbrk</refentrytitle>
    <manvolnum>2</manvolnum></citerefentry> to obtain memory, which is
    suboptimal for several reasons, including race conditions, increased
    fragmentation, and artificial limitations on maximum usable memory.  If
    <option>--enable-dss</option> is specified during configuration, this
    allocator uses both <citerefentry><refentrytitle>mmap</refentrytitle>
    <manvolnum>2</manvolnum></citerefentry> and
    <citerefentry><refentrytitle>sbrk</refentrytitle>
    <manvolnum>2</manvolnum></citerefentry>, in that order of preference;
    otherwise only <citerefentry><refentrytitle>mmap</refentrytitle>
    <manvolnum>2</manvolnum></citerefentry> is used.</para>

    <para>This allocator uses multiple arenas in order to reduce lock
    contention for threaded programs on multi-processor systems.  This works
    well with regard to threading scalability, but incurs some costs.  There is
    a small fixed per-arena overhead, and additionally, arenas manage memory
    completely independently of each other, which means a small fixed increase
    in overall memory fragmentation.  These overheads are not generally an
    issue, given the number of arenas normally used.  Note that using
    substantially more arenas than the default is not likely to improve
    performance, mainly due to reduced cache performance.  However, it may make
    sense to reduce the number of arenas if an application does not make much
    use of the allocation functions.</para>

    <para>In addition to multiple arenas, unless
    <option>--disable-tcache</option> is specified during configuration, this
    allocator supports thread-specific caching for small and large objects, in
    order to make it possible to completely avoid synchronization for most
    allocation requests.  Such caching allows very fast allocation in the
    common case, but it increases memory usage and fragmentation, since a
    bounded number of objects can remain allocated in each thread cache.</para>

    <para>Memory is conceptually broken into equal-sized chunks, where the
    chunk size is a power of two that is greater than the page size.  Chunks
    are always aligned to multiples of the chunk size.  This alignment makes it
    possible to find metadata for user objects very quickly.</para>

    <para>User objects are broken into three categories according to size:
    small, large, and huge.  Small objects are smaller than one page.  Large
    objects are smaller than the chunk size.  Huge objects are a multiple of
    the chunk size.  Small and large objects are managed by arenas; huge
    objects are managed separately in a single data structure that is shared by
    all threads.  Huge objects are used by applications infrequently enough
    that this single data structure is not a scalability issue.</para>

    <para>Each chunk that is managed by an arena tracks its contents as runs of
    contiguous pages (unused, backing a set of small objects, or backing one
    large object).  The combination of chunk alignment and chunk page maps
    makes it possible to determine all metadata regarding small and large
    allocations in constant time.</para>

    <para>Small objects are managed in groups by page runs.  Each run maintains
    a frontier and free list to track which regions are in use.  Allocation
    requests that are no more than half the quantum (8 or 16, depending on
    architecture) are rounded up to the nearest power of two that is at least
    <code language="C">sizeof(<type>double</type>)</code>.  All other small
    object size classes are multiples of the quantum, spaced such that internal
    fragmentation is limited to approximately 25% for all but the smallest size
    classes.  Allocation requests that are larger than the maximum small size
    class, but small enough to fit in an arena-managed chunk (see the <link
    linkend="opt.lg_chunk"><mallctl>opt.lg_chunk</mallctl></link> option), are
    rounded up to the nearest run size.  Allocation requests that are too large
    to fit in an arena-managed chunk are rounded up to the nearest multiple of
    the chunk size.</para>

    <para>Allocations are packed tightly together, which can be an issue for
    multi-threaded applications.  If you need to assure that allocations do not
    suffer from cacheline sharing, round your allocation requests up to the
    nearest multiple of the cacheline size, or specify cacheline alignment when
    allocating.</para>

    <para>Assuming 4 MiB chunks, 4 KiB pages, and a 16-byte quantum on a 64-bit
    system, the size classes in each category are as shown in <xref
    linkend="size_classes" xrefstyle="template:Table %n"/>.</para>

    <table xml:id="size_classes" frame="all">
      <title>Size classes</title>
      <tgroup cols="3" colsep="1" rowsep="1">
      <colspec colname="c1" align="left"/>
      <colspec colname="c2" align="right"/>
      <colspec colname="c3" align="left"/>
      <thead>
        <row>
          <entry>Category</entry>
          <entry>Spacing</entry>
          <entry>Size</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry morerows="6">Small</entry>
          <entry>lg</entry>
          <entry>[8]</entry>
        </row>
        <row>
          <entry>16</entry>
          <entry>[16, 32, 48, ..., 128]</entry>
        </row>
        <row>
          <entry>32</entry>
          <entry>[160, 192, 224, 256]</entry>
        </row>
        <row>
          <entry>64</entry>
          <entry>[320, 384, 448, 512]</entry>
        </row>
        <row>
          <entry>128</entry>
          <entry>[640, 768, 896, 1024]</entry>
        </row>
        <row>
          <entry>256</entry>
          <entry>[1280, 1536, 1792, 2048]</entry>
        </row>
        <row>
          <entry>512</entry>
          <entry>[2560, 3072, 3584]</entry>
        </row>
        <row>
          <entry>Large</entry>
          <entry>4 KiB</entry>
          <entry>[4 KiB, 8 KiB, 12 KiB, ..., 4072 KiB]</entry>
        </row>
        <row>
          <entry>Huge</entry>
          <entry>4 MiB</entry>
          <entry>[4 MiB, 8 MiB, 12 MiB, ...]</entry>
        </row>
      </tbody>
      </tgroup>
    </table>
  </refsect1>
  <refsect1 id="mallctl_namespace">
    <title>MALLCTL NAMESPACE</title>
    <para>The following names are defined in the namespace accessible via the
    <function>mallctl*<parameter/></function> functions.  Value types are
    specified in parentheses, their readable/writable statuses are encoded as
    <literal>rw</literal>, <literal>r-</literal>, <literal>-w</literal>, or
    <literal>--</literal>, and required build configuration flags follow, if
    any.  A name element encoded as <literal>&lt;i&gt;</literal> or
    <literal>&lt;j&gt;</literal> indicates an integer component, where the
    integer varies from 0 to some upper value that must be determined via
    introspection.  In the case of <mallctl>stats.arenas.&lt;i&gt;.*</mallctl>,
    <literal>&lt;i&gt;</literal> equal to <link
    linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link> can be
    used to access the summation of statistics from all arenas.  Take special
    note of the <link linkend="epoch"><mallctl>epoch</mallctl></link> mallctl,
    which controls refreshing of cached dynamic statistics.</para>

    <variablelist>
      <varlistentry id="version">
        <term>
          <mallctl>version</mallctl>
          (<type>const char *</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Return the jemalloc version string.</para></listitem>
      </varlistentry>

      <varlistentry id="epoch">
        <term>
          <mallctl>epoch</mallctl>
          (<type>uint64_t</type>)
          <literal>rw</literal>
        </term>
        <listitem><para>If a value is passed in, refresh the data from which
        the <function>mallctl*<parameter/></function> functions report values,
        and increment the epoch.  Return the current epoch.  This is useful for
        detecting whether another thread caused a refresh.</para></listitem>
      </varlistentry>

      <varlistentry id="config.debug">
        <term>
          <mallctl>config.debug</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--enable-debug</option> was specified during
        build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.dss">
        <term>
          <mallctl>config.dss</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--enable-dss</option> was specified during
        build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.fill">
        <term>
          <mallctl>config.fill</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--enable-fill</option> was specified during
        build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.lazy_lock">
        <term>
          <mallctl>config.lazy_lock</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--enable-lazy-lock</option> was specified
        during build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.mremap">
        <term>
          <mallctl>config.mremap</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--enable-mremap</option> was specified during
        build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.munmap">
        <term>
          <mallctl>config.munmap</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--enable-munmap</option> was specified during
        build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.prof">
        <term>
          <mallctl>config.prof</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--enable-prof</option> was specified during
        build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.prof_libgcc">
        <term>
          <mallctl>config.prof_libgcc</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--disable-prof-libgcc</option> was not
        specified during build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.prof_libunwind">
        <term>
          <mallctl>config.prof_libunwind</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--enable-prof-libunwind</option> was specified
        during build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.stats">
        <term>
          <mallctl>config.stats</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--enable-stats</option> was specified during
        build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.tcache">
        <term>
          <mallctl>config.tcache</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--disable-tcache</option> was not specified
        during build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.tls">
        <term>
          <mallctl>config.tls</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--disable-tls</option> was not specified during
        build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.utrace">
        <term>
          <mallctl>config.utrace</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--enable-utrace</option> was specified during
        build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.valgrind">
        <term>
          <mallctl>config.valgrind</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--enable-valgrind</option> was specified during
        build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="config.xmalloc">
        <term>
          <mallctl>config.xmalloc</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para><option>--enable-xmalloc</option> was specified during
        build configuration.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.abort">
        <term>
          <mallctl>opt.abort</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Abort-on-warning enabled/disabled.  If true, most
        warnings are fatal.  The process will call
        <citerefentry><refentrytitle>abort</refentrytitle>
        <manvolnum>3</manvolnum></citerefentry> in these cases.  This option is
        disabled by default unless <option>--enable-debug</option> is
        specified during configuration, in which case it is enabled by default.
        </para></listitem>
      </varlistentry>

      <varlistentry id="opt.dss">
        <term>
          <mallctl>opt.dss</mallctl>
          (<type>const char *</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>dss (<citerefentry><refentrytitle>sbrk</refentrytitle>
        <manvolnum>2</manvolnum></citerefentry>) allocation precedence as
        related to <citerefentry><refentrytitle>mmap</refentrytitle>
        <manvolnum>2</manvolnum></citerefentry> allocation.  The following
        settings are supported: &ldquo;disabled&rdquo;, &ldquo;primary&rdquo;,
        and &ldquo;secondary&rdquo;.  The default is &ldquo;secondary&rdquo; if
        <link linkend="config.dss"><mallctl>config.dss</mallctl></link> is
        true, &ldquo;disabled&rdquo; otherwise.
        </para></listitem>
      </varlistentry>

      <varlistentry id="opt.lg_chunk">
        <term>
          <mallctl>opt.lg_chunk</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Virtual memory chunk size (log base 2).  If a chunk
        size outside the supported size range is specified, the size is
        silently clipped to the minimum/maximum supported size.  The default
        chunk size is 4 MiB (2^22).
        </para></listitem>
      </varlistentry>

      <varlistentry id="opt.narenas">
        <term>
          <mallctl>opt.narenas</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Maximum number of arenas to use for automatic
        multiplexing of threads and arenas.  The default is four times the
        number of CPUs, or one if there is a single CPU.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.lg_dirty_mult">
        <term>
          <mallctl>opt.lg_dirty_mult</mallctl>
          (<type>ssize_t</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Per-arena minimum ratio (log base 2) of active to dirty
        pages.  Some dirty unused pages may be allowed to accumulate, within
        the limit set by the ratio (or one chunk worth of dirty pages,
        whichever is greater), before informing the kernel about some of those
        pages via <citerefentry><refentrytitle>madvise</refentrytitle>
        <manvolnum>2</manvolnum></citerefentry> or a similar system call.  This
        provides the kernel with sufficient information to recycle dirty pages
        if physical memory becomes scarce and the pages remain unused.  The
        default minimum ratio is 8:1 (2^3:1); an option value of -1 will
        disable dirty page purging.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.stats_print">
        <term>
          <mallctl>opt.stats_print</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Enable/disable statistics printing at exit.  If
        enabled, the <function>malloc_stats_print<parameter/></function>
        function is called at program exit via an
        <citerefentry><refentrytitle>atexit</refentrytitle>
        <manvolnum>3</manvolnum></citerefentry> function.  If
        <option>--enable-stats</option> is specified during configuration, this
        has the potential to cause deadlock for a multi-threaded process that
        exits while one or more threads are executing in the memory allocation
        functions.  Therefore, this option should only be used with care; it is
        primarily intended as a performance tuning aid during application
        development.  This option is disabled by default.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.junk">
        <term>
          <mallctl>opt.junk</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
          [<option>--enable-fill</option>]
        </term>
        <listitem><para>Junk filling enabled/disabled.  If enabled, each byte
        of uninitialized allocated memory will be initialized to
        <literal>0xa5</literal>.  All deallocated memory will be initialized to
        <literal>0x5a</literal>.  This is intended for debugging and will
        impact performance negatively.  This option is disabled by default
        unless <option>--enable-debug</option> is specified during
        configuration, in which case it is enabled by default unless running
        inside <ulink
        url="http://valgrind.org/">Valgrind</ulink>.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.quarantine">
        <term>
          <mallctl>opt.quarantine</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-fill</option>]
        </term>
        <listitem><para>Per thread quarantine size in bytes.  If non-zero, each
        thread maintains a FIFO object quarantine that stores up to the
        specified number of bytes of memory.  The quarantined memory is not
        freed until it is released from quarantine, though it is immediately
        junk-filled if the <link
        linkend="opt.junk"><mallctl>opt.junk</mallctl></link> option is
        enabled.  This feature is of particular use in combination with <ulink
        url="http://valgrind.org/">Valgrind</ulink>, which can detect attempts
        to access quarantined objects.  This is intended for debugging and will
        impact performance negatively.  The default quarantine size is 0 unless
        running inside Valgrind, in which case the default is 16
        MiB.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.redzone">
        <term>
          <mallctl>opt.redzone</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
          [<option>--enable-fill</option>]
        </term>
        <listitem><para>Redzones enabled/disabled.  If enabled, small
        allocations have redzones before and after them.  Furthermore, if the
        <link linkend="opt.junk"><mallctl>opt.junk</mallctl></link> option is
        enabled, the redzones are checked for corruption during deallocation.
        However, the primary intended purpose of this feature is to be used in
        combination with <ulink url="http://valgrind.org/">Valgrind</ulink>,
        which needs redzones in order to do effective buffer overflow/underflow
        detection.  This option is intended for debugging and will impact
        performance negatively.  This option is disabled by
        default unless running inside Valgrind.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.zero">
        <term>
          <mallctl>opt.zero</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
          [<option>--enable-fill</option>]
        </term>
        <listitem><para>Zero filling enabled/disabled.  If enabled, each byte
        of uninitialized allocated memory will be initialized to 0.  Note that
        this initialization only happens once for each byte, so
        <function>realloc<parameter/></function>,
        <function>rallocx<parameter/></function> and
        <function>rallocm<parameter/></function> calls do not zero memory that
        was previously allocated.  This is intended for debugging and will
        impact performance negatively.  This option is disabled by default.
        </para></listitem>
      </varlistentry>

      <varlistentry id="opt.utrace">
        <term>
          <mallctl>opt.utrace</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
          [<option>--enable-utrace</option>]
        </term>
        <listitem><para>Allocation tracing based on
        <citerefentry><refentrytitle>utrace</refentrytitle>
        <manvolnum>2</manvolnum></citerefentry> enabled/disabled.  This option
        is disabled by default.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.valgrind">
        <term>
          <mallctl>opt.valgrind</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
          [<option>--enable-valgrind</option>]
        </term>
        <listitem><para><ulink url="http://valgrind.org/">Valgrind</ulink>
        support enabled/disabled.  This option is vestigal because jemalloc
        auto-detects whether it is running inside Valgrind.  This option is
        disabled by default, unless running inside Valgrind.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.xmalloc">
        <term>
          <mallctl>opt.xmalloc</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
          [<option>--enable-xmalloc</option>]
        </term>
        <listitem><para>Abort-on-out-of-memory enabled/disabled.  If enabled,
        rather than returning failure for any allocation function, display a
        diagnostic message on <constant>STDERR_FILENO</constant> and cause the
        program to drop core (using
        <citerefentry><refentrytitle>abort</refentrytitle>
        <manvolnum>3</manvolnum></citerefentry>).  If an application is
        designed to depend on this behavior, set the option at compile time by
        including the following in the source code:
        <programlisting language="C"><![CDATA[
malloc_conf = "xmalloc:true";]]></programlisting>
        This option is disabled by default.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.tcache">
        <term>
          <mallctl>opt.tcache</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
          [<option>--enable-tcache</option>]
        </term>
        <listitem><para>Thread-specific caching enabled/disabled.  When there
        are multiple threads, each thread uses a thread-specific cache for
        objects up to a certain size.  Thread-specific caching allows many
        allocations to be satisfied without performing any thread
        synchronization, at the cost of increased memory use.  See the
        <link
        linkend="opt.lg_tcache_max"><mallctl>opt.lg_tcache_max</mallctl></link>
        option for related tuning information.  This option is enabled by
        default unless running inside <ulink
        url="http://valgrind.org/">Valgrind</ulink>.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.lg_tcache_max">
        <term>
          <mallctl>opt.lg_tcache_max</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-tcache</option>]
        </term>
        <listitem><para>Maximum size class (log base 2) to cache in the
        thread-specific cache.  At a minimum, all small size classes are
        cached, and at a maximum all large size classes are cached.  The
        default maximum is 32 KiB (2^15).</para></listitem>
      </varlistentry>

      <varlistentry id="opt.prof">
        <term>
          <mallctl>opt.prof</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
          [<option>--enable-prof</option>]
        </term>
        <listitem><para>Memory profiling enabled/disabled.  If enabled, profile
        memory allocation activity.  See the <link
        linkend="opt.prof_active"><mallctl>opt.prof_active</mallctl></link>
        option for on-the-fly activation/deactivation.  See the <link
        linkend="opt.lg_prof_sample"><mallctl>opt.lg_prof_sample</mallctl></link>
        option for probabilistic sampling control.  See the <link
        linkend="opt.prof_accum"><mallctl>opt.prof_accum</mallctl></link>
        option for control of cumulative sample reporting.  See the <link
        linkend="opt.lg_prof_interval"><mallctl>opt.lg_prof_interval</mallctl></link>
        option for information on interval-triggered profile dumping, the <link
        linkend="opt.prof_gdump"><mallctl>opt.prof_gdump</mallctl></link>
        option for information on high-water-triggered profile dumping, and the
        <link linkend="opt.prof_final"><mallctl>opt.prof_final</mallctl></link>
        option for final profile dumping.  Profile output is compatible with
        the included <command>pprof</command> Perl script, which originates
        from the <ulink url="http://code.google.com/p/gperftools/">gperftools
        package</ulink>.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.prof_prefix">
        <term>
          <mallctl>opt.prof_prefix</mallctl>
          (<type>const char *</type>)
          <literal>r-</literal>
          [<option>--enable-prof</option>]
        </term>
        <listitem><para>Filename prefix for profile dumps.  If the prefix is
        set to the empty string, no automatic dumps will occur; this is
        primarily useful for disabling the automatic final heap dump (which
        also disables leak reporting, if enabled).  The default prefix is
        <filename>jeprof</filename>.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.prof_active">
        <term>
          <mallctl>opt.prof_active</mallctl>
          (<type>bool</type>)
          <literal>rw</literal>
          [<option>--enable-prof</option>]
        </term>
        <listitem><para>Profiling activated/deactivated.  This is a secondary
        control mechanism that makes it possible to start the application with
        profiling enabled (see the <link
        linkend="opt.prof"><mallctl>opt.prof</mallctl></link> option) but
        inactive, then toggle profiling at any time during program execution
        with the <link
        linkend="prof.active"><mallctl>prof.active</mallctl></link> mallctl.
        This option is enabled by default.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.lg_prof_sample">
        <term>
          <mallctl>opt.lg_prof_sample</mallctl>
          (<type>ssize_t</type>)
          <literal>r-</literal>
          [<option>--enable-prof</option>]
        </term>
        <listitem><para>Average interval (log base 2) between allocation
        samples, as measured in bytes of allocation activity.  Increasing the
        sampling interval decreases profile fidelity, but also decreases the
        computational overhead.  The default sample interval is 512 KiB (2^19
        B).</para></listitem>
      </varlistentry>

      <varlistentry id="opt.prof_accum">
        <term>
          <mallctl>opt.prof_accum</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
          [<option>--enable-prof</option>]
        </term>
        <listitem><para>Reporting of cumulative object/byte counts in profile
        dumps enabled/disabled.  If this option is enabled, every unique
        backtrace must be stored for the duration of execution.  Depending on
        the application, this can impose a large memory overhead, and the
        cumulative counts are not always of interest.  This option is disabled
        by default.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.lg_prof_interval">
        <term>
          <mallctl>opt.lg_prof_interval</mallctl>
          (<type>ssize_t</type>)
          <literal>r-</literal>
          [<option>--enable-prof</option>]
        </term>
        <listitem><para>Average interval (log base 2) between memory profile
        dumps, as measured in bytes of allocation activity.  The actual
        interval between dumps may be sporadic because decentralized allocation
        counters are used to avoid synchronization bottlenecks.  Profiles are
        dumped to files named according to the pattern
        <filename>&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.i&lt;iseq&gt;.heap</filename>,
        where <literal>&lt;prefix&gt;</literal> is controlled by the
        <link
        linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
        option.  By default, interval-triggered profile dumping is disabled
        (encoded as -1).
        </para></listitem>
      </varlistentry>

      <varlistentry id="opt.prof_gdump">
        <term>
          <mallctl>opt.prof_gdump</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
          [<option>--enable-prof</option>]
        </term>
        <listitem><para>Trigger a memory profile dump every time the total
        virtual memory exceeds the previous maximum.  Profiles are dumped to
        files named according to the pattern
        <filename>&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.u&lt;useq&gt;.heap</filename>,
        where <literal>&lt;prefix&gt;</literal> is controlled by the <link
        linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
        option.  This option is disabled by default.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.prof_final">
        <term>
          <mallctl>opt.prof_final</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
          [<option>--enable-prof</option>]
        </term>
        <listitem><para>Use an
        <citerefentry><refentrytitle>atexit</refentrytitle>
        <manvolnum>3</manvolnum></citerefentry> function to dump final memory
        usage to a file named according to the pattern
        <filename>&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.f.heap</filename>,
        where <literal>&lt;prefix&gt;</literal> is controlled by the <link
        linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
        option.  This option is enabled by default.</para></listitem>
      </varlistentry>

      <varlistentry id="opt.prof_leak">
        <term>
          <mallctl>opt.prof_leak</mallctl>
          (<type>bool</type>)
          <literal>r-</literal>
          [<option>--enable-prof</option>]
        </term>
        <listitem><para>Leak reporting enabled/disabled.  If enabled, use an
        <citerefentry><refentrytitle>atexit</refentrytitle>
        <manvolnum>3</manvolnum></citerefentry> function to report memory leaks
        detected by allocation sampling.  See the
        <link linkend="opt.prof"><mallctl>opt.prof</mallctl></link> option for
        information on analyzing heap profile output.  This option is disabled
        by default.</para></listitem>
      </varlistentry>

      <varlistentry id="thread.arena">
        <term>
          <mallctl>thread.arena</mallctl>
          (<type>unsigned</type>)
          <literal>rw</literal>
        </term>
        <listitem><para>Get or set the arena associated with the calling
        thread.  If the specified arena was not initialized beforehand (see the
        <link
        linkend="arenas.initialized"><mallctl>arenas.initialized</mallctl></link>
        mallctl), it will be automatically initialized as a side effect of
        calling this interface.</para></listitem>
      </varlistentry>

      <varlistentry id="thread.allocated">
        <term>
          <mallctl>thread.allocated</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Get the total number of bytes ever allocated by the
        calling thread.  This counter has the potential to wrap around; it is
        up to the application to appropriately interpret the counter in such
        cases.</para></listitem>
      </varlistentry>

      <varlistentry id="thread.allocatedp">
        <term>
          <mallctl>thread.allocatedp</mallctl>
          (<type>uint64_t *</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Get a pointer to the the value that is returned by the
        <link
        linkend="thread.allocated"><mallctl>thread.allocated</mallctl></link>
        mallctl.  This is useful for avoiding the overhead of repeated
        <function>mallctl*<parameter/></function> calls.</para></listitem>
      </varlistentry>

      <varlistentry id="thread.deallocated">
        <term>
          <mallctl>thread.deallocated</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Get the total number of bytes ever deallocated by the
        calling thread.  This counter has the potential to wrap around; it is
        up to the application to appropriately interpret the counter in such
        cases.</para></listitem>
      </varlistentry>

      <varlistentry id="thread.deallocatedp">
        <term>
          <mallctl>thread.deallocatedp</mallctl>
          (<type>uint64_t *</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Get a pointer to the the value that is returned by the
        <link
        linkend="thread.deallocated"><mallctl>thread.deallocated</mallctl></link>
        mallctl.  This is useful for avoiding the overhead of repeated
        <function>mallctl*<parameter/></function> calls.</para></listitem>
      </varlistentry>

      <varlistentry id="thread.tcache.enabled">
        <term>
          <mallctl>thread.tcache.enabled</mallctl>
          (<type>bool</type>)
          <literal>rw</literal>
          [<option>--enable-tcache</option>]
        </term>
        <listitem><para>Enable/disable calling thread's tcache.  The tcache is
        implicitly flushed as a side effect of becoming
        disabled (see <link
        lenkend="thread.tcache.flush"><mallctl>thread.tcache.flush</mallctl></link>).
        </para></listitem>
      </varlistentry>

      <varlistentry id="thread.tcache.flush">
        <term>
          <mallctl>thread.tcache.flush</mallctl>
          (<type>void</type>)
          <literal>--</literal>
          [<option>--enable-tcache</option>]
        </term>
        <listitem><para>Flush calling thread's tcache.  This interface releases
        all cached objects and internal data structures associated with the
        calling thread's thread-specific cache.  Ordinarily, this interface
        need not be called, since automatic periodic incremental garbage
        collection occurs, and the thread cache is automatically discarded when
        a thread exits.  However, garbage collection is triggered by allocation
        activity, so it is possible for a thread that stops
        allocating/deallocating to retain its cache indefinitely, in which case
        the developer may find manual flushing useful.</para></listitem>
      </varlistentry>

      <varlistentry id="arena.i.purge">
        <term>
          <mallctl>arena.&lt;i&gt;.purge</mallctl>
          (<type>unsigned</type>)
          <literal>--</literal>
        </term>
        <listitem><para>Purge unused dirty pages for arena &lt;i&gt;, or for
        all arenas if &lt;i&gt; equals <link
        linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>.
        </para></listitem>
      </varlistentry>

      <varlistentry id="arena.i.dss">
        <term>
          <mallctl>arena.&lt;i&gt;.dss</mallctl>
          (<type>const char *</type>)
          <literal>rw</literal>
        </term>
        <listitem><para>Set the precedence of dss allocation as related to mmap
        allocation for arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals
        <link
        linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>.  Note
        that even during huge allocation this setting is read from the arena
        that would be chosen for small or large allocation so that applications
        can depend on consistent dss versus mmap allocation regardless of
        allocation size.  See <link
        linkend="opt.dss"><mallctl>opt.dss</mallctl></link> for supported
        settings.
        </para></listitem>
      </varlistentry>

      <varlistentry id="arenas.narenas">
        <term>
          <mallctl>arenas.narenas</mallctl>
          (<type>unsigned</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Current limit on number of arenas.</para></listitem>
      </varlistentry>

      <varlistentry id="arenas.initialized">
        <term>
          <mallctl>arenas.initialized</mallctl>
          (<type>bool *</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>An array of <link
        linkend="arenas.narenas"><mallctl>arenas.narenas</mallctl></link>
        booleans.  Each boolean indicates whether the corresponding arena is
        initialized.</para></listitem>
      </varlistentry>

      <varlistentry id="arenas.quantum">
        <term>
          <mallctl>arenas.quantum</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Quantum size.</para></listitem>
      </varlistentry>

      <varlistentry id="arenas.page">
        <term>
          <mallctl>arenas.page</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Page size.</para></listitem>
      </varlistentry>

      <varlistentry id="arenas.tcache_max">
        <term>
          <mallctl>arenas.tcache_max</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-tcache</option>]
        </term>
        <listitem><para>Maximum thread-cached size class.</para></listitem>
      </varlistentry>

      <varlistentry id="arenas.nbins">
        <term>
          <mallctl>arenas.nbins</mallctl>
          (<type>unsigned</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Number of bin size classes.</para></listitem>
      </varlistentry>

      <varlistentry id="arenas.nhbins">
        <term>
          <mallctl>arenas.nhbins</mallctl>
          (<type>unsigned</type>)
          <literal>r-</literal>
          [<option>--enable-tcache</option>]
        </term>
        <listitem><para>Total number of thread cache bin size
        classes.</para></listitem>
      </varlistentry>

      <varlistentry id="arenas.bin.i.size">
        <term>
          <mallctl>arenas.bin.&lt;i&gt;.size</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Maximum size supported by size class.</para></listitem>
      </varlistentry>

      <varlistentry id="arenas.bin.i.nregs">
        <term>
          <mallctl>arenas.bin.&lt;i&gt;.nregs</mallctl>
          (<type>uint32_t</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Number of regions per page run.</para></listitem>
      </varlistentry>

      <varlistentry id="arenas.bin.i.run_size">
        <term>
          <mallctl>arenas.bin.&lt;i&gt;.run_size</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Number of bytes per page run.</para></listitem>
      </varlistentry>

      <varlistentry id="arenas.nlruns">
        <term>
          <mallctl>arenas.nlruns</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Total number of large size classes.</para></listitem>
      </varlistentry>

      <varlistentry id="arenas.lrun.i.size">
        <term>
          <mallctl>arenas.lrun.&lt;i&gt;.size</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Maximum size supported by this large size
        class.</para></listitem>
      </varlistentry>

      <varlistentry id="arenas.purge">
        <term>
          <mallctl>arenas.purge</mallctl>
          (<type>unsigned</type>)
          <literal>-w</literal>
        </term>
        <listitem><para>Purge unused dirty pages for the specified arena, or
        for all arenas if none is specified.</para></listitem>
      </varlistentry>

      <varlistentry id="arenas.extend">
        <term>
          <mallctl>arenas.extend</mallctl>
          (<type>unsigned</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Extend the array of arenas by appending a new arena,
        and returning the new arena index.</para></listitem>
      </varlistentry>

      <varlistentry id="prof.active">
        <term>
          <mallctl>prof.active</mallctl>
          (<type>bool</type>)
          <literal>rw</literal>
          [<option>--enable-prof</option>]
        </term>
        <listitem><para>Control whether sampling is currently active.  See the
        <link
        linkend="opt.prof_active"><mallctl>opt.prof_active</mallctl></link>
        option for additional information.
        </para></listitem>
      </varlistentry>

      <varlistentry id="prof.dump">
        <term>
          <mallctl>prof.dump</mallctl>
          (<type>const char *</type>)
          <literal>-w</literal>
          [<option>--enable-prof</option>]
        </term>
        <listitem><para>Dump a memory profile to the specified file, or if NULL
        is specified, to a file according to the pattern
        <filename>&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.m&lt;mseq&gt;.heap</filename>,
        where <literal>&lt;prefix&gt;</literal> is controlled by the
        <link
        linkend="opt.prof_prefix"><mallctl>opt.prof_prefix</mallctl></link>
        option.</para></listitem>
      </varlistentry>

      <varlistentry id="prof.interval">
        <term>
          <mallctl>prof.interval</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-prof</option>]
        </term>
        <listitem><para>Average number of bytes allocated between
        inverval-based profile dumps.  See the
        <link
        linkend="opt.lg_prof_interval"><mallctl>opt.lg_prof_interval</mallctl></link>
        option for additional information.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.cactive">
        <term>
          <mallctl>stats.cactive</mallctl>
          (<type>size_t *</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Pointer to a counter that contains an approximate count
        of the current number of bytes in active pages.  The estimate may be
        high, but never low, because each arena rounds up to the nearest
        multiple of the chunk size when computing its contribution to the
        counter.  Note that the <link
        linkend="epoch"><mallctl>epoch</mallctl></link> mallctl has no bearing
        on this counter.  Furthermore, counter consistency is maintained via
        atomic operations, so it is necessary to use an atomic operation in
        order to guarantee a consistent read when dereferencing the pointer.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.allocated">
        <term>
          <mallctl>stats.allocated</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Total number of bytes allocated by the
        application.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.active">
        <term>
          <mallctl>stats.active</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Total number of bytes in active pages allocated by the
        application.  This is a multiple of the page size, and greater than or
        equal to <link
        linkend="stats.allocated"><mallctl>stats.allocated</mallctl></link>.
        This does not include <link linkend="stats.arenas.i.pdirty">
        <mallctl>stats.arenas.&lt;i&gt;.pdirty</mallctl></link> and pages
        entirely devoted to allocator metadata.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.mapped">
        <term>
          <mallctl>stats.mapped</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Total number of bytes in chunks mapped on behalf of the
        application.  This is a multiple of the chunk size, and is at least as
        large as <link
        linkend="stats.active"><mallctl>stats.active</mallctl></link>.  This
        does not include inactive chunks.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.chunks.current">
        <term>
          <mallctl>stats.chunks.current</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Total number of chunks actively mapped on behalf of the
        application.  This does not include inactive chunks.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.chunks.total">
        <term>
          <mallctl>stats.chunks.total</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of chunks allocated.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.chunks.high">
        <term>
          <mallctl>stats.chunks.high</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Maximum number of active chunks at any time thus far.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.huge.allocated">
        <term>
          <mallctl>stats.huge.allocated</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Number of bytes currently allocated by huge objects.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.huge.nmalloc">
        <term>
          <mallctl>stats.huge.nmalloc</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of huge allocation requests.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.huge.ndalloc">
        <term>
          <mallctl>stats.huge.ndalloc</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of huge deallocation requests.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.dss">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.dss</mallctl>
          (<type>const char *</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>dss (<citerefentry><refentrytitle>sbrk</refentrytitle>
        <manvolnum>2</manvolnum></citerefentry>) allocation precedence as
        related to <citerefentry><refentrytitle>mmap</refentrytitle>
        <manvolnum>2</manvolnum></citerefentry> allocation.  See <link
        linkend="opt.dss"><mallctl>opt.dss</mallctl></link> for details.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.nthreads">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.nthreads</mallctl>
          (<type>unsigned</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Number of threads currently assigned to
        arena.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.pactive">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.pactive</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Number of pages in active runs.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.pdirty">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.pdirty</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
        </term>
        <listitem><para>Number of pages within unused runs that are potentially
        dirty, and for which <function>madvise<parameter>...</parameter>
        <parameter><constant>MADV_DONTNEED</constant></parameter></function> or
        similar has not been called.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.mapped">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.mapped</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Number of mapped bytes.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.npurge">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.npurge</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Number of dirty page purge sweeps performed.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.nmadvise">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.nmadvise</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Number of <function>madvise<parameter>...</parameter>
        <parameter><constant>MADV_DONTNEED</constant></parameter></function> or
        similar calls made to purge dirty pages.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.purged">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.purged</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Number of pages purged.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.small.allocated">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.small.allocated</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Number of bytes currently allocated by small objects.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.small.nmalloc">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.small.nmalloc</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of allocation requests served by
        small bins.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.small.ndalloc">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.small.ndalloc</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of small objects returned to bins.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.small.nrequests">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.small.nrequests</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of small allocation requests.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.large.allocated">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.large.allocated</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Number of bytes currently allocated by large objects.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.large.nmalloc">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.large.nmalloc</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of large allocation requests served
        directly by the arena.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.large.ndalloc">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.large.ndalloc</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of large deallocation requests served
        directly by the arena.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.large.nrequests">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.large.nrequests</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of large allocation requests.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.bins.j.allocated">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.allocated</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Current number of bytes allocated by
        bin.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.bins.j.nmalloc">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nmalloc</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of allocations served by bin.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.bins.j.ndalloc">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.ndalloc</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of allocations returned to bin.
        </para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.bins.j.nrequests">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nrequests</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of allocation
        requests.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.bins.j.nfills">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nfills</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option> <option>--enable-tcache</option>]
        </term>
        <listitem><para>Cumulative number of tcache fills.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.bins.j.nflushes">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nflushes</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option> <option>--enable-tcache</option>]
        </term>
        <listitem><para>Cumulative number of tcache flushes.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.bins.j.nruns">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nruns</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of runs created.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.bins.j.nreruns">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nreruns</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of times the current run from which
        to allocate changed.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.bins.j.curruns">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curruns</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Current number of runs.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.lruns.j.nmalloc">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.lruns.&lt;j&gt;.nmalloc</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of allocation requests for this size
        class served directly by the arena.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.lruns.j.ndalloc">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.lruns.&lt;j&gt;.ndalloc</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of deallocation requests for this
        size class served directly by the arena.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.lruns.j.nrequests">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.lruns.&lt;j&gt;.nrequests</mallctl>
          (<type>uint64_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Cumulative number of allocation requests for this size
        class.</para></listitem>
      </varlistentry>

      <varlistentry id="stats.arenas.i.lruns.j.curruns">
        <term>
          <mallctl>stats.arenas.&lt;i&gt;.lruns.&lt;j&gt;.curruns</mallctl>
          (<type>size_t</type>)
          <literal>r-</literal>
          [<option>--enable-stats</option>]
        </term>
        <listitem><para>Current number of runs for this size class.
        </para></listitem>
      </varlistentry>
    </variablelist>
  </refsect1>
  <refsect1 id="debugging_malloc_problems">
    <title>DEBUGGING MALLOC PROBLEMS</title>
    <para>When debugging, it is a good idea to configure/build jemalloc with
    the <option>--enable-debug</option> and <option>--enable-fill</option>
    options, and recompile the program with suitable options and symbols for
    debugger support.  When so configured, jemalloc incorporates a wide variety
    of run-time assertions that catch application errors such as double-free,
    write-after-free, etc.</para>

    <para>Programs often accidentally depend on &ldquo;uninitialized&rdquo;
    memory actually being filled with zero bytes.  Junk filling
    (see the <link linkend="opt.junk"><mallctl>opt.junk</mallctl></link>
    option) tends to expose such bugs in the form of obviously incorrect
    results and/or coredumps.  Conversely, zero
    filling (see the <link
    linkend="opt.zero"><mallctl>opt.zero</mallctl></link> option) eliminates
    the symptoms of such bugs.  Between these two options, it is usually
    possible to quickly detect, diagnose, and eliminate such bugs.</para>

    <para>This implementation does not provide much detail about the problems
    it detects, because the performance impact for storing such information
    would be prohibitive.  However, jemalloc does integrate with the most
    excellent <ulink url="http://valgrind.org/">Valgrind</ulink> tool if the
    <option>--enable-valgrind</option> configuration option is enabled.</para>
  </refsect1>
  <refsect1 id="diagnostic_messages">
    <title>DIAGNOSTIC MESSAGES</title>
    <para>If any of the memory allocation/deallocation functions detect an
    error or warning condition, a message will be printed to file descriptor
    <constant>STDERR_FILENO</constant>.  Errors will result in the process
    dumping core.  If the <link
    linkend="opt.abort"><mallctl>opt.abort</mallctl></link> option is set, most
    warnings are treated as errors.</para>

    <para>The <varname>malloc_message</varname> variable allows the programmer
    to override the function which emits the text strings forming the errors
    and warnings if for some reason the <constant>STDERR_FILENO</constant> file
    descriptor is not suitable for this.
    <function>malloc_message<parameter/></function> takes the
    <parameter>cbopaque</parameter> pointer argument that is
    <constant>NULL</constant> unless overridden by the arguments in a call to
    <function>malloc_stats_print<parameter/></function>, followed by a string
    pointer.  Please note that doing anything which tries to allocate memory in
    this function is likely to result in a crash or deadlock.</para>

    <para>All messages are prefixed by
    &ldquo;<computeroutput>&lt;jemalloc&gt;: </computeroutput>&rdquo;.</para>
  </refsect1>
  <refsect1 id="return_values">
    <title>RETURN VALUES</title>
    <refsect2>
      <title>Standard API</title>
      <para>The <function>malloc<parameter/></function> and
      <function>calloc<parameter/></function> functions return a pointer to the
      allocated memory if successful; otherwise a <constant>NULL</constant>
      pointer is returned and <varname>errno</varname> is set to
      <errorname>ENOMEM</errorname>.</para>

      <para>The <function>posix_memalign<parameter/></function> function
      returns the value 0 if successful; otherwise it returns an error value.
      The <function>posix_memalign<parameter/></function> function will fail
      if:
        <variablelist>
          <varlistentry>
            <term><errorname>EINVAL</errorname></term>

            <listitem><para>The <parameter>alignment</parameter> parameter is
            not a power of 2 at least as large as
            <code language="C">sizeof(<type>void *</type>)</code>.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term><errorname>ENOMEM</errorname></term>

            <listitem><para>Memory allocation error.</para></listitem>
          </varlistentry>
        </variablelist>
      </para>

      <para>The <function>aligned_alloc<parameter/></function> function returns
      a pointer to the allocated memory if successful; otherwise a
      <constant>NULL</constant> pointer is returned and
      <varname>errno</varname> is set.  The
      <function>aligned_alloc<parameter/></function> function will fail if:
        <variablelist>
          <varlistentry>
            <term><errorname>EINVAL</errorname></term>

            <listitem><para>The <parameter>alignment</parameter> parameter is
            not a power of 2.
            </para></listitem>
          </varlistentry>
          <varlistentry>
            <term><errorname>ENOMEM</errorname></term>

            <listitem><para>Memory allocation error.</para></listitem>
          </varlistentry>
        </variablelist>
      </para>

      <para>The <function>realloc<parameter/></function> function returns a
      pointer, possibly identical to <parameter>ptr</parameter>, to the
      allocated memory if successful; otherwise a <constant>NULL</constant>
      pointer is returned, and <varname>errno</varname> is set to
      <errorname>ENOMEM</errorname> if the error was the result of an
      allocation failure.  The <function>realloc<parameter/></function>
      function always leaves the original buffer intact when an error occurs.
      </para>

      <para>The <function>free<parameter/></function> function returns no
      value.</para>
    </refsect2>
    <refsect2>
      <title>Non-standard API</title>
      <para>The <function>mallocx<parameter/></function> and
      <function>rallocx<parameter/></function> functions return a pointer to
      the allocated memory if successful; otherwise a <constant>NULL</constant>
      pointer is returned to indicate insufficient contiguous memory was
      available to service the allocation request.  </para>

      <para>The <function>xallocx<parameter/></function> function returns the
      real size of the resulting resized allocation pointed to by
      <parameter>ptr</parameter>, which is a value less than
      <parameter>size</parameter> if the allocation could not be adequately
      grown in place.  </para>

      <para>The <function>sallocx<parameter/></function> function returns the
      real size of the allocation pointed to by <parameter>ptr</parameter>.
      </para>

      <para>The <function>nallocx<parameter/></function> returns the real size
      that would result from a successful equivalent
      <function>mallocx<parameter/></function> function call, or zero if
      insufficient memory is available to perform the size computation.  </para>

      <para>The <function>mallctl<parameter/></function>,
      <function>mallctlnametomib<parameter/></function>, and
      <function>mallctlbymib<parameter/></function> functions return 0 on
      success; otherwise they return an error value.  The functions will fail
      if:
        <variablelist>
          <varlistentry>
            <term><errorname>EINVAL</errorname></term>

            <listitem><para><parameter>newp</parameter> is not
            <constant>NULL</constant>, and <parameter>newlen</parameter> is too
            large or too small.  Alternatively, <parameter>*oldlenp</parameter>
            is too large or too small; in this case as much data as possible
            are read despite the error.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><errorname>ENOENT</errorname></term>

            <listitem><para><parameter>name</parameter> or
            <parameter>mib</parameter> specifies an unknown/invalid
            value.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><errorname>EPERM</errorname></term>

            <listitem><para>Attempt to read or write void value, or attempt to
            write read-only value.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><errorname>EAGAIN</errorname></term>

            <listitem><para>A memory allocation failure
            occurred.</para></listitem>
          </varlistentry>
          <varlistentry>
            <term><errorname>EFAULT</errorname></term>

            <listitem><para>An interface with side effects failed in some way
            not directly related to <function>mallctl*<parameter/></function>
            read/write processing.</para></listitem>
          </varlistentry>
        </variablelist>
      </para>

      <para>The <function>malloc_usable_size<parameter/></function> function
      returns the usable size of the allocation pointed to by
      <parameter>ptr</parameter>.  </para>
    </refsect2>
    <refsect2>
      <title>Experimental API</title>
      <para>The <function>allocm<parameter/></function>,
      <function>rallocm<parameter/></function>,
      <function>sallocm<parameter/></function>,
      <function>dallocm<parameter/></function>, and
      <function>nallocm<parameter/></function> functions return
      <constant>ALLOCM_SUCCESS</constant> on success; otherwise they return an
      error value.  The <function>allocm<parameter/></function>,
      <function>rallocm<parameter/></function>, and
      <function>nallocm<parameter/></function> functions will fail if:
        <variablelist>
          <varlistentry>
            <term><errorname>ALLOCM_ERR_OOM</errorname></term>

            <listitem><para>Out of memory.  Insufficient contiguous memory was
            available to service the allocation request.  The
            <function>allocm<parameter/></function> function additionally sets
            <parameter>*ptr</parameter> to <constant>NULL</constant>, whereas
            the <function>rallocm<parameter/></function> function leaves
            <constant>*ptr</constant> unmodified.</para></listitem>
          </varlistentry>
        </variablelist>
      The <function>rallocm<parameter/></function> function will also
      fail if:
        <variablelist>
          <varlistentry>
            <term><errorname>ALLOCM_ERR_NOT_MOVED</errorname></term>

            <listitem><para><constant>ALLOCM_NO_MOVE</constant> was specified,
            but the reallocation request could not be serviced without moving
            the object.</para></listitem>
          </varlistentry>
        </variablelist>
      </para>
    </refsect2>
  </refsect1>
  <refsect1 id="environment">
    <title>ENVIRONMENT</title>
    <para>The following environment variable affects the execution of the
    allocation functions:
      <variablelist>
        <varlistentry>
          <term><envar>MALLOC_CONF</envar></term>

          <listitem><para>If the environment variable
          <envar>MALLOC_CONF</envar> is set, the characters it contains
          will be interpreted as options.</para></listitem>
        </varlistentry>
      </variablelist>
    </para>
  </refsect1>
  <refsect1 id="examples">
    <title>EXAMPLES</title>
    <para>To dump core whenever a problem occurs:
      <screen>ln -s 'abort:true' /etc/malloc.conf</screen>
    </para>
    <para>To specify in the source a chunk size that is 16 MiB:
      <programlisting language="C"><![CDATA[
malloc_conf = "lg_chunk:24";]]></programlisting></para>
  </refsect1>
  <refsect1 id="see_also">
    <title>SEE ALSO</title>
    <para><citerefentry><refentrytitle>madvise</refentrytitle>
    <manvolnum>2</manvolnum></citerefentry>,
    <citerefentry><refentrytitle>mmap</refentrytitle>
    <manvolnum>2</manvolnum></citerefentry>,
    <citerefentry><refentrytitle>sbrk</refentrytitle>
    <manvolnum>2</manvolnum></citerefentry>,
    <citerefentry><refentrytitle>utrace</refentrytitle>
    <manvolnum>2</manvolnum></citerefentry>,
    <citerefentry><refentrytitle>alloca</refentrytitle>
    <manvolnum>3</manvolnum></citerefentry>,
    <citerefentry><refentrytitle>atexit</refentrytitle>
    <manvolnum>3</manvolnum></citerefentry>,
    <citerefentry><refentrytitle>getpagesize</refentrytitle>
    <manvolnum>3</manvolnum></citerefentry></para>
  </refsect1>
  <refsect1 id="standards">
    <title>STANDARDS</title>
    <para>The <function>malloc<parameter/></function>,
    <function>calloc<parameter/></function>,
    <function>realloc<parameter/></function>, and
    <function>free<parameter/></function> functions conform to ISO/IEC
    9899:1990 (&ldquo;ISO C90&rdquo;).</para>

    <para>The <function>posix_memalign<parameter/></function> function conforms
    to IEEE Std 1003.1-2001 (&ldquo;POSIX.1&rdquo;).</para>
  </refsect1>
</refentry>
