<?xml version="1.0" encoding="utf-8"?>
<html><head><title>JEMALLOC</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"/></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="refentry"><a name="idm140689766630352"/><div class="titlepage"/><div class="refnamediv"><h2>Name</h2><p>jemalloc — general purpose memory allocation functions</p></div><div class="refsect1"><a name="library"/><h2>LIBRARY</h2><p>This manual describes jemalloc 5.1.0-0-g61efbda7098de6fe64c362d309824864308c36d4.  More information
    can be found at the <a class="ulink" href="http://jemalloc.net/" target="_top">jemalloc website</a>.</p></div><div class="refsynopsisdiv"><h2>SYNOPSIS</h2><div class="funcsynopsis"><pre class="funcsynopsisinfo">#include &lt;<code class="filename">jemalloc/jemalloc.h</code>&gt;</pre><div class="refsect2"><a name="idm140689767408528"/><h3>Standard API</h3><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">malloc</b>(</code></td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">calloc</b>(</code></td><td>size_t <var class="pdparam">number</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">posix_memalign</b>(</code></td><td>void **<var class="pdparam">ptr</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">aligned_alloc</b>(</code></td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">realloc</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">free</b>(</code></td><td>void *<var class="pdparam">ptr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="refsect2"><a name="idm140689770688880"/><h3>Non-standard API</h3><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">mallocx</b>(</code></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void *<b class="fsfunc">rallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">xallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">extra</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">sallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">dallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">sdallocx</b>(</code></td><td>void *<var class="pdparam">ptr</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">nallocx</b>(</code></td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td> </td><td>int <var class="pdparam">flags</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctl</b>(</code></td><td>const char *<var class="pdparam">name</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">oldp</var>, </td></tr><tr><td> </td><td>size_t *<var class="pdparam">oldlenp</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">newp</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">newlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctlnametomib</b>(</code></td><td>const char *<var class="pdparam">name</var>, </td></tr><tr><td> </td><td>size_t *<var class="pdparam">mibp</var>, </td></tr><tr><td> </td><td>size_t *<var class="pdparam">miblenp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">int <b class="fsfunc">mallctlbymib</b>(</code></td><td>const size_t *<var class="pdparam">mib</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">miblen</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">oldp</var>, </td></tr><tr><td> </td><td>size_t *<var class="pdparam">oldlenp</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">newp</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">newlen</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">malloc_stats_print</b>(</code></td><td>void <var class="pdparam">(*write_cb)</var>
            <code>(</code>void *, const char *<code>)</code>
          , </td></tr><tr><td> </td><td>void *<var class="pdparam">cbopaque</var>, </td></tr><tr><td> </td><td>const char *<var class="pdparam">opts</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">size_t <b class="fsfunc">malloc_usable_size</b>(</code></td><td>const void *<var class="pdparam">ptr</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">(*malloc_message)</b>(</code></td><td>void *<var class="pdparam">cbopaque</var>, </td></tr><tr><td> </td><td>const char *<var class="pdparam">s</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div><p><span class="type">const char *</span><code class="varname">malloc_conf</code>;</p></div></div></div><div class="refsect1"><a name="description"/><h2>DESCRIPTION</h2><div class="refsect2"><a name="idm140689765494448"/><h3>Standard API</h3><p>The <code class="function">malloc()</code> function allocates
      <em class="parameter"><code>size</code></em> bytes of uninitialized memory.  The allocated
      space is suitably aligned (after possible pointer coercion) for storage
      of any type of object.</p><p>The <code class="function">calloc()</code> function allocates
      space for <em class="parameter"><code>number</code></em> objects, each
      <em class="parameter"><code>size</code></em> bytes in length.  The result is identical to
      calling <code class="function">malloc()</code> with an argument of
      <em class="parameter"><code>number</code></em> * <em class="parameter"><code>size</code></em>, with the
      exception that the allocated memory is explicitly initialized to zero
      bytes.</p><p>The <code class="function">posix_memalign()</code> function
      allocates <em class="parameter"><code>size</code></em> bytes of memory such that the
      allocation's base address is a multiple of
      <em class="parameter"><code>alignment</code></em>, and returns the allocation in the value
      pointed to by <em class="parameter"><code>ptr</code></em>.  The requested
      <em class="parameter"><code>alignment</code></em> must be a power of 2 at least as large as
      <code class="code">sizeof(<span class="type">void *</span>)</code>.</p><p>The <code class="function">aligned_alloc()</code> function
      allocates <em class="parameter"><code>size</code></em> bytes of memory such that the
      allocation's base address is a multiple of
      <em class="parameter"><code>alignment</code></em>.  The requested
      <em class="parameter"><code>alignment</code></em> must be a power of 2.  Behavior is
      undefined if <em class="parameter"><code>size</code></em> is not an integral multiple of
      <em class="parameter"><code>alignment</code></em>.</p><p>The <code class="function">realloc()</code> function changes the
      size of the previously allocated memory referenced by
      <em class="parameter"><code>ptr</code></em> to <em class="parameter"><code>size</code></em> bytes.  The
      contents of the memory are unchanged up to the lesser of the new and old
      sizes.  If the new size is larger, the contents of the newly allocated
      portion of the memory are undefined.  Upon success, the memory referenced
      by <em class="parameter"><code>ptr</code></em> is freed and a pointer to the newly
      allocated memory is returned.  Note that
      <code class="function">realloc()</code> may move the memory allocation,
      resulting in a different return value than <em class="parameter"><code>ptr</code></em>.
      If <em class="parameter"><code>ptr</code></em> is <code class="constant">NULL</code>, the
      <code class="function">realloc()</code> function behaves identically to
      <code class="function">malloc()</code> for the specified size.</p><p>The <code class="function">free()</code> function causes the
      allocated memory referenced by <em class="parameter"><code>ptr</code></em> to be made
      available for future allocations.  If <em class="parameter"><code>ptr</code></em> is
      <code class="constant">NULL</code>, no action occurs.</p></div><div class="refsect2"><a name="idm140689765469472"/><h3>Non-standard API</h3><p>The <code class="function">mallocx()</code>,
      <code class="function">rallocx()</code>,
      <code class="function">xallocx()</code>,
      <code class="function">sallocx()</code>,
      <code class="function">dallocx()</code>,
      <code class="function">sdallocx()</code>, and
      <code class="function">nallocx()</code> functions all have a
      <em class="parameter"><code>flags</code></em> argument that can be used to specify
      options.  The functions only check the options that are contextually
      relevant.  Use bitwise or (<code class="code">|</code>) operations to
      specify one or more of the following:
        </p><div class="variablelist"><dl class="variablelist"><dt><a name="MALLOCX_LG_ALIGN"/><span class="term"><code class="constant">MALLOCX_LG_ALIGN(<em class="parameter"><code>la</code></em>)
            </code></span></dt><dd><p>Align the memory allocation to start at an address
            that is a multiple of <code class="code">(1 &lt;&lt;
            <em class="parameter"><code>la</code></em>)</code>.  This macro does not validate
            that <em class="parameter"><code>la</code></em> is within the valid
            range.</p></dd><dt><a name="MALLOCX_ALIGN"/><span class="term"><code class="constant">MALLOCX_ALIGN(<em class="parameter"><code>a</code></em>)
            </code></span></dt><dd><p>Align the memory allocation to start at an address
            that is a multiple of <em class="parameter"><code>a</code></em>, where
            <em class="parameter"><code>a</code></em> is a power of two.  This macro does not
            validate that <em class="parameter"><code>a</code></em> is a power of 2.
            </p></dd><dt><a name="MALLOCX_ZERO"/><span class="term"><code class="constant">MALLOCX_ZERO</code></span></dt><dd><p>Initialize newly allocated memory to contain zero
            bytes.  In the growing reallocation case, the real size prior to
            reallocation defines the boundary between untouched bytes and those
            that are initialized to contain zero bytes.  If this macro is
            absent, newly allocated memory is uninitialized.</p></dd><dt><a name="MALLOCX_TCACHE"/><span class="term"><code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)
            </code></span></dt><dd><p>Use the thread-specific cache (tcache) specified by
            the identifier <em class="parameter"><code>tc</code></em>, which must have been
            acquired via the <a class="link" href="#tcache.create"><quote><code class="mallctl">tcache.create</code></quote></a>
            mallctl.  This macro does not validate that
            <em class="parameter"><code>tc</code></em> specifies a valid
            identifier.</p></dd><dt><a name="MALLOC_TCACHE_NONE"/><span class="term"><code class="constant">MALLOCX_TCACHE_NONE</code></span></dt><dd><p>Do not use a thread-specific cache (tcache).  Unless
            <code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)</code> or
            <code class="constant">MALLOCX_TCACHE_NONE</code> is specified, an
            automatically managed tcache will be used under many circumstances.
            This macro cannot be used in the same <em class="parameter"><code>flags</code></em>
            argument as
            <code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)</code>.</p></dd><dt><a name="MALLOCX_ARENA"/><span class="term"><code class="constant">MALLOCX_ARENA(<em class="parameter"><code>a</code></em>)
            </code></span></dt><dd><p>Use the arena specified by the index
            <em class="parameter"><code>a</code></em>.  This macro has no effect for regions that
            were allocated via an arena other than the one specified.  This
            macro does not validate that <em class="parameter"><code>a</code></em> specifies an
            arena index in the valid range.</p></dd></dl></div><p>
      </p><p>The <code class="function">mallocx()</code> function allocates at
      least <em class="parameter"><code>size</code></em> bytes of memory, and returns a pointer
      to the base address of the allocation.  Behavior is undefined if
      <em class="parameter"><code>size</code></em> is <code class="constant">0</code>.</p><p>The <code class="function">rallocx()</code> function resizes the
      allocation at <em class="parameter"><code>ptr</code></em> to be at least
      <em class="parameter"><code>size</code></em> bytes, and returns a pointer to the base
      address of the resulting allocation, which may or may not have moved from
      its original location.  Behavior is undefined if
      <em class="parameter"><code>size</code></em> is <code class="constant">0</code>.</p><p>The <code class="function">xallocx()</code> function resizes the
      allocation at <em class="parameter"><code>ptr</code></em> in place to be at least
      <em class="parameter"><code>size</code></em> bytes, and returns the real size of the
      allocation.  If <em class="parameter"><code>extra</code></em> is non-zero, an attempt is
      made to resize the allocation to be at least <code class="code">(<em class="parameter"><code>size</code></em> +
      <em class="parameter"><code>extra</code></em>)</code> bytes, though inability to allocate
      the extra byte(s) will not by itself result in failure to resize.
      Behavior is undefined if <em class="parameter"><code>size</code></em> is
      <code class="constant">0</code>, or if <code class="code">(<em class="parameter"><code>size</code></em> + <em class="parameter"><code>extra</code></em>
      &gt; <code class="constant">SIZE_T_MAX</code>)</code>.</p><p>The <code class="function">sallocx()</code> function returns the
      real size of the allocation at <em class="parameter"><code>ptr</code></em>.</p><p>The <code class="function">dallocx()</code> function causes the
      memory referenced by <em class="parameter"><code>ptr</code></em> to be made available for
      future allocations.</p><p>The <code class="function">sdallocx()</code> function is an
      extension of <code class="function">dallocx()</code> with a
      <em class="parameter"><code>size</code></em> parameter to allow the caller to pass in the
      allocation size as an optimization.  The minimum valid input size is the
      original requested size of the allocation, and the maximum valid input
      size is the corresponding value returned by
      <code class="function">nallocx()</code> or
      <code class="function">sallocx()</code>.</p><p>The <code class="function">nallocx()</code> function allocates no
      memory, but it performs the same size computation as the
      <code class="function">mallocx()</code> function, and returns the real
      size of the allocation that would result from the equivalent
      <code class="function">mallocx()</code> function call, or
      <code class="constant">0</code> if the inputs exceed the maximum supported size
      class and/or alignment.  Behavior is undefined if
      <em class="parameter"><code>size</code></em> is <code class="constant">0</code>.</p><p>The <code class="function">mallctl()</code> function provides a
      general interface for introspecting the memory allocator, as well as
      setting modifiable parameters and triggering actions.  The
      period-separated <em class="parameter"><code>name</code></em> argument specifies a
      location in a tree-structured namespace; see the <a class="xref" href="#mallctl_namespace" title="MALLCTL NAMESPACE">MALLCTL NAMESPACE</a> section for
      documentation on the tree contents.  To read a value, pass a pointer via
      <em class="parameter"><code>oldp</code></em> to adequate space to contain the value, and a
      pointer to its length via <em class="parameter"><code>oldlenp</code></em>; otherwise pass
      <code class="constant">NULL</code> and <code class="constant">NULL</code>.  Similarly, to
      write a value, pass a pointer to the value via
      <em class="parameter"><code>newp</code></em>, and its length via
      <em class="parameter"><code>newlen</code></em>; otherwise pass <code class="constant">NULL</code>
      and <code class="constant">0</code>.</p><p>The <code class="function">mallctlnametomib()</code> function
      provides a way to avoid repeated name lookups for applications that
      repeatedly query the same portion of the namespace, by translating a name
      to a <span class="quote">“<span class="quote">Management Information Base</span>”</span> (MIB) that can be passed
      repeatedly to <code class="function">mallctlbymib()</code>.  Upon
      successful return from <code class="function">mallctlnametomib()</code>,
      <em class="parameter"><code>mibp</code></em> contains an array of
      <em class="parameter"><code>*miblenp</code></em> integers, where
      <em class="parameter"><code>*miblenp</code></em> is the lesser of the number of components
      in <em class="parameter"><code>name</code></em> and the input value of
      <em class="parameter"><code>*miblenp</code></em>.  Thus it is possible to pass a
      <em class="parameter"><code>*miblenp</code></em> that is smaller than the number of
      period-separated name components, which results in a partial MIB that can
      be used as the basis for constructing a complete MIB.  For name
      components that are integers (e.g. the 2 in
      <a class="link" href="#arenas.bin.i.size"><quote><code class="mallctl">arenas.bin.2.size</code></quote></a>),
      the corresponding MIB component will always be that integer.  Therefore,
      it is legitimate to construct code like the following: </p><pre class="programlisting">
unsigned nbins, i;
size_t mib[4];
size_t len, miblen;

len = sizeof(nbins);
mallctl("arenas.nbins", &amp;nbins, &amp;len, NULL, 0);

miblen = 4;
mallctlnametomib("arenas.bin.0.size", mib, &amp;miblen);
for (i = 0; i &lt; nbins; i++) {
	size_t bin_size;

	mib[2] = i;
	len = sizeof(bin_size);
	mallctlbymib(mib, miblen, (void *)&amp;bin_size, &amp;len, NULL, 0);
	/* Do something with bin_size... */
}</pre><dt><a name="malloc_stats_print_opts"/></dt><dd/><p>The <code class="function">malloc_stats_print()</code> function writes
      summary statistics via the <em class="parameter"><code>write_cb</code></em> callback
      function pointer and <em class="parameter"><code>cbopaque</code></em> data passed to
      <em class="parameter"><code>write_cb</code></em>, or <code class="function">malloc_message()</code>
      if <em class="parameter"><code>write_cb</code></em> is <code class="constant">NULL</code>.  The
      statistics are presented in human-readable form unless <span class="quote">“<span class="quote">J</span>”</span> is
      specified as a character within the <em class="parameter"><code>opts</code></em> string, in
      which case the statistics are presented in <a class="ulink" href="http://www.json.org/" target="_top">JSON format</a>.  This function can be
      called repeatedly.  General information that never changes during
      execution can be omitted by specifying <span class="quote">“<span class="quote">g</span>”</span> as a character
      within the <em class="parameter"><code>opts</code></em> string.  Note that
      <code class="function">malloc_message()</code> uses the
      <code class="function">mallctl*()</code> functions internally, so inconsistent
      statistics can be reported if multiple threads use these functions
      simultaneously.  If <code class="option">--enable-stats</code> is specified during
      configuration, <span class="quote">“<span class="quote">m</span>”</span>, <span class="quote">“<span class="quote">d</span>”</span>, and <span class="quote">“<span class="quote">a</span>”</span>
      can be specified to omit merged arena, destroyed merged arena, and per
      arena statistics, respectively; <span class="quote">“<span class="quote">b</span>”</span> and <span class="quote">“<span class="quote">l</span>”</span> can
      be specified to omit per size class statistics for bins and large objects,
      respectively; <span class="quote">“<span class="quote">x</span>”</span> can be specified to omit all mutex
      statistics.  Unrecognized characters are silently ignored.  Note that
      thread caching may prevent some statistics from being completely up to
      date, since extra locking would be required to merge counters that track
      thread cache operations.</p><p>The <code class="function">malloc_usable_size()</code> function
      returns the usable size of the allocation pointed to by
      <em class="parameter"><code>ptr</code></em>.  The return value may be larger than the size
      that was requested during allocation.  The
      <code class="function">malloc_usable_size()</code> function is not a
      mechanism for in-place <code class="function">realloc()</code>; rather
      it is provided solely as a tool for introspection purposes.  Any
      discrepancy between the requested allocation size and the size reported
      by <code class="function">malloc_usable_size()</code> should not be
      depended on, since such behavior is entirely implementation-dependent.
      </p></div></div><div class="refsect1"><a name="tuning"/><h2>TUNING</h2><p>Once, when the first call is made to one of the memory allocation
    routines, the allocator initializes its internals based in part on various
    options that can be specified at compile- or run-time.</p><p>The string specified via <code class="option">--with-malloc-conf</code>, the
    string pointed to by the global variable <code class="varname">malloc_conf</code>, the
    <span class="quote">“<span class="quote">name</span>”</span> of the file referenced by the symbolic link named
    <code class="filename">/etc/malloc.conf</code>, and the value of the
    environment variable <code class="envar">MALLOC_CONF</code>, will be interpreted, in
    that order, from left to right as options.  Note that
    <code class="varname">malloc_conf</code> may be read before
    <code class="function">main()</code> is entered, so the declaration of
    <code class="varname">malloc_conf</code> should specify an initializer that contains
    the final value to be read by jemalloc.  <code class="option">--with-malloc-conf</code>
    and <code class="varname">malloc_conf</code> are compile-time mechanisms, whereas
    <code class="filename">/etc/malloc.conf</code> and
    <code class="envar">MALLOC_CONF</code> can be safely set any time prior to program
    invocation.</p><p>An options string is a comma-separated list of option:value pairs.
    There is one key corresponding to each <a class="link" href="#opt.abort"><quote><code class="mallctl">opt.*</code></quote></a> mallctl (see the <a class="xref" href="#mallctl_namespace" title="MALLCTL NAMESPACE">MALLCTL NAMESPACE</a> section for options
    documentation).  For example, <code class="literal">abort:true,narenas:1</code> sets
    the <a class="link" href="#opt.abort"><quote><code class="mallctl">opt.abort</code></quote></a> and <a class="link" href="#opt.narenas"><quote><code class="mallctl">opt.narenas</code></quote></a> options.  Some
    options have boolean values (true/false), others have integer values (base
    8, 10, or 16, depending on prefix), and yet others have raw string
    values.</p></div><div class="refsect1"><a name="implementation_notes"/><h2>IMPLEMENTATION NOTES</h2><p>Traditionally, allocators have used
    <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span> to obtain memory, which is
    suboptimal for several reasons, including race conditions, increased
    fragmentation, and artificial limitations on maximum usable memory.  If
    <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span> is supported by the operating
    system, this allocator uses both
    <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span> and
    <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span>, in that order of preference;
    otherwise only <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span> is used.</p><p>This allocator uses multiple arenas in order to reduce lock
    contention for threaded programs on multi-processor systems.  This works
    well with regard to threading scalability, but incurs some costs.  There is
    a small fixed per-arena overhead, and additionally, arenas manage memory
    completely independently of each other, which means a small fixed increase
    in overall memory fragmentation.  These overheads are not generally an
    issue, given the number of arenas normally used.  Note that using
    substantially more arenas than the default is not likely to improve
    performance, mainly due to reduced cache performance.  However, it may make
    sense to reduce the number of arenas if an application does not make much
    use of the allocation functions.</p><p>In addition to multiple arenas, this allocator supports
    thread-specific caching, in order to make it possible to completely avoid
    synchronization for most allocation requests.  Such caching allows very fast
    allocation in the common case, but it increases memory usage and
    fragmentation, since a bounded number of objects can remain allocated in
    each thread cache.</p><p>Memory is conceptually broken into extents.  Extents are always
    aligned to multiples of the page size.  This alignment makes it possible to
    find metadata for user objects quickly.  User objects are broken into two
    categories according to size: small and large.  Contiguous small objects
    comprise a slab, which resides within a single extent, whereas large objects
    each have their own extents backing them.</p><p>Small objects are managed in groups by slabs.  Each slab maintains
    a bitmap to track which regions are in use.  Allocation requests that are no
    more than half the quantum (8 or 16, depending on architecture) are rounded
    up to the nearest power of two that is at least <code class="code">sizeof(<span class="type">double</span>)</code>.  All other object size
    classes are multiples of the quantum, spaced such that there are four size
    classes for each doubling in size, which limits internal fragmentation to
    approximately 20% for all but the smallest size classes.  Small size classes
    are smaller than four times the page size, and large size classes extend
    from four times the page size up to the largest size class that does not
    exceed <code class="constant">PTRDIFF_MAX</code>.</p><p>Allocations are packed tightly together, which can be an issue for
    multi-threaded applications.  If you need to assure that allocations do not
    suffer from cacheline sharing, round your allocation requests up to the
    nearest multiple of the cacheline size, or specify cacheline alignment when
    allocating.</p><p>The <code class="function">realloc()</code>,
    <code class="function">rallocx()</code>, and
    <code class="function">xallocx()</code> functions may resize allocations
    without moving them under limited circumstances.  Unlike the
    <code class="function">*allocx()</code> API, the standard API does not
    officially round up the usable size of an allocation to the nearest size
    class, so technically it is necessary to call
    <code class="function">realloc()</code> to grow e.g. a 9-byte allocation to
    16 bytes, or shrink a 16-byte allocation to 9 bytes.  Growth and shrinkage
    trivially succeeds in place as long as the pre-size and post-size both round
    up to the same size class.  No other API guarantees are made regarding
    in-place resizing, but the current implementation also tries to resize large
    allocations in place, as long as the pre-size and post-size are both large.
    For shrinkage to succeed, the extent allocator must support splitting (see
    <a class="link" href="#arena.i.extent_hooks"><quote><code class="mallctl">arena.&lt;i&gt;.extent_hooks</code></quote></a>).
    Growth only succeeds if the trailing memory is currently available, and the
    extent allocator supports merging.</p><p>Assuming 4 KiB pages and a 16-byte quantum on a 64-bit system, the
    size classes in each category are as shown in <a class="xref" href="#size_classes" title="Table 1. Size classes">Table 1</a>.</p><div class="table"><a name="size_classes"/><p class="title"><b>Table 1. Size classes</b></p><div class="table-contents"><table summary="Size classes" border="1"><colgroup><col align="left" class="c1"/><col align="right" class="c2"/><col align="left" class="c3"/></colgroup><thead><tr><th align="left">Category</th><th align="right">Spacing</th><th align="left">Size</th></tr></thead><tbody><tr><td rowspan="9" align="left">Small</td><td align="right">lg</td><td align="left">[8]</td></tr><tr><td align="right">16</td><td align="left">[16, 32, 48, 64, 80, 96, 112, 128]</td></tr><tr><td align="right">32</td><td align="left">[160, 192, 224, 256]</td></tr><tr><td align="right">64</td><td align="left">[320, 384, 448, 512]</td></tr><tr><td align="right">128</td><td align="left">[640, 768, 896, 1024]</td></tr><tr><td align="right">256</td><td align="left">[1280, 1536, 1792, 2048]</td></tr><tr><td align="right">512</td><td align="left">[2560, 3072, 3584, 4096]</td></tr><tr><td align="right">1 KiB</td><td align="left">[5 KiB, 6 KiB, 7 KiB, 8 KiB]</td></tr><tr><td align="right">2 KiB</td><td align="left">[10 KiB, 12 KiB, 14 KiB]</td></tr><tr><td rowspan="16" align="left">Large</td><td align="right">2 KiB</td><td align="left">[16 KiB]</td></tr><tr><td align="right">4 KiB</td><td align="left">[20 KiB, 24 KiB, 28 KiB, 32 KiB]</td></tr><tr><td align="right">8 KiB</td><td align="left">[40 KiB, 48 KiB, 54 KiB, 64 KiB]</td></tr><tr><td align="right">16 KiB</td><td align="left">[80 KiB, 96 KiB, 112 KiB, 128 KiB]</td></tr><tr><td align="right">32 KiB</td><td align="left">[160 KiB, 192 KiB, 224 KiB, 256 KiB]</td></tr><tr><td align="right">64 KiB</td><td align="left">[320 KiB, 384 KiB, 448 KiB, 512 KiB]</td></tr><tr><td align="right">128 KiB</td><td align="left">[640 KiB, 768 KiB, 896 KiB, 1 MiB]</td></tr><tr><td align="right">256 KiB</td><td align="left">[1280 KiB, 1536 KiB, 1792 KiB, 2 MiB]</td></tr><tr><td align="right">512 KiB</td><td align="left">[2560 KiB, 3 MiB, 3584 KiB, 4 MiB]</td></tr><tr><td align="right">1 MiB</td><td align="left">[5 MiB, 6 MiB, 7 MiB, 8 MiB]</td></tr><tr><td align="right">2 MiB</td><td align="left">[10 MiB, 12 MiB, 14 MiB, 16 MiB]</td></tr><tr><td align="right">4 MiB</td><td align="left">[20 MiB, 24 MiB, 28 MiB, 32 MiB]</td></tr><tr><td align="right">8 MiB</td><td align="left">[40 MiB, 48 MiB, 56 MiB, 64 MiB]</td></tr><tr><td align="right">...</td><td align="left">...</td></tr><tr><td align="right">512 PiB</td><td align="left">[2560 PiB, 3 EiB, 3584 PiB, 4 EiB]</td></tr><tr><td align="right">1 EiB</td><td align="left">[5 EiB, 6 EiB, 7 EiB]</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="refsect1"><a name="mallctl_namespace"/><h2>MALLCTL NAMESPACE</h2><p>The following names are defined in the namespace accessible via the
    <code class="function">mallctl*()</code> functions.  Value types are specified in
    parentheses, their readable/writable statuses are encoded as
    <code class="literal">rw</code>, <code class="literal">r-</code>, <code class="literal">-w</code>, or
    <code class="literal">--</code>, and required build configuration flags follow, if
    any.  A name element encoded as <code class="literal">&lt;i&gt;</code> or
    <code class="literal">&lt;j&gt;</code> indicates an integer component, where the
    integer varies from 0 to some upper value that must be determined via
    introspection.  In the case of <quote><code class="mallctl">stats.arenas.&lt;i&gt;.*</code></quote>
    and <quote><code class="mallctl">arena.&lt;i&gt;.{initialized,purge,decay,dss}</code></quote>,
    <code class="literal">&lt;i&gt;</code> equal to
    <code class="constant">MALLCTL_ARENAS_ALL</code> can be used to operate on all arenas
    or access the summation of statistics from all arenas; similarly
    <code class="literal">&lt;i&gt;</code> equal to
    <code class="constant">MALLCTL_ARENAS_DESTROYED</code> can be used to access the
    summation of statistics from all destroyed arenas.  These constants can be
    utilized either via <code class="function">mallctlnametomib()</code> followed by
    <code class="function">mallctlbymib()</code>, or via code such as the following:
    </p><pre class="programlisting">
#define STRINGIFY_HELPER(x) #x
#define STRINGIFY(x) STRINGIFY_HELPER(x)

mallctl("arena." STRINGIFY(MALLCTL_ARENAS_ALL) ".decay",
    NULL, NULL, NULL, 0);</pre><p>
    Take special note of the <a class="link" href="#epoch"><quote><code class="mallctl">epoch</code></quote></a> mallctl, which controls
    refreshing of cached dynamic statistics.</p><div class="variablelist"><dl class="variablelist"><dt><a name="version"/><span class="term">
          <quote><code class="mallctl">version</code></quote>
          (<span class="type">const char *</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Return the jemalloc version string.</p></dd><dt><a name="epoch"/><span class="term">
          <quote><code class="mallctl">epoch</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>If a value is passed in, refresh the data from which
        the <code class="function">mallctl*()</code> functions report values,
        and increment the epoch.  Return the current epoch.  This is useful for
        detecting whether another thread caused a refresh.</p></dd><dt><a name="background_thread"/><span class="term">
          <quote><code class="mallctl">background_thread</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>Enable/disable internal background worker threads.  When
        set to true, background threads are created on demand (the number of
        background threads will be no more than the number of CPUs or active
        arenas).  Threads run periodically, and handle <a class="link" href="#arena.i.decay">purging</a> asynchronously.  When switching
        off, background threads are terminated synchronously.  Note that after
        <span class="citerefentry"><span class="refentrytitle">fork</span>(2)</span>
        function, the state in the child process will be disabled regardless
        the state in parent process. See <a class="link" href="#stats.background_thread.num_threads"><quote><code class="mallctl">stats.background_thread</code></quote></a>
        for related stats.  <a class="link" href="#opt.background_thread"><quote><code class="mallctl">opt.background_thread</code></quote></a>
        can be used to set the default option.  This option is only available on
        selected pthread-based platforms.</p></dd><dt><a name="max_background_threads"/><span class="term">
          <quote><code class="mallctl">max_background_threads</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>Maximum number of background worker threads that will
        be created.  This value is capped at <a class="link" href="#opt.max_background_threads"><quote><code class="mallctl">opt.max_background_threads</code></quote></a> at
        startup.</p></dd><dt><a name="config.cache_oblivious"/><span class="term">
          <quote><code class="mallctl">config.cache_oblivious</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p><code class="option">--enable-cache-oblivious</code> was specified
        during build configuration.</p></dd><dt><a name="config.debug"/><span class="term">
          <quote><code class="mallctl">config.debug</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p><code class="option">--enable-debug</code> was specified during
        build configuration.</p></dd><dt><a name="config.fill"/><span class="term">
          <quote><code class="mallctl">config.fill</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p><code class="option">--enable-fill</code> was specified during
        build configuration.</p></dd><dt><a name="config.lazy_lock"/><span class="term">
          <quote><code class="mallctl">config.lazy_lock</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p><code class="option">--enable-lazy-lock</code> was specified
        during build configuration.</p></dd><dt><a name="config.malloc_conf"/><span class="term">
          <quote><code class="mallctl">config.malloc_conf</code></quote>
          (<span class="type">const char *</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Embedded configure-time-specified run-time options
        string, empty unless <code class="option">--with-malloc-conf</code> was specified
        during build configuration.</p></dd><dt><a name="config.prof"/><span class="term">
          <quote><code class="mallctl">config.prof</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p><code class="option">--enable-prof</code> was specified during
        build configuration.</p></dd><dt><a name="config.prof_libgcc"/><span class="term">
          <quote><code class="mallctl">config.prof_libgcc</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p><code class="option">--disable-prof-libgcc</code> was not
        specified during build configuration.</p></dd><dt><a name="config.prof_libunwind"/><span class="term">
          <quote><code class="mallctl">config.prof_libunwind</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p><code class="option">--enable-prof-libunwind</code> was specified
        during build configuration.</p></dd><dt><a name="config.stats"/><span class="term">
          <quote><code class="mallctl">config.stats</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p><code class="option">--enable-stats</code> was specified during
        build configuration.</p></dd><dt><a name="config.utrace"/><span class="term">
          <quote><code class="mallctl">config.utrace</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p><code class="option">--enable-utrace</code> was specified during
        build configuration.</p></dd><dt><a name="config.xmalloc"/><span class="term">
          <quote><code class="mallctl">config.xmalloc</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p><code class="option">--enable-xmalloc</code> was specified during
        build configuration.</p></dd><dt><a name="opt.abort"/><span class="term">
          <quote><code class="mallctl">opt.abort</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Abort-on-warning enabled/disabled.  If true, most
        warnings are fatal.  Note that runtime option warnings are not included
        (see <a class="link" href="#opt.abort_conf"><quote><code class="mallctl">opt.abort_conf</code></quote></a> for
        that). The process will call
        <span class="citerefentry"><span class="refentrytitle">abort</span>(3)</span> in these cases.  This option is
        disabled by default unless <code class="option">--enable-debug</code> is
        specified during configuration, in which case it is enabled by default.
        </p></dd><dt><a name="opt.abort_conf"/><span class="term">
          <quote><code class="mallctl">opt.abort_conf</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Abort-on-invalid-configuration enabled/disabled.  If
        true, invalid runtime options are fatal.  The process will call
        <span class="citerefentry"><span class="refentrytitle">abort</span>(3)</span> in these cases.  This option is
        disabled by default unless <code class="option">--enable-debug</code> is
        specified during configuration, in which case it is enabled by default.
        </p></dd><dt><a name="opt.metadata_thp"/><span class="term">
          <quote><code class="mallctl">opt.metadata_thp</code></quote>
          (<span class="type">const char *</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Controls whether to allow jemalloc to use transparent
        huge page (THP) for internal metadata (see <a class="link" href="#stats.metadata">stats.metadata</a>).  <span class="quote">“<span class="quote">always</span>”</span>
        allows such usage.  <span class="quote">“<span class="quote">auto</span>”</span> uses no THP initially, but may
        begin to do so when metadata usage reaches certain level.  The default
        is <span class="quote">“<span class="quote">disabled</span>”</span>.</p></dd><dt><a name="opt.retain"/><span class="term">
          <quote><code class="mallctl">opt.retain</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>If true, retain unused virtual memory for later reuse
        rather than discarding it by calling
        <span class="citerefentry"><span class="refentrytitle">munmap</span>(2)</span> or equivalent (see <a class="link" href="#stats.retained">stats.retained</a> for related details).
        This option is disabled by default unless discarding virtual memory is
        known to trigger
        platform-specific performance problems, e.g. for [64-bit] Linux, which
        has a quirk in its virtual memory allocation algorithm that causes
        semi-permanent VM map holes under normal jemalloc operation.  Although
        <span class="citerefentry"><span class="refentrytitle">munmap</span>(2)</span> causes issues on 32-bit Linux as
        well, retaining virtual memory for 32-bit Linux is disabled by default
        due to the practical possibility of address space exhaustion.
        </p></dd><dt><a name="opt.dss"/><span class="term">
          <quote><code class="mallctl">opt.dss</code></quote>
          (<span class="type">const char *</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>dss (<span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span>) allocation precedence as
        related to <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span> allocation.  The following
        settings are supported if
        <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span> is supported by the operating
        system: <span class="quote">“<span class="quote">disabled</span>”</span>, <span class="quote">“<span class="quote">primary</span>”</span>, and
        <span class="quote">“<span class="quote">secondary</span>”</span>; otherwise only <span class="quote">“<span class="quote">disabled</span>”</span> is
        supported.  The default is <span class="quote">“<span class="quote">secondary</span>”</span> if
        <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span> is supported by the operating
        system; <span class="quote">“<span class="quote">disabled</span>”</span> otherwise.
        </p></dd><dt><a name="opt.narenas"/><span class="term">
          <quote><code class="mallctl">opt.narenas</code></quote>
          (<span class="type">unsigned</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Maximum number of arenas to use for automatic
        multiplexing of threads and arenas.  The default is four times the
        number of CPUs, or one if there is a single CPU.</p></dd><dt><a name="opt.percpu_arena"/><span class="term">
          <quote><code class="mallctl">opt.percpu_arena</code></quote>
          (<span class="type">const char *</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Per CPU arena mode.  Use the <span class="quote">“<span class="quote">percpu</span>”</span>
        setting to enable this feature, which uses number of CPUs to determine
        number of arenas, and bind threads to arenas dynamically based on the
        CPU the thread runs on currently.  <span class="quote">“<span class="quote">phycpu</span>”</span> setting uses
        one arena per physical CPU, which means the two hyper threads on the
        same CPU share one arena.  Note that no runtime checking regarding the
        availability of hyper threading is done at the moment.  When set to
        <span class="quote">“<span class="quote">disabled</span>”</span>, narenas and thread to arena association will
        not be impacted by this option.  The default is <span class="quote">“<span class="quote">disabled</span>”</span>.
        </p></dd><dt><a name="opt.background_thread"/><span class="term">
          <quote><code class="mallctl">opt.background_thread</code></quote>
          (<span class="type">const bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Internal background worker threads enabled/disabled.
        Because of potential circular dependencies, enabling background thread
        using this option may cause crash or deadlock during initialization. For
        a reliable way to use this feature, see <a class="link" href="#background_thread">background_thread</a> for dynamic control
        options and details.  This option is disabled by
        default.</p></dd><dt><a name="opt.max_background_threads"/><span class="term">
          <quote><code class="mallctl">opt.max_background_threads</code></quote>
          (<span class="type">const size_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Maximum number of background threads that will be created
        if <a class="link" href="#background_thread">background_thread</a> is set.
        Defaults to number of cpus.</p></dd><dt><a name="opt.dirty_decay_ms"/><span class="term">
          <quote><code class="mallctl">opt.dirty_decay_ms</code></quote>
          (<span class="type">ssize_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Approximate time in milliseconds from the creation of a
        set of unused dirty pages until an equivalent set of unused dirty pages
        is purged (i.e. converted to muzzy via e.g.
        <code class="function">madvise(<em class="parameter"><code>...</code></em><em class="parameter"><code><code class="constant">MADV_FREE</code></code></em>)</code>
        if supported by the operating system, or converted to clean otherwise)
        and/or reused.  Dirty pages are defined as previously having been
        potentially written to by the application, and therefore consuming
        physical memory, yet having no current use.  The pages are incrementally
        purged according to a sigmoidal decay curve that starts and ends with
        zero purge rate.  A decay time of 0 causes all unused dirty pages to be
        purged immediately upon creation.  A decay time of -1 disables purging.
        The default decay time is 10 seconds.  See <a class="link" href="#arenas.dirty_decay_ms"><quote><code class="mallctl">arenas.dirty_decay_ms</code></quote></a>
        and <a class="link" href="#arena.i.dirty_decay_ms"><quote><code class="mallctl">arena.&lt;i&gt;.dirty_decay_ms</code></quote></a>
        for related dynamic control options.  See <a class="link" href="#opt.muzzy_decay_ms"><quote><code class="mallctl">opt.muzzy_decay_ms</code></quote></a>
        for a description of muzzy pages.</p></dd><dt><a name="opt.muzzy_decay_ms"/><span class="term">
          <quote><code class="mallctl">opt.muzzy_decay_ms</code></quote>
          (<span class="type">ssize_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Approximate time in milliseconds from the creation of a
        set of unused muzzy pages until an equivalent set of unused muzzy pages
        is purged (i.e. converted to clean) and/or reused.  Muzzy pages are
        defined as previously having been unused dirty pages that were
        subsequently purged in a manner that left them subject to the
        reclamation whims of the operating system (e.g.
        <code class="function">madvise(<em class="parameter"><code>...</code></em><em class="parameter"><code><code class="constant">MADV_FREE</code></code></em>)</code>),
        and therefore in an indeterminate state.  The pages are incrementally
        purged according to a sigmoidal decay curve that starts and ends with
        zero purge rate.  A decay time of 0 causes all unused muzzy pages to be
        purged immediately upon creation.  A decay time of -1 disables purging.
        The default decay time is 10 seconds.  See <a class="link" href="#arenas.muzzy_decay_ms"><quote><code class="mallctl">arenas.muzzy_decay_ms</code></quote></a>
        and <a class="link" href="#arena.i.muzzy_decay_ms"><quote><code class="mallctl">arena.&lt;i&gt;.muzzy_decay_ms</code></quote></a>
        for related dynamic control options.</p></dd><dt><a name="opt.lg_extent_max_active_fit"/><span class="term">
          <quote><code class="mallctl">opt.lg_extent_max_active_fit</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>When reusing dirty extents, this determines the (log
        base 2 of the) maximum ratio between the size of the active extent
        selected (to split off from) and the size of the requested allocation.
        This prevents the splitting of large active extents for smaller
        allocations, which can reduce fragmentation over the long run
        (especially for non-active extents).  Lower value may reduce
        fragmentation, at the cost of extra active extents.  The default value
        is 6, which gives a maximum ratio of 64 (2^6).</p></dd><dt><a name="opt.stats_print"/><span class="term">
          <quote><code class="mallctl">opt.stats_print</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Enable/disable statistics printing at exit.  If
        enabled, the <code class="function">malloc_stats_print()</code>
        function is called at program exit via an
        <span class="citerefentry"><span class="refentrytitle">atexit</span>(3)</span> function.  <a class="link" href="#opt.stats_print_opts"><quote><code class="mallctl">opt.stats_print_opts</code></quote></a>
        can be combined to specify output options. If
        <code class="option">--enable-stats</code> is specified during configuration, this
        has the potential to cause deadlock for a multi-threaded process that
        exits while one or more threads are executing in the memory allocation
        functions.  Furthermore, <code class="function">atexit()</code> may
        allocate memory during application initialization and then deadlock
        internally when jemalloc in turn calls
        <code class="function">atexit()</code>, so this option is not
        universally usable (though the application can register its own
        <code class="function">atexit()</code> function with equivalent
        functionality).  Therefore, this option should only be used with care;
        it is primarily intended as a performance tuning aid during application
        development.  This option is disabled by default.</p></dd><dt><a name="opt.stats_print_opts"/><span class="term">
          <quote><code class="mallctl">opt.stats_print_opts</code></quote>
          (<span class="type">const char *</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Options (the <em class="parameter"><code>opts</code></em> string) to pass
        to the <code class="function">malloc_stats_print()</code> at exit (enabled
        through <a class="link" href="#opt.stats_print"><quote><code class="mallctl">opt.stats_print</code></quote></a>). See
        available options in <a class="link" href="#malloc_stats_print_opts"><code class="function">malloc_stats_print()</code></a>.
        Has no effect unless <a class="link" href="#opt.stats_print"><quote><code class="mallctl">opt.stats_print</code></quote></a> is
        enabled.  The default is <span class="quote">“<span class="quote"/>”</span>.</p></dd><dt><a name="opt.junk"/><span class="term">
          <quote><code class="mallctl">opt.junk</code></quote>
          (<span class="type">const char *</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-fill</code>]
        </span></dt><dd><p>Junk filling.  If set to <span class="quote">“<span class="quote">alloc</span>”</span>, each byte
        of uninitialized allocated memory will be initialized to
        <code class="literal">0xa5</code>.  If set to <span class="quote">“<span class="quote">free</span>”</span>, all deallocated
        memory will be initialized to <code class="literal">0x5a</code>.  If set to
        <span class="quote">“<span class="quote">true</span>”</span>, both allocated and deallocated memory will be
        initialized, and if set to <span class="quote">“<span class="quote">false</span>”</span>, junk filling be
        disabled entirely.  This is intended for debugging and will impact
        performance negatively.  This option is <span class="quote">“<span class="quote">false</span>”</span> by default
        unless <code class="option">--enable-debug</code> is specified during
        configuration, in which case it is <span class="quote">“<span class="quote">true</span>”</span> by
        default.</p></dd><dt><a name="opt.zero"/><span class="term">
          <quote><code class="mallctl">opt.zero</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-fill</code>]
        </span></dt><dd><p>Zero filling enabled/disabled.  If enabled, each byte
        of uninitialized allocated memory will be initialized to 0.  Note that
        this initialization only happens once for each byte, so
        <code class="function">realloc()</code> and
        <code class="function">rallocx()</code> calls do not zero memory that
        was previously allocated.  This is intended for debugging and will
        impact performance negatively.  This option is disabled by default.
        </p></dd><dt><a name="opt.utrace"/><span class="term">
          <quote><code class="mallctl">opt.utrace</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-utrace</code>]
        </span></dt><dd><p>Allocation tracing based on
        <span class="citerefentry"><span class="refentrytitle">utrace</span>(2)</span> enabled/disabled.  This option
        is disabled by default.</p></dd><dt><a name="opt.xmalloc"/><span class="term">
          <quote><code class="mallctl">opt.xmalloc</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-xmalloc</code>]
        </span></dt><dd><p>Abort-on-out-of-memory enabled/disabled.  If enabled,
        rather than returning failure for any allocation function, display a
        diagnostic message on <code class="constant">STDERR_FILENO</code> and cause the
        program to drop core (using
        <span class="citerefentry"><span class="refentrytitle">abort</span>(3)</span>).  If an application is
        designed to depend on this behavior, set the option at compile time by
        including the following in the source code:
        </p><pre class="programlisting">
malloc_conf = "xmalloc:true";</pre><p>
        This option is disabled by default.</p></dd><dt><a name="opt.tcache"/><span class="term">
          <quote><code class="mallctl">opt.tcache</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Thread-specific caching (tcache) enabled/disabled.  When
        there are multiple threads, each thread uses a tcache for objects up to
        a certain size.  Thread-specific caching allows many allocations to be
        satisfied without performing any thread synchronization, at the cost of
        increased memory use.  See the <a class="link" href="#opt.lg_tcache_max"><quote><code class="mallctl">opt.lg_tcache_max</code></quote></a>
        option for related tuning information.  This option is enabled by
        default.</p></dd><dt><a name="opt.lg_tcache_max"/><span class="term">
          <quote><code class="mallctl">opt.lg_tcache_max</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Maximum size class (log base 2) to cache in the
        thread-specific cache (tcache).  At a minimum, all small size classes
        are cached, and at a maximum all large size classes are cached.  The
        default maximum is 32 KiB (2^15).</p></dd><dt><a name="opt.thp"/><span class="term">
          <quote><code class="mallctl">opt.thp</code></quote>
          (<span class="type">const char *</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Transparent hugepage (THP) mode. Settings "always",
        "never" and "default" are available if THP is supported by the operating
        system.  The "always" setting enables transparent hugepage for all user
        memory mappings with
        <em class="parameter"><code><code class="constant">MADV_HUGEPAGE</code></code></em>; "never"
        ensures no transparent hugepage with
        <em class="parameter"><code><code class="constant">MADV_NOHUGEPAGE</code></code></em>; the default
        setting "default" makes no changes.  Note that: this option does not
        affect THP for jemalloc internal metadata (see <a class="link" href="#opt.metadata_thp"><quote><code class="mallctl">opt.metadata_thp</code></quote></a>);
        in addition, for arenas with customized <a class="link" href="#arena.i.extent_hooks"><quote><code class="mallctl">extent_hooks</code></quote></a>,
        this option is bypassed as it is implemented as part of the default
        extent hooks.</p></dd><dt><a name="opt.prof"/><span class="term">
          <quote><code class="mallctl">opt.prof</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Memory profiling enabled/disabled.  If enabled, profile
        memory allocation activity.  See the <a class="link" href="#opt.prof_active"><quote><code class="mallctl">opt.prof_active</code></quote></a>
        option for on-the-fly activation/deactivation.  See the <a class="link" href="#opt.lg_prof_sample"><quote><code class="mallctl">opt.lg_prof_sample</code></quote></a>
        option for probabilistic sampling control.  See the <a class="link" href="#opt.prof_accum"><quote><code class="mallctl">opt.prof_accum</code></quote></a>
        option for control of cumulative sample reporting.  See the <a class="link" href="#opt.lg_prof_interval"><quote><code class="mallctl">opt.lg_prof_interval</code></quote></a>
        option for information on interval-triggered profile dumping, the <a class="link" href="#opt.prof_gdump"><quote><code class="mallctl">opt.prof_gdump</code></quote></a>
        option for information on high-water-triggered profile dumping, and the
        <a class="link" href="#opt.prof_final"><quote><code class="mallctl">opt.prof_final</code></quote></a>
        option for final profile dumping.  Profile output is compatible with
        the <span class="command"><strong>jeprof</strong></span> command, which is based on the
        <span class="command"><strong>pprof</strong></span> that is developed as part of the <a class="ulink" href="http://code.google.com/p/gperftools/" target="_top">gperftools
        package</a>.  See <a class="link" href="#heap_profile_format" title="HEAP PROFILE FORMAT">HEAP PROFILE
        FORMAT</a> for heap profile format documentation.</p></dd><dt><a name="opt.prof_prefix"/><span class="term">
          <quote><code class="mallctl">opt.prof_prefix</code></quote>
          (<span class="type">const char *</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Filename prefix for profile dumps.  If the prefix is
        set to the empty string, no automatic dumps will occur; this is
        primarily useful for disabling the automatic final heap dump (which
        also disables leak reporting, if enabled).  The default prefix is
        <code class="filename">jeprof</code>.</p></dd><dt><a name="opt.prof_active"/><span class="term">
          <quote><code class="mallctl">opt.prof_active</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Profiling activated/deactivated.  This is a secondary
        control mechanism that makes it possible to start the application with
        profiling enabled (see the <a class="link" href="#opt.prof"><quote><code class="mallctl">opt.prof</code></quote></a> option) but
        inactive, then toggle profiling at any time during program execution
        with the <a class="link" href="#prof.active"><quote><code class="mallctl">prof.active</code></quote></a> mallctl.
        This option is enabled by default.</p></dd><dt><a name="opt.prof_thread_active_init"/><span class="term">
          <quote><code class="mallctl">opt.prof_thread_active_init</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Initial setting for <a class="link" href="#thread.prof.active"><quote><code class="mallctl">thread.prof.active</code></quote></a>
        in newly created threads.  The initial setting for newly created threads
        can also be changed during execution via the <a class="link" href="#prof.thread_active_init"><quote><code class="mallctl">prof.thread_active_init</code></quote></a>
        mallctl.  This option is enabled by default.</p></dd><dt><a name="opt.lg_prof_sample"/><span class="term">
          <quote><code class="mallctl">opt.lg_prof_sample</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Average interval (log base 2) between allocation
        samples, as measured in bytes of allocation activity.  Increasing the
        sampling interval decreases profile fidelity, but also decreases the
        computational overhead.  The default sample interval is 512 KiB (2^19
        B).</p></dd><dt><a name="opt.prof_accum"/><span class="term">
          <quote><code class="mallctl">opt.prof_accum</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Reporting of cumulative object/byte counts in profile
        dumps enabled/disabled.  If this option is enabled, every unique
        backtrace must be stored for the duration of execution.  Depending on
        the application, this can impose a large memory overhead, and the
        cumulative counts are not always of interest.  This option is disabled
        by default.</p></dd><dt><a name="opt.lg_prof_interval"/><span class="term">
          <quote><code class="mallctl">opt.lg_prof_interval</code></quote>
          (<span class="type">ssize_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Average interval (log base 2) between memory profile
        dumps, as measured in bytes of allocation activity.  The actual
        interval between dumps may be sporadic because decentralized allocation
        counters are used to avoid synchronization bottlenecks.  Profiles are
        dumped to files named according to the pattern
        <code class="filename">&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.i&lt;iseq&gt;.heap</code>,
        where <code class="literal">&lt;prefix&gt;</code> is controlled by the
        <a class="link" href="#opt.prof_prefix"><quote><code class="mallctl">opt.prof_prefix</code></quote></a>
        option.  By default, interval-triggered profile dumping is disabled
        (encoded as -1).
        </p></dd><dt><a name="opt.prof_gdump"/><span class="term">
          <quote><code class="mallctl">opt.prof_gdump</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Set the initial state of <a class="link" href="#prof.gdump"><quote><code class="mallctl">prof.gdump</code></quote></a>, which when
        enabled triggers a memory profile dump every time the total virtual
        memory exceeds the previous maximum.  This option is disabled by
        default.</p></dd><dt><a name="opt.prof_final"/><span class="term">
          <quote><code class="mallctl">opt.prof_final</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Use an
        <span class="citerefentry"><span class="refentrytitle">atexit</span>(3)</span> function to dump final memory
        usage to a file named according to the pattern
        <code class="filename">&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.f.heap</code>,
        where <code class="literal">&lt;prefix&gt;</code> is controlled by the <a class="link" href="#opt.prof_prefix"><quote><code class="mallctl">opt.prof_prefix</code></quote></a>
        option.  Note that <code class="function">atexit()</code> may allocate
        memory during application initialization and then deadlock internally
        when jemalloc in turn calls <code class="function">atexit()</code>, so
        this option is not universally usable (though the application can
        register its own <code class="function">atexit()</code> function with
        equivalent functionality).  This option is disabled by
        default.</p></dd><dt><a name="opt.prof_leak"/><span class="term">
          <quote><code class="mallctl">opt.prof_leak</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Leak reporting enabled/disabled.  If enabled, use an
        <span class="citerefentry"><span class="refentrytitle">atexit</span>(3)</span> function to report memory leaks
        detected by allocation sampling.  See the
        <a class="link" href="#opt.prof"><quote><code class="mallctl">opt.prof</code></quote></a> option for
        information on analyzing heap profile output.  This option is disabled
        by default.</p></dd><dt><a name="thread.arena"/><span class="term">
          <quote><code class="mallctl">thread.arena</code></quote>
          (<span class="type">unsigned</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>Get or set the arena associated with the calling
        thread.  If the specified arena was not initialized beforehand (see the
        <a class="link" href="#arena.i.initialized"><quote><code class="mallctl">arena.i.initialized</code></quote></a>
        mallctl), it will be automatically initialized as a side effect of
        calling this interface.</p></dd><dt><a name="thread.allocated"/><span class="term">
          <quote><code class="mallctl">thread.allocated</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Get the total number of bytes ever allocated by the
        calling thread.  This counter has the potential to wrap around; it is
        up to the application to appropriately interpret the counter in such
        cases.</p></dd><dt><a name="thread.allocatedp"/><span class="term">
          <quote><code class="mallctl">thread.allocatedp</code></quote>
          (<span class="type">uint64_t *</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Get a pointer to the the value that is returned by the
        <a class="link" href="#thread.allocated"><quote><code class="mallctl">thread.allocated</code></quote></a>
        mallctl.  This is useful for avoiding the overhead of repeated
        <code class="function">mallctl*()</code> calls.</p></dd><dt><a name="thread.deallocated"/><span class="term">
          <quote><code class="mallctl">thread.deallocated</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Get the total number of bytes ever deallocated by the
        calling thread.  This counter has the potential to wrap around; it is
        up to the application to appropriately interpret the counter in such
        cases.</p></dd><dt><a name="thread.deallocatedp"/><span class="term">
          <quote><code class="mallctl">thread.deallocatedp</code></quote>
          (<span class="type">uint64_t *</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Get a pointer to the the value that is returned by the
        <a class="link" href="#thread.deallocated"><quote><code class="mallctl">thread.deallocated</code></quote></a>
        mallctl.  This is useful for avoiding the overhead of repeated
        <code class="function">mallctl*()</code> calls.</p></dd><dt><a name="thread.tcache.enabled"/><span class="term">
          <quote><code class="mallctl">thread.tcache.enabled</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>Enable/disable calling thread's tcache.  The tcache is
        implicitly flushed as a side effect of becoming
        disabled (see <a class="link" href="#thread.tcache.flush"><quote><code class="mallctl">thread.tcache.flush</code></quote></a>).
        </p></dd><dt><a name="thread.tcache.flush"/><span class="term">
          <quote><code class="mallctl">thread.tcache.flush</code></quote>
          (<span class="type">void</span>)
          <code class="literal">--</code>
        </span></dt><dd><p>Flush calling thread's thread-specific cache (tcache).
        This interface releases all cached objects and internal data structures
        associated with the calling thread's tcache.  Ordinarily, this interface
        need not be called, since automatic periodic incremental garbage
        collection occurs, and the thread cache is automatically discarded when
        a thread exits.  However, garbage collection is triggered by allocation
        activity, so it is possible for a thread that stops
        allocating/deallocating to retain its cache indefinitely, in which case
        the developer may find manual flushing useful.</p></dd><dt><a name="thread.prof.name"/><span class="term">
          <quote><code class="mallctl">thread.prof.name</code></quote>
          (<span class="type">const char *</span>)
          <code class="literal">r-</code> or
          <code class="literal">-w</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Get/set the descriptive name associated with the calling
        thread in memory profile dumps.  An internal copy of the name string is
        created, so the input string need not be maintained after this interface
        completes execution.  The output string of this interface should be
        copied for non-ephemeral uses, because multiple implementation details
        can cause asynchronous string deallocation.  Furthermore, each
        invocation of this interface can only read or write; simultaneous
        read/write is not supported due to string lifetime limitations.  The
        name string must be nil-terminated and comprised only of characters in
        the sets recognized
        by <span class="citerefentry"><span class="refentrytitle">isgraph</span>(3)</span> and
        <span class="citerefentry"><span class="refentrytitle">isblank</span>(3)</span>.</p></dd><dt><a name="thread.prof.active"/><span class="term">
          <quote><code class="mallctl">thread.prof.active</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">rw</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Control whether sampling is currently active for the
        calling thread.  This is an activation mechanism in addition to <a class="link" href="#prof.active"><quote><code class="mallctl">prof.active</code></quote></a>; both must
        be active for the calling thread to sample.  This flag is enabled by
        default.</p></dd><dt><a name="tcache.create"/><span class="term">
          <quote><code class="mallctl">tcache.create</code></quote>
          (<span class="type">unsigned</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Create an explicit thread-specific cache (tcache) and
        return an identifier that can be passed to the <a class="link" href="#MALLOCX_TCACHE"><code class="constant">MALLOCX_TCACHE(<em class="parameter"><code>tc</code></em>)</code></a>
        macro to explicitly use the specified cache rather than the
        automatically managed one that is used by default.  Each explicit cache
        can be used by only one thread at a time; the application must assure
        that this constraint holds.
        </p></dd><dt><a name="tcache.flush"/><span class="term">
          <quote><code class="mallctl">tcache.flush</code></quote>
          (<span class="type">unsigned</span>)
          <code class="literal">-w</code>
        </span></dt><dd><p>Flush the specified thread-specific cache (tcache).  The
        same considerations apply to this interface as to <a class="link" href="#thread.tcache.flush"><quote><code class="mallctl">thread.tcache.flush</code></quote></a>,
        except that the tcache will never be automatically discarded.
        </p></dd><dt><a name="tcache.destroy"/><span class="term">
          <quote><code class="mallctl">tcache.destroy</code></quote>
          (<span class="type">unsigned</span>)
          <code class="literal">-w</code>
        </span></dt><dd><p>Flush the specified thread-specific cache (tcache) and
        make the identifier available for use during a future tcache creation.
        </p></dd><dt><a name="arena.i.initialized"/><span class="term">
          <quote><code class="mallctl">arena.&lt;i&gt;.initialized</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Get whether the specified arena's statistics are
        initialized (i.e. the arena was initialized prior to the current epoch).
        This interface can also be nominally used to query whether the merged
        statistics corresponding to <code class="constant">MALLCTL_ARENAS_ALL</code> are
        initialized (always true).</p></dd><dt><a name="arena.i.decay"/><span class="term">
          <quote><code class="mallctl">arena.&lt;i&gt;.decay</code></quote>
          (<span class="type">void</span>)
          <code class="literal">--</code>
        </span></dt><dd><p>Trigger decay-based purging of unused dirty/muzzy pages
        for arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals
        <code class="constant">MALLCTL_ARENAS_ALL</code>.  The proportion of unused
        dirty/muzzy pages to be purged depends on the current time; see <a class="link" href="#opt.dirty_decay_ms"><quote><code class="mallctl">opt.dirty_decay_ms</code></quote></a>
        and <a class="link" href="#opt.muzzy_decay_ms"><quote><code class="mallctl">opt.muzy_decay_ms</code></quote></a>
        for details.</p></dd><dt><a name="arena.i.purge"/><span class="term">
          <quote><code class="mallctl">arena.&lt;i&gt;.purge</code></quote>
          (<span class="type">void</span>)
          <code class="literal">--</code>
        </span></dt><dd><p>Purge all unused dirty pages for arena &lt;i&gt;, or for
        all arenas if &lt;i&gt; equals <code class="constant">MALLCTL_ARENAS_ALL</code>.
        </p></dd><dt><a name="arena.i.reset"/><span class="term">
          <quote><code class="mallctl">arena.&lt;i&gt;.reset</code></quote>
          (<span class="type">void</span>)
          <code class="literal">--</code>
        </span></dt><dd><p>Discard all of the arena's extant allocations.  This
        interface can only be used with arenas explicitly created via <a class="link" href="#arenas.create"><quote><code class="mallctl">arenas.create</code></quote></a>.  None
        of the arena's discarded/cached allocations may accessed afterward.  As
        part of this requirement, all thread caches which were used to
        allocate/deallocate in conjunction with the arena must be flushed
        beforehand.</p></dd><dt><a name="arena.i.destroy"/><span class="term">
          <quote><code class="mallctl">arena.&lt;i&gt;.destroy</code></quote>
          (<span class="type">void</span>)
          <code class="literal">--</code>
        </span></dt><dd><p>Destroy the arena.  Discard all of the arena's extant
        allocations using the same mechanism as for <a class="link" href="#arena.i.reset"><quote><code class="mallctl">arena.&lt;i&gt;.reset</code></quote></a>
        (with all the same constraints and side effects), merge the arena stats
        into those accessible at arena index
        <code class="constant">MALLCTL_ARENAS_DESTROYED</code>, and then completely
        discard all metadata associated with the arena.  Future calls to <a class="link" href="#arenas.create"><quote><code class="mallctl">arenas.create</code></quote></a> may
        recycle the arena index.  Destruction will fail if any threads are
        currently associated with the arena as a result of calls to <a class="link" href="#thread.arena"><quote><code class="mallctl">thread.arena</code></quote></a>.</p></dd><dt><a name="arena.i.dss"/><span class="term">
          <quote><code class="mallctl">arena.&lt;i&gt;.dss</code></quote>
          (<span class="type">const char *</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>Set the precedence of dss allocation as related to mmap
        allocation for arena &lt;i&gt;, or for all arenas if &lt;i&gt; equals
        <code class="constant">MALLCTL_ARENAS_ALL</code>.  See <a class="link" href="#opt.dss"><quote><code class="mallctl">opt.dss</code></quote></a> for supported
        settings.</p></dd><dt><a name="arena.i.dirty_decay_ms"/><span class="term">
          <quote><code class="mallctl">arena.&lt;i&gt;.dirty_decay_ms</code></quote>
          (<span class="type">ssize_t</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>Current per-arena approximate time in milliseconds from
        the creation of a set of unused dirty pages until an equivalent set of
        unused dirty pages is purged and/or reused.  Each time this interface is
        set, all currently unused dirty pages are considered to have fully
        decayed, which causes immediate purging of all unused dirty pages unless
        the decay time is set to -1 (i.e. purging disabled).  See <a class="link" href="#opt.dirty_decay_ms"><quote><code class="mallctl">opt.dirty_decay_ms</code></quote></a>
        for additional information.</p></dd><dt><a name="arena.i.muzzy_decay_ms"/><span class="term">
          <quote><code class="mallctl">arena.&lt;i&gt;.muzzy_decay_ms</code></quote>
          (<span class="type">ssize_t</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>Current per-arena approximate time in milliseconds from
        the creation of a set of unused muzzy pages until an equivalent set of
        unused muzzy pages is purged and/or reused.  Each time this interface is
        set, all currently unused muzzy pages are considered to have fully
        decayed, which causes immediate purging of all unused muzzy pages unless
        the decay time is set to -1 (i.e. purging disabled).  See <a class="link" href="#opt.muzzy_decay_ms"><quote><code class="mallctl">opt.muzzy_decay_ms</code></quote></a>
        for additional information.</p></dd><dt><a name="arena.i.retain_grow_limit"/><span class="term">
          <quote><code class="mallctl">arena.&lt;i&gt;.retain_grow_limit</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>Maximum size to grow retained region (only relevant when
        <a class="link" href="#opt.retain"><quote><code class="mallctl">opt.retain</code></quote></a> is
        enabled).  This controls the maximum increment to expand virtual memory,
        or allocation through <a class="link" href="#arena.i.extent_hooks"><quote><code class="mallctl">arena.&lt;i&gt;extent_hooks</code></quote></a>.
        In particular, if customized extent hooks reserve physical memory
        (e.g. 1G huge pages), this is useful to control the allocation hook's
        input size.  The default is no limit.</p></dd><dt><a name="arena.i.extent_hooks"/><span class="term">
          <quote><code class="mallctl">arena.&lt;i&gt;.extent_hooks</code></quote>
          (<span class="type">extent_hooks_t *</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>Get or set the extent management hook functions for
        arena &lt;i&gt;.  The functions must be capable of operating on all
        extant extents associated with arena &lt;i&gt;, usually by passing
        unknown extents to the replaced functions.  In practice, it is feasible
        to control allocation for arenas explicitly created via <a class="link" href="#arenas.create"><quote><code class="mallctl">arenas.create</code></quote></a> such
        that all extents originate from an application-supplied extent allocator
        (by specifying the custom extent hook functions during arena creation),
        but the automatically created arenas will have already created extents
        prior to the application having an opportunity to take over extent
        allocation.</p><pre class="programlisting">
typedef extent_hooks_s extent_hooks_t;
struct extent_hooks_s {
	extent_alloc_t		*alloc;
	extent_dalloc_t		*dalloc;
	extent_destroy_t	*destroy;
	extent_commit_t		*commit;
	extent_decommit_t	*decommit;
	extent_purge_t		*purge_lazy;
	extent_purge_t		*purge_forced;
	extent_split_t		*split;
	extent_merge_t		*merge;
};</pre><p>The <span class="type">extent_hooks_t</span> structure comprises function
        pointers which are described individually below.  jemalloc uses these
        functions to manage extent lifetime, which starts off with allocation of
        mapped committed memory, in the simplest case followed by deallocation.
        However, there are performance and platform reasons to retain extents
        for later reuse.  Cleanup attempts cascade from deallocation to decommit
        to forced purging to lazy purging, which gives the extent management
        functions opportunities to reject the most permanent cleanup operations
        in favor of less permanent (and often less costly) operations.  All
        operations except allocation can be universally opted out of by setting
        the hook pointers to <code class="constant">NULL</code>, or selectively opted out
        of by returning failure.  Note that once the extent hook is set, the
        structure is accessed directly by the associated arenas, so it must
        remain valid for the entire lifetime of the arenas.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef void *<b class="fsfunc">(extent_alloc_t)</b>(</code></td><td>extent_hooks_t *<var class="pdparam">extent_hooks</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">new_addr</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">alignment</var>, </td></tr><tr><td> </td><td>bool *<var class="pdparam">zero</var>, </td></tr><tr><td> </td><td>bool *<var class="pdparam">commit</var>, </td></tr><tr><td> </td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="literallayout"><p/></div><p>An extent allocation function conforms to the
        <span class="type">extent_alloc_t</span> type and upon success returns a pointer to
        <em class="parameter"><code>size</code></em> bytes of mapped memory on behalf of arena
        <em class="parameter"><code>arena_ind</code></em> such that the extent's base address is
        a multiple of <em class="parameter"><code>alignment</code></em>, as well as setting
        <em class="parameter"><code>*zero</code></em> to indicate whether the extent is zeroed
        and <em class="parameter"><code>*commit</code></em> to indicate whether the extent is
        committed.  Upon error the function returns <code class="constant">NULL</code>
        and leaves <em class="parameter"><code>*zero</code></em> and
        <em class="parameter"><code>*commit</code></em> unmodified.  The
        <em class="parameter"><code>size</code></em> parameter is always a multiple of the page
        size.  The <em class="parameter"><code>alignment</code></em> parameter is always a power
        of two at least as large as the page size.  Zeroing is mandatory if
        <em class="parameter"><code>*zero</code></em> is true upon function entry.  Committing is
        mandatory if <em class="parameter"><code>*commit</code></em> is true upon function entry.
        If <em class="parameter"><code>new_addr</code></em> is not <code class="constant">NULL</code>, the
        returned pointer must be <em class="parameter"><code>new_addr</code></em> on success or
        <code class="constant">NULL</code> on error.  Committed memory may be committed
        in absolute terms as on a system that does not overcommit, or in
        implicit terms as on a system that overcommits and satisfies physical
        memory needs on demand via soft page faults.  Note that replacing the
        default extent allocation function makes the arena's <a class="link" href="#arena.i.dss"><quote><code class="mallctl">arena.&lt;i&gt;.dss</code></quote></a>
        setting irrelevant.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(extent_dalloc_t)</b>(</code></td><td>extent_hooks_t *<var class="pdparam">extent_hooks</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">addr</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td> </td><td>bool <var class="pdparam">committed</var>, </td></tr><tr><td> </td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="literallayout"><p/></div><p>
        An extent deallocation function conforms to the
        <span class="type">extent_dalloc_t</span> type and deallocates an extent at given
        <em class="parameter"><code>addr</code></em> and <em class="parameter"><code>size</code></em> with
        <em class="parameter"><code>committed</code></em>/decommited memory as indicated, on
        behalf of arena <em class="parameter"><code>arena_ind</code></em>, returning false upon
        success.  If the function returns true, this indicates opt-out from
        deallocation; the virtual memory mapping associated with the extent
        remains mapped, in the same commit state, and available for future use,
        in which case it will be automatically retained for later reuse.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef void <b class="fsfunc">(extent_destroy_t)</b>(</code></td><td>extent_hooks_t *<var class="pdparam">extent_hooks</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">addr</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td> </td><td>bool <var class="pdparam">committed</var>, </td></tr><tr><td> </td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="literallayout"><p/></div><p>
        An extent destruction function conforms to the
        <span class="type">extent_destroy_t</span> type and unconditionally destroys an
        extent at given <em class="parameter"><code>addr</code></em> and
        <em class="parameter"><code>size</code></em> with
        <em class="parameter"><code>committed</code></em>/decommited memory as indicated, on
        behalf of arena <em class="parameter"><code>arena_ind</code></em>.  This function may be
        called to destroy retained extents during arena destruction (see <a class="link" href="#arena.i.destroy"><quote><code class="mallctl">arena.&lt;i&gt;.destroy</code></quote></a>).</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(extent_commit_t)</b>(</code></td><td>extent_hooks_t *<var class="pdparam">extent_hooks</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">addr</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">offset</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">length</var>, </td></tr><tr><td> </td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="literallayout"><p/></div><p>An extent commit function conforms to the
        <span class="type">extent_commit_t</span> type and commits zeroed physical memory to
        back pages within an extent at given <em class="parameter"><code>addr</code></em> and
        <em class="parameter"><code>size</code></em> at <em class="parameter"><code>offset</code></em> bytes,
        extending for <em class="parameter"><code>length</code></em> on behalf of arena
        <em class="parameter"><code>arena_ind</code></em>, returning false upon success.
        Committed memory may be committed in absolute terms as on a system that
        does not overcommit, or in implicit terms as on a system that
        overcommits and satisfies physical memory needs on demand via soft page
        faults. If the function returns true, this indicates insufficient
        physical memory to satisfy the request.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(extent_decommit_t)</b>(</code></td><td>extent_hooks_t *<var class="pdparam">extent_hooks</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">addr</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">offset</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">length</var>, </td></tr><tr><td> </td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="literallayout"><p/></div><p>An extent decommit function conforms to the
        <span class="type">extent_decommit_t</span> type and decommits any physical memory
        that is backing pages within an extent at given
        <em class="parameter"><code>addr</code></em> and <em class="parameter"><code>size</code></em> at
        <em class="parameter"><code>offset</code></em> bytes, extending for
        <em class="parameter"><code>length</code></em> on behalf of arena
        <em class="parameter"><code>arena_ind</code></em>, returning false upon success, in which
        case the pages will be committed via the extent commit function before
        being reused.  If the function returns true, this indicates opt-out from
        decommit; the memory remains committed and available for future use, in
        which case it will be automatically retained for later reuse.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(extent_purge_t)</b>(</code></td><td>extent_hooks_t *<var class="pdparam">extent_hooks</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">addr</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">offset</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">length</var>, </td></tr><tr><td> </td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="literallayout"><p/></div><p>An extent purge function conforms to the
        <span class="type">extent_purge_t</span> type and discards physical pages
        within the virtual memory mapping associated with an extent at given
        <em class="parameter"><code>addr</code></em> and <em class="parameter"><code>size</code></em> at
        <em class="parameter"><code>offset</code></em> bytes, extending for
        <em class="parameter"><code>length</code></em> on behalf of arena
        <em class="parameter"><code>arena_ind</code></em>.  A lazy extent purge function (e.g.
        implemented via
        <code class="function">madvise(<em class="parameter"><code>...</code></em><em class="parameter"><code><code class="constant">MADV_FREE</code></code></em>)</code>)
        can delay purging indefinitely and leave the pages within the purged
        virtual memory range in an indeterminite state, whereas a forced extent
        purge function immediately purges, and the pages within the virtual
        memory range will be zero-filled the next time they are accessed.  If
        the function returns true, this indicates failure to purge.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(extent_split_t)</b>(</code></td><td>extent_hooks_t *<var class="pdparam">extent_hooks</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">addr</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size_a</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size_b</var>, </td></tr><tr><td> </td><td>bool <var class="pdparam">committed</var>, </td></tr><tr><td> </td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="literallayout"><p/></div><p>An extent split function conforms to the
        <span class="type">extent_split_t</span> type and optionally splits an extent at
        given <em class="parameter"><code>addr</code></em> and <em class="parameter"><code>size</code></em> into
        two adjacent extents, the first of <em class="parameter"><code>size_a</code></em> bytes,
        and the second of <em class="parameter"><code>size_b</code></em> bytes, operating on
        <em class="parameter"><code>committed</code></em>/decommitted memory as indicated, on
        behalf of arena <em class="parameter"><code>arena_ind</code></em>, returning false upon
        success.  If the function returns true, this indicates that the extent
        remains unsplit and therefore should continue to be operated on as a
        whole.</p><div class="funcsynopsis"><table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">typedef bool <b class="fsfunc">(extent_merge_t)</b>(</code></td><td>extent_hooks_t *<var class="pdparam">extent_hooks</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">addr_a</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size_a</var>, </td></tr><tr><td> </td><td>void *<var class="pdparam">addr_b</var>, </td></tr><tr><td> </td><td>size_t <var class="pdparam">size_b</var>, </td></tr><tr><td> </td><td>bool <var class="pdparam">committed</var>, </td></tr><tr><td> </td><td>unsigned <var class="pdparam">arena_ind</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer"> </div></div><div class="literallayout"><p/></div><p>An extent merge function conforms to the
        <span class="type">extent_merge_t</span> type and optionally merges adjacent extents,
        at given <em class="parameter"><code>addr_a</code></em> and <em class="parameter"><code>size_a</code></em>
        with given <em class="parameter"><code>addr_b</code></em> and
        <em class="parameter"><code>size_b</code></em> into one contiguous extent, operating on
        <em class="parameter"><code>committed</code></em>/decommitted memory as indicated, on
        behalf of arena <em class="parameter"><code>arena_ind</code></em>, returning false upon
        success.  If the function returns true, this indicates that the extents
        remain distinct mappings and therefore should continue to be operated on
        independently.</p></dd><dt><a name="arenas.narenas"/><span class="term">
          <quote><code class="mallctl">arenas.narenas</code></quote>
          (<span class="type">unsigned</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Current limit on number of arenas.</p></dd><dt><a name="arenas.dirty_decay_ms"/><span class="term">
          <quote><code class="mallctl">arenas.dirty_decay_ms</code></quote>
          (<span class="type">ssize_t</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>Current default per-arena approximate time in
        milliseconds from the creation of a set of unused dirty pages until an
        equivalent set of unused dirty pages is purged and/or reused, used to
        initialize <a class="link" href="#arena.i.dirty_decay_ms"><quote><code class="mallctl">arena.&lt;i&gt;.dirty_decay_ms</code></quote></a>
        during arena creation.  See <a class="link" href="#opt.dirty_decay_ms"><quote><code class="mallctl">opt.dirty_decay_ms</code></quote></a>
        for additional information.</p></dd><dt><a name="arenas.muzzy_decay_ms"/><span class="term">
          <quote><code class="mallctl">arenas.muzzy_decay_ms</code></quote>
          (<span class="type">ssize_t</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>Current default per-arena approximate time in
        milliseconds from the creation of a set of unused muzzy pages until an
        equivalent set of unused muzzy pages is purged and/or reused, used to
        initialize <a class="link" href="#arena.i.muzzy_decay_ms"><quote><code class="mallctl">arena.&lt;i&gt;.muzzy_decay_ms</code></quote></a>
        during arena creation.  See <a class="link" href="#opt.muzzy_decay_ms"><quote><code class="mallctl">opt.muzzy_decay_ms</code></quote></a>
        for additional information.</p></dd><dt><a name="arenas.quantum"/><span class="term">
          <quote><code class="mallctl">arenas.quantum</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Quantum size.</p></dd><dt><a name="arenas.page"/><span class="term">
          <quote><code class="mallctl">arenas.page</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Page size.</p></dd><dt><a name="arenas.tcache_max"/><span class="term">
          <quote><code class="mallctl">arenas.tcache_max</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Maximum thread-cached size class.</p></dd><dt><a name="arenas.nbins"/><span class="term">
          <quote><code class="mallctl">arenas.nbins</code></quote>
          (<span class="type">unsigned</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Number of bin size classes.</p></dd><dt><a name="arenas.nhbins"/><span class="term">
          <quote><code class="mallctl">arenas.nhbins</code></quote>
          (<span class="type">unsigned</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Total number of thread cache bin size
        classes.</p></dd><dt><a name="arenas.bin.i.size"/><span class="term">
          <quote><code class="mallctl">arenas.bin.&lt;i&gt;.size</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Maximum size supported by size class.</p></dd><dt><a name="arenas.bin.i.nregs"/><span class="term">
          <quote><code class="mallctl">arenas.bin.&lt;i&gt;.nregs</code></quote>
          (<span class="type">uint32_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Number of regions per slab.</p></dd><dt><a name="arenas.bin.i.slab_size"/><span class="term">
          <quote><code class="mallctl">arenas.bin.&lt;i&gt;.slab_size</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Number of bytes per slab.</p></dd><dt><a name="arenas.nlextents"/><span class="term">
          <quote><code class="mallctl">arenas.nlextents</code></quote>
          (<span class="type">unsigned</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Total number of large size classes.</p></dd><dt><a name="arenas.lextent.i.size"/><span class="term">
          <quote><code class="mallctl">arenas.lextent.&lt;i&gt;.size</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Maximum size supported by this large size
        class.</p></dd><dt><a name="arenas.create"/><span class="term">
          <quote><code class="mallctl">arenas.create</code></quote>
          (<span class="type">unsigned</span>, <span class="type">extent_hooks_t *</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>Explicitly create a new arena outside the range of
        automatically managed arenas, with optionally specified extent hooks,
        and return the new arena index.</p></dd><dt><a name="arenas.lookup"/><span class="term">
          <quote><code class="mallctl">arenas.lookup</code></quote>
          (<span class="type">unsigned</span>, <span class="type">void*</span>)
          <code class="literal">rw</code>
        </span></dt><dd><p>Index of the arena to which an allocation belongs to.</p></dd><dt><a name="prof.thread_active_init"/><span class="term">
          <quote><code class="mallctl">prof.thread_active_init</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">rw</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Control the initial setting for <a class="link" href="#thread.prof.active"><quote><code class="mallctl">thread.prof.active</code></quote></a>
        in newly created threads.  See the <a class="link" href="#opt.prof_thread_active_init"><quote><code class="mallctl">opt.prof_thread_active_init</code></quote></a>
        option for additional information.</p></dd><dt><a name="prof.active"/><span class="term">
          <quote><code class="mallctl">prof.active</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">rw</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Control whether sampling is currently active.  See the
        <a class="link" href="#opt.prof_active"><quote><code class="mallctl">opt.prof_active</code></quote></a>
        option for additional information, as well as the interrelated <a class="link" href="#thread.prof.active"><quote><code class="mallctl">thread.prof.active</code></quote></a>
        mallctl.</p></dd><dt><a name="prof.dump"/><span class="term">
          <quote><code class="mallctl">prof.dump</code></quote>
          (<span class="type">const char *</span>)
          <code class="literal">-w</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Dump a memory profile to the specified file, or if NULL
        is specified, to a file according to the pattern
        <code class="filename">&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.m&lt;mseq&gt;.heap</code>,
        where <code class="literal">&lt;prefix&gt;</code> is controlled by the
        <a class="link" href="#opt.prof_prefix"><quote><code class="mallctl">opt.prof_prefix</code></quote></a>
        option.</p></dd><dt><a name="prof.gdump"/><span class="term">
          <quote><code class="mallctl">prof.gdump</code></quote>
          (<span class="type">bool</span>)
          <code class="literal">rw</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>When enabled, trigger a memory profile dump every time
        the total virtual memory exceeds the previous maximum.  Profiles are
        dumped to files named according to the pattern
        <code class="filename">&lt;prefix&gt;.&lt;pid&gt;.&lt;seq&gt;.u&lt;useq&gt;.heap</code>,
        where <code class="literal">&lt;prefix&gt;</code> is controlled by the <a class="link" href="#opt.prof_prefix"><quote><code class="mallctl">opt.prof_prefix</code></quote></a>
        option.</p></dd><dt><a name="prof.reset"/><span class="term">
          <quote><code class="mallctl">prof.reset</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">-w</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Reset all memory profile statistics, and optionally
        update the sample rate (see <a class="link" href="#opt.lg_prof_sample"><quote><code class="mallctl">opt.lg_prof_sample</code></quote></a>
        and <a class="link" href="#prof.lg_sample"><quote><code class="mallctl">prof.lg_sample</code></quote></a>).
        </p></dd><dt><a name="prof.lg_sample"/><span class="term">
          <quote><code class="mallctl">prof.lg_sample</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Get the current sample rate (see <a class="link" href="#opt.lg_prof_sample"><quote><code class="mallctl">opt.lg_prof_sample</code></quote></a>).
        </p></dd><dt><a name="prof.interval"/><span class="term">
          <quote><code class="mallctl">prof.interval</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-prof</code>]
        </span></dt><dd><p>Average number of bytes allocated between
        interval-based profile dumps.  See the
        <a class="link" href="#opt.lg_prof_interval"><quote><code class="mallctl">opt.lg_prof_interval</code></quote></a>
        option for additional information.</p></dd><dt><a name="stats.allocated"/><span class="term">
          <quote><code class="mallctl">stats.allocated</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Total number of bytes allocated by the
        application.</p></dd><dt><a name="stats.active"/><span class="term">
          <quote><code class="mallctl">stats.active</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Total number of bytes in active pages allocated by the
        application.  This is a multiple of the page size, and greater than or
        equal to <a class="link" href="#stats.allocated"><quote><code class="mallctl">stats.allocated</code></quote></a>.
        This does not include <a class="link" href="#stats.arenas.i.pdirty">
        <quote><code class="mallctl">stats.arenas.&lt;i&gt;.pdirty</code></quote></a>,
        <a class="link" href="#stats.arenas.i.pmuzzy">
        <quote><code class="mallctl">stats.arenas.&lt;i&gt;.pmuzzy</code></quote></a>, nor pages
        entirely devoted to allocator metadata.</p></dd><dt><a name="stats.metadata"/><span class="term">
          <quote><code class="mallctl">stats.metadata</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Total number of bytes dedicated to metadata, which
        comprise base allocations used for bootstrap-sensitive allocator
        metadata structures (see <a class="link" href="#stats.arenas.i.base"><quote><code class="mallctl">stats.arenas.&lt;i&gt;.base</code></quote></a>)
        and internal allocations (see <a class="link" href="#stats.arenas.i.internal"><quote><code class="mallctl">stats.arenas.&lt;i&gt;.internal</code></quote></a>).
        Transparent huge page (enabled with <a class="link" href="#opt.metadata_thp">opt.metadata_thp</a>) usage is not
        considered.</p></dd><dt><a name="stats.metadata_thp"/><span class="term">
          <quote><code class="mallctl">stats.metadata_thp</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Number of transparent huge pages (THP) used for
        metadata.  See <a class="link" href="#stats.metadata"><quote><code class="mallctl">stats.metadata</code></quote></a> and
        <a class="link" href="#opt.metadata_thp">opt.metadata_thp</a>) for
        details.</p></dd><dt><a name="stats.resident"/><span class="term">
          <quote><code class="mallctl">stats.resident</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Maximum number of bytes in physically resident data
        pages mapped by the allocator, comprising all pages dedicated to
        allocator metadata, pages backing active allocations, and unused dirty
        pages.  This is a maximum rather than precise because pages may not
        actually be physically resident if they correspond to demand-zeroed
        virtual memory that has not yet been touched.  This is a multiple of the
        page size, and is larger than <a class="link" href="#stats.active"><quote><code class="mallctl">stats.active</code></quote></a>.</p></dd><dt><a name="stats.mapped"/><span class="term">
          <quote><code class="mallctl">stats.mapped</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Total number of bytes in active extents mapped by the
        allocator.  This is larger than <a class="link" href="#stats.active"><quote><code class="mallctl">stats.active</code></quote></a>.  This
        does not include inactive extents, even those that contain unused dirty
        pages, which means that there is no strict ordering between this and
        <a class="link" href="#stats.resident"><quote><code class="mallctl">stats.resident</code></quote></a>.</p></dd><dt><a name="stats.retained"/><span class="term">
          <quote><code class="mallctl">stats.retained</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Total number of bytes in virtual memory mappings that
        were retained rather than being returned to the operating system via
        e.g. <span class="citerefentry"><span class="refentrytitle">munmap</span>(2)</span> or similar.  Retained virtual
        memory is typically untouched, decommitted, or purged, so it has no
        strongly associated physical memory (see <a class="link" href="#arena.i.extent_hooks">extent hooks</a> for details).
        Retained memory is excluded from mapped memory statistics, e.g. <a class="link" href="#stats.mapped"><quote><code class="mallctl">stats.mapped</code></quote></a>.
        </p></dd><dt><a name="stats.background_thread.num_threads"/><span class="term">
          <quote><code class="mallctl">stats.background_thread.num_threads</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p> Number of <a class="link" href="#background_thread">background
        threads</a> running currently.</p></dd><dt><a name="stats.background_thread.num_runs"/><span class="term">
          <quote><code class="mallctl">stats.background_thread.num_runs</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p> Total number of runs from all <a class="link" href="#background_thread">background threads</a>.</p></dd><dt><a name="stats.background_thread.run_interval"/><span class="term">
          <quote><code class="mallctl">stats.background_thread.run_interval</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p> Average run interval in nanoseconds of <a class="link" href="#background_thread">background threads</a>.</p></dd><dt><a name="stats.mutexes.ctl"/><span class="term">
          <quote><code class="mallctl">stats.mutexes.ctl.{counter};</code></quote>
          (<span class="type">counter specific type</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Statistics on <code class="varname">ctl</code> mutex (global
        scope; mallctl related).  <quote><code class="mallctl">{counter}</code></quote> is one of the
        counters below:</p><dt><a name="mutex_counters"/></dt><dd><p><code class="varname">num_ops</code> (<span class="type">uint64_t</span>):
          Total number of lock acquisition operations on this mutex.</p><p><code class="varname">num_spin_acq</code> (<span class="type">uint64_t</span>): Number
	  of times the mutex was spin-acquired.  When the mutex is currently
	  locked and cannot be acquired immediately, a short period of
	  spin-retry within jemalloc will be performed.  Acquired through spin
	  generally means the contention was lightweight and not causing context
	  switches.</p><p><code class="varname">num_wait</code> (<span class="type">uint64_t</span>): Number of
	  times the mutex was wait-acquired, which means the mutex contention
	  was not solved by spin-retry, and blocking operation was likely
	  involved in order to acquire the mutex.  This event generally implies
	  higher cost / longer delay, and should be investigated if it happens
	  often.</p><p><code class="varname">max_wait_time</code> (<span class="type">uint64_t</span>):
	  Maximum length of time in nanoseconds spent on a single wait-acquired
	  lock operation.  Note that to avoid profiling overhead on the common
	  path, this does not consider spin-acquired cases.</p><p><code class="varname">total_wait_time</code> (<span class="type">uint64_t</span>):
	  Cumulative time in nanoseconds spent on wait-acquired lock operations.
	  Similarly, spin-acquired cases are not considered.</p><p><code class="varname">max_num_thds</code> (<span class="type">uint32_t</span>): Maximum
	  number of threads waiting on this mutex simultaneously.  Similarly,
	  spin-acquired cases are not considered.</p><p><code class="varname">num_owner_switch</code> (<span class="type">uint64_t</span>):
	  Number of times the current mutex owner is different from the previous
	  one.  This event does not generally imply an issue; rather it is an
	  indicator of how often the protected data are accessed by different
	  threads.
	  </p></dd></dd><dt><a name="stats.mutexes.background_thread"/><span class="term">
          <quote><code class="mallctl">stats.mutexes.background_thread.{counter}</code></quote>
	  (<span class="type">counter specific type</span>) <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Statistics on <code class="varname">background_thread</code> mutex
        (global scope; <a class="link" href="#background_thread"><quote><code class="mallctl">background_thread</code></quote></a>
        related).  <quote><code class="mallctl">{counter}</code></quote> is one of the counters in <a class="link" href="#mutex_counters">mutex profiling
        counters</a>.</p></dd><dt><a name="stats.mutexes.prof"/><span class="term">
          <quote><code class="mallctl">stats.mutexes.prof.{counter}</code></quote>
	  (<span class="type">counter specific type</span>) <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Statistics on <code class="varname">prof</code> mutex (global
        scope; profiling related).  <quote><code class="mallctl">{counter}</code></quote> is one of the
        counters in <a class="link" href="#mutex_counters">mutex profiling
        counters</a>.</p></dd><dt><a name="stats.mutexes.reset"/><span class="term">
          <quote><code class="mallctl">stats.mutexes.reset</code></quote>
	  (<span class="type">void</span>) <code class="literal">--</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Reset all mutex profile statistics, including global
        mutexes, arena mutexes and bin mutexes.</p></dd><dt><a name="stats.arenas.i.dss"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.dss</code></quote>
          (<span class="type">const char *</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>dss (<span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span>) allocation precedence as
        related to <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span> allocation.  See <a class="link" href="#opt.dss"><quote><code class="mallctl">opt.dss</code></quote></a> for details.
        </p></dd><dt><a name="stats.arenas.i.dirty_decay_ms"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.dirty_decay_ms</code></quote>
          (<span class="type">ssize_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Approximate time in milliseconds from the creation of a
        set of unused dirty pages until an equivalent set of unused dirty pages
        is purged and/or reused.  See <a class="link" href="#opt.dirty_decay_ms"><quote><code class="mallctl">opt.dirty_decay_ms</code></quote></a>
        for details.</p></dd><dt><a name="stats.arenas.i.muzzy_decay_ms"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.muzzy_decay_ms</code></quote>
          (<span class="type">ssize_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Approximate time in milliseconds from the creation of a
        set of unused muzzy pages until an equivalent set of unused muzzy pages
        is purged and/or reused.  See <a class="link" href="#opt.muzzy_decay_ms"><quote><code class="mallctl">opt.muzzy_decay_ms</code></quote></a>
        for details.</p></dd><dt><a name="stats.arenas.i.nthreads"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.nthreads</code></quote>
          (<span class="type">unsigned</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Number of threads currently assigned to
        arena.</p></dd><dt><a name="stats.arenas.i.uptime"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.uptime</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Time elapsed (in nanoseconds) since the arena was
        created.  If &lt;i&gt; equals <code class="constant">0</code> or
        <code class="constant">MALLCTL_ARENAS_ALL</code>, this is the uptime since malloc
        initialization.</p></dd><dt><a name="stats.arenas.i.pactive"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.pactive</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Number of pages in active extents.</p></dd><dt><a name="stats.arenas.i.pdirty"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.pdirty</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Number of pages within unused extents that are
        potentially dirty, and for which <code class="function">madvise()</code> or
        similar has not been called.  See <a class="link" href="#opt.dirty_decay_ms"><quote><code class="mallctl">opt.dirty_decay_ms</code></quote></a>
        for a description of dirty pages.</p></dd><dt><a name="stats.arenas.i.pmuzzy"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.pmuzzy</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Number of pages within unused extents that are muzzy.
        See <a class="link" href="#opt.muzzy_decay_ms"><quote><code class="mallctl">opt.muzzy_decay_ms</code></quote></a>
        for a description of muzzy pages.</p></dd><dt><a name="stats.arenas.i.mapped"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.mapped</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Number of mapped bytes.</p></dd><dt><a name="stats.arenas.i.retained"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.retained</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Number of retained bytes.  See <a class="link" href="#stats.retained"><quote><code class="mallctl">stats.retained</code></quote></a> for
        details.</p></dd><dt><a name="stats.arenas.i.base"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.base</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>
        Number of bytes dedicated to bootstrap-sensitive allocator metadata
        structures.</p></dd><dt><a name="stats.arenas.i.internal"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.internal</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Number of bytes dedicated to internal allocations.
        Internal allocations differ from application-originated allocations in
        that they are for internal use, and that they are omitted from heap
        profiles.</p></dd><dt><a name="stats.arenas.i.metadata_thp"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.metadata_thp</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Number of transparent huge pages (THP) used for
        metadata.  See <a class="link" href="#opt.metadata_thp">opt.metadata_thp</a>
        for details.</p></dd><dt><a name="stats.arenas.i.resident"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.resident</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Maximum number of bytes in physically resident data
        pages mapped by the arena, comprising all pages dedicated to allocator
        metadata, pages backing active allocations, and unused dirty pages.
        This is a maximum rather than precise because pages may not actually be
        physically resident if they correspond to demand-zeroed virtual memory
        that has not yet been touched.  This is a multiple of the page
        size.</p></dd><dt><a name="stats.arenas.i.dirty_npurge"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.dirty_npurge</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Number of dirty page purge sweeps performed.
        </p></dd><dt><a name="stats.arenas.i.dirty_nmadvise"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.dirty_nmadvise</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Number of <code class="function">madvise()</code> or similar
        calls made to purge dirty pages.</p></dd><dt><a name="stats.arenas.i.dirty_purged"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.dirty_purged</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Number of dirty pages purged.</p></dd><dt><a name="stats.arenas.i.muzzy_npurge"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.muzzy_npurge</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Number of muzzy page purge sweeps performed.
        </p></dd><dt><a name="stats.arenas.i.muzzy_nmadvise"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.muzzy_nmadvise</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Number of <code class="function">madvise()</code> or similar
        calls made to purge muzzy pages.</p></dd><dt><a name="stats.arenas.i.muzzy_purged"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.muzzy_purged</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Number of muzzy pages purged.</p></dd><dt><a name="stats.arenas.i.small.allocated"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.small.allocated</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Number of bytes currently allocated by small objects.
        </p></dd><dt><a name="stats.arenas.i.small.nmalloc"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.small.nmalloc</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of times a small allocation was
        requested from the arena's bins, whether to fill the relevant tcache if
        <a class="link" href="#opt.tcache"><quote><code class="mallctl">opt.tcache</code></quote></a> is
        enabled, or to directly satisfy an allocation request
        otherwise.</p></dd><dt><a name="stats.arenas.i.small.ndalloc"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.small.ndalloc</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of times a small allocation was
        returned to the arena's bins, whether to flush the relevant tcache if
        <a class="link" href="#opt.tcache"><quote><code class="mallctl">opt.tcache</code></quote></a> is
        enabled, or to directly deallocate an allocation
        otherwise.</p></dd><dt><a name="stats.arenas.i.small.nrequests"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.small.nrequests</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of allocation requests satisfied by
        all bin size classes.</p></dd><dt><a name="stats.arenas.i.large.allocated"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.large.allocated</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Number of bytes currently allocated by large objects.
        </p></dd><dt><a name="stats.arenas.i.large.nmalloc"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.large.nmalloc</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of times a large extent was allocated
        from the arena, whether to fill the relevant tcache if <a class="link" href="#opt.tcache"><quote><code class="mallctl">opt.tcache</code></quote></a> is enabled and
        the size class is within the range being cached, or to directly satisfy
        an allocation request otherwise.</p></dd><dt><a name="stats.arenas.i.large.ndalloc"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.large.ndalloc</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of times a large extent was returned
        to the arena, whether to flush the relevant tcache if <a class="link" href="#opt.tcache"><quote><code class="mallctl">opt.tcache</code></quote></a> is enabled and
        the size class is within the range being cached, or to directly
        deallocate an allocation otherwise.</p></dd><dt><a name="stats.arenas.i.large.nrequests"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.large.nrequests</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of allocation requests satisfied by
        all large size classes.</p></dd><dt><a name="stats.arenas.i.bins.j.nmalloc"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nmalloc</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of times a bin region of the
        corresponding size class was allocated from the arena, whether to fill
        the relevant tcache if <a class="link" href="#opt.tcache"><quote><code class="mallctl">opt.tcache</code></quote></a> is enabled, or
        to directly satisfy an allocation request otherwise.</p></dd><dt><a name="stats.arenas.i.bins.j.ndalloc"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.ndalloc</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of times a bin region of the
        corresponding size class was returned to the arena, whether to flush the
        relevant tcache if <a class="link" href="#opt.tcache"><quote><code class="mallctl">opt.tcache</code></quote></a> is enabled, or
        to directly deallocate an allocation otherwise.</p></dd><dt><a name="stats.arenas.i.bins.j.nrequests"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nrequests</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of allocation requests satisfied by
        bin regions of the corresponding size class.</p></dd><dt><a name="stats.arenas.i.bins.j.curregs"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curregs</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Current number of regions for this size
        class.</p></dd><dt><a name="stats.arenas.i.bins.j.nfills"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nfills</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Cumulative number of tcache fills.</p></dd><dt><a name="stats.arenas.i.bins.j.nflushes"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nflushes</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
        </span></dt><dd><p>Cumulative number of tcache flushes.</p></dd><dt><a name="stats.arenas.i.bins.j.nslabs"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nslabs</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of slabs created.</p></dd><dt><a name="stats.arenas.i.bins.j.nreslabs"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.nreslabs</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of times the current slab from which
        to allocate changed.</p></dd><dt><a name="stats.arenas.i.bins.j.curslabs"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.curslabs</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Current number of slabs.</p></dd><dt><a name="stats.arenas.i.bins.mutex"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.bins.&lt;j&gt;.mutex.{counter}</code></quote>
          (<span class="type">counter specific type</span>) <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Statistics on
        <code class="varname">arena.&lt;i&gt;.bins.&lt;j&gt;</code> mutex (arena bin
        scope; bin operation related).  <quote><code class="mallctl">{counter}</code></quote> is one of
        the counters in <a class="link" href="#mutex_counters">mutex profiling
        counters</a>.</p></dd><dt><a name="stats.arenas.i.lextents.j.nmalloc"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.lextents.&lt;j&gt;.nmalloc</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of times a large extent of the
        corresponding size class was allocated from the arena, whether to fill
        the relevant tcache if <a class="link" href="#opt.tcache"><quote><code class="mallctl">opt.tcache</code></quote></a> is enabled and
        the size class is within the range being cached, or to directly satisfy
        an allocation request otherwise.</p></dd><dt><a name="stats.arenas.i.lextents.j.ndalloc"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.lextents.&lt;j&gt;.ndalloc</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of times a large extent of the
        corresponding size class was returned to the arena, whether to flush the
        relevant tcache if <a class="link" href="#opt.tcache"><quote><code class="mallctl">opt.tcache</code></quote></a> is enabled and
        the size class is within the range being cached, or to directly
        deallocate an allocation otherwise.</p></dd><dt><a name="stats.arenas.i.lextents.j.nrequests"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.lextents.&lt;j&gt;.nrequests</code></quote>
          (<span class="type">uint64_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Cumulative number of allocation requests satisfied by
        large extents of the corresponding size class.</p></dd><dt><a name="stats.arenas.i.lextents.j.curlextents"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.lextents.&lt;j&gt;.curlextents</code></quote>
          (<span class="type">size_t</span>)
          <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Current number of large allocations for this size class.
        </p></dd><dt><a name="stats.arenas.i.mutexes.large"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.mutexes.large.{counter}</code></quote>
          (<span class="type">counter specific type</span>) <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Statistics on <code class="varname">arena.&lt;i&gt;.large</code>
        mutex (arena scope; large allocation related).
        <quote><code class="mallctl">{counter}</code></quote> is one of the counters in <a class="link" href="#mutex_counters">mutex profiling
        counters</a>.</p></dd><dt><a name="stats.arenas.i.mutexes.extent_avail"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.mutexes.extent_avail.{counter}</code></quote>
          (<span class="type">counter specific type</span>) <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Statistics on <code class="varname">arena.&lt;i&gt;.extent_avail
        </code> mutex (arena scope; extent avail related).
        <quote><code class="mallctl">{counter}</code></quote> is one of the counters in <a class="link" href="#mutex_counters">mutex profiling
        counters</a>.</p></dd><dt><a name="stats.arenas.i.mutexes.extents_dirty"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.mutexes.extents_dirty.{counter}</code></quote>
          (<span class="type">counter specific type</span>) <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Statistics on <code class="varname">arena.&lt;i&gt;.extents_dirty
        </code> mutex (arena scope; dirty extents related).
        <quote><code class="mallctl">{counter}</code></quote> is one of the counters in <a class="link" href="#mutex_counters">mutex profiling
        counters</a>.</p></dd><dt><a name="stats.arenas.i.mutexes.extents_muzzy"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.mutexes.extents_muzzy.{counter}</code></quote>
          (<span class="type">counter specific type</span>) <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Statistics on <code class="varname">arena.&lt;i&gt;.extents_muzzy
        </code> mutex (arena scope; muzzy extents related).
        <quote><code class="mallctl">{counter}</code></quote> is one of the counters in <a class="link" href="#mutex_counters">mutex profiling
        counters</a>.</p></dd><dt><a name="stats.arenas.i.mutexes.extents_retained"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.mutexes.extents_retained.{counter}</code></quote>
          (<span class="type">counter specific type</span>) <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Statistics on <code class="varname">arena.&lt;i&gt;.extents_retained
        </code> mutex (arena scope; retained extents related).
        <quote><code class="mallctl">{counter}</code></quote> is one of the counters in <a class="link" href="#mutex_counters">mutex profiling
        counters</a>.</p></dd><dt><a name="stats.arenas.i.mutexes.decay_dirty"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.mutexes.decay_dirty.{counter}</code></quote>
          (<span class="type">counter specific type</span>) <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Statistics on <code class="varname">arena.&lt;i&gt;.decay_dirty
        </code> mutex (arena scope; decay for dirty pages related).
        <quote><code class="mallctl">{counter}</code></quote> is one of the counters in <a class="link" href="#mutex_counters">mutex profiling
        counters</a>.</p></dd><dt><a name="stats.arenas.i.mutexes.decay_muzzy"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.mutexes.decay_muzzy.{counter}</code></quote>
          (<span class="type">counter specific type</span>) <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Statistics on <code class="varname">arena.&lt;i&gt;.decay_muzzy
        </code> mutex (arena scope; decay for muzzy pages related).
        <quote><code class="mallctl">{counter}</code></quote> is one of the counters in <a class="link" href="#mutex_counters">mutex profiling
        counters</a>.</p></dd><dt><a name="stats.arenas.i.mutexes.base"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.mutexes.base.{counter}</code></quote>
          (<span class="type">counter specific type</span>) <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Statistics on <code class="varname">arena.&lt;i&gt;.base</code>
        mutex (arena scope; base allocator related).
        <quote><code class="mallctl">{counter}</code></quote> is one of the counters in <a class="link" href="#mutex_counters">mutex profiling
        counters</a>.</p></dd><dt><a name="stats.arenas.i.mutexes.tcache_list"/><span class="term">
          <quote><code class="mallctl">stats.arenas.&lt;i&gt;.mutexes.tcache_list.{counter}</code></quote>
          (<span class="type">counter specific type</span>) <code class="literal">r-</code>
          [<code class="option">--enable-stats</code>]
        </span></dt><dd><p>Statistics on
        <code class="varname">arena.&lt;i&gt;.tcache_list</code> mutex (arena scope;
        tcache to arena association related).  This mutex is expected to be
        accessed less often.  <quote><code class="mallctl">{counter}</code></quote> is one of the
        counters in <a class="link" href="#mutex_counters">mutex profiling
        counters</a>.</p></dd></dl></div></div><div class="refsect1"><a name="heap_profile_format"/><h2>HEAP PROFILE FORMAT</h2><p>Although the heap profiling functionality was originally designed to
    be compatible with the
    <span class="command"><strong>pprof</strong></span> command that is developed as part of the <a class="ulink" href="http://code.google.com/p/gperftools/" target="_top">gperftools
    package</a>, the addition of per thread heap profiling functionality
    required a different heap profile format.  The <span class="command"><strong>jeprof</strong></span>
    command is derived from <span class="command"><strong>pprof</strong></span>, with enhancements to
    support the heap profile format described here.</p><p>In the following hypothetical heap profile, <code class="constant">[...]</code>
    indicates elision for the sake of compactness.  </p><pre class="programlisting">
heap_v2/524288
  t*: 28106: 56637512 [0: 0]
  [...]
  t3: 352: 16777344 [0: 0]
  [...]
  t99: 17754: 29341640 [0: 0]
  [...]
@ 0x5f86da8 0x5f5a1dc [...] 0x29e4d4e 0xa200316 0xabb2988 [...]
  t*: 13: 6688 [0: 0]
  t3: 12: 6496 [0: ]
  t99: 1: 192 [0: 0]
[...]

MAPPED_LIBRARIES:
[...]</pre><p> The following matches the above heap profile, but most
tokens are replaced with <code class="constant">&lt;description&gt;</code> to indicate
descriptions of the corresponding fields.  </p><pre class="programlisting">
&lt;heap_profile_format_version&gt;/&lt;mean_sample_interval&gt;
  &lt;aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
  [...]
  &lt;thread_3_aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt;[&lt;cumobjs&gt;: &lt;cumbytes&gt;]
  [...]
  &lt;thread_99_aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt;[&lt;cumobjs&gt;: &lt;cumbytes&gt;]
  [...]
@ &lt;top_frame&gt; &lt;frame&gt; [...] &lt;frame&gt; &lt;frame&gt; &lt;frame&gt; [...]
  &lt;backtrace_aggregate&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
  &lt;backtrace_thread_3&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
  &lt;backtrace_thread_99&gt;: &lt;curobjs&gt;: &lt;curbytes&gt; [&lt;cumobjs&gt;: &lt;cumbytes&gt;]
[...]

MAPPED_LIBRARIES:
&lt;/proc/&lt;pid&gt;/maps&gt;</pre></div><div class="refsect1"><a name="debugging_malloc_problems"/><h2>DEBUGGING MALLOC PROBLEMS</h2><p>When debugging, it is a good idea to configure/build jemalloc with
    the <code class="option">--enable-debug</code> and <code class="option">--enable-fill</code>
    options, and recompile the program with suitable options and symbols for
    debugger support.  When so configured, jemalloc incorporates a wide variety
    of run-time assertions that catch application errors such as double-free,
    write-after-free, etc.</p><p>Programs often accidentally depend on <span class="quote">“<span class="quote">uninitialized</span>”</span>
    memory actually being filled with zero bytes.  Junk filling
    (see the <a class="link" href="#opt.junk"><quote><code class="mallctl">opt.junk</code></quote></a>
    option) tends to expose such bugs in the form of obviously incorrect
    results and/or coredumps.  Conversely, zero
    filling (see the <a class="link" href="#opt.zero"><quote><code class="mallctl">opt.zero</code></quote></a> option) eliminates
    the symptoms of such bugs.  Between these two options, it is usually
    possible to quickly detect, diagnose, and eliminate such bugs.</p><p>This implementation does not provide much detail about the problems
    it detects, because the performance impact for storing such information
    would be prohibitive.</p></div><div class="refsect1"><a name="diagnostic_messages"/><h2>DIAGNOSTIC MESSAGES</h2><p>If any of the memory allocation/deallocation functions detect an
    error or warning condition, a message will be printed to file descriptor
    <code class="constant">STDERR_FILENO</code>.  Errors will result in the process
    dumping core.  If the <a class="link" href="#opt.abort"><quote><code class="mallctl">opt.abort</code></quote></a> option is set, most
    warnings are treated as errors.</p><p>The <code class="varname">malloc_message</code> variable allows the programmer
    to override the function which emits the text strings forming the errors
    and warnings if for some reason the <code class="constant">STDERR_FILENO</code> file
    descriptor is not suitable for this.
    <code class="function">malloc_message()</code> takes the
    <em class="parameter"><code>cbopaque</code></em> pointer argument that is
    <code class="constant">NULL</code> unless overridden by the arguments in a call to
    <code class="function">malloc_stats_print()</code>, followed by a string
    pointer.  Please note that doing anything which tries to allocate memory in
    this function is likely to result in a crash or deadlock.</p><p>All messages are prefixed by
    <span class="quote">“<span class="quote"><code class="computeroutput">&lt;jemalloc&gt;: </code></span>”</span>.</p></div><div class="refsect1"><a name="return_values"/><h2>RETURN VALUES</h2><div class="refsect2"><a name="idm140689764475728"/><h3>Standard API</h3><p>The <code class="function">malloc()</code> and
      <code class="function">calloc()</code> functions return a pointer to the
      allocated memory if successful; otherwise a <code class="constant">NULL</code>
      pointer is returned and <code class="varname">errno</code> is set to
      <span class="errorname">ENOMEM</span>.</p><p>The <code class="function">posix_memalign()</code> function
      returns the value 0 if successful; otherwise it returns an error value.
      The <code class="function">posix_memalign()</code> function will fail
      if:
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorname">EINVAL</span></span></dt><dd><p>The <em class="parameter"><code>alignment</code></em> parameter is
            not a power of 2 at least as large as
            <code class="code">sizeof(<span class="type">void *</span>)</code>.
            </p></dd><dt><span class="term"><span class="errorname">ENOMEM</span></span></dt><dd><p>Memory allocation error.</p></dd></dl></div><p>
      </p><p>The <code class="function">aligned_alloc()</code> function returns
      a pointer to the allocated memory if successful; otherwise a
      <code class="constant">NULL</code> pointer is returned and
      <code class="varname">errno</code> is set.  The
      <code class="function">aligned_alloc()</code> function will fail if:
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorname">EINVAL</span></span></dt><dd><p>The <em class="parameter"><code>alignment</code></em> parameter is
            not a power of 2.
            </p></dd><dt><span class="term"><span class="errorname">ENOMEM</span></span></dt><dd><p>Memory allocation error.</p></dd></dl></div><p>
      </p><p>The <code class="function">realloc()</code> function returns a
      pointer, possibly identical to <em class="parameter"><code>ptr</code></em>, to the
      allocated memory if successful; otherwise a <code class="constant">NULL</code>
      pointer is returned, and <code class="varname">errno</code> is set to
      <span class="errorname">ENOMEM</span> if the error was the result of an
      allocation failure.  The <code class="function">realloc()</code>
      function always leaves the original buffer intact when an error occurs.
      </p><p>The <code class="function">free()</code> function returns no
      value.</p></div><div class="refsect2"><a name="idm140689764454240"/><h3>Non-standard API</h3><p>The <code class="function">mallocx()</code> and
      <code class="function">rallocx()</code> functions return a pointer to
      the allocated memory if successful; otherwise a <code class="constant">NULL</code>
      pointer is returned to indicate insufficient contiguous memory was
      available to service the allocation request.  </p><p>The <code class="function">xallocx()</code> function returns the
      real size of the resulting resized allocation pointed to by
      <em class="parameter"><code>ptr</code></em>, which is a value less than
      <em class="parameter"><code>size</code></em> if the allocation could not be adequately
      grown in place.  </p><p>The <code class="function">sallocx()</code> function returns the
      real size of the allocation pointed to by <em class="parameter"><code>ptr</code></em>.
      </p><p>The <code class="function">nallocx()</code> returns the real size
      that would result from a successful equivalent
      <code class="function">mallocx()</code> function call, or zero if
      insufficient memory is available to perform the size computation.  </p><p>The <code class="function">mallctl()</code>,
      <code class="function">mallctlnametomib()</code>, and
      <code class="function">mallctlbymib()</code> functions return 0 on
      success; otherwise they return an error value.  The functions will fail
      if:
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="errorname">EINVAL</span></span></dt><dd><p><em class="parameter"><code>newp</code></em> is not
            <code class="constant">NULL</code>, and <em class="parameter"><code>newlen</code></em> is too
            large or too small.  Alternatively, <em class="parameter"><code>*oldlenp</code></em>
            is too large or too small; in this case as much data as possible
            are read despite the error.</p></dd><dt><span class="term"><span class="errorname">ENOENT</span></span></dt><dd><p><em class="parameter"><code>name</code></em> or
            <em class="parameter"><code>mib</code></em> specifies an unknown/invalid
            value.</p></dd><dt><span class="term"><span class="errorname">EPERM</span></span></dt><dd><p>Attempt to read or write void value, or attempt to
            write read-only value.</p></dd><dt><span class="term"><span class="errorname">EAGAIN</span></span></dt><dd><p>A memory allocation failure
            occurred.</p></dd><dt><span class="term"><span class="errorname">EFAULT</span></span></dt><dd><p>An interface with side effects failed in some way
            not directly related to <code class="function">mallctl*()</code>
            read/write processing.</p></dd></dl></div><p>
      </p><p>The <code class="function">malloc_usable_size()</code> function
      returns the usable size of the allocation pointed to by
      <em class="parameter"><code>ptr</code></em>.  </p></div></div><div class="refsect1"><a name="environment"/><h2>ENVIRONMENT</h2><p>The following environment variable affects the execution of the
    allocation functions:
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="envar">MALLOC_CONF</code></span></dt><dd><p>If the environment variable
          <code class="envar">MALLOC_CONF</code> is set, the characters it contains
          will be interpreted as options.</p></dd></dl></div><p>
    </p></div><div class="refsect1"><a name="examples"/><h2>EXAMPLES</h2><p>To dump core whenever a problem occurs:
      </p><pre class="screen">ln -s 'abort:true' /etc/malloc.conf</pre><p>
    </p><p>To specify in the source that only one arena should be automatically
    created:
      </p><pre class="programlisting">
malloc_conf = "narenas:1";</pre></div><div class="refsect1"><a name="see_also"/><h2>SEE ALSO</h2><p><span class="citerefentry"><span class="refentrytitle">madvise</span>(2)</span>,
    <span class="citerefentry"><span class="refentrytitle">mmap</span>(2)</span>,
    <span class="citerefentry"><span class="refentrytitle">sbrk</span>(2)</span>,
    <span class="citerefentry"><span class="refentrytitle">utrace</span>(2)</span>,
    <span class="citerefentry"><span class="refentrytitle">alloca</span>(3)</span>,
    <span class="citerefentry"><span class="refentrytitle">atexit</span>(3)</span>,
    <span class="citerefentry"><span class="refentrytitle">getpagesize</span>(3)</span></p></div><div class="refsect1"><a name="standards"/><h2>STANDARDS</h2><p>The <code class="function">malloc()</code>,
    <code class="function">calloc()</code>,
    <code class="function">realloc()</code>, and
    <code class="function">free()</code> functions conform to ISO/IEC
    9899:1990 (<span class="quote">“<span class="quote">ISO C90</span>”</span>).</p><p>The <code class="function">posix_memalign()</code> function conforms
    to IEEE Std 1003.1-2001 (<span class="quote">“<span class="quote">POSIX.1</span>”</span>).</p></div></div></body></html>