// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

type Arguments constexpr 'CodeStubArguments*';
type void generates 'void';
type never generates 'void';

type Tagged generates 'TNode<Object>';
type Smi extends Tagged generates 'TNode<Smi>';
type HeapObject extends Tagged generates 'TNode<HeapObject>';
type Object = Smi|HeapObject;
type int32 generates 'TNode<Int32T>' constexpr 'int32_t';
type uint32 generates 'TNode<Uint32T>' constexpr 'uint32_t';
type int64 generates 'TNode<Int64T>' constexpr 'int64_t';
type intptr generates 'TNode<IntPtrT>' constexpr 'intptr_t';
type uintptr generates 'TNode<UintPtrT>' constexpr 'uintptr_t';
type float32 generates 'TNode<Float32T>' constexpr 'float';
type float64 generates 'TNode<Float64T>' constexpr 'double';
type bool generates 'TNode<BoolT>' constexpr 'bool';
type string constexpr 'const char*';

type int31 extends int32 generates 'TNode<Int32T>' constexpr 'int31_t';
type RawPtr generates 'TNode<RawPtrT>' constexpr 'void*';
type AbstractCode extends HeapObject generates 'TNode<AbstractCode>';
type Code extends AbstractCode generates 'TNode<Code>';
type JSReceiver extends HeapObject generates 'TNode<JSReceiver>';
type Context extends HeapObject generates 'TNode<Context>';
type NativeContext extends Context generates 'TNode<Context>';
type String extends HeapObject generates 'TNode<String>';
type Oddball extends HeapObject generates 'TNode<Oddball>';
type HeapNumber extends HeapObject generates 'TNode<HeapNumber>';
type Number = Smi|HeapNumber;
type BigInt extends HeapObject generates 'TNode<BigInt>';
type Numeric = Number|BigInt;
type Boolean extends Oddball generates 'TNode<Oddball>';
type JSProxy extends JSReceiver generates 'TNode<JSProxy>';
type JSObject extends JSReceiver generates 'TNode<JSObject>';
type JSArgumentsObjectWithLength extends JSObject
    generates 'TNode<JSArgumentsObjectWithLength>';
type JSArray extends JSArgumentsObjectWithLength
    generates 'TNode<JSArray>';
type JSFunction extends JSObject generates 'TNode<JSFunction>';
type JSBoundFunction extends JSObject generates 'TNode<JSBoundFunction>';
type Callable = JSFunction|JSBoundFunction|JSProxy;
type Map extends HeapObject generates 'TNode<Map>';
type FixedArrayBase extends HeapObject generates 'TNode<FixedArrayBase>';
type FixedArray extends FixedArrayBase generates 'TNode<FixedArray>';
type FixedDoubleArray extends FixedArrayBase
    generates 'TNode<FixedDoubleArray>';
type FixedTypedArrayBase extends FixedArrayBase
    generates 'TNode<FixedTypedArrayBase>';
type FixedTypedArray extends FixedTypedArrayBase
    generates 'TNode<FixedTypedArray>';
type NumberDictionary extends HeapObject
    generates 'TNode<NumberDictionary>';

type NativeContextSlot generates 'TNode<IntPtrT>' constexpr 'int32_t';
const FAST_ALIASED_ARGUMENTS_MAP_INDEX: constexpr NativeContextSlot
    generates 'Context::FAST_ALIASED_ARGUMENTS_MAP_INDEX';
const SLOW_ALIASED_ARGUMENTS_MAP_INDEX: constexpr NativeContextSlot
    generates 'Context::SLOW_ALIASED_ARGUMENTS_MAP_INDEX';
const STRICT_ARGUMENTS_MAP_INDEX: constexpr NativeContextSlot
    generates 'Context::STRICT_ARGUMENTS_MAP_INDEX';
const SLOPPY_ARGUMENTS_MAP_INDEX: constexpr NativeContextSlot
    generates 'Context::SLOPPY_ARGUMENTS_MAP_INDEX';
extern operator '[]' macro LoadContextElement(
    NativeContext, NativeContextSlot): Object;

extern operator '[]' macro LoadContextElement(Context, intptr): Object;
extern operator '[]' macro LoadContextElement(Context, Smi): Object;

type JSArrayBuffer extends JSObject generates 'TNode<JSArrayBuffer>';
type JSArrayBufferView extends JSObject
    generates 'TNode<JSArrayBufferView>';
type JSTypedArray extends JSArrayBufferView
    generates 'TNode<JSTypedArray>';
type JSDataView extends JSArrayBufferView generates 'TNode<JSDataView>';

type InstanceType generates 'TNode<Int32T>' constexpr 'InstanceType';
type ElementsKind generates 'TNode<Int32T>' constexpr 'ElementsKind';
type LanguageMode generates 'TNode<Smi>' constexpr 'LanguageMode';
type ExtractFixedArrayFlags
    generates 'TNode<Smi>' constexpr 'ExtractFixedArrayFlags';
type ParameterMode generates 'TNode<Int32T>' constexpr 'ParameterMode';
type RootIndex generates 'TNode<Int32T>' constexpr 'RootIndex';
type WriteBarrierMode
    generates 'TNode<Int32T>' constexpr 'WriteBarrierMode';

type MessageTemplate constexpr 'MessageTemplate::Template';

type ToIntegerTruncationMode constexpr 'ToIntegerTruncationMode';

const NO_ELEMENTS: constexpr ElementsKind generates 'NO_ELEMENTS';

const PACKED_SMI_ELEMENTS:
    constexpr ElementsKind generates 'PACKED_SMI_ELEMENTS';
const HOLEY_SMI_ELEMENTS:
    constexpr ElementsKind generates 'HOLEY_SMI_ELEMENTS';
const PACKED_ELEMENTS:
    constexpr ElementsKind generates 'PACKED_ELEMENTS';
const HOLEY_ELEMENTS: constexpr ElementsKind generates 'HOLEY_ELEMENTS';
const PACKED_DOUBLE_ELEMENTS:
    constexpr ElementsKind generates 'PACKED_DOUBLE_ELEMENTS';
const HOLEY_DOUBLE_ELEMENTS:
    constexpr ElementsKind generates 'HOLEY_DOUBLE_ELEMENTS';
const DICTIONARY_ELEMENTS:
    constexpr ElementsKind generates 'DICTIONARY_ELEMENTS';

const UINT8_ELEMENTS: constexpr ElementsKind generates 'UINT8_ELEMENTS';
const INT8_ELEMENTS: constexpr ElementsKind generates 'INT8_ELEMENTS';
const UINT16_ELEMENTS:
    constexpr ElementsKind generates 'UINT16_ELEMENTS';
const INT16_ELEMENTS: constexpr ElementsKind generates 'INT16_ELEMENTS';
const UINT32_ELEMENTS:
    constexpr ElementsKind generates 'UINT32_ELEMENTS';
const INT32_ELEMENTS: constexpr ElementsKind generates 'INT32_ELEMENTS';
const FLOAT32_ELEMENTS:
    constexpr ElementsKind generates 'FLOAT32_ELEMENTS';
const FLOAT64_ELEMENTS:
    constexpr ElementsKind generates 'FLOAT64_ELEMENTS';
const UINT8_CLAMPED_ELEMENTS:
    constexpr ElementsKind generates 'UINT8_CLAMPED_ELEMENTS';
const BIGUINT64_ELEMENTS:
    constexpr ElementsKind generates 'BIGUINT64_ELEMENTS';
const BIGINT64_ELEMENTS:
    constexpr ElementsKind generates 'BIGINT64_ELEMENTS';

type FixedUint8Array extends FixedTypedArray;
type FixedInt8Array extends FixedTypedArray;
type FixedUint16Array extends FixedTypedArray;
type FixedInt16Array extends FixedTypedArray;
type FixedUint32Array extends FixedTypedArray;
type FixedInt32Array extends FixedTypedArray;
type FixedFloat32Array extends FixedTypedArray;
type FixedFloat64Array extends FixedTypedArray;
type FixedUint8ClampedArray extends FixedTypedArray;
type FixedBigUint64Array extends FixedTypedArray;
type FixedBigInt64Array extends FixedTypedArray;

const kFixedDoubleArrays: constexpr ExtractFixedArrayFlags
    generates 'ExtractFixedArrayFlag::kFixedDoubleArrays';
const kAllFixedArrays: constexpr ExtractFixedArrayFlags
    generates 'ExtractFixedArrayFlag::kAllFixedArrays';
const kFixedArrays: constexpr ExtractFixedArrayFlags
    generates 'ExtractFixedArrayFlag::kFixedArrays';

const kFixedCOWArrayMapRootIndex:
    constexpr RootIndex generates 'RootIndex::kFixedCOWArrayMap';
const kEmptyFixedArrayRootIndex:
    constexpr RootIndex generates 'RootIndex::kEmptyFixedArray';

const kInvalidArrayLength: constexpr MessageTemplate
    generates 'MessageTemplate::kInvalidArrayLength';
const kCalledNonCallable: constexpr MessageTemplate
    generates 'MessageTemplate::kCalledNonCallable';
const kCalledOnNullOrUndefined: constexpr MessageTemplate
    generates 'MessageTemplate::kCalledOnNullOrUndefined';

const kMaxSafeInteger: constexpr float64 generates 'kMaxSafeInteger';

const kTruncateMinusZero: constexpr ToIntegerTruncationMode
    generates 'ToIntegerTruncationMode::kTruncateMinusZero';

const kNotTypedArray: constexpr MessageTemplate
    generates 'MessageTemplate::kNotTypedArray';
const kDetachedOperation: constexpr MessageTemplate
    generates 'MessageTemplate::kDetachedOperation';
const kBadSortComparisonFunction: constexpr MessageTemplate
    generates 'MessageTemplate::kBadSortComparisonFunction';
const kIncompatibleMethodReceiver: constexpr MessageTemplate
    generates 'MessageTemplate::kIncompatibleMethodReceiver';
const kInvalidDataViewAccessorOffset: constexpr MessageTemplate
    generates 'MessageTemplate::kInvalidDataViewAccessorOffset';
const kStrictReadOnlyProperty: constexpr MessageTemplate
    generates 'MessageTemplate::kStrictReadOnlyProperty';

extern macro TheHoleConstant(): Oddball;
extern macro NullConstant(): Oddball;
extern macro UndefinedConstant(): Oddball;
extern macro TrueConstant(): Boolean;
extern macro FalseConstant(): Boolean;
extern macro Int32TrueConstant(): bool;
extern macro Int32FalseConstant(): bool;
extern macro LengthStringConstant(): String;

const Hole: Oddball = TheHoleConstant();
const Null: Oddball = NullConstant();
const Undefined: Oddball = UndefinedConstant();
const True: Boolean = TrueConstant();
const False: Boolean = FalseConstant();
const kLengthString: String = LengthStringConstant();

const true: constexpr bool generates 'true';
const false: constexpr bool generates 'false';

const kStrict: constexpr LanguageMode generates 'LanguageMode::kStrict';
const kSloppy: constexpr LanguageMode generates 'LanguageMode::kSloppy';

const SMI_PARAMETERS: constexpr ParameterMode generates 'SMI_PARAMETERS';
const INTPTR_PARAMETERS:
    constexpr ParameterMode generates 'INTPTR_PARAMETERS';

const SKIP_WRITE_BARRIER:
    constexpr WriteBarrierMode generates 'SKIP_WRITE_BARRIER';

extern macro Is64(): constexpr bool;

extern macro SelectBooleanConstant(bool): Boolean;

extern macro Print(constexpr string);
extern macro Print(constexpr string, Object);
extern macro Comment(constexpr string);
extern macro Print(Object);
extern macro DebugBreak();
extern macro ToInteger_Inline(Context, Object): Number;
extern macro ToInteger_Inline(
    Context, Object, constexpr ToIntegerTruncationMode): Number;
extern macro ToLength_Inline(Context, Object): Number;
extern macro ToNumber_Inline(Context, Object): Number;
extern macro ToString_Inline(Context, Object): String;
extern macro GetProperty(Context, Object, Object): Object;
extern builtin SetProperty(Context, Object, Object, Object);
extern builtin DeleteProperty(Context, Object, Object, LanguageMode);
extern builtin HasProperty(Context, JSReceiver, Object): Boolean;
extern macro HasProperty_Inline(Context, JSReceiver, Object): Boolean;

extern macro ThrowRangeError(Context, constexpr MessageTemplate): never;
extern macro ThrowTypeError(Context, constexpr MessageTemplate): never;
extern macro ThrowTypeError(Context, constexpr MessageTemplate, Object): never;
extern macro ThrowTypeError(
    Context, constexpr MessageTemplate, Object, Object, Object): never;
extern macro ArraySpeciesCreate(Context, Object, Number): JSReceiver;
extern macro InternalArrayCreate(Context, Number): JSArray;
extern macro EnsureArrayPushable(Map): ElementsKind
    labels Bailout;
extern macro EnsureArrayLengthWritable(Map) labels Bailout;

extern builtin ToObject(Context, Object): JSReceiver;
extern macro ToObject_Inline(Context, Object): JSReceiver;
extern macro IsNullOrUndefined(Object): bool;
extern macro IsTheHole(Object): bool;
extern macro IsString(HeapObject): bool;
extern builtin ToString(Context, Object): String;

extern runtime NormalizeElements(Context, JSObject);
extern runtime TransitionElementsKindWithKind(Context, JSObject, Smi);
extern runtime CreateDataProperty(Context, JSReceiver, Object, Object);

extern macro LoadRoot(constexpr RootIndex): Object;
extern macro StoreRoot(constexpr RootIndex, Object): Object;
extern macro LoadAndUntagToWord32Root(constexpr RootIndex): int32;

extern runtime StringEqual(Context, String, String): Oddball;
extern builtin StringLessThan(Context, String, String): Boolean;

extern macro StrictEqual(Object, Object): Boolean;
extern macro SmiLexicographicCompare(Smi, Smi): Smi;

extern operator '<' macro Int32LessThan(int32, int32): bool;
extern operator '>' macro Int32GreaterThan(int32, int32): bool;
extern operator '<=' macro Int32LessThanOrEqual(int32, int32): bool;
extern operator '>=' macro Int32GreaterThanOrEqual(int32, int32): bool;

extern operator '==' macro SmiEqual(Smi, Smi): bool;
extern operator '!=' macro SmiNotEqual(Smi, Smi): bool;
extern operator '<' macro SmiLessThan(Smi, Smi): bool;
extern operator '<=' macro SmiLessThanOrEqual(Smi, Smi): bool;
extern operator '>' macro SmiGreaterThan(Smi, Smi): bool;
extern operator '>=' macro SmiGreaterThanOrEqual(Smi, Smi): bool;

extern operator '==' macro ElementsKindEqual(
    constexpr ElementsKind, constexpr ElementsKind): constexpr bool;
extern operator '==' macro ElementsKindEqual(ElementsKind, ElementsKind): bool;
operator '!=' macro ElementsKindNotEqual(
    k1: ElementsKind, k2: ElementsKind): bool {
  return !ElementsKindEqual(k1, k2);
}
extern macro IsFastElementsKind(constexpr ElementsKind): constexpr bool;
extern macro IsDoubleElementsKind(constexpr ElementsKind): constexpr bool;

extern macro SmiAbove(Smi, Smi): bool;

extern operator '==' macro WordEqual(intptr, intptr): bool;
extern operator '==' macro WordEqual(uintptr, uintptr): bool;
extern operator '!=' macro WordNotEqual(intptr, intptr): bool;
extern operator '!=' macro WordNotEqual(uintptr, uintptr): bool;
extern operator '<' macro IntPtrLessThan(intptr, intptr): bool;
extern operator '>' macro IntPtrGreaterThan(intptr, intptr): bool;
extern operator '<=' macro IntPtrLessThanOrEqual(intptr, intptr): bool;
extern operator '>=' macro IntPtrGreaterThanOrEqual(intptr, intptr): bool;
extern operator '>' macro UintPtrGreaterThan(uintptr, uintptr): bool;
extern operator '>=' macro UintPtrGreaterThanOrEqual(uintptr, uintptr): bool;

extern operator '==' macro Float64Equal(float64, float64): bool;
extern operator '!=' macro Float64NotEqual(float64, float64): bool;
extern operator '>' macro Float64GreaterThan(float64, float64): bool;

extern operator '==' macro BranchIfNumberEqual(Number, Number): never
    labels Taken, NotTaken;
extern operator '<' macro BranchIfNumberLessThan(Number, Number): never
    labels Taken, NotTaken;
extern operator '<=' macro BranchIfNumberLessThanOrEqual(Number, Number): never
    labels Taken, NotTaken;

extern operator '>' macro BranchIfNumberGreaterThan(Number, Number): never
    labels Taken, NotTaken;
extern operator '>=' macro BranchIfNumberGreaterThanOrEqual(Number, Number):
    never
    labels Taken, NotTaken;

extern operator '==' macro WordEqual(Object, Object): bool;
extern operator '!=' macro WordNotEqual(Object, Object): bool;

extern operator '+' macro SmiAdd(Smi, Smi): Smi;
extern operator '-' macro SmiSub(Smi, Smi): Smi;
extern operator '&' macro SmiAnd(Smi, Smi): Smi;
extern operator '|' macro SmiOr(Smi, Smi): Smi;
extern operator '>>>' macro SmiShr(Smi, constexpr int31): Smi;
extern operator '<<' macro SmiShl(Smi, constexpr int31): Smi;

extern operator '+' macro IntPtrAdd(intptr, intptr): intptr;
extern operator '+' macro UintPtrAdd(uintptr, uintptr): uintptr;
extern operator '-' macro IntPtrSub(intptr, intptr): intptr;
extern operator '>>>' macro WordShr(uintptr, uintptr): uintptr;
extern operator '<<' macro WordShl(intptr, intptr): intptr;
extern operator '&' macro WordAnd(intptr, intptr): intptr;
extern operator '&' macro WordAnd(uintptr, uintptr): uintptr;

extern operator '+' macro Int32Add(int32, int32): int32;
extern operator '-' macro Int32Sub(int32, int32): int32;
extern operator '*' macro Int32Mul(int32, int32): int32;
extern operator '%' macro Int32Mod(int32, int32): int32;
extern operator '&' macro Word32And(int32, int32): int32;
extern operator '&' macro Word32And(uint32, uint32): uint32;
extern operator '==' macro
ConstexprInt31Equal(constexpr int31, constexpr int31): constexpr bool;

extern operator '==' macro Word32Equal(int32, int32): bool;
extern operator '==' macro Word32Equal(uint32, uint32): bool;
extern operator '!=' macro Word32NotEqual(int32, int32): bool;
extern operator '!=' macro Word32NotEqual(uint32, uint32): bool;
extern operator '>>>' macro Word32Shr(uint32, uint32): uint32;
extern operator '<<' macro Word32Shl(int32, int32): int32;
extern operator '<<' macro Word32Shl(uint32, uint32): uint32;
extern operator '|' macro Word32Or(int32, int32): int32;
extern operator '|' macro Word32Or(uint32, uint32): uint32;

extern operator '+' macro Float64Add(float64, float64): float64;

extern operator '+' macro NumberAdd(Number, Number): Number;
extern operator '-' macro NumberSub(Number, Number): Number;
extern macro NumberMin(Number, Number): Number;
extern macro NumberMax(Number, Number): Number;
macro Min(x: Number, y: Number): Number {
  return NumberMin(x, y);
}
macro Max(x: Number, y: Number): Number {
  return NumberMax(x, y);
}

extern macro SmiMax(Smi, Smi): Smi;
extern macro SmiMin(Smi, Smi): Smi;

extern operator '!' macro ConstexprBoolNot(constexpr bool): constexpr bool;
extern operator '!' macro Word32BinaryNot(bool): bool;
extern operator '!' macro IsFalse(Boolean): bool;

extern operator '.map' macro LoadMap(HeapObject): Map;
extern operator '.map=' macro StoreMap(HeapObject, Map);
extern operator '.instanceType' macro LoadInstanceType(HeapObject):
    InstanceType;

extern operator '.length' macro LoadStringLengthAsWord(String): intptr;

extern operator '.length' macro GetArgumentsLength(constexpr Arguments): intptr;
extern operator '[]' macro GetArgumentValue(
    constexpr Arguments, intptr): Object;

extern macro TaggedIsSmi(Object): bool;
extern macro TaggedIsNotSmi(Object): bool;
extern macro TaggedIsPositiveSmi(Object): bool;

extern macro HeapObjectToJSDataView(HeapObject): JSDataView
    labels CastError;
extern macro TaggedToHeapObject(Object): HeapObject
    labels CastError;
extern macro TaggedToSmi(Object): Smi
    labels CastError;
extern macro HeapObjectToJSArray(HeapObject): JSArray
    labels CastError;
extern macro HeapObjectToCallable(HeapObject): Callable
    labels CastError;
extern macro HeapObjectToFixedArray(HeapObject): FixedArray
    labels CastError;
extern macro HeapObjectToFixedDoubleArray(HeapObject): FixedDoubleArray
    labels CastError;
extern macro TaggedToNumber(Object): Number
    labels CastError;

macro CastHeapObject<A: type>(o: HeapObject): A
    labels CastError;
CastHeapObject<HeapObject>(o: HeapObject): HeapObject
    labels CastError {
  return o;
}
CastHeapObject<FixedArray>(o: HeapObject): FixedArray
    labels CastError {
  return HeapObjectToFixedArray(o) otherwise CastError;
}
CastHeapObject<FixedDoubleArray>(o: HeapObject): FixedDoubleArray
    labels CastError {
  return HeapObjectToFixedDoubleArray(o) otherwise CastError;
}
CastHeapObject<JSDataView>(o: HeapObject): JSDataView
    labels CastError {
  return HeapObjectToJSDataView(o) otherwise CastError;
}
CastHeapObject<Callable>(o: HeapObject): Callable
    labels CastError {
  return HeapObjectToCallable(o) otherwise CastError;
}
CastHeapObject<JSArray>(o: HeapObject): JSArray
    labels CastError {
  return HeapObjectToJSArray(o) otherwise CastError;
}

macro Cast<A: type>(o: HeapObject): A
    labels CastError {
  return CastHeapObject<A>(o) otherwise CastError;
}

// CastHeapObject allows this default-implementation to be non-recursive.
// Otherwise the generated CSA code might run into infinite recursion.
macro Cast<A: type>(o: Object): A
    labels CastError {
  return CastHeapObject<A>(TaggedToHeapObject(o) otherwise CastError)
      otherwise CastError;
}
Cast<Smi>(o: Object): Smi
    labels CastError {
  return TaggedToSmi(o) otherwise CastError;
}
Cast<Number>(o: Object): Number
    labels CastError {
  return TaggedToNumber(o) otherwise CastError;
}

extern macro AllocateHeapNumberWithValue(float64): HeapNumber;
extern macro ChangeInt32ToTagged(int32): Number;
extern macro ChangeUint32ToTagged(uint32): Number;
extern macro ChangeUintPtrToFloat64(uintptr): float64;
extern macro ChangeUintPtrToTagged(uintptr): Number;
extern macro Unsigned(int32): uint32;
extern macro Unsigned(intptr): uintptr;
extern macro Unsigned(RawPtr): uintptr;
extern macro Signed(uint32): int32;
extern macro Signed(uintptr): intptr;
extern macro Signed(RawPtr): intptr;
extern macro TruncateIntPtrToInt32(intptr): int32;
extern macro SmiTag(intptr): Smi;
extern macro SmiFromInt32(int32): Smi;
extern macro SmiUntag(Smi): intptr;
extern macro SmiToInt32(Smi): int32;
extern macro RoundIntPtrToFloat64(intptr): float64;
extern macro LoadHeapNumberValue(HeapNumber): float64;
extern macro ChangeFloat32ToFloat64(float32): float64;
extern macro ChangeNumberToFloat64(Number): float64;
extern macro ChangeFloat64ToUintPtr(float64): uintptr;
extern macro ChangeInt32ToIntPtr(int32): intptr;   // Sign-extends.
extern macro ChangeUint32ToWord(uint32): uintptr;  // Doesn't sign-extend.
extern macro LoadNativeContext(Context): NativeContext;
extern macro LoadJSArrayElementsMap(constexpr ElementsKind, Context): Map;

extern macro NumberConstant(constexpr float64): Number;
extern macro NumberConstant(constexpr int32): Number;
extern macro IntPtrConstant(constexpr int31): intptr;
extern macro IntPtrConstant(constexpr int32): intptr;
extern macro Int32Constant(constexpr int31): int31;
extern macro Int32Constant(constexpr int32): int32;
extern macro Float64Constant(constexpr int31): float64;
extern macro SmiConstant(constexpr int31): Smi;
extern macro BoolConstant(constexpr bool): bool;
extern macro StringConstant(constexpr string): String;
extern macro LanguageModeConstant(constexpr LanguageMode): LanguageMode;
extern macro Int32Constant(constexpr ElementsKind): ElementsKind;
extern macro IntPtrConstant(constexpr NativeContextSlot): NativeContextSlot;

macro FromConstexpr<A: type>(o: constexpr int31): A;
FromConstexpr<intptr>(i: constexpr int31): intptr {
  return IntPtrConstant(i);
}
FromConstexpr<int31>(i: constexpr int31): int31 {
  return Int32Constant(i);
}
FromConstexpr<int32>(i: constexpr int31): int32 {
  return Int32Constant(i);
}
FromConstexpr<uint32>(i: constexpr int31): uint32 {
  return Unsigned(Int32Constant(i));
}
FromConstexpr<uintptr>(i: constexpr int31): uintptr {
  return ChangeUint32ToWord(i);
}
FromConstexpr<Smi>(i: constexpr int31): Smi {
  return SmiConstant(i);
}
FromConstexpr<Number>(i: constexpr int31): Number {
  return SmiConstant(i);
}
FromConstexpr<float64>(i: constexpr int31): float64 {
  return Float64Constant(i);
}
macro FromConstexpr<A: type>(o: constexpr int32): A;
FromConstexpr<intptr>(i: constexpr int32): intptr {
  return IntPtrConstant(i);
}
FromConstexpr<int32>(i: constexpr int32): int32 {
  return Int32Constant(i);
}
FromConstexpr<Number>(i: constexpr int32): Number {
  return NumberConstant(i);
}
macro FromConstexpr<A: type>(o: constexpr float64): A;
FromConstexpr<Number>(f: constexpr float64): Number {
  return NumberConstant(f);
}
macro FromConstexpr<A: type>(b: constexpr bool): A;
FromConstexpr<bool>(b: constexpr bool): bool {
  return BoolConstant(b);
}
macro FromConstexpr<A: type>(l: constexpr LanguageMode): A;
FromConstexpr<LanguageMode>(b: constexpr LanguageMode): LanguageMode {
  return LanguageModeConstant(b);
}
macro FromConstexpr<A: type>(e: constexpr ElementsKind): A;
FromConstexpr<ElementsKind>(e: constexpr ElementsKind): ElementsKind {
  return Int32Constant(e);
}
macro FromConstexpr<A: type>(s: constexpr string): A;
FromConstexpr<String>(s: constexpr string): String {
  return StringConstant(s);
}
FromConstexpr<Object>(s: constexpr string): Object {
  return StringConstant(s);
}
macro FromConstexpr<A: type>(e: constexpr NativeContextSlot): A;
FromConstexpr<NativeContextSlot>(c: constexpr NativeContextSlot):
    NativeContextSlot {
  return IntPtrConstant(c);
}

macro Convert<A: type>(i: constexpr int31): A {
  return i;
}
extern macro ConvertElementsKindToInt(ElementsKind): int32;

macro Convert<A: type>(elementsKind: ElementsKind): A;
Convert<int32>(elementsKind: ElementsKind): int32 {
  return ConvertElementsKindToInt(elementsKind);
}

macro Convert<A: type>(i: int32): A;
Convert<Number>(i: int32): Number {
  return ChangeInt32ToTagged(i);
}
Convert<intptr>(i: int32): intptr {
  return ChangeInt32ToIntPtr(i);
}
Convert<Smi>(i: int32): Smi {
  return SmiFromInt32(i);
}
macro Convert<A: type>(ui: uint32): A;
Convert<Number>(ui: uint32): Number {
  return ChangeUint32ToTagged(ui);
}
Convert<Smi>(ui: uint32): Smi {
  return SmiFromInt32(Signed(ui));
}
Convert<uintptr>(ui: uint32): uintptr {
  return ChangeUint32ToWord(ui);
}
macro Convert<A: type>(i: intptr): A;
Convert<int32>(i: intptr): int32 {
  return TruncateIntPtrToInt32(i);
}
Convert<Smi>(i: intptr): Smi {
  return SmiTag(i);
}
macro Convert<A: type>(ui: uintptr): A;
Convert<uint32>(ui: uintptr): uint32 {
  return Unsigned(TruncateIntPtrToInt32(Signed(ui)));
}
macro Convert<A: type>(s: Smi): A;
Convert<intptr>(s: Smi): intptr {
  return SmiUntag(s);
}
Convert<int32>(s: Smi): int32 {
  return SmiToInt32(s);
}
macro Convert<A: type>(h: HeapNumber): A;
Convert<float64>(h: HeapNumber): float64 {
  return LoadHeapNumberValue(h);
}
macro Convert<A: type>(n: Number): A;
Convert<float64>(n: Number): float64 {
  return ChangeNumberToFloat64(n);
}
macro Convert<A: type>(f: float32): A;
Convert<float64>(f: float32): float64 {
  return ChangeFloat32ToFloat64(f);
}
macro Convert<A: type>(d: float64): A;
Convert<Number>(d: float64): Number {
  return AllocateHeapNumberWithValue(d);
}
Convert<float64>(ui: uintptr): float64 {
  return ChangeUintPtrToFloat64(ui);
}
Convert<Number>(ui: uintptr): Number {
  return ChangeUintPtrToTagged(ui);
}
Convert<uintptr>(d: float64): uintptr {
  return ChangeFloat64ToUintPtr(d);
}
macro Convert<A: type>(r: RawPtr): A;
Convert<uintptr>(r: RawPtr): uintptr {
  return Unsigned(r);
}
Convert<intptr>(r: RawPtr): intptr {
  return Signed(r);
}

extern macro UnsafeCastNumberToHeapNumber(Number): HeapNumber;
extern macro UnsafeCastObjectToFixedArrayBase(Object): FixedArrayBase;
extern macro UnsafeCastObjectToFixedArray(Object): FixedArray;
extern macro UnsafeCastObjectToContext(Object): Context;
extern macro UnsafeCastObjectToFixedDoubleArray(Object): FixedDoubleArray;
extern macro UnsafeCastObjectToHeapNumber(Object): HeapNumber;
extern macro UnsafeCastObjectToCallable(Object): Callable;
extern macro UnsafeCastObjectToSmi(Object): Smi;
extern macro UnsafeCastObjectToNumber(Object): Number;
extern macro UnsafeCastObjectToHeapObject(Object): HeapObject;
extern macro UnsafeCastObjectToJSArray(Object): JSArray;
extern macro UnsafeCastObjectToFixedTypedArrayBase(Object): FixedTypedArrayBase;
extern macro UnsafeCastObjectToNumberDictionary(Object): NumberDictionary;
extern macro UnsafeCastObjectToJSReceiver(Object): JSReceiver;
extern macro UnsafeCastObjectToJSObject(Object): JSObject;
extern macro UnsafeCastObjectToMap(Object): Map;

macro UnsafeCast<A: type>(n: Number): A;
UnsafeCast<HeapNumber>(n: Number): HeapNumber {
  return UnsafeCastNumberToHeapNumber(n);
}
macro UnsafeCast<A: type>(o: Object): A;
UnsafeCast<Object>(o: Object): Object {
  return o;
}
UnsafeCast<FixedArray>(o: Object): FixedArray {
  return UnsafeCastObjectToFixedArray(o);
}
UnsafeCast<FixedDoubleArray>(o: Object): FixedDoubleArray {
  return UnsafeCastObjectToFixedDoubleArray(o);
}
UnsafeCast<HeapNumber>(o: Object): HeapNumber {
  return UnsafeCastObjectToHeapNumber(o);
}
UnsafeCast<Callable>(o: Object): Callable {
  return UnsafeCastObjectToCallable(o);
}
UnsafeCast<Smi>(o: Object): Smi {
  return UnsafeCastObjectToSmi(o);
}
UnsafeCast<Number>(o: Object): Number {
  return UnsafeCastObjectToNumber(o);
}
UnsafeCast<HeapObject>(o: Object): HeapObject {
  return UnsafeCastObjectToHeapObject(o);
}
UnsafeCast<JSArray>(o: Object): JSArray {
  return UnsafeCastObjectToJSArray(o);
}
UnsafeCast<FixedTypedArrayBase>(o: Object): FixedTypedArrayBase {
  return UnsafeCastObjectToFixedTypedArrayBase(o);
}
UnsafeCast<NumberDictionary>(o: Object): NumberDictionary {
  return UnsafeCastObjectToNumberDictionary(o);
}
UnsafeCast<JSReceiver>(o: Object): JSReceiver {
  return UnsafeCastObjectToJSReceiver(o);
}
UnsafeCast<JSObject>(o: Object): JSObject {
  return UnsafeCastObjectToJSObject(o);
}
UnsafeCast<Map>(o: Object): Map {
  return UnsafeCastObjectToMap(o);
}
UnsafeCast<FixedArrayBase>(o: Object): FixedArrayBase {
  return UnsafeCastObjectToFixedArrayBase(o);
}
UnsafeCast<Context>(o: Object): Context {
  return UnsafeCastObjectToContext(o);
}

// RawCasts should *never* be used anywhere in Torque code except for
// in Torque-based UnsafeCast operators preceeded by an appropriate
// type check().
extern macro RawCastObjectToJSArgumentsObjectWithLength(Object):
    JSArgumentsObjectWithLength;

macro BranchIfJSArgumentsObjectWithLength(context: Context, o: Object): never
    labels True, False {
  const heapObject: HeapObject = Cast<HeapObject>(o) otherwise False;
  const map: Map = heapObject.map;
  const nativeContext: NativeContext = LoadNativeContext(context);
  if (map == nativeContext[FAST_ALIASED_ARGUMENTS_MAP_INDEX]) goto True;
  if (map == nativeContext[SLOW_ALIASED_ARGUMENTS_MAP_INDEX]) goto True;
  if (map == nativeContext[STRICT_ARGUMENTS_MAP_INDEX]) goto True;
  if (map != nativeContext[SLOPPY_ARGUMENTS_MAP_INDEX]) goto False;
  goto True;
}

macro UnsafeCast<A: type>(context: Context, o: Object): A;
UnsafeCast<JSArgumentsObjectWithLength>(
    context: Context, o: Object): JSArgumentsObjectWithLength {
  assert(BranchIfJSArgumentsObjectWithLength(context, o));
  return RawCastObjectToJSArgumentsObjectWithLength(o);
}

macro Cast<A: type>(context: Context, o: Object): A
    labels CastError;
Cast<JSArgumentsObjectWithLength>(context: Context, o: Object):
    JSArgumentsObjectWithLength
    labels CastError {
  if (BranchIfJSArgumentsObjectWithLength(context, o)) {
    return UnsafeCast<JSArgumentsObjectWithLength>(context, o);
  } else {
    goto CastError;
  }
}

const kCOWMap: Map = UnsafeCast<Map>(LoadRoot(kFixedCOWArrayMapRootIndex));
const kEmptyFixedArray: FixedArrayBase =
    UnsafeCast<FixedArrayBase>(LoadRoot(kEmptyFixedArrayRootIndex));

extern macro BranchIfFastJSArray(Object, Context): never
    labels Taken, NotTaken;
extern macro BranchIfNotFastJSArray(Object, Context): never
    labels Taken, NotTaken;

macro EnsureFastJSArray(context: Context, object: Object) labels Bailout {
  if (BranchIfNotFastJSArray(object, context)) goto Bailout;
}

extern macro IsPrototypeInitialArrayPrototype(Context, Map): bool;
extern macro IsNoElementsProtectorCellInvalid(): bool;
extern macro IsArraySpeciesProtectorCellInvalid(): bool;
extern macro IsTypedArraySpeciesProtectorCellInvalid(): bool;
extern macro IsPromiseSpeciesProtectorCellInvalid(): bool;

extern operator '.buffer' macro LoadTypedArrayBuffer(JSTypedArray):
    JSArrayBuffer;

extern operator '.data_ptr' macro LoadDataPtr(JSTypedArray): RawPtr;

extern operator '.elements_kind' macro LoadMapElementsKind(Map): ElementsKind;
extern operator '.elements_kind' macro LoadElementsKind(JSTypedArray):
    ElementsKind;

extern operator '.elements' macro LoadElements(JSObject): FixedArrayBase;
extern operator '.elements=' macro StoreElements(JSObject, FixedArrayBase);

extern operator '.length' macro LoadJSTypedArrayLength(JSTypedArray): Smi;
extern operator '.length' macro LoadJSArrayLength(JSArray): Number;
extern operator '.length' macro LoadJSArgumentsObjectWithLength(
    JSArgumentsObjectWithLength): Object;
extern operator '.length_fast' macro LoadFastJSArrayLength(JSArray): Smi;
extern operator '.length=' macro StoreJSArrayLength(JSArray, Smi);

extern operator '.length' macro LoadFixedArrayBaseLength(FixedArrayBase): Smi;
extern operator '[]' macro LoadFixedArrayElement(FixedArray, intptr): Object;
extern operator '[]' macro LoadFixedArrayElement(FixedArray, Smi): Object;
extern operator '[]' macro LoadFixedArrayElement(
    FixedArray, constexpr int31): Object;
extern operator '[]=' macro StoreFixedArrayElement(
    FixedArray, intptr, Object): void;
extern operator '[]=' macro StoreFixedArrayElement(
    FixedArray, constexpr int31, Object): void;
extern operator '[]=' macro StoreFixedArrayElementSmi(
    FixedArray, Smi, Object): void;
operator '[]=' macro StoreFixedDoubleArrayNumber(
    a: FixedDoubleArray, index: Smi, value: Number): void {
  a[index] = Convert<float64>(value);
}

extern macro StoreFixedArrayElementSmi(
    FixedArray, Smi, Object, constexpr WriteBarrierMode): void;

extern operator '.instance_type' macro LoadMapInstanceType(Map): int32;

extern macro LoadFixedDoubleArrayElement(FixedDoubleArray, Smi): float64;
extern macro Float64SilenceNaN(float64): float64;

extern macro StoreFixedDoubleArrayElement(
    FixedDoubleArray, Object, float64, constexpr ParameterMode);
macro StoreFixedDoubleArrayElementWithSmiIndex(
    array: FixedDoubleArray, index: Smi, value: float64) {
  StoreFixedDoubleArrayElement(array, index, value, SMI_PARAMETERS);
}

extern macro BasicLoadNumberDictionaryElement(NumberDictionary, intptr): Object
    labels NotData, IfHole;
extern macro BasicStoreNumberDictionaryElement(NumberDictionary, intptr, Object)
labels NotData, IfHole, ReadOnly;

extern macro IsFastElementsKind(ElementsKind): bool;
extern macro IsDoubleElementsKind(ElementsKind): bool;
extern macro IsFastSmiOrTaggedElementsKind(ElementsKind): bool;
extern macro IsFastSmiElementsKind(ElementsKind): bool;
extern macro IsHoleyFastElementsKind(ElementsKind): bool;

macro AllowDoubleElements(kind: ElementsKind): ElementsKind {
  if (kind == PACKED_SMI_ELEMENTS) {
    return PACKED_DOUBLE_ELEMENTS;
  } else if (kind == HOLEY_SMI_ELEMENTS) {
    return HOLEY_DOUBLE_ELEMENTS;
  }
  return kind;
}

macro AllowNonNumberElements(kind: ElementsKind): ElementsKind {
  if (kind == PACKED_SMI_ELEMENTS) {
    return PACKED_ELEMENTS;
  } else if (kind == HOLEY_SMI_ELEMENTS) {
    return HOLEY_ELEMENTS;
  } else if (kind == PACKED_DOUBLE_ELEMENTS) {
    return PACKED_ELEMENTS;
  } else if (kind == HOLEY_DOUBLE_ELEMENTS) {
    return HOLEY_ELEMENTS;
  }
  return kind;
}

extern macro AllocateZeroedFixedArray(intptr): FixedArray;
extern macro AllocateZeroedFixedDoubleArray(intptr): FixedDoubleArray;

extern macro CalculateNewElementsCapacity(Smi): Smi;

extern macro CopyFixedArrayElements(
    constexpr ElementsKind, FixedArray, constexpr ElementsKind, FixedArray,
    intptr, intptr, intptr): void;
extern macro CopyFixedArrayElements(
    constexpr ElementsKind, FixedArray, constexpr ElementsKind, FixedArray, Smi,
    Smi, Smi): void;

extern macro AllocateJSArray(constexpr ElementsKind, Map, intptr, Smi): JSArray;
extern macro AllocateJSArray(constexpr ElementsKind, Map, Smi, Smi): JSArray;
extern macro IsElementsKindGreaterThan(
    ElementsKind, constexpr ElementsKind): bool;

extern operator '[]=' macro StoreFixedDoubleArrayElementSmi(
    FixedDoubleArray, Smi, float64): void;

extern macro LoadDoubleWithHoleCheck(FixedDoubleArray, Smi): float64
    labels IfHole;
extern macro StoreFixedDoubleArrayHoleSmi(FixedDoubleArray, Smi): void;

extern macro Call(Context, Callable, Object): Object;
extern macro Call(Context, Callable, Object, Object): Object;
extern macro Call(Context, Callable, Object, Object, Object): Object;
extern macro Call(Context, Callable, Object, Object, Object, Object): Object;
extern macro Call(
    Context, Callable, Object, Object, Object, Object, Object): Object;
extern macro Call(
    Context, Callable, Object, Object, Object, Object, Object, Object): Object;

extern macro ExtractFixedArray(FixedArrayBase, Smi, Smi, Smi): FixedArrayBase;
extern macro ExtractFixedArray(
    FixedArrayBase, Smi, Smi, Smi,
    constexpr ExtractFixedArrayFlags): FixedArrayBase;

extern builtin ExtractFastJSArray(Context, JSArray, Smi, Smi): JSArray;

extern macro MoveElements(
    constexpr ElementsKind, FixedArrayBase, intptr, intptr, intptr): void;
macro TorqueMoveElements(
    elements: FixedArray, dstIndex: intptr, srcIndex: intptr,
    count: intptr): void {
  MoveElements(HOLEY_ELEMENTS, elements, dstIndex, srcIndex, count);
}
macro TorqueMoveElements(
    elements: FixedDoubleArray, dstIndex: intptr, srcIndex: intptr,
    count: intptr): void {
  MoveElements(HOLEY_DOUBLE_ELEMENTS, elements, dstIndex, srcIndex, count);
}

extern macro CopyElements(
    constexpr ElementsKind, FixedArrayBase, intptr, FixedArrayBase, intptr,
    intptr): void;
macro TorqueCopyElements(
    dstElements: FixedArray, dstIndex: intptr, srcElements: FixedArray,
    srcIndex: intptr, count: intptr): void {
  CopyElements(
      HOLEY_ELEMENTS, dstElements, dstIndex, srcElements, srcIndex, count);
}
macro TorqueCopyElements(
    dstElements: FixedDoubleArray, dstIndex: intptr,
    srcElements: FixedDoubleArray, srcIndex: intptr, count: intptr): void {
  CopyElements(
      HOLEY_DOUBLE_ELEMENTS, dstElements, dstIndex, srcElements, srcIndex,
      count);
}

macro LoadElementNoHole<T: type>(a: JSArray, index: Smi): Object
    labels IfHole;

LoadElementNoHole<FixedArray>(a: JSArray, index: Smi): Object
    labels IfHole {
  try {
    let elements: FixedArray =
        Cast<FixedArray>(a.elements) otherwise Unexpected;
    let e: Object = elements[index];
    if (e == Hole) {
      goto IfHole;
    }
    return e;
  }
  label Unexpected {
    unreachable;
  }
}

LoadElementNoHole<FixedDoubleArray>(a: JSArray, index: Smi): Object
    labels IfHole {
  try {
    let elements: FixedDoubleArray =
        Cast<FixedDoubleArray>(a.elements) otherwise Unexpected;
    let e: float64 = LoadDoubleWithHoleCheck(elements, index) otherwise IfHole;
    return AllocateHeapNumberWithValue(e);
  }
  label Unexpected {
    unreachable;
  }
}

extern macro TransitionElementsKind(JSObject, Map, ElementsKind, ElementsKind):
    void
    labels Bailout;

extern macro IsCallable(HeapObject): bool;
extern macro IsJSArray(HeapObject): bool;
extern macro IsJSReceiver(HeapObject): bool;
extern macro TaggedIsCallable(Object): bool;
extern macro IsDetachedBuffer(JSArrayBuffer): bool;
extern macro IsHeapNumber(HeapObject): bool;
extern macro IsFixedArray(HeapObject): bool;
extern macro IsNumber(Object): bool;
extern macro IsExtensibleMap(Map): bool;
extern macro IsCustomElementsReceiverInstanceType(int32): bool;
extern macro IsFastJSArray(Object, Context): bool;
extern macro Typeof(Object): Object;
extern macro LoadTargetFromFrame(): JSFunction;

// Return true iff number is NaN.
macro NumberIsNaN(number: Number): bool {
  typeswitch (number) {
    case (Smi): {
      return false;
    }
    case (hn: HeapNumber): {
      let value: float64 = Convert<float64>(hn);
      return value != value;
    }
  }
}

extern macro BranchIfToBooleanIsTrue(Object): never
    labels Taken, NotTaken;

macro ToBoolean(obj: Object): bool {
  if (BranchIfToBooleanIsTrue(obj)) {
    return true;
  } else {
    return false;
  }
}

macro ToIndex(input: Object, context: Context): Number
    labels RangeError {
  if (input == Undefined) {
    return 0;
  }

  let value: Number = ToInteger_Inline(context, input, kTruncateMinusZero);
  if (value < 0 || value > kMaxSafeInteger) {
    goto RangeError;
  }

  return value;
}

macro GetLengthProperty(context: Context, o: Object): Number {
  try {
    return (Cast<JSArray>(o) otherwise CheckArgs).length;
  }
  label CheckArgs {
    const a: JSArgumentsObjectWithLength =
        Cast<JSArgumentsObjectWithLength>(context, o) otherwise Slow;
    const length: Object = a.length;
    return Cast<Smi>(length) otherwise goto ToLength(length);
  }
  label Slow deferred {
    goto ToLength(GetProperty(context, o, kLengthString));
  }
  label ToLength(length: Object) deferred {
    return ToLength_Inline(context, length);
  }
}
