[/
 / Copyright (c) 2003-2021 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:reference Reference]

[xinclude quickref.xml]

[include requirements/asynchronous_operations.qbk]
[include requirements/read_write_operations.qbk]
[include requirements/synchronous_socket_operations.qbk]
[include requirements/asynchronous_socket_operations.qbk]
[include requirements/AcceptableProtocol.qbk]
[include requirements/AcceptHandler.qbk]
[include requirements/AsyncRandomAccessReadDevice.qbk]
[include requirements/AsyncRandomAccessWriteDevice.qbk]
[include requirements/AsyncReadStream.qbk]
[include requirements/AsyncWriteStream.qbk]
[include requirements/BufferedHandshakeHandler.qbk]
[include requirements/CancellationHandler.qbk]
[include requirements/CancellationSlot.qbk]
[include requirements/CompletionCondition.qbk]
[include requirements/CompletionHandler.qbk]
[include requirements/ConnectCondition.qbk]
[include requirements/ConnectHandler.qbk]
[include requirements/ConstBufferSequence.qbk]
[include requirements/DynamicBuffer.qbk]
[include requirements/DynamicBuffer_v1.qbk]
[include requirements/DynamicBuffer_v2.qbk]
[include requirements/Endpoint.qbk]
[include requirements/EndpointSequence.qbk]
[include requirements/ExecutionContext.qbk]
[include requirements/Executor.qbk]
[include requirements/GettableSerialPortOption.qbk]
[include requirements/GettableSocketOption.qbk]
[include requirements/Handler.qbk]
[include requirements/HandshakeHandler.qbk]
[include requirements/InternetProtocol.qbk]
[include requirements/IoControlCommand.qbk]
[include requirements/IoObjectService.qbk]
[include requirements/IteratorConnectHandler.qbk]
[include requirements/LegacyCompletionHandler.qbk]
[include requirements/MoveAcceptHandler.qbk]
[include requirements/MutableBufferSequence.qbk]
[include requirements/OperationState.qbk]
[include requirements/ProtoAllocator.qbk]
[include requirements/Protocol.qbk]
[include requirements/RangeConnectHandler.qbk]
[include requirements/ReadHandler.qbk]
[include requirements/Receiver.qbk]
[include requirements/ResolveHandler.qbk]
[include requirements/Scheduler.qbk]
[include requirements/Sender.qbk]
[include requirements/Service.qbk]
[include requirements/SettableSerialPortOption.qbk]
[include requirements/SettableSocketOption.qbk]
[include requirements/ShutdownHandler.qbk]
[include requirements/SignalHandler.qbk]
[include requirements/SyncRandomAccessReadDevice.qbk]
[include requirements/SyncRandomAccessWriteDevice.qbk]
[include requirements/SyncReadStream.qbk]
[include requirements/SyncWriteStream.qbk]
[include requirements/TimeTraits.qbk]
[include requirements/WaitHandler.qbk]
[include requirements/WaitTraits.qbk]
[include requirements/WriteHandler.qbk]


[section:any_io_executor any_io_executor]

[indexterm1 boost_asio.indexterm.any_io_executor..any_io_executor]


Polymorphic executor type for use with I/O objects. 


  class any_io_executor :
    public execution::any_executor< SupportableProperties >


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.any_io_executor.any_io_executor [*any_io_executor]] [constructor]]
    [Default constructor. 
     [hr]
     Construct in an empty state. Equivalent effects to default constructor. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. 
     [hr]
     Construct to point to the same target as another any_executor. 
     [hr]
     Construct a polymorphic wrapper for the specified executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.execute [*execute]]]
    [Execute the function on the target executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.operator_bool [*operator bool]]]
    [Determine whether the wrapper has a target executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move assignment operator. 
     [hr]
     Assignment operator that sets the polymorphic wrapper to the empty state. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.prefer [*prefer]]]
    [Obtain a polymorphic wrapper with the specified property. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.query [*query]]]
    [Obtain the value associated with the specified property. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.require [*require]]]
    [Obtain a polymorphic wrapper with the specified property. 
     [hr]
     ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.swap [*swap]]]
    [Swap targets with another polymorphic wrapper. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.target [*target]]]
    [Get a pointer to the target executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.target_type [*target_type]]]
    [Get the type of the target executor. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor._any_io_executor [*~any_io_executor]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.any_io_executor.operator_not__eq_ [*operator!=]]]
    [Inequality operator. ]
  ]
  
  [
    [[link boost_asio.reference.any_io_executor.operator_eq__eq_ [*operator==]]]
    [Equality operator. ]
  ]
  
]

The `any_io_executor` type is a polymorphic executor that supports the set of properties required by I/O objects. It is defined as the [link boost_asio.reference.execution__any_executor `execution::any_executor`] class template parameterised as follows: 

   execution::any_executor<
     execution::context_as_t<execution_context&>,
     execution::blocking_t::never_t,
     execution::prefer_only<execution::blocking_t::possibly_t>,
     execution::prefer_only<execution::outstanding_work_t::tracked_t>,
     execution::prefer_only<execution::outstanding_work_t::untracked_t>,
     execution::prefer_only<execution::relationship_t::fork_t>,
     execution::prefer_only<execution::relationship_t::continuation_t>
   > 




[heading Requirements]

['Header: ][^boost/asio/any_io_executor.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:any_io_executor any_io_executor::any_io_executor]

[indexterm2 boost_asio.indexterm.any_io_executor.any_io_executor..any_io_executor..any_io_executor] 
Default constructor. 


  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload1 any_io_executor]``();
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload1 more...]]``


Construct in an empty state. Equivalent effects to default constructor. 


  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload2 any_io_executor]``(
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload2 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload3 any_io_executor]``(
      const any_io_executor & e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload3 more...]]``


Move constructor. 


  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload4 any_io_executor]``(
      any_io_executor && e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload4 more...]]``


Construct to point to the same target as another any\_executor. 


  template<
      class... OtherSupportableProperties>
  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload5 any_io_executor]``(
      execution::any_executor< OtherSupportableProperties...> e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload5 more...]]``


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  ``[link boost_asio.reference.any_io_executor.any_io_executor.overload6 any_io_executor]``(
      Executor e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.any_io_executor.overload6 more...]]``


[section:overload1 any_io_executor::any_io_executor (1 of 6 overloads)]


Default constructor. 


  any_io_executor();



[endsect]



[section:overload2 any_io_executor::any_io_executor (2 of 6 overloads)]


Construct in an empty state. Equivalent effects to default constructor. 


  any_io_executor(
      nullptr_t );



[endsect]



[section:overload3 any_io_executor::any_io_executor (3 of 6 overloads)]


Copy constructor. 


  any_io_executor(
      const any_io_executor & e);



[endsect]



[section:overload4 any_io_executor::any_io_executor (4 of 6 overloads)]


Move constructor. 


  any_io_executor(
      any_io_executor && e);



[endsect]



[section:overload5 any_io_executor::any_io_executor (5 of 6 overloads)]


Construct to point to the same target as another any\_executor. 


  template<
      class... OtherSupportableProperties>
  any_io_executor(
      execution::any_executor< OtherSupportableProperties...> e);



[endsect]



[section:overload6 any_io_executor::any_io_executor (6 of 6 overloads)]


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  any_io_executor(
      Executor e);



[endsect]


[endsect]


[section:context any_io_executor::context]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_io_executor.context..context..any_io_executor] 
Obtain the underlying execution context. 


  automatically_determined context() const;


This function is provided for backward compatibility. It is automatically defined when the `SupportableProperties`... list includes a property of type `execution::context_as<U>`, for some type `U`. 


[endsect]



[section:execute any_io_executor::execute]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_io_executor.execute..execute..any_io_executor] 
Execute the function on the target executor. 


  template<
      typename Function>
  void execute(
      Function && f) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.execution__execute `execution::execute`] customisation point.

For example: 

   execution::any_executor<> ex = ...;
   execution::execute(ex, my_function_object); 




Throws [link boost_asio.reference.bad_executor `bad_executor`] if the polymorphic wrapper has no target. 


[endsect]



[section:operator_bool any_io_executor::operator bool]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_io_executor.operator_bool..operator bool..any_io_executor] 
Determine whether the wrapper has a target executor. 


  operator bool() const;



[heading Return Value]
      
`true` if the polymorphic wrapper has a target executor, otherwise false. 




[endsect]


[section:operator_not__eq_ any_io_executor::operator!=]

[indexterm2 boost_asio.indexterm.any_io_executor.operator_not__eq_..operator!=..any_io_executor] 
Inequality operator. 


  bool ``[link boost_asio.reference.any_io_executor.operator_not__eq_.overload1 operator!=]``(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_not__eq_.overload1 more...]]``

  bool ``[link boost_asio.reference.any_io_executor.operator_not__eq_.overload2 operator!=]``(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_not__eq_.overload2 more...]]``

  bool ``[link boost_asio.reference.any_io_executor.operator_not__eq_.overload3 operator!=]``(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_not__eq_.overload3 more...]]``


[section:overload1 any_io_executor::operator!= (1 of 3 overloads)]


['Inherited from execution::any_executor.]


Inequality operator. 


  bool operator!=(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);



[endsect]



[section:overload2 any_io_executor::operator!= (2 of 3 overloads)]


['Inherited from execution::any_executor.]


Inequality operator. 


  bool operator!=(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );



[endsect]



[section:overload3 any_io_executor::operator!= (3 of 3 overloads)]


['Inherited from execution::any_executor.]


Inequality operator. 


  bool operator!=(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);



[endsect]


[endsect]

[section:operator_eq_ any_io_executor::operator=]

[indexterm2 boost_asio.indexterm.any_io_executor.operator_eq_..operator=..any_io_executor] 
Assignment operator. 


  any_io_executor & ``[link boost_asio.reference.any_io_executor.operator_eq_.overload1 operator=]``(
      const any_io_executor & e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_eq_.overload1 more...]]``


Move assignment operator. 


  any_io_executor & ``[link boost_asio.reference.any_io_executor.operator_eq_.overload2 operator=]``(
      any_io_executor && e);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_eq_.overload2 more...]]``


Assignment operator that sets the polymorphic wrapper to the empty state. 


  any_io_executor & ``[link boost_asio.reference.any_io_executor.operator_eq_.overload3 operator=]``(
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_eq_.overload3 more...]]``


[section:overload1 any_io_executor::operator= (1 of 3 overloads)]


Assignment operator. 


  any_io_executor & operator=(
      const any_io_executor & e);



[endsect]



[section:overload2 any_io_executor::operator= (2 of 3 overloads)]


Move assignment operator. 


  any_io_executor & operator=(
      any_io_executor && e);



[endsect]



[section:overload3 any_io_executor::operator= (3 of 3 overloads)]


Assignment operator that sets the polymorphic wrapper to the empty state. 


  any_io_executor & operator=(
      nullptr_t );



[endsect]


[endsect]

[section:operator_eq__eq_ any_io_executor::operator==]

[indexterm2 boost_asio.indexterm.any_io_executor.operator_eq__eq_..operator==..any_io_executor] 
Equality operator. 


  bool ``[link boost_asio.reference.any_io_executor.operator_eq__eq_.overload1 operator==]``(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_eq__eq_.overload1 more...]]``

  bool ``[link boost_asio.reference.any_io_executor.operator_eq__eq_.overload2 operator==]``(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_eq__eq_.overload2 more...]]``

  bool ``[link boost_asio.reference.any_io_executor.operator_eq__eq_.overload3 operator==]``(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.operator_eq__eq_.overload3 more...]]``


[section:overload1 any_io_executor::operator== (1 of 3 overloads)]


['Inherited from execution::any_executor.]


Equality operator. 


  bool operator==(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);



[endsect]



[section:overload2 any_io_executor::operator== (2 of 3 overloads)]


['Inherited from execution::any_executor.]


Equality operator. 


  bool operator==(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );



[endsect]



[section:overload3 any_io_executor::operator== (3 of 3 overloads)]


['Inherited from execution::any_executor.]


Equality operator. 


  bool operator==(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);



[endsect]


[endsect]

[section:prefer any_io_executor::prefer]

[indexterm2 boost_asio.indexterm.any_io_executor.prefer..prefer..any_io_executor] 
Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_io_executor ``[link boost_asio.reference.any_io_executor.prefer.overload1 prefer]``(
      const Property & p,
      typename constraint< traits::prefer_member< const base_type &, const Property & >::is_valid >::type  = 0) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload1 more...]]``

  template<>
  any_io_executor ``[link boost_asio.reference.any_io_executor.prefer.overload2 prefer]``(
      const execution::blocking_t::possibly_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload2 more...]]``

  template<>
  any_io_executor ``[link boost_asio.reference.any_io_executor.prefer.overload3 prefer]``(
      const execution::outstanding_work_t::tracked_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload3 more...]]``

  template<>
  any_io_executor ``[link boost_asio.reference.any_io_executor.prefer.overload4 prefer]``(
      const execution::outstanding_work_t::untracked_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload4 more...]]``

  template<>
  any_io_executor ``[link boost_asio.reference.any_io_executor.prefer.overload5 prefer]``(
      const execution::relationship_t::fork_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload5 more...]]``

  template<>
  any_io_executor ``[link boost_asio.reference.any_io_executor.prefer.overload6 prefer]``(
      const execution::relationship_t::continuation_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload6 more...]]``

  template<
      typename Property>
  any_executor ``[link boost_asio.reference.any_io_executor.prefer.overload7 prefer]``(
      Property ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.prefer.overload7 more...]]``


[section:overload1 any_io_executor::prefer (1 of 7 overloads)]


Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_io_executor prefer(
      const Property & p,
      typename constraint< traits::prefer_member< const base_type &, const Property & >::is_valid >::type  = 0) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.prefer `prefer`] customisation point.

For example: 

   any_io_executor ex = ...;
   auto ex2 = boost::asio::prefer(ex, execution::blocking.possibly); 





[endsect]



[section:overload2 any_io_executor::prefer (2 of 7 overloads)]



  template<>
  any_io_executor prefer(
      const execution::blocking_t::possibly_t & p,
      int ) const;



[endsect]



[section:overload3 any_io_executor::prefer (3 of 7 overloads)]



  template<>
  any_io_executor prefer(
      const execution::outstanding_work_t::tracked_t & p,
      int ) const;



[endsect]



[section:overload4 any_io_executor::prefer (4 of 7 overloads)]



  template<>
  any_io_executor prefer(
      const execution::outstanding_work_t::untracked_t & p,
      int ) const;



[endsect]



[section:overload5 any_io_executor::prefer (5 of 7 overloads)]



  template<>
  any_io_executor prefer(
      const execution::relationship_t::fork_t & p,
      int ) const;



[endsect]



[section:overload6 any_io_executor::prefer (6 of 7 overloads)]



  template<>
  any_io_executor prefer(
      const execution::relationship_t::continuation_t & p,
      int ) const;



[endsect]



[section:overload7 any_io_executor::prefer (7 of 7 overloads)]


['Inherited from execution::any_executor.]


Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_executor prefer(
      Property ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.prefer `prefer`] customisation point.

For example: 

   execution::any_executor<execution::blocking_t::possibly_t> ex = ...;
   auto ex2 = boost::asio::prefer(ex, execution::blocking.possibly); 





[endsect]


[endsect]


[section:query any_io_executor::query]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_io_executor.query..query..any_io_executor] 
Obtain the value associated with the specified property. 


  template<
      typename Property>
  Property::polymorphic_query_result_type query(
      Property ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   execution::any_executor<execution::occupancy_t> ex = ...;
   size_t n = boost::asio::query(ex, execution::occupancy); 





[endsect]


[section:require any_io_executor::require]

[indexterm2 boost_asio.indexterm.any_io_executor.require..require..any_io_executor] 
Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_io_executor ``[link boost_asio.reference.any_io_executor.require.overload1 require]``(
      const Property & p,
      typename constraint< traits::require_member< const base_type &, const Property & >::is_valid >::type  = 0) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.require.overload1 more...]]``



  template<>
  any_io_executor ``[link boost_asio.reference.any_io_executor.require.overload2 require]``(
      const execution::blocking_t::never_t & p,
      int ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.require.overload2 more...]]``

  template<
      typename Property>
  any_executor ``[link boost_asio.reference.any_io_executor.require.overload3 require]``(
      Property ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.require.overload3 more...]]``


[section:overload1 any_io_executor::require (1 of 3 overloads)]


Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_io_executor require(
      const Property & p,
      typename constraint< traits::require_member< const base_type &, const Property & >::is_valid >::type  = 0) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] and [link boost_asio.reference.prefer `prefer`] customisation points.

For example: 

   any_io_executor ex = ...;
   auto ex2 = boost::asio::require(ex, execution::blocking.possibly); 





[endsect]



[section:overload2 any_io_executor::require (2 of 3 overloads)]



  template<>
  any_io_executor require(
      const execution::blocking_t::never_t & p,
      int ) const;



[endsect]



[section:overload3 any_io_executor::require (3 of 3 overloads)]


['Inherited from execution::any_executor.]


Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_executor require(
      Property ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] and [link boost_asio.reference.prefer `prefer`] customisation points.

For example: 

   execution::any_executor<execution::blocking_t::possibly_t> ex = ...;
   auto ex2 = boost::asio::requre(ex, execution::blocking.possibly); 





[endsect]


[endsect]

[section:swap any_io_executor::swap]

[indexterm2 boost_asio.indexterm.any_io_executor.swap..swap..any_io_executor] 
Swap targets with another polymorphic wrapper. 


  void ``[link boost_asio.reference.any_io_executor.swap.overload1 swap]``(
      any_io_executor & other);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.swap.overload1 more...]]``

  void ``[link boost_asio.reference.any_io_executor.swap.overload2 swap]``(
      any_executor & other);
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.swap.overload2 more...]]``


[section:overload1 any_io_executor::swap (1 of 2 overloads)]


Swap targets with another polymorphic wrapper. 


  void swap(
      any_io_executor & other);



[endsect]



[section:overload2 any_io_executor::swap (2 of 2 overloads)]


['Inherited from execution::any_executor.]


Swap targets with another polymorphic wrapper. 


  void swap(
      any_executor & other);



[endsect]


[endsect]

[section:target any_io_executor::target]

[indexterm2 boost_asio.indexterm.any_io_executor.target..target..any_io_executor] 
Get a pointer to the target executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  Executor * ``[link boost_asio.reference.any_io_executor.target.overload1 target]``();
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.target.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  const Executor * ``[link boost_asio.reference.any_io_executor.target.overload2 target]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.any_io_executor.target.overload2 more...]]``


[section:overload1 any_io_executor::target (1 of 2 overloads)]


['Inherited from execution::any_executor.]


Get a pointer to the target executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  Executor * target();



[endsect]



[section:overload2 any_io_executor::target (2 of 2 overloads)]


['Inherited from execution::any_executor.]


Get a pointer to the target executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  const Executor * target() const;



[endsect]


[endsect]


[section:target_type any_io_executor::target_type]


['Inherited from execution::any_executor.]

[indexterm2 boost_asio.indexterm.any_io_executor.target_type..target_type..any_io_executor] 
Get the type of the target executor. 


  const type_info & target_type() const;



[endsect]



[section:_any_io_executor any_io_executor::~any_io_executor]

[indexterm2 boost_asio.indexterm.any_io_executor._any_io_executor..~any_io_executor..any_io_executor] 
Destructor. 


  ~any_io_executor();



[endsect]



[endsect]


[section:asio_handler_allocate asio_handler_allocate]

[indexterm1 boost_asio.indexterm.asio_handler_allocate..asio_handler_allocate] 
(Deprecated: Use the [link boost_asio.reference.associated_allocator `associated_allocator`] trait.) Default allocation function for handlers. 


  asio_handler_allocate_is_deprecated asio_handler_allocate(
      std::size_t size,
      ... );


Asynchronous operations may need to allocate temporary objects. Since asynchronous operations have a handler function object, these temporary objects can be said to be associated with the handler.

Implement asio\_handler\_allocate and asio\_handler\_deallocate for your own handlers to provide custom allocation for these temporary objects.

The default implementation of these allocation hooks uses `operator new` and `operator delete`.


[heading Remarks]
      
All temporary objects associated with a handler will be deallocated before the upcall to the handler is performed. This allows the same memory to be reused for a subsequent asynchronous operation initiated by the handler.


[heading Example]
  


   class my_handler;

   void* asio_handler_allocate(std::size_t size, my_handler* context)
   {
     return ::operator new(size);
   }

   void asio_handler_deallocate(void* pointer, std::size_t size,
       my_handler* context)
   {
     ::operator delete(pointer);
   }






[heading Requirements]

['Header: ][^boost/asio/handler_alloc_hook.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:asio_handler_deallocate asio_handler_deallocate]

[indexterm1 boost_asio.indexterm.asio_handler_deallocate..asio_handler_deallocate] 
Default deallocation function for handlers. 


  asio_handler_deallocate_is_deprecated asio_handler_deallocate(
      void * pointer,
      std::size_t size,
      ... );


Implement asio\_handler\_allocate and asio\_handler\_deallocate for your own handlers to provide custom allocation for the associated temporary objects.

The default implementation of these allocation hooks uses `operator new` and `operator delete`.




[heading Requirements]

['Header: ][^boost/asio/handler_alloc_hook.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:asio_handler_invoke asio_handler_invoke]

[indexterm1 boost_asio.indexterm.asio_handler_invoke..asio_handler_invoke] 
(Deprecated: Use the [link boost_asio.reference.associated_executor `associated_executor`] trait.) Default invoke function for handlers. 


Default handler invocation hook used for non-const function objects. 

  template<
      typename Function>
  asio_handler_invoke_is_deprecated ``[link boost_asio.reference.asio_handler_invoke.overload1 asio_handler_invoke]``(
      Function & function,
      ... );
  ``  [''''&raquo;''' [link boost_asio.reference.asio_handler_invoke.overload1 more...]]``

Default handler invocation hook used for const function objects. 

  template<
      typename Function>
  asio_handler_invoke_is_deprecated ``[link boost_asio.reference.asio_handler_invoke.overload2 asio_handler_invoke]``(
      const Function & function,
      ... );
  ``  [''''&raquo;''' [link boost_asio.reference.asio_handler_invoke.overload2 more...]]``

Completion handlers for asynchronous operations are invoked by the [link boost_asio.reference.io_context `io_context`] associated with the corresponding object (e.g. a socket or deadline\_timer). Certain guarantees are made on when the handler may be invoked, in particular that a handler can only be invoked from a thread that is currently calling `run()` on the corresponding [link boost_asio.reference.io_context `io_context`] object. Handlers may subsequently be invoked through other objects (such as [link boost_asio.reference.io_context__strand `io_context::strand`] objects) that provide additional guarantees.

When asynchronous operations are composed from other asynchronous operations, all intermediate handlers should be invoked using the same method as the final handler. This is required to ensure that user-defined objects are not accessed in a way that may violate the guarantees. This hooking function ensures that the invoked method used for the final handler is accessible at each intermediate step.

Implement asio\_handler\_invoke for your own handlers to specify a custom invocation strategy.

This default implementation invokes the function object like so: 

   function(); 


If necessary, the default implementation makes a copy of the function object so that the non-const operator() can be used.


[heading Example]
  


   class my_handler;

   template <typename Function>
   void asio_handler_invoke(Function function, my_handler* context)
   {
     context->strand_.dispatch(function);
   }






[heading Requirements]

['Header: ][^boost/asio/handler_invoke_hook.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 asio_handler_invoke (1 of 2 overloads)]


Default handler invocation hook used for non-const function objects. 


  template<
      typename Function>
  asio_handler_invoke_is_deprecated asio_handler_invoke(
      Function & function,
      ... );



[endsect]



[section:overload2 asio_handler_invoke (2 of 2 overloads)]


Default handler invocation hook used for const function objects. 


  template<
      typename Function>
  asio_handler_invoke_is_deprecated asio_handler_invoke(
      const Function & function,
      ... );



[endsect]


[endsect]


[section:asio_handler_is_continuation asio_handler_is_continuation]

[indexterm1 boost_asio.indexterm.asio_handler_is_continuation..asio_handler_is_continuation] 
Default continuation function for handlers. 


  bool asio_handler_is_continuation(
      ... );


Asynchronous operations may represent a continuation of the asynchronous control flow associated with the current handler. The implementation can use this knowledge to optimise scheduling of the handler.

Implement asio\_handler\_is\_continuation for your own handlers to indicate when a handler represents a continuation.

The default implementation of the continuation hook returns `false`.


[heading Example]
  


   class my_handler;

   bool asio_handler_is_continuation(my_handler* context)
   {
     return true;
   }






[heading Requirements]

['Header: ][^boost/asio/handler_continuation_hook.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:associated_allocator associated_allocator]

[indexterm1 boost_asio.indexterm.associated_allocator..associated_allocator]


Traits type used to obtain the allocator associated with an object. 


  template<
      typename T,
      typename Allocator = std::allocator<void>>
  struct associated_allocator


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_allocator.type [*type]]]
    [If T has a nested type allocator_type, T::allocator_type. Otherwise Allocator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_allocator.get [*get]] [static]]
    [If T has a nested type allocator_type, returns t.get_allocator(). Otherwise returns a. ]
  ]
  
]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `Allocator` shall be a type meeting the Allocator requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `a` is an object of type `Allocator`.


* Provide a nested typedef `type` that identifies a type meeting the Allocator requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,a)` and with return type `type`. 



[heading Requirements]

['Header: ][^boost/asio/associated_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:get associated_allocator::get]

[indexterm2 boost_asio.indexterm.associated_allocator.get..get..associated_allocator] 
If `T` has a nested type `allocator_type`, returns `t.get_allocator()`. Otherwise returns `a`. 


  static type get(
      const T & t,
      const Allocator & a = Allocator());



[endsect]



[section:type associated_allocator::type]

[indexterm2 boost_asio.indexterm.associated_allocator.type..type..associated_allocator] 
If `T` has a nested type `allocator_type`, `T::allocator_type`. Otherwise `Allocator`. 


  typedef see_below type;



[heading Requirements]

['Header: ][^boost/asio/associated_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_ associated_allocator< reference_wrapper< T >, Allocator >]

[indexterm1 boost_asio.indexterm.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_..associated_allocator< reference_wrapper< T >, Allocator >]


Specialisation of [link boost_asio.reference.associated_allocator `associated_allocator`] for `std::reference_wrapper`. 


  template<
      typename T,
      typename Allocator>
  struct associated_allocator< reference_wrapper< T >, Allocator >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_.type [*type]]]
    [Forwards type to the associator specialisation for the unwrapped type T. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_.get [*get]] [static]]
    [Forwards the request to get the allocator to the associator specialisation for the unwrapped type T. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/associated_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:get associated_allocator< reference_wrapper< T >, Allocator >::get]

[indexterm2 boost_asio.indexterm.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_.get..get..associated_allocator< reference_wrapper< T >, Allocator >] 
Forwards the request to get the allocator to the associator specialisation for the unwrapped type `T`. 


  static type get(
      reference_wrapper< T > t,
      const Allocator & a = Allocator());



[endsect]



[section:type associated_allocator< reference_wrapper< T >, Allocator >::type]

[indexterm2 boost_asio.indexterm.associated_allocator_lt__reference_wrapper_lt__T__gt__comma__Allocator__gt_.type..type..associated_allocator< reference_wrapper< T >, Allocator >] 
Forwards `type` to the associator specialisation for the unwrapped type `T`. 


  typedef associated_allocator< T, Allocator >::type type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_allocator.type [*type]]]
    [If T has a nested type allocator_type, T::allocator_type. Otherwise Allocator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_allocator.get [*get]] [static]]
    [If T has a nested type allocator_type, returns t.get_allocator(). Otherwise returns a. ]
  ]
  
]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `Allocator` shall be a type meeting the Allocator requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `a` is an object of type `Allocator`.


* Provide a nested typedef `type` that identifies a type meeting the Allocator requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,a)` and with return type `type`. 




[heading Requirements]

['Header: ][^boost/asio/associated_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:associated_cancellation_slot associated_cancellation_slot]

[indexterm1 boost_asio.indexterm.associated_cancellation_slot..associated_cancellation_slot]


Traits type used to obtain the [link boost_asio.reference.cancellation_slot `cancellation_slot`] associated with an object. 


  template<
      typename T,
      typename ``[link boost_asio.reference.CancellationSlot CancellationSlot]`` = cancellation_slot>
  struct associated_cancellation_slot


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_cancellation_slot.type [*type]]]
    [If T has a nested type cancellation_slot_type, T::cancellation_slot_type. Otherwise CancellationSlot. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_cancellation_slot.get [*get]] [static]]
    [If T has a nested type cancellation_slot_type, returns t.get_cancellation_slot(). Otherwise returns s. ]
  ]
  
]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `CancellationSlot` shall be a type meeting the CancellationSlot requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `s` is an object of type `CancellationSlot`.


* Provide a nested typedef `type` that identifies a type meeting the CancellationSlot requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,s)` and with return type `type`. 



[heading Requirements]

['Header: ][^boost/asio/associated_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:get associated_cancellation_slot::get]

[indexterm2 boost_asio.indexterm.associated_cancellation_slot.get..get..associated_cancellation_slot] 
If `T` has a nested type `cancellation_slot_type`, returns `t.get_cancellation_slot()`. Otherwise returns `s`. 


  static type get(
      const T & t,
      const CancellationSlot & s = CancellationSlot());



[endsect]



[section:type associated_cancellation_slot::type]

[indexterm2 boost_asio.indexterm.associated_cancellation_slot.type..type..associated_cancellation_slot] 
If `T` has a nested type `cancellation_slot_type`, `T::cancellation_slot_type`. Otherwise `CancellationSlot`. 


  typedef see_below type;



[heading Requirements]

['Header: ][^boost/asio/associated_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:associated_executor associated_executor]

[indexterm1 boost_asio.indexterm.associated_executor..associated_executor]


Traits type used to obtain the executor associated with an object. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]`` = system_executor>
  struct associated_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_executor.type [*type]]]
    [If T has a nested type executor_type, T::executor_type. Otherwise Executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_executor.get [*get]] [static]]
    [If T has a nested type executor_type, returns t.get_executor(). Otherwise returns ex. ]
  ]
  
]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `Executor` shall be a type meeting the Executor requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `e` is an object of type `Executor`.


* Provide a nested typedef `type` that identifies a type meeting the Executor requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,e)` and with return type `type`. 



[heading Requirements]

['Header: ][^boost/asio/associated_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:get associated_executor::get]

[indexterm2 boost_asio.indexterm.associated_executor.get..get..associated_executor] 
If `T` has a nested type `executor_type`, returns `t.get_executor()`. Otherwise returns `ex`. 


  static type get(
      const T & t,
      const Executor & ex = Executor());



[endsect]



[section:type associated_executor::type]

[indexterm2 boost_asio.indexterm.associated_executor.type..type..associated_executor] 
If `T` has a nested type `executor_type`, `T::executor_type`. Otherwise `Executor`. 


  typedef see_below type;



[heading Requirements]

['Header: ][^boost/asio/associated_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_ associated_executor< reference_wrapper< T >, Executor >]

[indexterm1 boost_asio.indexterm.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_..associated_executor< reference_wrapper< T >, Executor >]


Specialisation of [link boost_asio.reference.associated_executor `associated_executor`] for `std::reference_wrapper`. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  struct associated_executor< reference_wrapper< T >, Executor >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.type [*type]]]
    [Forwards type to the associator specialisation for the unwrapped type T. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.get [*get]] [static]]
    [Forwards the request to get the executor to the associator specialisation for the unwrapped type T. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/associated_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:get associated_executor< reference_wrapper< T >, Executor >::get]

[indexterm2 boost_asio.indexterm.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.get..get..associated_executor< reference_wrapper< T >, Executor >] 
Forwards the request to get the executor to the associator specialisation for the unwrapped type `T`. 


  static type get(
      reference_wrapper< T > t,
      const Executor & ex = Executor());



[endsect]



[section:type associated_executor< reference_wrapper< T >, Executor >::type]

[indexterm2 boost_asio.indexterm.associated_executor_lt__reference_wrapper_lt__T__gt__comma__Executor__gt_.type..type..associated_executor< reference_wrapper< T >, Executor >] 
Forwards `type` to the associator specialisation for the unwrapped type `T`. 


  typedef associated_executor< T, Executor >::type type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.associated_executor.type [*type]]]
    [If T has a nested type executor_type, T::executor_type. Otherwise Executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.associated_executor.get [*get]] [static]]
    [If T has a nested type executor_type, returns t.get_executor(). Otherwise returns ex. ]
  ]
  
]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type. The template parameter `Executor` shall be a type meeting the Executor requirements.

Specialisations shall meet the following requirements, where `t` is a const reference to an object of type `T`, and `e` is an object of type `Executor`.


* Provide a nested typedef `type` that identifies a type meeting the Executor requirements.


* Provide a noexcept static member function named `get`, callable as `get(t)` and with return type `type`.


* Provide a noexcept static member function named `get`, callable as `get(t,e)` and with return type `type`. 




[heading Requirements]

['Header: ][^boost/asio/associated_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:associator associator]

[indexterm1 boost_asio.indexterm.associator..associator]


Used to generically specialise associators for a type. 


  template<
      template< typename, typename > class Associator,
      typename T,
      typename DefaultCandidate>
  struct associator


[heading Requirements]

['Header: ][^boost/asio/associator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:async_completion async_completion]

[indexterm1 boost_asio.indexterm.async_completion..async_completion]


Helper template to deduce the handler type from a CompletionToken, capture a local copy of the handler, and then create an [link boost_asio.reference.async_result `async_result`] for the handler. 


  template<
      typename CompletionToken,
      typename... Signatures>
  struct async_completion


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.async_completion.completion_handler_type [*completion_handler_type]]]
    [The real handler type to be used for the asynchronous operation. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.async_completion.async_completion [*async_completion]] [constructor]]
    [Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.async_completion.completion_handler [*completion_handler]]]
    [A copy of, or reference to, a real handler object. ]
  ]

  [
    [[link boost_asio.reference.async_completion.result [*result]]]
    [The result of the asynchronous operation's initiating function. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:async_completion async_completion::async_completion]

[indexterm2 boost_asio.indexterm.async_completion.async_completion..async_completion..async_completion] 
Constructor. 


  async_completion(
      CompletionToken & token);


The constructor creates the concrete completion handler and makes the link between the handler and the asynchronous result. 


[endsect]



[section:completion_handler async_completion::completion_handler]

[indexterm2 boost_asio.indexterm.async_completion.completion_handler..completion_handler..async_completion] 
A copy of, or reference to, a real handler object. 


  conditional< is_same< CompletionToken, completion_handler_type >::value, completion_handler_type &, completion_handler_type >::type completion_handler;



[endsect]



[section:completion_handler_type async_completion::completion_handler_type]

[indexterm2 boost_asio.indexterm.async_completion.completion_handler_type..completion_handler_type..async_completion] 
The real handler type to be used for the asynchronous operation. 


  typedef boost::asio::async_result< typename decay< CompletionToken >::type, Signatures... >::completion_handler_type completion_handler_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.async_result.completion_handler_type [*completion_handler_type]]]
    [The concrete completion handler type for the specific signature. ]
  
  ]

  [

    [[link boost_asio.reference.async_result.return_type [*return_type]]]
    [The return type of the initiating function. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.async_result.async_result [*async_result]] [constructor]]
    [Construct an async result from a given handler. ]
  ]
  
  [
    [[link boost_asio.reference.async_result.get [*get]]]
    [Obtain the value to be returned from the initiating function. ]
  ]
  
  [
    [[link boost_asio.reference.async_result.initiate [*initiate]] [static]]
    [Initiate the asynchronous operation that will produce the result, and obtain the value to be returned from the initiating function. ]
  ]
  
]

The [link boost_asio.reference.async_result `async_result`] traits class is used for determining:


* the concrete completion handler type to be called at the end of the asynchronous operation;


* the initiating function return type; and


* how the return value of the initiating function is obtained.

The trait allows the handler and return types to be determined at the point where the specific completion handler signature is known.

This template may be specialised for user-defined completion token types. The primary template assumes that the CompletionToken is the completion handler. 


[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:result async_completion::result]

[indexterm2 boost_asio.indexterm.async_completion.result..result..async_completion] 
The result of the asynchronous operation's initiating function. 


  async_result< typename decay< CompletionToken >::type, Signatures... > result;



[endsect]



[endsect]


[section:async_compose async_compose]

[indexterm1 boost_asio.indexterm.async_compose..async_compose] 
Launch an asynchronous operation with a stateful implementation. 


  template<
      typename CompletionToken,
      typename Signature,
      typename Implementation,
      typename... IoObjectsOrExecutors>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_compose(
      Implementation && implementation,
      CompletionToken & token,
      IoObjectsOrExecutors &&... io_objects_or_executors);


The async\_compose function simplifies the implementation of composed asynchronous operations automatically wrapping a stateful function object with a conforming intermediate completion handler.


[heading Parameters]
    

[variablelist
  
[[implementation][A function object that contains the implementation of the composed asynchronous operation. The first argument to the function object is a non-const reference to the enclosing intermediate completion handler. The remaining arguments are any arguments that originate from the completion handlers of any asynchronous operations performed by the implementation.]]

[[token][The completion token.]]

[[io_objects_or_executors][Zero or more I/O objects or I/O executors for which outstanding work must be maintained.]]

]


[heading Example:]
  




   struct async_echo_implementation
   {
     tcp::socket& socket_;
     boost::asio::mutable_buffer buffer_;
     enum { starting, reading, writing } state_;

     template <typename Self>
     void operator()(Self& self,
         boost::system::error_code error = {},
         std::size_t n = 0)
     {
       switch (state_)
       {
       case starting:
         state_ = reading;
         socket_.async_read_some(
             buffer_, std::move(self));
         break;
       case reading:
         if (error)
         {
           self.complete(error, 0);
         }
         else
         {
           state_ = writing;
           boost::asio::async_write(socket_, buffer_,
               boost::asio::transfer_exactly(n),
               std::move(self));
         }
         break;
       case writing:
         self.complete(error, n);
         break;
       }
     }
   };

   template <typename CompletionToken>
   auto async_echo(tcp::socket& socket,
       boost::asio::mutable_buffer buffer,
       CompletionToken&& token) ->
     typename boost::asio::async_result<
       typename std::decay<CompletionToken>::type,
         void(boost::system::error_code, std::size_t)>::return_type
   {
     return boost::asio::async_compose<CompletionToken,
       void(boost::system::error_code, std::size_t)>(
         async_echo_implementation{socket, buffer,
           async_echo_implementation::starting},
         token, socket);
   } 




[heading Requirements]

['Header: ][^boost/asio/compose.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:async_connect async_connect]

[indexterm1 boost_asio.indexterm.async_connect..async_connect] 
The `async_connect` function is a composed asynchronous operation that establishes a socket connection by trying each endpoint in a sequence. 


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``,
      typename ``[link boost_asio.reference.RangeConnectHandler RangeConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_connect.overload1 async_connect]``(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      RangeConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_connect.overload1 more...]]``

(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.IteratorConnectHandler IteratorConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_connect.overload2 async_connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      IteratorConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_connect.overload2 more...]]``

Asynchronously establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.IteratorConnectHandler IteratorConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_connect.overload3 async_connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      IteratorConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_connect.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``,
      typename ``[link boost_asio.reference.RangeConnectHandler RangeConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_connect.overload4 async_connect]``(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      RangeConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_connect.overload4 more...]]``

(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``,
      typename ``[link boost_asio.reference.IteratorConnectHandler IteratorConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_connect.overload5 async_connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      ConnectCondition connect_condition,
      IteratorConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_connect.overload5 more...]]``

Asynchronously establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``,
      typename ``[link boost_asio.reference.IteratorConnectHandler IteratorConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_connect.overload6 async_connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition,
      IteratorConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_connect.overload6 more...]]``

[heading Requirements]

['Header: ][^boost/asio/connect.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 async_connect (1 of 6 overloads)]


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``,
      typename ``[link boost_asio.reference.RangeConnectHandler RangeConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      RangeConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

[[handler][The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // boost::asio::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const boost::system::error_code& error,

     // On success, the successfully connected endpoint.
     // Otherwise, a default-constructed endpoint.
     const typename Protocol::endpoint& endpoint
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(my_context);

   // ...

   r.async_resolve(q, resolve_handler);

   // ...

   void resolve_handler(
       const boost::system::error_code& ec,
       tcp::resolver::results_type results)
   {
     if (!ec)
     {
       boost::asio::async_connect(s, results, connect_handler);
     }
   }

   // ...

   void connect_handler(
       const boost::system::error_code& ec,
       const tcp::endpoint& endpoint)
   {
     // ...
   } 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the socket's `async_connect` operation. 


[endsect]



[section:overload2 async_connect (2 of 6 overloads)]


(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.IteratorConnectHandler IteratorConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      IteratorConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[handler][The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // boost::asio::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const boost::system::error_code& error,

     // On success, an iterator denoting the successfully
     // connected endpoint. Otherwise, the end iterator.
     Iterator iterator
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the socket's `async_connect` operation. 


[endsect]



[section:overload3 async_connect (3 of 6 overloads)]


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.IteratorConnectHandler IteratorConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      IteratorConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

[[handler][The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // boost::asio::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const boost::system::error_code& error,

     // On success, an iterator denoting the successfully
     // connected endpoint. Otherwise, the end iterator.
     Iterator iterator
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   std::vector<tcp::endpoint> endpoints = ...;
   tcp::socket s(my_context);
   boost::asio::async_connect(s,
       endpoints.begin(), endpoints.end(),
       connect_handler);

   // ...

   void connect_handler(
       const boost::system::error_code& ec,
       std::vector<tcp::endpoint>::iterator i)
   {
     // ...
   } 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the socket's `async_connect` operation. 


[endsect]



[section:overload4 async_connect (4 of 6 overloads)]


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``,
      typename ``[link boost_asio.reference.RangeConnectHandler RangeConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      RangeConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const boost::system::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

[[handler][The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // boost::asio::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const boost::system::error_code& error,

     // On success, an iterator denoting the successfully
     // connected endpoint. Otherwise, the end iterator.
     Iterator iterator
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const boost::system::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the `boost::asio::connect` function as follows: 

   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(my_context);

   // ...

   r.async_resolve(q, resolve_handler);

   // ...

   void resolve_handler(
       const boost::system::error_code& ec,
       tcp::resolver::results_type results)
   {
     if (!ec)
     {
       boost::asio::async_connect(s, results,
           my_connect_condition(),
           connect_handler);
     }
   }

   // ...

   void connect_handler(
       const boost::system::error_code& ec,
       const tcp::endpoint& endpoint)
   {
     if (ec)
     {
       // An error occurred.
     }
     else
     {
       std::cout << "Connected to: " << endpoint << std::endl;
     }
   } 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the socket's `async_connect` operation. 


[endsect]



[section:overload5 async_connect (5 of 6 overloads)]


(Deprecated: Use range overload.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``,
      typename ``[link boost_asio.reference.IteratorConnectHandler IteratorConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      ConnectCondition connect_condition,
      IteratorConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const boost::system::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

[[handler][The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // boost::asio::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const boost::system::error_code& error,

     // On success, an iterator denoting the successfully
     // connected endpoint. Otherwise, the end iterator.
     Iterator iterator
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the socket's `async_connect` operation. 


[endsect]



[section:overload6 async_connect (6 of 6 overloads)]


Asynchronously establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``,
      typename ``[link boost_asio.reference.IteratorConnectHandler IteratorConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition,
      IteratorConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `async_connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const boost::system::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

[[handler][The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation. if the sequence is empty, set to
     // boost::asio::error::not_found. Otherwise, contains the
     // error from the last connection attempt.
     const boost::system::error_code& error,

     // On success, an iterator denoting the successfully
     // connected endpoint. Otherwise, the end iterator.
     Iterator iterator
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const boost::system::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the `boost::asio::connect` function as follows: 

   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(my_context);

   // ...

   r.async_resolve(q, resolve_handler);

   // ...

   void resolve_handler(
       const boost::system::error_code& ec,
       tcp::resolver::iterator i)
   {
     if (!ec)
     {
       tcp::resolver::iterator end;
       boost::asio::async_connect(s, i, end,
           my_connect_condition(),
           connect_handler);
     }
   }

   // ...

   void connect_handler(
       const boost::system::error_code& ec,
       tcp::resolver::iterator i)
   {
     if (ec)
     {
       // An error occurred.
     }
     else
     {
       std::cout << "Connected to: " << i->endpoint() << std::endl;
     }
   } 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the socket's `async_connect` operation. 


[endsect]


[endsect]


[section:async_initiate async_initiate]

[indexterm1 boost_asio.indexterm.async_initiate..async_initiate] 

  template<
      typename CompletionToken,
      completion_signature... Signatures,
      typename Initiation,
      typename... Args>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_initiate(
      Initiation && initiation,
      CompletionToken & ,
      Args &&... args);


[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:async_read async_read]

[indexterm1 boost_asio.indexterm.async_read..async_read] 
The `async_read` function is a composed asynchronous operation that reads a certain amount of data from a stream before completion. 


Start an asynchronous operation to read a certain amount of data from a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload1 async_read]``(
      AsyncReadStream & s,
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload2 async_read]``(
      AsyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload3 async_read]``(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload4 async_read]``(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload4 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload5 async_read]``(
      AsyncReadStream & s,
      basic_streambuf< Allocator > & b,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload5 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload6 async_read]``(
      AsyncReadStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload6 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload7 async_read]``(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload7 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read.overload8 async_read]``(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read.overload8 more...]]``

[heading Requirements]

['Header: ][^boost/asio/read.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 async_read (1 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes copied into the
                                             // buffers. If an error occurred,
                                             // this will be the  number of
                                             // bytes successfully transferred
                                             // prior to the error.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::async_read(s, boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::async_read(
       s, buffers,
       boost::asio::transfer_all(),
       handler); 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload2 async_read (2 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async\_read\_some function.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes copied into the
                                             // buffers. If an error occurred,
                                             // this will be the  number of
                                             // bytes successfully transferred
                                             // prior to the error.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::async_read(s,
       boost::asio::buffer(data, size),
       boost::asio::transfer_at_least(32),
       handler); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload3 async_read (3 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes copied into the
                                             // buffers. If an error occurred,
                                             // this will be the  number of
                                             // bytes successfully transferred
                                             // prior to the error.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::async_read(
       s, buffers,
       boost::asio::transfer_all(),
       handler); 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload4 async_read (4 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async\_read\_some function.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes copied into the
                                             // buffers. If an error occurred,
                                             // this will be the  number of
                                             // bytes successfully transferred
                                             // prior to the error.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload5 async_read (5 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      basic_streambuf< Allocator > & b,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffer is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes copied into the
                                             // buffers. If an error occurred,
                                             // this will be the  number of
                                             // bytes successfully transferred
                                             // prior to the error.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::async_read(
       s, b,
       boost::asio::transfer_all(),
       handler); 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload6 async_read (6 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffer is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async\_read\_some function.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes copied into the
                                             // buffers. If an error occurred,
                                             // this will be the  number of
                                             // bytes successfully transferred
                                             // prior to the error.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload7 async_read (7 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes copied into the
                                             // buffers. If an error occurred,
                                             // this will be the  number of
                                             // bytes successfully transferred
                                             // prior to the error.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::async_read(
       s, buffers,
       boost::asio::transfer_all(),
       handler); 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload8 async_read (8 of 8 overloads)]


Start an asynchronous operation to read a certain amount of data from a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other read operations (such as async\_read, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async\_read\_some function.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes copied into the
                                             // buffers. If an error occurred,
                                             // this will be the  number of
                                             // bytes successfully transferred
                                             // prior to the error.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]


[endsect]

[section:async_read_at async_read_at]

[indexterm1 boost_asio.indexterm.async_read_at..async_read_at] 
The `async_read_at` function is a composed asynchronous operation that reads a certain amount of data at the specified offset. 


Start an asynchronous operation to read a certain amount of data at the specified offset. 

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_at.overload1 async_read_at]``(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_at.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_at.overload2 async_read_at]``(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_at.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_at.overload3 async_read_at]``(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_at.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_at.overload4 async_read_at]``(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_at.overload4 more...]]``

[heading Requirements]

['Header: ][^boost/asio/read_at.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 async_read_at (1 of 4 overloads)]


Start an asynchronous operation to read a certain amount of data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_at(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's async\_read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::async_read_at(d, 42, boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::async_read_at(
       d, 42, buffers,
       boost::asio::transfer_all(),
       handler); 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessReadDevice` type's async\_read\_some\_at operation. 


[endsect]



[section:overload2 async_read_at (2 of 4 overloads)]


Start an asynchronous operation to read a certain amount of data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_at(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's async\_read\_some\_at function.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::async_read_at(d, 42,
       boost::asio::buffer(data, size),
       boost::asio::transfer_at_least(32),
       handler); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessReadDevice` type's async\_read\_some\_at operation. 


[endsect]



[section:overload3 async_read_at (3 of 4 overloads)]


Start an asynchronous operation to read a certain amount of data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_at(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's async\_read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::async_read_at(
       d, 42, b,
       boost::asio::transfer_all(),
       handler); 





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessReadDevice` type's async\_read\_some\_at operation. 


[endsect]



[section:overload4 async_read_at (4 of 4 overloads)]


Start an asynchronous operation to read a certain amount of data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessReadDevice AsyncRandomAccessReadDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_at(
      AsyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read a certain number of bytes of data from a random access device at the specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's async\_read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the AsyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_read_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's async\_read\_some\_at function.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes copied into the buffers. If an error
     // occurred, this will be the number of bytes successfully
     // transferred prior to the error.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessReadDevice` type's async\_read\_some\_at operation. 


[endsect]


[endsect]

[section:async_read_until async_read_until]

[indexterm1 boost_asio.indexterm.async_read_until..async_read_until] 
The `async_read_until` function is a composed asynchronous operation that reads data into a dynamic buffer sequence, or into a streambuf, until it contains a delimiter, matches a regular expression, or a function object indicates a match. 


Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload1 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      char delim,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload2 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      string_view delim,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload2 more...]]``

Start an asynchronous operation to read data into a dynamic buffer sequence until some part of its data matches a regular expression. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload3 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      const boost::regex & expr,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload3 more...]]``

Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename MatchCondition,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload4 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      MatchCondition match_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload4 more...]]``

Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload5 async_read_until]``(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      char delim,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload5 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload6 async_read_until]``(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      string_view delim,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload6 more...]]``

Start an asynchronous operation to read data into a streambuf until some part of its data matches a regular expression. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload7 async_read_until]``(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      const boost::regex & expr,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload7 more...]]``

Start an asynchronous operation to read data into a streambuf until a function object indicates a match. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename MatchCondition,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload8 async_read_until]``(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      MatchCondition match_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload8 more...]]``

Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload9 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      char delim,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload9 more...]]``

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload10 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      string_view delim,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload10 more...]]``

Start an asynchronous operation to read data into a dynamic buffer sequence until some part of its data matches a regular expression. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload11 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      const boost::regex & expr,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload11 more...]]``

Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. 

  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename MatchCondition,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_read_until.overload12 async_read_until]``(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      MatchCondition match_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_read_until.overload12 more...]]``

[heading Requirements]

['Header: ][^boost/asio/read_until.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 async_read_until (1 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      char delim,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[delim][The delimiter character.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area up to and including the delimiter.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a newline is encountered: 

   std::string data;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, data, '\n', handler); 


After the `async_read_until` operation completes successfully, the buffer `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\n' } 


After the call to `erase`, the remaining data is left in the buffer `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload2 async_read_until (2 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      string_view delim,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[delim][The delimiter string.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area up to and including the delimiter.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, data, "\r\n", handler); 


After the `async_read_until` operation completes successfully, the string `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the string `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload3 async_read_until (3 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until some part of its data matches a regular expression. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      const boost::regex & expr,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains some data that matches a regular expression. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* A substring of the dynamic buffer sequence's get area matches the regular expression.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the dynamic buffer sequence's get area already contains data that matches the regular expression, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[expr][The regular expression.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer
     // sequence's get area up to and including the
     // substring that matches the regular expression.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, data,
       boost::regex("\r\n"), handler); 


After the `async_read_until` operation completes successfully, the string `data` contains the data which matched the regular expression: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the match, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the string `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload4 async_read_until (4 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename MatchCondition,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      MatchCondition match_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The match condition function object returns a std::pair where the second element evaluates to true.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[match_condition][The function object to be called to determine whether a match exists. The signature of the function object must be: 
``
   pair<iterator, bool> match_condition(iterator begin, iterator end);
``
where `iterator` represents the type: 
``
   buffers_iterator<typename DynamicBuffer_v1::const_buffers_type>
``
The iterator parameters `begin` and `end` define the range of bytes to be scanned to determine whether there is a match. The `first` member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the `begin` parameter for any subsequent invocation of the match condition. The `second` member of the return value is true if a match has been found, false otherwise.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area that have been fully consumed by the match
     // function. O if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.

The default implementation of the `is_match_condition` type trait evaluates to true for function pointers and function objects with a `result_type` typedef. It must be specialised for other user-defined function objects.


[heading Examples]
  
To asynchronously read data into a `std::string` until whitespace is encountered: 

   typedef boost::asio::buffers_iterator<
       boost::asio::const_buffers_1> iterator;

   std::pair<iterator, bool>
   match_whitespace(iterator begin, iterator end)
   {
     iterator i = begin;
     while (i != end)
       if (std::isspace(*i++))
         return std::make_pair(i, true);
     return std::make_pair(i, false);
   }
   ...
   void handler(const boost::system::error_code& e, std::size_t size);
   ...
   std::string data;
   boost::asio::async_read_until(s, data, match_whitespace, handler);




To asynchronously read data into a `std::string` until a matching character is found: 

   class match_char
   {
   public:
     explicit match_char(char c) : c_(c) {}

     template <typename Iterator>
     std::pair<Iterator, bool> operator()(
         Iterator begin, Iterator end) const
     {
       Iterator i = begin;
       while (i != end)
         if (c_ == *i++)
           return std::make_pair(i, true);
       return std::make_pair(i, false);
     }

   private:
     char c_;
   };

   namespace asio {
     template <> struct is_match_condition<match_char>
       : public boost::true_type {};
   } // namespace asio
   ...
   void handler(const boost::system::error_code& e, std::size_t size);
   ...
   std::string data;
   boost::asio::async_read_until(s, data, match_char('a'), handler);





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload5 async_read_until (5 of 12 overloads)]


Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      char delim,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the streambuf contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[b][A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.]]

[[delim][The delimiter character.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the streambuf's get
     // area up to and including the delimiter.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a streambuf until a newline is encountered: 

   boost::asio::streambuf b;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::istream is(&b);
       std::string line;
       std::getline(is, line);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, b, '\n', handler); 


After the `async_read_until` operation completes successfully, the buffer `b` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\n', 'd', 'e', ... } 


The call to `std::getline` then extracts the data up to and including the newline (which is discarded), so that the string `line` contains: 

   { 'a', 'b', ..., 'c' } 


The remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload6 async_read_until (6 of 12 overloads)]


Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      string_view delim,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the streambuf contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[b][A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.]]

[[delim][The delimiter string.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the streambuf's get
     // area up to and including the delimiter.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a streambuf until a newline is encountered: 

   boost::asio::streambuf b;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::istream is(&b);
       std::string line;
       std::getline(is, line);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, b, "\r\n", handler); 


After the `async_read_until` operation completes successfully, the buffer `b` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `std::getline` then extracts the data up to and including the newline (which is discarded), so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r' } 


The remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload7 async_read_until (7 of 12 overloads)]


Start an asynchronous operation to read data into a streambuf until some part of its data matches a regular expression. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      const boost::regex & expr,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains some data that matches a regular expression. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* A substring of the streambuf's get area matches the regular expression.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the streambuf's get area already contains data that matches the regular expression, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[b][A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.]]

[[expr][The regular expression.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the streambuf's get
     // area up to and including the substring
     // that matches the regular. expression.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the streambuf may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the streambuf for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a streambuf until a CR-LF sequence is encountered: 

   boost::asio::streambuf b;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::istream is(&b);
       std::string line;
       std::getline(is, line);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, b, boost::regex("\r\n"), handler); 


After the `async_read_until` operation completes successfully, the buffer `b` contains the data which matched the regular expression: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `std::getline` then extracts the data up to and including the newline (which is discarded), so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r' } 


The remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload8 async_read_until (8 of 12 overloads)]


Start an asynchronous operation to read data into a streambuf until a function object indicates a match. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename Allocator,
      typename MatchCondition,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      MatchCondition match_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0);


This function is used to asynchronously read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The match condition function object returns a std::pair where the second element evaluates to true.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[b][A streambuf object into which the data will be read.]]

[[match_condition][The function object to be called to determine whether a match exists. The signature of the function object must be: 
``
   pair<iterator, bool> match_condition(iterator begin, iterator end);
``
where `iterator` represents the type: 
``
   buffers_iterator<basic_streambuf<Allocator>::const_buffers_type>
``
The iterator parameters `begin` and `end` define the range of bytes to be scanned to determine whether there is a match. The `first` member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the `begin` parameter for any subsequent invocation of the match condition. The `second` member of the return value is true if a match has been found, false otherwise.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the streambuf's get
     // area that have been fully consumed by the
     // match function. O if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent async\_read\_until operation to examine.

The default implementation of the `is_match_condition` type trait evaluates to true for function pointers and function objects with a `result_type` typedef. It must be specialised for other user-defined function objects.


[heading Examples]
  
To asynchronously read data into a streambuf until whitespace is encountered: 

   typedef boost::asio::buffers_iterator<
       boost::asio::streambuf::const_buffers_type> iterator;

   std::pair<iterator, bool>
   match_whitespace(iterator begin, iterator end)
   {
     iterator i = begin;
     while (i != end)
       if (std::isspace(*i++))
         return std::make_pair(i, true);
     return std::make_pair(i, false);
   }
   ...
   void handler(const boost::system::error_code& e, std::size_t size);
   ...
   boost::asio::streambuf b;
   boost::asio::async_read_until(s, b, match_whitespace, handler);




To asynchronously read data into a streambuf until a matching character is found: 

   class match_char
   {
   public:
     explicit match_char(char c) : c_(c) {}

     template <typename Iterator>
     std::pair<Iterator, bool> operator()(
         Iterator begin, Iterator end) const
     {
       Iterator i = begin;
       while (i != end)
         if (c_ == *i++)
           return std::make_pair(i, true);
       return std::make_pair(i, false);
     }

   private:
     char c_;
   };

   namespace asio {
     template <> struct is_match_condition<match_char>
       : public boost::true_type {};
   } // namespace asio
   ...
   void handler(const boost::system::error_code& e, std::size_t size);
   ...
   boost::asio::streambuf b;
   boost::asio::async_read_until(s, b, match_char('a'), handler);





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload9 async_read_until (9 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      char delim,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[delim][The delimiter character.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area up to and including the delimiter.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a newline is encountered: 

   std::string data;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, data, '\n', handler); 


After the `async_read_until` operation completes successfully, the buffer `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\n' } 


After the call to `erase`, the remaining data is left in the buffer `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload10 async_read_until (10 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      string_view delim,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[delim][The delimiter string.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area up to and including the delimiter.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, data, "\r\n", handler); 


After the `async_read_until` operation completes successfully, the string `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the string `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload11 async_read_until (11 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until some part of its data matches a regular expression. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      const boost::regex & expr,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains some data that matches a regular expression. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* A substring of the dynamic buffer sequence's get area matches the regular expression.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the dynamic buffer sequence's get area already contains data that matches the regular expression, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[expr][The regular expression.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer
     // sequence's get area up to and including the
     // substring that matches the regular expression.
     // 0 if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.


[heading Example]
  
To asynchronously read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   ...
   void handler(const boost::system::error_code& e, std::size_t size)
   {
     if (!e)
     {
       std::string line = data.substr(0, n);
       data.erase(0, n);
       ...
     }
   }
   ...
   boost::asio::async_read_until(s, data,
       boost::regex("\r\n"), handler); 


After the `async_read_until` operation completes successfully, the string `data` contains the data which matched the regular expression: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the match, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the string `data` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `async_read_until` operation.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]



[section:overload12 async_read_until (12 of 12 overloads)]


Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. 


  template<
      typename ``[link boost_asio.reference.AsyncReadStream AsyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename MatchCondition,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_until(
      AsyncReadStream & s,
      DynamicBuffer_v2 buffers,
      MatchCondition match_condition,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The match condition function object returns a std::pair where the second element evaluates to true.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_read\_some function, and is known as a ['composed operation]. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async\_read, async\_read\_until, the stream's async\_read\_some function, or any other composed operations that perform reads) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the AsyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[match_condition][The function object to be called to determine whether a match exists. The signature of the function object must be: 
``
   pair<iterator, bool> match_condition(iterator begin, iterator end);
``
where `iterator` represents the type: 
``
   buffers_iterator<typename DynamicBuffer_v2::const_buffers_type>
``
The iterator parameters `begin` and `end` define the range of bytes to be scanned to determine whether there is a match. The `first` member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the `begin` parameter for any subsequent invocation of the match condition. The `second` member of the return value is true if a match has been found, false otherwise.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // The number of bytes in the dynamic buffer sequence's
     // get area that have been fully consumed by the match
     // function. O if an error occurred.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
After a successful async\_read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent async\_read\_until operation to examine.

The default implementation of the `is_match_condition` type trait evaluates to true for function pointers and function objects with a `result_type` typedef. It must be specialised for other user-defined function objects.


[heading Examples]
  
To asynchronously read data into a `std::string` until whitespace is encountered: 

   typedef boost::asio::buffers_iterator<
       boost::asio::const_buffers_1> iterator;

   std::pair<iterator, bool>
   match_whitespace(iterator begin, iterator end)
   {
     iterator i = begin;
     while (i != end)
       if (std::isspace(*i++))
         return std::make_pair(i, true);
     return std::make_pair(i, false);
   }
   ...
   void handler(const boost::system::error_code& e, std::size_t size);
   ...
   std::string data;
   boost::asio::async_read_until(s, data, match_whitespace, handler);




To asynchronously read data into a `std::string` until a matching character is found: 

   class match_char
   {
   public:
     explicit match_char(char c) : c_(c) {}

     template <typename Iterator>
     std::pair<Iterator, bool> operator()(
         Iterator begin, Iterator end) const
     {
       Iterator i = begin;
       while (i != end)
         if (c_ == *i++)
           return std::make_pair(i, true);
       return std::make_pair(i, false);
     }

   private:
     char c_;
   };

   namespace asio {
     template <> struct is_match_condition<match_char>
       : public boost::true_type {};
   } // namespace asio
   ...
   void handler(const boost::system::error_code& e, std::size_t size);
   ...
   std::string data;
   boost::asio::async_read_until(s, data, match_char('a'), handler);





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncReadStream` type's `async_read_some` operation. 


[endsect]


[endsect]

[section:async_result async_result]

[indexterm1 boost_asio.indexterm.async_result..async_result]


An interface for customising the behaviour of an initiating function. 


  template<
      typename CompletionToken,
      typename... Signatures>
  class async_result


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.async_result.completion_handler_type [*completion_handler_type]]]
    [The concrete completion handler type for the specific signature. ]
  
  ]

  [

    [[link boost_asio.reference.async_result.return_type [*return_type]]]
    [The return type of the initiating function. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.async_result.async_result [*async_result]] [constructor]]
    [Construct an async result from a given handler. ]
  ]
  
  [
    [[link boost_asio.reference.async_result.get [*get]]]
    [Obtain the value to be returned from the initiating function. ]
  ]
  
  [
    [[link boost_asio.reference.async_result.initiate [*initiate]] [static]]
    [Initiate the asynchronous operation that will produce the result, and obtain the value to be returned from the initiating function. ]
  ]
  
]

The [link boost_asio.reference.async_result `async_result`] traits class is used for determining:


* the concrete completion handler type to be called at the end of the asynchronous operation;


* the initiating function return type; and


* how the return value of the initiating function is obtained.

The trait allows the handler and return types to be determined at the point where the specific completion handler signature is known.

This template may be specialised for user-defined completion token types. The primary template assumes that the CompletionToken is the completion handler. 

[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:async_result async_result::async_result]

[indexterm2 boost_asio.indexterm.async_result.async_result..async_result..async_result] 
Construct an async result from a given handler. 


  async_result(
      completion_handler_type & h);


When using a specalised [link boost_asio.reference.async_result `async_result`], the constructor has an opportunity to initialise some state associated with the completion handler, which is then returned from the initiating function. 


[endsect]



[section:completion_handler_type async_result::completion_handler_type]

[indexterm2 boost_asio.indexterm.async_result.completion_handler_type..completion_handler_type..async_result] 
The concrete completion handler type for the specific signature. 


  typedef CompletionToken completion_handler_type;



[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get async_result::get]

[indexterm2 boost_asio.indexterm.async_result.get..get..async_result] 
Obtain the value to be returned from the initiating function. 


  return_type get();



[endsect]



[section:initiate async_result::initiate]

[indexterm2 boost_asio.indexterm.async_result.initiate..initiate..async_result] 
Initiate the asynchronous operation that will produce the result, and obtain the value to be returned from the initiating function. 


  template<
      typename Initiation,
      typename RawCompletionToken,
      typename... Args>
  static return_type initiate(
      Initiation && initiation,
      RawCompletionToken && token,
      Args &&... args);



[endsect]



[section:return_type async_result::return_type]

[indexterm2 boost_asio.indexterm.async_result.return_type..return_type..async_result] 
The return type of the initiating function. 


  typedef void return_type;



[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_ async_result< std::packaged_task< Result(Args...)>, Signature >]

[indexterm1 boost_asio.indexterm.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_..async_result< std::packaged_task< Result(Args\.\.\.)>, Signature >]


Partial specialisation of `async_result` for `std::packaged_task`. 


  template<
      typename Result,
      typename... Args,
      typename Signature>
  class async_result< std::packaged_task< Result(Args...)>, Signature >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.completion_handler_type [*completion_handler_type]]]
    [The packaged task is the concrete completion handler type. ]
  
  ]

  [

    [[link boost_asio.reference.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.return_type [*return_type]]]
    [The return type of the initiating function is the future obtained from the packaged task. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.async_result [*async_result]]]
    [The constructor extracts the future from the packaged task. ]
  ]
  
  [
    [[link boost_asio.reference.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.get [*get]]]
    [Returns the packaged task's future. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/packaged_task.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:async_result async_result< std::packaged_task< Result(Args...)>, Signature >::async_result]

[indexterm2 boost_asio.indexterm.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.async_result..async_result..async_result< std::packaged_task< Result(Args\.\.\.)>, Signature >] 
The constructor extracts the future from the packaged task. 


  async_result(
      completion_handler_type & h);



[endsect]



[section:completion_handler_type async_result< std::packaged_task< Result(Args...)>, Signature >::completion_handler_type]

[indexterm2 boost_asio.indexterm.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.completion_handler_type..completion_handler_type..async_result< std::packaged_task< Result(Args\.\.\.)>, Signature >] 
The packaged task is the concrete completion handler type. 


  typedef std::packaged_task< Result(Args...)> completion_handler_type;



[heading Requirements]

['Header: ][^boost/asio/packaged_task.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get async_result< std::packaged_task< Result(Args...)>, Signature >::get]

[indexterm2 boost_asio.indexterm.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.get..get..async_result< std::packaged_task< Result(Args\.\.\.)>, Signature >] 
Returns the packaged task's future. 


  return_type get();



[endsect]



[section:return_type async_result< std::packaged_task< Result(Args...)>, Signature >::return_type]

[indexterm2 boost_asio.indexterm.async_result_lt__std__packaged_task_lt__Result_lp_Args_ellipsis__rp__gt__comma__Signature__gt_.return_type..return_type..async_result< std::packaged_task< Result(Args\.\.\.)>, Signature >] 
The return type of the initiating function is the future obtained from the packaged task. 


  typedef std::future< Result > return_type;



[heading Requirements]

['Header: ][^boost/asio/packaged_task.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:async_write async_write]

[indexterm1 boost_asio.indexterm.async_write..async_write] 
The `async_write` function is a composed asynchronous operation that writes a certain amount of data to a stream before completion. 


Start an asynchronous operation to write all of the supplied data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload1 async_write]``(
      AsyncWriteStream & s,
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload1 more...]]``

Start an asynchronous operation to write a certain amount of data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload2 async_write]``(
      AsyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      WriteHandler && handler,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload2 more...]]``

Start an asynchronous operation to write all of the supplied data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload3 async_write]``(
      AsyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload3 more...]]``

Start an asynchronous operation to write a certain amount of data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload4 async_write]``(
      AsyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      WriteHandler && handler,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload4 more...]]``

Start an asynchronous operation to write all of the supplied data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload5 async_write]``(
      AsyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload5 more...]]``

Start an asynchronous operation to write a certain amount of data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload6 async_write]``(
      AsyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      WriteHandler && handler);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload6 more...]]``

Start an asynchronous operation to write all of the supplied data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload7 async_write]``(
      AsyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload7 more...]]``

Start an asynchronous operation to write a certain amount of data to a stream. 

  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write.overload8 async_write]``(
      AsyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      WriteHandler && handler,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write.overload8 more...]]``

[heading Requirements]

['Header: ][^boost/asio/write.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 async_write (1 of 8 overloads)]


Start an asynchronous operation to write all of the supplied data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes written from the
                                             // buffers. If an error occurred,
                                             // this will be less than the sum
                                             // of the buffer sizes.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::async_write(s, boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload2 async_write (2 of 8 overloads)]


Start an asynchronous operation to write a certain amount of data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      WriteHandler && handler,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async\_write\_some function.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes written from the
                                             // buffers. If an error occurred,
                                             // this will be less than the sum
                                             // of the buffer sizes.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::async_write(s,
       boost::asio::buffer(data, size),
       boost::asio::transfer_at_least(32),
       handler); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload3 async_write (3 of 8 overloads)]


Start an asynchronous operation to write all of the supplied data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called. Successfully written data is automatically consumed from the buffers.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes written from the
                                             // buffers. If an error occurred,
                                             // this will be less than the sum
                                             // of the buffer sizes.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload4 async_write (4 of 8 overloads)]


Start an asynchronous operation to write a certain amount of data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      WriteHandler && handler,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called. Successfully written data is automatically consumed from the buffers.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async\_write\_some function.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes written from the
                                             // buffers. If an error occurred,
                                             // this will be less than the sum
                                             // of the buffer sizes.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload5 async_write (5 of 8 overloads)]


Start an asynchronous operation to write all of the supplied data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes written from the
                                             // buffers. If an error occurred,
                                             // this will be less than the sum
                                             // of the buffer sizes.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload6 async_write (6 of 8 overloads)]


Start an asynchronous operation to write a certain amount of data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      WriteHandler && handler);


This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async\_write\_some function.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes written from the
                                             // buffers. If an error occurred,
                                             // this will be less than the sum
                                             // of the buffer sizes.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload7 async_write (7 of 8 overloads)]


Start an asynchronous operation to write all of the supplied data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called. Successfully written data is automatically consumed from the buffers.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes written from the
                                             // buffers. If an error occurred,
                                             // this will be less than the sum
                                             // of the buffer sizes.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]



[section:overload8 async_write (8 of 8 overloads)]


Start an asynchronous operation to write a certain amount of data to a stream. 


  template<
      typename ``[link boost_asio.reference.AsyncWriteStream AsyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write(
      AsyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      WriteHandler && handler,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's async\_write\_some function, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as async\_write, the stream's async\_write\_some function, or any other composed operations that perform writes) until this operation completes.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the AsyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called. Successfully written data is automatically consumed from the buffers.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's async\_write\_some function.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.

     std::size_t bytes_transferred           // Number of bytes written from the
                                             // buffers. If an error occurred,
                                             // this will be less than the sum
                                             // of the buffer sizes.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncWriteStream` type's `async_write_some` operation. 


[endsect]


[endsect]

[section:async_write_at async_write_at]

[indexterm1 boost_asio.indexterm.async_write_at..async_write_at] 
The `async_write_at` function is a composed asynchronous operation that writes a certain amount of data at the specified offset before completion. 


Start an asynchronous operation to write all of the supplied data at the specified offset. 

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write_at.overload1 async_write_at]``(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write_at.overload1 more...]]``

Start an asynchronous operation to write a certain amount of data at the specified offset. 

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write_at.overload2 async_write_at]``(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write_at.overload2 more...]]``

Start an asynchronous operation to write all of the supplied data at the specified offset. 

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write_at.overload3 async_write_at]``(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write_at.overload3 more...]]``

Start an asynchronous operation to write a certain amount of data at the specified offset. 

  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.async_write_at.overload4 async_write_at]``(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.async_write_at.overload4 more...]]``

[heading Requirements]

['Header: ][^boost/asio/write_at.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 async_write_at (1 of 4 overloads)]


Start an asynchronous operation to write all of the supplied data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_at(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's async\_write\_some\_at function, and is known as a ['composed operation]. The program must ensure that the device performs no ['overlapping] write operations (such as async\_write\_at, the device's async\_write\_some\_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[buffers][One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::async_write_at(d, 42, boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessWriteDevice` type's async\_write\_some\_at operation. 


[endsect]



[section:overload2 async_write_at (2 of 4 overloads)]


Start an asynchronous operation to write a certain amount of data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_at(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's async\_write\_some\_at function, and is known as a ['composed operation]. The program must ensure that the device performs no ['overlapping] write operations (such as async\_write\_at, the device's async\_write\_some\_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[buffers][One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's async\_write\_some\_at function.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::async_write_at(d, 42,
       boost::asio::buffer(data, size),
       boost::asio::transfer_at_least(32),
       handler); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessWriteDevice` type's async\_write\_some\_at operation. 


[endsect]



[section:overload3 async_write_at (3 of 4 overloads)]


Start an asynchronous operation to write all of the supplied data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_at(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's async\_write\_some\_at function, and is known as a ['composed operation]. The program must ensure that the device performs no ['overlapping] write operations (such as async\_write\_at, the device's async\_write\_some\_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessWriteDevice` type's async\_write\_some\_at operation. 


[endsect]



[section:overload4 async_write_at (4 of 4 overloads)]


Start an asynchronous operation to write a certain amount of data at the specified offset. 


  template<
      typename ``[link boost_asio.reference.AsyncRandomAccessWriteDevice AsyncRandomAccessWriteDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_at(
      AsyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's async\_write\_some\_at function, and is known as a ['composed operation]. The program must ensure that the device performs no ['overlapping] write operations (such as async\_write\_at, the device's async\_write\_some\_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[b][A [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest async_write_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's async\_write\_some\_at function.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,

     // Number of bytes written from the buffers. If an error
     // occurred, this will be less than the sum of the buffer sizes.
     std::size_t bytes_transferred
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `AsyncRandomAccessWriteDevice` type's async\_write\_some\_at operation. 


[endsect]


[endsect]

[section:awaitable awaitable]

[indexterm1 boost_asio.indexterm.awaitable..awaitable]


The return type of a coroutine or asynchronous operation. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  class awaitable


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.awaitable.executor_type [*executor_type]]]
    [The executor type that will be used for the coroutine. ]
  
  ]

  [

    [[link boost_asio.reference.awaitable.value_type [*value_type]]]
    [The type of the awaited value. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.awaitable.awaitable [*awaitable]] [constructor]]
    [Default constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.awaitable.operator_eq_ [*operator=]]]
    [Move assignment. ]
  ]
  
  [
    [[link boost_asio.reference.awaitable.valid [*valid]]]
    [Checks if the awaitable refers to a future result. ]
  ]
  
  [
    [[link boost_asio.reference.awaitable._awaitable [*~awaitable]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/awaitable.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:awaitable awaitable::awaitable]

[indexterm2 boost_asio.indexterm.awaitable.awaitable..awaitable..awaitable] 
Default constructor. 


  constexpr ``[link boost_asio.reference.awaitable.awaitable.overload1 awaitable]``();
  ``  [''''&raquo;''' [link boost_asio.reference.awaitable.awaitable.overload1 more...]]``


Move constructor. 


  ``[link boost_asio.reference.awaitable.awaitable.overload2 awaitable]``(
      awaitable && other);
  ``  [''''&raquo;''' [link boost_asio.reference.awaitable.awaitable.overload2 more...]]``


[section:overload1 awaitable::awaitable (1 of 2 overloads)]


Default constructor. 


  constexpr awaitable();



[endsect]



[section:overload2 awaitable::awaitable (2 of 2 overloads)]


Move constructor. 


  awaitable(
      awaitable && other);



[endsect]


[endsect]


[section:executor_type awaitable::executor_type]

[indexterm2 boost_asio.indexterm.awaitable.executor_type..executor_type..awaitable] 
The executor type that will be used for the coroutine. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/awaitable.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ awaitable::operator=]

[indexterm2 boost_asio.indexterm.awaitable.operator_eq_..operator=..awaitable] 
Move assignment. 


  awaitable operator=(
      awaitable && other);



[endsect]



[section:valid awaitable::valid]

[indexterm2 boost_asio.indexterm.awaitable.valid..valid..awaitable] 
Checks if the awaitable refers to a future result. 


  bool valid() const;



[endsect]



[section:value_type awaitable::value_type]

[indexterm2 boost_asio.indexterm.awaitable.value_type..value_type..awaitable] 
The type of the awaited value. 


  typedef T value_type;



[heading Requirements]

['Header: ][^boost/asio/awaitable.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:_awaitable awaitable::~awaitable]

[indexterm2 boost_asio.indexterm.awaitable._awaitable..~awaitable..awaitable] 
Destructor. 


  ~awaitable();



[endsect]



[endsect]

[section:bad_executor bad_executor]

[indexterm1 boost_asio.indexterm.bad_executor..bad_executor]


Exception thrown when trying to access an empty polymorphic executor. 


  class bad_executor :
    public std::exception


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.bad_executor.bad_executor [*bad_executor]] [constructor]]
    [Constructor. ]
  ]
  
  [
    [[link boost_asio.reference.bad_executor.what [*what]]]
    [Obtain message associated with exception. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:bad_executor bad_executor::bad_executor]

[indexterm2 boost_asio.indexterm.bad_executor.bad_executor..bad_executor..bad_executor] 
Constructor. 


  bad_executor();



[endsect]



[section:what bad_executor::what]

[indexterm2 boost_asio.indexterm.bad_executor.what..what..bad_executor] 
Obtain message associated with exception. 


  virtual const char * what() const;



[endsect]



[endsect]

[section:basic_datagram_socket basic_datagram_socket]

[indexterm1 boost_asio.indexterm.basic_datagram_socket..basic_datagram_socket]


Provides datagram-oriented socket functionality. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class basic_datagram_socket :
    public basic_socket< Protocol, Executor >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_datagram_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_datagram_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_receive_from [*async_receive_from]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_send [*async_send]]]
    [Start an asynchronous send on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_send_to [*async_send_to]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket [*basic_datagram_socket]] [constructor]]
    [Construct a basic_datagram_socket without opening it. 
     [hr]
     Construct and open a basic_datagram_socket. 
     [hr]
     Construct a basic_datagram_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_datagram_socket on an existing native socket. 
     [hr]
     Move-construct a basic_datagram_socket from another. 
     [hr]
     Move-construct a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_datagram_socket from another. 
     [hr]
     Move-assign a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.receive [*receive]]]
    [Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.receive_from [*receive_from]]]
    [Receive a datagram with the endpoint of the sender. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.send [*send]]]
    [Send some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.send_to [*send_to]]]
    [Send a datagram to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket._basic_datagram_socket [*~basic_datagram_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_datagram_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] class template provides asynchronous and blocking datagram-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `send_to`, `receive`, `receive_from`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe. 

[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign basic_datagram_socket::assign]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.assign..assign..basic_datagram_socket] 
Assign an existing native socket to the socket. 


  void ``[link boost_asio.reference.basic_datagram_socket.assign.overload1 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.assign.overload1 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.assign.overload2 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.assign.overload2 more...]]``


[section:overload1 basic_datagram_socket::assign (1 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket);



[endsect]



[section:overload2 basic_datagram_socket::assign (2 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_connect basic_datagram_socket::async_connect]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.async_connect..async_connect..basic_datagram_socket] 
Start an asynchronous connect. 


  template<
      typename ``[link boost_asio.reference.ConnectHandler ConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      const endpoint_type & peer_endpoint,
      ConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.]]

[[handler][The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void connect_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Connect succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.async_connect(endpoint, connect_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:async_receive basic_datagram_socket::async_receive]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.async_receive..async_receive..basic_datagram_socket] 
Start an asynchronous receive on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_receive.overload1 async_receive]``(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_receive.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_receive.overload2 async_receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_receive.overload2 more...]]``


[section:overload1 basic_datagram_socket::async_receive (1 of 2 overloads)]


Start an asynchronous receive on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive data from the datagram socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The async\_receive operation can only be used with a connected socket. Use the async\_receive\_from function to receive data on an unconnected datagram socket.


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_receive(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_datagram_socket::async_receive (2 of 2 overloads)]


Start an asynchronous receive on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive data from the datagram socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The async\_receive operation can only be used with a connected socket. Use the async\_receive\_from function to receive data on an unconnected datagram socket.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]

[section:async_receive_from basic_datagram_socket::async_receive_from]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.async_receive_from..async_receive_from..basic_datagram_socket] 
Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_receive_from.overload1 async_receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_receive_from.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_receive_from.overload2 async_receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_receive_from.overload2 more...]]``


[section:overload1 basic_datagram_socket::async_receive_from (1 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive a datagram. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the datagram. Ownership of the sender\_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_receive_from(
       boost::asio::buffer(data, size), sender_endpoint, handler); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_datagram_socket::async_receive_from (2 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive a datagram. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the datagram. Ownership of the sender\_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]

[section:async_send basic_datagram_socket::async_send]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.async_send..async_send..basic_datagram_socket] 
Start an asynchronous send on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_send.overload1 async_send]``(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_send.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_send.overload2 async_send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_send.overload2 more...]]``


[section:overload1 basic_datagram_socket::async_send (1 of 2 overloads)]


Start an asynchronous send on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously send data on the datagram socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The async\_send operation can only be used with a connected socket. Use the async\_send\_to function to send data on an unconnected datagram socket.


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_send(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_datagram_socket::async_send (2 of 2 overloads)]


Start an asynchronous send on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously send data on the datagram socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the send call is to be made.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The async\_send operation can only be used with a connected socket. Use the async\_send\_to function to send data on an unconnected datagram socket.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]

[section:async_send_to basic_datagram_socket::async_send_to]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.async_send_to..async_send_to..basic_datagram_socket] 
Start an asynchronous send. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_send_to.overload1 async_send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_send_to.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_datagram_socket.async_send_to.overload2 async_send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.async_send_to.overload2 more...]]``


[section:overload1 basic_datagram_socket::async_send_to (1 of 2 overloads)]


Start an asynchronous send. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously send a datagram to the specified remote endpoint. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[destination][The remote endpoint to which the data will be sent. Copies will be made of the endpoint as required.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::ip::udp::endpoint destination(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.async_send_to(
       boost::asio::buffer(data, size), destination, handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_datagram_socket::async_send_to (2 of 2 overloads)]


Start an asynchronous send. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously send a datagram to the specified remote endpoint. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the send call is to be made.]]

[[destination][The remote endpoint to which the data will be sent. Copies will be made of the endpoint as required.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]


[section:async_wait basic_datagram_socket::async_wait]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.async_wait..async_wait..basic_datagram_socket] 
Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  template<
      typename ``[link boost_asio.reference.WaitHandler WaitHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_wait(
      wait_type w,
      WaitHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to perform an asynchronous wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[handler][The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void wait_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Wait succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:at_mark basic_datagram_socket::at_mark]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.at_mark..at_mark..basic_datagram_socket] 
Determine whether the socket is at the out-of-band data mark. 


  bool ``[link boost_asio.reference.basic_datagram_socket.at_mark.overload1 at_mark]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.at_mark.overload1 more...]]``

  bool ``[link boost_asio.reference.basic_datagram_socket.at_mark.overload2 at_mark]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.at_mark.overload2 more...]]``


[section:overload1 basic_datagram_socket::at_mark (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark() const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_datagram_socket::at_mark (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark(
      boost::system::error_code & ec) const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark. 




[endsect]


[endsect]

[section:available basic_datagram_socket::available]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.available..available..basic_datagram_socket] 
Determine the number of bytes available for reading. 


  std::size_t ``[link boost_asio.reference.basic_datagram_socket.available.overload1 available]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.available.overload1 more...]]``

  std::size_t ``[link boost_asio.reference.basic_datagram_socket.available.overload2 available]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.available.overload2 more...]]``


[section:overload1 basic_datagram_socket::available (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available() const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_datagram_socket::available (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available(
      boost::system::error_code & ec) const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs. 




[endsect]


[endsect]

[section:basic_datagram_socket basic_datagram_socket::basic_datagram_socket]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.basic_datagram_socket..basic_datagram_socket..basic_datagram_socket] 
Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] without opening it. 


  explicit ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload1 basic_datagram_socket]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload2 basic_datagram_socket]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload2 more...]]``


Construct and open a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`]. 


  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload3 basic_datagram_socket]``(
      const executor_type & ex,
      const protocol_type & protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload4 basic_datagram_socket]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload4 more...]]``


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`], opening it and binding it to the given local endpoint. 


  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload5 basic_datagram_socket]``(
      const executor_type & ex,
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload5 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload6 basic_datagram_socket]``(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload6 more...]]``


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] on an existing native socket. 


  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload7 basic_datagram_socket]``(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload7 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload8 basic_datagram_socket]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload8 more...]]``


Move-construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] from another. 


  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload9 basic_datagram_socket]``(
      basic_datagram_socket && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload9 more...]]``


Move-construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload10 basic_datagram_socket]``(
      basic_datagram_socket< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.basic_datagram_socket.overload10 more...]]``


[section:overload1 basic_datagram_socket::basic_datagram_socket (1 of 10 overloads)]


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] without opening it. 


  basic_datagram_socket(
      const executor_type & ex);


This constructor creates a datagram socket without opening it. The `open()` function must be called before data can be sent or received on the socket.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload2 basic_datagram_socket::basic_datagram_socket (2 of 10 overloads)]


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] without opening it. 


  template<
      typename ExecutionContext>
  basic_datagram_socket(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a datagram socket without opening it. The `open()` function must be called before data can be sent or received on the socket.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload3 basic_datagram_socket::basic_datagram_socket (3 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`]. 


  basic_datagram_socket(
      const executor_type & ex,
      const protocol_type & protocol);


This constructor creates and opens a datagram socket.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_datagram_socket::basic_datagram_socket (4 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`]. 


  template<
      typename ExecutionContext>
  basic_datagram_socket(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates and opens a datagram socket.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_datagram_socket::basic_datagram_socket (5 of 10 overloads)]


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`], opening it and binding it to the given local endpoint. 


  basic_datagram_socket(
      const executor_type & ex,
      const endpoint_type & endpoint);


This constructor creates a datagram socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the datagram socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload6 basic_datagram_socket::basic_datagram_socket (6 of 10 overloads)]


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`], opening it and binding it to the given local endpoint. 


  template<
      typename ExecutionContext>
  basic_datagram_socket(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a datagram socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the datagram socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload7 basic_datagram_socket::basic_datagram_socket (7 of 10 overloads)]


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] on an existing native socket. 


  basic_datagram_socket(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_socket);


This constructor creates a datagram socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][The new underlying socket implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 basic_datagram_socket::basic_datagram_socket (8 of 10 overloads)]


Construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] on an existing native socket. 


  template<
      typename ExecutionContext>
  basic_datagram_socket(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a datagram socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][The new underlying socket implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload9 basic_datagram_socket::basic_datagram_socket (9 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] from another. 


  basic_datagram_socket(
      basic_datagram_socket && other);


This constructor moves a datagram socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_datagram_socket(const executor_type&)` constructor. 




[endsect]



[section:overload10 basic_datagram_socket::basic_datagram_socket (10 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_datagram_socket(
      basic_datagram_socket< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);


This constructor moves a datagram socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_datagram_socket(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:bind basic_datagram_socket::bind]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.bind..bind..basic_datagram_socket] 
Bind the socket to the given local endpoint. 


  void ``[link boost_asio.reference.basic_datagram_socket.bind.overload1 bind]``(
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.bind.overload1 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.bind.overload2 bind]``(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.bind.overload2 more...]]``


[section:overload1 basic_datagram_socket::bind (1 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());
   socket.bind(boost::asio::ip::tcp::endpoint(
         boost::asio::ip::tcp::v4(), 12345));







[endsect]



[section:overload2 basic_datagram_socket::bind (2 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());
   boost::system::error_code ec;
   socket.bind(boost::asio::ip::tcp::endpoint(
         boost::asio::ip::tcp::v4(), 12345), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:broadcast basic_datagram_socket::broadcast]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.broadcast..broadcast..basic_datagram_socket] 
Socket option to permit sending of broadcast messages. 


  typedef implementation_defined broadcast;



Implements the SOL\_SOCKET/SO\_BROADCAST socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:bytes_readable basic_datagram_socket::bytes_readable]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.bytes_readable..bytes_readable..basic_datagram_socket] 
IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::bytes_readable command(true);
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:cancel basic_datagram_socket::cancel]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.cancel..cancel..basic_datagram_socket] 
Cancel all asynchronous operations associated with the socket. 


  void ``[link boost_asio.reference.basic_datagram_socket.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.cancel.overload2 more...]]``


[section:overload1 basic_datagram_socket::cancel (1 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining BOOST\_ASIO\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]



[section:overload2 basic_datagram_socket::cancel (2 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining BOOST\_ASIO\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]


[endsect]

[section:close basic_datagram_socket::close]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.close..close..basic_datagram_socket] 
Close the socket. 


  void ``[link boost_asio.reference.basic_datagram_socket.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.close.overload1 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.close.overload2 more...]]``


[section:overload1 basic_datagram_socket::close (1 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close();


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]



[section:overload2 basic_datagram_socket::close (2 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close(
      boost::system::error_code & ec);


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.close(ec);
   if (ec)
   {
     // An error occurred.
   }





[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]


[endsect]

[section:connect basic_datagram_socket::connect]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.connect..connect..basic_datagram_socket] 
Connect the socket to the specified endpoint. 


  void ``[link boost_asio.reference.basic_datagram_socket.connect.overload1 connect]``(
      const endpoint_type & peer_endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.connect.overload1 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.connect.overload2 connect]``(
      const endpoint_type & peer_endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.connect.overload2 more...]]``


[section:overload1 basic_datagram_socket::connect (1 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.connect(endpoint);







[endsect]



[section:overload2 basic_datagram_socket::connect (2 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint,
      boost::system::error_code & ec);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   boost::system::error_code ec;
   socket.connect(endpoint, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:debug basic_datagram_socket::debug]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.debug..debug..basic_datagram_socket] 
Socket option to enable socket-level debugging. 


  typedef implementation_defined debug;



Implements the SOL\_SOCKET/SO\_DEBUG socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:do_not_route basic_datagram_socket::do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.do_not_route..do_not_route..basic_datagram_socket] 
Socket option to prevent routing, use local interfaces only. 


  typedef implementation_defined do_not_route;



Implements the SOL\_SOCKET/SO\_DONTROUTE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:enable_connection_aborted basic_datagram_socket::enable_connection_aborted]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.enable_connection_aborted..enable_connection_aborted..basic_datagram_socket] 
Socket option to report aborted connections on accept. 


  typedef implementation_defined enable_connection_aborted;



Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:endpoint_type basic_datagram_socket::endpoint_type]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.endpoint_type..endpoint_type..basic_datagram_socket] 
The endpoint type. 


  typedef Protocol::endpoint endpoint_type;



[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:executor_type basic_datagram_socket::executor_type]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.executor_type..executor_type..basic_datagram_socket] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_datagram_socket::get_executor]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.get_executor..get_executor..basic_datagram_socket] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:get_option basic_datagram_socket::get_option]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.get_option..get_option..basic_datagram_socket] 
Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_datagram_socket.get_option.overload1 get_option]``(
      GettableSocketOption & option) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.get_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_datagram_socket.get_option.overload2 get_option]``(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.get_option.overload2 more...]]``


[section:overload1 basic_datagram_socket::get_option (1 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[endsect]



[section:overload2 basic_datagram_socket::get_option (2 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::keep_alive option;
   boost::system::error_code ec;
   socket.get_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }
   bool is_set = option.value();







[endsect]


[endsect]

[section:io_control basic_datagram_socket::io_control]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.io_control..io_control..basic_datagram_socket] 
Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_datagram_socket.io_control.overload1 io_control]``(
      IoControlCommand & command);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.io_control.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_datagram_socket.io_control.overload2 io_control]``(
      IoControlCommand & command,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.io_control.overload2 more...]]``


[section:overload1 basic_datagram_socket::io_control (1 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::bytes_readable command;
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[endsect]



[section:overload2 basic_datagram_socket::io_control (2 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command,
      boost::system::error_code & ec);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::bytes_readable command;
   boost::system::error_code ec;
   socket.io_control(command, ec);
   if (ec)
   {
     // An error occurred.
   }
   std::size_t bytes_readable = command.get();







[endsect]


[endsect]


[section:is_open basic_datagram_socket::is_open]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.is_open..is_open..basic_datagram_socket] 
Determine whether the socket is open. 


  bool is_open() const;



[endsect]



[section:keep_alive basic_datagram_socket::keep_alive]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.keep_alive..keep_alive..basic_datagram_socket] 
Socket option to send keep-alives. 


  typedef implementation_defined keep_alive;



Implements the SOL\_SOCKET/SO\_KEEPALIVE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:linger basic_datagram_socket::linger]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.linger..linger..basic_datagram_socket] 
Socket option to specify whether the socket lingers on close if unsent data is present. 


  typedef implementation_defined linger;



Implements the SOL\_SOCKET/SO\_LINGER socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option(true, 30);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option;
   socket.get_option(option);
   bool is_set = option.enabled();
   unsigned short timeout = option.timeout();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:local_endpoint basic_datagram_socket::local_endpoint]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.local_endpoint..local_endpoint..basic_datagram_socket] 
Get the local endpoint of the socket. 


  endpoint_type ``[link boost_asio.reference.basic_datagram_socket.local_endpoint.overload1 local_endpoint]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.local_endpoint.overload1 more...]]``

  endpoint_type ``[link boost_asio.reference.basic_datagram_socket.local_endpoint.overload2 local_endpoint]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.local_endpoint.overload2 more...]]``


[section:overload1 basic_datagram_socket::local_endpoint (1 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint() const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Return Value]
      
An object that represents the local endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();







[endsect]



[section:overload2 basic_datagram_socket::local_endpoint (2 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint(
      boost::system::error_code & ec) const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:lowest_layer basic_datagram_socket::lowest_layer]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.lowest_layer..lowest_layer..basic_datagram_socket] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.basic_datagram_socket.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.basic_datagram_socket.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.lowest_layer.overload2 more...]]``


[section:overload1 basic_datagram_socket::lowest_layer (1 of 2 overloads)]


['Inherited from basic_socket.]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_socket `basic_socket`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 basic_datagram_socket::lowest_layer (2 of 2 overloads)]


['Inherited from basic_socket.]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_socket `basic_socket`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type basic_datagram_socket::lowest_layer_type]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.lowest_layer_type..lowest_layer_type..basic_datagram_socket] 
A [link boost_asio.reference.basic_socket `basic_socket`] is always the lowest layer. 


  typedef basic_socket< Protocol, Executor > lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.basic_socket [*basic_socket]] [constructor]]
    [Construct a basic_socket without opening it. 
     [hr]
     Construct and open a basic_socket. 
     [hr]
     Construct a basic_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_socket on an existing native socket. 
     [hr]
     Move-construct a basic_socket from another. 
     [hr]
     Move-construct a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket from another. 
     [hr]
     Move-assign a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket._basic_socket [*~basic_socket]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_socket `basic_socket`] class template provides functionality that is common to both stream-oriented and datagram-oriented sockets.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:max_connections basic_datagram_socket::max_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.max_connections..max_connections..basic_datagram_socket] 
(Deprecated: Use max\_listen\_connections.) The maximum length of the queue of pending incoming connections. 


  static const int max_connections = implementation_defined;



[endsect]



[section:max_listen_connections basic_datagram_socket::max_listen_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.max_listen_connections..max_listen_connections..basic_datagram_socket] 
The maximum length of the queue of pending incoming connections. 


  static const int max_listen_connections = implementation_defined;



[endsect]



[section:message_do_not_route basic_datagram_socket::message_do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.message_do_not_route..message_do_not_route..basic_datagram_socket] 
Specify that the data should not be subject to routing. 


  static const int message_do_not_route = implementation_defined;



[endsect]



[section:message_end_of_record basic_datagram_socket::message_end_of_record]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.message_end_of_record..message_end_of_record..basic_datagram_socket] 
Specifies that the data marks the end of a record. 


  static const int message_end_of_record = implementation_defined;



[endsect]



[section:message_flags basic_datagram_socket::message_flags]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.message_flags..message_flags..basic_datagram_socket] 
Bitmask type for flags that can be passed to send and receive operations. 


  typedef int message_flags;



[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:message_out_of_band basic_datagram_socket::message_out_of_band]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.message_out_of_band..message_out_of_band..basic_datagram_socket] 
Process out-of-band data. 


  static const int message_out_of_band = implementation_defined;



[endsect]



[section:message_peek basic_datagram_socket::message_peek]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.message_peek..message_peek..basic_datagram_socket] 
Peek at incoming data without removing it from the input queue. 


  static const int message_peek = implementation_defined;



[endsect]



[section:native_handle basic_datagram_socket::native_handle]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.native_handle..native_handle..basic_datagram_socket] 
Get the native socket representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_datagram_socket::native_handle_type]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.native_handle_type..native_handle_type..basic_datagram_socket] 
The native representation of a socket. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:native_non_blocking basic_datagram_socket::native_non_blocking]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.native_non_blocking..native_non_blocking..basic_datagram_socket] 
Gets the non-blocking mode of the native socket implementation. 


  bool ``[link boost_asio.reference.basic_datagram_socket.native_non_blocking.overload1 native_non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.native_non_blocking.overload1 more...]]``


Sets the non-blocking mode of the native socket implementation. 


  void ``[link boost_asio.reference.basic_datagram_socket.native_non_blocking.overload2 native_non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.native_non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.native_non_blocking.overload3 native_non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.native_non_blocking.overload3 more...]]``


[section:overload1 basic_datagram_socket::native_non_blocking (1 of 3 overloads)]


['Inherited from basic_socket.]


Gets the non-blocking mode of the native socket implementation. 


  bool native_non_blocking() const;


This function is used to retrieve the non-blocking mode of the underlying native socket. This mode has no effect on the behaviour of the socket object's synchronous operations.


[heading Return Value]
      
`true` if the underlying socket is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).


[heading Remarks]
      
The current non-blocking mode is cached by the socket object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native socket.


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload2 basic_datagram_socket::native_non_blocking (2 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload3 basic_datagram_socket::native_non_blocking (3 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode,
      boost::system::error_code & ec);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]


[endsect]

[section:non_blocking basic_datagram_socket::non_blocking]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.non_blocking..non_blocking..basic_datagram_socket] 
Gets the non-blocking mode of the socket. 


  bool ``[link boost_asio.reference.basic_datagram_socket.non_blocking.overload1 non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.non_blocking.overload1 more...]]``


Sets the non-blocking mode of the socket. 


  void ``[link boost_asio.reference.basic_datagram_socket.non_blocking.overload2 non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.non_blocking.overload3 non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.non_blocking.overload3 more...]]``


[section:overload1 basic_datagram_socket::non_blocking (1 of 3 overloads)]


['Inherited from basic_socket.]


Gets the non-blocking mode of the socket. 


  bool non_blocking() const;



[heading Return Value]
      
`true` if the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload2 basic_datagram_socket::non_blocking (2 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload3 basic_datagram_socket::non_blocking (3 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode,
      boost::system::error_code & ec);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]


[endsect]

[section:open basic_datagram_socket::open]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.open..open..basic_datagram_socket] 
Open the socket using the specified protocol. 


  void ``[link boost_asio.reference.basic_datagram_socket.open.overload1 open]``(
      const protocol_type & protocol = protocol_type());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.open.overload1 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.open.overload2 open]``(
      const protocol_type & protocol,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.open.overload2 more...]]``


[section:overload1 basic_datagram_socket::open (1 of 2 overloads)]


['Inherited from basic_socket.]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol = protocol_type());


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());







[endsect]



[section:overload2 basic_datagram_socket::open (2 of 2 overloads)]


['Inherited from basic_socket.]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol,
      boost::system::error_code & ec);


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying which protocol is to be used.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::system::error_code ec;
   socket.open(boost::asio::ip::tcp::v4(), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:operator_eq_ basic_datagram_socket::operator=]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.operator_eq_..operator=..basic_datagram_socket] 
Move-assign a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] from another. 


  basic_datagram_socket & ``[link boost_asio.reference.basic_datagram_socket.operator_eq_.overload1 operator=]``(
      basic_datagram_socket && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.operator_eq_.overload1 more...]]``


Move-assign a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value, basic_datagram_socket & >::type ``[link boost_asio.reference.basic_datagram_socket.operator_eq_.overload2 operator=]``(
      basic_datagram_socket< Protocol1, Executor1 > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.operator_eq_.overload2 more...]]``


[section:overload1 basic_datagram_socket::operator= (1 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] from another. 


  basic_datagram_socket & operator=(
      basic_datagram_socket && other);


This assignment operator moves a datagram socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_datagram_socket(const executor_type&)` constructor. 




[endsect]



[section:overload2 basic_datagram_socket::operator= (2 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value, basic_datagram_socket & >::type operator=(
      basic_datagram_socket< Protocol1, Executor1 > && other);


This assignment operator moves a datagram socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_datagram_socket(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:out_of_band_inline basic_datagram_socket::out_of_band_inline]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.out_of_band_inline..out_of_band_inline..basic_datagram_socket] 
Socket option for putting received out-of-band data inline. 


  typedef implementation_defined out_of_band_inline;



Implements the SOL\_SOCKET/SO\_OOBINLINE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option;
   socket.get_option(option);
   bool value = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol_type basic_datagram_socket::protocol_type]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.protocol_type..protocol_type..basic_datagram_socket] 
The protocol type. 


  typedef Protocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:receive basic_datagram_socket::receive]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.receive..receive..basic_datagram_socket] 
Receive some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_datagram_socket.receive.overload1 receive]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.receive.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_datagram_socket.receive.overload2 receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.receive.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_datagram_socket.receive.overload3 receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.receive.overload3 more...]]``


[section:overload1 basic_datagram_socket::receive (1 of 3 overloads)]


Receive some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive(
      const MutableBufferSequence & buffers);


This function is used to receive data on the datagram socket. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The receive operation can only be used with a connected socket. Use the receive\_from function to receive data on an unconnected datagram socket.


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.receive(boost::asio::buffer(data, size)); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_datagram_socket::receive (2 of 3 overloads)]


Receive some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags);


This function is used to receive data on the datagram socket. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[flags][Flags specifying how the receive call is to be made.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The receive operation can only be used with a connected socket. Use the receive\_from function to receive data on an unconnected datagram socket. 




[endsect]



[section:overload3 basic_datagram_socket::receive (3 of 3 overloads)]


Receive some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);


This function is used to receive data on the datagram socket. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Remarks]
      
The receive operation can only be used with a connected socket. Use the receive\_from function to receive data on an unconnected datagram socket. 




[endsect]


[endsect]


[section:receive_buffer_size basic_datagram_socket::receive_buffer_size]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.receive_buffer_size..receive_buffer_size..basic_datagram_socket] 
Socket option for the receive buffer size of a socket. 


  typedef implementation_defined receive_buffer_size;



Implements the SOL\_SOCKET/SO\_RCVBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:receive_from basic_datagram_socket::receive_from]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.receive_from..receive_from..basic_datagram_socket] 
Receive a datagram with the endpoint of the sender. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_datagram_socket.receive_from.overload1 receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.receive_from.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_datagram_socket.receive_from.overload2 receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.receive_from.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_datagram_socket.receive_from.overload3 receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.receive_from.overload3 more...]]``


[section:overload1 basic_datagram_socket::receive_from (1 of 3 overloads)]


Receive a datagram with the endpoint of the sender. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint);


This function is used to receive a datagram. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the datagram.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::ip::udp::endpoint sender_endpoint;
   socket.receive_from(
       boost::asio::buffer(data, size), sender_endpoint);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_datagram_socket::receive_from (2 of 3 overloads)]


Receive a datagram with the endpoint of the sender. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags);


This function is used to receive a datagram. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the datagram.]]

[[flags][Flags specifying how the receive call is to be made.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload3 basic_datagram_socket::receive_from (3 of 3 overloads)]


Receive a datagram with the endpoint of the sender. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      boost::system::error_code & ec);


This function is used to receive a datagram. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the datagram.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes received. 




[endsect]


[endsect]


[section:receive_low_watermark basic_datagram_socket::receive_low_watermark]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.receive_low_watermark..receive_low_watermark..basic_datagram_socket] 
Socket option for the receive low watermark. 


  typedef implementation_defined receive_low_watermark;



Implements the SOL\_SOCKET/SO\_RCVLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:release basic_datagram_socket::release]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.release..release..basic_datagram_socket] 
Release ownership of the underlying native socket. 


  native_handle_type ``[link boost_asio.reference.basic_datagram_socket.release.overload1 release]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.release.overload1 more...]]``

  native_handle_type ``[link boost_asio.reference.basic_datagram_socket.release.overload2 release]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.release.overload2 more...]]``


[section:overload1 basic_datagram_socket::release (1 of 2 overloads)]


['Inherited from basic_socket.]


Release ownership of the underlying native socket. 


  native_handle_type release();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]



[section:overload2 basic_datagram_socket::release (2 of 2 overloads)]


['Inherited from basic_socket.]


Release ownership of the underlying native socket. 


  native_handle_type release(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]


[endsect]

[section:remote_endpoint basic_datagram_socket::remote_endpoint]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.remote_endpoint..remote_endpoint..basic_datagram_socket] 
Get the remote endpoint of the socket. 


  endpoint_type ``[link boost_asio.reference.basic_datagram_socket.remote_endpoint.overload1 remote_endpoint]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.remote_endpoint.overload1 more...]]``

  endpoint_type ``[link boost_asio.reference.basic_datagram_socket.remote_endpoint.overload2 remote_endpoint]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.remote_endpoint.overload2 more...]]``


[section:overload1 basic_datagram_socket::remote_endpoint (1 of 2 overloads)]


['Inherited from basic_socket.]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint() const;


This function is used to obtain the remote endpoint of the socket.


[heading Return Value]
      
An object that represents the remote endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();







[endsect]



[section:overload2 basic_datagram_socket::remote_endpoint (2 of 2 overloads)]


['Inherited from basic_socket.]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint(
      boost::system::error_code & ec) const;


This function is used to obtain the remote endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:reuse_address basic_datagram_socket::reuse_address]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.reuse_address..reuse_address..basic_datagram_socket] 
Socket option to allow the socket to be bound to an address that is already in use. 


  typedef implementation_defined reuse_address;



Implements the SOL\_SOCKET/SO\_REUSEADDR socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:send basic_datagram_socket::send]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.send..send..basic_datagram_socket] 
Send some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_datagram_socket.send.overload1 send]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.send.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_datagram_socket.send.overload2 send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.send.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_datagram_socket.send.overload3 send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.send.overload3 more...]]``


[section:overload1 basic_datagram_socket::send (1 of 3 overloads)]


Send some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send(
      const ConstBufferSequence & buffers);


This function is used to send data on the datagram socket. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One ore more data buffers to be sent on the socket.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The send operation can only be used with a connected socket. Use the send\_to function to send data on an unconnected datagram socket.


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.send(boost::asio::buffer(data, size)); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_datagram_socket::send (2 of 3 overloads)]


Send some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags);


This function is used to send data on the datagram socket. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One ore more data buffers to be sent on the socket.]]

[[flags][Flags specifying how the send call is to be made.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The send operation can only be used with a connected socket. Use the send\_to function to send data on an unconnected datagram socket. 




[endsect]



[section:overload3 basic_datagram_socket::send (3 of 3 overloads)]


Send some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);


This function is used to send data on the datagram socket. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket.]]

[[flags][Flags specifying how the send call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Remarks]
      
The send operation can only be used with a connected socket. Use the send\_to function to send data on an unconnected datagram socket. 




[endsect]


[endsect]


[section:send_buffer_size basic_datagram_socket::send_buffer_size]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.send_buffer_size..send_buffer_size..basic_datagram_socket] 
Socket option for the send buffer size of a socket. 


  typedef implementation_defined send_buffer_size;



Implements the SOL\_SOCKET/SO\_SNDBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:send_low_watermark basic_datagram_socket::send_low_watermark]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.send_low_watermark..send_low_watermark..basic_datagram_socket] 
Socket option for the send low watermark. 


  typedef implementation_defined send_low_watermark;



Implements the SOL\_SOCKET/SO\_SNDLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:send_to basic_datagram_socket::send_to]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.send_to..send_to..basic_datagram_socket] 
Send a datagram to the specified endpoint. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_datagram_socket.send_to.overload1 send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.send_to.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_datagram_socket.send_to.overload2 send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.send_to.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_datagram_socket.send_to.overload3 send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.send_to.overload3 more...]]``


[section:overload1 basic_datagram_socket::send_to (1 of 3 overloads)]


Send a datagram to the specified endpoint. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination);


This function is used to send a datagram to the specified remote endpoint. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint.]]

[[destination][The remote endpoint to which the data will be sent.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::ip::udp::endpoint destination(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.send_to(boost::asio::buffer(data, size), destination);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_datagram_socket::send_to (2 of 3 overloads)]


Send a datagram to the specified endpoint. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags);


This function is used to send a datagram to the specified remote endpoint. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint.]]

[[destination][The remote endpoint to which the data will be sent.]]

[[flags][Flags specifying how the send call is to be made.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload3 basic_datagram_socket::send_to (3 of 3 overloads)]


Send a datagram to the specified endpoint. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      boost::system::error_code & ec);


This function is used to send a datagram to the specified remote endpoint. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint.]]

[[destination][The remote endpoint to which the data will be sent.]]

[[flags][Flags specifying how the send call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes sent. 




[endsect]


[endsect]

[section:set_option basic_datagram_socket::set_option]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.set_option..set_option..basic_datagram_socket] 
Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void ``[link boost_asio.reference.basic_datagram_socket.set_option.overload1 set_option]``(
      const SettableSocketOption & option);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.set_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void ``[link boost_asio.reference.basic_datagram_socket.set_option.overload2 set_option]``(
      const SettableSocketOption & option,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.set_option.overload2 more...]]``


[section:overload1 basic_datagram_socket::set_option (1 of 2 overloads)]


['Inherited from basic_socket.]


Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void set_option(
      const SettableSocketOption & option);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::no_delay option(true);
   socket.set_option(option);







[endsect]



[section:overload2 basic_datagram_socket::set_option (2 of 2 overloads)]


['Inherited from basic_socket.]


Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void set_option(
      const SettableSocketOption & option,
      boost::system::error_code & ec);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::no_delay option(true);
   boost::system::error_code ec;
   socket.set_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:shutdown basic_datagram_socket::shutdown]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.shutdown..shutdown..basic_datagram_socket] 
Disable sends or receives on the socket. 


  void ``[link boost_asio.reference.basic_datagram_socket.shutdown.overload1 shutdown]``(
      shutdown_type what);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.shutdown.overload1 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.shutdown.overload2 shutdown]``(
      shutdown_type what,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.shutdown.overload2 more...]]``


[section:overload1 basic_datagram_socket::shutdown (1 of 2 overloads)]


['Inherited from basic_socket.]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);







[endsect]



[section:overload2 basic_datagram_socket::shutdown (2 of 2 overloads)]


['Inherited from basic_socket.]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what,
      boost::system::error_code & ec);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:shutdown_type basic_datagram_socket::shutdown_type]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.shutdown_type..shutdown_type..basic_datagram_socket] 
Different ways a socket may be shutdown. 

  enum shutdown_type

[indexterm2 boost_asio.indexterm.basic_datagram_socket.shutdown_type.shutdown_receive..shutdown_receive..basic_datagram_socket]
[indexterm2 boost_asio.indexterm.basic_datagram_socket.shutdown_type.shutdown_send..shutdown_send..basic_datagram_socket]
[indexterm2 boost_asio.indexterm.basic_datagram_socket.shutdown_type.shutdown_both..shutdown_both..basic_datagram_socket]

[heading Values]
[variablelist

  [
    [shutdown_receive]
    [Shutdown the receive side of the socket. ]
  ]

  [
    [shutdown_send]
    [Shutdown the send side of the socket. ]
  ]

  [
    [shutdown_both]
    [Shutdown both send and receive on the socket. ]
  ]

]



[endsect]


[section:wait basic_datagram_socket::wait]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.wait..wait..basic_datagram_socket] 
Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void ``[link boost_asio.reference.basic_datagram_socket.wait.overload1 wait]``(
      wait_type w);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.wait.overload1 more...]]``

  void ``[link boost_asio.reference.basic_datagram_socket.wait.overload2 wait]``(
      wait_type w,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_datagram_socket.wait.overload2 more...]]``


[section:overload1 basic_datagram_socket::wait (1 of 2 overloads)]


['Inherited from basic_socket.]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.wait(boost::asio::ip::tcp::socket::wait_read);







[endsect]



[section:overload2 basic_datagram_socket::wait (2 of 2 overloads)]


['Inherited from basic_socket.]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w,
      boost::system::error_code & ec);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);







[endsect]


[endsect]


[section:wait_type basic_datagram_socket::wait_type]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_datagram_socket.wait_type..wait_type..basic_datagram_socket] 
Wait types. 

  enum wait_type

[indexterm2 boost_asio.indexterm.basic_datagram_socket.wait_type.wait_read..wait_read..basic_datagram_socket]
[indexterm2 boost_asio.indexterm.basic_datagram_socket.wait_type.wait_write..wait_write..basic_datagram_socket]
[indexterm2 boost_asio.indexterm.basic_datagram_socket.wait_type.wait_error..wait_error..basic_datagram_socket]

[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a socket to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a socket to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a socket to have error conditions pending. ]
  ]

]


For use with `basic_socket::wait()` and `basic_socket::async_wait()`. 


[endsect]



[section:_basic_datagram_socket basic_datagram_socket::~basic_datagram_socket]

[indexterm2 boost_asio.indexterm.basic_datagram_socket._basic_datagram_socket..~basic_datagram_socket..basic_datagram_socket] 
Destroys the socket. 


  ~basic_datagram_socket();


This function destroys the socket, cancelling any outstanding asynchronous operations associated with the socket as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_datagram_socket__rebind_executor basic_datagram_socket::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_datagram_socket__rebind_executor..basic_datagram_socket::rebind_executor]


Rebinds the socket type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_datagram_socket__rebind_executor.other [*other]]]
    [The socket type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_datagram_socket::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_datagram_socket__rebind_executor.other..other..basic_datagram_socket::rebind_executor] 
The socket type when rebound to the specified executor. 


  typedef basic_datagram_socket< Protocol, Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_datagram_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_datagram_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_receive_from [*async_receive_from]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_send [*async_send]]]
    [Start an asynchronous send on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_send_to [*async_send_to]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket [*basic_datagram_socket]] [constructor]]
    [Construct a basic_datagram_socket without opening it. 
     [hr]
     Construct and open a basic_datagram_socket. 
     [hr]
     Construct a basic_datagram_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_datagram_socket on an existing native socket. 
     [hr]
     Move-construct a basic_datagram_socket from another. 
     [hr]
     Move-construct a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_datagram_socket from another. 
     [hr]
     Move-assign a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.receive [*receive]]]
    [Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.receive_from [*receive_from]]]
    [Receive a datagram with the endpoint of the sender. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.send [*send]]]
    [Send some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.send_to [*send_to]]]
    [Send a datagram to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket._basic_datagram_socket [*~basic_datagram_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_datagram_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] class template provides asynchronous and blocking datagram-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `send_to`, `receive`, `receive_from`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe. 


[heading Requirements]

['Header: ][^boost/asio/basic_datagram_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_deadline_timer basic_deadline_timer]

[indexterm1 boost_asio.indexterm.basic_deadline_timer..basic_deadline_timer]


Provides waitable timer functionality. 


  template<
      typename Time,
      typename ``[link boost_asio.reference.TimeTraits TimeTraits]`` = boost::asio::time_traits<Time>,
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  class basic_deadline_timer


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_deadline_timer__rebind_executor [*rebind_executor]]]
    [Rebinds the timer type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_deadline_timer.duration_type [*duration_type]]]
    [The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_deadline_timer.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_deadline_timer.time_type [*time_type]]]
    [The time type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_deadline_timer.traits_type [*traits_type]]]
    [The time traits type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_deadline_timer.async_wait [*async_wait]]]
    [Start an asynchronous wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.basic_deadline_timer [*basic_deadline_timer]] [constructor]]
    [Constructor. 
     [hr]
     Constructor to set a particular expiry time as an absolute time. 
     [hr]
     Constructor to set a particular expiry time relative to now. 
     [hr]
     Move-construct a basic_deadline_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.cancel_one [*cancel_one]]]
    [Cancels one asynchronous operation that is waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.expires_at [*expires_at]]]
    [Get the timer's expiry time as an absolute time. 
     [hr]
     Set the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.expires_from_now [*expires_from_now]]]
    [Get the timer's expiry time relative to now. 
     [hr]
     Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.operator_eq_ [*operator=]]]
    [Move-assign a basic_deadline_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.wait [*wait]]]
    [Perform a blocking wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer._basic_deadline_timer [*~basic_deadline_timer]] [destructor]]
    [Destroys the timer. ]
  ]
  
]

The [link boost_asio.reference.basic_deadline_timer `basic_deadline_timer`] class template provides the ability to perform a blocking or asynchronous wait for a timer to expire.

A deadline timer is always in one of two states: "expired" or "not expired". If the `wait()` or `async_wait()` function is called on an expired timer, the wait operation will complete immediately.

Most applications will use the [link boost_asio.reference.deadline_timer `deadline_timer`] typedef.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.


[heading Examples]
  
Performing a blocking wait: 

   // Construct a timer without setting an expiry time.
   boost::asio::deadline_timer timer(my_context);

   // Set an expiry time relative to now.
   timer.expires_from_now(boost::posix_time::seconds(5));

   // Wait for the timer to expire.
   timer.wait();





Performing an asynchronous wait: 

   void handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Timer expired.
     }
   }

   ...

   // Construct a timer with an absolute expiry time.
   boost::asio::deadline_timer timer(my_context,
       boost::posix_time::time_from_string("2005-12-07 23:59:59.000"));

   // Start an asynchronous wait.
   timer.async_wait(handler);





[heading Changing an active deadline_timer's expiry time]
  


Changing the expiry time of a timer while there are pending asynchronous waits causes those wait operations to be cancelled. To ensure that the action associated with the timer is performed only once, use something like this: used:



   void on_some_event()
   {
     if (my_timer.expires_from_now(seconds(5)) > 0)
     {
       // We managed to cancel the timer. Start new asynchronous wait.
       my_timer.async_wait(on_timeout);
     }
     else
     {
       // Too late, timer has already expired!
     }
   }

   void on_timeout(const boost::system::error_code& e)
   {
     if (e != boost::asio::error::operation_aborted)
     {
       // Timer was not cancelled, take necessary action.
     }
   }





* The `boost::asio::basic_deadline_timer::expires_from_now()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.


* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 



[heading Requirements]

['Header: ][^boost/asio/basic_deadline_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:async_wait basic_deadline_timer::async_wait]

[indexterm2 boost_asio.indexterm.basic_deadline_timer.async_wait..async_wait..basic_deadline_timer] 
Start an asynchronous wait on the timer. 


  template<
      typename ``[link boost_asio.reference.WaitHandler WaitHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_wait(
      WaitHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function may be used to initiate an asynchronous wait against the timer. It always returns immediately.

For each call to `async_wait()`, the supplied handler will be called exactly once. The handler will be called when:


* The timer has expired.


* The timer was cancelled, in which case the handler is passed the error code `boost::asio::error::operation_aborted`.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be called when the timer expires. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:basic_deadline_timer basic_deadline_timer::basic_deadline_timer]

[indexterm2 boost_asio.indexterm.basic_deadline_timer.basic_deadline_timer..basic_deadline_timer..basic_deadline_timer] 
Constructor. 


  explicit ``[link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload1 basic_deadline_timer]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload2 basic_deadline_timer]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload2 more...]]``


Constructor to set a particular expiry time as an absolute time. 


  ``[link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload3 basic_deadline_timer]``(
      const executor_type & ex,
      const time_type & expiry_time);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload4 basic_deadline_timer]``(
      ExecutionContext & context,
      const time_type & expiry_time,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload4 more...]]``


Constructor to set a particular expiry time relative to now. 


  ``[link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload5 basic_deadline_timer]``(
      const executor_type & ex,
      const duration_type & expiry_time);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload5 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload6 basic_deadline_timer]``(
      ExecutionContext & context,
      const duration_type & expiry_time,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload6 more...]]``


Move-construct a [link boost_asio.reference.basic_deadline_timer `basic_deadline_timer`] from another. 


  ``[link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload7 basic_deadline_timer]``(
      basic_deadline_timer && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.basic_deadline_timer.overload7 more...]]``


[section:overload1 basic_deadline_timer::basic_deadline_timer (1 of 7 overloads)]


Constructor. 


  basic_deadline_timer(
      const executor_type & ex);


This constructor creates a timer without setting an expiry time. The `expires_at()` or `expires_from_now()` functions must be called to set an expiry time before the timer can be waited on.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the timer will use, by default, to dispatch handlers for any asynchronous operations performed on the timer. ]]

]




[endsect]



[section:overload2 basic_deadline_timer::basic_deadline_timer (2 of 7 overloads)]


Constructor. 


  template<
      typename ExecutionContext>
  basic_deadline_timer(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a timer without setting an expiry time. The `expires_at()` or `expires_from_now()` functions must be called to set an expiry time before the timer can be waited on.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the timer will use, by default, to dispatch handlers for any asynchronous operations performed on the timer. ]]

]




[endsect]



[section:overload3 basic_deadline_timer::basic_deadline_timer (3 of 7 overloads)]


Constructor to set a particular expiry time as an absolute time. 


  basic_deadline_timer(
      const executor_type & ex,
      const time_type & expiry_time);


This constructor creates a timer and sets the expiry time.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the timer will use, by default, to dispatch handlers for any asynchronous operations performed on the timer.]]

[[expiry_time][The expiry time to be used for the timer, expressed as an absolute time. ]]

]




[endsect]



[section:overload4 basic_deadline_timer::basic_deadline_timer (4 of 7 overloads)]


Constructor to set a particular expiry time as an absolute time. 


  template<
      typename ExecutionContext>
  basic_deadline_timer(
      ExecutionContext & context,
      const time_type & expiry_time,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a timer and sets the expiry time.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the timer will use, by default, to dispatch handlers for any asynchronous operations performed on the timer.]]

[[expiry_time][The expiry time to be used for the timer, expressed as an absolute time. ]]

]




[endsect]



[section:overload5 basic_deadline_timer::basic_deadline_timer (5 of 7 overloads)]


Constructor to set a particular expiry time relative to now. 


  basic_deadline_timer(
      const executor_type & ex,
      const duration_type & expiry_time);


This constructor creates a timer and sets the expiry time.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the timer will use, by default, to dispatch handlers for any asynchronous operations performed on the timer.]]

[[expiry_time][The expiry time to be used for the timer, relative to now. ]]

]




[endsect]



[section:overload6 basic_deadline_timer::basic_deadline_timer (6 of 7 overloads)]


Constructor to set a particular expiry time relative to now. 


  template<
      typename ExecutionContext>
  basic_deadline_timer(
      ExecutionContext & context,
      const duration_type & expiry_time,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a timer and sets the expiry time.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the timer will use, by default, to dispatch handlers for any asynchronous operations performed on the timer.]]

[[expiry_time][The expiry time to be used for the timer, relative to now. ]]

]




[endsect]



[section:overload7 basic_deadline_timer::basic_deadline_timer (7 of 7 overloads)]


Move-construct a [link boost_asio.reference.basic_deadline_timer `basic_deadline_timer`] from another. 


  basic_deadline_timer(
      basic_deadline_timer && other);


This constructor moves a timer from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_deadline_timer `basic_deadline_timer`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_deadline_timer(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:cancel basic_deadline_timer::cancel]

[indexterm2 boost_asio.indexterm.basic_deadline_timer.cancel..cancel..basic_deadline_timer] 
Cancel any asynchronous operations that are waiting on the timer. 


  std::size_t ``[link boost_asio.reference.basic_deadline_timer.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.cancel.overload1 more...]]``

  std::size_t ``[link boost_asio.reference.basic_deadline_timer.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.cancel.overload2 more...]]``


[section:overload1 basic_deadline_timer::cancel (1 of 2 overloads)]


Cancel any asynchronous operations that are waiting on the timer. 


  std::size_t cancel();


This function forces the completion of any pending asynchronous wait operations against the timer. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.

Cancelling the timer does not change the expiry time.


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If the timer has already expired when `cancel()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]



[section:overload2 basic_deadline_timer::cancel (2 of 2 overloads)]


Cancel any asynchronous operations that are waiting on the timer. 


  std::size_t cancel(
      boost::system::error_code & ec);


This function forces the completion of any pending asynchronous wait operations against the timer. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.

Cancelling the timer does not change the expiry time.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Remarks]
      
If the timer has already expired when `cancel()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]


[endsect]

[section:cancel_one basic_deadline_timer::cancel_one]

[indexterm2 boost_asio.indexterm.basic_deadline_timer.cancel_one..cancel_one..basic_deadline_timer] 
Cancels one asynchronous operation that is waiting on the timer. 


  std::size_t ``[link boost_asio.reference.basic_deadline_timer.cancel_one.overload1 cancel_one]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.cancel_one.overload1 more...]]``

  std::size_t ``[link boost_asio.reference.basic_deadline_timer.cancel_one.overload2 cancel_one]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.cancel_one.overload2 more...]]``


[section:overload1 basic_deadline_timer::cancel_one (1 of 2 overloads)]


Cancels one asynchronous operation that is waiting on the timer. 


  std::size_t cancel_one();


This function forces the completion of one pending asynchronous wait operation against the timer. Handlers are cancelled in FIFO order. The handler for the cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.

Cancelling the timer does not change the expiry time.


[heading Return Value]
      
The number of asynchronous operations that were cancelled. That is, either 0 or 1.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If the timer has already expired when `cancel_one()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]



[section:overload2 basic_deadline_timer::cancel_one (2 of 2 overloads)]


Cancels one asynchronous operation that is waiting on the timer. 


  std::size_t cancel_one(
      boost::system::error_code & ec);


This function forces the completion of one pending asynchronous wait operation against the timer. Handlers are cancelled in FIFO order. The handler for the cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.

Cancelling the timer does not change the expiry time.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled. That is, either 0 or 1.


[heading Remarks]
      
If the timer has already expired when `cancel_one()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]


[endsect]


[section:duration_type basic_deadline_timer::duration_type]

[indexterm2 boost_asio.indexterm.basic_deadline_timer.duration_type..duration_type..basic_deadline_timer] 
The duration type. 


  typedef traits_type::duration_type duration_type;



[heading Requirements]

['Header: ][^boost/asio/basic_deadline_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:executor_type basic_deadline_timer::executor_type]

[indexterm2 boost_asio.indexterm.basic_deadline_timer.executor_type..executor_type..basic_deadline_timer] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_deadline_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:expires_at basic_deadline_timer::expires_at]

[indexterm2 boost_asio.indexterm.basic_deadline_timer.expires_at..expires_at..basic_deadline_timer] 
Get the timer's expiry time as an absolute time. 


  time_type ``[link boost_asio.reference.basic_deadline_timer.expires_at.overload1 expires_at]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.expires_at.overload1 more...]]``


Set the timer's expiry time as an absolute time. 


  std::size_t ``[link boost_asio.reference.basic_deadline_timer.expires_at.overload2 expires_at]``(
      const time_type & expiry_time);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.expires_at.overload2 more...]]``

  std::size_t ``[link boost_asio.reference.basic_deadline_timer.expires_at.overload3 expires_at]``(
      const time_type & expiry_time,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.expires_at.overload3 more...]]``


[section:overload1 basic_deadline_timer::expires_at (1 of 3 overloads)]


Get the timer's expiry time as an absolute time. 


  time_type expires_at() const;


This function may be used to obtain the timer's current expiry time. Whether the timer has expired or not does not affect this value. 


[endsect]



[section:overload2 basic_deadline_timer::expires_at (2 of 3 overloads)]


Set the timer's expiry time as an absolute time. 


  std::size_t expires_at(
      const time_type & expiry_time);


This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If the timer has already expired when `expires_at()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]



[section:overload3 basic_deadline_timer::expires_at (3 of 3 overloads)]


Set the timer's expiry time as an absolute time. 


  std::size_t expires_at(
      const time_type & expiry_time,
      boost::system::error_code & ec);


This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Remarks]
      
If the timer has already expired when `expires_at()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]


[endsect]

[section:expires_from_now basic_deadline_timer::expires_from_now]

[indexterm2 boost_asio.indexterm.basic_deadline_timer.expires_from_now..expires_from_now..basic_deadline_timer] 
Get the timer's expiry time relative to now. 


  duration_type ``[link boost_asio.reference.basic_deadline_timer.expires_from_now.overload1 expires_from_now]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.expires_from_now.overload1 more...]]``


Set the timer's expiry time relative to now. 


  std::size_t ``[link boost_asio.reference.basic_deadline_timer.expires_from_now.overload2 expires_from_now]``(
      const duration_type & expiry_time);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.expires_from_now.overload2 more...]]``

  std::size_t ``[link boost_asio.reference.basic_deadline_timer.expires_from_now.overload3 expires_from_now]``(
      const duration_type & expiry_time,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.expires_from_now.overload3 more...]]``


[section:overload1 basic_deadline_timer::expires_from_now (1 of 3 overloads)]


Get the timer's expiry time relative to now. 


  duration_type expires_from_now() const;


This function may be used to obtain the timer's current expiry time. Whether the timer has expired or not does not affect this value. 


[endsect]



[section:overload2 basic_deadline_timer::expires_from_now (2 of 3 overloads)]


Set the timer's expiry time relative to now. 


  std::size_t expires_from_now(
      const duration_type & expiry_time);


This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If the timer has already expired when `expires_from_now()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]



[section:overload3 basic_deadline_timer::expires_from_now (3 of 3 overloads)]


Set the timer's expiry time relative to now. 


  std::size_t expires_from_now(
      const duration_type & expiry_time,
      boost::system::error_code & ec);


This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Remarks]
      
If the timer has already expired when `expires_from_now()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]


[endsect]


[section:get_executor basic_deadline_timer::get_executor]

[indexterm2 boost_asio.indexterm.basic_deadline_timer.get_executor..get_executor..basic_deadline_timer] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:operator_eq_ basic_deadline_timer::operator=]

[indexterm2 boost_asio.indexterm.basic_deadline_timer.operator_eq_..operator=..basic_deadline_timer] 
Move-assign a [link boost_asio.reference.basic_deadline_timer `basic_deadline_timer`] from another. 


  basic_deadline_timer & operator=(
      basic_deadline_timer && other);


This assignment operator moves a timer from one object to another. Cancels any outstanding asynchronous operations associated with the target object.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_deadline_timer `basic_deadline_timer`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_deadline_timer(const executor_type&)` constructor. 




[endsect]



[section:time_type basic_deadline_timer::time_type]

[indexterm2 boost_asio.indexterm.basic_deadline_timer.time_type..time_type..basic_deadline_timer] 
The time type. 


  typedef traits_type::time_type time_type;



[heading Requirements]

['Header: ][^boost/asio/basic_deadline_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:traits_type basic_deadline_timer::traits_type]

[indexterm2 boost_asio.indexterm.basic_deadline_timer.traits_type..traits_type..basic_deadline_timer] 
The time traits type. 


  typedef TimeTraits traits_type;



[heading Requirements]

['Header: ][^boost/asio/basic_deadline_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:wait basic_deadline_timer::wait]

[indexterm2 boost_asio.indexterm.basic_deadline_timer.wait..wait..basic_deadline_timer] 
Perform a blocking wait on the timer. 


  void ``[link boost_asio.reference.basic_deadline_timer.wait.overload1 wait]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.wait.overload1 more...]]``

  void ``[link boost_asio.reference.basic_deadline_timer.wait.overload2 wait]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_deadline_timer.wait.overload2 more...]]``


[section:overload1 basic_deadline_timer::wait (1 of 2 overloads)]


Perform a blocking wait on the timer. 


  void wait();


This function is used to wait for the timer to expire. This function blocks and does not return until the timer has expired.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_deadline_timer::wait (2 of 2 overloads)]


Perform a blocking wait on the timer. 


  void wait(
      boost::system::error_code & ec);


This function is used to wait for the timer to expire. This function blocks and does not return until the timer has expired.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:_basic_deadline_timer basic_deadline_timer::~basic_deadline_timer]

[indexterm2 boost_asio.indexterm.basic_deadline_timer._basic_deadline_timer..~basic_deadline_timer..basic_deadline_timer] 
Destroys the timer. 


  ~basic_deadline_timer();


This function destroys the timer, cancelling any outstanding asynchronous wait operations associated with the timer as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_deadline_timer__rebind_executor basic_deadline_timer::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_deadline_timer__rebind_executor..basic_deadline_timer::rebind_executor]


Rebinds the timer type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_deadline_timer__rebind_executor.other [*other]]]
    [The timer type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_deadline_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_deadline_timer::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_deadline_timer__rebind_executor.other..other..basic_deadline_timer::rebind_executor] 
The timer type when rebound to the specified executor. 


  typedef basic_deadline_timer< Time, TimeTraits, Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_deadline_timer__rebind_executor [*rebind_executor]]]
    [Rebinds the timer type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_deadline_timer.duration_type [*duration_type]]]
    [The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_deadline_timer.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_deadline_timer.time_type [*time_type]]]
    [The time type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_deadline_timer.traits_type [*traits_type]]]
    [The time traits type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_deadline_timer.async_wait [*async_wait]]]
    [Start an asynchronous wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.basic_deadline_timer [*basic_deadline_timer]] [constructor]]
    [Constructor. 
     [hr]
     Constructor to set a particular expiry time as an absolute time. 
     [hr]
     Constructor to set a particular expiry time relative to now. 
     [hr]
     Move-construct a basic_deadline_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.cancel_one [*cancel_one]]]
    [Cancels one asynchronous operation that is waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.expires_at [*expires_at]]]
    [Get the timer's expiry time as an absolute time. 
     [hr]
     Set the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.expires_from_now [*expires_from_now]]]
    [Get the timer's expiry time relative to now. 
     [hr]
     Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.operator_eq_ [*operator=]]]
    [Move-assign a basic_deadline_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.wait [*wait]]]
    [Perform a blocking wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer._basic_deadline_timer [*~basic_deadline_timer]] [destructor]]
    [Destroys the timer. ]
  ]
  
]

The [link boost_asio.reference.basic_deadline_timer `basic_deadline_timer`] class template provides the ability to perform a blocking or asynchronous wait for a timer to expire.

A deadline timer is always in one of two states: "expired" or "not expired". If the `wait()` or `async_wait()` function is called on an expired timer, the wait operation will complete immediately.

Most applications will use the [link boost_asio.reference.deadline_timer `deadline_timer`] typedef.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.


[heading Examples]
  
Performing a blocking wait: 

   // Construct a timer without setting an expiry time.
   boost::asio::deadline_timer timer(my_context);

   // Set an expiry time relative to now.
   timer.expires_from_now(boost::posix_time::seconds(5));

   // Wait for the timer to expire.
   timer.wait();





Performing an asynchronous wait: 

   void handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Timer expired.
     }
   }

   ...

   // Construct a timer with an absolute expiry time.
   boost::asio::deadline_timer timer(my_context,
       boost::posix_time::time_from_string("2005-12-07 23:59:59.000"));

   // Start an asynchronous wait.
   timer.async_wait(handler);





[heading Changing an active deadline_timer's expiry time]
  


Changing the expiry time of a timer while there are pending asynchronous waits causes those wait operations to be cancelled. To ensure that the action associated with the timer is performed only once, use something like this: used:



   void on_some_event()
   {
     if (my_timer.expires_from_now(seconds(5)) > 0)
     {
       // We managed to cancel the timer. Start new asynchronous wait.
       my_timer.async_wait(on_timeout);
     }
     else
     {
       // Too late, timer has already expired!
     }
   }

   void on_timeout(const boost::system::error_code& e)
   {
     if (e != boost::asio::error::operation_aborted)
     {
       // Timer was not cancelled, take necessary action.
     }
   }





* The `boost::asio::basic_deadline_timer::expires_from_now()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.


* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 




[heading Requirements]

['Header: ][^boost/asio/basic_deadline_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_file basic_file]

[indexterm1 boost_asio.indexterm.basic_file..basic_file]


Provides file functionality. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class basic_file :
    public file_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_file__rebind_executor [*rebind_executor]]]
    [Rebinds the file type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_file.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_file.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.basic_file.native_handle_type [*native_handle_type]]]
    [The native representation of a file. ]
  
  ]

  [

    [[link boost_asio.reference.basic_file.seek_basis [*seek_basis]]]
    [Basis for seeking in a file. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_file.assign [*assign]]]
    [Assign an existing native file to the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.basic_file [*basic_file]] [constructor]]
    [Construct a basic_file without opening it. 
     [hr]
     Construct and open a basic_file. 
     [hr]
     Construct a basic_file on an existing native file handle. 
     [hr]
     Construct a basic_file on an existing native file. 
     [hr]
     Move-construct a basic_file from another. 
     [hr]
     Move-construct a basic_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.close [*close]]]
    [Close the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.is_open [*is_open]]]
    [Determine whether the file is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.native_handle [*native_handle]]]
    [Get the native file representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.open [*open]]]
    [Open the file using the specified path. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.operator_eq_ [*operator=]]]
    [Move-assign a basic_file from another. 
     [hr]
     Move-assign a basic_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.release [*release]]]
    [Release ownership of the underlying native file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.resize [*resize]]]
    [Alter the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.size [*size]]]
    [Get the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.sync_all [*sync_all]]]
    [Synchronise the file to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.sync_data [*sync_data]]]
    [Synchronise the file data to disk. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_file._basic_file [*~basic_file]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_file.append [*append]] [static]]
    [Open the file in append mode. ]
  ]

  [
    [[link boost_asio.reference.basic_file.create [*create]] [static]]
    [Create the file if it does not exist. ]
  ]

  [
    [[link boost_asio.reference.basic_file.exclusive [*exclusive]] [static]]
    [Ensure a new file is created. Must be combined with create. ]
  ]

  [
    [[link boost_asio.reference.basic_file.read_only [*read_only]] [static]]
    [Open the file for reading. ]
  ]

  [
    [[link boost_asio.reference.basic_file.read_write [*read_write]] [static]]
    [Open the file for reading and writing. ]
  ]

  [
    [[link boost_asio.reference.basic_file.truncate [*truncate]] [static]]
    [Open the file with any existing contents truncated. ]
  ]

  [
    [[link boost_asio.reference.basic_file.write_only [*write_only]] [static]]
    [Open the file for writing. ]
  ]

]

The [link boost_asio.reference.basic_file `basic_file`] class template provides functionality that is common to both stream-oriented and random-access files.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/basic_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:append basic_file::append]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_file.append..append..basic_file] 
Open the file in append mode. 


  static const flags append = implementation_defined;



[endsect]


[section:assign basic_file::assign]

[indexterm2 boost_asio.indexterm.basic_file.assign..assign..basic_file] 
Assign an existing native file to the file. 


  void ``[link boost_asio.reference.basic_file.assign.overload1 assign]``(
      const native_handle_type & native_file);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.assign.overload1 more...]]``

  void ``[link boost_asio.reference.basic_file.assign.overload2 assign]``(
      const native_handle_type & native_file,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.assign.overload2 more...]]``


[section:overload1 basic_file::assign (1 of 2 overloads)]


Assign an existing native file to the file. 


  void assign(
      const native_handle_type & native_file);



[endsect]



[section:overload2 basic_file::assign (2 of 2 overloads)]


Assign an existing native file to the file. 


  void assign(
      const native_handle_type & native_file,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:basic_file basic_file::basic_file]

[indexterm2 boost_asio.indexterm.basic_file.basic_file..basic_file..basic_file] 
Construct a [link boost_asio.reference.basic_file `basic_file`] without opening it. 


  explicit ``[link boost_asio.reference.basic_file.basic_file.overload1 basic_file]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.basic_file.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_file.basic_file.overload2 basic_file]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.basic_file.overload2 more...]]``


Construct and open a [link boost_asio.reference.basic_file `basic_file`]. 


  explicit ``[link boost_asio.reference.basic_file.basic_file.overload3 basic_file]``(
      const executor_type & ex,
      const char * path,
      file_base::flags open_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.basic_file.overload3 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_file.basic_file.overload4 basic_file]``(
      ExecutionContext & context,
      const char * path,
      file_base::flags open_flags,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.basic_file.overload4 more...]]``

  explicit ``[link boost_asio.reference.basic_file.basic_file.overload5 basic_file]``(
      const executor_type & ex,
      const std::string & path,
      file_base::flags open_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.basic_file.overload5 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_file.basic_file.overload6 basic_file]``(
      ExecutionContext & context,
      const std::string & path,
      file_base::flags open_flags,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.basic_file.overload6 more...]]``


Construct a [link boost_asio.reference.basic_file `basic_file`] on an existing native file handle. 


  ``[link boost_asio.reference.basic_file.basic_file.overload7 basic_file]``(
      const executor_type & ex,
      const native_handle_type & native_file);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.basic_file.overload7 more...]]``


Construct a [link boost_asio.reference.basic_file `basic_file`] on an existing native file. 


  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_file.basic_file.overload8 basic_file]``(
      ExecutionContext & context,
      const native_handle_type & native_file,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.basic_file.overload8 more...]]``


Move-construct a [link boost_asio.reference.basic_file `basic_file`] from another. 


  ``[link boost_asio.reference.basic_file.basic_file.overload9 basic_file]``(
      basic_file && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.basic_file.overload9 more...]]``


Move-construct a [link boost_asio.reference.basic_file `basic_file`] from a file of another executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.basic_file.basic_file.overload10 basic_file]``(
      basic_file< Executor1 > && other,
      typename constraint< is_convertible< Executor1, Executor >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.basic_file.overload10 more...]]``


[section:overload1 basic_file::basic_file (1 of 10 overloads)]


Construct a [link boost_asio.reference.basic_file `basic_file`] without opening it. 


  basic_file(
      const executor_type & ex);


This constructor initialises a file without opening it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file. ]]

]




[endsect]



[section:overload2 basic_file::basic_file (2 of 10 overloads)]


Construct a [link boost_asio.reference.basic_file `basic_file`] without opening it. 


  template<
      typename ExecutionContext>
  basic_file(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor initialises a file without opening it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file. ]]

]




[endsect]



[section:overload3 basic_file::basic_file (3 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_file `basic_file`]. 


  basic_file(
      const executor_type & ex,
      const char * path,
      file_base::flags open_flags);


This constructor initialises a file and opens it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened. ]]

]




[endsect]



[section:overload4 basic_file::basic_file (4 of 10 overloads)]


Construct a [link boost_asio.reference.basic_file `basic_file`] without opening it. 


  template<
      typename ExecutionContext>
  basic_file(
      ExecutionContext & context,
      const char * path,
      file_base::flags open_flags,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor initialises a file and opens it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened. ]]

]




[endsect]



[section:overload5 basic_file::basic_file (5 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_file `basic_file`]. 


  basic_file(
      const executor_type & ex,
      const std::string & path,
      file_base::flags open_flags);


This constructor initialises a file and opens it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened. ]]

]




[endsect]



[section:overload6 basic_file::basic_file (6 of 10 overloads)]


Construct a [link boost_asio.reference.basic_file `basic_file`] without opening it. 


  template<
      typename ExecutionContext>
  basic_file(
      ExecutionContext & context,
      const std::string & path,
      file_base::flags open_flags,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor initialises a file and opens it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened. ]]

]




[endsect]



[section:overload7 basic_file::basic_file (7 of 10 overloads)]


Construct a [link boost_asio.reference.basic_file `basic_file`] on an existing native file handle. 


  basic_file(
      const executor_type & ex,
      const native_handle_type & native_file);


This constructor initialises a file object to hold an existing native file.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[native_file][A native file handle.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 basic_file::basic_file (8 of 10 overloads)]


Construct a [link boost_asio.reference.basic_file `basic_file`] on an existing native file. 


  template<
      typename ExecutionContext>
  basic_file(
      ExecutionContext & context,
      const native_handle_type & native_file,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor initialises a file object to hold an existing native file.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[native_file][A native file.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload9 basic_file::basic_file (9 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_file `basic_file`] from another. 


  basic_file(
      basic_file && other);


This constructor moves a file from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_file `basic_file`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_file(const executor_type&) constructor`. 




[endsect]



[section:overload10 basic_file::basic_file (10 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_file `basic_file`] from a file of another executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_file(
      basic_file< Executor1 > && other,
      typename constraint< is_convertible< Executor1, Executor >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor moves a file from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_file `basic_file`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_file(const executor_type&) constructor`. 




[endsect]


[endsect]

[section:cancel basic_file::cancel]

[indexterm2 boost_asio.indexterm.basic_file.cancel..cancel..basic_file] 
Cancel all asynchronous operations associated with the file. 


  void ``[link boost_asio.reference.basic_file.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_file.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.cancel.overload2 more...]]``


[section:overload1 basic_file::cancel (1 of 2 overloads)]


Cancel all asynchronous operations associated with the file. 


  void cancel();


This function causes all outstanding asynchronous read and write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using the `close()` function to simultaneously cancel the outstanding operations and close the file.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]



[section:overload2 basic_file::cancel (2 of 2 overloads)]


Cancel all asynchronous operations associated with the file. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read and write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using the `close()` function to simultaneously cancel the outstanding operations and close the file.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]


[endsect]

[section:close basic_file::close]

[indexterm2 boost_asio.indexterm.basic_file.close..close..basic_file] 
Close the file. 


  void ``[link boost_asio.reference.basic_file.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.close.overload1 more...]]``

  void ``[link boost_asio.reference.basic_file.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.close.overload2 more...]]``


[section:overload1 basic_file::close (1 of 2 overloads)]


Close the file. 


  void close();


This function is used to close the file. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed. ]]

]




[endsect]



[section:overload2 basic_file::close (2 of 2 overloads)]


Close the file. 


  void close(
      boost::system::error_code & ec);


This function is used to close the file. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   ...
   boost::system::error_code ec;
   file.close(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:create basic_file::create]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_file.create..create..basic_file] 
Create the file if it does not exist. 


  static const flags create = implementation_defined;



[endsect]



[section:exclusive basic_file::exclusive]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_file.exclusive..exclusive..basic_file] 
Ensure a new file is created. Must be combined with `create`. 


  static const flags exclusive = implementation_defined;



[endsect]



[section:executor_type basic_file::executor_type]

[indexterm2 boost_asio.indexterm.basic_file.executor_type..executor_type..basic_file] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:flags basic_file::flags]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_file.flags..flags..basic_file] 
A bitmask type (C++ Std [lib.bitmask.types]). 


  typedef unspecified flags;



[heading Requirements]

['Header: ][^boost/asio/basic_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_file::get_executor]

[indexterm2 boost_asio.indexterm.basic_file.get_executor..get_executor..basic_file] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:is_open basic_file::is_open]

[indexterm2 boost_asio.indexterm.basic_file.is_open..is_open..basic_file] 
Determine whether the file is open. 


  bool is_open() const;



[endsect]



[section:native_handle basic_file::native_handle]

[indexterm2 boost_asio.indexterm.basic_file.native_handle..native_handle..basic_file] 
Get the native file representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the file. This is intended to allow access to native file functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_file::native_handle_type]

[indexterm2 boost_asio.indexterm.basic_file.native_handle_type..native_handle_type..basic_file] 
The native representation of a file. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/basic_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:open basic_file::open]

[indexterm2 boost_asio.indexterm.basic_file.open..open..basic_file] 
Open the file using the specified path. 


  void ``[link boost_asio.reference.basic_file.open.overload1 open]``(
      const char * path,
      file_base::flags open_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.open.overload1 more...]]``

  void ``[link boost_asio.reference.basic_file.open.overload2 open]``(
      const char * path,
      file_base::flags open_flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.open.overload2 more...]]``

  void ``[link boost_asio.reference.basic_file.open.overload3 open]``(
      const std::string & path,
      file_base::flags open_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.open.overload3 more...]]``

  void ``[link boost_asio.reference.basic_file.open.overload4 open]``(
      const std::string & path,
      file_base::flags open_flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.open.overload4 more...]]``


[section:overload1 basic_file::open (1 of 4 overloads)]


Open the file using the specified path. 


  void open(
      const char * path,
      file_base::flags open_flags);


This function opens the file so that it will use the specified path.


[heading Parameters]
    

[variablelist
  
[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   file.open("/path/to/my/file", boost::asio::stream_file::read_only);







[endsect]



[section:overload2 basic_file::open (2 of 4 overloads)]


Open the file using the specified path. 


  void open(
      const char * path,
      file_base::flags open_flags,
      boost::system::error_code & ec);


This function opens the file so that it will use the specified path.


[heading Parameters]
    

[variablelist
  
[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   boost::system::error_code ec;
   file.open("/path/to/my/file", boost::asio::stream_file::read_only, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]



[section:overload3 basic_file::open (3 of 4 overloads)]


Open the file using the specified path. 


  void open(
      const std::string & path,
      file_base::flags open_flags);


This function opens the file so that it will use the specified path.


[heading Parameters]
    

[variablelist
  
[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   file.open("/path/to/my/file", boost::asio::stream_file::read_only);







[endsect]



[section:overload4 basic_file::open (4 of 4 overloads)]


Open the file using the specified path. 


  void open(
      const std::string & path,
      file_base::flags open_flags,
      boost::system::error_code & ec);


This function opens the file so that it will use the specified path.


[heading Parameters]
    

[variablelist
  
[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   boost::system::error_code ec;
   file.open("/path/to/my/file", boost::asio::stream_file::read_only, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:operator_eq_ basic_file::operator=]

[indexterm2 boost_asio.indexterm.basic_file.operator_eq_..operator=..basic_file] 
Move-assign a [link boost_asio.reference.basic_file `basic_file`] from another. 


  basic_file & ``[link boost_asio.reference.basic_file.operator_eq_.overload1 operator=]``(
      basic_file && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.operator_eq_.overload1 more...]]``


Move-assign a [link boost_asio.reference.basic_file `basic_file`] from a file of another executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_file & >::type ``[link boost_asio.reference.basic_file.operator_eq_.overload2 operator=]``(
      basic_file< Executor1 > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.operator_eq_.overload2 more...]]``


[section:overload1 basic_file::operator= (1 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_file `basic_file`] from another. 


  basic_file & operator=(
      basic_file && other);


This assignment operator moves a file from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_file `basic_file`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_file(const executor_type&) constructor`. 




[endsect]



[section:overload2 basic_file::operator= (2 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_file `basic_file`] from a file of another executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_file & >::type operator=(
      basic_file< Executor1 > && other);


This assignment operator moves a file from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_file `basic_file`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_file(const executor_type&) constructor`. 




[endsect]


[endsect]


[section:read_only basic_file::read_only]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_file.read_only..read_only..basic_file] 
Open the file for reading. 


  static const flags read_only = implementation_defined;



[endsect]



[section:read_write basic_file::read_write]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_file.read_write..read_write..basic_file] 
Open the file for reading and writing. 


  static const flags read_write = implementation_defined;



[endsect]


[section:release basic_file::release]

[indexterm2 boost_asio.indexterm.basic_file.release..release..basic_file] 
Release ownership of the underlying native file. 


  native_handle_type ``[link boost_asio.reference.basic_file.release.overload1 release]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.release.overload1 more...]]``

  native_handle_type ``[link boost_asio.reference.basic_file.release.overload2 release]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.release.overload2 more...]]``


[section:overload1 basic_file::release (1 of 2 overloads)]


Release ownership of the underlying native file. 


  native_handle_type release();


This function causes all outstanding asynchronous read and write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native file is then transferred to the caller.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]



[section:overload2 basic_file::release (2 of 2 overloads)]


Release ownership of the underlying native file. 


  native_handle_type release(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read and write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native file is then transferred to the caller.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]


[endsect]

[section:resize basic_file::resize]

[indexterm2 boost_asio.indexterm.basic_file.resize..resize..basic_file] 
Alter the size of the file. 


  void ``[link boost_asio.reference.basic_file.resize.overload1 resize]``(
      uint64_t n);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.resize.overload1 more...]]``

  void ``[link boost_asio.reference.basic_file.resize.overload2 resize]``(
      uint64_t n,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.resize.overload2 more...]]``


[section:overload1 basic_file::resize (1 of 2 overloads)]


Alter the size of the file. 


  void resize(
      uint64_t n);


This function resizes the file to the specified size, in bytes. If the current file size exceeds `n` then any extra data is discarded. If the current size is less than `n` then the file is extended and filled with zeroes.


[heading Parameters]
    

[variablelist
  
[[n][The new size for the file.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_file::resize (2 of 2 overloads)]


Alter the size of the file. 


  void resize(
      uint64_t n,
      boost::system::error_code & ec);


This function resizes the file to the specified size, in bytes. If the current file size exceeds `n` then any extra data is discarded. If the current size is less than `n` then the file is extended and filled with zeroes.


[heading Parameters]
    

[variablelist
  
[[n][The new size for the file.]]

[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:seek_basis basic_file::seek_basis]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_file.seek_basis..seek_basis..basic_file] 
Basis for seeking in a file. 

  enum seek_basis

[indexterm2 boost_asio.indexterm.basic_file.seek_basis.seek_set..seek_set..basic_file]
[indexterm2 boost_asio.indexterm.basic_file.seek_basis.seek_cur..seek_cur..basic_file]
[indexterm2 boost_asio.indexterm.basic_file.seek_basis.seek_end..seek_end..basic_file]

[heading Values]
[variablelist

  [
    [seek_set]
    [Seek to an absolute position. ]
  ]

  [
    [seek_cur]
    [Seek to an offset relative to the current file position. ]
  ]

  [
    [seek_end]
    [Seek to an offset relative to the end of the file. ]
  ]

]



[endsect]


[section:size basic_file::size]

[indexterm2 boost_asio.indexterm.basic_file.size..size..basic_file] 
Get the size of the file. 


  uint64_t ``[link boost_asio.reference.basic_file.size.overload1 size]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.size.overload1 more...]]``

  uint64_t ``[link boost_asio.reference.basic_file.size.overload2 size]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.size.overload2 more...]]``


[section:overload1 basic_file::size (1 of 2 overloads)]


Get the size of the file. 


  uint64_t size() const;


This function determines the size of the file, in bytes.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_file::size (2 of 2 overloads)]


Get the size of the file. 


  uint64_t size(
      boost::system::error_code & ec) const;


This function determines the size of the file, in bytes.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:sync_all basic_file::sync_all]

[indexterm2 boost_asio.indexterm.basic_file.sync_all..sync_all..basic_file] 
Synchronise the file to disk. 


  void ``[link boost_asio.reference.basic_file.sync_all.overload1 sync_all]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.sync_all.overload1 more...]]``

  void ``[link boost_asio.reference.basic_file.sync_all.overload2 sync_all]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.sync_all.overload2 more...]]``


[section:overload1 basic_file::sync_all (1 of 2 overloads)]


Synchronise the file to disk. 


  void sync_all();


This function synchronises the file data and metadata to disk. Note that the semantics of this synchronisation vary between operation systems.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_file::sync_all (2 of 2 overloads)]


Synchronise the file to disk. 


  void sync_all(
      boost::system::error_code & ec);


This function synchronises the file data and metadata to disk. Note that the semantics of this synchronisation vary between operation systems.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:sync_data basic_file::sync_data]

[indexterm2 boost_asio.indexterm.basic_file.sync_data..sync_data..basic_file] 
Synchronise the file data to disk. 


  void ``[link boost_asio.reference.basic_file.sync_data.overload1 sync_data]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.sync_data.overload1 more...]]``

  void ``[link boost_asio.reference.basic_file.sync_data.overload2 sync_data]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_file.sync_data.overload2 more...]]``


[section:overload1 basic_file::sync_data (1 of 2 overloads)]


Synchronise the file data to disk. 


  void sync_data();


This function synchronises the file data to disk. Note that the semantics of this synchronisation vary between operation systems.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_file::sync_data (2 of 2 overloads)]


Synchronise the file data to disk. 


  void sync_data(
      boost::system::error_code & ec);


This function synchronises the file data to disk. Note that the semantics of this synchronisation vary between operation systems.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:truncate basic_file::truncate]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_file.truncate..truncate..basic_file] 
Open the file with any existing contents truncated. 


  static const flags truncate = implementation_defined;



[endsect]



[section:write_only basic_file::write_only]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_file.write_only..write_only..basic_file] 
Open the file for writing. 


  static const flags write_only = implementation_defined;



[endsect]



[section:_basic_file basic_file::~basic_file]

[indexterm2 boost_asio.indexterm.basic_file._basic_file..~basic_file..basic_file] 
Protected destructor to prevent deletion through this type. 


  ~basic_file();


This function destroys the file, cancelling any outstanding asynchronous operations associated with the file as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_file__rebind_executor basic_file::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_file__rebind_executor..basic_file::rebind_executor]


Rebinds the file type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_file__rebind_executor.other [*other]]]
    [The file type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_file::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_file__rebind_executor.other..other..basic_file::rebind_executor] 
The file type when rebound to the specified executor. 


  typedef basic_file< Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_file__rebind_executor [*rebind_executor]]]
    [Rebinds the file type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_file.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_file.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.basic_file.native_handle_type [*native_handle_type]]]
    [The native representation of a file. ]
  
  ]

  [

    [[link boost_asio.reference.basic_file.seek_basis [*seek_basis]]]
    [Basis for seeking in a file. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_file.assign [*assign]]]
    [Assign an existing native file to the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.basic_file [*basic_file]] [constructor]]
    [Construct a basic_file without opening it. 
     [hr]
     Construct and open a basic_file. 
     [hr]
     Construct a basic_file on an existing native file handle. 
     [hr]
     Construct a basic_file on an existing native file. 
     [hr]
     Move-construct a basic_file from another. 
     [hr]
     Move-construct a basic_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.close [*close]]]
    [Close the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.is_open [*is_open]]]
    [Determine whether the file is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.native_handle [*native_handle]]]
    [Get the native file representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.open [*open]]]
    [Open the file using the specified path. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.operator_eq_ [*operator=]]]
    [Move-assign a basic_file from another. 
     [hr]
     Move-assign a basic_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.release [*release]]]
    [Release ownership of the underlying native file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.resize [*resize]]]
    [Alter the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.size [*size]]]
    [Get the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.sync_all [*sync_all]]]
    [Synchronise the file to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_file.sync_data [*sync_data]]]
    [Synchronise the file data to disk. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_file._basic_file [*~basic_file]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_file.append [*append]] [static]]
    [Open the file in append mode. ]
  ]

  [
    [[link boost_asio.reference.basic_file.create [*create]] [static]]
    [Create the file if it does not exist. ]
  ]

  [
    [[link boost_asio.reference.basic_file.exclusive [*exclusive]] [static]]
    [Ensure a new file is created. Must be combined with create. ]
  ]

  [
    [[link boost_asio.reference.basic_file.read_only [*read_only]] [static]]
    [Open the file for reading. ]
  ]

  [
    [[link boost_asio.reference.basic_file.read_write [*read_write]] [static]]
    [Open the file for reading and writing. ]
  ]

  [
    [[link boost_asio.reference.basic_file.truncate [*truncate]] [static]]
    [Open the file with any existing contents truncated. ]
  ]

  [
    [[link boost_asio.reference.basic_file.write_only [*write_only]] [static]]
    [Open the file for writing. ]
  ]

]

The [link boost_asio.reference.basic_file `basic_file`] class template provides functionality that is common to both stream-oriented and random-access files.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_io_object basic_io_object]

[indexterm1 boost_asio.indexterm.basic_io_object..basic_io_object]


Base class for all I/O objects. 


  template<
      typename ``[link boost_asio.reference.IoObjectService IoObjectService]``>
  class basic_io_object


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_io_object.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_io_object.implementation_type [*implementation_type]]]
    [The underlying implementation type of I/O object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_io_object.service_type [*service_type]]]
    [The type of the service that will be used to provide I/O operations. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_io_object.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_io_object.get_io_context [*get_io_context]]]
    [(Deprecated: Use get_executor().) Get the io_context associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_io_object.get_io_service [*get_io_service]]]
    [(Deprecated: Use get_executor().) Get the io_context associated with the object. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_io_object.basic_io_object [*basic_io_object]] [constructor]]
    [Construct a basic_io_object. 
     [hr]
     Move-construct a basic_io_object. 
     [hr]
     Perform a converting move-construction of a basic_io_object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_io_object.get_implementation [*get_implementation]]]
    [Get the underlying implementation of the I/O object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_io_object.get_service [*get_service]]]
    [Get the service associated with the I/O object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_io_object.operator_eq_ [*operator=]]]
    [Move-assign a basic_io_object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_io_object._basic_io_object [*~basic_io_object]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]


[heading Remarks]
      
All I/O objects are non-copyable. However, when using C++0x, certain I/O objects do support move construction and move assignment. 



[heading Requirements]

['Header: ][^boost/asio/basic_io_object.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_io_object basic_io_object::basic_io_object]

[indexterm2 boost_asio.indexterm.basic_io_object.basic_io_object..basic_io_object..basic_io_object] 
Construct a [link boost_asio.reference.basic_io_object `basic_io_object`]. 


  explicit ``[link boost_asio.reference.basic_io_object.basic_io_object.overload1 basic_io_object]``(
      boost::asio::io_context & io_context);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_io_object.basic_io_object.overload1 more...]]``


Move-construct a [link boost_asio.reference.basic_io_object `basic_io_object`]. 


  ``[link boost_asio.reference.basic_io_object.basic_io_object.overload2 basic_io_object]``(
      basic_io_object && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_io_object.basic_io_object.overload2 more...]]``


Perform a converting move-construction of a [link boost_asio.reference.basic_io_object `basic_io_object`]. 


  template<
      typename ``[link boost_asio.reference.IoObjectService IoObjectService1]``>
  ``[link boost_asio.reference.basic_io_object.basic_io_object.overload3 basic_io_object]``(
      IoObjectService1 & other_service,
      typename IoObjectService1::implementation_type & other_implementation);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_io_object.basic_io_object.overload3 more...]]``


[section:overload1 basic_io_object::basic_io_object (1 of 3 overloads)]


Construct a [link boost_asio.reference.basic_io_object `basic_io_object`]. 


  basic_io_object(
      boost::asio::io_context & io_context);


Performs: 

   get_service().construct(get_implementation()); 





[endsect]



[section:overload2 basic_io_object::basic_io_object (2 of 3 overloads)]


Move-construct a [link boost_asio.reference.basic_io_object `basic_io_object`]. 


  basic_io_object(
      basic_io_object && other);


Performs: 

   get_service().move_construct(
       get_implementation(), other.get_implementation()); 





[heading Remarks]
      
Available only for services that support movability, 




[endsect]



[section:overload3 basic_io_object::basic_io_object (3 of 3 overloads)]


Perform a converting move-construction of a [link boost_asio.reference.basic_io_object `basic_io_object`]. 


  template<
      typename ``[link boost_asio.reference.IoObjectService IoObjectService1]``>
  basic_io_object(
      IoObjectService1 & other_service,
      typename IoObjectService1::implementation_type & other_implementation);



[endsect]


[endsect]


[section:executor_type basic_io_object::executor_type]

[indexterm2 boost_asio.indexterm.basic_io_object.executor_type..executor_type..basic_io_object] 
The type of the executor associated with the object. 


  typedef boost::asio::io_context::executor_type executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_io_object.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_io_object::get_executor]

[indexterm2 boost_asio.indexterm.basic_io_object.get_executor..get_executor..basic_io_object] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:get_implementation basic_io_object::get_implementation]

[indexterm2 boost_asio.indexterm.basic_io_object.get_implementation..get_implementation..basic_io_object] 
Get the underlying implementation of the I/O object. 


  implementation_type & ``[link boost_asio.reference.basic_io_object.get_implementation.overload1 get_implementation]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_io_object.get_implementation.overload1 more...]]``

  const implementation_type & ``[link boost_asio.reference.basic_io_object.get_implementation.overload2 get_implementation]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_io_object.get_implementation.overload2 more...]]``


[section:overload1 basic_io_object::get_implementation (1 of 2 overloads)]


Get the underlying implementation of the I/O object. 


  implementation_type & get_implementation();



[endsect]



[section:overload2 basic_io_object::get_implementation (2 of 2 overloads)]


Get the underlying implementation of the I/O object. 


  const implementation_type & get_implementation() const;



[endsect]


[endsect]


[section:get_io_context basic_io_object::get_io_context]

[indexterm2 boost_asio.indexterm.basic_io_object.get_io_context..get_io_context..basic_io_object] 
(Deprecated: Use `get_executor()`.) Get the [link boost_asio.reference.io_context `io_context`] associated with the object. 


  boost::asio::io_context & get_io_context();


This function may be used to obtain the [link boost_asio.reference.io_context `io_context`] object that the I/O object uses to dispatch handlers for asynchronous operations.


[heading Return Value]
      
A reference to the [link boost_asio.reference.io_context `io_context`] object that the I/O object will use to dispatch handlers. Ownership is not transferred to the caller. 




[endsect]



[section:get_io_service basic_io_object::get_io_service]

[indexterm2 boost_asio.indexterm.basic_io_object.get_io_service..get_io_service..basic_io_object] 
(Deprecated: Use `get_executor()`.) Get the [link boost_asio.reference.io_context `io_context`] associated with the object. 


  boost::asio::io_context & get_io_service();


This function may be used to obtain the [link boost_asio.reference.io_context `io_context`] object that the I/O object uses to dispatch handlers for asynchronous operations.


[heading Return Value]
      
A reference to the [link boost_asio.reference.io_context `io_context`] object that the I/O object will use to dispatch handlers. Ownership is not transferred to the caller. 




[endsect]


[section:get_service basic_io_object::get_service]

[indexterm2 boost_asio.indexterm.basic_io_object.get_service..get_service..basic_io_object] 
Get the service associated with the I/O object. 


  service_type & ``[link boost_asio.reference.basic_io_object.get_service.overload1 get_service]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_io_object.get_service.overload1 more...]]``

  const service_type & ``[link boost_asio.reference.basic_io_object.get_service.overload2 get_service]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_io_object.get_service.overload2 more...]]``


[section:overload1 basic_io_object::get_service (1 of 2 overloads)]


Get the service associated with the I/O object. 


  service_type & get_service();



[endsect]



[section:overload2 basic_io_object::get_service (2 of 2 overloads)]


Get the service associated with the I/O object. 


  const service_type & get_service() const;



[endsect]


[endsect]


[section:implementation_type basic_io_object::implementation_type]

[indexterm2 boost_asio.indexterm.basic_io_object.implementation_type..implementation_type..basic_io_object] 
The underlying implementation type of I/O object. 


  typedef service_type::implementation_type implementation_type;



[heading Requirements]

['Header: ][^boost/asio/basic_io_object.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ basic_io_object::operator=]

[indexterm2 boost_asio.indexterm.basic_io_object.operator_eq_..operator=..basic_io_object] 
Move-assign a [link boost_asio.reference.basic_io_object `basic_io_object`]. 


  basic_io_object & operator=(
      basic_io_object && other);


Performs: 

   get_service().move_assign(get_implementation(),
       other.get_service(), other.get_implementation()); 





[heading Remarks]
      
Available only for services that support movability, 




[endsect]



[section:service_type basic_io_object::service_type]

[indexterm2 boost_asio.indexterm.basic_io_object.service_type..service_type..basic_io_object] 
The type of the service that will be used to provide I/O operations. 


  typedef IoObjectService service_type;



[heading Requirements]

['Header: ][^boost/asio/basic_io_object.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:_basic_io_object basic_io_object::~basic_io_object]

[indexterm2 boost_asio.indexterm.basic_io_object._basic_io_object..~basic_io_object..basic_io_object] 
Protected destructor to prevent deletion through this type. 


  ~basic_io_object();


Performs: 

   get_service().destroy(get_implementation()); 





[endsect]



[endsect]

[section:basic_random_access_file basic_random_access_file]

[indexterm1 boost_asio.indexterm.basic_random_access_file..basic_random_access_file]


Provides random-access file functionality. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class basic_random_access_file :
    public basic_file< Executor >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_random_access_file__rebind_executor [*rebind_executor]]]
    [Rebinds the file type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_random_access_file.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_random_access_file.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.basic_random_access_file.native_handle_type [*native_handle_type]]]
    [The native representation of a file. ]
  
  ]

  [

    [[link boost_asio.reference.basic_random_access_file.seek_basis [*seek_basis]]]
    [Basis for seeking in a file. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_random_access_file.assign [*assign]]]
    [Assign an existing native file to the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.async_read_some_at [*async_read_some_at]]]
    [Start an asynchronous read at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.async_write_some_at [*async_write_some_at]]]
    [Start an asynchronous write at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.basic_random_access_file [*basic_random_access_file]] [constructor]]
    [Construct a basic_random_access_file without opening it. 
     [hr]
     Construct and open a basic_random_access_file. 
     [hr]
     Construct a basic_random_access_file on an existing native file. 
     [hr]
     Move-construct a basic_random_access_file from another. 
     [hr]
     Move-construct a basic_random_access_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.close [*close]]]
    [Close the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.is_open [*is_open]]]
    [Determine whether the file is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.native_handle [*native_handle]]]
    [Get the native file representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.open [*open]]]
    [Open the file using the specified path. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.operator_eq_ [*operator=]]]
    [Move-assign a basic_random_access_file from another. 
     [hr]
     Move-assign a basic_random_access_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.read_some_at [*read_some_at]]]
    [Read some data from the handle at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.release [*release]]]
    [Release ownership of the underlying native file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.resize [*resize]]]
    [Alter the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.size [*size]]]
    [Get the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.sync_all [*sync_all]]]
    [Synchronise the file to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.sync_data [*sync_data]]]
    [Synchronise the file data to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.write_some_at [*write_some_at]]]
    [Write some data to the handle at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file._basic_random_access_file [*~basic_random_access_file]] [destructor]]
    [Destroys the file. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_random_access_file.append [*append]] [static]]
    [Open the file in append mode. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.create [*create]] [static]]
    [Create the file if it does not exist. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.exclusive [*exclusive]] [static]]
    [Ensure a new file is created. Must be combined with create. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.read_only [*read_only]] [static]]
    [Open the file for reading. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.read_write [*read_write]] [static]]
    [Open the file for reading and writing. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.truncate [*truncate]] [static]]
    [Open the file with any existing contents truncated. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.write_only [*write_only]] [static]]
    [Open the file for writing. ]
  ]

]

The [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] class template provides asynchronous and blocking random-access file functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `read_some_at` and `write_some_at` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single file object. Other synchronous operations, such as `open` or `close`, are not thread safe. 

[heading Requirements]

['Header: ][^boost/asio/basic_random_access_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:append basic_random_access_file::append]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_random_access_file.append..append..basic_random_access_file] 
Open the file in append mode. 


  static const flags append = implementation_defined;



[endsect]


[section:assign basic_random_access_file::assign]

[indexterm2 boost_asio.indexterm.basic_random_access_file.assign..assign..basic_random_access_file] 
Assign an existing native file to the file. 


  void ``[link boost_asio.reference.basic_random_access_file.assign.overload1 assign]``(
      const native_handle_type & native_file);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.assign.overload1 more...]]``

  void ``[link boost_asio.reference.basic_random_access_file.assign.overload2 assign]``(
      const native_handle_type & native_file,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.assign.overload2 more...]]``


[section:overload1 basic_random_access_file::assign (1 of 2 overloads)]


['Inherited from basic_file.]


Assign an existing native file to the file. 


  void assign(
      const native_handle_type & native_file);



[endsect]



[section:overload2 basic_random_access_file::assign (2 of 2 overloads)]


['Inherited from basic_file.]


Assign an existing native file to the file. 


  void assign(
      const native_handle_type & native_file,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_read_some_at basic_random_access_file::async_read_some_at]

[indexterm2 boost_asio.indexterm.basic_random_access_file.async_read_some_at..async_read_some_at..basic_random_access_file] 
Start an asynchronous read at the specified offset. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_some_at(
      uint64_t offset,
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data from the random-access handle. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes read.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The read operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.async_read_at `async_read_at`]  function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   handle.async_read_some_at(42, boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:async_write_some_at basic_random_access_file::async_write_some_at]

[indexterm2 boost_asio.indexterm.basic_random_access_file.async_write_some_at..async_write_some_at..basic_random_access_file] 
Start an asynchronous write at the specified offset. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_some_at(
      uint64_t offset,
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write data to the random-access handle. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[offset][The offset at which the data will be written.]]

[[buffers][One or more data buffers to be written to the handle. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes written.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The write operation may not write all of the data to the file. Consider using the [link boost_asio.reference.async_write_at `async_write_at`]  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   handle.async_write_some_at(42, boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:basic_random_access_file basic_random_access_file::basic_random_access_file]

[indexterm2 boost_asio.indexterm.basic_random_access_file.basic_random_access_file..basic_random_access_file..basic_random_access_file] 
Construct a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] without opening it. 


  explicit ``[link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload1 basic_random_access_file]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload2 basic_random_access_file]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload2 more...]]``


Construct and open a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`]. 


  ``[link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload3 basic_random_access_file]``(
      const executor_type & ex,
      const char * path,
      file_base::flags open_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload4 basic_random_access_file]``(
      ExecutionContext & context,
      const char * path,
      file_base::flags open_flags,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload4 more...]]``

  ``[link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload5 basic_random_access_file]``(
      const executor_type & ex,
      const std::string & path,
      file_base::flags open_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload5 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload6 basic_random_access_file]``(
      ExecutionContext & context,
      const std::string & path,
      file_base::flags open_flags,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload6 more...]]``


Construct a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] on an existing native file. 


  ``[link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload7 basic_random_access_file]``(
      const executor_type & ex,
      const native_handle_type & native_file);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload7 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload8 basic_random_access_file]``(
      ExecutionContext & context,
      const native_handle_type & native_file,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload8 more...]]``


Move-construct a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] from another. 


  ``[link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload9 basic_random_access_file]``(
      basic_random_access_file && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload9 more...]]``


Move-construct a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] from a file of another executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload10 basic_random_access_file]``(
      basic_random_access_file< Executor1 > && other,
      typename constraint< is_convertible< Executor1, Executor >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.basic_random_access_file.overload10 more...]]``


[section:overload1 basic_random_access_file::basic_random_access_file (1 of 10 overloads)]


Construct a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] without opening it. 


  basic_random_access_file(
      const executor_type & ex);


This constructor initialises a file without opening it. The file needs to be opened before data can be read from or or written to it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file. ]]

]




[endsect]



[section:overload2 basic_random_access_file::basic_random_access_file (2 of 10 overloads)]


Construct a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] without opening it. 


  template<
      typename ExecutionContext>
  basic_random_access_file(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor initialises a file without opening it. The file needs to be opened before data can be read from or or written to it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file. ]]

]




[endsect]



[section:overload3 basic_random_access_file::basic_random_access_file (3 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`]. 


  basic_random_access_file(
      const executor_type & ex,
      const char * path,
      file_base::flags open_flags);


This constructor initialises and opens a file.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_random_access_file::basic_random_access_file (4 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`]. 


  template<
      typename ExecutionContext>
  basic_random_access_file(
      ExecutionContext & context,
      const char * path,
      file_base::flags open_flags,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor initialises and opens a file.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_random_access_file::basic_random_access_file (5 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`]. 


  basic_random_access_file(
      const executor_type & ex,
      const std::string & path,
      file_base::flags open_flags);


This constructor initialises and opens a file.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload6 basic_random_access_file::basic_random_access_file (6 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`]. 


  template<
      typename ExecutionContext>
  basic_random_access_file(
      ExecutionContext & context,
      const std::string & path,
      file_base::flags open_flags,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor initialises and opens a file.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload7 basic_random_access_file::basic_random_access_file (7 of 10 overloads)]


Construct a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] on an existing native file. 


  basic_random_access_file(
      const executor_type & ex,
      const native_handle_type & native_file);


This constructor initialises a random-access file object to hold an existing native file.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[native_file][The new underlying file implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 basic_random_access_file::basic_random_access_file (8 of 10 overloads)]


Construct a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] on an existing native file. 


  template<
      typename ExecutionContext>
  basic_random_access_file(
      ExecutionContext & context,
      const native_handle_type & native_file,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor initialises a random-access file object to hold an existing native file.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[native_file][The new underlying file implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload9 basic_random_access_file::basic_random_access_file (9 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] from another. 


  basic_random_access_file(
      basic_random_access_file && other);


This constructor moves a random-access file from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_random_access_file(const executor_type&)` constructor. 




[endsect]



[section:overload10 basic_random_access_file::basic_random_access_file (10 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] from a file of another executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_random_access_file(
      basic_random_access_file< Executor1 > && other,
      typename constraint< is_convertible< Executor1, Executor >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor moves a random-access file from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_random_access_file(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:cancel basic_random_access_file::cancel]

[indexterm2 boost_asio.indexterm.basic_random_access_file.cancel..cancel..basic_random_access_file] 
Cancel all asynchronous operations associated with the file. 


  void ``[link boost_asio.reference.basic_random_access_file.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_random_access_file.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.cancel.overload2 more...]]``


[section:overload1 basic_random_access_file::cancel (1 of 2 overloads)]


['Inherited from basic_file.]


Cancel all asynchronous operations associated with the file. 


  void cancel();


This function causes all outstanding asynchronous read and write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using the `close()` function to simultaneously cancel the outstanding operations and close the file.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]



[section:overload2 basic_random_access_file::cancel (2 of 2 overloads)]


['Inherited from basic_file.]


Cancel all asynchronous operations associated with the file. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read and write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using the `close()` function to simultaneously cancel the outstanding operations and close the file.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]


[endsect]

[section:close basic_random_access_file::close]

[indexterm2 boost_asio.indexterm.basic_random_access_file.close..close..basic_random_access_file] 
Close the file. 


  void ``[link boost_asio.reference.basic_random_access_file.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.close.overload1 more...]]``

  void ``[link boost_asio.reference.basic_random_access_file.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.close.overload2 more...]]``


[section:overload1 basic_random_access_file::close (1 of 2 overloads)]


['Inherited from basic_file.]


Close the file. 


  void close();


This function is used to close the file. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed. ]]

]




[endsect]



[section:overload2 basic_random_access_file::close (2 of 2 overloads)]


['Inherited from basic_file.]


Close the file. 


  void close(
      boost::system::error_code & ec);


This function is used to close the file. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   ...
   boost::system::error_code ec;
   file.close(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:create basic_random_access_file::create]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_random_access_file.create..create..basic_random_access_file] 
Create the file if it does not exist. 


  static const flags create = implementation_defined;



[endsect]



[section:exclusive basic_random_access_file::exclusive]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_random_access_file.exclusive..exclusive..basic_random_access_file] 
Ensure a new file is created. Must be combined with `create`. 


  static const flags exclusive = implementation_defined;



[endsect]



[section:executor_type basic_random_access_file::executor_type]

[indexterm2 boost_asio.indexterm.basic_random_access_file.executor_type..executor_type..basic_random_access_file] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_random_access_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:flags basic_random_access_file::flags]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_random_access_file.flags..flags..basic_random_access_file] 
A bitmask type (C++ Std [lib.bitmask.types]). 


  typedef unspecified flags;



[heading Requirements]

['Header: ][^boost/asio/basic_random_access_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_random_access_file::get_executor]


['Inherited from basic_file.]

[indexterm2 boost_asio.indexterm.basic_random_access_file.get_executor..get_executor..basic_random_access_file] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:is_open basic_random_access_file::is_open]


['Inherited from basic_file.]

[indexterm2 boost_asio.indexterm.basic_random_access_file.is_open..is_open..basic_random_access_file] 
Determine whether the file is open. 


  bool is_open() const;



[endsect]



[section:native_handle basic_random_access_file::native_handle]


['Inherited from basic_file.]

[indexterm2 boost_asio.indexterm.basic_random_access_file.native_handle..native_handle..basic_random_access_file] 
Get the native file representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the file. This is intended to allow access to native file functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_random_access_file::native_handle_type]

[indexterm2 boost_asio.indexterm.basic_random_access_file.native_handle_type..native_handle_type..basic_random_access_file] 
The native representation of a file. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/basic_random_access_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:open basic_random_access_file::open]

[indexterm2 boost_asio.indexterm.basic_random_access_file.open..open..basic_random_access_file] 
Open the file using the specified path. 


  void ``[link boost_asio.reference.basic_random_access_file.open.overload1 open]``(
      const char * path,
      file_base::flags open_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.open.overload1 more...]]``

  void ``[link boost_asio.reference.basic_random_access_file.open.overload2 open]``(
      const char * path,
      file_base::flags open_flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.open.overload2 more...]]``

  void ``[link boost_asio.reference.basic_random_access_file.open.overload3 open]``(
      const std::string & path,
      file_base::flags open_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.open.overload3 more...]]``

  void ``[link boost_asio.reference.basic_random_access_file.open.overload4 open]``(
      const std::string & path,
      file_base::flags open_flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.open.overload4 more...]]``


[section:overload1 basic_random_access_file::open (1 of 4 overloads)]


['Inherited from basic_file.]


Open the file using the specified path. 


  void open(
      const char * path,
      file_base::flags open_flags);


This function opens the file so that it will use the specified path.


[heading Parameters]
    

[variablelist
  
[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   file.open("/path/to/my/file", boost::asio::stream_file::read_only);







[endsect]



[section:overload2 basic_random_access_file::open (2 of 4 overloads)]


['Inherited from basic_file.]


Open the file using the specified path. 


  void open(
      const char * path,
      file_base::flags open_flags,
      boost::system::error_code & ec);


This function opens the file so that it will use the specified path.


[heading Parameters]
    

[variablelist
  
[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   boost::system::error_code ec;
   file.open("/path/to/my/file", boost::asio::stream_file::read_only, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]



[section:overload3 basic_random_access_file::open (3 of 4 overloads)]


['Inherited from basic_file.]


Open the file using the specified path. 


  void open(
      const std::string & path,
      file_base::flags open_flags);


This function opens the file so that it will use the specified path.


[heading Parameters]
    

[variablelist
  
[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   file.open("/path/to/my/file", boost::asio::stream_file::read_only);







[endsect]



[section:overload4 basic_random_access_file::open (4 of 4 overloads)]


['Inherited from basic_file.]


Open the file using the specified path. 


  void open(
      const std::string & path,
      file_base::flags open_flags,
      boost::system::error_code & ec);


This function opens the file so that it will use the specified path.


[heading Parameters]
    

[variablelist
  
[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   boost::system::error_code ec;
   file.open("/path/to/my/file", boost::asio::stream_file::read_only, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:operator_eq_ basic_random_access_file::operator=]

[indexterm2 boost_asio.indexterm.basic_random_access_file.operator_eq_..operator=..basic_random_access_file] 
Move-assign a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] from another. 


  basic_random_access_file & ``[link boost_asio.reference.basic_random_access_file.operator_eq_.overload1 operator=]``(
      basic_random_access_file && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.operator_eq_.overload1 more...]]``


Move-assign a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] from a file of another executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_random_access_file & >::type ``[link boost_asio.reference.basic_random_access_file.operator_eq_.overload2 operator=]``(
      basic_random_access_file< Executor1 > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.operator_eq_.overload2 more...]]``


[section:overload1 basic_random_access_file::operator= (1 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] from another. 


  basic_random_access_file & operator=(
      basic_random_access_file && other);


This assignment operator moves a random-access file from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_random_access_file(const executor_type&)` constructor. 




[endsect]



[section:overload2 basic_random_access_file::operator= (2 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] from a file of another executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_random_access_file & >::type operator=(
      basic_random_access_file< Executor1 > && other);


This assignment operator moves a random-access file from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_random_access_file(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:read_only basic_random_access_file::read_only]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_random_access_file.read_only..read_only..basic_random_access_file] 
Open the file for reading. 


  static const flags read_only = implementation_defined;



[endsect]


[section:read_some_at basic_random_access_file::read_some_at]

[indexterm2 boost_asio.indexterm.basic_random_access_file.read_some_at..read_some_at..basic_random_access_file] 
Read some data from the handle at the specified offset. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_random_access_file.read_some_at.overload1 read_some_at]``(
      uint64_t offset,
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.read_some_at.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_random_access_file.read_some_at.overload2 read_some_at]``(
      uint64_t offset,
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.read_some_at.overload2 more...]]``


[section:overload1 basic_random_access_file::read_some_at (1 of 2 overloads)]


Read some data from the handle at the specified offset. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some_at(
      uint64_t offset,
      const MutableBufferSequence & buffers);


This function is used to read data from the random-access handle. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes read.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the end of the file was reached.]]

]


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read_at `read_at`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   handle.read_some_at(42, boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_random_access_file::read_some_at (2 of 2 overloads)]


Read some data from the handle at the specified offset. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some_at(
      uint64_t offset,
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to read data from the random-access handle. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. Returns 0 if an error occurred.


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read_at `read_at`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]


[endsect]


[section:read_write basic_random_access_file::read_write]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_random_access_file.read_write..read_write..basic_random_access_file] 
Open the file for reading and writing. 


  static const flags read_write = implementation_defined;



[endsect]


[section:release basic_random_access_file::release]

[indexterm2 boost_asio.indexterm.basic_random_access_file.release..release..basic_random_access_file] 
Release ownership of the underlying native file. 


  native_handle_type ``[link boost_asio.reference.basic_random_access_file.release.overload1 release]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.release.overload1 more...]]``

  native_handle_type ``[link boost_asio.reference.basic_random_access_file.release.overload2 release]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.release.overload2 more...]]``


[section:overload1 basic_random_access_file::release (1 of 2 overloads)]


['Inherited from basic_file.]


Release ownership of the underlying native file. 


  native_handle_type release();


This function causes all outstanding asynchronous read and write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native file is then transferred to the caller.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]



[section:overload2 basic_random_access_file::release (2 of 2 overloads)]


['Inherited from basic_file.]


Release ownership of the underlying native file. 


  native_handle_type release(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read and write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native file is then transferred to the caller.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]


[endsect]

[section:resize basic_random_access_file::resize]

[indexterm2 boost_asio.indexterm.basic_random_access_file.resize..resize..basic_random_access_file] 
Alter the size of the file. 


  void ``[link boost_asio.reference.basic_random_access_file.resize.overload1 resize]``(
      uint64_t n);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.resize.overload1 more...]]``

  void ``[link boost_asio.reference.basic_random_access_file.resize.overload2 resize]``(
      uint64_t n,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.resize.overload2 more...]]``


[section:overload1 basic_random_access_file::resize (1 of 2 overloads)]


['Inherited from basic_file.]


Alter the size of the file. 


  void resize(
      uint64_t n);


This function resizes the file to the specified size, in bytes. If the current file size exceeds `n` then any extra data is discarded. If the current size is less than `n` then the file is extended and filled with zeroes.


[heading Parameters]
    

[variablelist
  
[[n][The new size for the file.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_random_access_file::resize (2 of 2 overloads)]


['Inherited from basic_file.]


Alter the size of the file. 


  void resize(
      uint64_t n,
      boost::system::error_code & ec);


This function resizes the file to the specified size, in bytes. If the current file size exceeds `n` then any extra data is discarded. If the current size is less than `n` then the file is extended and filled with zeroes.


[heading Parameters]
    

[variablelist
  
[[n][The new size for the file.]]

[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:seek_basis basic_random_access_file::seek_basis]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_random_access_file.seek_basis..seek_basis..basic_random_access_file] 
Basis for seeking in a file. 

  enum seek_basis

[indexterm2 boost_asio.indexterm.basic_random_access_file.seek_basis.seek_set..seek_set..basic_random_access_file]
[indexterm2 boost_asio.indexterm.basic_random_access_file.seek_basis.seek_cur..seek_cur..basic_random_access_file]
[indexterm2 boost_asio.indexterm.basic_random_access_file.seek_basis.seek_end..seek_end..basic_random_access_file]

[heading Values]
[variablelist

  [
    [seek_set]
    [Seek to an absolute position. ]
  ]

  [
    [seek_cur]
    [Seek to an offset relative to the current file position. ]
  ]

  [
    [seek_end]
    [Seek to an offset relative to the end of the file. ]
  ]

]



[endsect]


[section:size basic_random_access_file::size]

[indexterm2 boost_asio.indexterm.basic_random_access_file.size..size..basic_random_access_file] 
Get the size of the file. 


  uint64_t ``[link boost_asio.reference.basic_random_access_file.size.overload1 size]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.size.overload1 more...]]``

  uint64_t ``[link boost_asio.reference.basic_random_access_file.size.overload2 size]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.size.overload2 more...]]``


[section:overload1 basic_random_access_file::size (1 of 2 overloads)]


['Inherited from basic_file.]


Get the size of the file. 


  uint64_t size() const;


This function determines the size of the file, in bytes.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_random_access_file::size (2 of 2 overloads)]


['Inherited from basic_file.]


Get the size of the file. 


  uint64_t size(
      boost::system::error_code & ec) const;


This function determines the size of the file, in bytes.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:sync_all basic_random_access_file::sync_all]

[indexterm2 boost_asio.indexterm.basic_random_access_file.sync_all..sync_all..basic_random_access_file] 
Synchronise the file to disk. 


  void ``[link boost_asio.reference.basic_random_access_file.sync_all.overload1 sync_all]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.sync_all.overload1 more...]]``

  void ``[link boost_asio.reference.basic_random_access_file.sync_all.overload2 sync_all]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.sync_all.overload2 more...]]``


[section:overload1 basic_random_access_file::sync_all (1 of 2 overloads)]


['Inherited from basic_file.]


Synchronise the file to disk. 


  void sync_all();


This function synchronises the file data and metadata to disk. Note that the semantics of this synchronisation vary between operation systems.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_random_access_file::sync_all (2 of 2 overloads)]


['Inherited from basic_file.]


Synchronise the file to disk. 


  void sync_all(
      boost::system::error_code & ec);


This function synchronises the file data and metadata to disk. Note that the semantics of this synchronisation vary between operation systems.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:sync_data basic_random_access_file::sync_data]

[indexterm2 boost_asio.indexterm.basic_random_access_file.sync_data..sync_data..basic_random_access_file] 
Synchronise the file data to disk. 


  void ``[link boost_asio.reference.basic_random_access_file.sync_data.overload1 sync_data]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.sync_data.overload1 more...]]``

  void ``[link boost_asio.reference.basic_random_access_file.sync_data.overload2 sync_data]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.sync_data.overload2 more...]]``


[section:overload1 basic_random_access_file::sync_data (1 of 2 overloads)]


['Inherited from basic_file.]


Synchronise the file data to disk. 


  void sync_data();


This function synchronises the file data to disk. Note that the semantics of this synchronisation vary between operation systems.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_random_access_file::sync_data (2 of 2 overloads)]


['Inherited from basic_file.]


Synchronise the file data to disk. 


  void sync_data(
      boost::system::error_code & ec);


This function synchronises the file data to disk. Note that the semantics of this synchronisation vary between operation systems.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:truncate basic_random_access_file::truncate]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_random_access_file.truncate..truncate..basic_random_access_file] 
Open the file with any existing contents truncated. 


  static const flags truncate = implementation_defined;



[endsect]



[section:write_only basic_random_access_file::write_only]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_random_access_file.write_only..write_only..basic_random_access_file] 
Open the file for writing. 


  static const flags write_only = implementation_defined;



[endsect]


[section:write_some_at basic_random_access_file::write_some_at]

[indexterm2 boost_asio.indexterm.basic_random_access_file.write_some_at..write_some_at..basic_random_access_file] 
Write some data to the handle at the specified offset. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_random_access_file.write_some_at.overload1 write_some_at]``(
      uint64_t offset,
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.write_some_at.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_random_access_file.write_some_at.overload2 write_some_at]``(
      uint64_t offset,
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_random_access_file.write_some_at.overload2 more...]]``


[section:overload1 basic_random_access_file::write_some_at (1 of 2 overloads)]


Write some data to the handle at the specified offset. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some_at(
      uint64_t offset,
      const ConstBufferSequence & buffers);


This function is used to write data to the random-access handle. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[offset][The offset at which the data will be written.]]

[[buffers][One or more data buffers to be written to the handle.]]

]


[heading Return Value]
      
The number of bytes written.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the end of the file was reached.]]

]


[heading Remarks]
      
The write\_some\_at operation may not write all of the data. Consider using the [link boost_asio.reference.write_at `write_at`]  function if you need to ensure that all data is written before the blocking operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   handle.write_some_at(42, boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_random_access_file::write_some_at (2 of 2 overloads)]


Write some data to the handle at the specified offset. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some_at(
      uint64_t offset,
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to write data to the random-access handle. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[offset][The offset at which the data will be written.]]

[[buffers][One or more data buffers to be written to the handle.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. Returns 0 if an error occurred.


[heading Remarks]
      
The write\_some operation may not write all of the data to the file. Consider using the [link boost_asio.reference.write_at `write_at`]  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]


[endsect]


[section:_basic_random_access_file basic_random_access_file::~basic_random_access_file]

[indexterm2 boost_asio.indexterm.basic_random_access_file._basic_random_access_file..~basic_random_access_file..basic_random_access_file] 
Destroys the file. 


  ~basic_random_access_file();


This function destroys the file, cancelling any outstanding asynchronous operations associated with the file as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_random_access_file__rebind_executor basic_random_access_file::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_random_access_file__rebind_executor..basic_random_access_file::rebind_executor]


Rebinds the file type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_random_access_file__rebind_executor.other [*other]]]
    [The file type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_random_access_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_random_access_file::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_random_access_file__rebind_executor.other..other..basic_random_access_file::rebind_executor] 
The file type when rebound to the specified executor. 


  typedef basic_random_access_file< Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_random_access_file__rebind_executor [*rebind_executor]]]
    [Rebinds the file type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_random_access_file.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_random_access_file.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.basic_random_access_file.native_handle_type [*native_handle_type]]]
    [The native representation of a file. ]
  
  ]

  [

    [[link boost_asio.reference.basic_random_access_file.seek_basis [*seek_basis]]]
    [Basis for seeking in a file. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_random_access_file.assign [*assign]]]
    [Assign an existing native file to the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.async_read_some_at [*async_read_some_at]]]
    [Start an asynchronous read at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.async_write_some_at [*async_write_some_at]]]
    [Start an asynchronous write at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.basic_random_access_file [*basic_random_access_file]] [constructor]]
    [Construct a basic_random_access_file without opening it. 
     [hr]
     Construct and open a basic_random_access_file. 
     [hr]
     Construct a basic_random_access_file on an existing native file. 
     [hr]
     Move-construct a basic_random_access_file from another. 
     [hr]
     Move-construct a basic_random_access_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.close [*close]]]
    [Close the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.is_open [*is_open]]]
    [Determine whether the file is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.native_handle [*native_handle]]]
    [Get the native file representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.open [*open]]]
    [Open the file using the specified path. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.operator_eq_ [*operator=]]]
    [Move-assign a basic_random_access_file from another. 
     [hr]
     Move-assign a basic_random_access_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.read_some_at [*read_some_at]]]
    [Read some data from the handle at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.release [*release]]]
    [Release ownership of the underlying native file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.resize [*resize]]]
    [Alter the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.size [*size]]]
    [Get the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.sync_all [*sync_all]]]
    [Synchronise the file to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.sync_data [*sync_data]]]
    [Synchronise the file data to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.write_some_at [*write_some_at]]]
    [Write some data to the handle at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file._basic_random_access_file [*~basic_random_access_file]] [destructor]]
    [Destroys the file. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_random_access_file.append [*append]] [static]]
    [Open the file in append mode. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.create [*create]] [static]]
    [Create the file if it does not exist. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.exclusive [*exclusive]] [static]]
    [Ensure a new file is created. Must be combined with create. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.read_only [*read_only]] [static]]
    [Open the file for reading. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.read_write [*read_write]] [static]]
    [Open the file for reading and writing. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.truncate [*truncate]] [static]]
    [Open the file with any existing contents truncated. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.write_only [*write_only]] [static]]
    [Open the file for writing. ]
  ]

]

The [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] class template provides asynchronous and blocking random-access file functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `read_some_at` and `write_some_at` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single file object. Other synchronous operations, such as `open` or `close`, are not thread safe. 


[heading Requirements]

['Header: ][^boost/asio/basic_random_access_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_raw_socket basic_raw_socket]

[indexterm1 boost_asio.indexterm.basic_raw_socket..basic_raw_socket]


Provides raw-oriented socket functionality. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class basic_raw_socket :
    public basic_socket< Protocol, Executor >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_raw_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_raw_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_receive_from [*async_receive_from]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_send [*async_send]]]
    [Start an asynchronous send on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_send_to [*async_send_to]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.basic_raw_socket [*basic_raw_socket]] [constructor]]
    [Construct a basic_raw_socket without opening it. 
     [hr]
     Construct and open a basic_raw_socket. 
     [hr]
     Construct a basic_raw_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_raw_socket on an existing native socket. 
     [hr]
     Move-construct a basic_raw_socket from another. 
     [hr]
     Move-construct a basic_raw_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_raw_socket from another. 
     [hr]
     Move-assign a basic_raw_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.receive [*receive]]]
    [Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.receive_from [*receive_from]]]
    [Receive raw data with the endpoint of the sender. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.send [*send]]]
    [Send some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.send_to [*send_to]]]
    [Send raw data to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket._basic_raw_socket [*~basic_raw_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_raw_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] class template provides asynchronous and blocking raw-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `send_to`, `receive`, `receive_from`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe. 

[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign basic_raw_socket::assign]

[indexterm2 boost_asio.indexterm.basic_raw_socket.assign..assign..basic_raw_socket] 
Assign an existing native socket to the socket. 


  void ``[link boost_asio.reference.basic_raw_socket.assign.overload1 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.assign.overload1 more...]]``

  void ``[link boost_asio.reference.basic_raw_socket.assign.overload2 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.assign.overload2 more...]]``


[section:overload1 basic_raw_socket::assign (1 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket);



[endsect]



[section:overload2 basic_raw_socket::assign (2 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_connect basic_raw_socket::async_connect]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.async_connect..async_connect..basic_raw_socket] 
Start an asynchronous connect. 


  template<
      typename ``[link boost_asio.reference.ConnectHandler ConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      const endpoint_type & peer_endpoint,
      ConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.]]

[[handler][The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void connect_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Connect succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.async_connect(endpoint, connect_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:async_receive basic_raw_socket::async_receive]

[indexterm2 boost_asio.indexterm.basic_raw_socket.async_receive..async_receive..basic_raw_socket] 
Start an asynchronous receive on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_raw_socket.async_receive.overload1 async_receive]``(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.async_receive.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_raw_socket.async_receive.overload2 async_receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.async_receive.overload2 more...]]``


[section:overload1 basic_raw_socket::async_receive (1 of 2 overloads)]


Start an asynchronous receive on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive data from the raw socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The async\_receive operation can only be used with a connected socket. Use the async\_receive\_from function to receive data on an unconnected raw socket.


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_receive(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_raw_socket::async_receive (2 of 2 overloads)]


Start an asynchronous receive on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive data from the raw socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The async\_receive operation can only be used with a connected socket. Use the async\_receive\_from function to receive data on an unconnected raw socket.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]

[section:async_receive_from basic_raw_socket::async_receive_from]

[indexterm2 boost_asio.indexterm.basic_raw_socket.async_receive_from..async_receive_from..basic_raw_socket] 
Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_raw_socket.async_receive_from.overload1 async_receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.async_receive_from.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_raw_socket.async_receive_from.overload2 async_receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.async_receive_from.overload2 more...]]``


[section:overload1 basic_raw_socket::async_receive_from (1 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive raw data. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the data. Ownership of the sender\_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_receive_from(
       boost::asio::buffer(data, size), 0, sender_endpoint, handler); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_raw_socket::async_receive_from (2 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive raw data. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the data. Ownership of the sender\_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]

[section:async_send basic_raw_socket::async_send]

[indexterm2 boost_asio.indexterm.basic_raw_socket.async_send..async_send..basic_raw_socket] 
Start an asynchronous send on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_raw_socket.async_send.overload1 async_send]``(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.async_send.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_raw_socket.async_send.overload2 async_send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.async_send.overload2 more...]]``


[section:overload1 basic_raw_socket::async_send (1 of 2 overloads)]


Start an asynchronous send on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to send data on the raw socket. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The async\_send operation can only be used with a connected socket. Use the async\_send\_to function to send data on an unconnected raw socket.


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_send(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_raw_socket::async_send (2 of 2 overloads)]


Start an asynchronous send on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to send data on the raw socket. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the send call is to be made.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The async\_send operation can only be used with a connected socket. Use the async\_send\_to function to send data on an unconnected raw socket.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]

[section:async_send_to basic_raw_socket::async_send_to]

[indexterm2 boost_asio.indexterm.basic_raw_socket.async_send_to..async_send_to..basic_raw_socket] 
Start an asynchronous send. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_raw_socket.async_send_to.overload1 async_send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.async_send_to.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_raw_socket.async_send_to.overload2 async_send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.async_send_to.overload2 more...]]``


[section:overload1 basic_raw_socket::async_send_to (1 of 2 overloads)]


Start an asynchronous send. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously send raw data to the specified remote endpoint. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[destination][The remote endpoint to which the data will be sent. Copies will be made of the endpoint as required.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::ip::udp::endpoint destination(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.async_send_to(
       boost::asio::buffer(data, size), destination, handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_raw_socket::async_send_to (2 of 2 overloads)]


Start an asynchronous send. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously send raw data to the specified remote endpoint. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the send call is to be made.]]

[[destination][The remote endpoint to which the data will be sent. Copies will be made of the endpoint as required.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]


[section:async_wait basic_raw_socket::async_wait]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.async_wait..async_wait..basic_raw_socket] 
Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  template<
      typename ``[link boost_asio.reference.WaitHandler WaitHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_wait(
      wait_type w,
      WaitHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to perform an asynchronous wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[handler][The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void wait_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Wait succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:at_mark basic_raw_socket::at_mark]

[indexterm2 boost_asio.indexterm.basic_raw_socket.at_mark..at_mark..basic_raw_socket] 
Determine whether the socket is at the out-of-band data mark. 


  bool ``[link boost_asio.reference.basic_raw_socket.at_mark.overload1 at_mark]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.at_mark.overload1 more...]]``

  bool ``[link boost_asio.reference.basic_raw_socket.at_mark.overload2 at_mark]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.at_mark.overload2 more...]]``


[section:overload1 basic_raw_socket::at_mark (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark() const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_raw_socket::at_mark (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark(
      boost::system::error_code & ec) const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark. 




[endsect]


[endsect]

[section:available basic_raw_socket::available]

[indexterm2 boost_asio.indexterm.basic_raw_socket.available..available..basic_raw_socket] 
Determine the number of bytes available for reading. 


  std::size_t ``[link boost_asio.reference.basic_raw_socket.available.overload1 available]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.available.overload1 more...]]``

  std::size_t ``[link boost_asio.reference.basic_raw_socket.available.overload2 available]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.available.overload2 more...]]``


[section:overload1 basic_raw_socket::available (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available() const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_raw_socket::available (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available(
      boost::system::error_code & ec) const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs. 




[endsect]


[endsect]

[section:basic_raw_socket basic_raw_socket::basic_raw_socket]

[indexterm2 boost_asio.indexterm.basic_raw_socket.basic_raw_socket..basic_raw_socket..basic_raw_socket] 
Construct a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] without opening it. 


  explicit ``[link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload1 basic_raw_socket]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload2 basic_raw_socket]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload2 more...]]``


Construct and open a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`]. 


  ``[link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload3 basic_raw_socket]``(
      const executor_type & ex,
      const protocol_type & protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload4 basic_raw_socket]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload4 more...]]``


Construct a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`], opening it and binding it to the given local endpoint. 


  ``[link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload5 basic_raw_socket]``(
      const executor_type & ex,
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload5 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload6 basic_raw_socket]``(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload6 more...]]``


Construct a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] on an existing native socket. 


  ``[link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload7 basic_raw_socket]``(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload7 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload8 basic_raw_socket]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload8 more...]]``


Move-construct a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] from another. 


  ``[link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload9 basic_raw_socket]``(
      basic_raw_socket && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload9 more...]]``


Move-construct a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload10 basic_raw_socket]``(
      basic_raw_socket< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.basic_raw_socket.overload10 more...]]``


[section:overload1 basic_raw_socket::basic_raw_socket (1 of 10 overloads)]


Construct a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] without opening it. 


  basic_raw_socket(
      const executor_type & ex);


This constructor creates a raw socket without opening it. The `open()` function must be called before data can be sent or received on the socket.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload2 basic_raw_socket::basic_raw_socket (2 of 10 overloads)]


Construct a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] without opening it. 


  template<
      typename ExecutionContext>
  basic_raw_socket(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a raw socket without opening it. The `open()` function must be called before data can be sent or received on the socket.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload3 basic_raw_socket::basic_raw_socket (3 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`]. 


  basic_raw_socket(
      const executor_type & ex,
      const protocol_type & protocol);


This constructor creates and opens a raw socket.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_raw_socket::basic_raw_socket (4 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`]. 


  template<
      typename ExecutionContext>
  basic_raw_socket(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates and opens a raw socket.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_raw_socket::basic_raw_socket (5 of 10 overloads)]


Construct a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`], opening it and binding it to the given local endpoint. 


  basic_raw_socket(
      const executor_type & ex,
      const endpoint_type & endpoint);


This constructor creates a raw socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the raw socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload6 basic_raw_socket::basic_raw_socket (6 of 10 overloads)]


Construct a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`], opening it and binding it to the given local endpoint. 


  template<
      typename ExecutionContext>
  basic_raw_socket(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a raw socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the raw socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload7 basic_raw_socket::basic_raw_socket (7 of 10 overloads)]


Construct a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] on an existing native socket. 


  basic_raw_socket(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_socket);


This constructor creates a raw socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][The new underlying socket implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 basic_raw_socket::basic_raw_socket (8 of 10 overloads)]


Construct a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] on an existing native socket. 


  template<
      typename ExecutionContext>
  basic_raw_socket(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a raw socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][The new underlying socket implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload9 basic_raw_socket::basic_raw_socket (9 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] from another. 


  basic_raw_socket(
      basic_raw_socket && other);


This constructor moves a raw socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_raw_socket(const executor_type&)` constructor. 




[endsect]



[section:overload10 basic_raw_socket::basic_raw_socket (10 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_raw_socket(
      basic_raw_socket< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);


This constructor moves a raw socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_raw_socket(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:bind basic_raw_socket::bind]

[indexterm2 boost_asio.indexterm.basic_raw_socket.bind..bind..basic_raw_socket] 
Bind the socket to the given local endpoint. 


  void ``[link boost_asio.reference.basic_raw_socket.bind.overload1 bind]``(
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.bind.overload1 more...]]``

  void ``[link boost_asio.reference.basic_raw_socket.bind.overload2 bind]``(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.bind.overload2 more...]]``


[section:overload1 basic_raw_socket::bind (1 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());
   socket.bind(boost::asio::ip::tcp::endpoint(
         boost::asio::ip::tcp::v4(), 12345));







[endsect]



[section:overload2 basic_raw_socket::bind (2 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());
   boost::system::error_code ec;
   socket.bind(boost::asio::ip::tcp::endpoint(
         boost::asio::ip::tcp::v4(), 12345), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:broadcast basic_raw_socket::broadcast]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.broadcast..broadcast..basic_raw_socket] 
Socket option to permit sending of broadcast messages. 


  typedef implementation_defined broadcast;



Implements the SOL\_SOCKET/SO\_BROADCAST socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:bytes_readable basic_raw_socket::bytes_readable]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.bytes_readable..bytes_readable..basic_raw_socket] 
IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::bytes_readable command(true);
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:cancel basic_raw_socket::cancel]

[indexterm2 boost_asio.indexterm.basic_raw_socket.cancel..cancel..basic_raw_socket] 
Cancel all asynchronous operations associated with the socket. 


  void ``[link boost_asio.reference.basic_raw_socket.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_raw_socket.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.cancel.overload2 more...]]``


[section:overload1 basic_raw_socket::cancel (1 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining BOOST\_ASIO\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]



[section:overload2 basic_raw_socket::cancel (2 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining BOOST\_ASIO\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]


[endsect]

[section:close basic_raw_socket::close]

[indexterm2 boost_asio.indexterm.basic_raw_socket.close..close..basic_raw_socket] 
Close the socket. 


  void ``[link boost_asio.reference.basic_raw_socket.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.close.overload1 more...]]``

  void ``[link boost_asio.reference.basic_raw_socket.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.close.overload2 more...]]``


[section:overload1 basic_raw_socket::close (1 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close();


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]



[section:overload2 basic_raw_socket::close (2 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close(
      boost::system::error_code & ec);


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.close(ec);
   if (ec)
   {
     // An error occurred.
   }





[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]


[endsect]

[section:connect basic_raw_socket::connect]

[indexterm2 boost_asio.indexterm.basic_raw_socket.connect..connect..basic_raw_socket] 
Connect the socket to the specified endpoint. 


  void ``[link boost_asio.reference.basic_raw_socket.connect.overload1 connect]``(
      const endpoint_type & peer_endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.connect.overload1 more...]]``

  void ``[link boost_asio.reference.basic_raw_socket.connect.overload2 connect]``(
      const endpoint_type & peer_endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.connect.overload2 more...]]``


[section:overload1 basic_raw_socket::connect (1 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.connect(endpoint);







[endsect]



[section:overload2 basic_raw_socket::connect (2 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint,
      boost::system::error_code & ec);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   boost::system::error_code ec;
   socket.connect(endpoint, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:debug basic_raw_socket::debug]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.debug..debug..basic_raw_socket] 
Socket option to enable socket-level debugging. 


  typedef implementation_defined debug;



Implements the SOL\_SOCKET/SO\_DEBUG socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:do_not_route basic_raw_socket::do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.do_not_route..do_not_route..basic_raw_socket] 
Socket option to prevent routing, use local interfaces only. 


  typedef implementation_defined do_not_route;



Implements the SOL\_SOCKET/SO\_DONTROUTE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:enable_connection_aborted basic_raw_socket::enable_connection_aborted]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.enable_connection_aborted..enable_connection_aborted..basic_raw_socket] 
Socket option to report aborted connections on accept. 


  typedef implementation_defined enable_connection_aborted;



Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:endpoint_type basic_raw_socket::endpoint_type]

[indexterm2 boost_asio.indexterm.basic_raw_socket.endpoint_type..endpoint_type..basic_raw_socket] 
The endpoint type. 


  typedef Protocol::endpoint endpoint_type;



[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:executor_type basic_raw_socket::executor_type]

[indexterm2 boost_asio.indexterm.basic_raw_socket.executor_type..executor_type..basic_raw_socket] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_raw_socket::get_executor]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.get_executor..get_executor..basic_raw_socket] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:get_option basic_raw_socket::get_option]

[indexterm2 boost_asio.indexterm.basic_raw_socket.get_option..get_option..basic_raw_socket] 
Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_raw_socket.get_option.overload1 get_option]``(
      GettableSocketOption & option) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.get_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_raw_socket.get_option.overload2 get_option]``(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.get_option.overload2 more...]]``


[section:overload1 basic_raw_socket::get_option (1 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[endsect]



[section:overload2 basic_raw_socket::get_option (2 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::keep_alive option;
   boost::system::error_code ec;
   socket.get_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }
   bool is_set = option.value();







[endsect]


[endsect]

[section:io_control basic_raw_socket::io_control]

[indexterm2 boost_asio.indexterm.basic_raw_socket.io_control..io_control..basic_raw_socket] 
Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_raw_socket.io_control.overload1 io_control]``(
      IoControlCommand & command);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.io_control.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_raw_socket.io_control.overload2 io_control]``(
      IoControlCommand & command,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.io_control.overload2 more...]]``


[section:overload1 basic_raw_socket::io_control (1 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::bytes_readable command;
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[endsect]



[section:overload2 basic_raw_socket::io_control (2 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command,
      boost::system::error_code & ec);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::bytes_readable command;
   boost::system::error_code ec;
   socket.io_control(command, ec);
   if (ec)
   {
     // An error occurred.
   }
   std::size_t bytes_readable = command.get();







[endsect]


[endsect]


[section:is_open basic_raw_socket::is_open]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.is_open..is_open..basic_raw_socket] 
Determine whether the socket is open. 


  bool is_open() const;



[endsect]



[section:keep_alive basic_raw_socket::keep_alive]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.keep_alive..keep_alive..basic_raw_socket] 
Socket option to send keep-alives. 


  typedef implementation_defined keep_alive;



Implements the SOL\_SOCKET/SO\_KEEPALIVE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:linger basic_raw_socket::linger]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.linger..linger..basic_raw_socket] 
Socket option to specify whether the socket lingers on close if unsent data is present. 


  typedef implementation_defined linger;



Implements the SOL\_SOCKET/SO\_LINGER socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option(true, 30);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option;
   socket.get_option(option);
   bool is_set = option.enabled();
   unsigned short timeout = option.timeout();







[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:local_endpoint basic_raw_socket::local_endpoint]

[indexterm2 boost_asio.indexterm.basic_raw_socket.local_endpoint..local_endpoint..basic_raw_socket] 
Get the local endpoint of the socket. 


  endpoint_type ``[link boost_asio.reference.basic_raw_socket.local_endpoint.overload1 local_endpoint]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.local_endpoint.overload1 more...]]``

  endpoint_type ``[link boost_asio.reference.basic_raw_socket.local_endpoint.overload2 local_endpoint]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.local_endpoint.overload2 more...]]``


[section:overload1 basic_raw_socket::local_endpoint (1 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint() const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Return Value]
      
An object that represents the local endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();







[endsect]



[section:overload2 basic_raw_socket::local_endpoint (2 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint(
      boost::system::error_code & ec) const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:lowest_layer basic_raw_socket::lowest_layer]

[indexterm2 boost_asio.indexterm.basic_raw_socket.lowest_layer..lowest_layer..basic_raw_socket] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.basic_raw_socket.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.basic_raw_socket.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.lowest_layer.overload2 more...]]``


[section:overload1 basic_raw_socket::lowest_layer (1 of 2 overloads)]


['Inherited from basic_socket.]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_socket `basic_socket`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 basic_raw_socket::lowest_layer (2 of 2 overloads)]


['Inherited from basic_socket.]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_socket `basic_socket`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type basic_raw_socket::lowest_layer_type]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.lowest_layer_type..lowest_layer_type..basic_raw_socket] 
A [link boost_asio.reference.basic_socket `basic_socket`] is always the lowest layer. 


  typedef basic_socket< Protocol, Executor > lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.basic_socket [*basic_socket]] [constructor]]
    [Construct a basic_socket without opening it. 
     [hr]
     Construct and open a basic_socket. 
     [hr]
     Construct a basic_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_socket on an existing native socket. 
     [hr]
     Move-construct a basic_socket from another. 
     [hr]
     Move-construct a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket from another. 
     [hr]
     Move-assign a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket._basic_socket [*~basic_socket]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_socket `basic_socket`] class template provides functionality that is common to both stream-oriented and datagram-oriented sockets.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:max_connections basic_raw_socket::max_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.max_connections..max_connections..basic_raw_socket] 
(Deprecated: Use max\_listen\_connections.) The maximum length of the queue of pending incoming connections. 


  static const int max_connections = implementation_defined;



[endsect]



[section:max_listen_connections basic_raw_socket::max_listen_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.max_listen_connections..max_listen_connections..basic_raw_socket] 
The maximum length of the queue of pending incoming connections. 


  static const int max_listen_connections = implementation_defined;



[endsect]



[section:message_do_not_route basic_raw_socket::message_do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.message_do_not_route..message_do_not_route..basic_raw_socket] 
Specify that the data should not be subject to routing. 


  static const int message_do_not_route = implementation_defined;



[endsect]



[section:message_end_of_record basic_raw_socket::message_end_of_record]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.message_end_of_record..message_end_of_record..basic_raw_socket] 
Specifies that the data marks the end of a record. 


  static const int message_end_of_record = implementation_defined;



[endsect]



[section:message_flags basic_raw_socket::message_flags]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.message_flags..message_flags..basic_raw_socket] 
Bitmask type for flags that can be passed to send and receive operations. 


  typedef int message_flags;



[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:message_out_of_band basic_raw_socket::message_out_of_band]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.message_out_of_band..message_out_of_band..basic_raw_socket] 
Process out-of-band data. 


  static const int message_out_of_band = implementation_defined;



[endsect]



[section:message_peek basic_raw_socket::message_peek]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.message_peek..message_peek..basic_raw_socket] 
Peek at incoming data without removing it from the input queue. 


  static const int message_peek = implementation_defined;



[endsect]



[section:native_handle basic_raw_socket::native_handle]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.native_handle..native_handle..basic_raw_socket] 
Get the native socket representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_raw_socket::native_handle_type]

[indexterm2 boost_asio.indexterm.basic_raw_socket.native_handle_type..native_handle_type..basic_raw_socket] 
The native representation of a socket. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:native_non_blocking basic_raw_socket::native_non_blocking]

[indexterm2 boost_asio.indexterm.basic_raw_socket.native_non_blocking..native_non_blocking..basic_raw_socket] 
Gets the non-blocking mode of the native socket implementation. 


  bool ``[link boost_asio.reference.basic_raw_socket.native_non_blocking.overload1 native_non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.native_non_blocking.overload1 more...]]``


Sets the non-blocking mode of the native socket implementation. 


  void ``[link boost_asio.reference.basic_raw_socket.native_non_blocking.overload2 native_non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.native_non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.basic_raw_socket.native_non_blocking.overload3 native_non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.native_non_blocking.overload3 more...]]``


[section:overload1 basic_raw_socket::native_non_blocking (1 of 3 overloads)]


['Inherited from basic_socket.]


Gets the non-blocking mode of the native socket implementation. 


  bool native_non_blocking() const;


This function is used to retrieve the non-blocking mode of the underlying native socket. This mode has no effect on the behaviour of the socket object's synchronous operations.


[heading Return Value]
      
`true` if the underlying socket is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).


[heading Remarks]
      
The current non-blocking mode is cached by the socket object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native socket.


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload2 basic_raw_socket::native_non_blocking (2 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload3 basic_raw_socket::native_non_blocking (3 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode,
      boost::system::error_code & ec);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]


[endsect]

[section:non_blocking basic_raw_socket::non_blocking]

[indexterm2 boost_asio.indexterm.basic_raw_socket.non_blocking..non_blocking..basic_raw_socket] 
Gets the non-blocking mode of the socket. 


  bool ``[link boost_asio.reference.basic_raw_socket.non_blocking.overload1 non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.non_blocking.overload1 more...]]``


Sets the non-blocking mode of the socket. 


  void ``[link boost_asio.reference.basic_raw_socket.non_blocking.overload2 non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.basic_raw_socket.non_blocking.overload3 non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.non_blocking.overload3 more...]]``


[section:overload1 basic_raw_socket::non_blocking (1 of 3 overloads)]


['Inherited from basic_socket.]


Gets the non-blocking mode of the socket. 


  bool non_blocking() const;



[heading Return Value]
      
`true` if the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload2 basic_raw_socket::non_blocking (2 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload3 basic_raw_socket::non_blocking (3 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode,
      boost::system::error_code & ec);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]


[endsect]

[section:open basic_raw_socket::open]

[indexterm2 boost_asio.indexterm.basic_raw_socket.open..open..basic_raw_socket] 
Open the socket using the specified protocol. 


  void ``[link boost_asio.reference.basic_raw_socket.open.overload1 open]``(
      const protocol_type & protocol = protocol_type());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.open.overload1 more...]]``

  void ``[link boost_asio.reference.basic_raw_socket.open.overload2 open]``(
      const protocol_type & protocol,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.open.overload2 more...]]``


[section:overload1 basic_raw_socket::open (1 of 2 overloads)]


['Inherited from basic_socket.]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol = protocol_type());


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());







[endsect]



[section:overload2 basic_raw_socket::open (2 of 2 overloads)]


['Inherited from basic_socket.]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol,
      boost::system::error_code & ec);


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying which protocol is to be used.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::system::error_code ec;
   socket.open(boost::asio::ip::tcp::v4(), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:operator_eq_ basic_raw_socket::operator=]

[indexterm2 boost_asio.indexterm.basic_raw_socket.operator_eq_..operator=..basic_raw_socket] 
Move-assign a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] from another. 


  basic_raw_socket & ``[link boost_asio.reference.basic_raw_socket.operator_eq_.overload1 operator=]``(
      basic_raw_socket && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.operator_eq_.overload1 more...]]``


Move-assign a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value, basic_raw_socket & >::type ``[link boost_asio.reference.basic_raw_socket.operator_eq_.overload2 operator=]``(
      basic_raw_socket< Protocol1, Executor1 > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.operator_eq_.overload2 more...]]``


[section:overload1 basic_raw_socket::operator= (1 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] from another. 


  basic_raw_socket & operator=(
      basic_raw_socket && other);


This assignment operator moves a raw socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_raw_socket(const executor_type&)` constructor. 




[endsect]



[section:overload2 basic_raw_socket::operator= (2 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value, basic_raw_socket & >::type operator=(
      basic_raw_socket< Protocol1, Executor1 > && other);


This assignment operator moves a raw socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_raw_socket(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:out_of_band_inline basic_raw_socket::out_of_band_inline]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.out_of_band_inline..out_of_band_inline..basic_raw_socket] 
Socket option for putting received out-of-band data inline. 


  typedef implementation_defined out_of_band_inline;



Implements the SOL\_SOCKET/SO\_OOBINLINE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option;
   socket.get_option(option);
   bool value = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol_type basic_raw_socket::protocol_type]

[indexterm2 boost_asio.indexterm.basic_raw_socket.protocol_type..protocol_type..basic_raw_socket] 
The protocol type. 


  typedef Protocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:receive basic_raw_socket::receive]

[indexterm2 boost_asio.indexterm.basic_raw_socket.receive..receive..basic_raw_socket] 
Receive some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_raw_socket.receive.overload1 receive]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.receive.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_raw_socket.receive.overload2 receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.receive.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_raw_socket.receive.overload3 receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.receive.overload3 more...]]``


[section:overload1 basic_raw_socket::receive (1 of 3 overloads)]


Receive some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive(
      const MutableBufferSequence & buffers);


This function is used to receive data on the raw socket. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The receive operation can only be used with a connected socket. Use the receive\_from function to receive data on an unconnected raw socket.


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.receive(boost::asio::buffer(data, size)); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_raw_socket::receive (2 of 3 overloads)]


Receive some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags);


This function is used to receive data on the raw socket. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[flags][Flags specifying how the receive call is to be made.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The receive operation can only be used with a connected socket. Use the receive\_from function to receive data on an unconnected raw socket. 




[endsect]



[section:overload3 basic_raw_socket::receive (3 of 3 overloads)]


Receive some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);


This function is used to receive data on the raw socket. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Remarks]
      
The receive operation can only be used with a connected socket. Use the receive\_from function to receive data on an unconnected raw socket. 




[endsect]


[endsect]


[section:receive_buffer_size basic_raw_socket::receive_buffer_size]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.receive_buffer_size..receive_buffer_size..basic_raw_socket] 
Socket option for the receive buffer size of a socket. 


  typedef implementation_defined receive_buffer_size;



Implements the SOL\_SOCKET/SO\_RCVBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:receive_from basic_raw_socket::receive_from]

[indexterm2 boost_asio.indexterm.basic_raw_socket.receive_from..receive_from..basic_raw_socket] 
Receive raw data with the endpoint of the sender. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_raw_socket.receive_from.overload1 receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.receive_from.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_raw_socket.receive_from.overload2 receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.receive_from.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_raw_socket.receive_from.overload3 receive_from]``(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.receive_from.overload3 more...]]``


[section:overload1 basic_raw_socket::receive_from (1 of 3 overloads)]


Receive raw data with the endpoint of the sender. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint);


This function is used to receive raw data. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the data.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::ip::udp::endpoint sender_endpoint;
   socket.receive_from(
       boost::asio::buffer(data, size), sender_endpoint);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_raw_socket::receive_from (2 of 3 overloads)]


Receive raw data with the endpoint of the sender. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags);


This function is used to receive raw data. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the data.]]

[[flags][Flags specifying how the receive call is to be made.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload3 basic_raw_socket::receive_from (3 of 3 overloads)]


Receive raw data with the endpoint of the sender. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive_from(
      const MutableBufferSequence & buffers,
      endpoint_type & sender_endpoint,
      socket_base::message_flags flags,
      boost::system::error_code & ec);


This function is used to receive raw data. The function call will block until data has been received successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[sender_endpoint][An endpoint object that receives the endpoint of the remote sender of the data.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes received. 




[endsect]


[endsect]


[section:receive_low_watermark basic_raw_socket::receive_low_watermark]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.receive_low_watermark..receive_low_watermark..basic_raw_socket] 
Socket option for the receive low watermark. 


  typedef implementation_defined receive_low_watermark;



Implements the SOL\_SOCKET/SO\_RCVLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:release basic_raw_socket::release]

[indexterm2 boost_asio.indexterm.basic_raw_socket.release..release..basic_raw_socket] 
Release ownership of the underlying native socket. 


  native_handle_type ``[link boost_asio.reference.basic_raw_socket.release.overload1 release]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.release.overload1 more...]]``

  native_handle_type ``[link boost_asio.reference.basic_raw_socket.release.overload2 release]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.release.overload2 more...]]``


[section:overload1 basic_raw_socket::release (1 of 2 overloads)]


['Inherited from basic_socket.]


Release ownership of the underlying native socket. 


  native_handle_type release();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]



[section:overload2 basic_raw_socket::release (2 of 2 overloads)]


['Inherited from basic_socket.]


Release ownership of the underlying native socket. 


  native_handle_type release(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]


[endsect]

[section:remote_endpoint basic_raw_socket::remote_endpoint]

[indexterm2 boost_asio.indexterm.basic_raw_socket.remote_endpoint..remote_endpoint..basic_raw_socket] 
Get the remote endpoint of the socket. 


  endpoint_type ``[link boost_asio.reference.basic_raw_socket.remote_endpoint.overload1 remote_endpoint]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.remote_endpoint.overload1 more...]]``

  endpoint_type ``[link boost_asio.reference.basic_raw_socket.remote_endpoint.overload2 remote_endpoint]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.remote_endpoint.overload2 more...]]``


[section:overload1 basic_raw_socket::remote_endpoint (1 of 2 overloads)]


['Inherited from basic_socket.]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint() const;


This function is used to obtain the remote endpoint of the socket.


[heading Return Value]
      
An object that represents the remote endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();







[endsect]



[section:overload2 basic_raw_socket::remote_endpoint (2 of 2 overloads)]


['Inherited from basic_socket.]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint(
      boost::system::error_code & ec) const;


This function is used to obtain the remote endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:reuse_address basic_raw_socket::reuse_address]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.reuse_address..reuse_address..basic_raw_socket] 
Socket option to allow the socket to be bound to an address that is already in use. 


  typedef implementation_defined reuse_address;



Implements the SOL\_SOCKET/SO\_REUSEADDR socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:send basic_raw_socket::send]

[indexterm2 boost_asio.indexterm.basic_raw_socket.send..send..basic_raw_socket] 
Send some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_raw_socket.send.overload1 send]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.send.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_raw_socket.send.overload2 send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.send.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_raw_socket.send.overload3 send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.send.overload3 more...]]``


[section:overload1 basic_raw_socket::send (1 of 3 overloads)]


Send some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send(
      const ConstBufferSequence & buffers);


This function is used to send data on the raw socket. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One ore more data buffers to be sent on the socket.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The send operation can only be used with a connected socket. Use the send\_to function to send data on an unconnected raw socket.


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.send(boost::asio::buffer(data, size)); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_raw_socket::send (2 of 3 overloads)]


Send some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags);


This function is used to send data on the raw socket. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One ore more data buffers to be sent on the socket.]]

[[flags][Flags specifying how the send call is to be made.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The send operation can only be used with a connected socket. Use the send\_to function to send data on an unconnected raw socket. 




[endsect]



[section:overload3 basic_raw_socket::send (3 of 3 overloads)]


Send some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);


This function is used to send data on the raw socket. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket.]]

[[flags][Flags specifying how the send call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Remarks]
      
The send operation can only be used with a connected socket. Use the send\_to function to send data on an unconnected raw socket. 




[endsect]


[endsect]


[section:send_buffer_size basic_raw_socket::send_buffer_size]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.send_buffer_size..send_buffer_size..basic_raw_socket] 
Socket option for the send buffer size of a socket. 


  typedef implementation_defined send_buffer_size;



Implements the SOL\_SOCKET/SO\_SNDBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:send_low_watermark basic_raw_socket::send_low_watermark]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.send_low_watermark..send_low_watermark..basic_raw_socket] 
Socket option for the send low watermark. 


  typedef implementation_defined send_low_watermark;



Implements the SOL\_SOCKET/SO\_SNDLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:send_to basic_raw_socket::send_to]

[indexterm2 boost_asio.indexterm.basic_raw_socket.send_to..send_to..basic_raw_socket] 
Send raw data to the specified endpoint. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_raw_socket.send_to.overload1 send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.send_to.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_raw_socket.send_to.overload2 send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.send_to.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_raw_socket.send_to.overload3 send_to]``(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.send_to.overload3 more...]]``


[section:overload1 basic_raw_socket::send_to (1 of 3 overloads)]


Send raw data to the specified endpoint. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination);


This function is used to send raw data to the specified remote endpoint. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint.]]

[[destination][The remote endpoint to which the data will be sent.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::ip::udp::endpoint destination(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.send_to(boost::asio::buffer(data, size), destination);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_raw_socket::send_to (2 of 3 overloads)]


Send raw data to the specified endpoint. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags);


This function is used to send raw data to the specified remote endpoint. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint.]]

[[destination][The remote endpoint to which the data will be sent.]]

[[flags][Flags specifying how the send call is to be made.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload3 basic_raw_socket::send_to (3 of 3 overloads)]


Send raw data to the specified endpoint. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send_to(
      const ConstBufferSequence & buffers,
      const endpoint_type & destination,
      socket_base::message_flags flags,
      boost::system::error_code & ec);


This function is used to send raw data to the specified remote endpoint. The function call will block until the data has been sent successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent to the remote endpoint.]]

[[destination][The remote endpoint to which the data will be sent.]]

[[flags][Flags specifying how the send call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes sent. 




[endsect]


[endsect]

[section:set_option basic_raw_socket::set_option]

[indexterm2 boost_asio.indexterm.basic_raw_socket.set_option..set_option..basic_raw_socket] 
Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void ``[link boost_asio.reference.basic_raw_socket.set_option.overload1 set_option]``(
      const SettableSocketOption & option);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.set_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void ``[link boost_asio.reference.basic_raw_socket.set_option.overload2 set_option]``(
      const SettableSocketOption & option,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.set_option.overload2 more...]]``


[section:overload1 basic_raw_socket::set_option (1 of 2 overloads)]


['Inherited from basic_socket.]


Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void set_option(
      const SettableSocketOption & option);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::no_delay option(true);
   socket.set_option(option);







[endsect]



[section:overload2 basic_raw_socket::set_option (2 of 2 overloads)]


['Inherited from basic_socket.]


Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void set_option(
      const SettableSocketOption & option,
      boost::system::error_code & ec);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::no_delay option(true);
   boost::system::error_code ec;
   socket.set_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:shutdown basic_raw_socket::shutdown]

[indexterm2 boost_asio.indexterm.basic_raw_socket.shutdown..shutdown..basic_raw_socket] 
Disable sends or receives on the socket. 


  void ``[link boost_asio.reference.basic_raw_socket.shutdown.overload1 shutdown]``(
      shutdown_type what);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.shutdown.overload1 more...]]``

  void ``[link boost_asio.reference.basic_raw_socket.shutdown.overload2 shutdown]``(
      shutdown_type what,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.shutdown.overload2 more...]]``


[section:overload1 basic_raw_socket::shutdown (1 of 2 overloads)]


['Inherited from basic_socket.]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);







[endsect]



[section:overload2 basic_raw_socket::shutdown (2 of 2 overloads)]


['Inherited from basic_socket.]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what,
      boost::system::error_code & ec);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:shutdown_type basic_raw_socket::shutdown_type]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.shutdown_type..shutdown_type..basic_raw_socket] 
Different ways a socket may be shutdown. 

  enum shutdown_type

[indexterm2 boost_asio.indexterm.basic_raw_socket.shutdown_type.shutdown_receive..shutdown_receive..basic_raw_socket]
[indexterm2 boost_asio.indexterm.basic_raw_socket.shutdown_type.shutdown_send..shutdown_send..basic_raw_socket]
[indexterm2 boost_asio.indexterm.basic_raw_socket.shutdown_type.shutdown_both..shutdown_both..basic_raw_socket]

[heading Values]
[variablelist

  [
    [shutdown_receive]
    [Shutdown the receive side of the socket. ]
  ]

  [
    [shutdown_send]
    [Shutdown the send side of the socket. ]
  ]

  [
    [shutdown_both]
    [Shutdown both send and receive on the socket. ]
  ]

]



[endsect]


[section:wait basic_raw_socket::wait]

[indexterm2 boost_asio.indexterm.basic_raw_socket.wait..wait..basic_raw_socket] 
Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void ``[link boost_asio.reference.basic_raw_socket.wait.overload1 wait]``(
      wait_type w);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.wait.overload1 more...]]``

  void ``[link boost_asio.reference.basic_raw_socket.wait.overload2 wait]``(
      wait_type w,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_raw_socket.wait.overload2 more...]]``


[section:overload1 basic_raw_socket::wait (1 of 2 overloads)]


['Inherited from basic_socket.]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.wait(boost::asio::ip::tcp::socket::wait_read);







[endsect]



[section:overload2 basic_raw_socket::wait (2 of 2 overloads)]


['Inherited from basic_socket.]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w,
      boost::system::error_code & ec);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);







[endsect]


[endsect]


[section:wait_type basic_raw_socket::wait_type]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_raw_socket.wait_type..wait_type..basic_raw_socket] 
Wait types. 

  enum wait_type

[indexterm2 boost_asio.indexterm.basic_raw_socket.wait_type.wait_read..wait_read..basic_raw_socket]
[indexterm2 boost_asio.indexterm.basic_raw_socket.wait_type.wait_write..wait_write..basic_raw_socket]
[indexterm2 boost_asio.indexterm.basic_raw_socket.wait_type.wait_error..wait_error..basic_raw_socket]

[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a socket to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a socket to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a socket to have error conditions pending. ]
  ]

]


For use with `basic_socket::wait()` and `basic_socket::async_wait()`. 


[endsect]



[section:_basic_raw_socket basic_raw_socket::~basic_raw_socket]

[indexterm2 boost_asio.indexterm.basic_raw_socket._basic_raw_socket..~basic_raw_socket..basic_raw_socket] 
Destroys the socket. 


  ~basic_raw_socket();


This function destroys the socket, cancelling any outstanding asynchronous operations associated with the socket as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_raw_socket__rebind_executor basic_raw_socket::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_raw_socket__rebind_executor..basic_raw_socket::rebind_executor]


Rebinds the socket type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_raw_socket__rebind_executor.other [*other]]]
    [The socket type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_raw_socket::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_raw_socket__rebind_executor.other..other..basic_raw_socket::rebind_executor] 
The socket type when rebound to the specified executor. 


  typedef basic_raw_socket< Protocol, Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_raw_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_raw_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_receive_from [*async_receive_from]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_send [*async_send]]]
    [Start an asynchronous send on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_send_to [*async_send_to]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.basic_raw_socket [*basic_raw_socket]] [constructor]]
    [Construct a basic_raw_socket without opening it. 
     [hr]
     Construct and open a basic_raw_socket. 
     [hr]
     Construct a basic_raw_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_raw_socket on an existing native socket. 
     [hr]
     Move-construct a basic_raw_socket from another. 
     [hr]
     Move-construct a basic_raw_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_raw_socket from another. 
     [hr]
     Move-assign a basic_raw_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.receive [*receive]]]
    [Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.receive_from [*receive_from]]]
    [Receive raw data with the endpoint of the sender. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.send [*send]]]
    [Send some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.send_to [*send_to]]]
    [Send raw data to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket._basic_raw_socket [*~basic_raw_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_raw_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] class template provides asynchronous and blocking raw-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `send_to`, `receive`, `receive_from`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe. 


[heading Requirements]

['Header: ][^boost/asio/basic_raw_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_readable_pipe basic_readable_pipe]

[indexterm1 boost_asio.indexterm.basic_readable_pipe..basic_readable_pipe]


Provides pipe functionality. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  class basic_readable_pipe


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_readable_pipe__rebind_executor [*rebind_executor]]]
    [Rebinds the pipe type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_readable_pipe.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_readable_pipe.lowest_layer_type [*lowest_layer_type]]]
    [A basic_readable_pipe is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_readable_pipe.native_handle_type [*native_handle_type]]]
    [The native representation of a pipe. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_readable_pipe.assign [*assign]]]
    [Assign an existing native pipe to the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.basic_readable_pipe [*basic_readable_pipe]] [constructor]]
    [Construct a basic_readable_pipe without opening it. 
     [hr]
     Construct a basic_readable_pipe on an existing native pipe. 
     [hr]
     Move-construct a basic_readable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.close [*close]]]
    [Close the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.is_open [*is_open]]]
    [Determine whether the pipe is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.native_handle [*native_handle]]]
    [Get the native pipe representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.operator_eq_ [*operator=]]]
    [Move-assign a basic_readable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.read_some [*read_some]]]
    [Read some data from the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe._basic_readable_pipe [*~basic_readable_pipe]] [destructor]]
    [Destroys the pipe. ]
  ]
  
]

The [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] class provides a wrapper over pipe functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/basic_readable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign basic_readable_pipe::assign]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.assign..assign..basic_readable_pipe] 
Assign an existing native pipe to the pipe. 


  void ``[link boost_asio.reference.basic_readable_pipe.assign.overload1 assign]``(
      const native_handle_type & native_pipe);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.assign.overload1 more...]]``

  void ``[link boost_asio.reference.basic_readable_pipe.assign.overload2 assign]``(
      const native_handle_type & native_pipe,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.assign.overload2 more...]]``


[section:overload1 basic_readable_pipe::assign (1 of 2 overloads)]


Assign an existing native pipe to the pipe. 


  void assign(
      const native_handle_type & native_pipe);



[endsect]



[section:overload2 basic_readable_pipe::assign (2 of 2 overloads)]


Assign an existing native pipe to the pipe. 


  void assign(
      const native_handle_type & native_pipe,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_read_some basic_readable_pipe::async_read_some]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.async_read_some..async_read_some..basic_readable_pipe] 
Start an asynchronous read. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_some(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data from the pipe. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes read.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The read operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.async_read `async_read`]  function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   basic_readable_pipe.async_read_some(
       boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]


[section:basic_readable_pipe basic_readable_pipe::basic_readable_pipe]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.basic_readable_pipe..basic_readable_pipe..basic_readable_pipe] 
Construct a [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] without opening it. 


  explicit ``[link boost_asio.reference.basic_readable_pipe.basic_readable_pipe.overload1 basic_readable_pipe]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.basic_readable_pipe.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_readable_pipe.basic_readable_pipe.overload2 basic_readable_pipe]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.basic_readable_pipe.overload2 more...]]``


Construct a [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] on an existing native pipe. 


  ``[link boost_asio.reference.basic_readable_pipe.basic_readable_pipe.overload3 basic_readable_pipe]``(
      const executor_type & ex,
      const native_handle_type & native_pipe);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.basic_readable_pipe.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_readable_pipe.basic_readable_pipe.overload4 basic_readable_pipe]``(
      ExecutionContext & context,
      const native_handle_type & native_pipe,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.basic_readable_pipe.overload4 more...]]``


Move-construct a [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] from another. 


  ``[link boost_asio.reference.basic_readable_pipe.basic_readable_pipe.overload5 basic_readable_pipe]``(
      basic_readable_pipe && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.basic_readable_pipe.overload5 more...]]``


[section:overload1 basic_readable_pipe::basic_readable_pipe (1 of 5 overloads)]


Construct a [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] without opening it. 


  basic_readable_pipe(
      const executor_type & ex);


This constructor creates a pipe without opening it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the pipe will use, by default, to dispatch handlers for any asynchronous operations performed on the pipe. ]]

]




[endsect]



[section:overload2 basic_readable_pipe::basic_readable_pipe (2 of 5 overloads)]


Construct a [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] without opening it. 


  template<
      typename ExecutionContext>
  basic_readable_pipe(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates a pipe without opening it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the pipe will use, by default, to dispatch handlers for any asynchronous operations performed on the pipe. ]]

]




[endsect]



[section:overload3 basic_readable_pipe::basic_readable_pipe (3 of 5 overloads)]


Construct a [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] on an existing native pipe. 


  basic_readable_pipe(
      const executor_type & ex,
      const native_handle_type & native_pipe);


This constructor creates a pipe object to hold an existing native pipe.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the pipe will use, by default, to dispatch handlers for any asynchronous operations performed on the pipe.]]

[[native_pipe][A native pipe.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_readable_pipe::basic_readable_pipe (4 of 5 overloads)]


Construct a [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] on an existing native pipe. 


  template<
      typename ExecutionContext>
  basic_readable_pipe(
      ExecutionContext & context,
      const native_handle_type & native_pipe,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a pipe object to hold an existing native pipe.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the pipe will use, by default, to dispatch handlers for any asynchronous operations performed on the pipe.]]

[[native_pipe][A native pipe.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_readable_pipe::basic_readable_pipe (5 of 5 overloads)]


Move-construct a [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] from another. 


  basic_readable_pipe(
      basic_readable_pipe && other);


This constructor moves a pipe from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_readable_pipe(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:cancel basic_readable_pipe::cancel]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.cancel..cancel..basic_readable_pipe] 
Cancel all asynchronous operations associated with the pipe. 


  void ``[link boost_asio.reference.basic_readable_pipe.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_readable_pipe.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.cancel.overload2 more...]]``


[section:overload1 basic_readable_pipe::cancel (1 of 2 overloads)]


Cancel all asynchronous operations associated with the pipe. 


  void cancel();


This function causes all outstanding asynchronous read operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_readable_pipe::cancel (2 of 2 overloads)]


Cancel all asynchronous operations associated with the pipe. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:close basic_readable_pipe::close]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.close..close..basic_readable_pipe] 
Close the pipe. 


  void ``[link boost_asio.reference.basic_readable_pipe.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.close.overload1 more...]]``

  void ``[link boost_asio.reference.basic_readable_pipe.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.close.overload2 more...]]``


[section:overload1 basic_readable_pipe::close (1 of 2 overloads)]


Close the pipe. 


  void close();


This function is used to close the pipe. Any asynchronous read operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_readable_pipe::close (2 of 2 overloads)]


Close the pipe. 


  void close(
      boost::system::error_code & ec);


This function is used to close the pipe. Any asynchronous read operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:executor_type basic_readable_pipe::executor_type]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.executor_type..executor_type..basic_readable_pipe] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_readable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_readable_pipe::get_executor]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.get_executor..get_executor..basic_readable_pipe] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:is_open basic_readable_pipe::is_open]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.is_open..is_open..basic_readable_pipe] 
Determine whether the pipe is open. 


  bool is_open() const;



[endsect]


[section:lowest_layer basic_readable_pipe::lowest_layer]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.lowest_layer..lowest_layer..basic_readable_pipe] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.basic_readable_pipe.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.basic_readable_pipe.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.lowest_layer.overload2 more...]]``


[section:overload1 basic_readable_pipe::lowest_layer (1 of 2 overloads)]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 basic_readable_pipe::lowest_layer (2 of 2 overloads)]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type basic_readable_pipe::lowest_layer_type]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.lowest_layer_type..lowest_layer_type..basic_readable_pipe] 
A [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] is always the lowest layer. 


  typedef basic_readable_pipe lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_readable_pipe__rebind_executor [*rebind_executor]]]
    [Rebinds the pipe type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_readable_pipe.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_readable_pipe.lowest_layer_type [*lowest_layer_type]]]
    [A basic_readable_pipe is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_readable_pipe.native_handle_type [*native_handle_type]]]
    [The native representation of a pipe. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_readable_pipe.assign [*assign]]]
    [Assign an existing native pipe to the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.basic_readable_pipe [*basic_readable_pipe]] [constructor]]
    [Construct a basic_readable_pipe without opening it. 
     [hr]
     Construct a basic_readable_pipe on an existing native pipe. 
     [hr]
     Move-construct a basic_readable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.close [*close]]]
    [Close the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.is_open [*is_open]]]
    [Determine whether the pipe is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.native_handle [*native_handle]]]
    [Get the native pipe representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.operator_eq_ [*operator=]]]
    [Move-assign a basic_readable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.read_some [*read_some]]]
    [Read some data from the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe._basic_readable_pipe [*~basic_readable_pipe]] [destructor]]
    [Destroys the pipe. ]
  ]
  
]

The [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] class provides a wrapper over pipe functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_readable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:native_handle basic_readable_pipe::native_handle]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.native_handle..native_handle..basic_readable_pipe] 
Get the native pipe representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the pipe. This is intended to allow access to native pipe functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_readable_pipe::native_handle_type]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.native_handle_type..native_handle_type..basic_readable_pipe] 
The native representation of a pipe. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/basic_readable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ basic_readable_pipe::operator=]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.operator_eq_..operator=..basic_readable_pipe] 
Move-assign a [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] from another. 


  basic_readable_pipe & operator=(
      basic_readable_pipe && other);


This assignment operator moves a pipe from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_readable_pipe(const executor_type&)` constructor. 




[endsect]


[section:read_some basic_readable_pipe::read_some]

[indexterm2 boost_asio.indexterm.basic_readable_pipe.read_some..read_some..basic_readable_pipe] 
Read some data from the pipe. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_readable_pipe.read_some.overload1 read_some]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.read_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_readable_pipe.read_some.overload2 read_some]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_readable_pipe.read_some.overload2 more...]]``


[section:overload1 basic_readable_pipe::read_some (1 of 2 overloads)]


Read some data from the pipe. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers);


This function is used to read data from the pipe. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes read.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   basic_readable_pipe.read_some(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_readable_pipe::read_some (2 of 2 overloads)]


Read some data from the pipe. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to read data from the pipe. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. Returns 0 if an error occurred.


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]


[endsect]


[section:_basic_readable_pipe basic_readable_pipe::~basic_readable_pipe]

[indexterm2 boost_asio.indexterm.basic_readable_pipe._basic_readable_pipe..~basic_readable_pipe..basic_readable_pipe] 
Destroys the pipe. 


  ~basic_readable_pipe();


This function destroys the pipe, cancelling any outstanding asynchronous wait operations associated with the pipe as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_readable_pipe__rebind_executor basic_readable_pipe::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_readable_pipe__rebind_executor..basic_readable_pipe::rebind_executor]


Rebinds the pipe type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_readable_pipe__rebind_executor.other [*other]]]
    [The pipe type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_readable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_readable_pipe::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_readable_pipe__rebind_executor.other..other..basic_readable_pipe::rebind_executor] 
The pipe type when rebound to the specified executor. 


  typedef basic_readable_pipe< Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_readable_pipe__rebind_executor [*rebind_executor]]]
    [Rebinds the pipe type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_readable_pipe.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_readable_pipe.lowest_layer_type [*lowest_layer_type]]]
    [A basic_readable_pipe is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_readable_pipe.native_handle_type [*native_handle_type]]]
    [The native representation of a pipe. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_readable_pipe.assign [*assign]]]
    [Assign an existing native pipe to the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.basic_readable_pipe [*basic_readable_pipe]] [constructor]]
    [Construct a basic_readable_pipe without opening it. 
     [hr]
     Construct a basic_readable_pipe on an existing native pipe. 
     [hr]
     Move-construct a basic_readable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.close [*close]]]
    [Close the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.is_open [*is_open]]]
    [Determine whether the pipe is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.native_handle [*native_handle]]]
    [Get the native pipe representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.operator_eq_ [*operator=]]]
    [Move-assign a basic_readable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.read_some [*read_some]]]
    [Read some data from the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe._basic_readable_pipe [*~basic_readable_pipe]] [destructor]]
    [Destroys the pipe. ]
  ]
  
]

The [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] class provides a wrapper over pipe functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_readable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_seq_packet_socket basic_seq_packet_socket]

[indexterm1 boost_asio.indexterm.basic_seq_packet_socket..basic_seq_packet_socket]


Provides sequenced packet socket functionality. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class basic_seq_packet_socket :
    public basic_socket< Protocol, Executor >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_seq_packet_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.async_send [*async_send]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket [*basic_seq_packet_socket]] [constructor]]
    [Construct a basic_seq_packet_socket without opening it. 
     [hr]
     Construct and open a basic_seq_packet_socket. 
     [hr]
     Construct a basic_seq_packet_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_seq_packet_socket on an existing native socket. 
     [hr]
     Move-construct a basic_seq_packet_socket from another. 
     [hr]
     Move-construct a basic_seq_packet_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_seq_packet_socket from another. 
     [hr]
     Move-assign a basic_seq_packet_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.receive [*receive]]]
    [Receive some data on the socket. 
     [hr]
     Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.send [*send]]]
    [Send some data on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket._basic_seq_packet_socket [*~basic_seq_packet_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] class template provides asynchronous and blocking sequenced packet socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `receive`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe. 

[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign basic_seq_packet_socket::assign]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.assign..assign..basic_seq_packet_socket] 
Assign an existing native socket to the socket. 


  void ``[link boost_asio.reference.basic_seq_packet_socket.assign.overload1 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.assign.overload1 more...]]``

  void ``[link boost_asio.reference.basic_seq_packet_socket.assign.overload2 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.assign.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::assign (1 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket);



[endsect]



[section:overload2 basic_seq_packet_socket::assign (2 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_connect basic_seq_packet_socket::async_connect]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.async_connect..async_connect..basic_seq_packet_socket] 
Start an asynchronous connect. 


  template<
      typename ``[link boost_asio.reference.ConnectHandler ConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      const endpoint_type & peer_endpoint,
      ConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.]]

[[handler][The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void connect_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Connect succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.async_connect(endpoint, connect_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:async_receive basic_seq_packet_socket::async_receive]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.async_receive..async_receive..basic_seq_packet_socket] 
Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_seq_packet_socket.async_receive.overload1 async_receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags & out_flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.async_receive.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_seq_packet_socket.async_receive.overload2 async_receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags in_flags,
      socket_base::message_flags & out_flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.async_receive.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::async_receive (1 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags & out_flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive data from the sequenced packet socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[out_flags][Once the asynchronous operation completes, contains flags associated with the received data. For example, if the `socket_base::message_end_of_record` bit is set then the received data marks the end of a record. The caller must guarantee that the referenced variable remains valid until the handler is called.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_receive(boost::asio::buffer(data, size), out_flags, handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_seq_packet_socket::async_receive (2 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags in_flags,
      socket_base::message_flags & out_flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive data from the sequenced data socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[in_flags][Flags specifying how the receive call is to be made.]]

[[out_flags][Once the asynchronous operation completes, contains flags associated with the received data. For example, if the `socket_base::message_end_of_record` bit is set then the received data marks the end of a record. The caller must guarantee that the referenced variable remains valid until the handler is called.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_receive(
       boost::asio::buffer(data, size),
       0, out_flags, handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]


[section:async_send basic_seq_packet_socket::async_send]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.async_send..async_send..basic_seq_packet_socket] 
Start an asynchronous send. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously send data on the sequenced packet socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the send call is to be made.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_send(boost::asio::buffer(data, size), 0, handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:async_wait basic_seq_packet_socket::async_wait]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.async_wait..async_wait..basic_seq_packet_socket] 
Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  template<
      typename ``[link boost_asio.reference.WaitHandler WaitHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_wait(
      wait_type w,
      WaitHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to perform an asynchronous wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[handler][The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void wait_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Wait succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:at_mark basic_seq_packet_socket::at_mark]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.at_mark..at_mark..basic_seq_packet_socket] 
Determine whether the socket is at the out-of-band data mark. 


  bool ``[link boost_asio.reference.basic_seq_packet_socket.at_mark.overload1 at_mark]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.at_mark.overload1 more...]]``

  bool ``[link boost_asio.reference.basic_seq_packet_socket.at_mark.overload2 at_mark]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.at_mark.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::at_mark (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark() const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_seq_packet_socket::at_mark (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark(
      boost::system::error_code & ec) const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark. 




[endsect]


[endsect]

[section:available basic_seq_packet_socket::available]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.available..available..basic_seq_packet_socket] 
Determine the number of bytes available for reading. 


  std::size_t ``[link boost_asio.reference.basic_seq_packet_socket.available.overload1 available]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.available.overload1 more...]]``

  std::size_t ``[link boost_asio.reference.basic_seq_packet_socket.available.overload2 available]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.available.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::available (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available() const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_seq_packet_socket::available (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available(
      boost::system::error_code & ec) const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs. 




[endsect]


[endsect]

[section:basic_seq_packet_socket basic_seq_packet_socket::basic_seq_packet_socket]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.basic_seq_packet_socket..basic_seq_packet_socket..basic_seq_packet_socket] 
Construct a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] without opening it. 


  explicit ``[link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload1 basic_seq_packet_socket]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload2 basic_seq_packet_socket]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload2 more...]]``


Construct and open a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`]. 


  ``[link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload3 basic_seq_packet_socket]``(
      const executor_type & ex,
      const protocol_type & protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload4 basic_seq_packet_socket]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload4 more...]]``


Construct a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`], opening it and binding it to the given local endpoint. 


  ``[link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload5 basic_seq_packet_socket]``(
      const executor_type & ex,
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload5 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload6 basic_seq_packet_socket]``(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload6 more...]]``


Construct a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] on an existing native socket. 


  ``[link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload7 basic_seq_packet_socket]``(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload7 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload8 basic_seq_packet_socket]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload8 more...]]``


Move-construct a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] from another. 


  ``[link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload9 basic_seq_packet_socket]``(
      basic_seq_packet_socket && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload9 more...]]``


Move-construct a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload10 basic_seq_packet_socket]``(
      basic_seq_packet_socket< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket.overload10 more...]]``


[section:overload1 basic_seq_packet_socket::basic_seq_packet_socket (1 of 10 overloads)]


Construct a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] without opening it. 


  basic_seq_packet_socket(
      const executor_type & ex);


This constructor creates a sequenced packet socket without opening it. The socket needs to be opened and then connected or accepted before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload2 basic_seq_packet_socket::basic_seq_packet_socket (2 of 10 overloads)]


Construct a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] without opening it. 


  template<
      typename ExecutionContext>
  basic_seq_packet_socket(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a sequenced packet socket without opening it. The socket needs to be opened and then connected or accepted before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload3 basic_seq_packet_socket::basic_seq_packet_socket (3 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`]. 


  basic_seq_packet_socket(
      const executor_type & ex,
      const protocol_type & protocol);


This constructor creates and opens a sequenced\_packet socket. The socket needs to be connected or accepted before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_seq_packet_socket::basic_seq_packet_socket (4 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`]. 


  template<
      typename ExecutionContext>
  basic_seq_packet_socket(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates and opens a sequenced\_packet socket. The socket needs to be connected or accepted before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_seq_packet_socket::basic_seq_packet_socket (5 of 10 overloads)]


Construct a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`], opening it and binding it to the given local endpoint. 


  basic_seq_packet_socket(
      const executor_type & ex,
      const endpoint_type & endpoint);


This constructor creates a sequenced packet socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the sequenced packet socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload6 basic_seq_packet_socket::basic_seq_packet_socket (6 of 10 overloads)]


Construct a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`], opening it and binding it to the given local endpoint. 


  template<
      typename ExecutionContext>
  basic_seq_packet_socket(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a sequenced packet socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the sequenced packet socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload7 basic_seq_packet_socket::basic_seq_packet_socket (7 of 10 overloads)]


Construct a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] on an existing native socket. 


  basic_seq_packet_socket(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_socket);


This constructor creates a sequenced packet socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][The new underlying socket implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 basic_seq_packet_socket::basic_seq_packet_socket (8 of 10 overloads)]


Construct a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] on an existing native socket. 


  template<
      typename ExecutionContext>
  basic_seq_packet_socket(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a sequenced packet socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][The new underlying socket implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload9 basic_seq_packet_socket::basic_seq_packet_socket (9 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] from another. 


  basic_seq_packet_socket(
      basic_seq_packet_socket && other);


This constructor moves a sequenced packet socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_seq_packet_socket(const executor_type&)` constructor. 




[endsect]



[section:overload10 basic_seq_packet_socket::basic_seq_packet_socket (10 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_seq_packet_socket(
      basic_seq_packet_socket< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);


This constructor moves a sequenced packet socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_seq_packet_socket(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:bind basic_seq_packet_socket::bind]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.bind..bind..basic_seq_packet_socket] 
Bind the socket to the given local endpoint. 


  void ``[link boost_asio.reference.basic_seq_packet_socket.bind.overload1 bind]``(
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.bind.overload1 more...]]``

  void ``[link boost_asio.reference.basic_seq_packet_socket.bind.overload2 bind]``(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.bind.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::bind (1 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());
   socket.bind(boost::asio::ip::tcp::endpoint(
         boost::asio::ip::tcp::v4(), 12345));







[endsect]



[section:overload2 basic_seq_packet_socket::bind (2 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());
   boost::system::error_code ec;
   socket.bind(boost::asio::ip::tcp::endpoint(
         boost::asio::ip::tcp::v4(), 12345), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:broadcast basic_seq_packet_socket::broadcast]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.broadcast..broadcast..basic_seq_packet_socket] 
Socket option to permit sending of broadcast messages. 


  typedef implementation_defined broadcast;



Implements the SOL\_SOCKET/SO\_BROADCAST socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:bytes_readable basic_seq_packet_socket::bytes_readable]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.bytes_readable..bytes_readable..basic_seq_packet_socket] 
IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::bytes_readable command(true);
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:cancel basic_seq_packet_socket::cancel]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.cancel..cancel..basic_seq_packet_socket] 
Cancel all asynchronous operations associated with the socket. 


  void ``[link boost_asio.reference.basic_seq_packet_socket.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_seq_packet_socket.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.cancel.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::cancel (1 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining BOOST\_ASIO\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]



[section:overload2 basic_seq_packet_socket::cancel (2 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining BOOST\_ASIO\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]


[endsect]

[section:close basic_seq_packet_socket::close]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.close..close..basic_seq_packet_socket] 
Close the socket. 


  void ``[link boost_asio.reference.basic_seq_packet_socket.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.close.overload1 more...]]``

  void ``[link boost_asio.reference.basic_seq_packet_socket.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.close.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::close (1 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close();


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]



[section:overload2 basic_seq_packet_socket::close (2 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close(
      boost::system::error_code & ec);


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.close(ec);
   if (ec)
   {
     // An error occurred.
   }





[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]


[endsect]

[section:connect basic_seq_packet_socket::connect]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.connect..connect..basic_seq_packet_socket] 
Connect the socket to the specified endpoint. 


  void ``[link boost_asio.reference.basic_seq_packet_socket.connect.overload1 connect]``(
      const endpoint_type & peer_endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.connect.overload1 more...]]``

  void ``[link boost_asio.reference.basic_seq_packet_socket.connect.overload2 connect]``(
      const endpoint_type & peer_endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.connect.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::connect (1 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.connect(endpoint);







[endsect]



[section:overload2 basic_seq_packet_socket::connect (2 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint,
      boost::system::error_code & ec);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   boost::system::error_code ec;
   socket.connect(endpoint, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:debug basic_seq_packet_socket::debug]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.debug..debug..basic_seq_packet_socket] 
Socket option to enable socket-level debugging. 


  typedef implementation_defined debug;



Implements the SOL\_SOCKET/SO\_DEBUG socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:do_not_route basic_seq_packet_socket::do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.do_not_route..do_not_route..basic_seq_packet_socket] 
Socket option to prevent routing, use local interfaces only. 


  typedef implementation_defined do_not_route;



Implements the SOL\_SOCKET/SO\_DONTROUTE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:enable_connection_aborted basic_seq_packet_socket::enable_connection_aborted]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.enable_connection_aborted..enable_connection_aborted..basic_seq_packet_socket] 
Socket option to report aborted connections on accept. 


  typedef implementation_defined enable_connection_aborted;



Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:endpoint_type basic_seq_packet_socket::endpoint_type]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.endpoint_type..endpoint_type..basic_seq_packet_socket] 
The endpoint type. 


  typedef Protocol::endpoint endpoint_type;



[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:executor_type basic_seq_packet_socket::executor_type]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.executor_type..executor_type..basic_seq_packet_socket] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_seq_packet_socket::get_executor]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.get_executor..get_executor..basic_seq_packet_socket] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:get_option basic_seq_packet_socket::get_option]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.get_option..get_option..basic_seq_packet_socket] 
Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_seq_packet_socket.get_option.overload1 get_option]``(
      GettableSocketOption & option) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.get_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_seq_packet_socket.get_option.overload2 get_option]``(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.get_option.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::get_option (1 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[endsect]



[section:overload2 basic_seq_packet_socket::get_option (2 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::keep_alive option;
   boost::system::error_code ec;
   socket.get_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }
   bool is_set = option.value();







[endsect]


[endsect]

[section:io_control basic_seq_packet_socket::io_control]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.io_control..io_control..basic_seq_packet_socket] 
Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_seq_packet_socket.io_control.overload1 io_control]``(
      IoControlCommand & command);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.io_control.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_seq_packet_socket.io_control.overload2 io_control]``(
      IoControlCommand & command,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.io_control.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::io_control (1 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::bytes_readable command;
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[endsect]



[section:overload2 basic_seq_packet_socket::io_control (2 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command,
      boost::system::error_code & ec);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::bytes_readable command;
   boost::system::error_code ec;
   socket.io_control(command, ec);
   if (ec)
   {
     // An error occurred.
   }
   std::size_t bytes_readable = command.get();







[endsect]


[endsect]


[section:is_open basic_seq_packet_socket::is_open]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.is_open..is_open..basic_seq_packet_socket] 
Determine whether the socket is open. 


  bool is_open() const;



[endsect]



[section:keep_alive basic_seq_packet_socket::keep_alive]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.keep_alive..keep_alive..basic_seq_packet_socket] 
Socket option to send keep-alives. 


  typedef implementation_defined keep_alive;



Implements the SOL\_SOCKET/SO\_KEEPALIVE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:linger basic_seq_packet_socket::linger]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.linger..linger..basic_seq_packet_socket] 
Socket option to specify whether the socket lingers on close if unsent data is present. 


  typedef implementation_defined linger;



Implements the SOL\_SOCKET/SO\_LINGER socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option(true, 30);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option;
   socket.get_option(option);
   bool is_set = option.enabled();
   unsigned short timeout = option.timeout();







[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:local_endpoint basic_seq_packet_socket::local_endpoint]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.local_endpoint..local_endpoint..basic_seq_packet_socket] 
Get the local endpoint of the socket. 


  endpoint_type ``[link boost_asio.reference.basic_seq_packet_socket.local_endpoint.overload1 local_endpoint]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.local_endpoint.overload1 more...]]``

  endpoint_type ``[link boost_asio.reference.basic_seq_packet_socket.local_endpoint.overload2 local_endpoint]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.local_endpoint.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::local_endpoint (1 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint() const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Return Value]
      
An object that represents the local endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();







[endsect]



[section:overload2 basic_seq_packet_socket::local_endpoint (2 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint(
      boost::system::error_code & ec) const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:lowest_layer basic_seq_packet_socket::lowest_layer]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.lowest_layer..lowest_layer..basic_seq_packet_socket] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.basic_seq_packet_socket.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.basic_seq_packet_socket.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.lowest_layer.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::lowest_layer (1 of 2 overloads)]


['Inherited from basic_socket.]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_socket `basic_socket`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 basic_seq_packet_socket::lowest_layer (2 of 2 overloads)]


['Inherited from basic_socket.]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_socket `basic_socket`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type basic_seq_packet_socket::lowest_layer_type]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.lowest_layer_type..lowest_layer_type..basic_seq_packet_socket] 
A [link boost_asio.reference.basic_socket `basic_socket`] is always the lowest layer. 


  typedef basic_socket< Protocol, Executor > lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.basic_socket [*basic_socket]] [constructor]]
    [Construct a basic_socket without opening it. 
     [hr]
     Construct and open a basic_socket. 
     [hr]
     Construct a basic_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_socket on an existing native socket. 
     [hr]
     Move-construct a basic_socket from another. 
     [hr]
     Move-construct a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket from another. 
     [hr]
     Move-assign a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket._basic_socket [*~basic_socket]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_socket `basic_socket`] class template provides functionality that is common to both stream-oriented and datagram-oriented sockets.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:max_connections basic_seq_packet_socket::max_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.max_connections..max_connections..basic_seq_packet_socket] 
(Deprecated: Use max\_listen\_connections.) The maximum length of the queue of pending incoming connections. 


  static const int max_connections = implementation_defined;



[endsect]



[section:max_listen_connections basic_seq_packet_socket::max_listen_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.max_listen_connections..max_listen_connections..basic_seq_packet_socket] 
The maximum length of the queue of pending incoming connections. 


  static const int max_listen_connections = implementation_defined;



[endsect]



[section:message_do_not_route basic_seq_packet_socket::message_do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.message_do_not_route..message_do_not_route..basic_seq_packet_socket] 
Specify that the data should not be subject to routing. 


  static const int message_do_not_route = implementation_defined;



[endsect]



[section:message_end_of_record basic_seq_packet_socket::message_end_of_record]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.message_end_of_record..message_end_of_record..basic_seq_packet_socket] 
Specifies that the data marks the end of a record. 


  static const int message_end_of_record = implementation_defined;



[endsect]



[section:message_flags basic_seq_packet_socket::message_flags]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.message_flags..message_flags..basic_seq_packet_socket] 
Bitmask type for flags that can be passed to send and receive operations. 


  typedef int message_flags;



[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:message_out_of_band basic_seq_packet_socket::message_out_of_band]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.message_out_of_band..message_out_of_band..basic_seq_packet_socket] 
Process out-of-band data. 


  static const int message_out_of_band = implementation_defined;



[endsect]



[section:message_peek basic_seq_packet_socket::message_peek]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.message_peek..message_peek..basic_seq_packet_socket] 
Peek at incoming data without removing it from the input queue. 


  static const int message_peek = implementation_defined;



[endsect]



[section:native_handle basic_seq_packet_socket::native_handle]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.native_handle..native_handle..basic_seq_packet_socket] 
Get the native socket representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_seq_packet_socket::native_handle_type]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.native_handle_type..native_handle_type..basic_seq_packet_socket] 
The native representation of a socket. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:native_non_blocking basic_seq_packet_socket::native_non_blocking]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.native_non_blocking..native_non_blocking..basic_seq_packet_socket] 
Gets the non-blocking mode of the native socket implementation. 


  bool ``[link boost_asio.reference.basic_seq_packet_socket.native_non_blocking.overload1 native_non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.native_non_blocking.overload1 more...]]``


Sets the non-blocking mode of the native socket implementation. 


  void ``[link boost_asio.reference.basic_seq_packet_socket.native_non_blocking.overload2 native_non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.native_non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.basic_seq_packet_socket.native_non_blocking.overload3 native_non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.native_non_blocking.overload3 more...]]``


[section:overload1 basic_seq_packet_socket::native_non_blocking (1 of 3 overloads)]


['Inherited from basic_socket.]


Gets the non-blocking mode of the native socket implementation. 


  bool native_non_blocking() const;


This function is used to retrieve the non-blocking mode of the underlying native socket. This mode has no effect on the behaviour of the socket object's synchronous operations.


[heading Return Value]
      
`true` if the underlying socket is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).


[heading Remarks]
      
The current non-blocking mode is cached by the socket object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native socket.


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload2 basic_seq_packet_socket::native_non_blocking (2 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload3 basic_seq_packet_socket::native_non_blocking (3 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode,
      boost::system::error_code & ec);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]


[endsect]

[section:non_blocking basic_seq_packet_socket::non_blocking]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.non_blocking..non_blocking..basic_seq_packet_socket] 
Gets the non-blocking mode of the socket. 


  bool ``[link boost_asio.reference.basic_seq_packet_socket.non_blocking.overload1 non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.non_blocking.overload1 more...]]``


Sets the non-blocking mode of the socket. 


  void ``[link boost_asio.reference.basic_seq_packet_socket.non_blocking.overload2 non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.basic_seq_packet_socket.non_blocking.overload3 non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.non_blocking.overload3 more...]]``


[section:overload1 basic_seq_packet_socket::non_blocking (1 of 3 overloads)]


['Inherited from basic_socket.]


Gets the non-blocking mode of the socket. 


  bool non_blocking() const;



[heading Return Value]
      
`true` if the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload2 basic_seq_packet_socket::non_blocking (2 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload3 basic_seq_packet_socket::non_blocking (3 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode,
      boost::system::error_code & ec);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]


[endsect]

[section:open basic_seq_packet_socket::open]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.open..open..basic_seq_packet_socket] 
Open the socket using the specified protocol. 


  void ``[link boost_asio.reference.basic_seq_packet_socket.open.overload1 open]``(
      const protocol_type & protocol = protocol_type());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.open.overload1 more...]]``

  void ``[link boost_asio.reference.basic_seq_packet_socket.open.overload2 open]``(
      const protocol_type & protocol,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.open.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::open (1 of 2 overloads)]


['Inherited from basic_socket.]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol = protocol_type());


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());







[endsect]



[section:overload2 basic_seq_packet_socket::open (2 of 2 overloads)]


['Inherited from basic_socket.]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol,
      boost::system::error_code & ec);


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying which protocol is to be used.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::system::error_code ec;
   socket.open(boost::asio::ip::tcp::v4(), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:operator_eq_ basic_seq_packet_socket::operator=]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.operator_eq_..operator=..basic_seq_packet_socket] 
Move-assign a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] from another. 


  basic_seq_packet_socket & ``[link boost_asio.reference.basic_seq_packet_socket.operator_eq_.overload1 operator=]``(
      basic_seq_packet_socket && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.operator_eq_.overload1 more...]]``


Move-assign a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value, basic_seq_packet_socket & >::type ``[link boost_asio.reference.basic_seq_packet_socket.operator_eq_.overload2 operator=]``(
      basic_seq_packet_socket< Protocol1, Executor1 > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.operator_eq_.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::operator= (1 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] from another. 


  basic_seq_packet_socket & operator=(
      basic_seq_packet_socket && other);


This assignment operator moves a sequenced packet socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_seq_packet_socket(const executor_type&)` constructor. 




[endsect]



[section:overload2 basic_seq_packet_socket::operator= (2 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value, basic_seq_packet_socket & >::type operator=(
      basic_seq_packet_socket< Protocol1, Executor1 > && other);


This assignment operator moves a sequenced packet socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_seq_packet_socket(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:out_of_band_inline basic_seq_packet_socket::out_of_band_inline]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.out_of_band_inline..out_of_band_inline..basic_seq_packet_socket] 
Socket option for putting received out-of-band data inline. 


  typedef implementation_defined out_of_band_inline;



Implements the SOL\_SOCKET/SO\_OOBINLINE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option;
   socket.get_option(option);
   bool value = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol_type basic_seq_packet_socket::protocol_type]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.protocol_type..protocol_type..basic_seq_packet_socket] 
The protocol type. 


  typedef Protocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:receive basic_seq_packet_socket::receive]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.receive..receive..basic_seq_packet_socket] 
Receive some data on the socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_seq_packet_socket.receive.overload1 receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags & out_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.receive.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_seq_packet_socket.receive.overload2 receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags in_flags,
      socket_base::message_flags & out_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.receive.overload2 more...]]``


Receive some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_seq_packet_socket.receive.overload3 receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags in_flags,
      socket_base::message_flags & out_flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.receive.overload3 more...]]``


[section:overload1 basic_seq_packet_socket::receive (1 of 3 overloads)]


Receive some data on the socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags & out_flags);


This function is used to receive data on the sequenced packet socket. The function call will block until data has been received successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[out_flags][After the receive call completes, contains flags associated with the received data. For example, if the `socket_base::message_end_of_record` bit is set then the received data marks the end of a record.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.receive(boost::asio::buffer(data, size), out_flags);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_seq_packet_socket::receive (2 of 3 overloads)]


Receive some data on the socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags in_flags,
      socket_base::message_flags & out_flags);


This function is used to receive data on the sequenced packet socket. The function call will block until data has been received successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[in_flags][Flags specifying how the receive call is to be made.]]

[[out_flags][After the receive call completes, contains flags associated with the received data. For example, if the `socket_base::message_end_of_record` bit is set then the received data marks the end of a record.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The receive operation may not receive all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.receive(boost::asio::buffer(data, size), 0, out_flags);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload3 basic_seq_packet_socket::receive (3 of 3 overloads)]


Receive some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags in_flags,
      socket_base::message_flags & out_flags,
      boost::system::error_code & ec);


This function is used to receive data on the sequenced packet socket. The function call will block until data has been received successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[in_flags][Flags specifying how the receive call is to be made.]]

[[out_flags][After the receive call completes, contains flags associated with the received data. For example, if the `socket_base::message_end_of_record` bit is set then the received data marks the end of a record.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes received. Returns 0 if an error occurred.


[heading Remarks]
      
The receive operation may not receive all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]


[endsect]


[section:receive_buffer_size basic_seq_packet_socket::receive_buffer_size]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.receive_buffer_size..receive_buffer_size..basic_seq_packet_socket] 
Socket option for the receive buffer size of a socket. 


  typedef implementation_defined receive_buffer_size;



Implements the SOL\_SOCKET/SO\_RCVBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:receive_low_watermark basic_seq_packet_socket::receive_low_watermark]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.receive_low_watermark..receive_low_watermark..basic_seq_packet_socket] 
Socket option for the receive low watermark. 


  typedef implementation_defined receive_low_watermark;



Implements the SOL\_SOCKET/SO\_RCVLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:release basic_seq_packet_socket::release]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.release..release..basic_seq_packet_socket] 
Release ownership of the underlying native socket. 


  native_handle_type ``[link boost_asio.reference.basic_seq_packet_socket.release.overload1 release]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.release.overload1 more...]]``

  native_handle_type ``[link boost_asio.reference.basic_seq_packet_socket.release.overload2 release]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.release.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::release (1 of 2 overloads)]


['Inherited from basic_socket.]


Release ownership of the underlying native socket. 


  native_handle_type release();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]



[section:overload2 basic_seq_packet_socket::release (2 of 2 overloads)]


['Inherited from basic_socket.]


Release ownership of the underlying native socket. 


  native_handle_type release(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]


[endsect]

[section:remote_endpoint basic_seq_packet_socket::remote_endpoint]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.remote_endpoint..remote_endpoint..basic_seq_packet_socket] 
Get the remote endpoint of the socket. 


  endpoint_type ``[link boost_asio.reference.basic_seq_packet_socket.remote_endpoint.overload1 remote_endpoint]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.remote_endpoint.overload1 more...]]``

  endpoint_type ``[link boost_asio.reference.basic_seq_packet_socket.remote_endpoint.overload2 remote_endpoint]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.remote_endpoint.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::remote_endpoint (1 of 2 overloads)]


['Inherited from basic_socket.]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint() const;


This function is used to obtain the remote endpoint of the socket.


[heading Return Value]
      
An object that represents the remote endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();







[endsect]



[section:overload2 basic_seq_packet_socket::remote_endpoint (2 of 2 overloads)]


['Inherited from basic_socket.]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint(
      boost::system::error_code & ec) const;


This function is used to obtain the remote endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:reuse_address basic_seq_packet_socket::reuse_address]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.reuse_address..reuse_address..basic_seq_packet_socket] 
Socket option to allow the socket to be bound to an address that is already in use. 


  typedef implementation_defined reuse_address;



Implements the SOL\_SOCKET/SO\_REUSEADDR socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:send basic_seq_packet_socket::send]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.send..send..basic_seq_packet_socket] 
Send some data on the socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_seq_packet_socket.send.overload1 send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.send.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_seq_packet_socket.send.overload2 send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.send.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::send (1 of 2 overloads)]


Send some data on the socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags);


This function is used to send data on the sequenced packet socket. The function call will block until the data has been sent successfully, or an until error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket.]]

[[flags][Flags specifying how the send call is to be made.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.send(boost::asio::buffer(data, size), 0);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_seq_packet_socket::send (2 of 2 overloads)]


Send some data on the socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);


This function is used to send data on the sequenced packet socket. The function call will block the data has been sent successfully, or an until error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket.]]

[[flags][Flags specifying how the send call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes sent. Returns 0 if an error occurred.


[heading Remarks]
      
The send operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]


[endsect]


[section:send_buffer_size basic_seq_packet_socket::send_buffer_size]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.send_buffer_size..send_buffer_size..basic_seq_packet_socket] 
Socket option for the send buffer size of a socket. 


  typedef implementation_defined send_buffer_size;



Implements the SOL\_SOCKET/SO\_SNDBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:send_low_watermark basic_seq_packet_socket::send_low_watermark]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.send_low_watermark..send_low_watermark..basic_seq_packet_socket] 
Socket option for the send low watermark. 


  typedef implementation_defined send_low_watermark;



Implements the SOL\_SOCKET/SO\_SNDLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:set_option basic_seq_packet_socket::set_option]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.set_option..set_option..basic_seq_packet_socket] 
Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void ``[link boost_asio.reference.basic_seq_packet_socket.set_option.overload1 set_option]``(
      const SettableSocketOption & option);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.set_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void ``[link boost_asio.reference.basic_seq_packet_socket.set_option.overload2 set_option]``(
      const SettableSocketOption & option,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.set_option.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::set_option (1 of 2 overloads)]


['Inherited from basic_socket.]


Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void set_option(
      const SettableSocketOption & option);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::no_delay option(true);
   socket.set_option(option);







[endsect]



[section:overload2 basic_seq_packet_socket::set_option (2 of 2 overloads)]


['Inherited from basic_socket.]


Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void set_option(
      const SettableSocketOption & option,
      boost::system::error_code & ec);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::no_delay option(true);
   boost::system::error_code ec;
   socket.set_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:shutdown basic_seq_packet_socket::shutdown]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.shutdown..shutdown..basic_seq_packet_socket] 
Disable sends or receives on the socket. 


  void ``[link boost_asio.reference.basic_seq_packet_socket.shutdown.overload1 shutdown]``(
      shutdown_type what);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.shutdown.overload1 more...]]``

  void ``[link boost_asio.reference.basic_seq_packet_socket.shutdown.overload2 shutdown]``(
      shutdown_type what,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.shutdown.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::shutdown (1 of 2 overloads)]


['Inherited from basic_socket.]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);







[endsect]



[section:overload2 basic_seq_packet_socket::shutdown (2 of 2 overloads)]


['Inherited from basic_socket.]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what,
      boost::system::error_code & ec);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:shutdown_type basic_seq_packet_socket::shutdown_type]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.shutdown_type..shutdown_type..basic_seq_packet_socket] 
Different ways a socket may be shutdown. 

  enum shutdown_type

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.shutdown_type.shutdown_receive..shutdown_receive..basic_seq_packet_socket]
[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.shutdown_type.shutdown_send..shutdown_send..basic_seq_packet_socket]
[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.shutdown_type.shutdown_both..shutdown_both..basic_seq_packet_socket]

[heading Values]
[variablelist

  [
    [shutdown_receive]
    [Shutdown the receive side of the socket. ]
  ]

  [
    [shutdown_send]
    [Shutdown the send side of the socket. ]
  ]

  [
    [shutdown_both]
    [Shutdown both send and receive on the socket. ]
  ]

]



[endsect]


[section:wait basic_seq_packet_socket::wait]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.wait..wait..basic_seq_packet_socket] 
Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void ``[link boost_asio.reference.basic_seq_packet_socket.wait.overload1 wait]``(
      wait_type w);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.wait.overload1 more...]]``

  void ``[link boost_asio.reference.basic_seq_packet_socket.wait.overload2 wait]``(
      wait_type w,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_seq_packet_socket.wait.overload2 more...]]``


[section:overload1 basic_seq_packet_socket::wait (1 of 2 overloads)]


['Inherited from basic_socket.]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.wait(boost::asio::ip::tcp::socket::wait_read);







[endsect]



[section:overload2 basic_seq_packet_socket::wait (2 of 2 overloads)]


['Inherited from basic_socket.]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w,
      boost::system::error_code & ec);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);







[endsect]


[endsect]


[section:wait_type basic_seq_packet_socket::wait_type]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.wait_type..wait_type..basic_seq_packet_socket] 
Wait types. 

  enum wait_type

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.wait_type.wait_read..wait_read..basic_seq_packet_socket]
[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.wait_type.wait_write..wait_write..basic_seq_packet_socket]
[indexterm2 boost_asio.indexterm.basic_seq_packet_socket.wait_type.wait_error..wait_error..basic_seq_packet_socket]

[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a socket to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a socket to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a socket to have error conditions pending. ]
  ]

]


For use with `basic_socket::wait()` and `basic_socket::async_wait()`. 


[endsect]



[section:_basic_seq_packet_socket basic_seq_packet_socket::~basic_seq_packet_socket]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket._basic_seq_packet_socket..~basic_seq_packet_socket..basic_seq_packet_socket] 
Destroys the socket. 


  ~basic_seq_packet_socket();


This function destroys the socket, cancelling any outstanding asynchronous operations associated with the socket as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_seq_packet_socket__rebind_executor basic_seq_packet_socket::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_seq_packet_socket__rebind_executor..basic_seq_packet_socket::rebind_executor]


Rebinds the socket type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_seq_packet_socket__rebind_executor.other [*other]]]
    [The socket type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_seq_packet_socket::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_seq_packet_socket__rebind_executor.other..other..basic_seq_packet_socket::rebind_executor] 
The socket type when rebound to the specified executor. 


  typedef basic_seq_packet_socket< Protocol, Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_seq_packet_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.async_send [*async_send]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket [*basic_seq_packet_socket]] [constructor]]
    [Construct a basic_seq_packet_socket without opening it. 
     [hr]
     Construct and open a basic_seq_packet_socket. 
     [hr]
     Construct a basic_seq_packet_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_seq_packet_socket on an existing native socket. 
     [hr]
     Move-construct a basic_seq_packet_socket from another. 
     [hr]
     Move-construct a basic_seq_packet_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_seq_packet_socket from another. 
     [hr]
     Move-assign a basic_seq_packet_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.receive [*receive]]]
    [Receive some data on the socket. 
     [hr]
     Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.send [*send]]]
    [Send some data on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket._basic_seq_packet_socket [*~basic_seq_packet_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] class template provides asynchronous and blocking sequenced packet socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `receive`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe. 


[heading Requirements]

['Header: ][^boost/asio/basic_seq_packet_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_serial_port basic_serial_port]

[indexterm1 boost_asio.indexterm.basic_serial_port..basic_serial_port]


Provides serial port functionality. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  class basic_serial_port :
    public serial_port_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_serial_port__rebind_executor [*rebind_executor]]]
    [Rebinds the serial port type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_serial_port.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_serial_port.lowest_layer_type [*lowest_layer_type]]]
    [A basic_basic_serial_port is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_serial_port.native_handle_type [*native_handle_type]]]
    [The native representation of a serial port. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_serial_port.assign [*assign]]]
    [Assign an existing native serial port to the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.basic_serial_port [*basic_serial_port]] [constructor]]
    [Construct a basic_serial_port without opening it. 
     [hr]
     Construct and open a basic_serial_port. 
     [hr]
     Construct a basic_serial_port on an existing native serial port. 
     [hr]
     Move-construct a basic_serial_port from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.close [*close]]]
    [Close the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.get_option [*get_option]]]
    [Get an option from the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.is_open [*is_open]]]
    [Determine whether the serial port is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.native_handle [*native_handle]]]
    [Get the native serial port representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.open [*open]]]
    [Open the serial port using the specified device name. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.operator_eq_ [*operator=]]]
    [Move-assign a basic_serial_port from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.read_some [*read_some]]]
    [Read some data from the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.send_break [*send_break]]]
    [Send a break sequence to the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.set_option [*set_option]]]
    [Set an option on the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.write_some [*write_some]]]
    [Write some data to the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port._basic_serial_port [*~basic_serial_port]] [destructor]]
    [Destroys the serial port. ]
  ]
  
]

The [link boost_asio.reference.basic_serial_port `basic_serial_port`] class provides a wrapper over serial port functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/basic_serial_port.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign basic_serial_port::assign]

[indexterm2 boost_asio.indexterm.basic_serial_port.assign..assign..basic_serial_port] 
Assign an existing native serial port to the serial port. 


  void ``[link boost_asio.reference.basic_serial_port.assign.overload1 assign]``(
      const native_handle_type & native_serial_port);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.assign.overload1 more...]]``

  void ``[link boost_asio.reference.basic_serial_port.assign.overload2 assign]``(
      const native_handle_type & native_serial_port,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.assign.overload2 more...]]``


[section:overload1 basic_serial_port::assign (1 of 2 overloads)]


Assign an existing native serial port to the serial port. 


  void assign(
      const native_handle_type & native_serial_port);



[endsect]



[section:overload2 basic_serial_port::assign (2 of 2 overloads)]


Assign an existing native serial port to the serial port. 


  void assign(
      const native_handle_type & native_serial_port,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_read_some basic_serial_port::async_read_some]

[indexterm2 boost_asio.indexterm.basic_serial_port.async_read_some..async_read_some..basic_serial_port] 
Start an asynchronous read. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_some(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data from the serial port. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes read.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The read operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.async_read `async_read`]  function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   basic_serial_port.async_read_some(
       boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:async_write_some basic_serial_port::async_write_some]

[indexterm2 boost_asio.indexterm.basic_serial_port.async_write_some..async_write_some..basic_serial_port] 
Start an asynchronous write. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_some(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write data to the serial port. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the serial port. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes written.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The write operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.async_write `async_write`]  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   basic_serial_port.async_write_some(
       boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]


[section:basic_serial_port basic_serial_port::basic_serial_port]

[indexterm2 boost_asio.indexterm.basic_serial_port.basic_serial_port..basic_serial_port..basic_serial_port] 
Construct a [link boost_asio.reference.basic_serial_port `basic_serial_port`] without opening it. 


  explicit ``[link boost_asio.reference.basic_serial_port.basic_serial_port.overload1 basic_serial_port]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.basic_serial_port.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_serial_port.basic_serial_port.overload2 basic_serial_port]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.basic_serial_port.overload2 more...]]``


Construct and open a [link boost_asio.reference.basic_serial_port `basic_serial_port`]. 


  ``[link boost_asio.reference.basic_serial_port.basic_serial_port.overload3 basic_serial_port]``(
      const executor_type & ex,
      const char * device);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.basic_serial_port.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_serial_port.basic_serial_port.overload4 basic_serial_port]``(
      ExecutionContext & context,
      const char * device,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.basic_serial_port.overload4 more...]]``

  ``[link boost_asio.reference.basic_serial_port.basic_serial_port.overload5 basic_serial_port]``(
      const executor_type & ex,
      const std::string & device);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.basic_serial_port.overload5 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_serial_port.basic_serial_port.overload6 basic_serial_port]``(
      ExecutionContext & context,
      const std::string & device,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.basic_serial_port.overload6 more...]]``


Construct a [link boost_asio.reference.basic_serial_port `basic_serial_port`] on an existing native serial port. 


  ``[link boost_asio.reference.basic_serial_port.basic_serial_port.overload7 basic_serial_port]``(
      const executor_type & ex,
      const native_handle_type & native_serial_port);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.basic_serial_port.overload7 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_serial_port.basic_serial_port.overload8 basic_serial_port]``(
      ExecutionContext & context,
      const native_handle_type & native_serial_port,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.basic_serial_port.overload8 more...]]``


Move-construct a [link boost_asio.reference.basic_serial_port `basic_serial_port`] from another. 


  ``[link boost_asio.reference.basic_serial_port.basic_serial_port.overload9 basic_serial_port]``(
      basic_serial_port && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.basic_serial_port.overload9 more...]]``


[section:overload1 basic_serial_port::basic_serial_port (1 of 9 overloads)]


Construct a [link boost_asio.reference.basic_serial_port `basic_serial_port`] without opening it. 


  basic_serial_port(
      const executor_type & ex);


This constructor creates a serial port without opening it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the serial port will use, by default, to dispatch handlers for any asynchronous operations performed on the serial port. ]]

]




[endsect]



[section:overload2 basic_serial_port::basic_serial_port (2 of 9 overloads)]


Construct a [link boost_asio.reference.basic_serial_port `basic_serial_port`] without opening it. 


  template<
      typename ExecutionContext>
  basic_serial_port(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates a serial port without opening it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the serial port will use, by default, to dispatch handlers for any asynchronous operations performed on the serial port. ]]

]




[endsect]



[section:overload3 basic_serial_port::basic_serial_port (3 of 9 overloads)]


Construct and open a [link boost_asio.reference.basic_serial_port `basic_serial_port`]. 


  basic_serial_port(
      const executor_type & ex,
      const char * device);


This constructor creates and opens a serial port for the specified device name.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the serial port will use, by default, to dispatch handlers for any asynchronous operations performed on the serial port.]]

[[device][The platform-specific device name for this serial port. ]]

]




[endsect]



[section:overload4 basic_serial_port::basic_serial_port (4 of 9 overloads)]


Construct and open a [link boost_asio.reference.basic_serial_port `basic_serial_port`]. 


  template<
      typename ExecutionContext>
  basic_serial_port(
      ExecutionContext & context,
      const char * device,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates and opens a serial port for the specified device name.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the serial port will use, by default, to dispatch handlers for any asynchronous operations performed on the serial port.]]

[[device][The platform-specific device name for this serial port. ]]

]




[endsect]



[section:overload5 basic_serial_port::basic_serial_port (5 of 9 overloads)]


Construct and open a [link boost_asio.reference.basic_serial_port `basic_serial_port`]. 


  basic_serial_port(
      const executor_type & ex,
      const std::string & device);


This constructor creates and opens a serial port for the specified device name.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the serial port will use, by default, to dispatch handlers for any asynchronous operations performed on the serial port.]]

[[device][The platform-specific device name for this serial port. ]]

]




[endsect]



[section:overload6 basic_serial_port::basic_serial_port (6 of 9 overloads)]


Construct and open a [link boost_asio.reference.basic_serial_port `basic_serial_port`]. 


  template<
      typename ExecutionContext>
  basic_serial_port(
      ExecutionContext & context,
      const std::string & device,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates and opens a serial port for the specified device name.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the serial port will use, by default, to dispatch handlers for any asynchronous operations performed on the serial port.]]

[[device][The platform-specific device name for this serial port. ]]

]




[endsect]



[section:overload7 basic_serial_port::basic_serial_port (7 of 9 overloads)]


Construct a [link boost_asio.reference.basic_serial_port `basic_serial_port`] on an existing native serial port. 


  basic_serial_port(
      const executor_type & ex,
      const native_handle_type & native_serial_port);


This constructor creates a serial port object to hold an existing native serial port.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the serial port will use, by default, to dispatch handlers for any asynchronous operations performed on the serial port.]]

[[native_serial_port][A native serial port.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 basic_serial_port::basic_serial_port (8 of 9 overloads)]


Construct a [link boost_asio.reference.basic_serial_port `basic_serial_port`] on an existing native serial port. 


  template<
      typename ExecutionContext>
  basic_serial_port(
      ExecutionContext & context,
      const native_handle_type & native_serial_port,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a serial port object to hold an existing native serial port.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the serial port will use, by default, to dispatch handlers for any asynchronous operations performed on the serial port.]]

[[native_serial_port][A native serial port.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload9 basic_serial_port::basic_serial_port (9 of 9 overloads)]


Move-construct a [link boost_asio.reference.basic_serial_port `basic_serial_port`] from another. 


  basic_serial_port(
      basic_serial_port && other);


This constructor moves a serial port from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_serial_port `basic_serial_port`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_serial_port(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:cancel basic_serial_port::cancel]

[indexterm2 boost_asio.indexterm.basic_serial_port.cancel..cancel..basic_serial_port] 
Cancel all asynchronous operations associated with the serial port. 


  void ``[link boost_asio.reference.basic_serial_port.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_serial_port.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.cancel.overload2 more...]]``


[section:overload1 basic_serial_port::cancel (1 of 2 overloads)]


Cancel all asynchronous operations associated with the serial port. 


  void cancel();


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_serial_port::cancel (2 of 2 overloads)]


Cancel all asynchronous operations associated with the serial port. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:close basic_serial_port::close]

[indexterm2 boost_asio.indexterm.basic_serial_port.close..close..basic_serial_port] 
Close the serial port. 


  void ``[link boost_asio.reference.basic_serial_port.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.close.overload1 more...]]``

  void ``[link boost_asio.reference.basic_serial_port.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.close.overload2 more...]]``


[section:overload1 basic_serial_port::close (1 of 2 overloads)]


Close the serial port. 


  void close();


This function is used to close the serial port. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_serial_port::close (2 of 2 overloads)]


Close the serial port. 


  void close(
      boost::system::error_code & ec);


This function is used to close the serial port. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:executor_type basic_serial_port::executor_type]

[indexterm2 boost_asio.indexterm.basic_serial_port.executor_type..executor_type..basic_serial_port] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_serial_port.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_serial_port::get_executor]

[indexterm2 boost_asio.indexterm.basic_serial_port.get_executor..get_executor..basic_serial_port] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:get_option basic_serial_port::get_option]

[indexterm2 boost_asio.indexterm.basic_serial_port.get_option..get_option..basic_serial_port] 
Get an option from the serial port. 


  template<
      typename ``[link boost_asio.reference.GettableSerialPortOption GettableSerialPortOption]``>
  void ``[link boost_asio.reference.basic_serial_port.get_option.overload1 get_option]``(
      GettableSerialPortOption & option) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.get_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.GettableSerialPortOption GettableSerialPortOption]``>
  void ``[link boost_asio.reference.basic_serial_port.get_option.overload2 get_option]``(
      GettableSerialPortOption & option,
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.get_option.overload2 more...]]``


[section:overload1 basic_serial_port::get_option (1 of 2 overloads)]


Get an option from the serial port. 


  template<
      typename ``[link boost_asio.reference.GettableSerialPortOption GettableSerialPortOption]``>
  void get_option(
      GettableSerialPortOption & option) const;


This function is used to get the current value of an option on the serial port.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the serial port.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]





[endsect]



[section:overload2 basic_serial_port::get_option (2 of 2 overloads)]


Get an option from the serial port. 


  template<
      typename ``[link boost_asio.reference.GettableSerialPortOption GettableSerialPortOption]``>
  void get_option(
      GettableSerialPortOption & option,
      boost::system::error_code & ec) const;


This function is used to get the current value of an option on the serial port.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the serial port.]]

[[ec][Set to indicate what error occurred, if any.]]

]





[endsect]


[endsect]


[section:is_open basic_serial_port::is_open]

[indexterm2 boost_asio.indexterm.basic_serial_port.is_open..is_open..basic_serial_port] 
Determine whether the serial port is open. 


  bool is_open() const;



[endsect]


[section:lowest_layer basic_serial_port::lowest_layer]

[indexterm2 boost_asio.indexterm.basic_serial_port.lowest_layer..lowest_layer..basic_serial_port] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.basic_serial_port.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.basic_serial_port.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.lowest_layer.overload2 more...]]``


[section:overload1 basic_serial_port::lowest_layer (1 of 2 overloads)]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_serial_port `basic_serial_port`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 basic_serial_port::lowest_layer (2 of 2 overloads)]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_serial_port `basic_serial_port`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type basic_serial_port::lowest_layer_type]

[indexterm2 boost_asio.indexterm.basic_serial_port.lowest_layer_type..lowest_layer_type..basic_serial_port] 
A basic\_basic\_serial\_port is always the lowest layer. 


  typedef basic_serial_port lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_serial_port__rebind_executor [*rebind_executor]]]
    [Rebinds the serial port type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_serial_port.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_serial_port.lowest_layer_type [*lowest_layer_type]]]
    [A basic_basic_serial_port is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_serial_port.native_handle_type [*native_handle_type]]]
    [The native representation of a serial port. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_serial_port.assign [*assign]]]
    [Assign an existing native serial port to the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.basic_serial_port [*basic_serial_port]] [constructor]]
    [Construct a basic_serial_port without opening it. 
     [hr]
     Construct and open a basic_serial_port. 
     [hr]
     Construct a basic_serial_port on an existing native serial port. 
     [hr]
     Move-construct a basic_serial_port from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.close [*close]]]
    [Close the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.get_option [*get_option]]]
    [Get an option from the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.is_open [*is_open]]]
    [Determine whether the serial port is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.native_handle [*native_handle]]]
    [Get the native serial port representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.open [*open]]]
    [Open the serial port using the specified device name. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.operator_eq_ [*operator=]]]
    [Move-assign a basic_serial_port from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.read_some [*read_some]]]
    [Read some data from the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.send_break [*send_break]]]
    [Send a break sequence to the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.set_option [*set_option]]]
    [Set an option on the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.write_some [*write_some]]]
    [Write some data to the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port._basic_serial_port [*~basic_serial_port]] [destructor]]
    [Destroys the serial port. ]
  ]
  
]

The [link boost_asio.reference.basic_serial_port `basic_serial_port`] class provides a wrapper over serial port functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_serial_port.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:native_handle basic_serial_port::native_handle]

[indexterm2 boost_asio.indexterm.basic_serial_port.native_handle..native_handle..basic_serial_port] 
Get the native serial port representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the serial port. This is intended to allow access to native serial port functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_serial_port::native_handle_type]

[indexterm2 boost_asio.indexterm.basic_serial_port.native_handle_type..native_handle_type..basic_serial_port] 
The native representation of a serial port. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/basic_serial_port.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:open basic_serial_port::open]

[indexterm2 boost_asio.indexterm.basic_serial_port.open..open..basic_serial_port] 
Open the serial port using the specified device name. 


  void ``[link boost_asio.reference.basic_serial_port.open.overload1 open]``(
      const std::string & device);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.open.overload1 more...]]``

  void ``[link boost_asio.reference.basic_serial_port.open.overload2 open]``(
      const std::string & device,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.open.overload2 more...]]``


[section:overload1 basic_serial_port::open (1 of 2 overloads)]


Open the serial port using the specified device name. 


  void open(
      const std::string & device);


This function opens the serial port for the specified device name.


[heading Parameters]
    

[variablelist
  
[[device][The platform-specific device name.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_serial_port::open (2 of 2 overloads)]


Open the serial port using the specified device name. 


  void open(
      const std::string & device,
      boost::system::error_code & ec);


This function opens the serial port using the given platform-specific device name.


[heading Parameters]
    

[variablelist
  
[[device][The platform-specific device name.]]

[[ec][Set the indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:operator_eq_ basic_serial_port::operator=]

[indexterm2 boost_asio.indexterm.basic_serial_port.operator_eq_..operator=..basic_serial_port] 
Move-assign a [link boost_asio.reference.basic_serial_port `basic_serial_port`] from another. 


  basic_serial_port & operator=(
      basic_serial_port && other);


This assignment operator moves a serial port from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_serial_port `basic_serial_port`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_serial_port(const executor_type&)` constructor. 




[endsect]


[section:read_some basic_serial_port::read_some]

[indexterm2 boost_asio.indexterm.basic_serial_port.read_some..read_some..basic_serial_port] 
Read some data from the serial port. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_serial_port.read_some.overload1 read_some]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.read_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_serial_port.read_some.overload2 read_some]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.read_some.overload2 more...]]``


[section:overload1 basic_serial_port::read_some (1 of 2 overloads)]


Read some data from the serial port. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers);


This function is used to read data from the serial port. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes read.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   basic_serial_port.read_some(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_serial_port::read_some (2 of 2 overloads)]


Read some data from the serial port. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to read data from the serial port. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. Returns 0 if an error occurred.


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]


[endsect]

[section:send_break basic_serial_port::send_break]

[indexterm2 boost_asio.indexterm.basic_serial_port.send_break..send_break..basic_serial_port] 
Send a break sequence to the serial port. 


  void ``[link boost_asio.reference.basic_serial_port.send_break.overload1 send_break]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.send_break.overload1 more...]]``

  void ``[link boost_asio.reference.basic_serial_port.send_break.overload2 send_break]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.send_break.overload2 more...]]``


[section:overload1 basic_serial_port::send_break (1 of 2 overloads)]


Send a break sequence to the serial port. 


  void send_break();


This function causes a break sequence of platform-specific duration to be sent out the serial port.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_serial_port::send_break (2 of 2 overloads)]


Send a break sequence to the serial port. 


  void send_break(
      boost::system::error_code & ec);


This function causes a break sequence of platform-specific duration to be sent out the serial port.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:set_option basic_serial_port::set_option]

[indexterm2 boost_asio.indexterm.basic_serial_port.set_option..set_option..basic_serial_port] 
Set an option on the serial port. 


  template<
      typename ``[link boost_asio.reference.SettableSerialPortOption SettableSerialPortOption]``>
  void ``[link boost_asio.reference.basic_serial_port.set_option.overload1 set_option]``(
      const SettableSerialPortOption & option);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.set_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.SettableSerialPortOption SettableSerialPortOption]``>
  void ``[link boost_asio.reference.basic_serial_port.set_option.overload2 set_option]``(
      const SettableSerialPortOption & option,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.set_option.overload2 more...]]``


[section:overload1 basic_serial_port::set_option (1 of 2 overloads)]


Set an option on the serial port. 


  template<
      typename ``[link boost_asio.reference.SettableSerialPortOption SettableSerialPortOption]``>
  void set_option(
      const SettableSerialPortOption & option);


This function is used to set an option on the serial port.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be set on the serial port.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]





[endsect]



[section:overload2 basic_serial_port::set_option (2 of 2 overloads)]


Set an option on the serial port. 


  template<
      typename ``[link boost_asio.reference.SettableSerialPortOption SettableSerialPortOption]``>
  void set_option(
      const SettableSerialPortOption & option,
      boost::system::error_code & ec);


This function is used to set an option on the serial port.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be set on the serial port.]]

[[ec][Set to indicate what error occurred, if any.]]

]





[endsect]


[endsect]

[section:write_some basic_serial_port::write_some]

[indexterm2 boost_asio.indexterm.basic_serial_port.write_some..write_some..basic_serial_port] 
Write some data to the serial port. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_serial_port.write_some.overload1 write_some]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.write_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_serial_port.write_some.overload2 write_some]``(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_serial_port.write_some.overload2 more...]]``


[section:overload1 basic_serial_port::write_some (1 of 2 overloads)]


Write some data to the serial port. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers);


This function is used to write data to the serial port. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the serial port.]]

]


[heading Return Value]
      
The number of bytes written.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   basic_serial_port.write_some(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_serial_port::write_some (2 of 2 overloads)]


Write some data to the serial port. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to write data to the serial port. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the serial port.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. Returns 0 if an error occurred.


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]


[endsect]


[section:_basic_serial_port basic_serial_port::~basic_serial_port]

[indexterm2 boost_asio.indexterm.basic_serial_port._basic_serial_port..~basic_serial_port..basic_serial_port] 
Destroys the serial port. 


  ~basic_serial_port();


This function destroys the serial port, cancelling any outstanding asynchronous wait operations associated with the serial port as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_serial_port__rebind_executor basic_serial_port::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_serial_port__rebind_executor..basic_serial_port::rebind_executor]


Rebinds the serial port type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_serial_port__rebind_executor.other [*other]]]
    [The serial port type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_serial_port.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_serial_port::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_serial_port__rebind_executor.other..other..basic_serial_port::rebind_executor] 
The serial port type when rebound to the specified executor. 


  typedef basic_serial_port< Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_serial_port__rebind_executor [*rebind_executor]]]
    [Rebinds the serial port type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_serial_port.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_serial_port.lowest_layer_type [*lowest_layer_type]]]
    [A basic_basic_serial_port is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_serial_port.native_handle_type [*native_handle_type]]]
    [The native representation of a serial port. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_serial_port.assign [*assign]]]
    [Assign an existing native serial port to the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.basic_serial_port [*basic_serial_port]] [constructor]]
    [Construct a basic_serial_port without opening it. 
     [hr]
     Construct and open a basic_serial_port. 
     [hr]
     Construct a basic_serial_port on an existing native serial port. 
     [hr]
     Move-construct a basic_serial_port from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.close [*close]]]
    [Close the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.get_option [*get_option]]]
    [Get an option from the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.is_open [*is_open]]]
    [Determine whether the serial port is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.native_handle [*native_handle]]]
    [Get the native serial port representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.open [*open]]]
    [Open the serial port using the specified device name. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.operator_eq_ [*operator=]]]
    [Move-assign a basic_serial_port from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.read_some [*read_some]]]
    [Read some data from the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.send_break [*send_break]]]
    [Send a break sequence to the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.set_option [*set_option]]]
    [Set an option on the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.write_some [*write_some]]]
    [Write some data to the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port._basic_serial_port [*~basic_serial_port]] [destructor]]
    [Destroys the serial port. ]
  ]
  
]

The [link boost_asio.reference.basic_serial_port `basic_serial_port`] class provides a wrapper over serial port functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_serial_port.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_signal_set basic_signal_set]

[indexterm1 boost_asio.indexterm.basic_signal_set..basic_signal_set]


Provides signal functionality. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  class basic_signal_set


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_signal_set__rebind_executor [*rebind_executor]]]
    [Rebinds the signal set type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_signal_set.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_signal_set.add [*add]]]
    [Add a signal to a signal_set. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.async_wait [*async_wait]]]
    [Start an asynchronous operation to wait for a signal to be delivered. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.basic_signal_set [*basic_signal_set]] [constructor]]
    [Construct a signal set without adding any signals. 
     [hr]
     Construct a signal set and add one signal. 
     [hr]
     Construct a signal set and add two signals. 
     [hr]
     Construct a signal set and add three signals. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.cancel [*cancel]]]
    [Cancel all operations associated with the signal set. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.clear [*clear]]]
    [Remove all signals from a signal_set. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.remove [*remove]]]
    [Remove a signal from a signal_set. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set._basic_signal_set [*~basic_signal_set]] [destructor]]
    [Destroys the signal set. ]
  ]
  
]

The [link boost_asio.reference.basic_signal_set `basic_signal_set`] class provides the ability to perform an asynchronous wait for one or more signals to occur.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.


[heading Example]
  
Performing an asynchronous wait: 

   void handler(
       const boost::system::error_code& error,
       int signal_number)
   {
     if (!error)
     {
       // A signal occurred.
     }
   }

   ...

   // Construct a signal set registered for process termination.
   boost::asio::signal_set signals(my_context, SIGINT, SIGTERM);

   // Start an asynchronous wait for one of the signals to occur.
   signals.async_wait(handler);





[heading Queueing of signal notifications]
  


If a signal is registered with a signal\_set, and the signal occurs when there are no waiting handlers, then the signal notification is queued. The next async\_wait operation on that signal\_set will dequeue the notification. If multiple notifications are queued, subsequent async\_wait operations dequeue them one at a time. Signal notifications are dequeued in order of ascending signal number.

If a signal number is removed from a signal\_set (using the `remove` or `erase` member functions) then any queued notifications for that signal are discarded.


[heading Multiple registration of signals]
  


The same signal number may be registered with different signal\_set objects. When the signal occurs, one handler is called for each signal\_set object.

Note that multiple registration only works for signals that are registered using Asio. The application must not also register a signal handler using functions such as `signal()` or `sigaction()`.


[heading Signal masking on POSIX platforms]
  


POSIX allows signals to be blocked using functions such as `sigprocmask()` and `pthread_sigmask()`. For signals to be delivered, programs must ensure that any signals registered using signal\_set objects are unblocked in at least one thread. 

[heading Requirements]

['Header: ][^boost/asio/basic_signal_set.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:add basic_signal_set::add]

[indexterm2 boost_asio.indexterm.basic_signal_set.add..add..basic_signal_set] 
Add a signal to a signal\_set. 


  void ``[link boost_asio.reference.basic_signal_set.add.overload1 add]``(
      int signal_number);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.add.overload1 more...]]``

  void ``[link boost_asio.reference.basic_signal_set.add.overload2 add]``(
      int signal_number,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.add.overload2 more...]]``


[section:overload1 basic_signal_set::add (1 of 2 overloads)]


Add a signal to a signal\_set. 


  void add(
      int signal_number);


This function adds the specified signal to the set. It has no effect if the signal is already in the set.


[heading Parameters]
    

[variablelist
  
[[signal_number][The signal to be added to the set.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_signal_set::add (2 of 2 overloads)]


Add a signal to a signal\_set. 


  void add(
      int signal_number,
      boost::system::error_code & ec);


This function adds the specified signal to the set. It has no effect if the signal is already in the set.


[heading Parameters]
    

[variablelist
  
[[signal_number][The signal to be added to the set.]]

[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:async_wait basic_signal_set::async_wait]

[indexterm2 boost_asio.indexterm.basic_signal_set.async_wait..async_wait..basic_signal_set] 
Start an asynchronous operation to wait for a signal to be delivered. 


  template<
      typename ``[link boost_asio.reference.SignalHandler SignalHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_wait(
      SignalHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function may be used to initiate an asynchronous wait against the signal set. It always returns immediately.

For each call to `async_wait()`, the supplied handler will be called exactly once. The handler will be called when:


* One of the registered signals in the signal set occurs; or


* The signal set was cancelled, in which case the handler is passed the error code `boost::asio::error::operation_aborted`.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be called when the signal occurs. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     int signal_number // Indicates which signal occurred.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`]. ]]

]




[endsect]


[section:basic_signal_set basic_signal_set::basic_signal_set]

[indexterm2 boost_asio.indexterm.basic_signal_set.basic_signal_set..basic_signal_set..basic_signal_set] 
Construct a signal set without adding any signals. 


  explicit ``[link boost_asio.reference.basic_signal_set.basic_signal_set.overload1 basic_signal_set]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.basic_signal_set.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_signal_set.basic_signal_set.overload2 basic_signal_set]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.basic_signal_set.overload2 more...]]``


Construct a signal set and add one signal. 


  ``[link boost_asio.reference.basic_signal_set.basic_signal_set.overload3 basic_signal_set]``(
      const executor_type & ex,
      int signal_number_1);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.basic_signal_set.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_signal_set.basic_signal_set.overload4 basic_signal_set]``(
      ExecutionContext & context,
      int signal_number_1,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.basic_signal_set.overload4 more...]]``


Construct a signal set and add two signals. 


  ``[link boost_asio.reference.basic_signal_set.basic_signal_set.overload5 basic_signal_set]``(
      const executor_type & ex,
      int signal_number_1,
      int signal_number_2);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.basic_signal_set.overload5 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_signal_set.basic_signal_set.overload6 basic_signal_set]``(
      ExecutionContext & context,
      int signal_number_1,
      int signal_number_2,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.basic_signal_set.overload6 more...]]``


Construct a signal set and add three signals. 


  ``[link boost_asio.reference.basic_signal_set.basic_signal_set.overload7 basic_signal_set]``(
      const executor_type & ex,
      int signal_number_1,
      int signal_number_2,
      int signal_number_3);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.basic_signal_set.overload7 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_signal_set.basic_signal_set.overload8 basic_signal_set]``(
      ExecutionContext & context,
      int signal_number_1,
      int signal_number_2,
      int signal_number_3,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.basic_signal_set.overload8 more...]]``


[section:overload1 basic_signal_set::basic_signal_set (1 of 8 overloads)]


Construct a signal set without adding any signals. 


  basic_signal_set(
      const executor_type & ex);


This constructor creates a signal set without registering for any signals.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the signal set will use, by default, to dispatch handlers for any asynchronous operations performed on the signal set. ]]

]




[endsect]



[section:overload2 basic_signal_set::basic_signal_set (2 of 8 overloads)]


Construct a signal set without adding any signals. 


  template<
      typename ExecutionContext>
  basic_signal_set(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates a signal set without registering for any signals.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the signal set will use, by default, to dispatch handlers for any asynchronous operations performed on the signal set. ]]

]




[endsect]



[section:overload3 basic_signal_set::basic_signal_set (3 of 8 overloads)]


Construct a signal set and add one signal. 


  basic_signal_set(
      const executor_type & ex,
      int signal_number_1);


This constructor creates a signal set and registers for one signal.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the signal set will use, by default, to dispatch handlers for any asynchronous operations performed on the signal set.]]

[[signal_number_1][The signal number to be added.]]

]


[heading Remarks]
      
This constructor is equivalent to performing: 

   boost::asio::signal_set signals(ex);
   signals.add(signal_number_1); 







[endsect]



[section:overload4 basic_signal_set::basic_signal_set (4 of 8 overloads)]


Construct a signal set and add one signal. 


  template<
      typename ExecutionContext>
  basic_signal_set(
      ExecutionContext & context,
      int signal_number_1,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates a signal set and registers for one signal.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the signal set will use, by default, to dispatch handlers for any asynchronous operations performed on the signal set.]]

[[signal_number_1][The signal number to be added.]]

]


[heading Remarks]
      
This constructor is equivalent to performing: 

   boost::asio::signal_set signals(context);
   signals.add(signal_number_1); 







[endsect]



[section:overload5 basic_signal_set::basic_signal_set (5 of 8 overloads)]


Construct a signal set and add two signals. 


  basic_signal_set(
      const executor_type & ex,
      int signal_number_1,
      int signal_number_2);


This constructor creates a signal set and registers for two signals.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the signal set will use, by default, to dispatch handlers for any asynchronous operations performed on the signal set.]]

[[signal_number_1][The first signal number to be added.]]

[[signal_number_2][The second signal number to be added.]]

]


[heading Remarks]
      
This constructor is equivalent to performing: 

   boost::asio::signal_set signals(ex);
   signals.add(signal_number_1);
   signals.add(signal_number_2); 







[endsect]



[section:overload6 basic_signal_set::basic_signal_set (6 of 8 overloads)]


Construct a signal set and add two signals. 


  template<
      typename ExecutionContext>
  basic_signal_set(
      ExecutionContext & context,
      int signal_number_1,
      int signal_number_2,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates a signal set and registers for two signals.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the signal set will use, by default, to dispatch handlers for any asynchronous operations performed on the signal set.]]

[[signal_number_1][The first signal number to be added.]]

[[signal_number_2][The second signal number to be added.]]

]


[heading Remarks]
      
This constructor is equivalent to performing: 

   boost::asio::signal_set signals(context);
   signals.add(signal_number_1);
   signals.add(signal_number_2); 







[endsect]



[section:overload7 basic_signal_set::basic_signal_set (7 of 8 overloads)]


Construct a signal set and add three signals. 


  basic_signal_set(
      const executor_type & ex,
      int signal_number_1,
      int signal_number_2,
      int signal_number_3);


This constructor creates a signal set and registers for three signals.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the signal set will use, by default, to dispatch handlers for any asynchronous operations performed on the signal set.]]

[[signal_number_1][The first signal number to be added.]]

[[signal_number_2][The second signal number to be added.]]

[[signal_number_3][The third signal number to be added.]]

]


[heading Remarks]
      
This constructor is equivalent to performing: 

   boost::asio::signal_set signals(ex);
   signals.add(signal_number_1);
   signals.add(signal_number_2);
   signals.add(signal_number_3); 







[endsect]



[section:overload8 basic_signal_set::basic_signal_set (8 of 8 overloads)]


Construct a signal set and add three signals. 


  template<
      typename ExecutionContext>
  basic_signal_set(
      ExecutionContext & context,
      int signal_number_1,
      int signal_number_2,
      int signal_number_3,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates a signal set and registers for three signals.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the signal set will use, by default, to dispatch handlers for any asynchronous operations performed on the signal set.]]

[[signal_number_1][The first signal number to be added.]]

[[signal_number_2][The second signal number to be added.]]

[[signal_number_3][The third signal number to be added.]]

]


[heading Remarks]
      
This constructor is equivalent to performing: 

   boost::asio::signal_set signals(context);
   signals.add(signal_number_1);
   signals.add(signal_number_2);
   signals.add(signal_number_3); 







[endsect]


[endsect]

[section:cancel basic_signal_set::cancel]

[indexterm2 boost_asio.indexterm.basic_signal_set.cancel..cancel..basic_signal_set] 
Cancel all operations associated with the signal set. 


  void ``[link boost_asio.reference.basic_signal_set.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_signal_set.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.cancel.overload2 more...]]``


[section:overload1 basic_signal_set::cancel (1 of 2 overloads)]


Cancel all operations associated with the signal set. 


  void cancel();


This function forces the completion of any pending asynchronous wait operations against the signal set. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.

Cancellation does not alter the set of registered signals.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If a registered signal occurred before `cancel()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]



[section:overload2 basic_signal_set::cancel (2 of 2 overloads)]


Cancel all operations associated with the signal set. 


  void cancel(
      boost::system::error_code & ec);


This function forces the completion of any pending asynchronous wait operations against the signal set. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.

Cancellation does not alter the set of registered signals.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
If a registered signal occurred before `cancel()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]


[endsect]

[section:clear basic_signal_set::clear]

[indexterm2 boost_asio.indexterm.basic_signal_set.clear..clear..basic_signal_set] 
Remove all signals from a signal\_set. 


  void ``[link boost_asio.reference.basic_signal_set.clear.overload1 clear]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.clear.overload1 more...]]``

  void ``[link boost_asio.reference.basic_signal_set.clear.overload2 clear]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.clear.overload2 more...]]``


[section:overload1 basic_signal_set::clear (1 of 2 overloads)]


Remove all signals from a signal\_set. 


  void clear();


This function removes all signals from the set. It has no effect if the set is already empty.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Removes all queued notifications. 




[endsect]



[section:overload2 basic_signal_set::clear (2 of 2 overloads)]


Remove all signals from a signal\_set. 


  void clear(
      boost::system::error_code & ec);


This function removes all signals from the set. It has no effect if the set is already empty.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Removes all queued notifications. 




[endsect]


[endsect]


[section:executor_type basic_signal_set::executor_type]

[indexterm2 boost_asio.indexterm.basic_signal_set.executor_type..executor_type..basic_signal_set] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_signal_set.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_signal_set::get_executor]

[indexterm2 boost_asio.indexterm.basic_signal_set.get_executor..get_executor..basic_signal_set] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:remove basic_signal_set::remove]

[indexterm2 boost_asio.indexterm.basic_signal_set.remove..remove..basic_signal_set] 
Remove a signal from a signal\_set. 


  void ``[link boost_asio.reference.basic_signal_set.remove.overload1 remove]``(
      int signal_number);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.remove.overload1 more...]]``

  void ``[link boost_asio.reference.basic_signal_set.remove.overload2 remove]``(
      int signal_number,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_signal_set.remove.overload2 more...]]``


[section:overload1 basic_signal_set::remove (1 of 2 overloads)]


Remove a signal from a signal\_set. 


  void remove(
      int signal_number);


This function removes the specified signal from the set. It has no effect if the signal is not in the set.


[heading Parameters]
    

[variablelist
  
[[signal_number][The signal to be removed from the set.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Removes any notifications that have been queued for the specified signal number. 




[endsect]



[section:overload2 basic_signal_set::remove (2 of 2 overloads)]


Remove a signal from a signal\_set. 


  void remove(
      int signal_number,
      boost::system::error_code & ec);


This function removes the specified signal from the set. It has no effect if the signal is not in the set.


[heading Parameters]
    

[variablelist
  
[[signal_number][The signal to be removed from the set.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Removes any notifications that have been queued for the specified signal number. 




[endsect]


[endsect]


[section:_basic_signal_set basic_signal_set::~basic_signal_set]

[indexterm2 boost_asio.indexterm.basic_signal_set._basic_signal_set..~basic_signal_set..basic_signal_set] 
Destroys the signal set. 


  ~basic_signal_set();


This function destroys the signal set, cancelling any outstanding asynchronous wait operations associated with the signal set as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_signal_set__rebind_executor basic_signal_set::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_signal_set__rebind_executor..basic_signal_set::rebind_executor]


Rebinds the signal set type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_signal_set__rebind_executor.other [*other]]]
    [The signal set type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_signal_set.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_signal_set::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_signal_set__rebind_executor.other..other..basic_signal_set::rebind_executor] 
The signal set type when rebound to the specified executor. 


  typedef basic_signal_set< Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_signal_set__rebind_executor [*rebind_executor]]]
    [Rebinds the signal set type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_signal_set.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_signal_set.add [*add]]]
    [Add a signal to a signal_set. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.async_wait [*async_wait]]]
    [Start an asynchronous operation to wait for a signal to be delivered. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.basic_signal_set [*basic_signal_set]] [constructor]]
    [Construct a signal set without adding any signals. 
     [hr]
     Construct a signal set and add one signal. 
     [hr]
     Construct a signal set and add two signals. 
     [hr]
     Construct a signal set and add three signals. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.cancel [*cancel]]]
    [Cancel all operations associated with the signal set. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.clear [*clear]]]
    [Remove all signals from a signal_set. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.remove [*remove]]]
    [Remove a signal from a signal_set. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set._basic_signal_set [*~basic_signal_set]] [destructor]]
    [Destroys the signal set. ]
  ]
  
]

The [link boost_asio.reference.basic_signal_set `basic_signal_set`] class provides the ability to perform an asynchronous wait for one or more signals to occur.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.


[heading Example]
  
Performing an asynchronous wait: 

   void handler(
       const boost::system::error_code& error,
       int signal_number)
   {
     if (!error)
     {
       // A signal occurred.
     }
   }

   ...

   // Construct a signal set registered for process termination.
   boost::asio::signal_set signals(my_context, SIGINT, SIGTERM);

   // Start an asynchronous wait for one of the signals to occur.
   signals.async_wait(handler);





[heading Queueing of signal notifications]
  


If a signal is registered with a signal\_set, and the signal occurs when there are no waiting handlers, then the signal notification is queued. The next async\_wait operation on that signal\_set will dequeue the notification. If multiple notifications are queued, subsequent async\_wait operations dequeue them one at a time. Signal notifications are dequeued in order of ascending signal number.

If a signal number is removed from a signal\_set (using the `remove` or `erase` member functions) then any queued notifications for that signal are discarded.


[heading Multiple registration of signals]
  


The same signal number may be registered with different signal\_set objects. When the signal occurs, one handler is called for each signal\_set object.

Note that multiple registration only works for signals that are registered using Asio. The application must not also register a signal handler using functions such as `signal()` or `sigaction()`.


[heading Signal masking on POSIX platforms]
  


POSIX allows signals to be blocked using functions such as `sigprocmask()` and `pthread_sigmask()`. For signals to be delivered, programs must ensure that any signals registered using signal\_set objects are unblocked in at least one thread. 


[heading Requirements]

['Header: ][^boost/asio/basic_signal_set.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_socket basic_socket]

[indexterm1 boost_asio.indexterm.basic_socket..basic_socket]


Provides socket functionality. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class basic_socket :
    public socket_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.basic_socket [*basic_socket]] [constructor]]
    [Construct a basic_socket without opening it. 
     [hr]
     Construct and open a basic_socket. 
     [hr]
     Construct a basic_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_socket on an existing native socket. 
     [hr]
     Move-construct a basic_socket from another. 
     [hr]
     Move-construct a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket from another. 
     [hr]
     Move-assign a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket._basic_socket [*~basic_socket]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_socket `basic_socket`] class template provides functionality that is common to both stream-oriented and datagram-oriented sockets.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign basic_socket::assign]

[indexterm2 boost_asio.indexterm.basic_socket.assign..assign..basic_socket] 
Assign an existing native socket to the socket. 


  void ``[link boost_asio.reference.basic_socket.assign.overload1 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.assign.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket.assign.overload2 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.assign.overload2 more...]]``


[section:overload1 basic_socket::assign (1 of 2 overloads)]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket);



[endsect]



[section:overload2 basic_socket::assign (2 of 2 overloads)]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_connect basic_socket::async_connect]

[indexterm2 boost_asio.indexterm.basic_socket.async_connect..async_connect..basic_socket] 
Start an asynchronous connect. 


  template<
      typename ``[link boost_asio.reference.ConnectHandler ConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      const endpoint_type & peer_endpoint,
      ConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.]]

[[handler][The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void connect_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Connect succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.async_connect(endpoint, connect_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:async_wait basic_socket::async_wait]

[indexterm2 boost_asio.indexterm.basic_socket.async_wait..async_wait..basic_socket] 
Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  template<
      typename ``[link boost_asio.reference.WaitHandler WaitHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_wait(
      wait_type w,
      WaitHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to perform an asynchronous wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[handler][The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void wait_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Wait succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:at_mark basic_socket::at_mark]

[indexterm2 boost_asio.indexterm.basic_socket.at_mark..at_mark..basic_socket] 
Determine whether the socket is at the out-of-band data mark. 


  bool ``[link boost_asio.reference.basic_socket.at_mark.overload1 at_mark]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.at_mark.overload1 more...]]``

  bool ``[link boost_asio.reference.basic_socket.at_mark.overload2 at_mark]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.at_mark.overload2 more...]]``


[section:overload1 basic_socket::at_mark (1 of 2 overloads)]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark() const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_socket::at_mark (2 of 2 overloads)]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark(
      boost::system::error_code & ec) const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark. 




[endsect]


[endsect]

[section:available basic_socket::available]

[indexterm2 boost_asio.indexterm.basic_socket.available..available..basic_socket] 
Determine the number of bytes available for reading. 


  std::size_t ``[link boost_asio.reference.basic_socket.available.overload1 available]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.available.overload1 more...]]``

  std::size_t ``[link boost_asio.reference.basic_socket.available.overload2 available]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.available.overload2 more...]]``


[section:overload1 basic_socket::available (1 of 2 overloads)]


Determine the number of bytes available for reading. 


  std::size_t available() const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_socket::available (2 of 2 overloads)]


Determine the number of bytes available for reading. 


  std::size_t available(
      boost::system::error_code & ec) const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs. 




[endsect]


[endsect]

[section:basic_socket basic_socket::basic_socket]

[indexterm2 boost_asio.indexterm.basic_socket.basic_socket..basic_socket..basic_socket] 
Construct a [link boost_asio.reference.basic_socket `basic_socket`] without opening it. 


  explicit ``[link boost_asio.reference.basic_socket.basic_socket.overload1 basic_socket]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.basic_socket.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_socket.basic_socket.overload2 basic_socket]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.basic_socket.overload2 more...]]``


Construct and open a [link boost_asio.reference.basic_socket `basic_socket`]. 


  ``[link boost_asio.reference.basic_socket.basic_socket.overload3 basic_socket]``(
      const executor_type & ex,
      const protocol_type & protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.basic_socket.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_socket.basic_socket.overload4 basic_socket]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.basic_socket.overload4 more...]]``


Construct a [link boost_asio.reference.basic_socket `basic_socket`], opening it and binding it to the given local endpoint. 


  ``[link boost_asio.reference.basic_socket.basic_socket.overload5 basic_socket]``(
      const executor_type & ex,
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.basic_socket.overload5 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_socket.basic_socket.overload6 basic_socket]``(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.basic_socket.overload6 more...]]``


Construct a [link boost_asio.reference.basic_socket `basic_socket`] on an existing native socket. 


  ``[link boost_asio.reference.basic_socket.basic_socket.overload7 basic_socket]``(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.basic_socket.overload7 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_socket.basic_socket.overload8 basic_socket]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.basic_socket.overload8 more...]]``


Move-construct a [link boost_asio.reference.basic_socket `basic_socket`] from another. 


  ``[link boost_asio.reference.basic_socket.basic_socket.overload9 basic_socket]``(
      basic_socket && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.basic_socket.overload9 more...]]``


Move-construct a [link boost_asio.reference.basic_socket `basic_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.basic_socket.basic_socket.overload10 basic_socket]``(
      basic_socket< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.basic_socket.overload10 more...]]``


[section:overload1 basic_socket::basic_socket (1 of 10 overloads)]


Construct a [link boost_asio.reference.basic_socket `basic_socket`] without opening it. 


  basic_socket(
      const executor_type & ex);


This constructor creates a socket without opening it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload2 basic_socket::basic_socket (2 of 10 overloads)]


Construct a [link boost_asio.reference.basic_socket `basic_socket`] without opening it. 


  template<
      typename ExecutionContext>
  basic_socket(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a socket without opening it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload3 basic_socket::basic_socket (3 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_socket `basic_socket`]. 


  basic_socket(
      const executor_type & ex,
      const protocol_type & protocol);


This constructor creates and opens a socket.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_socket::basic_socket (4 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_socket `basic_socket`]. 


  template<
      typename ExecutionContext>
  basic_socket(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates and opens a socket.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_socket::basic_socket (5 of 10 overloads)]


Construct a [link boost_asio.reference.basic_socket `basic_socket`], opening it and binding it to the given local endpoint. 


  basic_socket(
      const executor_type & ex,
      const endpoint_type & endpoint);


This constructor creates a socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload6 basic_socket::basic_socket (6 of 10 overloads)]


Construct a [link boost_asio.reference.basic_socket `basic_socket`], opening it and binding it to the given local endpoint. 


  template<
      typename ExecutionContext>
  basic_socket(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload7 basic_socket::basic_socket (7 of 10 overloads)]


Construct a [link boost_asio.reference.basic_socket `basic_socket`] on an existing native socket. 


  basic_socket(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_socket);


This constructor creates a socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][A native socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 basic_socket::basic_socket (8 of 10 overloads)]


Construct a [link boost_asio.reference.basic_socket `basic_socket`] on an existing native socket. 


  template<
      typename ExecutionContext>
  basic_socket(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][A native socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload9 basic_socket::basic_socket (9 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_socket `basic_socket`] from another. 


  basic_socket(
      basic_socket && other);


This constructor moves a socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_socket `basic_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket(const executor_type&) constructor`. 




[endsect]



[section:overload10 basic_socket::basic_socket (10 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_socket `basic_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_socket(
      basic_socket< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);


This constructor moves a socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_socket `basic_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket(const executor_type&) constructor`. 




[endsect]


[endsect]

[section:bind basic_socket::bind]

[indexterm2 boost_asio.indexterm.basic_socket.bind..bind..basic_socket] 
Bind the socket to the given local endpoint. 


  void ``[link boost_asio.reference.basic_socket.bind.overload1 bind]``(
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.bind.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket.bind.overload2 bind]``(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.bind.overload2 more...]]``


[section:overload1 basic_socket::bind (1 of 2 overloads)]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());
   socket.bind(boost::asio::ip::tcp::endpoint(
         boost::asio::ip::tcp::v4(), 12345));







[endsect]



[section:overload2 basic_socket::bind (2 of 2 overloads)]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());
   boost::system::error_code ec;
   socket.bind(boost::asio::ip::tcp::endpoint(
         boost::asio::ip::tcp::v4(), 12345), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:broadcast basic_socket::broadcast]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.broadcast..broadcast..basic_socket] 
Socket option to permit sending of broadcast messages. 


  typedef implementation_defined broadcast;



Implements the SOL\_SOCKET/SO\_BROADCAST socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:bytes_readable basic_socket::bytes_readable]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.bytes_readable..bytes_readable..basic_socket] 
IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::bytes_readable command(true);
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:cancel basic_socket::cancel]

[indexterm2 boost_asio.indexterm.basic_socket.cancel..cancel..basic_socket] 
Cancel all asynchronous operations associated with the socket. 


  void ``[link boost_asio.reference.basic_socket.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.cancel.overload2 more...]]``


[section:overload1 basic_socket::cancel (1 of 2 overloads)]


Cancel all asynchronous operations associated with the socket. 


  void cancel();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining BOOST\_ASIO\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]



[section:overload2 basic_socket::cancel (2 of 2 overloads)]


Cancel all asynchronous operations associated with the socket. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining BOOST\_ASIO\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]


[endsect]

[section:close basic_socket::close]

[indexterm2 boost_asio.indexterm.basic_socket.close..close..basic_socket] 
Close the socket. 


  void ``[link boost_asio.reference.basic_socket.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.close.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.close.overload2 more...]]``


[section:overload1 basic_socket::close (1 of 2 overloads)]


Close the socket. 


  void close();


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]



[section:overload2 basic_socket::close (2 of 2 overloads)]


Close the socket. 


  void close(
      boost::system::error_code & ec);


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.close(ec);
   if (ec)
   {
     // An error occurred.
   }





[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]


[endsect]

[section:connect basic_socket::connect]

[indexterm2 boost_asio.indexterm.basic_socket.connect..connect..basic_socket] 
Connect the socket to the specified endpoint. 


  void ``[link boost_asio.reference.basic_socket.connect.overload1 connect]``(
      const endpoint_type & peer_endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.connect.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket.connect.overload2 connect]``(
      const endpoint_type & peer_endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.connect.overload2 more...]]``


[section:overload1 basic_socket::connect (1 of 2 overloads)]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.connect(endpoint);







[endsect]



[section:overload2 basic_socket::connect (2 of 2 overloads)]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint,
      boost::system::error_code & ec);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   boost::system::error_code ec;
   socket.connect(endpoint, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:debug basic_socket::debug]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.debug..debug..basic_socket] 
Socket option to enable socket-level debugging. 


  typedef implementation_defined debug;



Implements the SOL\_SOCKET/SO\_DEBUG socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:do_not_route basic_socket::do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.do_not_route..do_not_route..basic_socket] 
Socket option to prevent routing, use local interfaces only. 


  typedef implementation_defined do_not_route;



Implements the SOL\_SOCKET/SO\_DONTROUTE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:enable_connection_aborted basic_socket::enable_connection_aborted]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.enable_connection_aborted..enable_connection_aborted..basic_socket] 
Socket option to report aborted connections on accept. 


  typedef implementation_defined enable_connection_aborted;



Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:endpoint_type basic_socket::endpoint_type]

[indexterm2 boost_asio.indexterm.basic_socket.endpoint_type..endpoint_type..basic_socket] 
The endpoint type. 


  typedef Protocol::endpoint endpoint_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:executor_type basic_socket::executor_type]

[indexterm2 boost_asio.indexterm.basic_socket.executor_type..executor_type..basic_socket] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_socket::get_executor]

[indexterm2 boost_asio.indexterm.basic_socket.get_executor..get_executor..basic_socket] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:get_option basic_socket::get_option]

[indexterm2 boost_asio.indexterm.basic_socket.get_option..get_option..basic_socket] 
Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_socket.get_option.overload1 get_option]``(
      GettableSocketOption & option) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.get_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_socket.get_option.overload2 get_option]``(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.get_option.overload2 more...]]``


[section:overload1 basic_socket::get_option (1 of 2 overloads)]


Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[endsect]



[section:overload2 basic_socket::get_option (2 of 2 overloads)]


Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::keep_alive option;
   boost::system::error_code ec;
   socket.get_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }
   bool is_set = option.value();







[endsect]


[endsect]

[section:io_control basic_socket::io_control]

[indexterm2 boost_asio.indexterm.basic_socket.io_control..io_control..basic_socket] 
Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_socket.io_control.overload1 io_control]``(
      IoControlCommand & command);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.io_control.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_socket.io_control.overload2 io_control]``(
      IoControlCommand & command,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.io_control.overload2 more...]]``


[section:overload1 basic_socket::io_control (1 of 2 overloads)]


Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::bytes_readable command;
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[endsect]



[section:overload2 basic_socket::io_control (2 of 2 overloads)]


Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command,
      boost::system::error_code & ec);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::bytes_readable command;
   boost::system::error_code ec;
   socket.io_control(command, ec);
   if (ec)
   {
     // An error occurred.
   }
   std::size_t bytes_readable = command.get();







[endsect]


[endsect]


[section:is_open basic_socket::is_open]

[indexterm2 boost_asio.indexterm.basic_socket.is_open..is_open..basic_socket] 
Determine whether the socket is open. 


  bool is_open() const;



[endsect]



[section:keep_alive basic_socket::keep_alive]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.keep_alive..keep_alive..basic_socket] 
Socket option to send keep-alives. 


  typedef implementation_defined keep_alive;



Implements the SOL\_SOCKET/SO\_KEEPALIVE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:linger basic_socket::linger]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.linger..linger..basic_socket] 
Socket option to specify whether the socket lingers on close if unsent data is present. 


  typedef implementation_defined linger;



Implements the SOL\_SOCKET/SO\_LINGER socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option(true, 30);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option;
   socket.get_option(option);
   bool is_set = option.enabled();
   unsigned short timeout = option.timeout();







[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:local_endpoint basic_socket::local_endpoint]

[indexterm2 boost_asio.indexterm.basic_socket.local_endpoint..local_endpoint..basic_socket] 
Get the local endpoint of the socket. 


  endpoint_type ``[link boost_asio.reference.basic_socket.local_endpoint.overload1 local_endpoint]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.local_endpoint.overload1 more...]]``

  endpoint_type ``[link boost_asio.reference.basic_socket.local_endpoint.overload2 local_endpoint]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.local_endpoint.overload2 more...]]``


[section:overload1 basic_socket::local_endpoint (1 of 2 overloads)]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint() const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Return Value]
      
An object that represents the local endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();







[endsect]



[section:overload2 basic_socket::local_endpoint (2 of 2 overloads)]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint(
      boost::system::error_code & ec) const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:lowest_layer basic_socket::lowest_layer]

[indexterm2 boost_asio.indexterm.basic_socket.lowest_layer..lowest_layer..basic_socket] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.basic_socket.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.basic_socket.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.lowest_layer.overload2 more...]]``


[section:overload1 basic_socket::lowest_layer (1 of 2 overloads)]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_socket `basic_socket`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 basic_socket::lowest_layer (2 of 2 overloads)]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_socket `basic_socket`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type basic_socket::lowest_layer_type]

[indexterm2 boost_asio.indexterm.basic_socket.lowest_layer_type..lowest_layer_type..basic_socket] 
A [link boost_asio.reference.basic_socket `basic_socket`] is always the lowest layer. 


  typedef basic_socket< Protocol, Executor > lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.basic_socket [*basic_socket]] [constructor]]
    [Construct a basic_socket without opening it. 
     [hr]
     Construct and open a basic_socket. 
     [hr]
     Construct a basic_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_socket on an existing native socket. 
     [hr]
     Move-construct a basic_socket from another. 
     [hr]
     Move-construct a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket from another. 
     [hr]
     Move-assign a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket._basic_socket [*~basic_socket]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_socket `basic_socket`] class template provides functionality that is common to both stream-oriented and datagram-oriented sockets.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:max_connections basic_socket::max_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.max_connections..max_connections..basic_socket] 
(Deprecated: Use max\_listen\_connections.) The maximum length of the queue of pending incoming connections. 


  static const int max_connections = implementation_defined;



[endsect]



[section:max_listen_connections basic_socket::max_listen_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.max_listen_connections..max_listen_connections..basic_socket] 
The maximum length of the queue of pending incoming connections. 


  static const int max_listen_connections = implementation_defined;



[endsect]



[section:message_do_not_route basic_socket::message_do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.message_do_not_route..message_do_not_route..basic_socket] 
Specify that the data should not be subject to routing. 


  static const int message_do_not_route = implementation_defined;



[endsect]



[section:message_end_of_record basic_socket::message_end_of_record]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.message_end_of_record..message_end_of_record..basic_socket] 
Specifies that the data marks the end of a record. 


  static const int message_end_of_record = implementation_defined;



[endsect]



[section:message_flags basic_socket::message_flags]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.message_flags..message_flags..basic_socket] 
Bitmask type for flags that can be passed to send and receive operations. 


  typedef int message_flags;



[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:message_out_of_band basic_socket::message_out_of_band]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.message_out_of_band..message_out_of_band..basic_socket] 
Process out-of-band data. 


  static const int message_out_of_band = implementation_defined;



[endsect]



[section:message_peek basic_socket::message_peek]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.message_peek..message_peek..basic_socket] 
Peek at incoming data without removing it from the input queue. 


  static const int message_peek = implementation_defined;



[endsect]



[section:native_handle basic_socket::native_handle]

[indexterm2 boost_asio.indexterm.basic_socket.native_handle..native_handle..basic_socket] 
Get the native socket representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_socket::native_handle_type]

[indexterm2 boost_asio.indexterm.basic_socket.native_handle_type..native_handle_type..basic_socket] 
The native representation of a socket. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:native_non_blocking basic_socket::native_non_blocking]

[indexterm2 boost_asio.indexterm.basic_socket.native_non_blocking..native_non_blocking..basic_socket] 
Gets the non-blocking mode of the native socket implementation. 


  bool ``[link boost_asio.reference.basic_socket.native_non_blocking.overload1 native_non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.native_non_blocking.overload1 more...]]``


Sets the non-blocking mode of the native socket implementation. 


  void ``[link boost_asio.reference.basic_socket.native_non_blocking.overload2 native_non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.native_non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.basic_socket.native_non_blocking.overload3 native_non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.native_non_blocking.overload3 more...]]``


[section:overload1 basic_socket::native_non_blocking (1 of 3 overloads)]


Gets the non-blocking mode of the native socket implementation. 


  bool native_non_blocking() const;


This function is used to retrieve the non-blocking mode of the underlying native socket. This mode has no effect on the behaviour of the socket object's synchronous operations.


[heading Return Value]
      
`true` if the underlying socket is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).


[heading Remarks]
      
The current non-blocking mode is cached by the socket object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native socket.


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload2 basic_socket::native_non_blocking (2 of 3 overloads)]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload3 basic_socket::native_non_blocking (3 of 3 overloads)]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode,
      boost::system::error_code & ec);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]


[endsect]

[section:non_blocking basic_socket::non_blocking]

[indexterm2 boost_asio.indexterm.basic_socket.non_blocking..non_blocking..basic_socket] 
Gets the non-blocking mode of the socket. 


  bool ``[link boost_asio.reference.basic_socket.non_blocking.overload1 non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.non_blocking.overload1 more...]]``


Sets the non-blocking mode of the socket. 


  void ``[link boost_asio.reference.basic_socket.non_blocking.overload2 non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.basic_socket.non_blocking.overload3 non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.non_blocking.overload3 more...]]``


[section:overload1 basic_socket::non_blocking (1 of 3 overloads)]


Gets the non-blocking mode of the socket. 


  bool non_blocking() const;



[heading Return Value]
      
`true` if the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload2 basic_socket::non_blocking (2 of 3 overloads)]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload3 basic_socket::non_blocking (3 of 3 overloads)]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode,
      boost::system::error_code & ec);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]


[endsect]

[section:open basic_socket::open]

[indexterm2 boost_asio.indexterm.basic_socket.open..open..basic_socket] 
Open the socket using the specified protocol. 


  void ``[link boost_asio.reference.basic_socket.open.overload1 open]``(
      const protocol_type & protocol = protocol_type());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.open.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket.open.overload2 open]``(
      const protocol_type & protocol,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.open.overload2 more...]]``


[section:overload1 basic_socket::open (1 of 2 overloads)]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol = protocol_type());


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());







[endsect]



[section:overload2 basic_socket::open (2 of 2 overloads)]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol,
      boost::system::error_code & ec);


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying which protocol is to be used.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::system::error_code ec;
   socket.open(boost::asio::ip::tcp::v4(), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:operator_eq_ basic_socket::operator=]

[indexterm2 boost_asio.indexterm.basic_socket.operator_eq_..operator=..basic_socket] 
Move-assign a [link boost_asio.reference.basic_socket `basic_socket`] from another. 


  basic_socket & ``[link boost_asio.reference.basic_socket.operator_eq_.overload1 operator=]``(
      basic_socket && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.operator_eq_.overload1 more...]]``


Move-assign a [link boost_asio.reference.basic_socket `basic_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value, basic_socket & >::type ``[link boost_asio.reference.basic_socket.operator_eq_.overload2 operator=]``(
      basic_socket< Protocol1, Executor1 > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.operator_eq_.overload2 more...]]``


[section:overload1 basic_socket::operator= (1 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_socket `basic_socket`] from another. 


  basic_socket & operator=(
      basic_socket && other);


This assignment operator moves a socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_socket `basic_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket(const executor_type&) constructor`. 




[endsect]



[section:overload2 basic_socket::operator= (2 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_socket `basic_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value, basic_socket & >::type operator=(
      basic_socket< Protocol1, Executor1 > && other);


This assignment operator moves a socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_socket `basic_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket(const executor_type&) constructor`. 




[endsect]


[endsect]


[section:out_of_band_inline basic_socket::out_of_band_inline]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.out_of_band_inline..out_of_band_inline..basic_socket] 
Socket option for putting received out-of-band data inline. 


  typedef implementation_defined out_of_band_inline;



Implements the SOL\_SOCKET/SO\_OOBINLINE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option;
   socket.get_option(option);
   bool value = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol_type basic_socket::protocol_type]

[indexterm2 boost_asio.indexterm.basic_socket.protocol_type..protocol_type..basic_socket] 
The protocol type. 


  typedef Protocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:receive_buffer_size basic_socket::receive_buffer_size]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.receive_buffer_size..receive_buffer_size..basic_socket] 
Socket option for the receive buffer size of a socket. 


  typedef implementation_defined receive_buffer_size;



Implements the SOL\_SOCKET/SO\_RCVBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:receive_low_watermark basic_socket::receive_low_watermark]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.receive_low_watermark..receive_low_watermark..basic_socket] 
Socket option for the receive low watermark. 


  typedef implementation_defined receive_low_watermark;



Implements the SOL\_SOCKET/SO\_RCVLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:release basic_socket::release]

[indexterm2 boost_asio.indexterm.basic_socket.release..release..basic_socket] 
Release ownership of the underlying native socket. 


  native_handle_type ``[link boost_asio.reference.basic_socket.release.overload1 release]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.release.overload1 more...]]``

  native_handle_type ``[link boost_asio.reference.basic_socket.release.overload2 release]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.release.overload2 more...]]``


[section:overload1 basic_socket::release (1 of 2 overloads)]


Release ownership of the underlying native socket. 


  native_handle_type release();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]



[section:overload2 basic_socket::release (2 of 2 overloads)]


Release ownership of the underlying native socket. 


  native_handle_type release(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]


[endsect]

[section:remote_endpoint basic_socket::remote_endpoint]

[indexterm2 boost_asio.indexterm.basic_socket.remote_endpoint..remote_endpoint..basic_socket] 
Get the remote endpoint of the socket. 


  endpoint_type ``[link boost_asio.reference.basic_socket.remote_endpoint.overload1 remote_endpoint]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.remote_endpoint.overload1 more...]]``

  endpoint_type ``[link boost_asio.reference.basic_socket.remote_endpoint.overload2 remote_endpoint]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.remote_endpoint.overload2 more...]]``


[section:overload1 basic_socket::remote_endpoint (1 of 2 overloads)]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint() const;


This function is used to obtain the remote endpoint of the socket.


[heading Return Value]
      
An object that represents the remote endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();







[endsect]



[section:overload2 basic_socket::remote_endpoint (2 of 2 overloads)]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint(
      boost::system::error_code & ec) const;


This function is used to obtain the remote endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:reuse_address basic_socket::reuse_address]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.reuse_address..reuse_address..basic_socket] 
Socket option to allow the socket to be bound to an address that is already in use. 


  typedef implementation_defined reuse_address;



Implements the SOL\_SOCKET/SO\_REUSEADDR socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:send_buffer_size basic_socket::send_buffer_size]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.send_buffer_size..send_buffer_size..basic_socket] 
Socket option for the send buffer size of a socket. 


  typedef implementation_defined send_buffer_size;



Implements the SOL\_SOCKET/SO\_SNDBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:send_low_watermark basic_socket::send_low_watermark]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.send_low_watermark..send_low_watermark..basic_socket] 
Socket option for the send low watermark. 


  typedef implementation_defined send_low_watermark;



Implements the SOL\_SOCKET/SO\_SNDLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:set_option basic_socket::set_option]

[indexterm2 boost_asio.indexterm.basic_socket.set_option..set_option..basic_socket] 
Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void ``[link boost_asio.reference.basic_socket.set_option.overload1 set_option]``(
      const SettableSocketOption & option);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.set_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void ``[link boost_asio.reference.basic_socket.set_option.overload2 set_option]``(
      const SettableSocketOption & option,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.set_option.overload2 more...]]``


[section:overload1 basic_socket::set_option (1 of 2 overloads)]


Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void set_option(
      const SettableSocketOption & option);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::no_delay option(true);
   socket.set_option(option);







[endsect]



[section:overload2 basic_socket::set_option (2 of 2 overloads)]


Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void set_option(
      const SettableSocketOption & option,
      boost::system::error_code & ec);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::no_delay option(true);
   boost::system::error_code ec;
   socket.set_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:shutdown basic_socket::shutdown]

[indexterm2 boost_asio.indexterm.basic_socket.shutdown..shutdown..basic_socket] 
Disable sends or receives on the socket. 


  void ``[link boost_asio.reference.basic_socket.shutdown.overload1 shutdown]``(
      shutdown_type what);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.shutdown.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket.shutdown.overload2 shutdown]``(
      shutdown_type what,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.shutdown.overload2 more...]]``


[section:overload1 basic_socket::shutdown (1 of 2 overloads)]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);







[endsect]



[section:overload2 basic_socket::shutdown (2 of 2 overloads)]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what,
      boost::system::error_code & ec);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:shutdown_type basic_socket::shutdown_type]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.shutdown_type..shutdown_type..basic_socket] 
Different ways a socket may be shutdown. 

  enum shutdown_type

[indexterm2 boost_asio.indexterm.basic_socket.shutdown_type.shutdown_receive..shutdown_receive..basic_socket]
[indexterm2 boost_asio.indexterm.basic_socket.shutdown_type.shutdown_send..shutdown_send..basic_socket]
[indexterm2 boost_asio.indexterm.basic_socket.shutdown_type.shutdown_both..shutdown_both..basic_socket]

[heading Values]
[variablelist

  [
    [shutdown_receive]
    [Shutdown the receive side of the socket. ]
  ]

  [
    [shutdown_send]
    [Shutdown the send side of the socket. ]
  ]

  [
    [shutdown_both]
    [Shutdown both send and receive on the socket. ]
  ]

]



[endsect]


[section:wait basic_socket::wait]

[indexterm2 boost_asio.indexterm.basic_socket.wait..wait..basic_socket] 
Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void ``[link boost_asio.reference.basic_socket.wait.overload1 wait]``(
      wait_type w);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.wait.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket.wait.overload2 wait]``(
      wait_type w,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket.wait.overload2 more...]]``


[section:overload1 basic_socket::wait (1 of 2 overloads)]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.wait(boost::asio::ip::tcp::socket::wait_read);







[endsect]



[section:overload2 basic_socket::wait (2 of 2 overloads)]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w,
      boost::system::error_code & ec);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);







[endsect]


[endsect]


[section:wait_type basic_socket::wait_type]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket.wait_type..wait_type..basic_socket] 
Wait types. 

  enum wait_type

[indexterm2 boost_asio.indexterm.basic_socket.wait_type.wait_read..wait_read..basic_socket]
[indexterm2 boost_asio.indexterm.basic_socket.wait_type.wait_write..wait_write..basic_socket]
[indexterm2 boost_asio.indexterm.basic_socket.wait_type.wait_error..wait_error..basic_socket]

[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a socket to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a socket to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a socket to have error conditions pending. ]
  ]

]


For use with `basic_socket::wait()` and `basic_socket::async_wait()`. 


[endsect]



[section:_basic_socket basic_socket::~basic_socket]

[indexterm2 boost_asio.indexterm.basic_socket._basic_socket..~basic_socket..basic_socket] 
Protected destructor to prevent deletion through this type. 


  ~basic_socket();


This function destroys the socket, cancelling any outstanding asynchronous operations associated with the socket as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_socket__rebind_executor basic_socket::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_socket__rebind_executor..basic_socket::rebind_executor]


Rebinds the socket type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket__rebind_executor.other [*other]]]
    [The socket type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_socket::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_socket__rebind_executor.other..other..basic_socket::rebind_executor] 
The socket type when rebound to the specified executor. 


  typedef basic_socket< Protocol, Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.basic_socket [*basic_socket]] [constructor]]
    [Construct a basic_socket without opening it. 
     [hr]
     Construct and open a basic_socket. 
     [hr]
     Construct a basic_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_socket on an existing native socket. 
     [hr]
     Move-construct a basic_socket from another. 
     [hr]
     Move-construct a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket from another. 
     [hr]
     Move-assign a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket._basic_socket [*~basic_socket]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_socket `basic_socket`] class template provides functionality that is common to both stream-oriented and datagram-oriented sockets.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_socket_acceptor basic_socket_acceptor]

[indexterm1 boost_asio.indexterm.basic_socket_acceptor..basic_socket_acceptor]


Provides the ability to accept new connections. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class basic_socket_acceptor :
    public socket_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket_acceptor__rebind_executor [*rebind_executor]]]
    [Rebinds the acceptor type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.native_handle_type [*native_handle_type]]]
    [The native representation of an acceptor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_acceptor.accept [*accept]]]
    [Accept a new connection. 
     [hr]
     Accept a new connection and obtain the endpoint of the peer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.assign [*assign]]]
    [Assigns an existing native acceptor to the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.async_accept [*async_accept]]]
    [Start an asynchronous accept. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.async_wait [*async_wait]]]
    [Asynchronously wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor [*basic_socket_acceptor]] [constructor]]
    [Construct an acceptor without opening it. 
     [hr]
     Construct an open acceptor. 
     [hr]
     Construct an acceptor opened on the given endpoint. 
     [hr]
     Construct a basic_socket_acceptor on an existing native acceptor. 
     [hr]
     Move-construct a basic_socket_acceptor from another. 
     [hr]
     Move-construct a basic_socket_acceptor from an acceptor of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.bind [*bind]]]
    [Bind the acceptor to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.close [*close]]]
    [Close the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.get_option [*get_option]]]
    [Get an option from the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.io_control [*io_control]]]
    [Perform an IO control command on the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.is_open [*is_open]]]
    [Determine whether the acceptor is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.listen [*listen]]]
    [Place the acceptor into the state where it will listen for new connections. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.native_handle [*native_handle]]]
    [Get the native acceptor representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native acceptor implementation. 
     [hr]
     Sets the non-blocking mode of the native acceptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the acceptor. 
     [hr]
     Sets the non-blocking mode of the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.open [*open]]]
    [Open the acceptor using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_acceptor from another. 
     [hr]
     Move-assign a basic_socket_acceptor from an acceptor of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.release [*release]]]
    [Release ownership of the underlying native acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.set_option [*set_option]]]
    [Set an option on the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.wait [*wait]]]
    [Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor._basic_socket_acceptor [*~basic_socket_acceptor]] [destructor]]
    [Destroys the acceptor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_acceptor.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] class template is used for accepting new socket connections.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `accept` operations are thread safe, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to synchronous `accept` operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe.


[heading Example]
  
Opening a socket acceptor with the SO\_REUSEADDR option enabled: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port);
   acceptor.open(endpoint.protocol());
   acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
   acceptor.bind(endpoint);
   acceptor.listen();






[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:accept basic_socket_acceptor::accept]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.accept..accept..basic_socket_acceptor] 
Accept a new connection. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  void ``[link boost_asio.reference.basic_socket_acceptor.accept.overload1 accept]``(
      basic_socket< Protocol1, Executor1 > & peer,
      typename constraint< is_convertible< Protocol, Protocol1 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  void ``[link boost_asio.reference.basic_socket_acceptor.accept.overload2 accept]``(
      basic_socket< Protocol1, Executor1 > & peer,
      boost::system::error_code & ec,
      typename constraint< is_convertible< Protocol, Protocol1 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload2 more...]]``


Accept a new connection and obtain the endpoint of the peer. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  void ``[link boost_asio.reference.basic_socket_acceptor.accept.overload3 accept]``(
      basic_socket< protocol_type, Executor1 > & peer,
      endpoint_type & peer_endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  void ``[link boost_asio.reference.basic_socket_acceptor.accept.overload4 accept]``(
      basic_socket< protocol_type, Executor1 > & peer,
      endpoint_type & peer_endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload4 more...]]``

  Protocol::socket::template rebind_executor< executor_type >::other ``[link boost_asio.reference.basic_socket_acceptor.accept.overload5 accept]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload5 more...]]``

  Protocol::socket::template rebind_executor< executor_type >::other ``[link boost_asio.reference.basic_socket_acceptor.accept.overload6 accept]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload6 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  Protocol::socket::template rebind_executor< Executor1 >::other ``[link boost_asio.reference.basic_socket_acceptor.accept.overload7 accept]``(
      const Executor1 & ex,
      typename constraint< is_executor< Executor1 >::value||execution::is_executor< Executor1 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload7 more...]]``

  template<
      typename ExecutionContext>
  Protocol::socket::template rebind_executor< typename ExecutionContext::executor_type >::other ``[link boost_asio.reference.basic_socket_acceptor.accept.overload8 accept]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload8 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  Protocol::socket::template rebind_executor< Executor1 >::other ``[link boost_asio.reference.basic_socket_acceptor.accept.overload9 accept]``(
      const Executor1 & ex,
      boost::system::error_code & ec,
      typename constraint< is_executor< Executor1 >::value||execution::is_executor< Executor1 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload9 more...]]``

  template<
      typename ExecutionContext>
  Protocol::socket::template rebind_executor< typename ExecutionContext::executor_type >::other ``[link boost_asio.reference.basic_socket_acceptor.accept.overload10 accept]``(
      ExecutionContext & context,
      boost::system::error_code & ec,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload10 more...]]``

  Protocol::socket::template rebind_executor< executor_type >::other ``[link boost_asio.reference.basic_socket_acceptor.accept.overload11 accept]``(
      endpoint_type & peer_endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload11 more...]]``

  Protocol::socket::template rebind_executor< executor_type >::other ``[link boost_asio.reference.basic_socket_acceptor.accept.overload12 accept]``(
      endpoint_type & peer_endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload12 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  Protocol::socket::template rebind_executor< Executor1 >::other ``[link boost_asio.reference.basic_socket_acceptor.accept.overload13 accept]``(
      const Executor1 & ex,
      endpoint_type & peer_endpoint,
      typename constraint< is_executor< Executor1 >::value||execution::is_executor< Executor1 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload13 more...]]``

  template<
      typename ExecutionContext>
  Protocol::socket::template rebind_executor< typename ExecutionContext::executor_type >::other ``[link boost_asio.reference.basic_socket_acceptor.accept.overload14 accept]``(
      ExecutionContext & context,
      endpoint_type & peer_endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload14 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  Protocol::socket::template rebind_executor< Executor1 >::other ``[link boost_asio.reference.basic_socket_acceptor.accept.overload15 accept]``(
      const executor_type & ex,
      endpoint_type & peer_endpoint,
      boost::system::error_code & ec,
      typename constraint< is_executor< Executor1 >::value||execution::is_executor< Executor1 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload15 more...]]``

  template<
      typename ExecutionContext>
  Protocol::socket::template rebind_executor< typename ExecutionContext::executor_type >::other ``[link boost_asio.reference.basic_socket_acceptor.accept.overload16 accept]``(
      ExecutionContext & context,
      endpoint_type & peer_endpoint,
      boost::system::error_code & ec,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.accept.overload16 more...]]``


[section:overload1 basic_socket_acceptor::accept (1 of 16 overloads)]


Accept a new connection. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  void accept(
      basic_socket< Protocol1, Executor1 > & peer,
      typename constraint< is_convertible< Protocol, Protocol1 >::value >::type  = 0);


This function is used to accept a new connection from a peer into the given socket. The function call will block until a new connection has been accepted successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[peer][The socket into which the new connection will be accepted.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::socket socket(my_context);
   acceptor.accept(socket);







[endsect]



[section:overload2 basic_socket_acceptor::accept (2 of 16 overloads)]


Accept a new connection. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  void accept(
      basic_socket< Protocol1, Executor1 > & peer,
      boost::system::error_code & ec,
      typename constraint< is_convertible< Protocol, Protocol1 >::value >::type  = 0);


This function is used to accept a new connection from a peer into the given socket. The function call will block until a new connection has been accepted successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[peer][The socket into which the new connection will be accepted.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::socket socket(my_context);
   boost::system::error_code ec;
   acceptor.accept(socket, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]



[section:overload3 basic_socket_acceptor::accept (3 of 16 overloads)]


Accept a new connection and obtain the endpoint of the peer. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  void accept(
      basic_socket< protocol_type, Executor1 > & peer,
      endpoint_type & peer_endpoint);


This function is used to accept a new connection from a peer into the given socket, and additionally provide the endpoint of the remote peer. The function call will block until a new connection has been accepted successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[peer][The socket into which the new connection will be accepted.]]

[[peer_endpoint][An endpoint object which will receive the endpoint of the remote peer.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint;
   acceptor.accept(socket, endpoint);







[endsect]



[section:overload4 basic_socket_acceptor::accept (4 of 16 overloads)]


Accept a new connection and obtain the endpoint of the peer. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  void accept(
      basic_socket< protocol_type, Executor1 > & peer,
      endpoint_type & peer_endpoint,
      boost::system::error_code & ec);


This function is used to accept a new connection from a peer into the given socket, and additionally provide the endpoint of the remote peer. The function call will block until a new connection has been accepted successfully or an error occurs.


[heading Parameters]
    

[variablelist
  
[[peer][The socket into which the new connection will be accepted.]]

[[peer_endpoint][An endpoint object which will receive the endpoint of the remote peer.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint;
   boost::system::error_code ec;
   acceptor.accept(socket, endpoint, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]



[section:overload5 basic_socket_acceptor::accept (5 of 16 overloads)]


Accept a new connection. 


  Protocol::socket::template rebind_executor< executor_type >::other accept();


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Return Value]
      
A socket object representing the newly accepted connection.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::socket socket(acceptor.accept());







[endsect]



[section:overload6 basic_socket_acceptor::accept (6 of 16 overloads)]


Accept a new connection. 


  Protocol::socket::template rebind_executor< executor_type >::other accept(
      boost::system::error_code & ec);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
On success, a socket object representing the newly accepted connection. On error, a socket object where `is_open()` is false.


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::socket socket(acceptor.accept(ec));
   if (ec)
   {
     // An error occurred.
   }







[endsect]



[section:overload7 basic_socket_acceptor::accept (7 of 16 overloads)]


Accept a new connection. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  Protocol::socket::template rebind_executor< Executor1 >::other accept(
      const Executor1 & ex,
      typename constraint< is_executor< Executor1 >::value||execution::is_executor< Executor1 >::value >::type  = 0);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor object to be used for the newly accepted socket.]]

]


[heading Return Value]
      
A socket object representing the newly accepted connection.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::socket socket(acceptor.accept());







[endsect]



[section:overload8 basic_socket_acceptor::accept (8 of 16 overloads)]


Accept a new connection. 


  template<
      typename ExecutionContext>
  Protocol::socket::template rebind_executor< typename ExecutionContext::executor_type >::other accept(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[context][The I/O execution context object to be used for the newly accepted socket.]]

]


[heading Return Value]
      
A socket object representing the newly accepted connection.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::socket socket(acceptor.accept());







[endsect]



[section:overload9 basic_socket_acceptor::accept (9 of 16 overloads)]


Accept a new connection. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  Protocol::socket::template rebind_executor< Executor1 >::other accept(
      const Executor1 & ex,
      boost::system::error_code & ec,
      typename constraint< is_executor< Executor1 >::value||execution::is_executor< Executor1 >::value >::type  = 0);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor object to be used for the newly accepted socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
On success, a socket object representing the newly accepted connection. On error, a socket object where `is_open()` is false.


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::socket socket(acceptor.accept(my_context2, ec));
   if (ec)
   {
     // An error occurred.
   }







[endsect]



[section:overload10 basic_socket_acceptor::accept (10 of 16 overloads)]


Accept a new connection. 


  template<
      typename ExecutionContext>
  Protocol::socket::template rebind_executor< typename ExecutionContext::executor_type >::other accept(
      ExecutionContext & context,
      boost::system::error_code & ec,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[context][The I/O execution context object to be used for the newly accepted socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
On success, a socket object representing the newly accepted connection. On error, a socket object where `is_open()` is false.


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::socket socket(acceptor.accept(my_context2, ec));
   if (ec)
   {
     // An error occurred.
   }







[endsect]



[section:overload11 basic_socket_acceptor::accept (11 of 16 overloads)]


Accept a new connection. 


  Protocol::socket::template rebind_executor< executor_type >::other accept(
      endpoint_type & peer_endpoint);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written.]]

]


[heading Return Value]
      
A socket object representing the newly accepted connection.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint;
   boost::asio::ip::tcp::socket socket(acceptor.accept(endpoint));







[endsect]



[section:overload12 basic_socket_acceptor::accept (12 of 16 overloads)]


Accept a new connection. 


  Protocol::socket::template rebind_executor< executor_type >::other accept(
      endpoint_type & peer_endpoint,
      boost::system::error_code & ec);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
On success, a socket object representing the newly accepted connection. On error, a socket object where `is_open()` is false.


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint;
   boost::asio::ip::tcp::socket socket(acceptor.accept(endpoint, ec));
   if (ec)
   {
     // An error occurred.
   }







[endsect]



[section:overload13 basic_socket_acceptor::accept (13 of 16 overloads)]


Accept a new connection. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  Protocol::socket::template rebind_executor< Executor1 >::other accept(
      const Executor1 & ex,
      endpoint_type & peer_endpoint,
      typename constraint< is_executor< Executor1 >::value||execution::is_executor< Executor1 >::value >::type  = 0);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor object to be used for the newly accepted socket.]]

[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written.]]

]


[heading Return Value]
      
A socket object representing the newly accepted connection.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint;
   boost::asio::ip::tcp::socket socket(
       acceptor.accept(my_context2, endpoint));







[endsect]



[section:overload14 basic_socket_acceptor::accept (14 of 16 overloads)]


Accept a new connection. 


  template<
      typename ExecutionContext>
  Protocol::socket::template rebind_executor< typename ExecutionContext::executor_type >::other accept(
      ExecutionContext & context,
      endpoint_type & peer_endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[context][The I/O execution context object to be used for the newly accepted socket.]]

[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written.]]

]


[heading Return Value]
      
A socket object representing the newly accepted connection.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint;
   boost::asio::ip::tcp::socket socket(
       acceptor.accept(my_context2, endpoint));







[endsect]



[section:overload15 basic_socket_acceptor::accept (15 of 16 overloads)]


Accept a new connection. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  Protocol::socket::template rebind_executor< Executor1 >::other accept(
      const executor_type & ex,
      endpoint_type & peer_endpoint,
      boost::system::error_code & ec,
      typename constraint< is_executor< Executor1 >::value||execution::is_executor< Executor1 >::value >::type  = 0);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor object to be used for the newly accepted socket.]]

[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
On success, a socket object representing the newly accepted connection. On error, a socket object where `is_open()` is false.


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint;
   boost::asio::ip::tcp::socket socket(
       acceptor.accept(my_context2, endpoint, ec));
   if (ec)
   {
     // An error occurred.
   }







[endsect]



[section:overload16 basic_socket_acceptor::accept (16 of 16 overloads)]


Accept a new connection. 


  template<
      typename ExecutionContext>
  Protocol::socket::template rebind_executor< typename ExecutionContext::executor_type >::other accept(
      ExecutionContext & context,
      endpoint_type & peer_endpoint,
      boost::system::error_code & ec,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[context][The I/O execution context object to be used for the newly accepted socket.]]

[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
On success, a socket object representing the newly accepted connection. On error, a socket object where `is_open()` is false.


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint;
   boost::asio::ip::tcp::socket socket(
       acceptor.accept(my_context2, endpoint, ec));
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:assign basic_socket_acceptor::assign]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.assign..assign..basic_socket_acceptor] 
Assigns an existing native acceptor to the acceptor. 


  void ``[link boost_asio.reference.basic_socket_acceptor.assign.overload1 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_acceptor);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.assign.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket_acceptor.assign.overload2 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_acceptor,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.assign.overload2 more...]]``


[section:overload1 basic_socket_acceptor::assign (1 of 2 overloads)]


Assigns an existing native acceptor to the acceptor. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_acceptor);



[endsect]



[section:overload2 basic_socket_acceptor::assign (2 of 2 overloads)]


Assigns an existing native acceptor to the acceptor. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_acceptor,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:async_accept basic_socket_acceptor::async_accept]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.async_accept..async_accept..basic_socket_acceptor] 
Start an asynchronous accept. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.AcceptHandler AcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_socket_acceptor.async_accept.overload1 async_accept]``(
      basic_socket< Protocol1, Executor1 > & peer,
      AcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< Protocol, Protocol1 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.async_accept.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.AcceptHandler AcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_socket_acceptor.async_accept.overload2 async_accept]``(
      basic_socket< protocol_type, Executor1 > & peer,
      endpoint_type & peer_endpoint,
      AcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.async_accept.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.MoveAcceptHandler MoveAcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_socket_acceptor.async_accept.overload3 async_accept]``(
      MoveAcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.async_accept.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.MoveAcceptHandler MoveAcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_socket_acceptor.async_accept.overload4 async_accept]``(
      const Executor1 & ex,
      MoveAcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_executor< Executor1 >::value||execution::is_executor< Executor1 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.async_accept.overload4 more...]]``

  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.MoveAcceptHandler MoveAcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_socket_acceptor.async_accept.overload5 async_accept]``(
      ExecutionContext & context,
      MoveAcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.async_accept.overload5 more...]]``

  template<
      typename ``[link boost_asio.reference.MoveAcceptHandler MoveAcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_socket_acceptor.async_accept.overload6 async_accept]``(
      endpoint_type & peer_endpoint,
      MoveAcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.async_accept.overload6 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.MoveAcceptHandler MoveAcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_socket_acceptor.async_accept.overload7 async_accept]``(
      const Executor1 & ex,
      endpoint_type & peer_endpoint,
      MoveAcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_executor< Executor1 >::value||execution::is_executor< Executor1 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.async_accept.overload7 more...]]``

  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.MoveAcceptHandler MoveAcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_socket_acceptor.async_accept.overload8 async_accept]``(
      ExecutionContext & context,
      endpoint_type & peer_endpoint,
      MoveAcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.async_accept.overload8 more...]]``


[section:overload1 basic_socket_acceptor::async_accept (1 of 8 overloads)]


Start an asynchronous accept. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.AcceptHandler AcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_accept(
      basic_socket< Protocol1, Executor1 > & peer,
      AcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< Protocol, Protocol1 >::value >::type  = 0);


This function is used to asynchronously accept a new connection into a socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[peer][The socket into which the new connection will be accepted. Ownership of the peer object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[handler][The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void accept_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Accept succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::socket socket(my_context);
   acceptor.async_accept(socket, accept_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_socket_acceptor::async_accept (2 of 8 overloads)]


Start an asynchronous accept. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.AcceptHandler AcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_accept(
      basic_socket< protocol_type, Executor1 > & peer,
      endpoint_type & peer_endpoint,
      AcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously accept a new connection into a socket, and additionally obtain the endpoint of the remote peer. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[peer][The socket into which the new connection will be accepted. Ownership of the peer object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written. Ownership of the peer\_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[handler][The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload3 basic_socket_acceptor::async_accept (3 of 8 overloads)]


Start an asynchronous accept. 


  template<
      typename ``[link boost_asio.reference.MoveAcceptHandler MoveAcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_accept(
      MoveAcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously accept a new connection. The function call always returns immediately.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,
     // On success, the newly accepted socket.
     typename Protocol::socket::template
       rebind_executor<executor_type>::other peer
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void accept_handler(const boost::system::error_code& error,
       boost::asio::ip::tcp::socket peer)
   {
     if (!error)
     {
       // Accept succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   acceptor.async_accept(accept_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload4 basic_socket_acceptor::async_accept (4 of 8 overloads)]


Start an asynchronous accept. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.MoveAcceptHandler MoveAcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_accept(
      const Executor1 & ex,
      MoveAcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_executor< Executor1 >::value||execution::is_executor< Executor1 >::value >::type  = 0);


This function is used to asynchronously accept a new connection. The function call always returns immediately.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor object to be used for the newly accepted socket.]]

[[handler][The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     typename Protocol::socket::template rebind_executor<
       Executor1>::other peer // On success, the newly accepted socket.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void accept_handler(const boost::system::error_code& error,
       boost::asio::ip::tcp::socket peer)
   {
     if (!error)
     {
       // Accept succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   acceptor.async_accept(my_context2, accept_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload5 basic_socket_acceptor::async_accept (5 of 8 overloads)]


Start an asynchronous accept. 


  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.MoveAcceptHandler MoveAcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_accept(
      ExecutionContext & context,
      MoveAcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This function is used to asynchronously accept a new connection. The function call always returns immediately.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[context][The I/O execution context object to be used for the newly accepted socket.]]

[[handler][The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     typename Protocol::socket::template rebind_executor<
       typename ExecutionContext::executor_type>::other peer
         // On success, the newly accepted socket.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void accept_handler(const boost::system::error_code& error,
       boost::asio::ip::tcp::socket peer)
   {
     if (!error)
     {
       // Accept succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   acceptor.async_accept(my_context2, accept_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload6 basic_socket_acceptor::async_accept (6 of 8 overloads)]


Start an asynchronous accept. 


  template<
      typename ``[link boost_asio.reference.MoveAcceptHandler MoveAcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_accept(
      endpoint_type & peer_endpoint,
      MoveAcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously accept a new connection. The function call always returns immediately.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written. Ownership of the peer\_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[handler][The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     // Result of operation.
     const boost::system::error_code& error,
     // On success, the newly accepted socket.
     typename Protocol::socket::template
       rebind_executor<executor_type>::other peer
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void accept_handler(const boost::system::error_code& error,
       boost::asio::ip::tcp::socket peer)
   {
     if (!error)
     {
       // Accept succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint;
   acceptor.async_accept(endpoint, accept_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload7 basic_socket_acceptor::async_accept (7 of 8 overloads)]


Start an asynchronous accept. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.MoveAcceptHandler MoveAcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_accept(
      const Executor1 & ex,
      endpoint_type & peer_endpoint,
      MoveAcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_executor< Executor1 >::value||execution::is_executor< Executor1 >::value >::type  = 0);


This function is used to asynchronously accept a new connection. The function call always returns immediately.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor object to be used for the newly accepted socket.]]

[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written. Ownership of the peer\_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[handler][The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     typename Protocol::socket::template rebind_executor<
       Executor1>::other peer // On success, the newly accepted socket.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void accept_handler(const boost::system::error_code& error,
       boost::asio::ip::tcp::socket peer)
   {
     if (!error)
     {
       // Accept succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint;
   acceptor.async_accept(my_context2, endpoint, accept_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload8 basic_socket_acceptor::async_accept (8 of 8 overloads)]


Start an asynchronous accept. 


  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.MoveAcceptHandler MoveAcceptHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_accept(
      ExecutionContext & context,
      endpoint_type & peer_endpoint,
      MoveAcceptHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This function is used to asynchronously accept a new connection. The function call always returns immediately.

This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.


[heading Parameters]
    

[variablelist
  
[[context][The I/O execution context object to be used for the newly accepted socket.]]

[[peer_endpoint][An endpoint object into which the endpoint of the remote peer will be written. Ownership of the peer\_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.]]

[[handler][The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     typename Protocol::socket::template rebind_executor<
       typename ExecutionContext::executor_type>::other peer
         // On success, the newly accepted socket.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void accept_handler(const boost::system::error_code& error,
       boost::asio::ip::tcp::socket peer)
   {
     if (!error)
     {
       // Accept succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint;
   acceptor.async_accept(my_context2, endpoint, accept_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]


[section:async_wait basic_socket_acceptor::async_wait]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.async_wait..async_wait..basic_socket_acceptor] 
Asynchronously wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. 


  template<
      typename ``[link boost_asio.reference.WaitHandler WaitHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_wait(
      wait_type w,
      WaitHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to perform an asynchronous wait for an acceptor to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired acceptor state.]]

[[handler][The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void wait_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Wait succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   acceptor.async_wait(
       boost::asio::ip::tcp::acceptor::wait_read,
       wait_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:basic_socket_acceptor basic_socket_acceptor::basic_socket_acceptor]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.basic_socket_acceptor..basic_socket_acceptor..basic_socket_acceptor] 
Construct an acceptor without opening it. 


  explicit ``[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload1 basic_socket_acceptor]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload2 basic_socket_acceptor]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload2 more...]]``


Construct an open acceptor. 


  ``[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload3 basic_socket_acceptor]``(
      const executor_type & ex,
      const protocol_type & protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload4 basic_socket_acceptor]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload4 more...]]``


Construct an acceptor opened on the given endpoint. 


  ``[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload5 basic_socket_acceptor]``(
      const executor_type & ex,
      const endpoint_type & endpoint,
      bool reuse_addr = true);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload5 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload6 basic_socket_acceptor]``(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      bool reuse_addr = true,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload6 more...]]``


Construct a [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] on an existing native acceptor. 


  ``[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload7 basic_socket_acceptor]``(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_acceptor);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload7 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload8 basic_socket_acceptor]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_acceptor,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload8 more...]]``


Move-construct a [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] from another. 


  ``[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload9 basic_socket_acceptor]``(
      basic_socket_acceptor && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload9 more...]]``


Move-construct a [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] from an acceptor of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload10 basic_socket_acceptor]``(
      basic_socket_acceptor< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor.overload10 more...]]``


[section:overload1 basic_socket_acceptor::basic_socket_acceptor (1 of 10 overloads)]


Construct an acceptor without opening it. 


  basic_socket_acceptor(
      const executor_type & ex);


This constructor creates an acceptor without opening it to listen for new connections. The `open()` function must be called before the acceptor can accept new socket connections.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the acceptor will use, by default, to dispatch handlers for any asynchronous operations performed on the acceptor. ]]

]




[endsect]



[section:overload2 basic_socket_acceptor::basic_socket_acceptor (2 of 10 overloads)]


Construct an acceptor without opening it. 


  template<
      typename ExecutionContext>
  basic_socket_acceptor(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates an acceptor without opening it to listen for new connections. The `open()` function must be called before the acceptor can accept new socket connections.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the acceptor will use, by default, to dispatch handlers for any asynchronous operations performed on the acceptor. ]]

]




[endsect]



[section:overload3 basic_socket_acceptor::basic_socket_acceptor (3 of 10 overloads)]


Construct an open acceptor. 


  basic_socket_acceptor(
      const executor_type & ex,
      const protocol_type & protocol);


This constructor creates an acceptor and automatically opens it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the acceptor will use, by default, to dispatch handlers for any asynchronous operations performed on the acceptor.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_socket_acceptor::basic_socket_acceptor (4 of 10 overloads)]


Construct an open acceptor. 


  template<
      typename ExecutionContext>
  basic_socket_acceptor(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates an acceptor and automatically opens it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the acceptor will use, by default, to dispatch handlers for any asynchronous operations performed on the acceptor.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_socket_acceptor::basic_socket_acceptor (5 of 10 overloads)]


Construct an acceptor opened on the given endpoint. 


  basic_socket_acceptor(
      const executor_type & ex,
      const endpoint_type & endpoint,
      bool reuse_addr = true);


This constructor creates an acceptor and automatically opens it to listen for new connections on the specified endpoint.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the acceptor will use, by default, to dispatch handlers for any asynchronous operations performed on the acceptor.]]

[[endpoint][An endpoint on the local machine on which the acceptor will listen for new connections.]]

[[reuse_addr][Whether the constructor should set the socket option `socket_base::reuse_address`.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This constructor is equivalent to the following code: 

   basic_socket_acceptor<Protocol> acceptor(my_context);
   acceptor.open(endpoint.protocol());
   if (reuse_addr)
     acceptor.set_option(socket_base::reuse_address(true));
   acceptor.bind(endpoint);
   acceptor.listen();







[endsect]



[section:overload6 basic_socket_acceptor::basic_socket_acceptor (6 of 10 overloads)]


Construct an acceptor opened on the given endpoint. 


  template<
      typename ExecutionContext>
  basic_socket_acceptor(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      bool reuse_addr = true,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates an acceptor and automatically opens it to listen for new connections on the specified endpoint.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the acceptor will use, by default, to dispatch handlers for any asynchronous operations performed on the acceptor.]]

[[endpoint][An endpoint on the local machine on which the acceptor will listen for new connections.]]

[[reuse_addr][Whether the constructor should set the socket option `socket_base::reuse_address`.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This constructor is equivalent to the following code: 

   basic_socket_acceptor<Protocol> acceptor(my_context);
   acceptor.open(endpoint.protocol());
   if (reuse_addr)
     acceptor.set_option(socket_base::reuse_address(true));
   acceptor.bind(endpoint);
   acceptor.listen();







[endsect]



[section:overload7 basic_socket_acceptor::basic_socket_acceptor (7 of 10 overloads)]


Construct a [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] on an existing native acceptor. 


  basic_socket_acceptor(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_acceptor);


This constructor creates an acceptor object to hold an existing native acceptor.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the acceptor will use, by default, to dispatch handlers for any asynchronous operations performed on the acceptor.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_acceptor][A native acceptor.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 basic_socket_acceptor::basic_socket_acceptor (8 of 10 overloads)]


Construct a [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] on an existing native acceptor. 


  template<
      typename ExecutionContext>
  basic_socket_acceptor(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_acceptor,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates an acceptor object to hold an existing native acceptor.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the acceptor will use, by default, to dispatch handlers for any asynchronous operations performed on the acceptor.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_acceptor][A native acceptor.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload9 basic_socket_acceptor::basic_socket_acceptor (9 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] from another. 


  basic_socket_acceptor(
      basic_socket_acceptor && other);


This constructor moves an acceptor from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket_acceptor(const executor_type&)` constructor. 




[endsect]



[section:overload10 basic_socket_acceptor::basic_socket_acceptor (10 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] from an acceptor of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_socket_acceptor(
      basic_socket_acceptor< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);


This constructor moves an acceptor from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket_acceptor(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:bind basic_socket_acceptor::bind]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.bind..bind..basic_socket_acceptor] 
Bind the acceptor to the given local endpoint. 


  void ``[link boost_asio.reference.basic_socket_acceptor.bind.overload1 bind]``(
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.bind.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket_acceptor.bind.overload2 bind]``(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.bind.overload2 more...]]``


[section:overload1 basic_socket_acceptor::bind (1 of 2 overloads)]


Bind the acceptor to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint);


This function binds the socket acceptor to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket acceptor will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 12345);
   acceptor.open(endpoint.protocol());
   acceptor.bind(endpoint);







[endsect]



[section:overload2 basic_socket_acceptor::bind (2 of 2 overloads)]


Bind the acceptor to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);


This function binds the socket acceptor to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket acceptor will be bound.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), 12345);
   acceptor.open(endpoint.protocol());
   boost::system::error_code ec;
   acceptor.bind(endpoint, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:broadcast basic_socket_acceptor::broadcast]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.broadcast..broadcast..basic_socket_acceptor] 
Socket option to permit sending of broadcast messages. 


  typedef implementation_defined broadcast;



Implements the SOL\_SOCKET/SO\_BROADCAST socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:bytes_readable basic_socket_acceptor::bytes_readable]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.bytes_readable..bytes_readable..basic_socket_acceptor] 
IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::bytes_readable command(true);
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:cancel basic_socket_acceptor::cancel]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.cancel..cancel..basic_socket_acceptor] 
Cancel all asynchronous operations associated with the acceptor. 


  void ``[link boost_asio.reference.basic_socket_acceptor.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket_acceptor.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.cancel.overload2 more...]]``


[section:overload1 basic_socket_acceptor::cancel (1 of 2 overloads)]


Cancel all asynchronous operations associated with the acceptor. 


  void cancel();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_socket_acceptor::cancel (2 of 2 overloads)]


Cancel all asynchronous operations associated with the acceptor. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:close basic_socket_acceptor::close]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.close..close..basic_socket_acceptor] 
Close the acceptor. 


  void ``[link boost_asio.reference.basic_socket_acceptor.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.close.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket_acceptor.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.close.overload2 more...]]``


[section:overload1 basic_socket_acceptor::close (1 of 2 overloads)]


Close the acceptor. 


  void close();


This function is used to close the acceptor. Any asynchronous accept operations will be cancelled immediately.

A subsequent call to `open()` is required before the acceptor can again be used to again perform socket accept operations.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_socket_acceptor::close (2 of 2 overloads)]


Close the acceptor. 


  void close(
      boost::system::error_code & ec);


This function is used to close the acceptor. Any asynchronous accept operations will be cancelled immediately.

A subsequent call to `open()` is required before the acceptor can again be used to again perform socket accept operations.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::system::error_code ec;
   acceptor.close(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:debug basic_socket_acceptor::debug]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.debug..debug..basic_socket_acceptor] 
Socket option to enable socket-level debugging. 


  typedef implementation_defined debug;



Implements the SOL\_SOCKET/SO\_DEBUG socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:do_not_route basic_socket_acceptor::do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.do_not_route..do_not_route..basic_socket_acceptor] 
Socket option to prevent routing, use local interfaces only. 


  typedef implementation_defined do_not_route;



Implements the SOL\_SOCKET/SO\_DONTROUTE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:enable_connection_aborted basic_socket_acceptor::enable_connection_aborted]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.enable_connection_aborted..enable_connection_aborted..basic_socket_acceptor] 
Socket option to report aborted connections on accept. 


  typedef implementation_defined enable_connection_aborted;



Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:endpoint_type basic_socket_acceptor::endpoint_type]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.endpoint_type..endpoint_type..basic_socket_acceptor] 
The endpoint type. 


  typedef Protocol::endpoint endpoint_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:executor_type basic_socket_acceptor::executor_type]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.executor_type..executor_type..basic_socket_acceptor] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_socket_acceptor::get_executor]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.get_executor..get_executor..basic_socket_acceptor] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:get_option basic_socket_acceptor::get_option]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.get_option..get_option..basic_socket_acceptor] 
Get an option from the acceptor. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_socket_acceptor.get_option.overload1 get_option]``(
      GettableSocketOption & option) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.get_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_socket_acceptor.get_option.overload2 get_option]``(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.get_option.overload2 more...]]``


[section:overload1 basic_socket_acceptor::get_option (1 of 2 overloads)]


Get an option from the acceptor. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option) const;


This function is used to get the current value of an option on the acceptor.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the acceptor.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_REUSEADDR option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::acceptor::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.get();







[endsect]



[section:overload2 basic_socket_acceptor::get_option (2 of 2 overloads)]


Get an option from the acceptor. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;


This function is used to get the current value of an option on the acceptor.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the acceptor.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_REUSEADDR option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::acceptor::reuse_address option;
   boost::system::error_code ec;
   acceptor.get_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }
   bool is_set = option.get();







[endsect]


[endsect]

[section:io_control basic_socket_acceptor::io_control]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.io_control..io_control..basic_socket_acceptor] 
Perform an IO control command on the acceptor. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_socket_acceptor.io_control.overload1 io_control]``(
      IoControlCommand & command);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.io_control.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_socket_acceptor.io_control.overload2 io_control]``(
      IoControlCommand & command,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.io_control.overload2 more...]]``


[section:overload1 basic_socket_acceptor::io_control (1 of 2 overloads)]


Perform an IO control command on the acceptor. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command);


This function is used to execute an IO control command on the acceptor.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the acceptor.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::acceptor::non_blocking_io command(true);
   socket.io_control(command);







[endsect]



[section:overload2 basic_socket_acceptor::io_control (2 of 2 overloads)]


Perform an IO control command on the acceptor. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command,
      boost::system::error_code & ec);


This function is used to execute an IO control command on the acceptor.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the acceptor.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::acceptor::non_blocking_io command(true);
   boost::system::error_code ec;
   socket.io_control(command, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:is_open basic_socket_acceptor::is_open]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.is_open..is_open..basic_socket_acceptor] 
Determine whether the acceptor is open. 


  bool is_open() const;



[endsect]



[section:keep_alive basic_socket_acceptor::keep_alive]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.keep_alive..keep_alive..basic_socket_acceptor] 
Socket option to send keep-alives. 


  typedef implementation_defined keep_alive;



Implements the SOL\_SOCKET/SO\_KEEPALIVE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:linger basic_socket_acceptor::linger]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.linger..linger..basic_socket_acceptor] 
Socket option to specify whether the socket lingers on close if unsent data is present. 


  typedef implementation_defined linger;



Implements the SOL\_SOCKET/SO\_LINGER socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option(true, 30);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option;
   socket.get_option(option);
   bool is_set = option.enabled();
   unsigned short timeout = option.timeout();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:listen basic_socket_acceptor::listen]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.listen..listen..basic_socket_acceptor] 
Place the acceptor into the state where it will listen for new connections. 


  void ``[link boost_asio.reference.basic_socket_acceptor.listen.overload1 listen]``(
      int backlog = socket_base::max_listen_connections);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.listen.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket_acceptor.listen.overload2 listen]``(
      int backlog,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.listen.overload2 more...]]``


[section:overload1 basic_socket_acceptor::listen (1 of 2 overloads)]


Place the acceptor into the state where it will listen for new connections. 


  void listen(
      int backlog = socket_base::max_listen_connections);


This function puts the socket acceptor into the state where it may accept new connections.


[heading Parameters]
    

[variablelist
  
[[backlog][The maximum length of the queue of pending connections.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_socket_acceptor::listen (2 of 2 overloads)]


Place the acceptor into the state where it will listen for new connections. 


  void listen(
      int backlog,
      boost::system::error_code & ec);


This function puts the socket acceptor into the state where it may accept new connections.


[heading Parameters]
    

[variablelist
  
[[backlog][The maximum length of the queue of pending connections.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::system::error_code ec;
   acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:local_endpoint basic_socket_acceptor::local_endpoint]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.local_endpoint..local_endpoint..basic_socket_acceptor] 
Get the local endpoint of the acceptor. 


  endpoint_type ``[link boost_asio.reference.basic_socket_acceptor.local_endpoint.overload1 local_endpoint]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.local_endpoint.overload1 more...]]``

  endpoint_type ``[link boost_asio.reference.basic_socket_acceptor.local_endpoint.overload2 local_endpoint]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.local_endpoint.overload2 more...]]``


[section:overload1 basic_socket_acceptor::local_endpoint (1 of 2 overloads)]


Get the local endpoint of the acceptor. 


  endpoint_type local_endpoint() const;


This function is used to obtain the locally bound endpoint of the acceptor.


[heading Return Value]
      
An object that represents the local endpoint of the acceptor.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint();







[endsect]



[section:overload2 basic_socket_acceptor::local_endpoint (2 of 2 overloads)]


Get the local endpoint of the acceptor. 


  endpoint_type local_endpoint(
      boost::system::error_code & ec) const;


This function is used to obtain the locally bound endpoint of the acceptor.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the local endpoint of the acceptor. Returns a default-constructed endpoint object if an error occurred and the error handler did not throw an exception.


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::system::error_code ec;
   boost::asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:max_connections basic_socket_acceptor::max_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.max_connections..max_connections..basic_socket_acceptor] 
(Deprecated: Use max\_listen\_connections.) The maximum length of the queue of pending incoming connections. 


  static const int max_connections = implementation_defined;



[endsect]



[section:max_listen_connections basic_socket_acceptor::max_listen_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.max_listen_connections..max_listen_connections..basic_socket_acceptor] 
The maximum length of the queue of pending incoming connections. 


  static const int max_listen_connections = implementation_defined;



[endsect]



[section:message_do_not_route basic_socket_acceptor::message_do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.message_do_not_route..message_do_not_route..basic_socket_acceptor] 
Specify that the data should not be subject to routing. 


  static const int message_do_not_route = implementation_defined;



[endsect]



[section:message_end_of_record basic_socket_acceptor::message_end_of_record]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.message_end_of_record..message_end_of_record..basic_socket_acceptor] 
Specifies that the data marks the end of a record. 


  static const int message_end_of_record = implementation_defined;



[endsect]



[section:message_flags basic_socket_acceptor::message_flags]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.message_flags..message_flags..basic_socket_acceptor] 
Bitmask type for flags that can be passed to send and receive operations. 


  typedef int message_flags;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:message_out_of_band basic_socket_acceptor::message_out_of_band]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.message_out_of_band..message_out_of_band..basic_socket_acceptor] 
Process out-of-band data. 


  static const int message_out_of_band = implementation_defined;



[endsect]



[section:message_peek basic_socket_acceptor::message_peek]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.message_peek..message_peek..basic_socket_acceptor] 
Peek at incoming data without removing it from the input queue. 


  static const int message_peek = implementation_defined;



[endsect]



[section:native_handle basic_socket_acceptor::native_handle]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.native_handle..native_handle..basic_socket_acceptor] 
Get the native acceptor representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the acceptor. This is intended to allow access to native acceptor functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_socket_acceptor::native_handle_type]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.native_handle_type..native_handle_type..basic_socket_acceptor] 
The native representation of an acceptor. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:native_non_blocking basic_socket_acceptor::native_non_blocking]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.native_non_blocking..native_non_blocking..basic_socket_acceptor] 
Gets the non-blocking mode of the native acceptor implementation. 


  bool ``[link boost_asio.reference.basic_socket_acceptor.native_non_blocking.overload1 native_non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.native_non_blocking.overload1 more...]]``


Sets the non-blocking mode of the native acceptor implementation. 


  void ``[link boost_asio.reference.basic_socket_acceptor.native_non_blocking.overload2 native_non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.native_non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.basic_socket_acceptor.native_non_blocking.overload3 native_non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.native_non_blocking.overload3 more...]]``


[section:overload1 basic_socket_acceptor::native_non_blocking (1 of 3 overloads)]


Gets the non-blocking mode of the native acceptor implementation. 


  bool native_non_blocking() const;


This function is used to retrieve the non-blocking mode of the underlying native acceptor. This mode has no effect on the behaviour of the acceptor object's synchronous operations.


[heading Return Value]
      
`true` if the underlying acceptor is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).


[heading Remarks]
      
The current non-blocking mode is cached by the acceptor object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native acceptor. 




[endsect]



[section:overload2 basic_socket_acceptor::native_non_blocking (2 of 3 overloads)]


Sets the non-blocking mode of the native acceptor implementation. 


  void native_non_blocking(
      bool mode);


This function is used to modify the non-blocking mode of the underlying native acceptor. It has no effect on the behaviour of the acceptor object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying acceptor is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense. ]]

]




[endsect]



[section:overload3 basic_socket_acceptor::native_non_blocking (3 of 3 overloads)]


Sets the non-blocking mode of the native acceptor implementation. 


  void native_non_blocking(
      bool mode,
      boost::system::error_code & ec);


This function is used to modify the non-blocking mode of the underlying native acceptor. It has no effect on the behaviour of the acceptor object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying acceptor is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense. ]]

]




[endsect]


[endsect]

[section:non_blocking basic_socket_acceptor::non_blocking]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.non_blocking..non_blocking..basic_socket_acceptor] 
Gets the non-blocking mode of the acceptor. 


  bool ``[link boost_asio.reference.basic_socket_acceptor.non_blocking.overload1 non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.non_blocking.overload1 more...]]``


Sets the non-blocking mode of the acceptor. 


  void ``[link boost_asio.reference.basic_socket_acceptor.non_blocking.overload2 non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.basic_socket_acceptor.non_blocking.overload3 non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.non_blocking.overload3 more...]]``


[section:overload1 basic_socket_acceptor::non_blocking (1 of 3 overloads)]


Gets the non-blocking mode of the acceptor. 


  bool non_blocking() const;



[heading Return Value]
      
`true` if the acceptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload2 basic_socket_acceptor::non_blocking (2 of 3 overloads)]


Sets the non-blocking mode of the acceptor. 


  void non_blocking(
      bool mode);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the acceptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload3 basic_socket_acceptor::non_blocking (3 of 3 overloads)]


Sets the non-blocking mode of the acceptor. 


  void non_blocking(
      bool mode,
      boost::system::error_code & ec);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the acceptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]


[endsect]

[section:open basic_socket_acceptor::open]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.open..open..basic_socket_acceptor] 
Open the acceptor using the specified protocol. 


  void ``[link boost_asio.reference.basic_socket_acceptor.open.overload1 open]``(
      const protocol_type & protocol = protocol_type());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.open.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket_acceptor.open.overload2 open]``(
      const protocol_type & protocol,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.open.overload2 more...]]``


[section:overload1 basic_socket_acceptor::open (1 of 2 overloads)]


Open the acceptor using the specified protocol. 


  void open(
      const protocol_type & protocol = protocol_type());


This function opens the socket acceptor so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying which protocol is to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   acceptor.open(boost::asio::ip::tcp::v4());







[endsect]



[section:overload2 basic_socket_acceptor::open (2 of 2 overloads)]


Open the acceptor using the specified protocol. 


  void open(
      const protocol_type & protocol,
      boost::system::error_code & ec);


This function opens the socket acceptor so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying which protocol is to be used.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::acceptor acceptor(my_context);
   boost::system::error_code ec;
   acceptor.open(boost::asio::ip::tcp::v4(), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:operator_eq_ basic_socket_acceptor::operator=]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.operator_eq_..operator=..basic_socket_acceptor] 
Move-assign a [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] from another. 


  basic_socket_acceptor & ``[link boost_asio.reference.basic_socket_acceptor.operator_eq_.overload1 operator=]``(
      basic_socket_acceptor && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.operator_eq_.overload1 more...]]``


Move-assign a [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] from an acceptor of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value, basic_socket_acceptor & >::type ``[link boost_asio.reference.basic_socket_acceptor.operator_eq_.overload2 operator=]``(
      basic_socket_acceptor< Protocol1, Executor1 > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.operator_eq_.overload2 more...]]``


[section:overload1 basic_socket_acceptor::operator= (1 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] from another. 


  basic_socket_acceptor & operator=(
      basic_socket_acceptor && other);


This assignment operator moves an acceptor from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket_acceptor(const executor_type&)` constructor. 




[endsect]



[section:overload2 basic_socket_acceptor::operator= (2 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] from an acceptor of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value, basic_socket_acceptor & >::type operator=(
      basic_socket_acceptor< Protocol1, Executor1 > && other);


This assignment operator moves an acceptor from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_socket_acceptor(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:out_of_band_inline basic_socket_acceptor::out_of_band_inline]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.out_of_band_inline..out_of_band_inline..basic_socket_acceptor] 
Socket option for putting received out-of-band data inline. 


  typedef implementation_defined out_of_band_inline;



Implements the SOL\_SOCKET/SO\_OOBINLINE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option;
   socket.get_option(option);
   bool value = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol_type basic_socket_acceptor::protocol_type]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.protocol_type..protocol_type..basic_socket_acceptor] 
The protocol type. 


  typedef Protocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:receive_buffer_size basic_socket_acceptor::receive_buffer_size]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.receive_buffer_size..receive_buffer_size..basic_socket_acceptor] 
Socket option for the receive buffer size of a socket. 


  typedef implementation_defined receive_buffer_size;



Implements the SOL\_SOCKET/SO\_RCVBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:receive_low_watermark basic_socket_acceptor::receive_low_watermark]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.receive_low_watermark..receive_low_watermark..basic_socket_acceptor] 
Socket option for the receive low watermark. 


  typedef implementation_defined receive_low_watermark;



Implements the SOL\_SOCKET/SO\_RCVLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:release basic_socket_acceptor::release]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.release..release..basic_socket_acceptor] 
Release ownership of the underlying native acceptor. 


  native_handle_type ``[link boost_asio.reference.basic_socket_acceptor.release.overload1 release]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.release.overload1 more...]]``

  native_handle_type ``[link boost_asio.reference.basic_socket_acceptor.release.overload2 release]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.release.overload2 more...]]``


[section:overload1 basic_socket_acceptor::release (1 of 2 overloads)]


Release ownership of the underlying native acceptor. 


  native_handle_type release();


This function causes all outstanding asynchronous accept operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native acceptor is then transferred to the caller.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]



[section:overload2 basic_socket_acceptor::release (2 of 2 overloads)]


Release ownership of the underlying native acceptor. 


  native_handle_type release(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous accept operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native acceptor is then transferred to the caller.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]


[endsect]


[section:reuse_address basic_socket_acceptor::reuse_address]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.reuse_address..reuse_address..basic_socket_acceptor] 
Socket option to allow the socket to be bound to an address that is already in use. 


  typedef implementation_defined reuse_address;



Implements the SOL\_SOCKET/SO\_REUSEADDR socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:send_buffer_size basic_socket_acceptor::send_buffer_size]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.send_buffer_size..send_buffer_size..basic_socket_acceptor] 
Socket option for the send buffer size of a socket. 


  typedef implementation_defined send_buffer_size;



Implements the SOL\_SOCKET/SO\_SNDBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:send_low_watermark basic_socket_acceptor::send_low_watermark]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.send_low_watermark..send_low_watermark..basic_socket_acceptor] 
Socket option for the send low watermark. 


  typedef implementation_defined send_low_watermark;



Implements the SOL\_SOCKET/SO\_SNDLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:set_option basic_socket_acceptor::set_option]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.set_option..set_option..basic_socket_acceptor] 
Set an option on the acceptor. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void ``[link boost_asio.reference.basic_socket_acceptor.set_option.overload1 set_option]``(
      const SettableSocketOption & option);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.set_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void ``[link boost_asio.reference.basic_socket_acceptor.set_option.overload2 set_option]``(
      const SettableSocketOption & option,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.set_option.overload2 more...]]``


[section:overload1 basic_socket_acceptor::set_option (1 of 2 overloads)]


Set an option on the acceptor. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void set_option(
      const SettableSocketOption & option);


This function is used to set an option on the acceptor.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the acceptor.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Setting the SOL\_SOCKET/SO\_REUSEADDR option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::acceptor::reuse_address option(true);
   acceptor.set_option(option);







[endsect]



[section:overload2 basic_socket_acceptor::set_option (2 of 2 overloads)]


Set an option on the acceptor. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void set_option(
      const SettableSocketOption & option,
      boost::system::error_code & ec);


This function is used to set an option on the acceptor.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the acceptor.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Setting the SOL\_SOCKET/SO\_REUSEADDR option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::ip::tcp::acceptor::reuse_address option(true);
   boost::system::error_code ec;
   acceptor.set_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:shutdown_type basic_socket_acceptor::shutdown_type]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.shutdown_type..shutdown_type..basic_socket_acceptor] 
Different ways a socket may be shutdown. 

  enum shutdown_type

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.shutdown_type.shutdown_receive..shutdown_receive..basic_socket_acceptor]
[indexterm2 boost_asio.indexterm.basic_socket_acceptor.shutdown_type.shutdown_send..shutdown_send..basic_socket_acceptor]
[indexterm2 boost_asio.indexterm.basic_socket_acceptor.shutdown_type.shutdown_both..shutdown_both..basic_socket_acceptor]

[heading Values]
[variablelist

  [
    [shutdown_receive]
    [Shutdown the receive side of the socket. ]
  ]

  [
    [shutdown_send]
    [Shutdown the send side of the socket. ]
  ]

  [
    [shutdown_both]
    [Shutdown both send and receive on the socket. ]
  ]

]



[endsect]


[section:wait basic_socket_acceptor::wait]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.wait..wait..basic_socket_acceptor] 
Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. 


  void ``[link boost_asio.reference.basic_socket_acceptor.wait.overload1 wait]``(
      wait_type w);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.wait.overload1 more...]]``

  void ``[link boost_asio.reference.basic_socket_acceptor.wait.overload2 wait]``(
      wait_type w,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_acceptor.wait.overload2 more...]]``


[section:overload1 basic_socket_acceptor::wait (1 of 2 overloads)]


Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w);


This function is used to perform a blocking wait for an acceptor to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired acceptor state.]]

]


[heading Example]
  
Waiting for an acceptor to become readable. 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   acceptor.wait(boost::asio::ip::tcp::acceptor::wait_read);







[endsect]



[section:overload2 basic_socket_acceptor::wait (2 of 2 overloads)]


Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w,
      boost::system::error_code & ec);


This function is used to perform a blocking wait for an acceptor to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired acceptor state.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Waiting for an acceptor to become readable. 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::system::error_code ec;
   acceptor.wait(boost::asio::ip::tcp::acceptor::wait_read, ec);







[endsect]


[endsect]


[section:wait_type basic_socket_acceptor::wait_type]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.wait_type..wait_type..basic_socket_acceptor] 
Wait types. 

  enum wait_type

[indexterm2 boost_asio.indexterm.basic_socket_acceptor.wait_type.wait_read..wait_read..basic_socket_acceptor]
[indexterm2 boost_asio.indexterm.basic_socket_acceptor.wait_type.wait_write..wait_write..basic_socket_acceptor]
[indexterm2 boost_asio.indexterm.basic_socket_acceptor.wait_type.wait_error..wait_error..basic_socket_acceptor]

[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a socket to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a socket to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a socket to have error conditions pending. ]
  ]

]


For use with `basic_socket::wait()` and `basic_socket::async_wait()`. 


[endsect]



[section:_basic_socket_acceptor basic_socket_acceptor::~basic_socket_acceptor]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor._basic_socket_acceptor..~basic_socket_acceptor..basic_socket_acceptor] 
Destroys the acceptor. 


  ~basic_socket_acceptor();


This function destroys the acceptor, cancelling any outstanding asynchronous operations associated with the acceptor as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_socket_acceptor__rebind_executor basic_socket_acceptor::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_socket_acceptor__rebind_executor..basic_socket_acceptor::rebind_executor]


Rebinds the acceptor type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket_acceptor__rebind_executor.other [*other]]]
    [The socket type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_socket_acceptor::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_socket_acceptor__rebind_executor.other..other..basic_socket_acceptor::rebind_executor] 
The socket type when rebound to the specified executor. 


  typedef basic_socket_acceptor< Protocol, Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket_acceptor__rebind_executor [*rebind_executor]]]
    [Rebinds the acceptor type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.native_handle_type [*native_handle_type]]]
    [The native representation of an acceptor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_acceptor.accept [*accept]]]
    [Accept a new connection. 
     [hr]
     Accept a new connection and obtain the endpoint of the peer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.assign [*assign]]]
    [Assigns an existing native acceptor to the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.async_accept [*async_accept]]]
    [Start an asynchronous accept. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.async_wait [*async_wait]]]
    [Asynchronously wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor [*basic_socket_acceptor]] [constructor]]
    [Construct an acceptor without opening it. 
     [hr]
     Construct an open acceptor. 
     [hr]
     Construct an acceptor opened on the given endpoint. 
     [hr]
     Construct a basic_socket_acceptor on an existing native acceptor. 
     [hr]
     Move-construct a basic_socket_acceptor from another. 
     [hr]
     Move-construct a basic_socket_acceptor from an acceptor of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.bind [*bind]]]
    [Bind the acceptor to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.close [*close]]]
    [Close the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.get_option [*get_option]]]
    [Get an option from the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.io_control [*io_control]]]
    [Perform an IO control command on the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.is_open [*is_open]]]
    [Determine whether the acceptor is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.listen [*listen]]]
    [Place the acceptor into the state where it will listen for new connections. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.native_handle [*native_handle]]]
    [Get the native acceptor representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native acceptor implementation. 
     [hr]
     Sets the non-blocking mode of the native acceptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the acceptor. 
     [hr]
     Sets the non-blocking mode of the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.open [*open]]]
    [Open the acceptor using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_acceptor from another. 
     [hr]
     Move-assign a basic_socket_acceptor from an acceptor of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.release [*release]]]
    [Release ownership of the underlying native acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.set_option [*set_option]]]
    [Set an option on the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.wait [*wait]]]
    [Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor._basic_socket_acceptor [*~basic_socket_acceptor]] [destructor]]
    [Destroys the acceptor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_acceptor.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] class template is used for accepting new socket connections.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `accept` operations are thread safe, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to synchronous `accept` operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe.


[heading Example]
  
Opening a socket acceptor with the SO\_REUSEADDR option enabled: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port);
   acceptor.open(endpoint.protocol());
   acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
   acceptor.bind(endpoint);
   acceptor.listen();







[heading Requirements]

['Header: ][^boost/asio/basic_socket_acceptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_socket_iostream basic_socket_iostream]

[indexterm1 boost_asio.indexterm.basic_socket_iostream..basic_socket_iostream]


Iostream interface for a socket. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename Clock = chrono::steady_clock,
      typename ``[link boost_asio.reference.WaitTraits WaitTraits]`` = wait_traits<Clock>>
  class basic_socket_iostream


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket_iostream.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.duration [*duration]]]
    [The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.duration_type [*duration_type]]]
    [(Deprecated: Use duration.) The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.time_point [*time_point]]]
    [The time type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.time_type [*time_type]]]
    [(Deprecated: Use time_point.) The time type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_iostream.basic_socket_iostream [*basic_socket_iostream]] [constructor]]
    [Construct a basic_socket_iostream without establishing a connection. 
     [hr]
     Construct a basic_socket_iostream from the supplied socket. 
     [hr]
     Move-construct a basic_socket_iostream from another. 
     [hr]
     Establish a connection to an endpoint corresponding to a resolver query. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.close [*close]]]
    [Close the connection. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.connect [*connect]]]
    [Establish a connection to an endpoint corresponding to a resolver query. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.error [*error]]]
    [Get the last error associated with the stream. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expires_after [*expires_after]]]
    [Set the stream's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expires_at [*expires_at]]]
    [(Deprecated: Use expiry().) Get the stream's expiry time as an absolute time. 
     [hr]
     Set the stream's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expires_from_now [*expires_from_now]]]
    [(Deprecated: Use expiry().) Get the stream's expiry time relative to now. 
     [hr]
     (Deprecated: Use expires_after().) Set the stream's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expiry [*expiry]]]
    [Get the stream's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_iostream from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.rdbuf [*rdbuf]]]
    [Return a pointer to the underlying streambuf. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.socket [*socket]]]
    [Get a reference to the underlying socket. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/basic_socket_iostream.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_socket_iostream basic_socket_iostream::basic_socket_iostream]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.basic_socket_iostream..basic_socket_iostream..basic_socket_iostream] 
Construct a [link boost_asio.reference.basic_socket_iostream `basic_socket_iostream`] without establishing a connection. 


  ``[link boost_asio.reference.basic_socket_iostream.basic_socket_iostream.overload1 basic_socket_iostream]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_iostream.basic_socket_iostream.overload1 more...]]``


Construct a [link boost_asio.reference.basic_socket_iostream `basic_socket_iostream`] from the supplied socket. 


  explicit ``[link boost_asio.reference.basic_socket_iostream.basic_socket_iostream.overload2 basic_socket_iostream]``(
      basic_stream_socket< protocol_type > s);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_iostream.basic_socket_iostream.overload2 more...]]``


Move-construct a [link boost_asio.reference.basic_socket_iostream `basic_socket_iostream`] from another. 


  ``[link boost_asio.reference.basic_socket_iostream.basic_socket_iostream.overload3 basic_socket_iostream]``(
      basic_socket_iostream && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_iostream.basic_socket_iostream.overload3 more...]]``


Establish a connection to an endpoint corresponding to a resolver query. 


  template<
      typename T1,
      ... ,
      typename TN>
  explicit ``[link boost_asio.reference.basic_socket_iostream.basic_socket_iostream.overload4 basic_socket_iostream]``(
      T1 t1,
      ... ,
      TN tn);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_iostream.basic_socket_iostream.overload4 more...]]``


[section:overload1 basic_socket_iostream::basic_socket_iostream (1 of 4 overloads)]


Construct a [link boost_asio.reference.basic_socket_iostream `basic_socket_iostream`] without establishing a connection. 


  basic_socket_iostream();



[endsect]



[section:overload2 basic_socket_iostream::basic_socket_iostream (2 of 4 overloads)]


Construct a [link boost_asio.reference.basic_socket_iostream `basic_socket_iostream`] from the supplied socket. 


  basic_socket_iostream(
      basic_stream_socket< protocol_type > s);



[endsect]



[section:overload3 basic_socket_iostream::basic_socket_iostream (3 of 4 overloads)]


Move-construct a [link boost_asio.reference.basic_socket_iostream `basic_socket_iostream`] from another. 


  basic_socket_iostream(
      basic_socket_iostream && other);



[endsect]



[section:overload4 basic_socket_iostream::basic_socket_iostream (4 of 4 overloads)]


Establish a connection to an endpoint corresponding to a resolver query. 


  template<
      typename T1,
      ... ,
      typename TN>
  basic_socket_iostream(
      T1 t1,
      ... ,
      TN tn);


This constructor automatically establishes a connection based on the supplied resolver query parameters. The arguments are used to construct a resolver query object. 


[endsect]


[endsect]


[section:clock_type basic_socket_iostream::clock_type]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.clock_type..clock_type..basic_socket_iostream] 
The clock type. 


  typedef Clock clock_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_iostream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:close basic_socket_iostream::close]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.close..close..basic_socket_iostream] 
Close the connection. 


  void close();



[endsect]



[section:connect basic_socket_iostream::connect]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.connect..connect..basic_socket_iostream] 
Establish a connection to an endpoint corresponding to a resolver query. 


  template<
      typename T1,
      ... ,
      typename TN>
  void connect(
      T1 t1,
      ... ,
      TN tn);


This function automatically establishes a connection based on the supplied resolver query parameters. The arguments are used to construct a resolver query object. 


[endsect]



[section:duration basic_socket_iostream::duration]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.duration..duration..basic_socket_iostream] 
The duration type. 


  typedef WaitTraits::duration duration;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_iostream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:duration_type basic_socket_iostream::duration_type]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.duration_type..duration_type..basic_socket_iostream] 
(Deprecated: Use duration.) The duration type. 


  typedef WaitTraits::duration_type duration_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_iostream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:endpoint_type basic_socket_iostream::endpoint_type]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.endpoint_type..endpoint_type..basic_socket_iostream] 
The endpoint type. 


  typedef Protocol::endpoint endpoint_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_iostream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:error basic_socket_iostream::error]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.error..error..basic_socket_iostream] 
Get the last error associated with the stream. 


  const boost::system::error_code & error() const;



[heading Return Value]
      
An `error_code` corresponding to the last error from the stream.


[heading Example]
  
To print the error associated with a failure to establish a connection: 

   tcp::iostream s("www.boost.org", "http");
   if (!s)
   {
     std::cout << "Error: " << s.error().message() << std::endl;
   } 







[endsect]



[section:expires_after basic_socket_iostream::expires_after]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.expires_after..expires_after..basic_socket_iostream] 
Set the stream's expiry time relative to now. 


  void expires_after(
      const duration & expiry_time);


This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error `boost::asio::error::operation_aborted`.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer. ]]

]




[endsect]


[section:expires_at basic_socket_iostream::expires_at]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.expires_at..expires_at..basic_socket_iostream] 
(Deprecated: Use `expiry()`.) Get the stream's expiry time as an absolute time. 


  time_point ``[link boost_asio.reference.basic_socket_iostream.expires_at.overload1 expires_at]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_iostream.expires_at.overload1 more...]]``


Set the stream's expiry time as an absolute time. 


  void ``[link boost_asio.reference.basic_socket_iostream.expires_at.overload2 expires_at]``(
      const time_point & expiry_time);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_iostream.expires_at.overload2 more...]]``


[section:overload1 basic_socket_iostream::expires_at (1 of 2 overloads)]


(Deprecated: Use `expiry()`.) Get the stream's expiry time as an absolute time. 


  time_point expires_at() const;



[heading Return Value]
      
An absolute time value representing the stream's expiry time. 




[endsect]



[section:overload2 basic_socket_iostream::expires_at (2 of 2 overloads)]


Set the stream's expiry time as an absolute time. 


  void expires_at(
      const time_point & expiry_time);


This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error `boost::asio::error::operation_aborted`.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the stream. ]]

]




[endsect]


[endsect]

[section:expires_from_now basic_socket_iostream::expires_from_now]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.expires_from_now..expires_from_now..basic_socket_iostream] 
(Deprecated: Use `expiry()`.) Get the stream's expiry time relative to now. 


  duration ``[link boost_asio.reference.basic_socket_iostream.expires_from_now.overload1 expires_from_now]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_iostream.expires_from_now.overload1 more...]]``


(Deprecated: Use `expires_after()`.) Set the stream's expiry time relative to now. 


  void ``[link boost_asio.reference.basic_socket_iostream.expires_from_now.overload2 expires_from_now]``(
      const duration & expiry_time);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_iostream.expires_from_now.overload2 more...]]``


[section:overload1 basic_socket_iostream::expires_from_now (1 of 2 overloads)]


(Deprecated: Use `expiry()`.) Get the stream's expiry time relative to now. 


  duration expires_from_now() const;



[heading Return Value]
      
A relative time value representing the stream's expiry time. 




[endsect]



[section:overload2 basic_socket_iostream::expires_from_now (2 of 2 overloads)]


(Deprecated: Use `expires_after()`.) Set the stream's expiry time relative to now. 


  void expires_from_now(
      const duration & expiry_time);


This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error `boost::asio::error::operation_aborted`.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer. ]]

]




[endsect]


[endsect]


[section:expiry basic_socket_iostream::expiry]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.expiry..expiry..basic_socket_iostream] 
Get the stream's expiry time as an absolute time. 


  time_point expiry() const;



[heading Return Value]
      
An absolute time value representing the stream's expiry time. 




[endsect]



[section:operator_eq_ basic_socket_iostream::operator=]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.operator_eq_..operator=..basic_socket_iostream] 
Move-assign a [link boost_asio.reference.basic_socket_iostream `basic_socket_iostream`] from another. 


  basic_socket_iostream & operator=(
      basic_socket_iostream && other);



[endsect]



[section:protocol_type basic_socket_iostream::protocol_type]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.protocol_type..protocol_type..basic_socket_iostream] 
The protocol type. 


  typedef Protocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_iostream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:rdbuf basic_socket_iostream::rdbuf]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.rdbuf..rdbuf..basic_socket_iostream] 
Return a pointer to the underlying streambuf. 


  basic_socket_streambuf< Protocol, Clock, WaitTraits > * rdbuf() const;



[endsect]



[section:socket basic_socket_iostream::socket]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.socket..socket..basic_socket_iostream] 
Get a reference to the underlying socket. 


  basic_socket< Protocol > & socket();



[endsect]



[section:time_point basic_socket_iostream::time_point]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.time_point..time_point..basic_socket_iostream] 
The time type. 


  typedef WaitTraits::time_point time_point;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_iostream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:time_type basic_socket_iostream::time_type]

[indexterm2 boost_asio.indexterm.basic_socket_iostream.time_type..time_type..basic_socket_iostream] 
(Deprecated: Use time\_point.) The time type. 


  typedef WaitTraits::time_type time_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_iostream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_socket_streambuf basic_socket_streambuf]

[indexterm1 boost_asio.indexterm.basic_socket_streambuf..basic_socket_streambuf]


Iostream streambuf for a socket. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename Clock = chrono::steady_clock,
      typename ``[link boost_asio.reference.WaitTraits WaitTraits]`` = wait_traits<Clock>>
  class basic_socket_streambuf :
    basic_socket< Protocol >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket_streambuf.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_streambuf.duration [*duration]]]
    [The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_streambuf.duration_type [*duration_type]]]
    [(Deprecated: Use duration.) The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_streambuf.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_streambuf.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_streambuf.time_point [*time_point]]]
    [The time type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_streambuf.time_type [*time_type]]]
    [(Deprecated: Use time_point.) The time type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_streambuf.basic_socket_streambuf [*basic_socket_streambuf]] [constructor]]
    [Construct a basic_socket_streambuf without establishing a connection. 
     [hr]
     Construct a basic_socket_streambuf from the supplied socket. 
     [hr]
     Move-construct a basic_socket_streambuf from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf.close [*close]]]
    [Close the connection. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf.connect [*connect]]]
    [Establish a connection. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf.error [*error]]]
    [Get the last error associated with the stream buffer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf.expires_after [*expires_after]]]
    [Set the stream buffer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf.expires_at [*expires_at]]]
    [(Deprecated: Use expiry().) Get the stream buffer's expiry time as an absolute time. 
     [hr]
     Set the stream buffer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf.expires_from_now [*expires_from_now]]]
    [(Deprecated: Use expiry().) Get the stream buffer's expiry time relative to now. 
     [hr]
     (Deprecated: Use expires_after().) Set the stream buffer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf.expiry [*expiry]]]
    [Get the stream buffer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_streambuf from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf.puberror [*puberror]]]
    [(Deprecated: Use error().) Get the last error associated with the stream buffer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf.socket [*socket]]]
    [Get a reference to the underlying socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf._basic_socket_streambuf [*~basic_socket_streambuf]] [destructor]]
    [Destructor flushes buffered data. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_streambuf.overflow [*overflow]]]
    []
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf.setbuf [*setbuf]]]
    []
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf.sync [*sync]]]
    []
  ]
  
  [
    [[link boost_asio.reference.basic_socket_streambuf.underflow [*underflow]]]
    []
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/basic_socket_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_socket_streambuf basic_socket_streambuf::basic_socket_streambuf]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.basic_socket_streambuf..basic_socket_streambuf..basic_socket_streambuf] 
Construct a [link boost_asio.reference.basic_socket_streambuf `basic_socket_streambuf`] without establishing a connection. 


  ``[link boost_asio.reference.basic_socket_streambuf.basic_socket_streambuf.overload1 basic_socket_streambuf]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_streambuf.basic_socket_streambuf.overload1 more...]]``


Construct a [link boost_asio.reference.basic_socket_streambuf `basic_socket_streambuf`] from the supplied socket. 


  explicit ``[link boost_asio.reference.basic_socket_streambuf.basic_socket_streambuf.overload2 basic_socket_streambuf]``(
      basic_stream_socket< protocol_type > s);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_streambuf.basic_socket_streambuf.overload2 more...]]``


Move-construct a [link boost_asio.reference.basic_socket_streambuf `basic_socket_streambuf`] from another. 


  ``[link boost_asio.reference.basic_socket_streambuf.basic_socket_streambuf.overload3 basic_socket_streambuf]``(
      basic_socket_streambuf && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_streambuf.basic_socket_streambuf.overload3 more...]]``


[section:overload1 basic_socket_streambuf::basic_socket_streambuf (1 of 3 overloads)]


Construct a [link boost_asio.reference.basic_socket_streambuf `basic_socket_streambuf`] without establishing a connection. 


  basic_socket_streambuf();



[endsect]



[section:overload2 basic_socket_streambuf::basic_socket_streambuf (2 of 3 overloads)]


Construct a [link boost_asio.reference.basic_socket_streambuf `basic_socket_streambuf`] from the supplied socket. 


  basic_socket_streambuf(
      basic_stream_socket< protocol_type > s);



[endsect]



[section:overload3 basic_socket_streambuf::basic_socket_streambuf (3 of 3 overloads)]


Move-construct a [link boost_asio.reference.basic_socket_streambuf `basic_socket_streambuf`] from another. 


  basic_socket_streambuf(
      basic_socket_streambuf && other);



[endsect]


[endsect]


[section:clock_type basic_socket_streambuf::clock_type]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.clock_type..clock_type..basic_socket_streambuf] 
The clock type. 


  typedef Clock clock_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:close basic_socket_streambuf::close]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.close..close..basic_socket_streambuf] 
Close the connection. 


  basic_socket_streambuf * close();



[heading Return Value]
      
`this` if a connection was successfully established, a null pointer otherwise. 




[endsect]


[section:connect basic_socket_streambuf::connect]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.connect..connect..basic_socket_streambuf] 
Establish a connection. 


  basic_socket_streambuf * ``[link boost_asio.reference.basic_socket_streambuf.connect.overload1 connect]``(
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_streambuf.connect.overload1 more...]]``

  template<
      typename T1,
      ... ,
      typename TN>
  basic_socket_streambuf * ``[link boost_asio.reference.basic_socket_streambuf.connect.overload2 connect]``(
      T1 t1,
      ... ,
      TN tn);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_streambuf.connect.overload2 more...]]``


[section:overload1 basic_socket_streambuf::connect (1 of 2 overloads)]


Establish a connection. 


  basic_socket_streambuf * connect(
      const endpoint_type & endpoint);


This function establishes a connection to the specified endpoint.


[heading Return Value]
      
`this` if a connection was successfully established, a null pointer otherwise. 




[endsect]



[section:overload2 basic_socket_streambuf::connect (2 of 2 overloads)]


Establish a connection. 


  template<
      typename T1,
      ... ,
      typename TN>
  basic_socket_streambuf * connect(
      T1 t1,
      ... ,
      TN tn);


This function automatically establishes a connection based on the supplied resolver query parameters. The arguments are used to construct a resolver query object.


[heading Return Value]
      
`this` if a connection was successfully established, a null pointer otherwise. 




[endsect]


[endsect]


[section:duration basic_socket_streambuf::duration]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.duration..duration..basic_socket_streambuf] 
The duration type. 


  typedef WaitTraits::duration duration;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:duration_type basic_socket_streambuf::duration_type]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.duration_type..duration_type..basic_socket_streambuf] 
(Deprecated: Use duration.) The duration type. 


  typedef WaitTraits::duration_type duration_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:endpoint_type basic_socket_streambuf::endpoint_type]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.endpoint_type..endpoint_type..basic_socket_streambuf] 
The endpoint type. 


  typedef Protocol::endpoint endpoint_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:error basic_socket_streambuf::error]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.error..error..basic_socket_streambuf] 
Get the last error associated with the stream buffer. 


  const boost::system::error_code & error() const;



[heading Return Value]
      
An `error_code` corresponding to the last error from the stream buffer. 




[endsect]



[section:expires_after basic_socket_streambuf::expires_after]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.expires_after..expires_after..basic_socket_streambuf] 
Set the stream buffer's expiry time relative to now. 


  void expires_after(
      const duration & expiry_time);


This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error `boost::asio::error::operation_aborted`.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer. ]]

]




[endsect]


[section:expires_at basic_socket_streambuf::expires_at]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.expires_at..expires_at..basic_socket_streambuf] 
(Deprecated: Use `expiry()`.) Get the stream buffer's expiry time as an absolute time. 


  time_point ``[link boost_asio.reference.basic_socket_streambuf.expires_at.overload1 expires_at]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_streambuf.expires_at.overload1 more...]]``


Set the stream buffer's expiry time as an absolute time. 


  void ``[link boost_asio.reference.basic_socket_streambuf.expires_at.overload2 expires_at]``(
      const time_point & expiry_time);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_streambuf.expires_at.overload2 more...]]``


[section:overload1 basic_socket_streambuf::expires_at (1 of 2 overloads)]


(Deprecated: Use `expiry()`.) Get the stream buffer's expiry time as an absolute time. 


  time_point expires_at() const;



[heading Return Value]
      
An absolute time value representing the stream buffer's expiry time. 




[endsect]



[section:overload2 basic_socket_streambuf::expires_at (2 of 2 overloads)]


Set the stream buffer's expiry time as an absolute time. 


  void expires_at(
      const time_point & expiry_time);


This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error `boost::asio::error::operation_aborted`.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the stream. ]]

]




[endsect]


[endsect]

[section:expires_from_now basic_socket_streambuf::expires_from_now]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.expires_from_now..expires_from_now..basic_socket_streambuf] 
(Deprecated: Use `expiry()`.) Get the stream buffer's expiry time relative to now. 


  duration ``[link boost_asio.reference.basic_socket_streambuf.expires_from_now.overload1 expires_from_now]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_streambuf.expires_from_now.overload1 more...]]``


(Deprecated: Use `expires_after()`.) Set the stream buffer's expiry time relative to now. 


  void ``[link boost_asio.reference.basic_socket_streambuf.expires_from_now.overload2 expires_from_now]``(
      const duration & expiry_time);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_socket_streambuf.expires_from_now.overload2 more...]]``


[section:overload1 basic_socket_streambuf::expires_from_now (1 of 2 overloads)]


(Deprecated: Use `expiry()`.) Get the stream buffer's expiry time relative to now. 


  duration expires_from_now() const;



[heading Return Value]
      
A relative time value representing the stream buffer's expiry time. 




[endsect]



[section:overload2 basic_socket_streambuf::expires_from_now (2 of 2 overloads)]


(Deprecated: Use `expires_after()`.) Set the stream buffer's expiry time relative to now. 


  void expires_from_now(
      const duration & expiry_time);


This function sets the expiry time associated with the stream. Stream operations performed after this time (where the operations cannot be completed using the internal buffers) will fail with the error `boost::asio::error::operation_aborted`.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer. ]]

]




[endsect]


[endsect]


[section:expiry basic_socket_streambuf::expiry]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.expiry..expiry..basic_socket_streambuf] 
Get the stream buffer's expiry time as an absolute time. 


  time_point expiry() const;



[heading Return Value]
      
An absolute time value representing the stream buffer's expiry time. 




[endsect]



[section:operator_eq_ basic_socket_streambuf::operator=]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.operator_eq_..operator=..basic_socket_streambuf] 
Move-assign a [link boost_asio.reference.basic_socket_streambuf `basic_socket_streambuf`] from another. 


  basic_socket_streambuf & operator=(
      basic_socket_streambuf && other);



[endsect]



[section:overflow basic_socket_streambuf::overflow]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.overflow..overflow..basic_socket_streambuf] 

  int_type overflow(
      int_type c);



[endsect]



[section:protocol_type basic_socket_streambuf::protocol_type]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.protocol_type..protocol_type..basic_socket_streambuf] 
The protocol type. 


  typedef Protocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:puberror basic_socket_streambuf::puberror]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.puberror..puberror..basic_socket_streambuf] 
(Deprecated: Use `error()`.) Get the last error associated with the stream buffer. 


  const boost::system::error_code & puberror() const;



[heading Return Value]
      
An `error_code` corresponding to the last error from the stream buffer. 




[endsect]



[section:setbuf basic_socket_streambuf::setbuf]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.setbuf..setbuf..basic_socket_streambuf] 

  std::streambuf * setbuf(
      char_type * s,
      std::streamsize n);



[endsect]



[section:socket basic_socket_streambuf::socket]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.socket..socket..basic_socket_streambuf] 
Get a reference to the underlying socket. 


  basic_socket< Protocol > & socket();



[endsect]



[section:sync basic_socket_streambuf::sync]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.sync..sync..basic_socket_streambuf] 

  int sync();



[endsect]



[section:time_point basic_socket_streambuf::time_point]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.time_point..time_point..basic_socket_streambuf] 
The time type. 


  typedef WaitTraits::time_point time_point;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:time_type basic_socket_streambuf::time_type]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.time_type..time_type..basic_socket_streambuf] 
(Deprecated: Use time\_point.) The time type. 


  typedef WaitTraits::time_type time_type;



[heading Requirements]

['Header: ][^boost/asio/basic_socket_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:underflow basic_socket_streambuf::underflow]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf.underflow..underflow..basic_socket_streambuf] 

  int_type underflow();



[endsect]



[section:_basic_socket_streambuf basic_socket_streambuf::~basic_socket_streambuf]

[indexterm2 boost_asio.indexterm.basic_socket_streambuf._basic_socket_streambuf..~basic_socket_streambuf..basic_socket_streambuf] 
Destructor flushes buffered data. 


  virtual ~basic_socket_streambuf();



[endsect]



[endsect]

[section:basic_stream_file basic_stream_file]

[indexterm1 boost_asio.indexterm.basic_stream_file..basic_stream_file]


Provides stream-oriented file functionality. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class basic_stream_file :
    public basic_file< Executor >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_stream_file__rebind_executor [*rebind_executor]]]
    [Rebinds the file type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_file.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_file.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_file.native_handle_type [*native_handle_type]]]
    [The native representation of a file. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_file.seek_basis [*seek_basis]]]
    [Basis for seeking in a file. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_file.assign [*assign]]]
    [Assign an existing native file to the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.basic_stream_file [*basic_stream_file]] [constructor]]
    [Construct a basic_stream_file without opening it. 
     [hr]
     Construct and open a basic_stream_file. 
     [hr]
     Construct a basic_stream_file on an existing native file. 
     [hr]
     Move-construct a basic_stream_file from another. 
     [hr]
     Move-construct a basic_stream_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.close [*close]]]
    [Close the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.is_open [*is_open]]]
    [Determine whether the file is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.native_handle [*native_handle]]]
    [Get the native file representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.open [*open]]]
    [Open the file using the specified path. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.operator_eq_ [*operator=]]]
    [Move-assign a basic_stream_file from another. 
     [hr]
     Move-assign a basic_stream_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.read_some [*read_some]]]
    [Read some data from the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.release [*release]]]
    [Release ownership of the underlying native file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.resize [*resize]]]
    [Alter the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.seek [*seek]]]
    [Seek to a position in the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.size [*size]]]
    [Get the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.sync_all [*sync_all]]]
    [Synchronise the file to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.sync_data [*sync_data]]]
    [Synchronise the file data to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.write_some [*write_some]]]
    [Write some data to the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file._basic_stream_file [*~basic_stream_file]] [destructor]]
    [Destroys the file. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_file.append [*append]] [static]]
    [Open the file in append mode. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.create [*create]] [static]]
    [Create the file if it does not exist. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.exclusive [*exclusive]] [static]]
    [Ensure a new file is created. Must be combined with create. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.read_only [*read_only]] [static]]
    [Open the file for reading. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.read_write [*read_write]] [static]]
    [Open the file for reading and writing. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.truncate [*truncate]] [static]]
    [Open the file with any existing contents truncated. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.write_only [*write_only]] [static]]
    [Open the file for writing. ]
  ]

]

The [link boost_asio.reference.basic_stream_file `basic_stream_file`] class template provides asynchronous and blocking stream-oriented file functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.




[heading Requirements]

['Header: ][^boost/asio/basic_stream_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:append basic_stream_file::append]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_stream_file.append..append..basic_stream_file] 
Open the file in append mode. 


  static const flags append = implementation_defined;



[endsect]


[section:assign basic_stream_file::assign]

[indexterm2 boost_asio.indexterm.basic_stream_file.assign..assign..basic_stream_file] 
Assign an existing native file to the file. 


  void ``[link boost_asio.reference.basic_stream_file.assign.overload1 assign]``(
      const native_handle_type & native_file);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.assign.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_file.assign.overload2 assign]``(
      const native_handle_type & native_file,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.assign.overload2 more...]]``


[section:overload1 basic_stream_file::assign (1 of 2 overloads)]


['Inherited from basic_file.]


Assign an existing native file to the file. 


  void assign(
      const native_handle_type & native_file);



[endsect]



[section:overload2 basic_stream_file::assign (2 of 2 overloads)]


['Inherited from basic_file.]


Assign an existing native file to the file. 


  void assign(
      const native_handle_type & native_file,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_read_some basic_stream_file::async_read_some]

[indexterm2 boost_asio.indexterm.basic_stream_file.async_read_some..async_read_some..basic_stream_file] 
Start an asynchronous read. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_some(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data from the stream file. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes read.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The read operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.async_read `async_read`]  function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   file.async_read_some(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:async_write_some basic_stream_file::async_write_some]

[indexterm2 boost_asio.indexterm.basic_stream_file.async_write_some..async_write_some..basic_stream_file] 
Start an asynchronous write. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_some(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write data to the stream file. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the file. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes written.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The write operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.async_write `async_write`]  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   file.async_write_some(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:basic_stream_file basic_stream_file::basic_stream_file]

[indexterm2 boost_asio.indexterm.basic_stream_file.basic_stream_file..basic_stream_file..basic_stream_file] 
Construct a [link boost_asio.reference.basic_stream_file `basic_stream_file`] without opening it. 


  explicit ``[link boost_asio.reference.basic_stream_file.basic_stream_file.overload1 basic_stream_file]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.basic_stream_file.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_stream_file.basic_stream_file.overload2 basic_stream_file]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.basic_stream_file.overload2 more...]]``


Construct and open a [link boost_asio.reference.basic_stream_file `basic_stream_file`]. 


  ``[link boost_asio.reference.basic_stream_file.basic_stream_file.overload3 basic_stream_file]``(
      const executor_type & ex,
      const char * path,
      file_base::flags open_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.basic_stream_file.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_stream_file.basic_stream_file.overload4 basic_stream_file]``(
      ExecutionContext & context,
      const char * path,
      file_base::flags open_flags,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.basic_stream_file.overload4 more...]]``

  ``[link boost_asio.reference.basic_stream_file.basic_stream_file.overload5 basic_stream_file]``(
      const executor_type & ex,
      const std::string & path,
      file_base::flags open_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.basic_stream_file.overload5 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_stream_file.basic_stream_file.overload6 basic_stream_file]``(
      ExecutionContext & context,
      const std::string & path,
      file_base::flags open_flags,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.basic_stream_file.overload6 more...]]``


Construct a [link boost_asio.reference.basic_stream_file `basic_stream_file`] on an existing native file. 


  ``[link boost_asio.reference.basic_stream_file.basic_stream_file.overload7 basic_stream_file]``(
      const executor_type & ex,
      const native_handle_type & native_file);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.basic_stream_file.overload7 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_stream_file.basic_stream_file.overload8 basic_stream_file]``(
      ExecutionContext & context,
      const native_handle_type & native_file,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.basic_stream_file.overload8 more...]]``


Move-construct a [link boost_asio.reference.basic_stream_file `basic_stream_file`] from another. 


  ``[link boost_asio.reference.basic_stream_file.basic_stream_file.overload9 basic_stream_file]``(
      basic_stream_file && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.basic_stream_file.overload9 more...]]``


Move-construct a [link boost_asio.reference.basic_stream_file `basic_stream_file`] from a file of another executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.basic_stream_file.basic_stream_file.overload10 basic_stream_file]``(
      basic_stream_file< Executor1 > && other,
      typename constraint< is_convertible< Executor1, Executor >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.basic_stream_file.overload10 more...]]``


[section:overload1 basic_stream_file::basic_stream_file (1 of 10 overloads)]


Construct a [link boost_asio.reference.basic_stream_file `basic_stream_file`] without opening it. 


  basic_stream_file(
      const executor_type & ex);


This constructor initialises a file without opening it. The file needs to be opened before data can be read from or or written to it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file. ]]

]




[endsect]



[section:overload2 basic_stream_file::basic_stream_file (2 of 10 overloads)]


Construct a [link boost_asio.reference.basic_stream_file `basic_stream_file`] without opening it. 


  template<
      typename ExecutionContext>
  basic_stream_file(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor initialises a file without opening it. The file needs to be opened before data can be read from or or written to it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file. ]]

]




[endsect]



[section:overload3 basic_stream_file::basic_stream_file (3 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_stream_file `basic_stream_file`]. 


  basic_stream_file(
      const executor_type & ex,
      const char * path,
      file_base::flags open_flags);


This constructor initialises and opens a file.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_stream_file::basic_stream_file (4 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_stream_file `basic_stream_file`]. 


  template<
      typename ExecutionContext>
  basic_stream_file(
      ExecutionContext & context,
      const char * path,
      file_base::flags open_flags,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor initialises and opens a file.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_stream_file::basic_stream_file (5 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_stream_file `basic_stream_file`]. 


  basic_stream_file(
      const executor_type & ex,
      const std::string & path,
      file_base::flags open_flags);


This constructor initialises and opens a file.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload6 basic_stream_file::basic_stream_file (6 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_stream_file `basic_stream_file`]. 


  template<
      typename ExecutionContext>
  basic_stream_file(
      ExecutionContext & context,
      const std::string & path,
      file_base::flags open_flags,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor initialises and opens a file.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload7 basic_stream_file::basic_stream_file (7 of 10 overloads)]


Construct a [link boost_asio.reference.basic_stream_file `basic_stream_file`] on an existing native file. 


  basic_stream_file(
      const executor_type & ex,
      const native_handle_type & native_file);


This constructor initialises a stream file object to hold an existing native file.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[native_file][The new underlying file implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 basic_stream_file::basic_stream_file (8 of 10 overloads)]


Construct a [link boost_asio.reference.basic_stream_file `basic_stream_file`] on an existing native file. 


  template<
      typename ExecutionContext>
  basic_stream_file(
      ExecutionContext & context,
      const native_handle_type & native_file,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor initialises a stream file object to hold an existing native file.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the file will use, by default, to dispatch handlers for any asynchronous operations performed on the file.]]

[[native_file][The new underlying file implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload9 basic_stream_file::basic_stream_file (9 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_stream_file `basic_stream_file`] from another. 


  basic_stream_file(
      basic_stream_file && other);


This constructor moves a stream file from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_stream_file `basic_stream_file`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_file(const executor_type&)` constructor. 




[endsect]



[section:overload10 basic_stream_file::basic_stream_file (10 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_stream_file `basic_stream_file`] from a file of another executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_stream_file(
      basic_stream_file< Executor1 > && other,
      typename constraint< is_convertible< Executor1, Executor >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor moves a stream file from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_stream_file `basic_stream_file`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_file(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:cancel basic_stream_file::cancel]

[indexterm2 boost_asio.indexterm.basic_stream_file.cancel..cancel..basic_stream_file] 
Cancel all asynchronous operations associated with the file. 


  void ``[link boost_asio.reference.basic_stream_file.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_file.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.cancel.overload2 more...]]``


[section:overload1 basic_stream_file::cancel (1 of 2 overloads)]


['Inherited from basic_file.]


Cancel all asynchronous operations associated with the file. 


  void cancel();


This function causes all outstanding asynchronous read and write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using the `close()` function to simultaneously cancel the outstanding operations and close the file.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]



[section:overload2 basic_stream_file::cancel (2 of 2 overloads)]


['Inherited from basic_file.]


Cancel all asynchronous operations associated with the file. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read and write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using the `close()` function to simultaneously cancel the outstanding operations and close the file.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]


[endsect]

[section:close basic_stream_file::close]

[indexterm2 boost_asio.indexterm.basic_stream_file.close..close..basic_stream_file] 
Close the file. 


  void ``[link boost_asio.reference.basic_stream_file.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.close.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_file.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.close.overload2 more...]]``


[section:overload1 basic_stream_file::close (1 of 2 overloads)]


['Inherited from basic_file.]


Close the file. 


  void close();


This function is used to close the file. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed. ]]

]




[endsect]



[section:overload2 basic_stream_file::close (2 of 2 overloads)]


['Inherited from basic_file.]


Close the file. 


  void close(
      boost::system::error_code & ec);


This function is used to close the file. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   ...
   boost::system::error_code ec;
   file.close(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:create basic_stream_file::create]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_stream_file.create..create..basic_stream_file] 
Create the file if it does not exist. 


  static const flags create = implementation_defined;



[endsect]



[section:exclusive basic_stream_file::exclusive]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_stream_file.exclusive..exclusive..basic_stream_file] 
Ensure a new file is created. Must be combined with `create`. 


  static const flags exclusive = implementation_defined;



[endsect]



[section:executor_type basic_stream_file::executor_type]

[indexterm2 boost_asio.indexterm.basic_stream_file.executor_type..executor_type..basic_stream_file] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_stream_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:flags basic_stream_file::flags]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_stream_file.flags..flags..basic_stream_file] 
A bitmask type (C++ Std [lib.bitmask.types]). 


  typedef unspecified flags;



[heading Requirements]

['Header: ][^boost/asio/basic_stream_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_stream_file::get_executor]


['Inherited from basic_file.]

[indexterm2 boost_asio.indexterm.basic_stream_file.get_executor..get_executor..basic_stream_file] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:is_open basic_stream_file::is_open]


['Inherited from basic_file.]

[indexterm2 boost_asio.indexterm.basic_stream_file.is_open..is_open..basic_stream_file] 
Determine whether the file is open. 


  bool is_open() const;



[endsect]



[section:native_handle basic_stream_file::native_handle]


['Inherited from basic_file.]

[indexterm2 boost_asio.indexterm.basic_stream_file.native_handle..native_handle..basic_stream_file] 
Get the native file representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the file. This is intended to allow access to native file functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_stream_file::native_handle_type]

[indexterm2 boost_asio.indexterm.basic_stream_file.native_handle_type..native_handle_type..basic_stream_file] 
The native representation of a file. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/basic_stream_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:open basic_stream_file::open]

[indexterm2 boost_asio.indexterm.basic_stream_file.open..open..basic_stream_file] 
Open the file using the specified path. 


  void ``[link boost_asio.reference.basic_stream_file.open.overload1 open]``(
      const char * path,
      file_base::flags open_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.open.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_file.open.overload2 open]``(
      const char * path,
      file_base::flags open_flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.open.overload2 more...]]``

  void ``[link boost_asio.reference.basic_stream_file.open.overload3 open]``(
      const std::string & path,
      file_base::flags open_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.open.overload3 more...]]``

  void ``[link boost_asio.reference.basic_stream_file.open.overload4 open]``(
      const std::string & path,
      file_base::flags open_flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.open.overload4 more...]]``


[section:overload1 basic_stream_file::open (1 of 4 overloads)]


['Inherited from basic_file.]


Open the file using the specified path. 


  void open(
      const char * path,
      file_base::flags open_flags);


This function opens the file so that it will use the specified path.


[heading Parameters]
    

[variablelist
  
[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   file.open("/path/to/my/file", boost::asio::stream_file::read_only);







[endsect]



[section:overload2 basic_stream_file::open (2 of 4 overloads)]


['Inherited from basic_file.]


Open the file using the specified path. 


  void open(
      const char * path,
      file_base::flags open_flags,
      boost::system::error_code & ec);


This function opens the file so that it will use the specified path.


[heading Parameters]
    

[variablelist
  
[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   boost::system::error_code ec;
   file.open("/path/to/my/file", boost::asio::stream_file::read_only, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]



[section:overload3 basic_stream_file::open (3 of 4 overloads)]


['Inherited from basic_file.]


Open the file using the specified path. 


  void open(
      const std::string & path,
      file_base::flags open_flags);


This function opens the file so that it will use the specified path.


[heading Parameters]
    

[variablelist
  
[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   file.open("/path/to/my/file", boost::asio::stream_file::read_only);







[endsect]



[section:overload4 basic_stream_file::open (4 of 4 overloads)]


['Inherited from basic_file.]


Open the file using the specified path. 


  void open(
      const std::string & path,
      file_base::flags open_flags,
      boost::system::error_code & ec);


This function opens the file so that it will use the specified path.


[heading Parameters]
    

[variablelist
  
[[path][The path name identifying the file to be opened.]]

[[open_flags][A set of flags that determine how the file should be opened.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::stream_file file(my_context);
   boost::system::error_code ec;
   file.open("/path/to/my/file", boost::asio::stream_file::read_only, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:operator_eq_ basic_stream_file::operator=]

[indexterm2 boost_asio.indexterm.basic_stream_file.operator_eq_..operator=..basic_stream_file] 
Move-assign a [link boost_asio.reference.basic_stream_file `basic_stream_file`] from another. 


  basic_stream_file & ``[link boost_asio.reference.basic_stream_file.operator_eq_.overload1 operator=]``(
      basic_stream_file && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.operator_eq_.overload1 more...]]``


Move-assign a [link boost_asio.reference.basic_stream_file `basic_stream_file`] from a file of another executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_stream_file & >::type ``[link boost_asio.reference.basic_stream_file.operator_eq_.overload2 operator=]``(
      basic_stream_file< Executor1 > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.operator_eq_.overload2 more...]]``


[section:overload1 basic_stream_file::operator= (1 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_stream_file `basic_stream_file`] from another. 


  basic_stream_file & operator=(
      basic_stream_file && other);


This assignment operator moves a stream file from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_stream_file `basic_stream_file`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_file(const executor_type&)` constructor. 




[endsect]



[section:overload2 basic_stream_file::operator= (2 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_stream_file `basic_stream_file`] from a file of another executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_stream_file & >::type operator=(
      basic_stream_file< Executor1 > && other);


This assignment operator moves a stream file from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_stream_file `basic_stream_file`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_file(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:read_only basic_stream_file::read_only]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_stream_file.read_only..read_only..basic_stream_file] 
Open the file for reading. 


  static const flags read_only = implementation_defined;



[endsect]


[section:read_some basic_stream_file::read_some]

[indexterm2 boost_asio.indexterm.basic_stream_file.read_some..read_some..basic_stream_file] 
Read some data from the file. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_file.read_some.overload1 read_some]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.read_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_file.read_some.overload2 read_some]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.read_some.overload2 more...]]``


[section:overload1 basic_stream_file::read_some (1 of 2 overloads)]


Read some data from the file. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers);


This function is used to read data from the stream file. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes read.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the end of the file was reached.]]

]


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   file.read_some(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_stream_file::read_some (2 of 2 overloads)]


Read some data from the file. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to read data from the stream file. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. Returns 0 if an error occurred.


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]


[endsect]


[section:read_write basic_stream_file::read_write]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_stream_file.read_write..read_write..basic_stream_file] 
Open the file for reading and writing. 


  static const flags read_write = implementation_defined;



[endsect]


[section:release basic_stream_file::release]

[indexterm2 boost_asio.indexterm.basic_stream_file.release..release..basic_stream_file] 
Release ownership of the underlying native file. 


  native_handle_type ``[link boost_asio.reference.basic_stream_file.release.overload1 release]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.release.overload1 more...]]``

  native_handle_type ``[link boost_asio.reference.basic_stream_file.release.overload2 release]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.release.overload2 more...]]``


[section:overload1 basic_stream_file::release (1 of 2 overloads)]


['Inherited from basic_file.]


Release ownership of the underlying native file. 


  native_handle_type release();


This function causes all outstanding asynchronous read and write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native file is then transferred to the caller.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]



[section:overload2 basic_stream_file::release (2 of 2 overloads)]


['Inherited from basic_file.]


Release ownership of the underlying native file. 


  native_handle_type release(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read and write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native file is then transferred to the caller.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]


[endsect]

[section:resize basic_stream_file::resize]

[indexterm2 boost_asio.indexterm.basic_stream_file.resize..resize..basic_stream_file] 
Alter the size of the file. 


  void ``[link boost_asio.reference.basic_stream_file.resize.overload1 resize]``(
      uint64_t n);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.resize.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_file.resize.overload2 resize]``(
      uint64_t n,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.resize.overload2 more...]]``


[section:overload1 basic_stream_file::resize (1 of 2 overloads)]


['Inherited from basic_file.]


Alter the size of the file. 


  void resize(
      uint64_t n);


This function resizes the file to the specified size, in bytes. If the current file size exceeds `n` then any extra data is discarded. If the current size is less than `n` then the file is extended and filled with zeroes.


[heading Parameters]
    

[variablelist
  
[[n][The new size for the file.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_stream_file::resize (2 of 2 overloads)]


['Inherited from basic_file.]


Alter the size of the file. 


  void resize(
      uint64_t n,
      boost::system::error_code & ec);


This function resizes the file to the specified size, in bytes. If the current file size exceeds `n` then any extra data is discarded. If the current size is less than `n` then the file is extended and filled with zeroes.


[heading Parameters]
    

[variablelist
  
[[n][The new size for the file.]]

[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:seek basic_stream_file::seek]

[indexterm2 boost_asio.indexterm.basic_stream_file.seek..seek..basic_stream_file] 
Seek to a position in the file. 


  uint64_t ``[link boost_asio.reference.basic_stream_file.seek.overload1 seek]``(
      int64_t offset,
      file_base::seek_basis whence);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.seek.overload1 more...]]``

  uint64_t ``[link boost_asio.reference.basic_stream_file.seek.overload2 seek]``(
      int64_t offset,
      file_base::seek_basis whence,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.seek.overload2 more...]]``


[section:overload1 basic_stream_file::seek (1 of 2 overloads)]


Seek to a position in the file. 


  uint64_t seek(
      int64_t offset,
      file_base::seek_basis whence);


This function updates the current position in the file.


[heading Parameters]
    

[variablelist
  
[[offset][The requested position in the file, relative to `whence`.]]

[[whence][One of `seek_set`, `seek_cur` or `seek_end`.]]

]


[heading Return Value]
      
The new position relative to the beginning of the file.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_stream_file::seek (2 of 2 overloads)]


Seek to a position in the file. 


  uint64_t seek(
      int64_t offset,
      file_base::seek_basis whence,
      boost::system::error_code & ec);


This function updates the current position in the file.


[heading Parameters]
    

[variablelist
  
[[offset][The requested position in the file, relative to `whence`.]]

[[whence][One of `seek_set`, `seek_cur` or `seek_end`.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The new position relative to the beginning of the file. 




[endsect]


[endsect]


[section:seek_basis basic_stream_file::seek_basis]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_stream_file.seek_basis..seek_basis..basic_stream_file] 
Basis for seeking in a file. 

  enum seek_basis

[indexterm2 boost_asio.indexterm.basic_stream_file.seek_basis.seek_set..seek_set..basic_stream_file]
[indexterm2 boost_asio.indexterm.basic_stream_file.seek_basis.seek_cur..seek_cur..basic_stream_file]
[indexterm2 boost_asio.indexterm.basic_stream_file.seek_basis.seek_end..seek_end..basic_stream_file]

[heading Values]
[variablelist

  [
    [seek_set]
    [Seek to an absolute position. ]
  ]

  [
    [seek_cur]
    [Seek to an offset relative to the current file position. ]
  ]

  [
    [seek_end]
    [Seek to an offset relative to the end of the file. ]
  ]

]



[endsect]


[section:size basic_stream_file::size]

[indexterm2 boost_asio.indexterm.basic_stream_file.size..size..basic_stream_file] 
Get the size of the file. 


  uint64_t ``[link boost_asio.reference.basic_stream_file.size.overload1 size]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.size.overload1 more...]]``

  uint64_t ``[link boost_asio.reference.basic_stream_file.size.overload2 size]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.size.overload2 more...]]``


[section:overload1 basic_stream_file::size (1 of 2 overloads)]


['Inherited from basic_file.]


Get the size of the file. 


  uint64_t size() const;


This function determines the size of the file, in bytes.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_stream_file::size (2 of 2 overloads)]


['Inherited from basic_file.]


Get the size of the file. 


  uint64_t size(
      boost::system::error_code & ec) const;


This function determines the size of the file, in bytes.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:sync_all basic_stream_file::sync_all]

[indexterm2 boost_asio.indexterm.basic_stream_file.sync_all..sync_all..basic_stream_file] 
Synchronise the file to disk. 


  void ``[link boost_asio.reference.basic_stream_file.sync_all.overload1 sync_all]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.sync_all.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_file.sync_all.overload2 sync_all]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.sync_all.overload2 more...]]``


[section:overload1 basic_stream_file::sync_all (1 of 2 overloads)]


['Inherited from basic_file.]


Synchronise the file to disk. 


  void sync_all();


This function synchronises the file data and metadata to disk. Note that the semantics of this synchronisation vary between operation systems.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_stream_file::sync_all (2 of 2 overloads)]


['Inherited from basic_file.]


Synchronise the file to disk. 


  void sync_all(
      boost::system::error_code & ec);


This function synchronises the file data and metadata to disk. Note that the semantics of this synchronisation vary between operation systems.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:sync_data basic_stream_file::sync_data]

[indexterm2 boost_asio.indexterm.basic_stream_file.sync_data..sync_data..basic_stream_file] 
Synchronise the file data to disk. 


  void ``[link boost_asio.reference.basic_stream_file.sync_data.overload1 sync_data]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.sync_data.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_file.sync_data.overload2 sync_data]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.sync_data.overload2 more...]]``


[section:overload1 basic_stream_file::sync_data (1 of 2 overloads)]


['Inherited from basic_file.]


Synchronise the file data to disk. 


  void sync_data();


This function synchronises the file data to disk. Note that the semantics of this synchronisation vary between operation systems.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_stream_file::sync_data (2 of 2 overloads)]


['Inherited from basic_file.]


Synchronise the file data to disk. 


  void sync_data(
      boost::system::error_code & ec);


This function synchronises the file data to disk. Note that the semantics of this synchronisation vary between operation systems.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:truncate basic_stream_file::truncate]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_stream_file.truncate..truncate..basic_stream_file] 
Open the file with any existing contents truncated. 


  static const flags truncate = implementation_defined;



[endsect]



[section:write_only basic_stream_file::write_only]


['Inherited from file_base.]

[indexterm2 boost_asio.indexterm.basic_stream_file.write_only..write_only..basic_stream_file] 
Open the file for writing. 


  static const flags write_only = implementation_defined;



[endsect]


[section:write_some basic_stream_file::write_some]

[indexterm2 boost_asio.indexterm.basic_stream_file.write_some..write_some..basic_stream_file] 
Write some data to the file. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_file.write_some.overload1 write_some]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.write_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_file.write_some.overload2 write_some]``(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_file.write_some.overload2 more...]]``


[section:overload1 basic_stream_file::write_some (1 of 2 overloads)]


Write some data to the file. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers);


This function is used to write data to the stream file. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the file.]]

]


[heading Return Value]
      
The number of bytes written.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the end of the file was reached.]]

]


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   file.write_some(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_stream_file::write_some (2 of 2 overloads)]


Write some data to the file. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to write data to the stream file. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the file.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. Returns 0 if an error occurred.


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]


[endsect]


[section:_basic_stream_file basic_stream_file::~basic_stream_file]

[indexterm2 boost_asio.indexterm.basic_stream_file._basic_stream_file..~basic_stream_file..basic_stream_file] 
Destroys the file. 


  ~basic_stream_file();


This function destroys the file, cancelling any outstanding asynchronous operations associated with the file as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_stream_file__rebind_executor basic_stream_file::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_stream_file__rebind_executor..basic_stream_file::rebind_executor]


Rebinds the file type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_stream_file__rebind_executor.other [*other]]]
    [The file type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_stream_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_stream_file::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_stream_file__rebind_executor.other..other..basic_stream_file::rebind_executor] 
The file type when rebound to the specified executor. 


  typedef basic_stream_file< Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_stream_file__rebind_executor [*rebind_executor]]]
    [Rebinds the file type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_file.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_file.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_file.native_handle_type [*native_handle_type]]]
    [The native representation of a file. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_file.seek_basis [*seek_basis]]]
    [Basis for seeking in a file. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_file.assign [*assign]]]
    [Assign an existing native file to the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.basic_stream_file [*basic_stream_file]] [constructor]]
    [Construct a basic_stream_file without opening it. 
     [hr]
     Construct and open a basic_stream_file. 
     [hr]
     Construct a basic_stream_file on an existing native file. 
     [hr]
     Move-construct a basic_stream_file from another. 
     [hr]
     Move-construct a basic_stream_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.close [*close]]]
    [Close the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.is_open [*is_open]]]
    [Determine whether the file is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.native_handle [*native_handle]]]
    [Get the native file representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.open [*open]]]
    [Open the file using the specified path. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.operator_eq_ [*operator=]]]
    [Move-assign a basic_stream_file from another. 
     [hr]
     Move-assign a basic_stream_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.read_some [*read_some]]]
    [Read some data from the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.release [*release]]]
    [Release ownership of the underlying native file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.resize [*resize]]]
    [Alter the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.seek [*seek]]]
    [Seek to a position in the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.size [*size]]]
    [Get the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.sync_all [*sync_all]]]
    [Synchronise the file to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.sync_data [*sync_data]]]
    [Synchronise the file data to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.write_some [*write_some]]]
    [Write some data to the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file._basic_stream_file [*~basic_stream_file]] [destructor]]
    [Destroys the file. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_file.append [*append]] [static]]
    [Open the file in append mode. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.create [*create]] [static]]
    [Create the file if it does not exist. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.exclusive [*exclusive]] [static]]
    [Ensure a new file is created. Must be combined with create. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.read_only [*read_only]] [static]]
    [Open the file for reading. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.read_write [*read_write]] [static]]
    [Open the file for reading and writing. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.truncate [*truncate]] [static]]
    [Open the file with any existing contents truncated. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.write_only [*write_only]] [static]]
    [Open the file for writing. ]
  ]

]

The [link boost_asio.reference.basic_stream_file `basic_stream_file`] class template provides asynchronous and blocking stream-oriented file functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.





[heading Requirements]

['Header: ][^boost/asio/basic_stream_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_stream_socket basic_stream_socket]

[indexterm1 boost_asio.indexterm.basic_stream_socket..basic_stream_socket]


Provides stream-oriented socket functionality. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class basic_stream_socket :
    public basic_socket< Protocol, Executor >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_stream_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_send [*async_send]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.basic_stream_socket [*basic_stream_socket]] [constructor]]
    [Construct a basic_stream_socket without opening it. 
     [hr]
     Construct and open a basic_stream_socket. 
     [hr]
     Construct a basic_stream_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_stream_socket on an existing native socket. 
     [hr]
     Move-construct a basic_stream_socket from another. 
     [hr]
     Move-construct a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_stream_socket from another. 
     [hr]
     Move-assign a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.read_some [*read_some]]]
    [Read some data from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.receive [*receive]]]
    [Receive some data on the socket. 
     [hr]
     Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.send [*send]]]
    [Send some data on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.write_some [*write_some]]]
    [Write some data to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket._basic_stream_socket [*~basic_stream_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] class template provides asynchronous and blocking stream-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `receive`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe.




[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign basic_stream_socket::assign]

[indexterm2 boost_asio.indexterm.basic_stream_socket.assign..assign..basic_stream_socket] 
Assign an existing native socket to the socket. 


  void ``[link boost_asio.reference.basic_stream_socket.assign.overload1 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.assign.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_socket.assign.overload2 assign]``(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.assign.overload2 more...]]``


[section:overload1 basic_stream_socket::assign (1 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket);



[endsect]



[section:overload2 basic_stream_socket::assign (2 of 2 overloads)]


['Inherited from basic_socket.]


Assign an existing native socket to the socket. 


  void assign(
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_connect basic_stream_socket::async_connect]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.async_connect..async_connect..basic_stream_socket] 
Start an asynchronous connect. 


  template<
      typename ``[link boost_asio.reference.ConnectHandler ConnectHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_connect(
      const endpoint_type & peer_endpoint,
      ConnectHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.]]

[[handler][The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void connect_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Connect succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.async_connect(endpoint, connect_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:async_read_some basic_stream_socket::async_read_some]

[indexterm2 boost_asio.indexterm.basic_stream_socket.async_read_some..async_read_some..basic_stream_socket] 
Start an asynchronous read. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_some(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data from the stream socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes read.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The read operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.async_read `async_read`]  function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_read_some(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:async_receive basic_stream_socket::async_receive]

[indexterm2 boost_asio.indexterm.basic_stream_socket.async_receive..async_receive..basic_stream_socket] 
Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_stream_socket.async_receive.overload1 async_receive]``(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.async_receive.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_stream_socket.async_receive.overload2 async_receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.async_receive.overload2 more...]]``


[section:overload1 basic_stream_socket::async_receive (1 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive data from the stream socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The receive operation may not receive all of the requested number of bytes. Consider using the [link boost_asio.reference.async_read `async_read`]  function if you need to ensure that the requested amount of data is received before the asynchronous operation completes.


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_receive(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_stream_socket::async_receive (2 of 2 overloads)]


Start an asynchronous receive. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously receive data from the stream socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[handler][The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes received.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The receive operation may not receive all of the requested number of bytes. Consider using the [link boost_asio.reference.async_read `async_read`]  function if you need to ensure that the requested amount of data is received before the asynchronous operation completes.


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_receive(boost::asio::buffer(data, size), 0, handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]

[section:async_send basic_stream_socket::async_send]

[indexterm2 boost_asio.indexterm.basic_stream_socket.async_send..async_send..basic_stream_socket] 
Start an asynchronous send. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_stream_socket.async_send.overload1 async_send]``(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.async_send.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.basic_stream_socket.async_send.overload2 async_send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.async_send.overload2 more...]]``


[section:overload1 basic_stream_socket::async_send (1 of 2 overloads)]


Start an asynchronous send. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously send data on the stream socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The send operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.async_write `async_write`]  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_send(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:overload2 basic_stream_socket::async_send (2 of 2 overloads)]


Start an asynchronous send. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously send data on the stream socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[flags][Flags specifying how the send call is to be made.]]

[[handler][The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes sent.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The send operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.async_write `async_write`]  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_send(boost::asio::buffer(data, size), 0, handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[endsect]


[section:async_wait basic_stream_socket::async_wait]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.async_wait..async_wait..basic_stream_socket] 
Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  template<
      typename ``[link boost_asio.reference.WaitHandler WaitHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_wait(
      wait_type w,
      WaitHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to perform an asynchronous wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[handler][The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void wait_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Wait succeeded.
     }
   }

   ...

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);





[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:async_write_some basic_stream_socket::async_write_some]

[indexterm2 boost_asio.indexterm.basic_stream_socket.async_write_some..async_write_some..basic_stream_socket] 
Start an asynchronous write. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_some(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write data to the stream socket. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes written.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The write operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.async_write `async_write`]  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.async_write_some(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
On POSIX or Windows operating systems, this asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:at_mark basic_stream_socket::at_mark]

[indexterm2 boost_asio.indexterm.basic_stream_socket.at_mark..at_mark..basic_stream_socket] 
Determine whether the socket is at the out-of-band data mark. 


  bool ``[link boost_asio.reference.basic_stream_socket.at_mark.overload1 at_mark]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.at_mark.overload1 more...]]``

  bool ``[link boost_asio.reference.basic_stream_socket.at_mark.overload2 at_mark]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.at_mark.overload2 more...]]``


[section:overload1 basic_stream_socket::at_mark (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark() const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_stream_socket::at_mark (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine whether the socket is at the out-of-band data mark. 


  bool at_mark(
      boost::system::error_code & ec) const;


This function is used to check whether the socket input is currently positioned at the out-of-band data mark.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A bool indicating whether the socket is at the out-of-band data mark. 




[endsect]


[endsect]

[section:available basic_stream_socket::available]

[indexterm2 boost_asio.indexterm.basic_stream_socket.available..available..basic_stream_socket] 
Determine the number of bytes available for reading. 


  std::size_t ``[link boost_asio.reference.basic_stream_socket.available.overload1 available]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.available.overload1 more...]]``

  std::size_t ``[link boost_asio.reference.basic_stream_socket.available.overload2 available]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.available.overload2 more...]]``


[section:overload1 basic_stream_socket::available (1 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available() const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_stream_socket::available (2 of 2 overloads)]


['Inherited from basic_socket.]


Determine the number of bytes available for reading. 


  std::size_t available(
      boost::system::error_code & ec) const;


This function is used to determine the number of bytes that may be read without blocking.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes that may be read without blocking, or 0 if an error occurs. 




[endsect]


[endsect]

[section:basic_stream_socket basic_stream_socket::basic_stream_socket]

[indexterm2 boost_asio.indexterm.basic_stream_socket.basic_stream_socket..basic_stream_socket..basic_stream_socket] 
Construct a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] without opening it. 


  explicit ``[link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload1 basic_stream_socket]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload2 basic_stream_socket]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload2 more...]]``


Construct and open a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`]. 


  ``[link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload3 basic_stream_socket]``(
      const executor_type & ex,
      const protocol_type & protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload4 basic_stream_socket]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload4 more...]]``


Construct a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`], opening it and binding it to the given local endpoint. 


  ``[link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload5 basic_stream_socket]``(
      const executor_type & ex,
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload5 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload6 basic_stream_socket]``(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload6 more...]]``


Construct a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] on an existing native socket. 


  ``[link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload7 basic_stream_socket]``(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_socket);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload7 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload8 basic_stream_socket]``(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload8 more...]]``


Move-construct a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] from another. 


  ``[link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload9 basic_stream_socket]``(
      basic_stream_socket && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload9 more...]]``


Move-construct a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload10 basic_stream_socket]``(
      basic_stream_socket< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.basic_stream_socket.overload10 more...]]``


[section:overload1 basic_stream_socket::basic_stream_socket (1 of 10 overloads)]


Construct a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] without opening it. 


  basic_stream_socket(
      const executor_type & ex);


This constructor creates a stream socket without opening it. The socket needs to be opened and then connected or accepted before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload2 basic_stream_socket::basic_stream_socket (2 of 10 overloads)]


Construct a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] without opening it. 


  template<
      typename ExecutionContext>
  basic_stream_socket(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a stream socket without opening it. The socket needs to be opened and then connected or accepted before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. ]]

]




[endsect]



[section:overload3 basic_stream_socket::basic_stream_socket (3 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`]. 


  basic_stream_socket(
      const executor_type & ex,
      const protocol_type & protocol);


This constructor creates and opens a stream socket. The socket needs to be connected or accepted before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_stream_socket::basic_stream_socket (4 of 10 overloads)]


Construct and open a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`]. 


  template<
      typename ExecutionContext>
  basic_stream_socket(
      ExecutionContext & context,
      const protocol_type & protocol,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates and opens a stream socket. The socket needs to be connected or accepted before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_stream_socket::basic_stream_socket (5 of 10 overloads)]


Construct a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`], opening it and binding it to the given local endpoint. 


  basic_stream_socket(
      const executor_type & ex,
      const endpoint_type & endpoint);


This constructor creates a stream socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the stream socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload6 basic_stream_socket::basic_stream_socket (6 of 10 overloads)]


Construct a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`], opening it and binding it to the given local endpoint. 


  template<
      typename ExecutionContext>
  basic_stream_socket(
      ExecutionContext & context,
      const endpoint_type & endpoint,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a stream socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[endpoint][An endpoint on the local machine to which the stream socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload7 basic_stream_socket::basic_stream_socket (7 of 10 overloads)]


Construct a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] on an existing native socket. 


  basic_stream_socket(
      const executor_type & ex,
      const protocol_type & protocol,
      const native_handle_type & native_socket);


This constructor creates a stream socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][The new underlying socket implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 basic_stream_socket::basic_stream_socket (8 of 10 overloads)]


Construct a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] on an existing native socket. 


  template<
      typename ExecutionContext>
  basic_stream_socket(
      ExecutionContext & context,
      const protocol_type & protocol,
      const native_handle_type & native_socket,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a stream socket object to hold an existing native socket.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.]]

[[protocol][An object specifying protocol parameters to be used.]]

[[native_socket][The new underlying socket implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload9 basic_stream_socket::basic_stream_socket (9 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] from another. 


  basic_stream_socket(
      basic_stream_socket && other);


This constructor moves a stream socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_socket(const executor_type&)` constructor. 




[endsect]



[section:overload10 basic_stream_socket::basic_stream_socket (10 of 10 overloads)]


Move-construct a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_stream_socket(
      basic_stream_socket< Protocol1, Executor1 > && other,
      typename constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value >::type  = 0);


This constructor moves a stream socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_socket(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:bind basic_stream_socket::bind]

[indexterm2 boost_asio.indexterm.basic_stream_socket.bind..bind..basic_stream_socket] 
Bind the socket to the given local endpoint. 


  void ``[link boost_asio.reference.basic_stream_socket.bind.overload1 bind]``(
      const endpoint_type & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.bind.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_socket.bind.overload2 bind]``(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.bind.overload2 more...]]``


[section:overload1 basic_stream_socket::bind (1 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());
   socket.bind(boost::asio::ip::tcp::endpoint(
         boost::asio::ip::tcp::v4(), 12345));







[endsect]



[section:overload2 basic_stream_socket::bind (2 of 2 overloads)]


['Inherited from basic_socket.]


Bind the socket to the given local endpoint. 


  void bind(
      const endpoint_type & endpoint,
      boost::system::error_code & ec);


This function binds the socket to the specified endpoint on the local machine.


[heading Parameters]
    

[variablelist
  
[[endpoint][An endpoint on the local machine to which the socket will be bound.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());
   boost::system::error_code ec;
   socket.bind(boost::asio::ip::tcp::endpoint(
         boost::asio::ip::tcp::v4(), 12345), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:broadcast basic_stream_socket::broadcast]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.broadcast..broadcast..basic_stream_socket] 
Socket option to permit sending of broadcast messages. 


  typedef implementation_defined broadcast;



Implements the SOL\_SOCKET/SO\_BROADCAST socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:bytes_readable basic_stream_socket::bytes_readable]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.bytes_readable..bytes_readable..basic_stream_socket] 
IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::bytes_readable command(true);
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:cancel basic_stream_socket::cancel]

[indexterm2 boost_asio.indexterm.basic_stream_socket.cancel..cancel..basic_stream_socket] 
Cancel all asynchronous operations associated with the socket. 


  void ``[link boost_asio.reference.basic_stream_socket.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_socket.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.cancel.overload2 more...]]``


[section:overload1 basic_stream_socket::cancel (1 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining BOOST\_ASIO\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]



[section:overload2 basic_stream_socket::cancel (2 of 2 overloads)]


['Inherited from basic_socket.]


Cancel all asynchronous operations associated with the socket. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls to `cancel()` will always fail with `boost::asio::error::operation_not_supported` when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST\_ASIO\_ENABLE\_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:


* It will only cancel asynchronous operations that were initiated in the current thread.


* It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.

For portable cancellation, consider using one of the following alternatives:


* Disable asio's I/O completion port backend by defining BOOST\_ASIO\_DISABLE\_IOCP.


* Use the `close()` function to simultaneously cancel the outstanding operations and close the socket.

When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. 


[endsect]


[endsect]

[section:close basic_stream_socket::close]

[indexterm2 boost_asio.indexterm.basic_stream_socket.close..close..basic_stream_socket] 
Close the socket. 


  void ``[link boost_asio.reference.basic_stream_socket.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.close.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_socket.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.close.overload2 more...]]``


[section:overload1 basic_stream_socket::close (1 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close();


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]



[section:overload2 basic_stream_socket::close (2 of 2 overloads)]


['Inherited from basic_socket.]


Close the socket. 


  void close(
      boost::system::error_code & ec);


This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.close(ec);
   if (ec)
   {
     // An error occurred.
   }





[heading Remarks]
      
For portable behaviour with respect to graceful closure of a connected socket, call `shutdown()` before closing the socket. 




[endsect]


[endsect]

[section:connect basic_stream_socket::connect]

[indexterm2 boost_asio.indexterm.basic_stream_socket.connect..connect..basic_stream_socket] 
Connect the socket to the specified endpoint. 


  void ``[link boost_asio.reference.basic_stream_socket.connect.overload1 connect]``(
      const endpoint_type & peer_endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.connect.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_socket.connect.overload2 connect]``(
      const endpoint_type & peer_endpoint,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.connect.overload2 more...]]``


[section:overload1 basic_stream_socket::connect (1 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   socket.connect(endpoint);







[endsect]



[section:overload2 basic_stream_socket::connect (2 of 2 overloads)]


['Inherited from basic_socket.]


Connect the socket to the specified endpoint. 


  void connect(
      const endpoint_type & peer_endpoint,
      boost::system::error_code & ec);


This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.

The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.


[heading Parameters]
    

[variablelist
  
[[peer_endpoint][The remote endpoint to which the socket will be connected.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::asio::ip::tcp::endpoint endpoint(
       boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   boost::system::error_code ec;
   socket.connect(endpoint, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:debug basic_stream_socket::debug]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.debug..debug..basic_stream_socket] 
Socket option to enable socket-level debugging. 


  typedef implementation_defined debug;



Implements the SOL\_SOCKET/SO\_DEBUG socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:do_not_route basic_stream_socket::do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.do_not_route..do_not_route..basic_stream_socket] 
Socket option to prevent routing, use local interfaces only. 


  typedef implementation_defined do_not_route;



Implements the SOL\_SOCKET/SO\_DONTROUTE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:enable_connection_aborted basic_stream_socket::enable_connection_aborted]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.enable_connection_aborted..enable_connection_aborted..basic_stream_socket] 
Socket option to report aborted connections on accept. 


  typedef implementation_defined enable_connection_aborted;



Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:endpoint_type basic_stream_socket::endpoint_type]

[indexterm2 boost_asio.indexterm.basic_stream_socket.endpoint_type..endpoint_type..basic_stream_socket] 
The endpoint type. 


  typedef Protocol::endpoint endpoint_type;



[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:executor_type basic_stream_socket::executor_type]

[indexterm2 boost_asio.indexterm.basic_stream_socket.executor_type..executor_type..basic_stream_socket] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_stream_socket::get_executor]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.get_executor..get_executor..basic_stream_socket] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:get_option basic_stream_socket::get_option]

[indexterm2 boost_asio.indexterm.basic_stream_socket.get_option..get_option..basic_stream_socket] 
Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_stream_socket.get_option.overload1 get_option]``(
      GettableSocketOption & option) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.get_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void ``[link boost_asio.reference.basic_stream_socket.get_option.overload2 get_option]``(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.get_option.overload2 more...]]``


[section:overload1 basic_stream_socket::get_option (1 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[endsect]



[section:overload2 basic_stream_socket::get_option (2 of 2 overloads)]


['Inherited from basic_socket.]


Get an option from the socket. 


  template<
      typename ``[link boost_asio.reference.GettableSocketOption GettableSocketOption]``>
  void get_option(
      GettableSocketOption & option,
      boost::system::error_code & ec) const;


This function is used to get the current value of an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The option value to be obtained from the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the value of the SOL\_SOCKET/SO\_KEEPALIVE option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::keep_alive option;
   boost::system::error_code ec;
   socket.get_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }
   bool is_set = option.value();







[endsect]


[endsect]

[section:io_control basic_stream_socket::io_control]

[indexterm2 boost_asio.indexterm.basic_stream_socket.io_control..io_control..basic_stream_socket] 
Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_stream_socket.io_control.overload1 io_control]``(
      IoControlCommand & command);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.io_control.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.basic_stream_socket.io_control.overload2 io_control]``(
      IoControlCommand & command,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.io_control.overload2 more...]]``


[section:overload1 basic_stream_socket::io_control (1 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::bytes_readable command;
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[endsect]



[section:overload2 basic_stream_socket::io_control (2 of 2 overloads)]


['Inherited from basic_socket.]


Perform an IO control command on the socket. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command,
      boost::system::error_code & ec);


This function is used to execute an IO control command on the socket.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::socket::bytes_readable command;
   boost::system::error_code ec;
   socket.io_control(command, ec);
   if (ec)
   {
     // An error occurred.
   }
   std::size_t bytes_readable = command.get();







[endsect]


[endsect]


[section:is_open basic_stream_socket::is_open]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.is_open..is_open..basic_stream_socket] 
Determine whether the socket is open. 


  bool is_open() const;



[endsect]



[section:keep_alive basic_stream_socket::keep_alive]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.keep_alive..keep_alive..basic_stream_socket] 
Socket option to send keep-alives. 


  typedef implementation_defined keep_alive;



Implements the SOL\_SOCKET/SO\_KEEPALIVE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:linger basic_stream_socket::linger]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.linger..linger..basic_stream_socket] 
Socket option to specify whether the socket lingers on close if unsent data is present. 


  typedef implementation_defined linger;



Implements the SOL\_SOCKET/SO\_LINGER socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option(true, 30);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option;
   socket.get_option(option);
   bool is_set = option.enabled();
   unsigned short timeout = option.timeout();







[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:local_endpoint basic_stream_socket::local_endpoint]

[indexterm2 boost_asio.indexterm.basic_stream_socket.local_endpoint..local_endpoint..basic_stream_socket] 
Get the local endpoint of the socket. 


  endpoint_type ``[link boost_asio.reference.basic_stream_socket.local_endpoint.overload1 local_endpoint]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.local_endpoint.overload1 more...]]``

  endpoint_type ``[link boost_asio.reference.basic_stream_socket.local_endpoint.overload2 local_endpoint]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.local_endpoint.overload2 more...]]``


[section:overload1 basic_stream_socket::local_endpoint (1 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint() const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Return Value]
      
An object that represents the local endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();







[endsect]



[section:overload2 basic_stream_socket::local_endpoint (2 of 2 overloads)]


['Inherited from basic_socket.]


Get the local endpoint of the socket. 


  endpoint_type local_endpoint(
      boost::system::error_code & ec) const;


This function is used to obtain the locally bound endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:lowest_layer basic_stream_socket::lowest_layer]

[indexterm2 boost_asio.indexterm.basic_stream_socket.lowest_layer..lowest_layer..basic_stream_socket] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.basic_stream_socket.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.basic_stream_socket.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.lowest_layer.overload2 more...]]``


[section:overload1 basic_stream_socket::lowest_layer (1 of 2 overloads)]


['Inherited from basic_socket.]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_socket `basic_socket`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 basic_stream_socket::lowest_layer (2 of 2 overloads)]


['Inherited from basic_socket.]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_socket `basic_socket`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type basic_stream_socket::lowest_layer_type]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.lowest_layer_type..lowest_layer_type..basic_stream_socket] 
A [link boost_asio.reference.basic_socket `basic_socket`] is always the lowest layer. 


  typedef basic_socket< Protocol, Executor > lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.basic_socket [*basic_socket]] [constructor]]
    [Construct a basic_socket without opening it. 
     [hr]
     Construct and open a basic_socket. 
     [hr]
     Construct a basic_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_socket on an existing native socket. 
     [hr]
     Move-construct a basic_socket from another. 
     [hr]
     Move-construct a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket from another. 
     [hr]
     Move-assign a basic_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket._basic_socket [*~basic_socket]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_socket `basic_socket`] class template provides functionality that is common to both stream-oriented and datagram-oriented sockets.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:max_connections basic_stream_socket::max_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.max_connections..max_connections..basic_stream_socket] 
(Deprecated: Use max\_listen\_connections.) The maximum length of the queue of pending incoming connections. 


  static const int max_connections = implementation_defined;



[endsect]



[section:max_listen_connections basic_stream_socket::max_listen_connections]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.max_listen_connections..max_listen_connections..basic_stream_socket] 
The maximum length of the queue of pending incoming connections. 


  static const int max_listen_connections = implementation_defined;



[endsect]



[section:message_do_not_route basic_stream_socket::message_do_not_route]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.message_do_not_route..message_do_not_route..basic_stream_socket] 
Specify that the data should not be subject to routing. 


  static const int message_do_not_route = implementation_defined;



[endsect]



[section:message_end_of_record basic_stream_socket::message_end_of_record]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.message_end_of_record..message_end_of_record..basic_stream_socket] 
Specifies that the data marks the end of a record. 


  static const int message_end_of_record = implementation_defined;



[endsect]



[section:message_flags basic_stream_socket::message_flags]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.message_flags..message_flags..basic_stream_socket] 
Bitmask type for flags that can be passed to send and receive operations. 


  typedef int message_flags;



[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:message_out_of_band basic_stream_socket::message_out_of_band]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.message_out_of_band..message_out_of_band..basic_stream_socket] 
Process out-of-band data. 


  static const int message_out_of_band = implementation_defined;



[endsect]



[section:message_peek basic_stream_socket::message_peek]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.message_peek..message_peek..basic_stream_socket] 
Peek at incoming data without removing it from the input queue. 


  static const int message_peek = implementation_defined;



[endsect]



[section:native_handle basic_stream_socket::native_handle]


['Inherited from basic_socket.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.native_handle..native_handle..basic_stream_socket] 
Get the native socket representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_stream_socket::native_handle_type]

[indexterm2 boost_asio.indexterm.basic_stream_socket.native_handle_type..native_handle_type..basic_stream_socket] 
The native representation of a socket. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:native_non_blocking basic_stream_socket::native_non_blocking]

[indexterm2 boost_asio.indexterm.basic_stream_socket.native_non_blocking..native_non_blocking..basic_stream_socket] 
Gets the non-blocking mode of the native socket implementation. 


  bool ``[link boost_asio.reference.basic_stream_socket.native_non_blocking.overload1 native_non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.native_non_blocking.overload1 more...]]``


Sets the non-blocking mode of the native socket implementation. 


  void ``[link boost_asio.reference.basic_stream_socket.native_non_blocking.overload2 native_non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.native_non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.basic_stream_socket.native_non_blocking.overload3 native_non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.native_non_blocking.overload3 more...]]``


[section:overload1 basic_stream_socket::native_non_blocking (1 of 3 overloads)]


['Inherited from basic_socket.]


Gets the non-blocking mode of the native socket implementation. 


  bool native_non_blocking() const;


This function is used to retrieve the non-blocking mode of the underlying native socket. This mode has no effect on the behaviour of the socket object's synchronous operations.


[heading Return Value]
      
`true` if the underlying socket is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).


[heading Remarks]
      
The current non-blocking mode is cached by the socket object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native socket.


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload2 basic_stream_socket::native_non_blocking (2 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]



[section:overload3 basic_stream_socket::native_non_blocking (3 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the native socket implementation. 


  void native_non_blocking(
      bool mode,
      boost::system::error_code & ec);


This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying socket is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense.]]

]


[heading Example]
  
This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's `sendfile` system call might be encapsulated: 

   template <typename Handler>
   struct sendfile_op
   {
     tcp::socket& sock_;
     int fd_;
     Handler handler_;
     off_t offset_;
     std::size_t total_bytes_transferred_;

     // Function call operator meeting WriteHandler requirements.
     // Used as the handler for the async_write_some operation.
     void operator()(boost::system::error_code ec, std::size_t)
     {
       // Put the underlying socket into non-blocking mode.
       if (!ec)
         if (!sock_.native_non_blocking())
           sock_.native_non_blocking(true, ec);

       if (!ec)
       {
         for (;;)
         {
           // Try the system call.
           errno = 0;
           int n = ::sendfile(sock_.native_handle(), fd_, &offset_, 65536);
           ec = boost::system::error_code(n < 0 ? errno : 0,
               boost::asio::error::get_system_category());
           total_bytes_transferred_ += ec ? 0 : n;

           // Retry operation immediately if interrupted by signal.
           if (ec == boost::asio::error::interrupted)
             continue;

           // Check if we need to run the operation again.
           if (ec == boost::asio::error::would_block
               || ec == boost::asio::error::try_again)
           {
             // We have to wait for the socket to become ready again.
             sock_.async_wait(tcp::socket::wait_write, *this);
             return;
           }

           if (ec || n == 0)
           {
             // An error occurred, or we have reached the end of the file.
             // Either way we must exit the loop so we can call the handler.
             break;
           }

           // Loop around to try calling sendfile again.
         }
       }

       // Pass result back to user's handler.
       handler_(ec, total_bytes_transferred_);
     }
   };

   template <typename Handler>
   void async_sendfile(tcp::socket& sock, int fd, Handler h)
   {
     sendfile_op<Handler> op = { sock, fd, h, 0, 0 };
     sock.async_wait(tcp::socket::wait_write, op);
   } 







[endsect]


[endsect]

[section:non_blocking basic_stream_socket::non_blocking]

[indexterm2 boost_asio.indexterm.basic_stream_socket.non_blocking..non_blocking..basic_stream_socket] 
Gets the non-blocking mode of the socket. 


  bool ``[link boost_asio.reference.basic_stream_socket.non_blocking.overload1 non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.non_blocking.overload1 more...]]``


Sets the non-blocking mode of the socket. 


  void ``[link boost_asio.reference.basic_stream_socket.non_blocking.overload2 non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.basic_stream_socket.non_blocking.overload3 non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.non_blocking.overload3 more...]]``


[section:overload1 basic_stream_socket::non_blocking (1 of 3 overloads)]


['Inherited from basic_socket.]


Gets the non-blocking mode of the socket. 


  bool non_blocking() const;



[heading Return Value]
      
`true` if the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload2 basic_stream_socket::non_blocking (2 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload3 basic_stream_socket::non_blocking (3 of 3 overloads)]


['Inherited from basic_socket.]


Sets the non-blocking mode of the socket. 


  void non_blocking(
      bool mode,
      boost::system::error_code & ec);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the socket's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]


[endsect]

[section:open basic_stream_socket::open]

[indexterm2 boost_asio.indexterm.basic_stream_socket.open..open..basic_stream_socket] 
Open the socket using the specified protocol. 


  void ``[link boost_asio.reference.basic_stream_socket.open.overload1 open]``(
      const protocol_type & protocol = protocol_type());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.open.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_socket.open.overload2 open]``(
      const protocol_type & protocol,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.open.overload2 more...]]``


[section:overload1 basic_stream_socket::open (1 of 2 overloads)]


['Inherited from basic_socket.]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol = protocol_type());


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying protocol parameters to be used.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   socket.open(boost::asio::ip::tcp::v4());







[endsect]



[section:overload2 basic_stream_socket::open (2 of 2 overloads)]


['Inherited from basic_socket.]


Open the socket using the specified protocol. 


  void open(
      const protocol_type & protocol,
      boost::system::error_code & ec);


This function opens the socket so that it will use the specified protocol.


[heading Parameters]
    

[variablelist
  
[[protocol][An object specifying which protocol is to be used.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   boost::system::error_code ec;
   socket.open(boost::asio::ip::tcp::v4(), ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:operator_eq_ basic_stream_socket::operator=]

[indexterm2 boost_asio.indexterm.basic_stream_socket.operator_eq_..operator=..basic_stream_socket] 
Move-assign a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] from another. 


  basic_stream_socket & ``[link boost_asio.reference.basic_stream_socket.operator_eq_.overload1 operator=]``(
      basic_stream_socket && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.operator_eq_.overload1 more...]]``


Move-assign a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value, basic_stream_socket & >::type ``[link boost_asio.reference.basic_stream_socket.operator_eq_.overload2 operator=]``(
      basic_stream_socket< Protocol1, Executor1 > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.operator_eq_.overload2 more...]]``


[section:overload1 basic_stream_socket::operator= (1 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] from another. 


  basic_stream_socket & operator=(
      basic_stream_socket && other);


This assignment operator moves a stream socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_socket(const executor_type&)` constructor. 




[endsect]



[section:overload2 basic_stream_socket::operator= (2 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] from a socket of another protocol type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol1]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Protocol1, Protocol >::value &&is_convertible< Executor1, Executor >::value, basic_stream_socket & >::type operator=(
      basic_stream_socket< Protocol1, Executor1 > && other);


This assignment operator moves a stream socket from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_socket(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:out_of_band_inline basic_stream_socket::out_of_band_inline]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.out_of_band_inline..out_of_band_inline..basic_stream_socket] 
Socket option for putting received out-of-band data inline. 


  typedef implementation_defined out_of_band_inline;



Implements the SOL\_SOCKET/SO\_OOBINLINE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option;
   socket.get_option(option);
   bool value = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol_type basic_stream_socket::protocol_type]

[indexterm2 boost_asio.indexterm.basic_stream_socket.protocol_type..protocol_type..basic_stream_socket] 
The protocol type. 


  typedef Protocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:read_some basic_stream_socket::read_some]

[indexterm2 boost_asio.indexterm.basic_stream_socket.read_some..read_some..basic_stream_socket] 
Read some data from the socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_socket.read_some.overload1 read_some]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.read_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_socket.read_some.overload2 read_some]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.read_some.overload2 more...]]``


[section:overload1 basic_stream_socket::read_some (1 of 2 overloads)]


Read some data from the socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers);


This function is used to read data from the stream socket. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes read.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.read_some(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_stream_socket::read_some (2 of 2 overloads)]


Read some data from the socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to read data from the stream socket. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. Returns 0 if an error occurred.


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]


[endsect]

[section:receive basic_stream_socket::receive]

[indexterm2 boost_asio.indexterm.basic_stream_socket.receive..receive..basic_stream_socket] 
Receive some data on the socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_socket.receive.overload1 receive]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.receive.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_socket.receive.overload2 receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.receive.overload2 more...]]``


Receive some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_socket.receive.overload3 receive]``(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.receive.overload3 more...]]``


[section:overload1 basic_stream_socket::receive (1 of 3 overloads)]


Receive some data on the socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive(
      const MutableBufferSequence & buffers);


This function is used to receive data on the stream socket. The function call will block until one or more bytes of data has been received successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The receive operation may not receive all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.receive(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_stream_socket::receive (2 of 3 overloads)]


Receive some data on the socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags);


This function is used to receive data on the stream socket. The function call will block until one or more bytes of data has been received successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[flags][Flags specifying how the receive call is to be made.]]

]


[heading Return Value]
      
The number of bytes received.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The receive operation may not receive all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To receive into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.receive(boost::asio::buffer(data, size), 0);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload3 basic_stream_socket::receive (3 of 3 overloads)]


Receive some data on a connected socket. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t receive(
      const MutableBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);


This function is used to receive data on the stream socket. The function call will block until one or more bytes of data has been received successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be received.]]

[[flags][Flags specifying how the receive call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes received. Returns 0 if an error occurred.


[heading Remarks]
      
The receive operation may not receive all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]


[endsect]


[section:receive_buffer_size basic_stream_socket::receive_buffer_size]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.receive_buffer_size..receive_buffer_size..basic_stream_socket] 
Socket option for the receive buffer size of a socket. 


  typedef implementation_defined receive_buffer_size;



Implements the SOL\_SOCKET/SO\_RCVBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:receive_low_watermark basic_stream_socket::receive_low_watermark]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.receive_low_watermark..receive_low_watermark..basic_stream_socket] 
Socket option for the receive low watermark. 


  typedef implementation_defined receive_low_watermark;



Implements the SOL\_SOCKET/SO\_RCVLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:release basic_stream_socket::release]

[indexterm2 boost_asio.indexterm.basic_stream_socket.release..release..basic_stream_socket] 
Release ownership of the underlying native socket. 


  native_handle_type ``[link boost_asio.reference.basic_stream_socket.release.overload1 release]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.release.overload1 more...]]``

  native_handle_type ``[link boost_asio.reference.basic_stream_socket.release.overload2 release]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.release.overload2 more...]]``


[section:overload1 basic_stream_socket::release (1 of 2 overloads)]


['Inherited from basic_socket.]


Release ownership of the underlying native socket. 


  native_handle_type release();


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]



[section:overload2 basic_stream_socket::release (2 of 2 overloads)]


['Inherited from basic_socket.]


Release ownership of the underlying native socket. 


  native_handle_type release(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. Ownership of the native socket is then transferred to the caller.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
This function is unsupported on Windows versions prior to Windows 8.1, and will fail with `boost::asio::error::operation_not_supported` on these platforms. 




[endsect]


[endsect]

[section:remote_endpoint basic_stream_socket::remote_endpoint]

[indexterm2 boost_asio.indexterm.basic_stream_socket.remote_endpoint..remote_endpoint..basic_stream_socket] 
Get the remote endpoint of the socket. 


  endpoint_type ``[link boost_asio.reference.basic_stream_socket.remote_endpoint.overload1 remote_endpoint]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.remote_endpoint.overload1 more...]]``

  endpoint_type ``[link boost_asio.reference.basic_stream_socket.remote_endpoint.overload2 remote_endpoint]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.remote_endpoint.overload2 more...]]``


[section:overload1 basic_stream_socket::remote_endpoint (1 of 2 overloads)]


['Inherited from basic_socket.]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint() const;


This function is used to obtain the remote endpoint of the socket.


[heading Return Value]
      
An object that represents the remote endpoint of the socket.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();







[endsect]



[section:overload2 basic_stream_socket::remote_endpoint (2 of 2 overloads)]


['Inherited from basic_socket.]


Get the remote endpoint of the socket. 


  endpoint_type remote_endpoint(
      boost::system::error_code & ec) const;


This function is used to obtain the remote endpoint of the socket.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:reuse_address basic_stream_socket::reuse_address]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.reuse_address..reuse_address..basic_stream_socket] 
Socket option to allow the socket to be bound to an address that is already in use. 


  typedef implementation_defined reuse_address;



Implements the SOL\_SOCKET/SO\_REUSEADDR socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:send basic_stream_socket::send]

[indexterm2 boost_asio.indexterm.basic_stream_socket.send..send..basic_stream_socket] 
Send some data on the socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_socket.send.overload1 send]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.send.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_socket.send.overload2 send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.send.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_socket.send.overload3 send]``(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.send.overload3 more...]]``


[section:overload1 basic_stream_socket::send (1 of 3 overloads)]


Send some data on the socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send(
      const ConstBufferSequence & buffers);


This function is used to send data on the stream socket. The function call will block until one or more bytes of the data has been sent successfully, or an until error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The send operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes.


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.send(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_stream_socket::send (2 of 3 overloads)]


Send some data on the socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags);


This function is used to send data on the stream socket. The function call will block until one or more bytes of the data has been sent successfully, or an until error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket.]]

[[flags][Flags specifying how the send call is to be made.]]

]


[heading Return Value]
      
The number of bytes sent.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The send operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes.


[heading Example]
  
To send a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.send(boost::asio::buffer(data, size), 0);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload3 basic_stream_socket::send (3 of 3 overloads)]


Send some data on the socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t send(
      const ConstBufferSequence & buffers,
      socket_base::message_flags flags,
      boost::system::error_code & ec);


This function is used to send data on the stream socket. The function call will block until one or more bytes of the data has been sent successfully, or an until error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be sent on the socket.]]

[[flags][Flags specifying how the send call is to be made.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes sent. Returns 0 if an error occurred.


[heading Remarks]
      
The send operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]


[endsect]


[section:send_buffer_size basic_stream_socket::send_buffer_size]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.send_buffer_size..send_buffer_size..basic_stream_socket] 
Socket option for the send buffer size of a socket. 


  typedef implementation_defined send_buffer_size;



Implements the SOL\_SOCKET/SO\_SNDBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:send_low_watermark basic_stream_socket::send_low_watermark]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.send_low_watermark..send_low_watermark..basic_stream_socket] 
Socket option for the send low watermark. 


  typedef implementation_defined send_low_watermark;



Implements the SOL\_SOCKET/SO\_SNDLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:set_option basic_stream_socket::set_option]

[indexterm2 boost_asio.indexterm.basic_stream_socket.set_option..set_option..basic_stream_socket] 
Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void ``[link boost_asio.reference.basic_stream_socket.set_option.overload1 set_option]``(
      const SettableSocketOption & option);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.set_option.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void ``[link boost_asio.reference.basic_stream_socket.set_option.overload2 set_option]``(
      const SettableSocketOption & option,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.set_option.overload2 more...]]``


[section:overload1 basic_stream_socket::set_option (1 of 2 overloads)]


['Inherited from basic_socket.]


Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void set_option(
      const SettableSocketOption & option);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::no_delay option(true);
   socket.set_option(option);







[endsect]



[section:overload2 basic_stream_socket::set_option (2 of 2 overloads)]


['Inherited from basic_socket.]


Set an option on the socket. 


  template<
      typename ``[link boost_asio.reference.SettableSocketOption SettableSocketOption]``>
  void set_option(
      const SettableSocketOption & option,
      boost::system::error_code & ec);


This function is used to set an option on the socket.


[heading Parameters]
    

[variablelist
  
[[option][The new option value to be set on the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Setting the IPPROTO\_TCP/TCP\_NODELAY option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::no_delay option(true);
   boost::system::error_code ec;
   socket.set_option(option, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]

[section:shutdown basic_stream_socket::shutdown]

[indexterm2 boost_asio.indexterm.basic_stream_socket.shutdown..shutdown..basic_stream_socket] 
Disable sends or receives on the socket. 


  void ``[link boost_asio.reference.basic_stream_socket.shutdown.overload1 shutdown]``(
      shutdown_type what);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.shutdown.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_socket.shutdown.overload2 shutdown]``(
      shutdown_type what,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.shutdown.overload2 more...]]``


[section:overload1 basic_stream_socket::shutdown (1 of 2 overloads)]


['Inherited from basic_socket.]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);







[endsect]



[section:overload2 basic_stream_socket::shutdown (2 of 2 overloads)]


['Inherited from basic_socket.]


Disable sends or receives on the socket. 


  void shutdown(
      shutdown_type what,
      boost::system::error_code & ec);


This function is used to disable send operations, receive operations, or both.


[heading Parameters]
    

[variablelist
  
[[what][Determines what types of operation will no longer be allowed.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Shutting down the send side of the socket: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);
   if (ec)
   {
     // An error occurred.
   }







[endsect]


[endsect]


[section:shutdown_type basic_stream_socket::shutdown_type]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.shutdown_type..shutdown_type..basic_stream_socket] 
Different ways a socket may be shutdown. 

  enum shutdown_type

[indexterm2 boost_asio.indexterm.basic_stream_socket.shutdown_type.shutdown_receive..shutdown_receive..basic_stream_socket]
[indexterm2 boost_asio.indexterm.basic_stream_socket.shutdown_type.shutdown_send..shutdown_send..basic_stream_socket]
[indexterm2 boost_asio.indexterm.basic_stream_socket.shutdown_type.shutdown_both..shutdown_both..basic_stream_socket]

[heading Values]
[variablelist

  [
    [shutdown_receive]
    [Shutdown the receive side of the socket. ]
  ]

  [
    [shutdown_send]
    [Shutdown the send side of the socket. ]
  ]

  [
    [shutdown_both]
    [Shutdown both send and receive on the socket. ]
  ]

]



[endsect]


[section:wait basic_stream_socket::wait]

[indexterm2 boost_asio.indexterm.basic_stream_socket.wait..wait..basic_stream_socket] 
Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void ``[link boost_asio.reference.basic_stream_socket.wait.overload1 wait]``(
      wait_type w);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.wait.overload1 more...]]``

  void ``[link boost_asio.reference.basic_stream_socket.wait.overload2 wait]``(
      wait_type w,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.wait.overload2 more...]]``


[section:overload1 basic_stream_socket::wait (1 of 2 overloads)]


['Inherited from basic_socket.]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   socket.wait(boost::asio::ip::tcp::socket::wait_read);







[endsect]



[section:overload2 basic_stream_socket::wait (2 of 2 overloads)]


['Inherited from basic_socket.]


Wait for the socket to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w,
      boost::system::error_code & ec);


This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired socket state.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Waiting for a socket to become readable. 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::system::error_code ec;
   socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);







[endsect]


[endsect]


[section:wait_type basic_stream_socket::wait_type]


['Inherited from socket_base.]

[indexterm2 boost_asio.indexterm.basic_stream_socket.wait_type..wait_type..basic_stream_socket] 
Wait types. 

  enum wait_type

[indexterm2 boost_asio.indexterm.basic_stream_socket.wait_type.wait_read..wait_read..basic_stream_socket]
[indexterm2 boost_asio.indexterm.basic_stream_socket.wait_type.wait_write..wait_write..basic_stream_socket]
[indexterm2 boost_asio.indexterm.basic_stream_socket.wait_type.wait_error..wait_error..basic_stream_socket]

[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a socket to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a socket to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a socket to have error conditions pending. ]
  ]

]


For use with `basic_socket::wait()` and `basic_socket::async_wait()`. 


[endsect]


[section:write_some basic_stream_socket::write_some]

[indexterm2 boost_asio.indexterm.basic_stream_socket.write_some..write_some..basic_stream_socket] 
Write some data to the socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_socket.write_some.overload1 write_some]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.write_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_stream_socket.write_some.overload2 write_some]``(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_stream_socket.write_some.overload2 more...]]``


[section:overload1 basic_stream_socket::write_some (1 of 2 overloads)]


Write some data to the socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers);


This function is used to write data to the stream socket. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the socket.]]

]


[heading Return Value]
      
The number of bytes written.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   socket.write_some(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_stream_socket::write_some (2 of 2 overloads)]


Write some data to the socket. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to write data to the stream socket. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the socket.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. Returns 0 if an error occurred.


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]


[endsect]


[section:_basic_stream_socket basic_stream_socket::~basic_stream_socket]

[indexterm2 boost_asio.indexterm.basic_stream_socket._basic_stream_socket..~basic_stream_socket..basic_stream_socket] 
Destroys the socket. 


  ~basic_stream_socket();


This function destroys the socket, cancelling any outstanding asynchronous operations associated with the socket as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_stream_socket__rebind_executor basic_stream_socket::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_stream_socket__rebind_executor..basic_stream_socket::rebind_executor]


Rebinds the socket type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_stream_socket__rebind_executor.other [*other]]]
    [The socket type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_stream_socket::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_stream_socket__rebind_executor.other..other..basic_stream_socket::rebind_executor] 
The socket type when rebound to the specified executor. 


  typedef basic_stream_socket< Protocol, Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_stream_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_send [*async_send]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.basic_stream_socket [*basic_stream_socket]] [constructor]]
    [Construct a basic_stream_socket without opening it. 
     [hr]
     Construct and open a basic_stream_socket. 
     [hr]
     Construct a basic_stream_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_stream_socket on an existing native socket. 
     [hr]
     Move-construct a basic_stream_socket from another. 
     [hr]
     Move-construct a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_stream_socket from another. 
     [hr]
     Move-assign a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.read_some [*read_some]]]
    [Read some data from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.receive [*receive]]]
    [Receive some data on the socket. 
     [hr]
     Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.send [*send]]]
    [Send some data on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.write_some [*write_some]]]
    [Write some data to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket._basic_stream_socket [*~basic_stream_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] class template provides asynchronous and blocking stream-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `receive`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe.





[heading Requirements]

['Header: ][^boost/asio/basic_stream_socket.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_streambuf basic_streambuf]

[indexterm1 boost_asio.indexterm.basic_streambuf..basic_streambuf]


Automatically resizable buffer class based on std::streambuf. 


  template<
      typename Allocator = std::allocator<char>>
  class basic_streambuf :
    noncopyable


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_streambuf.const_buffers_type [*const_buffers_type]]]
    [The type used to represent the input sequence as a list of buffers. ]
  
  ]

  [

    [[link boost_asio.reference.basic_streambuf.mutable_buffers_type [*mutable_buffers_type]]]
    [The type used to represent the output sequence as a list of buffers. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_streambuf.basic_streambuf [*basic_streambuf]] [constructor]]
    [Construct a basic_streambuf object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.capacity [*capacity]]]
    [Get the current capacity of the basic_streambuf. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.commit [*commit]]]
    [Move characters from the output sequence to the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.consume [*consume]]]
    [Remove characters from the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.data [*data]]]
    [Get a list of buffers that represents the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.max_size [*max_size]]]
    [Get the maximum size of the basic_streambuf. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.prepare [*prepare]]]
    [Get a list of buffers that represents the output sequence, with the given size. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.size [*size]]]
    [Get the size of the input sequence. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_streambuf.overflow [*overflow]]]
    [Override std::streambuf behaviour. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.reserve [*reserve]]]
    []
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.underflow [*underflow]]]
    [Override std::streambuf behaviour. ]
  ]
  
]

The `basic_streambuf` class is derived from `std::streambuf` to associate the streambuf's input and output sequences with one or more character arrays. These character arrays are internal to the `basic_streambuf` object, but direct access to the array elements is provided to permit them to be used efficiently with I/O operations. Characters written to the output sequence of a `basic_streambuf` object are appended to the input sequence of the same object.

The `basic_streambuf` class's public interface is intended to permit the following implementation strategies:


* A single contiguous character array, which is reallocated as necessary to accommodate changes in the size of the character sequence. This is the implementation approach currently used in Asio.


* A sequence of one or more character arrays, where each array is of the same size. Additional character array objects are appended to the sequence to accommodate changes in the size of the character sequence.


* A sequence of one or more character arrays of varying sizes. Additional character array objects are appended to the sequence to accommodate changes in the size of the character sequence.

The constructor for [link boost_asio.reference.basic_streambuf `basic_streambuf`] accepts a `size_t` argument specifying the maximum of the sum of the sizes of the input sequence and output sequence. During the lifetime of the `basic_streambuf` object, the following invariant holds: 

   size() <= max_size()


Any member function that would, if successful, cause the invariant to be violated shall throw an exception of class `std::length_error`.

The constructor for `basic_streambuf` takes an Allocator argument. A copy of this argument is used for any memory allocation performed, by the constructor and by all member functions, during the lifetime of each `basic_streambuf` object.


[heading Examples]
  
Writing directly from an streambuf to a socket: 

   boost::asio::streambuf b;
   std::ostream os(&b);
   os << "Hello, World!\n";

   // try sending some data in input sequence
   size_t n = sock.send(b.data());

   b.consume(n); // sent data is removed from input sequence




Reading from a socket directly into a streambuf: 

   boost::asio::streambuf b;

   // reserve 512 bytes in output sequence
   boost::asio::streambuf::mutable_buffers_type bufs = b.prepare(512);

   size_t n = sock.receive(bufs);

   // received data is "committed" from output sequence to input sequence
   b.commit(n);

   std::istream is(&b);
   std::string s;
   is >> s;




[heading Requirements]

['Header: ][^boost/asio/basic_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:basic_streambuf basic_streambuf::basic_streambuf]

[indexterm2 boost_asio.indexterm.basic_streambuf.basic_streambuf..basic_streambuf..basic_streambuf] 
Construct a [link boost_asio.reference.basic_streambuf `basic_streambuf`] object. 


  basic_streambuf(
      std::size_t maximum_size = (std::numeric_limits< std::size_t >::max)(),
      const Allocator & allocator = Allocator());


Constructs a streambuf with the specified maximum size. The initial size of the streambuf's input sequence is 0. 


[endsect]



[section:capacity basic_streambuf::capacity]

[indexterm2 boost_asio.indexterm.basic_streambuf.capacity..capacity..basic_streambuf] 
Get the current capacity of the [link boost_asio.reference.basic_streambuf `basic_streambuf`]. 


  std::size_t capacity() const;



[heading Return Value]
      
The current total capacity of the streambuf, i.e. for both the input sequence and output sequence. 




[endsect]



[section:commit basic_streambuf::commit]

[indexterm2 boost_asio.indexterm.basic_streambuf.commit..commit..basic_streambuf] 
Move characters from the output sequence to the input sequence. 


  void commit(
      std::size_t n);


Appends `n` characters from the start of the output sequence to the input sequence. The beginning of the output sequence is advanced by `n` characters.

Requires a preceding call `prepare(x)` where `x >= n`, and no intervening operations that modify the input or output sequence.


[heading Remarks]
      
If `n` is greater than the size of the output sequence, the entire output sequence is moved to the input sequence and no error is issued. 




[endsect]



[section:const_buffers_type basic_streambuf::const_buffers_type]

[indexterm2 boost_asio.indexterm.basic_streambuf.const_buffers_type..const_buffers_type..basic_streambuf] 
The type used to represent the input sequence as a list of buffers. 


  typedef implementation_defined const_buffers_type;



[heading Requirements]

['Header: ][^boost/asio/basic_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:consume basic_streambuf::consume]

[indexterm2 boost_asio.indexterm.basic_streambuf.consume..consume..basic_streambuf] 
Remove characters from the input sequence. 


  void consume(
      std::size_t n);


Removes `n` characters from the beginning of the input sequence.


[heading Remarks]
      
If `n` is greater than the size of the input sequence, the entire input sequence is consumed and no error is issued. 




[endsect]



[section:data basic_streambuf::data]

[indexterm2 boost_asio.indexterm.basic_streambuf.data..data..basic_streambuf] 
Get a list of buffers that represents the input sequence. 


  const_buffers_type data() const;



[heading Return Value]
      
An object of type `const_buffers_type` that satisfies ConstBufferSequence requirements, representing all character arrays in the input sequence.


[heading Remarks]
      
The returned object is invalidated by any `basic_streambuf` member function that modifies the input sequence or output sequence. 




[endsect]



[section:max_size basic_streambuf::max_size]

[indexterm2 boost_asio.indexterm.basic_streambuf.max_size..max_size..basic_streambuf] 
Get the maximum size of the [link boost_asio.reference.basic_streambuf `basic_streambuf`]. 


  std::size_t max_size() const;



[heading Return Value]
      
The allowed maximum of the sum of the sizes of the input sequence and output sequence. 




[endsect]



[section:mutable_buffers_type basic_streambuf::mutable_buffers_type]

[indexterm2 boost_asio.indexterm.basic_streambuf.mutable_buffers_type..mutable_buffers_type..basic_streambuf] 
The type used to represent the output sequence as a list of buffers. 


  typedef implementation_defined mutable_buffers_type;



[heading Requirements]

['Header: ][^boost/asio/basic_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:overflow basic_streambuf::overflow]

[indexterm2 boost_asio.indexterm.basic_streambuf.overflow..overflow..basic_streambuf] 
Override std::streambuf behaviour. 


  int_type overflow(
      int_type c);


Behaves according to the specification of `std::streambuf::overflow()`, with the specialisation that `std::length_error` is thrown if appending the character to the input sequence would require the condition `size() > max_size()` to be true. 


[endsect]



[section:prepare basic_streambuf::prepare]

[indexterm2 boost_asio.indexterm.basic_streambuf.prepare..prepare..basic_streambuf] 
Get a list of buffers that represents the output sequence, with the given size. 


  mutable_buffers_type prepare(
      std::size_t n);


Ensures that the output sequence can accommodate `n` characters, reallocating character array objects as necessary.


[heading Return Value]
      
An object of type `mutable_buffers_type` that satisfies MutableBufferSequence requirements, representing character array objects at the start of the output sequence such that the sum of the buffer sizes is `n`.


[heading Exceptions]
    

[variablelist
  
[[std::length_error][If `size() + n > max_size()`.]]

]


[heading Remarks]
      
The returned object is invalidated by any `basic_streambuf` member function that modifies the input sequence or output sequence. 




[endsect]



[section:reserve basic_streambuf::reserve]

[indexterm2 boost_asio.indexterm.basic_streambuf.reserve..reserve..basic_streambuf] 

  void reserve(
      std::size_t n);



[endsect]



[section:size basic_streambuf::size]

[indexterm2 boost_asio.indexterm.basic_streambuf.size..size..basic_streambuf] 
Get the size of the input sequence. 


  std::size_t size() const;



[heading Return Value]
      
The size of the input sequence. The value is equal to that calculated for `s` in the following code: 

   size_t s = 0;
   const_buffers_type bufs = data();
   const_buffers_type::const_iterator i = bufs.begin();
   while (i != bufs.end())
   {
     const_buffer buf(*i++);
     s += buf.size();
   }







[endsect]



[section:underflow basic_streambuf::underflow]

[indexterm2 boost_asio.indexterm.basic_streambuf.underflow..underflow..basic_streambuf] 
Override std::streambuf behaviour. 


  int_type underflow();


Behaves according to the specification of `std::streambuf::underflow()`. 


[endsect]



[endsect]

[section:basic_streambuf_ref basic_streambuf_ref]

[indexterm1 boost_asio.indexterm.basic_streambuf_ref..basic_streambuf_ref]


Adapts [link boost_asio.reference.basic_streambuf `basic_streambuf`] to the dynamic buffer sequence type requirements. 


  template<
      typename Allocator = std::allocator<char>>
  class basic_streambuf_ref


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_streambuf_ref.const_buffers_type [*const_buffers_type]]]
    [The type used to represent the input sequence as a list of buffers. ]
  
  ]

  [

    [[link boost_asio.reference.basic_streambuf_ref.mutable_buffers_type [*mutable_buffers_type]]]
    [The type used to represent the output sequence as a list of buffers. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_streambuf_ref.basic_streambuf_ref [*basic_streambuf_ref]] [constructor]]
    [Construct a basic_streambuf_ref for the given basic_streambuf object. 
     [hr]
     Copy construct a basic_streambuf_ref. 
     [hr]
     Move construct a basic_streambuf_ref. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf_ref.capacity [*capacity]]]
    [Get the current capacity of the dynamic buffer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf_ref.commit [*commit]]]
    [Move bytes from the output sequence to the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf_ref.consume [*consume]]]
    [Remove characters from the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf_ref.data [*data]]]
    [Get a list of buffers that represents the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf_ref.max_size [*max_size]]]
    [Get the maximum size of the dynamic buffer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf_ref.prepare [*prepare]]]
    [Get a list of buffers that represents the output sequence, with the given size. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf_ref.size [*size]]]
    [Get the size of the input sequence. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/basic_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_streambuf_ref basic_streambuf_ref::basic_streambuf_ref]

[indexterm2 boost_asio.indexterm.basic_streambuf_ref.basic_streambuf_ref..basic_streambuf_ref..basic_streambuf_ref] 
Construct a [link boost_asio.reference.basic_streambuf_ref `basic_streambuf_ref`] for the given [link boost_asio.reference.basic_streambuf `basic_streambuf`] object. 


  explicit ``[link boost_asio.reference.basic_streambuf_ref.basic_streambuf_ref.overload1 basic_streambuf_ref]``(
      basic_streambuf< Allocator > & sb);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_streambuf_ref.basic_streambuf_ref.overload1 more...]]``


Copy construct a [link boost_asio.reference.basic_streambuf_ref `basic_streambuf_ref`]. 


  ``[link boost_asio.reference.basic_streambuf_ref.basic_streambuf_ref.overload2 basic_streambuf_ref]``(
      const basic_streambuf_ref & other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_streambuf_ref.basic_streambuf_ref.overload2 more...]]``


Move construct a [link boost_asio.reference.basic_streambuf_ref `basic_streambuf_ref`]. 


  ``[link boost_asio.reference.basic_streambuf_ref.basic_streambuf_ref.overload3 basic_streambuf_ref]``(
      basic_streambuf_ref && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_streambuf_ref.basic_streambuf_ref.overload3 more...]]``


[section:overload1 basic_streambuf_ref::basic_streambuf_ref (1 of 3 overloads)]


Construct a [link boost_asio.reference.basic_streambuf_ref `basic_streambuf_ref`] for the given [link boost_asio.reference.basic_streambuf `basic_streambuf`] object. 


  basic_streambuf_ref(
      basic_streambuf< Allocator > & sb);



[endsect]



[section:overload2 basic_streambuf_ref::basic_streambuf_ref (2 of 3 overloads)]


Copy construct a [link boost_asio.reference.basic_streambuf_ref `basic_streambuf_ref`]. 


  basic_streambuf_ref(
      const basic_streambuf_ref & other);



[endsect]



[section:overload3 basic_streambuf_ref::basic_streambuf_ref (3 of 3 overloads)]


Move construct a [link boost_asio.reference.basic_streambuf_ref `basic_streambuf_ref`]. 


  basic_streambuf_ref(
      basic_streambuf_ref && other);



[endsect]


[endsect]


[section:capacity basic_streambuf_ref::capacity]

[indexterm2 boost_asio.indexterm.basic_streambuf_ref.capacity..capacity..basic_streambuf_ref] 
Get the current capacity of the dynamic buffer. 


  std::size_t capacity() const;



[endsect]



[section:commit basic_streambuf_ref::commit]

[indexterm2 boost_asio.indexterm.basic_streambuf_ref.commit..commit..basic_streambuf_ref] 
Move bytes from the output sequence to the input sequence. 


  void commit(
      std::size_t n);



[endsect]



[section:const_buffers_type basic_streambuf_ref::const_buffers_type]

[indexterm2 boost_asio.indexterm.basic_streambuf_ref.const_buffers_type..const_buffers_type..basic_streambuf_ref] 
The type used to represent the input sequence as a list of buffers. 


  typedef basic_streambuf< Allocator >::const_buffers_type const_buffers_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_streambuf.const_buffers_type [*const_buffers_type]]]
    [The type used to represent the input sequence as a list of buffers. ]
  
  ]

  [

    [[link boost_asio.reference.basic_streambuf.mutable_buffers_type [*mutable_buffers_type]]]
    [The type used to represent the output sequence as a list of buffers. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_streambuf.basic_streambuf [*basic_streambuf]] [constructor]]
    [Construct a basic_streambuf object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.capacity [*capacity]]]
    [Get the current capacity of the basic_streambuf. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.commit [*commit]]]
    [Move characters from the output sequence to the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.consume [*consume]]]
    [Remove characters from the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.data [*data]]]
    [Get a list of buffers that represents the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.max_size [*max_size]]]
    [Get the maximum size of the basic_streambuf. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.prepare [*prepare]]]
    [Get a list of buffers that represents the output sequence, with the given size. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.size [*size]]]
    [Get the size of the input sequence. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_streambuf.overflow [*overflow]]]
    [Override std::streambuf behaviour. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.reserve [*reserve]]]
    []
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.underflow [*underflow]]]
    [Override std::streambuf behaviour. ]
  ]
  
]

The `basic_streambuf` class is derived from `std::streambuf` to associate the streambuf's input and output sequences with one or more character arrays. These character arrays are internal to the `basic_streambuf` object, but direct access to the array elements is provided to permit them to be used efficiently with I/O operations. Characters written to the output sequence of a `basic_streambuf` object are appended to the input sequence of the same object.

The `basic_streambuf` class's public interface is intended to permit the following implementation strategies:


* A single contiguous character array, which is reallocated as necessary to accommodate changes in the size of the character sequence. This is the implementation approach currently used in Asio.


* A sequence of one or more character arrays, where each array is of the same size. Additional character array objects are appended to the sequence to accommodate changes in the size of the character sequence.


* A sequence of one or more character arrays of varying sizes. Additional character array objects are appended to the sequence to accommodate changes in the size of the character sequence.

The constructor for [link boost_asio.reference.basic_streambuf `basic_streambuf`] accepts a `size_t` argument specifying the maximum of the sum of the sizes of the input sequence and output sequence. During the lifetime of the `basic_streambuf` object, the following invariant holds: 

   size() <= max_size()


Any member function that would, if successful, cause the invariant to be violated shall throw an exception of class `std::length_error`.

The constructor for `basic_streambuf` takes an Allocator argument. A copy of this argument is used for any memory allocation performed, by the constructor and by all member functions, during the lifetime of each `basic_streambuf` object.


[heading Examples]
  
Writing directly from an streambuf to a socket: 

   boost::asio::streambuf b;
   std::ostream os(&b);
   os << "Hello, World!\n";

   // try sending some data in input sequence
   size_t n = sock.send(b.data());

   b.consume(n); // sent data is removed from input sequence




Reading from a socket directly into a streambuf: 

   boost::asio::streambuf b;

   // reserve 512 bytes in output sequence
   boost::asio::streambuf::mutable_buffers_type bufs = b.prepare(512);

   size_t n = sock.receive(bufs);

   // received data is "committed" from output sequence to input sequence
   b.commit(n);

   std::istream is(&b);
   std::string s;
   is >> s;





[heading Requirements]

['Header: ][^boost/asio/basic_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:consume basic_streambuf_ref::consume]

[indexterm2 boost_asio.indexterm.basic_streambuf_ref.consume..consume..basic_streambuf_ref] 
Remove characters from the input sequence. 


  void consume(
      std::size_t n);



[endsect]



[section:data basic_streambuf_ref::data]

[indexterm2 boost_asio.indexterm.basic_streambuf_ref.data..data..basic_streambuf_ref] 
Get a list of buffers that represents the input sequence. 


  const_buffers_type data() const;



[endsect]



[section:max_size basic_streambuf_ref::max_size]

[indexterm2 boost_asio.indexterm.basic_streambuf_ref.max_size..max_size..basic_streambuf_ref] 
Get the maximum size of the dynamic buffer. 


  std::size_t max_size() const;



[endsect]



[section:mutable_buffers_type basic_streambuf_ref::mutable_buffers_type]

[indexterm2 boost_asio.indexterm.basic_streambuf_ref.mutable_buffers_type..mutable_buffers_type..basic_streambuf_ref] 
The type used to represent the output sequence as a list of buffers. 


  typedef basic_streambuf< Allocator >::mutable_buffers_type mutable_buffers_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_streambuf.const_buffers_type [*const_buffers_type]]]
    [The type used to represent the input sequence as a list of buffers. ]
  
  ]

  [

    [[link boost_asio.reference.basic_streambuf.mutable_buffers_type [*mutable_buffers_type]]]
    [The type used to represent the output sequence as a list of buffers. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_streambuf.basic_streambuf [*basic_streambuf]] [constructor]]
    [Construct a basic_streambuf object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.capacity [*capacity]]]
    [Get the current capacity of the basic_streambuf. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.commit [*commit]]]
    [Move characters from the output sequence to the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.consume [*consume]]]
    [Remove characters from the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.data [*data]]]
    [Get a list of buffers that represents the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.max_size [*max_size]]]
    [Get the maximum size of the basic_streambuf. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.prepare [*prepare]]]
    [Get a list of buffers that represents the output sequence, with the given size. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.size [*size]]]
    [Get the size of the input sequence. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_streambuf.overflow [*overflow]]]
    [Override std::streambuf behaviour. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.reserve [*reserve]]]
    []
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.underflow [*underflow]]]
    [Override std::streambuf behaviour. ]
  ]
  
]

The `basic_streambuf` class is derived from `std::streambuf` to associate the streambuf's input and output sequences with one or more character arrays. These character arrays are internal to the `basic_streambuf` object, but direct access to the array elements is provided to permit them to be used efficiently with I/O operations. Characters written to the output sequence of a `basic_streambuf` object are appended to the input sequence of the same object.

The `basic_streambuf` class's public interface is intended to permit the following implementation strategies:


* A single contiguous character array, which is reallocated as necessary to accommodate changes in the size of the character sequence. This is the implementation approach currently used in Asio.


* A sequence of one or more character arrays, where each array is of the same size. Additional character array objects are appended to the sequence to accommodate changes in the size of the character sequence.


* A sequence of one or more character arrays of varying sizes. Additional character array objects are appended to the sequence to accommodate changes in the size of the character sequence.

The constructor for [link boost_asio.reference.basic_streambuf `basic_streambuf`] accepts a `size_t` argument specifying the maximum of the sum of the sizes of the input sequence and output sequence. During the lifetime of the `basic_streambuf` object, the following invariant holds: 

   size() <= max_size()


Any member function that would, if successful, cause the invariant to be violated shall throw an exception of class `std::length_error`.

The constructor for `basic_streambuf` takes an Allocator argument. A copy of this argument is used for any memory allocation performed, by the constructor and by all member functions, during the lifetime of each `basic_streambuf` object.


[heading Examples]
  
Writing directly from an streambuf to a socket: 

   boost::asio::streambuf b;
   std::ostream os(&b);
   os << "Hello, World!\n";

   // try sending some data in input sequence
   size_t n = sock.send(b.data());

   b.consume(n); // sent data is removed from input sequence




Reading from a socket directly into a streambuf: 

   boost::asio::streambuf b;

   // reserve 512 bytes in output sequence
   boost::asio::streambuf::mutable_buffers_type bufs = b.prepare(512);

   size_t n = sock.receive(bufs);

   // received data is "committed" from output sequence to input sequence
   b.commit(n);

   std::istream is(&b);
   std::string s;
   is >> s;





[heading Requirements]

['Header: ][^boost/asio/basic_streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:prepare basic_streambuf_ref::prepare]

[indexterm2 boost_asio.indexterm.basic_streambuf_ref.prepare..prepare..basic_streambuf_ref] 
Get a list of buffers that represents the output sequence, with the given size. 


  mutable_buffers_type prepare(
      std::size_t n);



[endsect]



[section:size basic_streambuf_ref::size]

[indexterm2 boost_asio.indexterm.basic_streambuf_ref.size..size..basic_streambuf_ref] 
Get the size of the input sequence. 


  std::size_t size() const;



[endsect]



[endsect]

[section:basic_system_executor basic_system_executor]

[indexterm1 boost_asio.indexterm.basic_system_executor..basic_system_executor]


An executor that uses arbitrary threads. 


  template<
      typename Blocking,
      typename Relationship,
      typename Allocator>
  class basic_system_executor


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_system_executor.basic_system_executor [*basic_system_executor]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.defer [*defer]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.dispatch [*dispatch]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.execute [*execute]]]
    [Execution function. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.on_work_finished [*on_work_finished]]]
    [Inform the executor that some work is no longer outstanding. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.on_work_started [*on_work_started]]]
    [Inform the executor that it has some outstanding work to do. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.post [*post]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.query [*query]]]
    [Query the current value of the allocator property. 
     [hr]
     Query the occupancy (recommended number of work items) for the system context. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.query__static [*query]] [static]]
    [Query the current value of the mapping property. 
     [hr]
     Query the current value of the context property. 
     [hr]
     Query the current value of the blocking property. 
     [hr]
     Query the current value of the relationship property. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.require [*require]]]
    [Obtain an executor with the blocking.possibly property. 
     [hr]
     Obtain an executor with the blocking.always property. 
     [hr]
     Obtain an executor with the blocking.never property. 
     [hr]
     Obtain an executor with the relationship.continuation property. 
     [hr]
     Obtain an executor with the relationship.fork property. 
     [hr]
     Obtain an executor with the specified allocator property. 
     [hr]
     Obtain an executor with the default allocator property. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_system_executor.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]

The system executor represents an execution context where functions are permitted to run on arbitrary threads. When the blocking.never property is established, the system executor will schedule the function to run on an unspecified system thread pool. When either blocking.possibly or blocking.always is established, the executor invokes the function immediately. 

[heading Requirements]

['Header: ][^boost/asio/system_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:basic_system_executor basic_system_executor::basic_system_executor]

[indexterm2 boost_asio.indexterm.basic_system_executor.basic_system_executor..basic_system_executor..basic_system_executor] 
Default constructor. 


  basic_system_executor();



[endsect]



[section:context basic_system_executor::context]

[indexterm2 boost_asio.indexterm.basic_system_executor.context..context..basic_system_executor] 
Obtain the underlying execution context. 


  system_context & context() const;



[endsect]



[section:defer basic_system_executor::defer]

[indexterm2 boost_asio.indexterm.basic_system_executor.defer..defer..basic_system_executor] 
Request the system executor to invoke the given function object. 


  template<
      typename Function,
      typename OtherAllocator>
  void defer(
      Function && f,
      const OtherAllocator & a) const;


This function is used to ask the executor to execute the given function object. The function object will never be executed inside this function. Instead, it will be scheduled to run on an unspecified system thread pool.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:dispatch basic_system_executor::dispatch]

[indexterm2 boost_asio.indexterm.basic_system_executor.dispatch..dispatch..basic_system_executor] 
Request the system executor to invoke the given function object. 


  template<
      typename Function,
      typename OtherAllocator>
  void dispatch(
      Function && f,
      const OtherAllocator & a) const;


This function is used to ask the executor to execute the given function object. The function object will always be executed inside this function.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:execute basic_system_executor::execute]

[indexterm2 boost_asio.indexterm.basic_system_executor.execute..execute..basic_system_executor] 
Execution function. 


  template<
      typename Function>
  void execute(
      Function && f) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.execution__execute `execution::execute`] customisation point.

For example: 

   boost::asio::system_executor ex;
   execution::execute(ex, my_function_object); 





[endsect]



[section:on_work_finished basic_system_executor::on_work_finished]

[indexterm2 boost_asio.indexterm.basic_system_executor.on_work_finished..on_work_finished..basic_system_executor] 
Inform the executor that some work is no longer outstanding. 


  void on_work_finished() const;


For the system executor, this is a no-op. 


[endsect]



[section:on_work_started basic_system_executor::on_work_started]

[indexterm2 boost_asio.indexterm.basic_system_executor.on_work_started..on_work_started..basic_system_executor] 
Inform the executor that it has some outstanding work to do. 


  void on_work_started() const;


For the system executor, this is a no-op. 


[endsect]



[section:operator_not__eq_ basic_system_executor::operator!=]

[indexterm2 boost_asio.indexterm.basic_system_executor.operator_not__eq_..operator!=..basic_system_executor] 
Compare two executors for inequality. 


  friend bool operator!=(
      const basic_system_executor & ,
      const basic_system_executor & );


Two executors are equal if they refer to the same underlying [link boost_asio.reference.io_context `io_context`]. 

[heading Requirements]

['Header: ][^boost/asio/system_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq__eq_ basic_system_executor::operator==]

[indexterm2 boost_asio.indexterm.basic_system_executor.operator_eq__eq_..operator==..basic_system_executor] 
Compare two executors for equality. 


  friend bool operator==(
      const basic_system_executor & ,
      const basic_system_executor & );


Two executors are equal if they refer to the same underlying [link boost_asio.reference.io_context `io_context`]. 

[heading Requirements]

['Header: ][^boost/asio/system_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:post basic_system_executor::post]

[indexterm2 boost_asio.indexterm.basic_system_executor.post..post..basic_system_executor] 
Request the system executor to invoke the given function object. 


  template<
      typename Function,
      typename OtherAllocator>
  void post(
      Function && f,
      const OtherAllocator & a) const;


This function is used to ask the executor to execute the given function object. The function object will never be executed inside this function. Instead, it will be scheduled to run on an unspecified system thread pool.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]


[section:query basic_system_executor::query]

[indexterm2 boost_asio.indexterm.basic_system_executor.query..query..basic_system_executor] 
Query the current value of the `allocator` property. 


  template<
      typename OtherAllocator>
  constexpr Allocator ``[link boost_asio.reference.basic_system_executor.query.overload1 query]``(
      execution::allocator_t< OtherAllocator > ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.query.overload1 more...]]``

  constexpr Allocator ``[link boost_asio.reference.basic_system_executor.query.overload2 query]``(
      execution::allocator_t< void > ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.query.overload2 more...]]``


Query the occupancy (recommended number of work items) for the system context. 


  std::size_t ``[link boost_asio.reference.basic_system_executor.query.overload3 query]``(
      execution::occupancy_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.query.overload3 more...]]``


[section:overload1 basic_system_executor::query (1 of 3 overloads)]


Query the current value of the `allocator` property. 


  template<
      typename OtherAllocator>
  constexpr Allocator query(
      execution::allocator_t< OtherAllocator > ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   boost::asio::system_executor ex;
   auto alloc = boost::asio::query(ex,
       boost::asio::execution::allocator); 





[endsect]



[section:overload2 basic_system_executor::query (2 of 3 overloads)]


Query the current value of the `allocator` property. 


  constexpr Allocator query(
      execution::allocator_t< void > ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   boost::asio::system_executor ex;
   auto alloc = boost::asio::query(ex,
       boost::asio::execution::allocator); 





[endsect]



[section:overload3 basic_system_executor::query (3 of 3 overloads)]


Query the occupancy (recommended number of work items) for the system context. 


  std::size_t query(
      execution::occupancy_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   boost::asio::system_executor ex;
   std::size_t occupancy = boost::asio::query(
       ex, boost::asio::execution::occupancy); 





[endsect]


[endsect]

[section:query__static basic_system_executor::query]

[indexterm2 boost_asio.indexterm.basic_system_executor.query__static..query..basic_system_executor] 
Query the current value of the `mapping` property. 


  static constexpr execution::mapping_t ``[link boost_asio.reference.basic_system_executor.query__static.overload1 query]``(
      execution::mapping_t );
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.query__static.overload1 more...]]``


Query the current value of the `context` property. 


  static system_context & ``[link boost_asio.reference.basic_system_executor.query__static.overload2 query]``(
      execution::context_t );
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.query__static.overload2 more...]]``


Query the current value of the `blocking` property. 


  static constexpr execution::blocking_t ``[link boost_asio.reference.basic_system_executor.query__static.overload3 query]``(
      execution::blocking_t );
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.query__static.overload3 more...]]``


Query the current value of the `relationship` property. 


  static constexpr execution::relationship_t ``[link boost_asio.reference.basic_system_executor.query__static.overload4 query]``(
      execution::relationship_t );
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.query__static.overload4 more...]]``


[section:overload1 basic_system_executor::query (1 of 4 overloads)]


Query the current value of the `mapping` property. 


  static constexpr execution::mapping_t query(
      execution::mapping_t );


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   boost::asio::system_executor ex;
   if (boost::asio::query(ex, boost::asio::execution::mapping)
         == boost::asio::execution::mapping.thread)
     ... 





[endsect]



[section:overload2 basic_system_executor::query (2 of 4 overloads)]


Query the current value of the `context` property. 


  static system_context & query(
      execution::context_t );


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   boost::asio::system_executor ex;
   boost::asio::system_context& pool = boost::asio::query(
       ex, boost::asio::execution::context); 





[endsect]



[section:overload3 basic_system_executor::query (3 of 4 overloads)]


Query the current value of the `blocking` property. 


  static constexpr execution::blocking_t query(
      execution::blocking_t );


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   boost::asio::system_executor ex;
   if (boost::asio::query(ex, boost::asio::execution::blocking)
         == boost::asio::execution::blocking.always)
     ... 





[endsect]



[section:overload4 basic_system_executor::query (4 of 4 overloads)]


Query the current value of the `relationship` property. 


  static constexpr execution::relationship_t query(
      execution::relationship_t );


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   boost::asio::system_executor ex;
   if (boost::asio::query(ex, boost::asio::execution::relationship)
         == boost::asio::execution::relationship.continuation)
     ... 





[endsect]


[endsect]

[section:require basic_system_executor::require]

[indexterm2 boost_asio.indexterm.basic_system_executor.require..require..basic_system_executor] 
Obtain an executor with the `blocking.possibly` property. 


  basic_system_executor< execution::blocking_t::possibly_t, Relationship, Allocator > ``[link boost_asio.reference.basic_system_executor.require.overload1 require]``(
      execution::blocking_t::possibly_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.require.overload1 more...]]``


Obtain an executor with the `blocking.always` property. 


  basic_system_executor< execution::blocking_t::always_t, Relationship, Allocator > ``[link boost_asio.reference.basic_system_executor.require.overload2 require]``(
      execution::blocking_t::always_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.require.overload2 more...]]``


Obtain an executor with the `blocking.never` property. 


  basic_system_executor< execution::blocking_t::never_t, Relationship, Allocator > ``[link boost_asio.reference.basic_system_executor.require.overload3 require]``(
      execution::blocking_t::never_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.require.overload3 more...]]``


Obtain an executor with the `relationship.continuation` property. 


  basic_system_executor< Blocking, execution::relationship_t::continuation_t, Allocator > ``[link boost_asio.reference.basic_system_executor.require.overload4 require]``(
      execution::relationship_t::continuation_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.require.overload4 more...]]``


Obtain an executor with the `relationship.fork` property. 


  basic_system_executor< Blocking, execution::relationship_t::fork_t, Allocator > ``[link boost_asio.reference.basic_system_executor.require.overload5 require]``(
      execution::relationship_t::fork_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.require.overload5 more...]]``


Obtain an executor with the specified `allocator` property. 


  template<
      typename OtherAllocator>
  basic_system_executor< Blocking, Relationship, OtherAllocator > ``[link boost_asio.reference.basic_system_executor.require.overload6 require]``(
      execution::allocator_t< OtherAllocator > a) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.require.overload6 more...]]``


Obtain an executor with the default `allocator` property. 


  basic_system_executor< Blocking, Relationship, std::allocator< void > > ``[link boost_asio.reference.basic_system_executor.require.overload7 require]``(
      execution::allocator_t< void > ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_system_executor.require.overload7 more...]]``


[section:overload1 basic_system_executor::require (1 of 7 overloads)]


Obtain an executor with the `blocking.possibly` property. 


  basic_system_executor< execution::blocking_t::possibly_t, Relationship, Allocator > require(
      execution::blocking_t::possibly_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   boost::asio::system_executor ex1;
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::blocking.possibly); 





[endsect]



[section:overload2 basic_system_executor::require (2 of 7 overloads)]


Obtain an executor with the `blocking.always` property. 


  basic_system_executor< execution::blocking_t::always_t, Relationship, Allocator > require(
      execution::blocking_t::always_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   boost::asio::system_executor ex1;
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::blocking.always); 





[endsect]



[section:overload3 basic_system_executor::require (3 of 7 overloads)]


Obtain an executor with the `blocking.never` property. 


  basic_system_executor< execution::blocking_t::never_t, Relationship, Allocator > require(
      execution::blocking_t::never_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   boost::asio::system_executor ex1;
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::blocking.never); 





[endsect]



[section:overload4 basic_system_executor::require (4 of 7 overloads)]


Obtain an executor with the `relationship.continuation` property. 


  basic_system_executor< Blocking, execution::relationship_t::continuation_t, Allocator > require(
      execution::relationship_t::continuation_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   boost::asio::system_executor ex1;
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::relationship.continuation); 





[endsect]



[section:overload5 basic_system_executor::require (5 of 7 overloads)]


Obtain an executor with the `relationship.fork` property. 


  basic_system_executor< Blocking, execution::relationship_t::fork_t, Allocator > require(
      execution::relationship_t::fork_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   boost::asio::system_executor ex1;
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::relationship.fork); 





[endsect]



[section:overload6 basic_system_executor::require (6 of 7 overloads)]


Obtain an executor with the specified `allocator` property. 


  template<
      typename OtherAllocator>
  basic_system_executor< Blocking, Relationship, OtherAllocator > require(
      execution::allocator_t< OtherAllocator > a) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   boost::asio::system_executor ex1;
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::allocator(my_allocator)); 





[endsect]



[section:overload7 basic_system_executor::require (7 of 7 overloads)]


Obtain an executor with the default `allocator` property. 


  basic_system_executor< Blocking, Relationship, std::allocator< void > > require(
      execution::allocator_t< void > ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   boost::asio::system_executor ex1;
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::allocator); 





[endsect]


[endsect]


[endsect]

[section:basic_waitable_timer basic_waitable_timer]

[indexterm1 boost_asio.indexterm.basic_waitable_timer..basic_waitable_timer]


Provides waitable timer functionality. 


  template<
      typename Clock,
      typename ``[link boost_asio.reference.WaitTraits WaitTraits]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class basic_waitable_timer


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_waitable_timer__rebind_executor [*rebind_executor]]]
    [Rebinds the timer type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.duration [*duration]]]
    [The duration type of the clock. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.time_point [*time_point]]]
    [The time point type of the clock. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.traits_type [*traits_type]]]
    [The wait traits type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_waitable_timer.async_wait [*async_wait]]]
    [Start an asynchronous wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.basic_waitable_timer [*basic_waitable_timer]] [constructor]]
    [Constructor. 
     [hr]
     Constructor to set a particular expiry time as an absolute time. 
     [hr]
     Constructor to set a particular expiry time relative to now. 
     [hr]
     Move-construct a basic_waitable_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the timer. 
     [hr]
     (Deprecated: Use non-error_code overload.) Cancel any asynchronous operations that are waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.cancel_one [*cancel_one]]]
    [Cancels one asynchronous operation that is waiting on the timer. 
     [hr]
     (Deprecated: Use non-error_code overload.) Cancels one asynchronous operation that is waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_after [*expires_after]]]
    [Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_at [*expires_at]]]
    [(Deprecated: Use expiry().) Get the timer's expiry time as an absolute time. 
     [hr]
     Set the timer's expiry time as an absolute time. 
     [hr]
     (Deprecated: Use non-error_code overload.) Set the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_from_now [*expires_from_now]]]
    [(Deprecated: Use expiry().) Get the timer's expiry time relative to now. 
     [hr]
     (Deprecated: Use expires_after().) Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expiry [*expiry]]]
    [Get the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.operator_eq_ [*operator=]]]
    [Move-assign a basic_waitable_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.wait [*wait]]]
    [Perform a blocking wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer._basic_waitable_timer [*~basic_waitable_timer]] [destructor]]
    [Destroys the timer. ]
  ]
  
]

The [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] class template provides the ability to perform a blocking or asynchronous wait for a timer to expire.

A waitable timer is always in one of two states: "expired" or "not expired". If the `wait()` or `async_wait()` function is called on an expired timer, the wait operation will complete immediately.

Most applications will use one of the [link boost_asio.reference.steady_timer `steady_timer`], [link boost_asio.reference.system_timer `system_timer`] or [link boost_asio.reference.high_resolution_timer `high_resolution_timer`] typedefs.


[heading Remarks]
      
This waitable timer functionality is for use with the C++11 standard library's `<chrono>` facility, or with the Boost.Chrono library.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.


[heading Examples]
  
Performing a blocking wait (C++11): 

   // Construct a timer without setting an expiry time.
   boost::asio::steady_timer timer(my_context);

   // Set an expiry time relative to now.
   timer.expires_after(std::chrono::seconds(5));

   // Wait for the timer to expire.
   timer.wait();





Performing an asynchronous wait (C++11): 

   void handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Timer expired.
     }
   }

   ...

   // Construct a timer with an absolute expiry time.
   boost::asio::steady_timer timer(my_context,
       std::chrono::steady_clock::now() + std::chrono::seconds(60));

   // Start an asynchronous wait.
   timer.async_wait(handler);





[heading Changing an active waitable timer's expiry time]
  


Changing the expiry time of a timer while there are pending asynchronous waits causes those wait operations to be cancelled. To ensure that the action associated with the timer is performed only once, use something like this: used:



   void on_some_event()
   {
     if (my_timer.expires_after(seconds(5)) > 0)
     {
       // We managed to cancel the timer. Start new asynchronous wait.
       my_timer.async_wait(on_timeout);
     }
     else
     {
       // Too late, timer has already expired!
     }
   }

   void on_timeout(const boost::system::error_code& e)
   {
     if (e != boost::asio::error::operation_aborted)
     {
       // Timer was not cancelled, take necessary action.
     }
   }





* The `boost::asio::basic_waitable_timer::expires_after()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.


* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 



[heading Requirements]

['Header: ][^boost/asio/basic_waitable_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:async_wait basic_waitable_timer::async_wait]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.async_wait..async_wait..basic_waitable_timer] 
Start an asynchronous wait on the timer. 


  template<
      typename ``[link boost_asio.reference.WaitHandler WaitHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_wait(
      WaitHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function may be used to initiate an asynchronous wait against the timer. It always returns immediately.

For each call to `async_wait()`, the supplied handler will be called exactly once. The handler will be called when:


* The timer has expired.


* The timer was cancelled, in which case the handler is passed the error code `boost::asio::error::operation_aborted`.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be called when the timer expires. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:basic_waitable_timer basic_waitable_timer::basic_waitable_timer]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.basic_waitable_timer..basic_waitable_timer..basic_waitable_timer] 
Constructor. 


  explicit ``[link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload1 basic_waitable_timer]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload2 basic_waitable_timer]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload2 more...]]``


Constructor to set a particular expiry time as an absolute time. 


  ``[link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload3 basic_waitable_timer]``(
      const executor_type & ex,
      const time_point & expiry_time);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload3 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload4 basic_waitable_timer]``(
      ExecutionContext & context,
      const time_point & expiry_time,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload4 more...]]``


Constructor to set a particular expiry time relative to now. 


  ``[link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload5 basic_waitable_timer]``(
      const executor_type & ex,
      const duration & expiry_time);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload5 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload6 basic_waitable_timer]``(
      ExecutionContext & context,
      const duration & expiry_time,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload6 more...]]``


Move-construct a [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] from another. 


  ``[link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload7 basic_waitable_timer]``(
      basic_waitable_timer && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload7 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload8 basic_waitable_timer]``(
      basic_waitable_timer< Clock, WaitTraits, Executor1 > && other,
      typename constraint< is_convertible< Executor1, Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.basic_waitable_timer.overload8 more...]]``


[section:overload1 basic_waitable_timer::basic_waitable_timer (1 of 8 overloads)]


Constructor. 


  basic_waitable_timer(
      const executor_type & ex);


This constructor creates a timer without setting an expiry time. The `expires_at()` or `expires_after()` functions must be called to set an expiry time before the timer can be waited on.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the timer will use, by default, to dispatch handlers for any asynchronous operations performed on the timer. ]]

]




[endsect]



[section:overload2 basic_waitable_timer::basic_waitable_timer (2 of 8 overloads)]


Constructor. 


  template<
      typename ExecutionContext>
  basic_waitable_timer(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a timer without setting an expiry time. The `expires_at()` or `expires_after()` functions must be called to set an expiry time before the timer can be waited on.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the timer will use, by default, to dispatch handlers for any asynchronous operations performed on the timer. ]]

]




[endsect]



[section:overload3 basic_waitable_timer::basic_waitable_timer (3 of 8 overloads)]


Constructor to set a particular expiry time as an absolute time. 


  basic_waitable_timer(
      const executor_type & ex,
      const time_point & expiry_time);


This constructor creates a timer and sets the expiry time.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor object that the timer will use, by default, to dispatch handlers for any asynchronous operations performed on the timer.]]

[[expiry_time][The expiry time to be used for the timer, expressed as an absolute time. ]]

]




[endsect]



[section:overload4 basic_waitable_timer::basic_waitable_timer (4 of 8 overloads)]


Constructor to set a particular expiry time as an absolute time. 


  template<
      typename ExecutionContext>
  basic_waitable_timer(
      ExecutionContext & context,
      const time_point & expiry_time,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a timer and sets the expiry time.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the timer will use, by default, to dispatch handlers for any asynchronous operations performed on the timer.]]

[[expiry_time][The expiry time to be used for the timer, expressed as an absolute time. ]]

]




[endsect]



[section:overload5 basic_waitable_timer::basic_waitable_timer (5 of 8 overloads)]


Constructor to set a particular expiry time relative to now. 


  basic_waitable_timer(
      const executor_type & ex,
      const duration & expiry_time);


This constructor creates a timer and sets the expiry time.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the timer will use, by default, to dispatch handlers for any asynchronous operations performed on the timer.]]

[[expiry_time][The expiry time to be used for the timer, relative to now. ]]

]




[endsect]



[section:overload6 basic_waitable_timer::basic_waitable_timer (6 of 8 overloads)]


Constructor to set a particular expiry time relative to now. 


  template<
      typename ExecutionContext>
  basic_waitable_timer(
      ExecutionContext & context,
      const duration & expiry_time,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a timer and sets the expiry time.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the timer will use, by default, to dispatch handlers for any asynchronous operations performed on the timer.]]

[[expiry_time][The expiry time to be used for the timer, relative to now. ]]

]




[endsect]



[section:overload7 basic_waitable_timer::basic_waitable_timer (7 of 8 overloads)]


Move-construct a [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] from another. 


  basic_waitable_timer(
      basic_waitable_timer && other);


This constructor moves a timer from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_waitable_timer(const executor_type&)` constructor. 




[endsect]



[section:overload8 basic_waitable_timer::basic_waitable_timer (8 of 8 overloads)]


Move-construct a [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] from another. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_waitable_timer(
      basic_waitable_timer< Clock, WaitTraits, Executor1 > && other,
      typename constraint< is_convertible< Executor1, Executor >::value >::type  = 0);


This constructor moves a timer from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_waitable_timer(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:cancel basic_waitable_timer::cancel]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.cancel..cancel..basic_waitable_timer] 
Cancel any asynchronous operations that are waiting on the timer. 


  std::size_t ``[link boost_asio.reference.basic_waitable_timer.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.cancel.overload1 more...]]``


(Deprecated: Use non-error\_code overload.) Cancel any asynchronous operations that are waiting on the timer. 


  std::size_t ``[link boost_asio.reference.basic_waitable_timer.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.cancel.overload2 more...]]``


[section:overload1 basic_waitable_timer::cancel (1 of 2 overloads)]


Cancel any asynchronous operations that are waiting on the timer. 


  std::size_t cancel();


This function forces the completion of any pending asynchronous wait operations against the timer. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.

Cancelling the timer does not change the expiry time.


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If the timer has already expired when `cancel()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]



[section:overload2 basic_waitable_timer::cancel (2 of 2 overloads)]


(Deprecated: Use non-error\_code overload.) Cancel any asynchronous operations that are waiting on the timer. 


  std::size_t cancel(
      boost::system::error_code & ec);


This function forces the completion of any pending asynchronous wait operations against the timer. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.

Cancelling the timer does not change the expiry time.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Remarks]
      
If the timer has already expired when `cancel()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]


[endsect]

[section:cancel_one basic_waitable_timer::cancel_one]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.cancel_one..cancel_one..basic_waitable_timer] 
Cancels one asynchronous operation that is waiting on the timer. 


  std::size_t ``[link boost_asio.reference.basic_waitable_timer.cancel_one.overload1 cancel_one]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.cancel_one.overload1 more...]]``


(Deprecated: Use non-error\_code overload.) Cancels one asynchronous operation that is waiting on the timer. 


  std::size_t ``[link boost_asio.reference.basic_waitable_timer.cancel_one.overload2 cancel_one]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.cancel_one.overload2 more...]]``


[section:overload1 basic_waitable_timer::cancel_one (1 of 2 overloads)]


Cancels one asynchronous operation that is waiting on the timer. 


  std::size_t cancel_one();


This function forces the completion of one pending asynchronous wait operation against the timer. Handlers are cancelled in FIFO order. The handler for the cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.

Cancelling the timer does not change the expiry time.


[heading Return Value]
      
The number of asynchronous operations that were cancelled. That is, either 0 or 1.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If the timer has already expired when `cancel_one()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]



[section:overload2 basic_waitable_timer::cancel_one (2 of 2 overloads)]


(Deprecated: Use non-error\_code overload.) Cancels one asynchronous operation that is waiting on the timer. 


  std::size_t cancel_one(
      boost::system::error_code & ec);


This function forces the completion of one pending asynchronous wait operation against the timer. Handlers are cancelled in FIFO order. The handler for the cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.

Cancelling the timer does not change the expiry time.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled. That is, either 0 or 1.


[heading Remarks]
      
If the timer has already expired when `cancel_one()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]


[endsect]


[section:clock_type basic_waitable_timer::clock_type]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.clock_type..clock_type..basic_waitable_timer] 
The clock type. 


  typedef Clock clock_type;



[heading Requirements]

['Header: ][^boost/asio/basic_waitable_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:duration basic_waitable_timer::duration]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.duration..duration..basic_waitable_timer] 
The duration type of the clock. 


  typedef clock_type::duration duration;



[heading Requirements]

['Header: ][^boost/asio/basic_waitable_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:executor_type basic_waitable_timer::executor_type]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.executor_type..executor_type..basic_waitable_timer] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_waitable_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:expires_after basic_waitable_timer::expires_after]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.expires_after..expires_after..basic_waitable_timer] 
Set the timer's expiry time relative to now. 


  std::size_t expires_after(
      const duration & expiry_time);


This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If the timer has already expired when `expires_after()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]


[section:expires_at basic_waitable_timer::expires_at]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.expires_at..expires_at..basic_waitable_timer] 
(Deprecated: Use `expiry()`.) Get the timer's expiry time as an absolute time. 


  time_point ``[link boost_asio.reference.basic_waitable_timer.expires_at.overload1 expires_at]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.expires_at.overload1 more...]]``


Set the timer's expiry time as an absolute time. 


  std::size_t ``[link boost_asio.reference.basic_waitable_timer.expires_at.overload2 expires_at]``(
      const time_point & expiry_time);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.expires_at.overload2 more...]]``


(Deprecated: Use non-error\_code overload.) Set the timer's expiry time as an absolute time. 


  std::size_t ``[link boost_asio.reference.basic_waitable_timer.expires_at.overload3 expires_at]``(
      const time_point & expiry_time,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.expires_at.overload3 more...]]``


[section:overload1 basic_waitable_timer::expires_at (1 of 3 overloads)]


(Deprecated: Use `expiry()`.) Get the timer's expiry time as an absolute time. 


  time_point expires_at() const;


This function may be used to obtain the timer's current expiry time. Whether the timer has expired or not does not affect this value. 


[endsect]



[section:overload2 basic_waitable_timer::expires_at (2 of 3 overloads)]


Set the timer's expiry time as an absolute time. 


  std::size_t expires_at(
      const time_point & expiry_time);


This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If the timer has already expired when `expires_at()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]



[section:overload3 basic_waitable_timer::expires_at (3 of 3 overloads)]


(Deprecated: Use non-error\_code overload.) Set the timer's expiry time as an absolute time. 


  std::size_t expires_at(
      const time_point & expiry_time,
      boost::system::error_code & ec);


This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Remarks]
      
If the timer has already expired when `expires_at()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]


[endsect]

[section:expires_from_now basic_waitable_timer::expires_from_now]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.expires_from_now..expires_from_now..basic_waitable_timer] 
(Deprecated: Use `expiry()`.) Get the timer's expiry time relative to now. 


  duration ``[link boost_asio.reference.basic_waitable_timer.expires_from_now.overload1 expires_from_now]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.expires_from_now.overload1 more...]]``


(Deprecated: Use `expires_after()`.) Set the timer's expiry time relative to now. 


  std::size_t ``[link boost_asio.reference.basic_waitable_timer.expires_from_now.overload2 expires_from_now]``(
      const duration & expiry_time);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.expires_from_now.overload2 more...]]``

  std::size_t ``[link boost_asio.reference.basic_waitable_timer.expires_from_now.overload3 expires_from_now]``(
      const duration & expiry_time,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.expires_from_now.overload3 more...]]``


[section:overload1 basic_waitable_timer::expires_from_now (1 of 3 overloads)]


(Deprecated: Use `expiry()`.) Get the timer's expiry time relative to now. 


  duration expires_from_now() const;


This function may be used to obtain the timer's current expiry time. Whether the timer has expired or not does not affect this value. 


[endsect]



[section:overload2 basic_waitable_timer::expires_from_now (2 of 3 overloads)]


(Deprecated: Use `expires_after()`.) Set the timer's expiry time relative to now. 


  std::size_t expires_from_now(
      const duration & expiry_time);


This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
If the timer has already expired when `expires_from_now()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]



[section:overload3 basic_waitable_timer::expires_from_now (3 of 3 overloads)]


(Deprecated: Use `expires_after()`.) Set the timer's expiry time relative to now. 


  std::size_t expires_from_now(
      const duration & expiry_time,
      boost::system::error_code & ec);


This function sets the expiry time. Any pending asynchronous wait operations will be cancelled. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code.


[heading Parameters]
    

[variablelist
  
[[expiry_time][The expiry time to be used for the timer.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of asynchronous operations that were cancelled.


[heading Remarks]
      
If the timer has already expired when `expires_from_now()` is called, then the handlers for asynchronous wait operations will:


* have already been invoked; or


* have been queued for invocation in the near future.

These handlers can no longer be cancelled, and therefore are passed an error code that indicates the successful completion of the wait operation. 


[endsect]


[endsect]


[section:expiry basic_waitable_timer::expiry]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.expiry..expiry..basic_waitable_timer] 
Get the timer's expiry time as an absolute time. 


  time_point expiry() const;


This function may be used to obtain the timer's current expiry time. Whether the timer has expired or not does not affect this value. 


[endsect]



[section:get_executor basic_waitable_timer::get_executor]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.get_executor..get_executor..basic_waitable_timer] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:operator_eq_ basic_waitable_timer::operator=]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.operator_eq_..operator=..basic_waitable_timer] 
Move-assign a [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] from another. 


  basic_waitable_timer & ``[link boost_asio.reference.basic_waitable_timer.operator_eq_.overload1 operator=]``(
      basic_waitable_timer && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.operator_eq_.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_waitable_timer & >::type ``[link boost_asio.reference.basic_waitable_timer.operator_eq_.overload2 operator=]``(
      basic_waitable_timer< Clock, WaitTraits, Executor1 > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.operator_eq_.overload2 more...]]``


[section:overload1 basic_waitable_timer::operator= (1 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] from another. 


  basic_waitable_timer & operator=(
      basic_waitable_timer && other);


This assignment operator moves a timer from one object to another. Cancels any outstanding asynchronous operations associated with the target object.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_waitable_timer(const executor_type&)` constructor. 




[endsect]



[section:overload2 basic_waitable_timer::operator= (2 of 2 overloads)]


Move-assign a [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] from another. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_waitable_timer & >::type operator=(
      basic_waitable_timer< Clock, WaitTraits, Executor1 > && other);


This assignment operator moves a timer from one object to another. Cancels any outstanding asynchronous operations associated with the target object.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_waitable_timer(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:time_point basic_waitable_timer::time_point]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.time_point..time_point..basic_waitable_timer] 
The time point type of the clock. 


  typedef clock_type::time_point time_point;



[heading Requirements]

['Header: ][^boost/asio/basic_waitable_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:traits_type basic_waitable_timer::traits_type]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.traits_type..traits_type..basic_waitable_timer] 
The wait traits type. 


  typedef WaitTraits traits_type;



[heading Requirements]

['Header: ][^boost/asio/basic_waitable_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:wait basic_waitable_timer::wait]

[indexterm2 boost_asio.indexterm.basic_waitable_timer.wait..wait..basic_waitable_timer] 
Perform a blocking wait on the timer. 


  void ``[link boost_asio.reference.basic_waitable_timer.wait.overload1 wait]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.wait.overload1 more...]]``

  void ``[link boost_asio.reference.basic_waitable_timer.wait.overload2 wait]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_waitable_timer.wait.overload2 more...]]``


[section:overload1 basic_waitable_timer::wait (1 of 2 overloads)]


Perform a blocking wait on the timer. 


  void wait();


This function is used to wait for the timer to expire. This function blocks and does not return until the timer has expired.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_waitable_timer::wait (2 of 2 overloads)]


Perform a blocking wait on the timer. 


  void wait(
      boost::system::error_code & ec);


This function is used to wait for the timer to expire. This function blocks and does not return until the timer has expired.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:_basic_waitable_timer basic_waitable_timer::~basic_waitable_timer]

[indexterm2 boost_asio.indexterm.basic_waitable_timer._basic_waitable_timer..~basic_waitable_timer..basic_waitable_timer] 
Destroys the timer. 


  ~basic_waitable_timer();


This function destroys the timer, cancelling any outstanding asynchronous wait operations associated with the timer as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_waitable_timer__rebind_executor basic_waitable_timer::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_waitable_timer__rebind_executor..basic_waitable_timer::rebind_executor]


Rebinds the timer type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_waitable_timer__rebind_executor.other [*other]]]
    [The timer type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_waitable_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_waitable_timer::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_waitable_timer__rebind_executor.other..other..basic_waitable_timer::rebind_executor] 
The timer type when rebound to the specified executor. 


  typedef basic_waitable_timer< Clock, WaitTraits, Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_waitable_timer__rebind_executor [*rebind_executor]]]
    [Rebinds the timer type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.duration [*duration]]]
    [The duration type of the clock. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.time_point [*time_point]]]
    [The time point type of the clock. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.traits_type [*traits_type]]]
    [The wait traits type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_waitable_timer.async_wait [*async_wait]]]
    [Start an asynchronous wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.basic_waitable_timer [*basic_waitable_timer]] [constructor]]
    [Constructor. 
     [hr]
     Constructor to set a particular expiry time as an absolute time. 
     [hr]
     Constructor to set a particular expiry time relative to now. 
     [hr]
     Move-construct a basic_waitable_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the timer. 
     [hr]
     (Deprecated: Use non-error_code overload.) Cancel any asynchronous operations that are waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.cancel_one [*cancel_one]]]
    [Cancels one asynchronous operation that is waiting on the timer. 
     [hr]
     (Deprecated: Use non-error_code overload.) Cancels one asynchronous operation that is waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_after [*expires_after]]]
    [Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_at [*expires_at]]]
    [(Deprecated: Use expiry().) Get the timer's expiry time as an absolute time. 
     [hr]
     Set the timer's expiry time as an absolute time. 
     [hr]
     (Deprecated: Use non-error_code overload.) Set the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_from_now [*expires_from_now]]]
    [(Deprecated: Use expiry().) Get the timer's expiry time relative to now. 
     [hr]
     (Deprecated: Use expires_after().) Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expiry [*expiry]]]
    [Get the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.operator_eq_ [*operator=]]]
    [Move-assign a basic_waitable_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.wait [*wait]]]
    [Perform a blocking wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer._basic_waitable_timer [*~basic_waitable_timer]] [destructor]]
    [Destroys the timer. ]
  ]
  
]

The [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] class template provides the ability to perform a blocking or asynchronous wait for a timer to expire.

A waitable timer is always in one of two states: "expired" or "not expired". If the `wait()` or `async_wait()` function is called on an expired timer, the wait operation will complete immediately.

Most applications will use one of the [link boost_asio.reference.steady_timer `steady_timer`], [link boost_asio.reference.system_timer `system_timer`] or [link boost_asio.reference.high_resolution_timer `high_resolution_timer`] typedefs.


[heading Remarks]
      
This waitable timer functionality is for use with the C++11 standard library's `<chrono>` facility, or with the Boost.Chrono library.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.


[heading Examples]
  
Performing a blocking wait (C++11): 

   // Construct a timer without setting an expiry time.
   boost::asio::steady_timer timer(my_context);

   // Set an expiry time relative to now.
   timer.expires_after(std::chrono::seconds(5));

   // Wait for the timer to expire.
   timer.wait();





Performing an asynchronous wait (C++11): 

   void handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Timer expired.
     }
   }

   ...

   // Construct a timer with an absolute expiry time.
   boost::asio::steady_timer timer(my_context,
       std::chrono::steady_clock::now() + std::chrono::seconds(60));

   // Start an asynchronous wait.
   timer.async_wait(handler);





[heading Changing an active waitable timer's expiry time]
  


Changing the expiry time of a timer while there are pending asynchronous waits causes those wait operations to be cancelled. To ensure that the action associated with the timer is performed only once, use something like this: used:



   void on_some_event()
   {
     if (my_timer.expires_after(seconds(5)) > 0)
     {
       // We managed to cancel the timer. Start new asynchronous wait.
       my_timer.async_wait(on_timeout);
     }
     else
     {
       // Too late, timer has already expired!
     }
   }

   void on_timeout(const boost::system::error_code& e)
   {
     if (e != boost::asio::error::operation_aborted)
     {
       // Timer was not cancelled, take necessary action.
     }
   }





* The `boost::asio::basic_waitable_timer::expires_after()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.


* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 




[heading Requirements]

['Header: ][^boost/asio/basic_waitable_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_writable_pipe basic_writable_pipe]

[indexterm1 boost_asio.indexterm.basic_writable_pipe..basic_writable_pipe]


Provides pipe functionality. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  class basic_writable_pipe


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_writable_pipe__rebind_executor [*rebind_executor]]]
    [Rebinds the pipe type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_writable_pipe.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_writable_pipe.lowest_layer_type [*lowest_layer_type]]]
    [A basic_writable_pipe is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_writable_pipe.native_handle_type [*native_handle_type]]]
    [The native representation of a pipe. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_writable_pipe.assign [*assign]]]
    [Assign an existing native pipe to the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.basic_writable_pipe [*basic_writable_pipe]] [constructor]]
    [Construct a basic_writable_pipe without opening it. 
     [hr]
     Construct a basic_writable_pipe on an existing native pipe. 
     [hr]
     Move-construct a basic_writable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.close [*close]]]
    [Close the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.is_open [*is_open]]]
    [Determine whether the pipe is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.native_handle [*native_handle]]]
    [Get the native pipe representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.operator_eq_ [*operator=]]]
    [Move-assign a basic_writable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.write_some [*write_some]]]
    [Write some data to the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe._basic_writable_pipe [*~basic_writable_pipe]] [destructor]]
    [Destroys the pipe. ]
  ]
  
]

The [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] class provides a wrapper over pipe functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/basic_writable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign basic_writable_pipe::assign]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.assign..assign..basic_writable_pipe] 
Assign an existing native pipe to the pipe. 


  void ``[link boost_asio.reference.basic_writable_pipe.assign.overload1 assign]``(
      const native_handle_type & native_pipe);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.assign.overload1 more...]]``

  void ``[link boost_asio.reference.basic_writable_pipe.assign.overload2 assign]``(
      const native_handle_type & native_pipe,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.assign.overload2 more...]]``


[section:overload1 basic_writable_pipe::assign (1 of 2 overloads)]


Assign an existing native pipe to the pipe. 


  void assign(
      const native_handle_type & native_pipe);



[endsect]



[section:overload2 basic_writable_pipe::assign (2 of 2 overloads)]


Assign an existing native pipe to the pipe. 


  void assign(
      const native_handle_type & native_pipe,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_write_some basic_writable_pipe::async_write_some]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.async_write_some..async_write_some..basic_writable_pipe] 
Start an asynchronous write. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_some(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write data to the pipe. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the pipe. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes written.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The write operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.async_write `async_write`]  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   pipe.async_write_some(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]


[section:basic_writable_pipe basic_writable_pipe::basic_writable_pipe]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.basic_writable_pipe..basic_writable_pipe..basic_writable_pipe] 
Construct a [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] without opening it. 


  explicit ``[link boost_asio.reference.basic_writable_pipe.basic_writable_pipe.overload1 basic_writable_pipe]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.basic_writable_pipe.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.basic_writable_pipe.basic_writable_pipe.overload2 basic_writable_pipe]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.basic_writable_pipe.overload2 more...]]``


Construct a [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] on an existing native pipe. 


  ``[link boost_asio.reference.basic_writable_pipe.basic_writable_pipe.overload3 basic_writable_pipe]``(
      const executor_type & ex,
      const native_handle_type & native_pipe);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.basic_writable_pipe.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.basic_writable_pipe.basic_writable_pipe.overload4 basic_writable_pipe]``(
      ExecutionContext & context,
      const native_handle_type & native_pipe,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.basic_writable_pipe.overload4 more...]]``


Move-construct a [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] from another. 


  ``[link boost_asio.reference.basic_writable_pipe.basic_writable_pipe.overload5 basic_writable_pipe]``(
      basic_writable_pipe && other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.basic_writable_pipe.overload5 more...]]``


[section:overload1 basic_writable_pipe::basic_writable_pipe (1 of 5 overloads)]


Construct a [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] without opening it. 


  basic_writable_pipe(
      const executor_type & ex);


This constructor creates a pipe without opening it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the pipe will use, by default, to dispatch handlers for any asynchronous operations performed on the pipe. ]]

]




[endsect]



[section:overload2 basic_writable_pipe::basic_writable_pipe (2 of 5 overloads)]


Construct a [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] without opening it. 


  template<
      typename ExecutionContext>
  basic_writable_pipe(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates a pipe without opening it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the pipe will use, by default, to dispatch handlers for any asynchronous operations performed on the pipe. ]]

]




[endsect]



[section:overload3 basic_writable_pipe::basic_writable_pipe (3 of 5 overloads)]


Construct a [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] on an existing native pipe. 


  basic_writable_pipe(
      const executor_type & ex,
      const native_handle_type & native_pipe);


This constructor creates a pipe object to hold an existing native pipe.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the pipe will use, by default, to dispatch handlers for any asynchronous operations performed on the pipe.]]

[[native_pipe][A native pipe.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 basic_writable_pipe::basic_writable_pipe (4 of 5 overloads)]


Construct a [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] on an existing native pipe. 


  template<
      typename ExecutionContext>
  basic_writable_pipe(
      ExecutionContext & context,
      const native_handle_type & native_pipe,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a pipe object to hold an existing native pipe.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the pipe will use, by default, to dispatch handlers for any asynchronous operations performed on the pipe.]]

[[native_pipe][A native pipe.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 basic_writable_pipe::basic_writable_pipe (5 of 5 overloads)]


Move-construct a [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] from another. 


  basic_writable_pipe(
      basic_writable_pipe && other);


This constructor moves a pipe from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_writable_pipe(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:cancel basic_writable_pipe::cancel]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.cancel..cancel..basic_writable_pipe] 
Cancel all asynchronous operations associated with the pipe. 


  void ``[link boost_asio.reference.basic_writable_pipe.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.basic_writable_pipe.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.cancel.overload2 more...]]``


[section:overload1 basic_writable_pipe::cancel (1 of 2 overloads)]


Cancel all asynchronous operations associated with the pipe. 


  void cancel();


This function causes all outstanding asynchronous write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_writable_pipe::cancel (2 of 2 overloads)]


Cancel all asynchronous operations associated with the pipe. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:close basic_writable_pipe::close]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.close..close..basic_writable_pipe] 
Close the pipe. 


  void ``[link boost_asio.reference.basic_writable_pipe.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.close.overload1 more...]]``

  void ``[link boost_asio.reference.basic_writable_pipe.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.close.overload2 more...]]``


[section:overload1 basic_writable_pipe::close (1 of 2 overloads)]


Close the pipe. 


  void close();


This function is used to close the pipe. Any asynchronous write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 basic_writable_pipe::close (2 of 2 overloads)]


Close the pipe. 


  void close(
      boost::system::error_code & ec);


This function is used to close the pipe. Any asynchronous write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:executor_type basic_writable_pipe::executor_type]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.executor_type..executor_type..basic_writable_pipe] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/basic_writable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor basic_writable_pipe::get_executor]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.get_executor..get_executor..basic_writable_pipe] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:is_open basic_writable_pipe::is_open]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.is_open..is_open..basic_writable_pipe] 
Determine whether the pipe is open. 


  bool is_open() const;



[endsect]


[section:lowest_layer basic_writable_pipe::lowest_layer]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.lowest_layer..lowest_layer..basic_writable_pipe] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.basic_writable_pipe.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.basic_writable_pipe.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.lowest_layer.overload2 more...]]``


[section:overload1 basic_writable_pipe::lowest_layer (1 of 2 overloads)]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 basic_writable_pipe::lowest_layer (2 of 2 overloads)]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since a [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type basic_writable_pipe::lowest_layer_type]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.lowest_layer_type..lowest_layer_type..basic_writable_pipe] 
A [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] is always the lowest layer. 


  typedef basic_writable_pipe lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_writable_pipe__rebind_executor [*rebind_executor]]]
    [Rebinds the pipe type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_writable_pipe.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_writable_pipe.lowest_layer_type [*lowest_layer_type]]]
    [A basic_writable_pipe is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_writable_pipe.native_handle_type [*native_handle_type]]]
    [The native representation of a pipe. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_writable_pipe.assign [*assign]]]
    [Assign an existing native pipe to the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.basic_writable_pipe [*basic_writable_pipe]] [constructor]]
    [Construct a basic_writable_pipe without opening it. 
     [hr]
     Construct a basic_writable_pipe on an existing native pipe. 
     [hr]
     Move-construct a basic_writable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.close [*close]]]
    [Close the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.is_open [*is_open]]]
    [Determine whether the pipe is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.native_handle [*native_handle]]]
    [Get the native pipe representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.operator_eq_ [*operator=]]]
    [Move-assign a basic_writable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.write_some [*write_some]]]
    [Write some data to the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe._basic_writable_pipe [*~basic_writable_pipe]] [destructor]]
    [Destroys the pipe. ]
  ]
  
]

The [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] class provides a wrapper over pipe functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_writable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:native_handle basic_writable_pipe::native_handle]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.native_handle..native_handle..basic_writable_pipe] 
Get the native pipe representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the pipe. This is intended to allow access to native pipe functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type basic_writable_pipe::native_handle_type]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.native_handle_type..native_handle_type..basic_writable_pipe] 
The native representation of a pipe. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/basic_writable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ basic_writable_pipe::operator=]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.operator_eq_..operator=..basic_writable_pipe] 
Move-assign a [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] from another. 


  basic_writable_pipe & operator=(
      basic_writable_pipe && other);


This assignment operator moves a pipe from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_writable_pipe(const executor_type&)` constructor. 




[endsect]


[section:write_some basic_writable_pipe::write_some]

[indexterm2 boost_asio.indexterm.basic_writable_pipe.write_some..write_some..basic_writable_pipe] 
Write some data to the pipe. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_writable_pipe.write_some.overload1 write_some]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.write_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.basic_writable_pipe.write_some.overload2 write_some]``(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_writable_pipe.write_some.overload2 more...]]``


[section:overload1 basic_writable_pipe::write_some (1 of 2 overloads)]


Write some data to the pipe. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers);


This function is used to write data to the pipe. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the pipe.]]

]


[heading Return Value]
      
The number of bytes written.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   pipe.write_some(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 basic_writable_pipe::write_some (2 of 2 overloads)]


Write some data to the pipe. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to write data to the pipe. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the pipe.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. Returns 0 if an error occurred.


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]


[endsect]


[section:_basic_writable_pipe basic_writable_pipe::~basic_writable_pipe]

[indexterm2 boost_asio.indexterm.basic_writable_pipe._basic_writable_pipe..~basic_writable_pipe..basic_writable_pipe] 
Destroys the pipe. 


  ~basic_writable_pipe();


This function destroys the pipe, cancelling any outstanding asynchronous wait operations associated with the pipe as if by calling `cancel`. 


[endsect]



[endsect]

[section:basic_writable_pipe__rebind_executor basic_writable_pipe::rebind_executor]

[indexterm1 boost_asio.indexterm.basic_writable_pipe__rebind_executor..basic_writable_pipe::rebind_executor]


Rebinds the pipe type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_writable_pipe__rebind_executor.other [*other]]]
    [The pipe type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/basic_writable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other basic_writable_pipe::rebind_executor::other]

[indexterm2 boost_asio.indexterm.basic_writable_pipe__rebind_executor.other..other..basic_writable_pipe::rebind_executor] 
The pipe type when rebound to the specified executor. 


  typedef basic_writable_pipe< Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_writable_pipe__rebind_executor [*rebind_executor]]]
    [Rebinds the pipe type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_writable_pipe.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_writable_pipe.lowest_layer_type [*lowest_layer_type]]]
    [A basic_writable_pipe is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_writable_pipe.native_handle_type [*native_handle_type]]]
    [The native representation of a pipe. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_writable_pipe.assign [*assign]]]
    [Assign an existing native pipe to the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.basic_writable_pipe [*basic_writable_pipe]] [constructor]]
    [Construct a basic_writable_pipe without opening it. 
     [hr]
     Construct a basic_writable_pipe on an existing native pipe. 
     [hr]
     Move-construct a basic_writable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.close [*close]]]
    [Close the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.is_open [*is_open]]]
    [Determine whether the pipe is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.native_handle [*native_handle]]]
    [Get the native pipe representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.operator_eq_ [*operator=]]]
    [Move-assign a basic_writable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.write_some [*write_some]]]
    [Write some data to the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe._basic_writable_pipe [*~basic_writable_pipe]] [destructor]]
    [Destroys the pipe. ]
  ]
  
]

The [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] class provides a wrapper over pipe functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/basic_writable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:basic_yield_context basic_yield_context]

[indexterm1 boost_asio.indexterm.basic_yield_context..basic_yield_context]


Context object the represents the currently executing coroutine. 


  template<
      typename ``[link boost_asio.reference.Handler Handler]``>
  class basic_yield_context


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_yield_context.callee_type [*callee_type]]]
    [The coroutine callee type, used by the implementation. ]
  
  ]

  [

    [[link boost_asio.reference.basic_yield_context.caller_type [*caller_type]]]
    [The coroutine caller type, used by the implementation. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_yield_context.basic_yield_context [*basic_yield_context]] [constructor]]
    [Construct a yield context to represent the specified coroutine. 
     [hr]
     Construct a yield context from another yield context type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_yield_context.operator_lb__rb_ [*operator\[\]]]]
    [Return a yield context that sets the specified error_code. ]
  ]
  
]

The [link boost_asio.reference.basic_yield_context `basic_yield_context`] class is used to represent the currently executing stackful coroutine. A [link boost_asio.reference.basic_yield_context `basic_yield_context`] may be passed as a handler to an asynchronous operation. For example:



   template <typename Handler>
   void my_coroutine(basic_yield_context<Handler> yield)
   {
     ...
     std::size_t n = my_socket.async_read_some(buffer, yield);
     ...
   } 




The initiating function (async\_read\_some in the above example) suspends the current coroutine. The coroutine is resumed when the asynchronous operation completes, and the result of the operation is returned. 

[heading Requirements]

['Header: ][^boost/asio/spawn.hpp]

['Convenience header: ]None

[section:basic_yield_context basic_yield_context::basic_yield_context]

[indexterm2 boost_asio.indexterm.basic_yield_context.basic_yield_context..basic_yield_context..basic_yield_context] 
Construct a yield context to represent the specified coroutine. 


  ``[link boost_asio.reference.basic_yield_context.basic_yield_context.overload1 basic_yield_context]``(
      const detail::weak_ptr< callee_type > & coro,
      caller_type & ca,
      Handler & handler);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_yield_context.basic_yield_context.overload1 more...]]``


Construct a yield context from another yield context type. 


  template<
      typename OtherHandler>
  ``[link boost_asio.reference.basic_yield_context.basic_yield_context.overload2 basic_yield_context]``(
      const basic_yield_context< OtherHandler > & other);
  ``  [''''&raquo;''' [link boost_asio.reference.basic_yield_context.basic_yield_context.overload2 more...]]``


[section:overload1 basic_yield_context::basic_yield_context (1 of 2 overloads)]


Construct a yield context to represent the specified coroutine. 


  basic_yield_context(
      const detail::weak_ptr< callee_type > & coro,
      caller_type & ca,
      Handler & handler);


Most applications do not need to use this constructor. Instead, the `spawn()` function passes a yield context as an argument to the coroutine function. 


[endsect]



[section:overload2 basic_yield_context::basic_yield_context (2 of 2 overloads)]


Construct a yield context from another yield context type. 


  template<
      typename OtherHandler>
  basic_yield_context(
      const basic_yield_context< OtherHandler > & other);


Requires that OtherHandler be convertible to Handler. 


[endsect]


[endsect]


[section:callee_type basic_yield_context::callee_type]

[indexterm2 boost_asio.indexterm.basic_yield_context.callee_type..callee_type..basic_yield_context] 
The coroutine callee type, used by the implementation. 


  typedef implementation_defined callee_type;



When using Boost.Coroutine v1, this type is: 

   typename coroutine<void()> 


When using Boost.Coroutine v2 (unidirectional coroutines), this type is: 

   push_coroutine<void> 




[heading Requirements]

['Header: ][^boost/asio/spawn.hpp]

['Convenience header: ]None


[endsect]



[section:caller_type basic_yield_context::caller_type]

[indexterm2 boost_asio.indexterm.basic_yield_context.caller_type..caller_type..basic_yield_context] 
The coroutine caller type, used by the implementation. 


  typedef implementation_defined caller_type;



When using Boost.Coroutine v1, this type is: 

   typename coroutine<void()>::caller_type 


When using Boost.Coroutine v2 (unidirectional coroutines), this type is: 

   pull_coroutine<void> 




[heading Requirements]

['Header: ][^boost/asio/spawn.hpp]

['Convenience header: ]None


[endsect]



[section:operator_lb__rb_ basic_yield_context::operator\[\]]

[indexterm2 boost_asio.indexterm.basic_yield_context.operator_lb__rb_..operator\[\]..basic_yield_context] 
Return a yield context that sets the specified error\_code. 


  basic_yield_context operator[](
      boost::system::error_code & ec) const;


By default, when a yield context is used with an asynchronous operation, a non-success error\_code is converted to system\_error and thrown. This operator may be used to specify an error\_code object that should instead be set with the asynchronous operation's result. For example:



   template <typename Handler>
   void my_coroutine(basic_yield_context<Handler> yield)
   {
     ...
     std::size_t n = my_socket.async_read_some(buffer, yield[ec]);
     if (ec)
     {
       // An error occurred.
     }
     ...
   } 





[endsect]



[endsect]


[section:bind_cancellation_slot bind_cancellation_slot]

[indexterm1 boost_asio.indexterm.bind_cancellation_slot..bind_cancellation_slot] 
Associate an object of type `T` with a cancellation slot of type `CancellationSlot`. 


  template<
      typename ``[link boost_asio.reference.CancellationSlot CancellationSlot]``,
      typename T>
  cancellation_slot_binder< typename decay< T >::type, CancellationSlot > bind_cancellation_slot(
      const CancellationSlot & s,
      T && t);


[heading Requirements]

['Header: ][^boost/asio/bind_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:bind_executor bind_executor]

[indexterm1 boost_asio.indexterm.bind_executor..bind_executor] 
Associate an object of type `T` with an executor of type `Executor`. 

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename T>
  executor_binder< typename decay< T >::type, Executor > ``[link boost_asio.reference.bind_executor.overload1 bind_executor]``(
      const Executor & ex,
      T && t,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.bind_executor.overload1 more...]]``

Associate an object of type `T` with an execution context's executor. 

  template<
      typename ExecutionContext,
      typename T>
  executor_binder< typename decay< T >::type, typename ExecutionContext::executor_type > ``[link boost_asio.reference.bind_executor.overload2 bind_executor]``(
      ExecutionContext & ctx,
      T && t,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.bind_executor.overload2 more...]]``

[heading Requirements]

['Header: ][^boost/asio/bind_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 bind_executor (1 of 2 overloads)]


Associate an object of type `T` with an executor of type `Executor`. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename T>
  executor_binder< typename decay< T >::type, Executor > bind_executor(
      const Executor & ex,
      T && t,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);



[endsect]



[section:overload2 bind_executor (2 of 2 overloads)]


Associate an object of type `T` with an execution context's executor. 


  template<
      typename ExecutionContext,
      typename T>
  executor_binder< typename decay< T >::type, typename ExecutionContext::executor_type > bind_executor(
      ExecutionContext & ctx,
      T && t,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[endsect]


[endsect]

[section:buffer buffer]

[indexterm1 boost_asio.indexterm.buffer..buffer] 
The `boost::asio::buffer` function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string. 


Create a new modifiable buffer from an existing buffer. 

  mutable_buffer ``[link boost_asio.reference.buffer.overload1 buffer]``(
      const mutable_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload1 more...]]``

  mutable_buffer ``[link boost_asio.reference.buffer.overload2 buffer]``(
      const mutable_buffer & b,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload2 more...]]``

Create a new non-modifiable buffer from an existing buffer. 

  const_buffer ``[link boost_asio.reference.buffer.overload3 buffer]``(
      const const_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload3 more...]]``

  const_buffer ``[link boost_asio.reference.buffer.overload4 buffer]``(
      const const_buffer & b,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload4 more...]]``

Create a new modifiable buffer that represents the given memory range. 

  mutable_buffer ``[link boost_asio.reference.buffer.overload5 buffer]``(
      void * data,
      std::size_t size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload5 more...]]``

Create a new non-modifiable buffer that represents the given memory range. 

  const_buffer ``[link boost_asio.reference.buffer.overload6 buffer]``(
      const void * data,
      std::size_t size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload6 more...]]``

Create a new modifiable buffer that represents the given POD array. 

  template<
      typename PodType,
      std::size_t N>
  mutable_buffer ``[link boost_asio.reference.buffer.overload7 buffer]``(
      PodType (&data)[N]);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload7 more...]]``

  template<
      typename PodType,
      std::size_t N>
  mutable_buffer ``[link boost_asio.reference.buffer.overload8 buffer]``(
      PodType (&data)[N],
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload8 more...]]``

Create a new non-modifiable buffer that represents the given POD array. 

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link boost_asio.reference.buffer.overload9 buffer]``(
      const PodType (&data)[N]);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload9 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link boost_asio.reference.buffer.overload10 buffer]``(
      const PodType (&data)[N],
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload10 more...]]``

Create a new modifiable buffer that represents the given POD array. 

  template<
      typename PodType,
      std::size_t N>
  mutable_buffer ``[link boost_asio.reference.buffer.overload11 buffer]``(
      boost::array< PodType, N > & data);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload11 more...]]``

  template<
      typename PodType,
      std::size_t N>
  mutable_buffer ``[link boost_asio.reference.buffer.overload12 buffer]``(
      boost::array< PodType, N > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload12 more...]]``

Create a new non-modifiable buffer that represents the given POD array. 

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link boost_asio.reference.buffer.overload13 buffer]``(
      boost::array< const PodType, N > & data);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload13 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link boost_asio.reference.buffer.overload14 buffer]``(
      boost::array< const PodType, N > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload14 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link boost_asio.reference.buffer.overload15 buffer]``(
      const boost::array< PodType, N > & data);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload15 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link boost_asio.reference.buffer.overload16 buffer]``(
      const boost::array< PodType, N > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload16 more...]]``

Create a new modifiable buffer that represents the given POD array. 

  template<
      typename PodType,
      std::size_t N>
  mutable_buffer ``[link boost_asio.reference.buffer.overload17 buffer]``(
      std::array< PodType, N > & data);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload17 more...]]``

  template<
      typename PodType,
      std::size_t N>
  mutable_buffer ``[link boost_asio.reference.buffer.overload18 buffer]``(
      std::array< PodType, N > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload18 more...]]``

Create a new non-modifiable buffer that represents the given POD array. 

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link boost_asio.reference.buffer.overload19 buffer]``(
      std::array< const PodType, N > & data);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload19 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link boost_asio.reference.buffer.overload20 buffer]``(
      std::array< const PodType, N > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload20 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link boost_asio.reference.buffer.overload21 buffer]``(
      const std::array< PodType, N > & data);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload21 more...]]``

  template<
      typename PodType,
      std::size_t N>
  const_buffer ``[link boost_asio.reference.buffer.overload22 buffer]``(
      const std::array< PodType, N > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload22 more...]]``

Create a new modifiable buffer that represents the given POD vector. 

  template<
      typename PodType,
      typename Allocator>
  mutable_buffer ``[link boost_asio.reference.buffer.overload23 buffer]``(
      std::vector< PodType, Allocator > & data);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload23 more...]]``

  template<
      typename PodType,
      typename Allocator>
  mutable_buffer ``[link boost_asio.reference.buffer.overload24 buffer]``(
      std::vector< PodType, Allocator > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload24 more...]]``

Create a new non-modifiable buffer that represents the given POD vector. 

  template<
      typename PodType,
      typename Allocator>
  const_buffer ``[link boost_asio.reference.buffer.overload25 buffer]``(
      const std::vector< PodType, Allocator > & data);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload25 more...]]``

  template<
      typename PodType,
      typename Allocator>
  const_buffer ``[link boost_asio.reference.buffer.overload26 buffer]``(
      const std::vector< PodType, Allocator > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload26 more...]]``

Create a new modifiable buffer that represents the given string. 

  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  mutable_buffer ``[link boost_asio.reference.buffer.overload27 buffer]``(
      std::basic_string< Elem, Traits, Allocator > & data);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload27 more...]]``

  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  mutable_buffer ``[link boost_asio.reference.buffer.overload28 buffer]``(
      std::basic_string< Elem, Traits, Allocator > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload28 more...]]``

Create a new non-modifiable buffer that represents the given string. 

  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  const_buffer ``[link boost_asio.reference.buffer.overload29 buffer]``(
      const std::basic_string< Elem, Traits, Allocator > & data);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload29 more...]]``

  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  const_buffer ``[link boost_asio.reference.buffer.overload30 buffer]``(
      const std::basic_string< Elem, Traits, Allocator > & data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload30 more...]]``

Create a new modifiable buffer that represents the given string\_view. 

  template<
      typename Elem,
      typename Traits>
  const_buffer ``[link boost_asio.reference.buffer.overload31 buffer]``(
      basic_string_view< Elem, Traits > data);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload31 more...]]``

Create a new non-modifiable buffer that represents the given string. 

  template<
      typename Elem,
      typename Traits>
  const_buffer ``[link boost_asio.reference.buffer.overload32 buffer]``(
      basic_string_view< Elem, Traits > data,
      std::size_t max_size_in_bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload32 more...]]``

Obtain a buffer representing the entire registered buffer. 

  mutable_registered_buffer ``[link boost_asio.reference.buffer.overload33 buffer]``(
      const mutable_registered_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload33 more...]]``

  const_registered_buffer ``[link boost_asio.reference.buffer.overload34 buffer]``(
      const const_registered_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload34 more...]]``

Obtain a buffer representing part of a registered buffer. 

  mutable_registered_buffer ``[link boost_asio.reference.buffer.overload35 buffer]``(
      const mutable_registered_buffer & b,
      std::size_t n);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload35 more...]]``

  const_registered_buffer ``[link boost_asio.reference.buffer.overload36 buffer]``(
      const const_registered_buffer & b,
      std::size_t n);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer.overload36 more...]]``

A buffer object represents a contiguous region of memory as a 2-tuple consisting of a pointer and size in bytes. A tuple of the form `{void*, size_t}` specifies a mutable (modifiable) region of memory. Similarly, a tuple of the form `{const void*, size_t}` specifies a const (non-modifiable) region of memory. These two forms correspond to the classes [link boost_asio.reference.mutable_buffer `mutable_buffer`] and [link boost_asio.reference.const_buffer `const_buffer`], respectively. To mirror C++'s conversion rules, a [link boost_asio.reference.mutable_buffer `mutable_buffer`] is implicitly convertible to a [link boost_asio.reference.const_buffer `const_buffer`], and the opposite conversion is not permitted.

The simplest use case involves reading or writing a single buffer of a specified size:



   sock.send(boost::asio::buffer(data, size)); 




In the above example, the return value of `boost::asio::buffer` meets the requirements of the ConstBufferSequence concept so that it may be directly passed to the socket's write function. A buffer created for modifiable memory also meets the requirements of the MutableBufferSequence concept.

An individual buffer may be created from a builtin array, std::vector, std::array or boost::array of POD elements. This helps prevent buffer overruns by automatically determining the size of the buffer:



   char d1[128];
   size_t bytes_transferred = sock.receive(boost::asio::buffer(d1));

   std::vector<char> d2(128);
   bytes_transferred = sock.receive(boost::asio::buffer(d2));

   std::array<char, 128> d3;
   bytes_transferred = sock.receive(boost::asio::buffer(d3));

   boost::array<char, 128> d4;
   bytes_transferred = sock.receive(boost::asio::buffer(d4)); 




In all three cases above, the buffers created are exactly 128 bytes long. Note that a vector is ['never] automatically resized when creating or using a buffer. The buffer size is determined using the vector's `size()` member function, and not its capacity.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   boost::asio::mutable_buffer b1 = ...;
   std::size_t s1 = b1.size();
   unsigned char* p1 = static_cast<unsigned char*>(b1.data());

   boost::asio::const_buffer b2 = ...;
   std::size_t s2 = b2.size();
   const void* p2 = b2.data(); 




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered.

For convenience, a [link boost_asio.reference.buffer_size `buffer_size`]  function is provided that works with both buffers and buffer sequences (that is, types meeting the ConstBufferSequence or MutableBufferSequence type requirements). In this case, the function returns the total size of all buffers in the sequence.


[heading Buffer Copying]
  


The [link boost_asio.reference.buffer_copy `buffer_copy`]  function may be used to copy raw bytes between individual buffers and buffer sequences.

In particular, when used with the [link boost_asio.reference.buffer_size `buffer_size`]  function, the [link boost_asio.reference.buffer_copy `buffer_copy`]  function can be used to linearise a sequence of buffers. For example:



   vector<const_buffer> buffers = ...;

   vector<unsigned char> data(boost::asio::buffer_size(buffers));
   boost::asio::buffer_copy(boost::asio::buffer(data), buffers); 




Note that [link boost_asio.reference.buffer_copy `buffer_copy`]  is implemented in terms of `memcpy`, and consequently it cannot be used to copy between overlapping memory regions.


[heading Buffer Invalidation]
  


A buffer object does not have any ownership of the memory it refers to. It is the responsibility of the application to ensure the memory region remains valid until it is no longer required for an I/O operation. When the memory is no longer available, the buffer is said to have been invalidated.

For the `boost::asio::buffer` overloads that accept an argument of type std::vector, the buffer objects returned are invalidated by any vector operation that also invalidates all references, pointers and iterators referring to the elements in the sequence (C++ Std, 23.2.4)

For the `boost::asio::buffer` overloads that accept an argument of type std::basic\_string, the buffer objects returned are invalidated according to the rules defined for invalidation of references, pointers and iterators referring to elements of the sequence (C++ Std, 21.3).


[heading Buffer Arithmetic]
  


Buffer objects may be manipulated using simple arithmetic in a safe way which helps prevent buffer overruns. Consider an array initialised as follows:



   boost::array<char, 6> a = { 'a', 'b', 'c', 'd', 'e' }; 




A buffer object `b1` created using:



   b1 = boost::asio::buffer(a); 




represents the entire array, `{ 'a', 'b', 'c', 'd', 'e' }`. An optional second argument to the `boost::asio::buffer` function may be used to limit the size, in bytes, of the buffer:



   b2 = boost::asio::buffer(a, 3); 




such that `b2` represents the data `{ 'a', 'b', 'c' }`. Even if the size argument exceeds the actual size of the array, the size of the buffer object created will be limited to the array size.

An offset may be applied to an existing buffer to create a new one:



   b3 = b1 + 2; 




where `b3` will set to represent `{ 'c', 'd', 'e' }`. If the offset exceeds the size of the existing buffer, the newly created buffer will be empty.

Both an offset and size may be specified to create a buffer that corresponds to a specific range of bytes within an existing buffer:



   b4 = boost::asio::buffer(b1 + 1, 3); 




so that `b4` will refer to the bytes `{ 'b', 'c', 'd' }`.


[heading Buffers and Scatter-Gather I/O]
  


To read or write using multiple buffers (i.e. scatter-gather I/O), multiple buffer objects may be assigned into a container that supports the MutableBufferSequence (for read) or ConstBufferSequence (for write) concepts:



   char d1[128];
   std::vector<char> d2(128);
   boost::array<char, 128> d3;

   boost::array<mutable_buffer, 3> bufs1 = {
     boost::asio::buffer(d1),
     boost::asio::buffer(d2),
     boost::asio::buffer(d3) };
   bytes_transferred = sock.receive(bufs1);

   std::vector<const_buffer> bufs2;
   bufs2.push_back(boost::asio::buffer(d1));
   bufs2.push_back(boost::asio::buffer(d2));
   bufs2.push_back(boost::asio::buffer(d3));
   bytes_transferred = sock.send(bufs2); 




[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 buffer (1 of 36 overloads)]


Create a new modifiable buffer from an existing buffer. 


  mutable_buffer buffer(
      const mutable_buffer & b);



[heading Return Value]
      
`mutable_buffer(b)`. 




[endsect]



[section:overload2 buffer (2 of 36 overloads)]


Create a new modifiable buffer from an existing buffer. 


  mutable_buffer buffer(
      const mutable_buffer & b,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       b.data(),
       min(b.size(), max_size_in_bytes)); 







[endsect]



[section:overload3 buffer (3 of 36 overloads)]


Create a new non-modifiable buffer from an existing buffer. 


  const_buffer buffer(
      const const_buffer & b);



[heading Return Value]
      
`const_buffer(b)`. 




[endsect]



[section:overload4 buffer (4 of 36 overloads)]


Create a new non-modifiable buffer from an existing buffer. 


  const_buffer buffer(
      const const_buffer & b,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       b.data(),
       min(b.size(), max_size_in_bytes)); 







[endsect]



[section:overload5 buffer (5 of 36 overloads)]


Create a new modifiable buffer that represents the given memory range. 


  mutable_buffer buffer(
      void * data,
      std::size_t size_in_bytes);



[heading Return Value]
      
`mutable_buffer(data, size_in_bytes)`. 




[endsect]



[section:overload6 buffer (6 of 36 overloads)]


Create a new non-modifiable buffer that represents the given memory range. 


  const_buffer buffer(
      const void * data,
      std::size_t size_in_bytes);



[heading Return Value]
      
`const_buffer(data, size_in_bytes)`. 




[endsect]



[section:overload7 buffer (7 of 36 overloads)]


Create a new modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  mutable_buffer buffer(
      PodType (&data)[N]);



[heading Return Value]
      
A [link boost_asio.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       static_cast<void*>(data),
       N * sizeof(PodType)); 







[endsect]



[section:overload8 buffer (8 of 36 overloads)]


Create a new modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  mutable_buffer buffer(
      PodType (&data)[N],
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       static_cast<void*>(data),
       min(N * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload9 buffer (9 of 36 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      const PodType (&data)[N]);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       static_cast<const void*>(data),
       N * sizeof(PodType)); 







[endsect]



[section:overload10 buffer (10 of 36 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      const PodType (&data)[N],
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       static_cast<const void*>(data),
       min(N * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload11 buffer (11 of 36 overloads)]


Create a new modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  mutable_buffer buffer(
      boost::array< PodType, N > & data);



[heading Return Value]
      
A [link boost_asio.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.data(),
       data.size() * sizeof(PodType)); 







[endsect]



[section:overload12 buffer (12 of 36 overloads)]


Create a new modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  mutable_buffer buffer(
      boost::array< PodType, N > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.data(),
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload13 buffer (13 of 36 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      boost::array< const PodType, N > & data);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       data.size() * sizeof(PodType)); 







[endsect]



[section:overload14 buffer (14 of 36 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      boost::array< const PodType, N > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload15 buffer (15 of 36 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      const boost::array< PodType, N > & data);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       data.size() * sizeof(PodType)); 







[endsect]



[section:overload16 buffer (16 of 36 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      const boost::array< PodType, N > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload17 buffer (17 of 36 overloads)]


Create a new modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  mutable_buffer buffer(
      std::array< PodType, N > & data);



[heading Return Value]
      
A [link boost_asio.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.data(),
       data.size() * sizeof(PodType)); 







[endsect]



[section:overload18 buffer (18 of 36 overloads)]


Create a new modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  mutable_buffer buffer(
      std::array< PodType, N > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.data(),
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload19 buffer (19 of 36 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      std::array< const PodType, N > & data);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       data.size() * sizeof(PodType)); 







[endsect]



[section:overload20 buffer (20 of 36 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      std::array< const PodType, N > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload21 buffer (21 of 36 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      const std::array< PodType, N > & data);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       data.size() * sizeof(PodType)); 







[endsect]



[section:overload22 buffer (22 of 36 overloads)]


Create a new non-modifiable buffer that represents the given POD array. 


  template<
      typename PodType,
      std::size_t N>
  const_buffer buffer(
      const std::array< PodType, N > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 







[endsect]



[section:overload23 buffer (23 of 36 overloads)]


Create a new modifiable buffer that represents the given POD vector. 


  template<
      typename PodType,
      typename Allocator>
  mutable_buffer buffer(
      std::vector< PodType, Allocator > & data);



[heading Return Value]
      
A [link boost_asio.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.size() ? &data[0] : 0,
       data.size() * sizeof(PodType)); 





[heading Remarks]
      
The buffer is invalidated by any vector operation that would also invalidate iterators. 




[endsect]



[section:overload24 buffer (24 of 36 overloads)]


Create a new modifiable buffer that represents the given POD vector. 


  template<
      typename PodType,
      typename Allocator>
  mutable_buffer buffer(
      std::vector< PodType, Allocator > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.size() ? &data[0] : 0,
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 





[heading Remarks]
      
The buffer is invalidated by any vector operation that would also invalidate iterators. 




[endsect]



[section:overload25 buffer (25 of 36 overloads)]


Create a new non-modifiable buffer that represents the given POD vector. 


  template<
      typename PodType,
      typename Allocator>
  const_buffer buffer(
      const std::vector< PodType, Allocator > & data);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.size() ? &data[0] : 0,
       data.size() * sizeof(PodType)); 





[heading Remarks]
      
The buffer is invalidated by any vector operation that would also invalidate iterators. 




[endsect]



[section:overload26 buffer (26 of 36 overloads)]


Create a new non-modifiable buffer that represents the given POD vector. 


  template<
      typename PodType,
      typename Allocator>
  const_buffer buffer(
      const std::vector< PodType, Allocator > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.size() ? &data[0] : 0,
       min(data.size() * sizeof(PodType), max_size_in_bytes)); 





[heading Remarks]
      
The buffer is invalidated by any vector operation that would also invalidate iterators. 




[endsect]



[section:overload27 buffer (27 of 36 overloads)]


Create a new modifiable buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  mutable_buffer buffer(
      std::basic_string< Elem, Traits, Allocator > & data);



[heading Return Value]
      
`mutable_buffer(data.size() ? &data[0] : 0, data.size() * sizeof(Elem))`.


[heading Remarks]
      
The buffer is invalidated by any non-const operation called on the given string object. 




[endsect]



[section:overload28 buffer (28 of 36 overloads)]


Create a new modifiable buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  mutable_buffer buffer(
      std::basic_string< Elem, Traits, Allocator > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.size() ? &data[0] : 0,
       min(data.size() * sizeof(Elem), max_size_in_bytes)); 





[heading Remarks]
      
The buffer is invalidated by any non-const operation called on the given string object. 




[endsect]



[section:overload29 buffer (29 of 36 overloads)]


Create a new non-modifiable buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  const_buffer buffer(
      const std::basic_string< Elem, Traits, Allocator > & data);



[heading Return Value]
      
`const_buffer(data.data(), data.size() * sizeof(Elem))`.


[heading Remarks]
      
The buffer is invalidated by any non-const operation called on the given string object. 




[endsect]



[section:overload30 buffer (30 of 36 overloads)]


Create a new non-modifiable buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  const_buffer buffer(
      const std::basic_string< Elem, Traits, Allocator > & data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.const_buffer `const_buffer`] value equivalent to: 

   const_buffer(
       data.data(),
       min(data.size() * sizeof(Elem), max_size_in_bytes)); 





[heading Remarks]
      
The buffer is invalidated by any non-const operation called on the given string object. 




[endsect]



[section:overload31 buffer (31 of 36 overloads)]


Create a new modifiable buffer that represents the given string\_view. 


  template<
      typename Elem,
      typename Traits>
  const_buffer buffer(
      basic_string_view< Elem, Traits > data);



[heading Return Value]
      
`mutable_buffer(data.size() ? &data[0] : 0, data.size() * sizeof(Elem))`. 




[endsect]



[section:overload32 buffer (32 of 36 overloads)]


Create a new non-modifiable buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits>
  const_buffer buffer(
      basic_string_view< Elem, Traits > data,
      std::size_t max_size_in_bytes);



[heading Return Value]
      
A [link boost_asio.reference.mutable_buffer `mutable_buffer`] value equivalent to: 

   mutable_buffer(
       data.size() ? &data[0] : 0,
       min(data.size() * sizeof(Elem), max_size_in_bytes)); 







[endsect]



[section:overload33 buffer (33 of 36 overloads)]


Obtain a buffer representing the entire registered buffer. 


  mutable_registered_buffer buffer(
      const mutable_registered_buffer & b);



[endsect]



[section:overload34 buffer (34 of 36 overloads)]


Obtain a buffer representing the entire registered buffer. 


  const_registered_buffer buffer(
      const const_registered_buffer & b);



[endsect]



[section:overload35 buffer (35 of 36 overloads)]


Obtain a buffer representing part of a registered buffer. 


  mutable_registered_buffer buffer(
      const mutable_registered_buffer & b,
      std::size_t n);



[endsect]



[section:overload36 buffer (36 of 36 overloads)]


Obtain a buffer representing part of a registered buffer. 


  const_registered_buffer buffer(
      const const_registered_buffer & b,
      std::size_t n);



[endsect]


[endsect]

[section:buffer_cast buffer_cast]

[indexterm1 boost_asio.indexterm.buffer_cast..buffer_cast] 
(Deprecated: Use the `data()` member function.) The `boost::asio::buffer_cast` function is used to obtain a pointer to the underlying memory region associated with a buffer. 


Cast a non-modifiable buffer to a specified pointer to POD type. 

  template<
      typename PointerToPodType>
  PointerToPodType ``[link boost_asio.reference.buffer_cast.overload1 buffer_cast]``(
      const mutable_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_cast.overload1 more...]]``

  template<
      typename PointerToPodType>
  PointerToPodType ``[link boost_asio.reference.buffer_cast.overload2 buffer_cast]``(
      const const_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_cast.overload2 more...]]``


[heading Examples:]
  


To access the memory of a non-modifiable buffer, use: 

   boost::asio::const_buffer b1 = ...;
   const unsigned char* p1 = boost::asio::buffer_cast<const unsigned char*>(b1);




To access the memory of a modifiable buffer, use: 

   boost::asio::mutable_buffer b2 = ...;
   unsigned char* p2 = boost::asio::buffer_cast<unsigned char*>(b2);




The `boost::asio::buffer_cast` function permits violations of type safety, so uses of it in application code should be carefully considered. 

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 buffer_cast (1 of 2 overloads)]


Cast a non-modifiable buffer to a specified pointer to POD type. 


  template<
      typename PointerToPodType>
  PointerToPodType buffer_cast(
      const mutable_buffer & b);



[endsect]



[section:overload2 buffer_cast (2 of 2 overloads)]


Cast a non-modifiable buffer to a specified pointer to POD type. 


  template<
      typename PointerToPodType>
  PointerToPodType buffer_cast(
      const const_buffer & b);



[endsect]


[endsect]

[section:buffer_copy buffer_copy]

[indexterm1 boost_asio.indexterm.buffer_copy..buffer_copy] 
The `boost::asio::buffer_copy` function is used to copy bytes from a source buffer (or buffer sequence) to a target buffer (or buffer sequence). 


Copies bytes from a source buffer sequence to a target buffer sequence. 

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffer_copy.overload1 buffer_copy]``(
      const MutableBufferSequence & target,
      const ConstBufferSequence & source);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_copy.overload1 more...]]``

Copies a limited number of bytes from a source buffer sequence to a target buffer sequence. 

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffer_copy.overload2 buffer_copy]``(
      const MutableBufferSequence & target,
      const ConstBufferSequence & source,
      std::size_t max_bytes_to_copy);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_copy.overload2 more...]]``

The `buffer_copy` function is available in two forms:


* A 2-argument form: `buffer_copy(target, source)` 


* A 3-argument form: `buffer_copy(target, source, max_bytes_to_copy)` 

Both forms return the number of bytes actually copied. The number of bytes copied is the lesser of:


* `buffer_size(target)` 


* `buffer_size(source)` 


* `If` specified, `max_bytes_to_copy`.

This prevents buffer overflow, regardless of the buffer sizes used in the copy operation.

Note that [link boost_asio.reference.buffer_copy `buffer_copy`]  is implemented in terms of `memcpy`, and consequently it cannot be used to copy between overlapping memory regions. 

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 buffer_copy (1 of 2 overloads)]


Copies bytes from a source buffer sequence to a target buffer sequence. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t buffer_copy(
      const MutableBufferSequence & target,
      const ConstBufferSequence & source);



[heading Parameters]
    

[variablelist
  
[[target][A modifiable buffer sequence representing the memory regions to which the bytes will be copied.]]

[[source][A non-modifiable buffer sequence representing the memory regions from which the bytes will be copied.]]

]


[heading Return Value]
      
The number of bytes copied.


[heading Remarks]
      
The number of bytes copied is the lesser of:


* `buffer_size(target)` 


* `buffer_size(source)` 

This function is implemented in terms of `memcpy`, and consequently it cannot be used to copy between overlapping memory regions. 


[endsect]



[section:overload2 buffer_copy (2 of 2 overloads)]


Copies a limited number of bytes from a source buffer sequence to a target buffer sequence. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t buffer_copy(
      const MutableBufferSequence & target,
      const ConstBufferSequence & source,
      std::size_t max_bytes_to_copy);



[heading Parameters]
    

[variablelist
  
[[target][A modifiable buffer sequence representing the memory regions to which the bytes will be copied.]]

[[source][A non-modifiable buffer sequence representing the memory regions from which the bytes will be copied.]]

[[max_bytes_to_copy][The maximum number of bytes to be copied.]]

]


[heading Return Value]
      
The number of bytes copied.


[heading Remarks]
      
The number of bytes copied is the lesser of:


* `buffer_size(target)` 


* `buffer_size(source)` 


* `max_bytes_to_copy` 

This function is implemented in terms of `memcpy`, and consequently it cannot be used to copy between overlapping memory regions. 


[endsect]


[endsect]

[section:buffer_registration buffer_registration]

[indexterm1 boost_asio.indexterm.buffer_registration..buffer_registration]


Automatically registers and unregistered buffers with an execution context. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename Allocator = std::allocator<void>>
  class buffer_registration


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.buffer_registration.allocator_type [*allocator_type]]]
    [The allocator type used for allocating storage for the buffers container. ]
  
  ]

  [

    [[link boost_asio.reference.buffer_registration.const_iterator [*const_iterator]]]
    [The type of a const iterator over the registered buffers. ]
  
  ]

  [

    [[link boost_asio.reference.buffer_registration.iterator [*iterator]]]
    [The type of an iterator over the registered buffers. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.buffer_registration.at [*at]]]
    [Get the buffer at the specified index. ]
  ]
  
  [
    [[link boost_asio.reference.buffer_registration.begin [*begin]]]
    [Get the begin iterator for the sequence of registered buffers. ]
  ]
  
  [
    [[link boost_asio.reference.buffer_registration.buffer_registration [*buffer_registration]] [constructor]]
    [Register buffers with an executor's execution context. 
     [hr]
     Register buffers with an execution context. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.buffer_registration.cbegin [*cbegin]]]
    [Get the begin iterator for the sequence of registered buffers. ]
  ]
  
  [
    [[link boost_asio.reference.buffer_registration.cend [*cend]]]
    [Get the end iterator for the sequence of registered buffers. ]
  ]
  
  [
    [[link boost_asio.reference.buffer_registration.end [*end]]]
    [Get the end iterator for the sequence of registered buffers. ]
  ]
  
  [
    [[link boost_asio.reference.buffer_registration.operator_eq_ [*operator=]]]
    [Move assignment. ]
  ]
  
  [
    [[link boost_asio.reference.buffer_registration.operator_lb__rb_ [*operator\[\]]]]
    [Get the buffer at the specified index. ]
  ]
  
  [
    [[link boost_asio.reference.buffer_registration.size [*size]]]
    [Get the number of registered buffers. ]
  ]
  
  [
    [[link boost_asio.reference.buffer_registration._buffer_registration [*~buffer_registration]] [destructor]]
    [Unregisters the buffers. ]
  ]
  
]

For portability, applications should assume that only one registration is permitted per execution context. 

[heading Requirements]

['Header: ][^boost/asio/buffer_registration.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:allocator_type buffer_registration::allocator_type]

[indexterm2 boost_asio.indexterm.buffer_registration.allocator_type..allocator_type..buffer_registration] 
The allocator type used for allocating storage for the buffers container. 


  typedef Allocator allocator_type;



[heading Requirements]

['Header: ][^boost/asio/buffer_registration.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:at buffer_registration::at]

[indexterm2 boost_asio.indexterm.buffer_registration.at..at..buffer_registration] 
Get the buffer at the specified index. 


  const mutable_registered_buffer & at(
      std::size_t i);



[endsect]



[section:begin buffer_registration::begin]

[indexterm2 boost_asio.indexterm.buffer_registration.begin..begin..buffer_registration] 
Get the begin iterator for the sequence of registered buffers. 


  const_iterator begin() const;



[endsect]


[section:buffer_registration buffer_registration::buffer_registration]

[indexterm2 boost_asio.indexterm.buffer_registration.buffer_registration..buffer_registration..buffer_registration] 
Register buffers with an executor's execution context. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  ``[link boost_asio.reference.buffer_registration.buffer_registration.overload1 buffer_registration]``(
      const Executor & ex,
      const MutableBufferSequence & buffer_sequence,
      const allocator_type & alloc = allocator_type(),
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_registration.buffer_registration.overload1 more...]]``


Register buffers with an execution context. 


  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.buffer_registration.buffer_registration.overload2 buffer_registration]``(
      ExecutionContext & ctx,
      const MutableBufferSequence & buffer_sequence,
      const allocator_type & alloc = allocator_type(),
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_registration.buffer_registration.overload2 more...]]``


Move constructor. 


  ``[link boost_asio.reference.buffer_registration.buffer_registration.overload3 buffer_registration]``(
      buffer_registration && other);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_registration.buffer_registration.overload3 more...]]``


[section:overload1 buffer_registration::buffer_registration (1 of 3 overloads)]


Register buffers with an executor's execution context. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  buffer_registration(
      const Executor & ex,
      const MutableBufferSequence & buffer_sequence,
      const allocator_type & alloc = allocator_type(),
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);



[endsect]



[section:overload2 buffer_registration::buffer_registration (2 of 3 overloads)]


Register buffers with an execution context. 


  template<
      typename ExecutionContext>
  buffer_registration(
      ExecutionContext & ctx,
      const MutableBufferSequence & buffer_sequence,
      const allocator_type & alloc = allocator_type(),
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[endsect]



[section:overload3 buffer_registration::buffer_registration (3 of 3 overloads)]


Move constructor. 


  buffer_registration(
      buffer_registration && other);



[endsect]


[endsect]


[section:cbegin buffer_registration::cbegin]

[indexterm2 boost_asio.indexterm.buffer_registration.cbegin..cbegin..buffer_registration] 
Get the begin iterator for the sequence of registered buffers. 


  const_iterator cbegin() const;



[endsect]



[section:cend buffer_registration::cend]

[indexterm2 boost_asio.indexterm.buffer_registration.cend..cend..buffer_registration] 
Get the end iterator for the sequence of registered buffers. 


  const_iterator cend() const;



[endsect]



[section:const_iterator buffer_registration::const_iterator]

[indexterm2 boost_asio.indexterm.buffer_registration.const_iterator..const_iterator..buffer_registration] 
The type of a const iterator over the registered buffers. 


  typedef unspecified const_iterator;



[heading Requirements]

['Header: ][^boost/asio/buffer_registration.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:end buffer_registration::end]

[indexterm2 boost_asio.indexterm.buffer_registration.end..end..buffer_registration] 
Get the end iterator for the sequence of registered buffers. 


  const_iterator end() const;



[endsect]



[section:iterator buffer_registration::iterator]

[indexterm2 boost_asio.indexterm.buffer_registration.iterator..iterator..buffer_registration] 
The type of an iterator over the registered buffers. 


  typedef unspecified iterator;



[heading Requirements]

['Header: ][^boost/asio/buffer_registration.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ buffer_registration::operator=]

[indexterm2 boost_asio.indexterm.buffer_registration.operator_eq_..operator=..buffer_registration] 
Move assignment. 


  buffer_registration & operator=(
      buffer_registration && other);



[endsect]



[section:operator_lb__rb_ buffer_registration::operator\[\]]

[indexterm2 boost_asio.indexterm.buffer_registration.operator_lb__rb_..operator\[\]..buffer_registration] 
Get the buffer at the specified index. 


  const mutable_registered_buffer & operator[](
      std::size_t i);



[endsect]



[section:size buffer_registration::size]

[indexterm2 boost_asio.indexterm.buffer_registration.size..size..buffer_registration] 
Get the number of registered buffers. 


  std::size_t size() const;



[endsect]



[section:_buffer_registration buffer_registration::~buffer_registration]

[indexterm2 boost_asio.indexterm.buffer_registration._buffer_registration..~buffer_registration..buffer_registration] 
Unregisters the buffers. 


  ~buffer_registration();



[endsect]



[endsect]

[section:buffer_sequence_begin buffer_sequence_begin]

[indexterm1 boost_asio.indexterm.buffer_sequence_begin..buffer_sequence_begin] 
The `boost::asio::buffer_sequence_begin` function returns an iterator pointing to the first element in a buffer sequence. 


Get an iterator to the first element in a buffer sequence. 

  template<
      typename MutableBuffer>
  const mutable_buffer * ``[link boost_asio.reference.buffer_sequence_begin.overload1 buffer_sequence_begin]``(
      const MutableBuffer & b,
      typename constraint< is_convertible< const MutableBuffer *, const mutable_buffer * >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_sequence_begin.overload1 more...]]``

  template<
      typename ConstBuffer>
  const const_buffer * ``[link boost_asio.reference.buffer_sequence_begin.overload2 buffer_sequence_begin]``(
      const ConstBuffer & b,
      typename constraint< is_convertible< const ConstBuffer *, const const_buffer * >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_sequence_begin.overload2 more...]]``

  template<
      typename C>
  auto ``[link boost_asio.reference.buffer_sequence_begin.overload3 buffer_sequence_begin]``(
      C & c,
      typename constraint< !is_convertible< const C *, const mutable_buffer * >::value &&!is_convertible< const C *, const const_buffer * >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_sequence_begin.overload3 more...]]``

  template<
      typename C>
  auto ``[link boost_asio.reference.buffer_sequence_begin.overload4 buffer_sequence_begin]``(
      const C & c,
      typename constraint< !is_convertible< const C *, const mutable_buffer * >::value &&!is_convertible< const C *, const const_buffer * >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_sequence_begin.overload4 more...]]``

Get an iterator to the first element in a buffer sequence. 

  const mutable_buffer * ``[link boost_asio.reference.buffer_sequence_begin.overload5 buffer_sequence_begin]``(
      const mutable_registered_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_sequence_begin.overload5 more...]]``

  const const_buffer * ``[link boost_asio.reference.buffer_sequence_begin.overload6 buffer_sequence_begin]``(
      const const_registered_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_sequence_begin.overload6 more...]]``

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 buffer_sequence_begin (1 of 6 overloads)]


Get an iterator to the first element in a buffer sequence. 


  template<
      typename MutableBuffer>
  const mutable_buffer * buffer_sequence_begin(
      const MutableBuffer & b,
      typename constraint< is_convertible< const MutableBuffer *, const mutable_buffer * >::value >::type  = 0);



[endsect]



[section:overload2 buffer_sequence_begin (2 of 6 overloads)]


Get an iterator to the first element in a buffer sequence. 


  template<
      typename ConstBuffer>
  const const_buffer * buffer_sequence_begin(
      const ConstBuffer & b,
      typename constraint< is_convertible< const ConstBuffer *, const const_buffer * >::value >::type  = 0);



[endsect]



[section:overload3 buffer_sequence_begin (3 of 6 overloads)]


Get an iterator to the first element in a buffer sequence. 


  template<
      typename C>
  auto buffer_sequence_begin(
      C & c,
      typename constraint< !is_convertible< const C *, const mutable_buffer * >::value &&!is_convertible< const C *, const const_buffer * >::value >::type  = 0);



[endsect]



[section:overload4 buffer_sequence_begin (4 of 6 overloads)]


Get an iterator to the first element in a buffer sequence. 


  template<
      typename C>
  auto buffer_sequence_begin(
      const C & c,
      typename constraint< !is_convertible< const C *, const mutable_buffer * >::value &&!is_convertible< const C *, const const_buffer * >::value >::type  = 0);



[endsect]



[section:overload5 buffer_sequence_begin (5 of 6 overloads)]


Get an iterator to the first element in a buffer sequence. 


  const mutable_buffer * buffer_sequence_begin(
      const mutable_registered_buffer & b);



[endsect]



[section:overload6 buffer_sequence_begin (6 of 6 overloads)]


Get an iterator to the first element in a buffer sequence. 


  const const_buffer * buffer_sequence_begin(
      const const_registered_buffer & b);



[endsect]


[endsect]

[section:buffer_sequence_end buffer_sequence_end]

[indexterm1 boost_asio.indexterm.buffer_sequence_end..buffer_sequence_end] 
The `boost::asio::buffer_sequence_end` function returns an iterator pointing to one past the end element in a buffer sequence. 


Get an iterator to one past the end element in a buffer sequence. 

  template<
      typename MutableBuffer>
  const mutable_buffer * ``[link boost_asio.reference.buffer_sequence_end.overload1 buffer_sequence_end]``(
      const MutableBuffer & b,
      typename constraint< is_convertible< const MutableBuffer *, const mutable_buffer * >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_sequence_end.overload1 more...]]``

  template<
      typename ConstBuffer>
  const const_buffer * ``[link boost_asio.reference.buffer_sequence_end.overload2 buffer_sequence_end]``(
      const ConstBuffer & b,
      typename constraint< is_convertible< const ConstBuffer *, const const_buffer * >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_sequence_end.overload2 more...]]``

  template<
      typename C>
  auto ``[link boost_asio.reference.buffer_sequence_end.overload3 buffer_sequence_end]``(
      C & c,
      typename constraint< !is_convertible< const C *, const mutable_buffer * >::value &&!is_convertible< const C *, const const_buffer * >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_sequence_end.overload3 more...]]``

  template<
      typename C>
  auto ``[link boost_asio.reference.buffer_sequence_end.overload4 buffer_sequence_end]``(
      const C & c,
      typename constraint< !is_convertible< const C *, const mutable_buffer * >::value &&!is_convertible< const C *, const const_buffer * >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_sequence_end.overload4 more...]]``

Get an iterator to one past the end element in a buffer sequence. 

  const mutable_buffer * ``[link boost_asio.reference.buffer_sequence_end.overload5 buffer_sequence_end]``(
      const mutable_registered_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_sequence_end.overload5 more...]]``

  const const_buffer * ``[link boost_asio.reference.buffer_sequence_end.overload6 buffer_sequence_end]``(
      const const_registered_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.buffer_sequence_end.overload6 more...]]``

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 buffer_sequence_end (1 of 6 overloads)]


Get an iterator to one past the end element in a buffer sequence. 


  template<
      typename MutableBuffer>
  const mutable_buffer * buffer_sequence_end(
      const MutableBuffer & b,
      typename constraint< is_convertible< const MutableBuffer *, const mutable_buffer * >::value >::type  = 0);



[endsect]



[section:overload2 buffer_sequence_end (2 of 6 overloads)]


Get an iterator to one past the end element in a buffer sequence. 


  template<
      typename ConstBuffer>
  const const_buffer * buffer_sequence_end(
      const ConstBuffer & b,
      typename constraint< is_convertible< const ConstBuffer *, const const_buffer * >::value >::type  = 0);



[endsect]



[section:overload3 buffer_sequence_end (3 of 6 overloads)]


Get an iterator to one past the end element in a buffer sequence. 


  template<
      typename C>
  auto buffer_sequence_end(
      C & c,
      typename constraint< !is_convertible< const C *, const mutable_buffer * >::value &&!is_convertible< const C *, const const_buffer * >::value >::type  = 0);



[endsect]



[section:overload4 buffer_sequence_end (4 of 6 overloads)]


Get an iterator to one past the end element in a buffer sequence. 


  template<
      typename C>
  auto buffer_sequence_end(
      const C & c,
      typename constraint< !is_convertible< const C *, const mutable_buffer * >::value &&!is_convertible< const C *, const const_buffer * >::value >::type  = 0);



[endsect]



[section:overload5 buffer_sequence_end (5 of 6 overloads)]


Get an iterator to one past the end element in a buffer sequence. 


  const mutable_buffer * buffer_sequence_end(
      const mutable_registered_buffer & b);



[endsect]



[section:overload6 buffer_sequence_end (6 of 6 overloads)]


Get an iterator to one past the end element in a buffer sequence. 


  const const_buffer * buffer_sequence_end(
      const const_registered_buffer & b);



[endsect]


[endsect]


[section:buffer_size buffer_size]

[indexterm1 boost_asio.indexterm.buffer_size..buffer_size] 
Get the total number of bytes in a buffer sequence. 


  template<
      typename BufferSequence>
  std::size_t buffer_size(
      const BufferSequence & b);


The `buffer_size` function determines the total size of all buffers in the buffer sequence, as if computed as follows:



   size_t total_size = 0;
   auto i = boost::asio::buffer_sequence_begin(buffers);
   auto end = boost::asio::buffer_sequence_end(buffers);
   for (; i != end; ++i)
   {
     const_buffer b(*i);
     total_size += b.size();
   }
   return total_size; 




The `BufferSequence` template parameter may meet either of the `ConstBufferSequence` or `MutableBufferSequence` type requirements. 

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:buffered_read_stream buffered_read_stream]

[indexterm1 boost_asio.indexterm.buffered_read_stream..buffered_read_stream]


Adds buffering to the read-related operations of a stream. 


  template<
      typename Stream>
  class buffered_read_stream :
    noncopyable


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.buffered_read_stream.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.buffered_read_stream.lowest_layer_type [*lowest_layer_type]]]
    [The type of the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.buffered_read_stream.next_layer_type [*next_layer_type]]]
    [The type of the next layer. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.buffered_read_stream.async_fill [*async_fill]]]
    [Start an asynchronous fill. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_read_stream.async_read_some [*async_read_some]]]
    [Start an asynchronous read. The buffer into which the data will be read must be valid for the lifetime of the asynchronous operation. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_read_stream.async_write_some [*async_write_some]]]
    [Start an asynchronous write. The data being written must be valid for the lifetime of the asynchronous operation. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_read_stream.buffered_read_stream [*buffered_read_stream]] [constructor]]
    [Construct, passing the specified argument to initialise the next layer. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_read_stream.close [*close]]]
    [Close the stream. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_read_stream.fill [*fill]]]
    [Fill the buffer with some data. Returns the number of bytes placed in the buffer as a result of the operation. Throws an exception on failure. 
     [hr]
     Fill the buffer with some data. Returns the number of bytes placed in the buffer as a result of the operation, or 0 if an error occurred. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_read_stream.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_read_stream.in_avail [*in_avail]]]
    [Determine the amount of data that may be read without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_read_stream.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_read_stream.next_layer [*next_layer]]]
    [Get a reference to the next layer. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_read_stream.peek [*peek]]]
    [Peek at the incoming data on the stream. Returns the number of bytes read. Throws an exception on failure. 
     [hr]
     Peek at the incoming data on the stream. Returns the number of bytes read, or 0 if an error occurred. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_read_stream.read_some [*read_some]]]
    [Read some data from the stream. Returns the number of bytes read. Throws an exception on failure. 
     [hr]
     Read some data from the stream. Returns the number of bytes read or 0 if an error occurred. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_read_stream.write_some [*write_some]]]
    [Write the given data to the stream. Returns the number of bytes written. Throws an exception on failure. 
     [hr]
     Write the given data to the stream. Returns the number of bytes written, or 0 if an error occurred. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.buffered_read_stream.default_buffer_size [*default_buffer_size]] [static]]
    [The default buffer size. ]
  ]

]

The [link boost_asio.reference.buffered_read_stream `buffered_read_stream`] class template can be used to add buffering to the synchronous and asynchronous read operations of a stream.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.




[heading Requirements]

['Header: ][^boost/asio/buffered_read_stream.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:async_fill buffered_read_stream::async_fill]

[indexterm2 boost_asio.indexterm.buffered_read_stream.async_fill..async_fill..buffered_read_stream] 
Start an asynchronous fill. 


  template<
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_fill(
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);



[endsect]



[section:async_read_some buffered_read_stream::async_read_some]

[indexterm2 boost_asio.indexterm.buffered_read_stream.async_read_some..async_read_some..buffered_read_stream] 
Start an asynchronous read. The buffer into which the data will be read must be valid for the lifetime of the asynchronous operation. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_some(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);



[endsect]



[section:async_write_some buffered_read_stream::async_write_some]

[indexterm2 boost_asio.indexterm.buffered_read_stream.async_write_some..async_write_some..buffered_read_stream] 
Start an asynchronous write. The data being written must be valid for the lifetime of the asynchronous operation. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_some(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);



[endsect]


[section:buffered_read_stream buffered_read_stream::buffered_read_stream]

[indexterm2 boost_asio.indexterm.buffered_read_stream.buffered_read_stream..buffered_read_stream..buffered_read_stream] 
Construct, passing the specified argument to initialise the next layer. 


  template<
      typename Arg>
  explicit ``[link boost_asio.reference.buffered_read_stream.buffered_read_stream.overload1 buffered_read_stream]``(
      Arg & a);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.buffered_read_stream.overload1 more...]]``

  template<
      typename Arg>
  ``[link boost_asio.reference.buffered_read_stream.buffered_read_stream.overload2 buffered_read_stream]``(
      Arg & a,
      std::size_t buffer_size);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.buffered_read_stream.overload2 more...]]``


[section:overload1 buffered_read_stream::buffered_read_stream (1 of 2 overloads)]


Construct, passing the specified argument to initialise the next layer. 


  template<
      typename Arg>
  buffered_read_stream(
      Arg & a);



[endsect]



[section:overload2 buffered_read_stream::buffered_read_stream (2 of 2 overloads)]


Construct, passing the specified argument to initialise the next layer. 


  template<
      typename Arg>
  buffered_read_stream(
      Arg & a,
      std::size_t buffer_size);



[endsect]


[endsect]

[section:close buffered_read_stream::close]

[indexterm2 boost_asio.indexterm.buffered_read_stream.close..close..buffered_read_stream] 
Close the stream. 


  void ``[link boost_asio.reference.buffered_read_stream.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.close.overload1 more...]]``

  void ``[link boost_asio.reference.buffered_read_stream.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.close.overload2 more...]]``


[section:overload1 buffered_read_stream::close (1 of 2 overloads)]


Close the stream. 


  void close();



[endsect]



[section:overload2 buffered_read_stream::close (2 of 2 overloads)]


Close the stream. 


  void close(
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:default_buffer_size buffered_read_stream::default_buffer_size]

[indexterm2 boost_asio.indexterm.buffered_read_stream.default_buffer_size..default_buffer_size..buffered_read_stream] 
The default buffer size. 


  static const std::size_t default_buffer_size = implementation_defined;



[endsect]



[section:executor_type buffered_read_stream::executor_type]

[indexterm2 boost_asio.indexterm.buffered_read_stream.executor_type..executor_type..buffered_read_stream] 
The type of the executor associated with the object. 


  typedef lowest_layer_type::executor_type executor_type;



[heading Requirements]

['Header: ][^boost/asio/buffered_read_stream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:fill buffered_read_stream::fill]

[indexterm2 boost_asio.indexterm.buffered_read_stream.fill..fill..buffered_read_stream] 
Fill the buffer with some data. Returns the number of bytes placed in the buffer as a result of the operation. Throws an exception on failure. 


  std::size_t ``[link boost_asio.reference.buffered_read_stream.fill.overload1 fill]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.fill.overload1 more...]]``


Fill the buffer with some data. Returns the number of bytes placed in the buffer as a result of the operation, or 0 if an error occurred. 


  std::size_t ``[link boost_asio.reference.buffered_read_stream.fill.overload2 fill]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.fill.overload2 more...]]``


[section:overload1 buffered_read_stream::fill (1 of 2 overloads)]


Fill the buffer with some data. Returns the number of bytes placed in the buffer as a result of the operation. Throws an exception on failure. 


  std::size_t fill();



[endsect]



[section:overload2 buffered_read_stream::fill (2 of 2 overloads)]


Fill the buffer with some data. Returns the number of bytes placed in the buffer as a result of the operation, or 0 if an error occurred. 


  std::size_t fill(
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:get_executor buffered_read_stream::get_executor]

[indexterm2 boost_asio.indexterm.buffered_read_stream.get_executor..get_executor..buffered_read_stream] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:in_avail buffered_read_stream::in_avail]

[indexterm2 boost_asio.indexterm.buffered_read_stream.in_avail..in_avail..buffered_read_stream] 
Determine the amount of data that may be read without blocking. 


  std::size_t ``[link boost_asio.reference.buffered_read_stream.in_avail.overload1 in_avail]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.in_avail.overload1 more...]]``

  std::size_t ``[link boost_asio.reference.buffered_read_stream.in_avail.overload2 in_avail]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.in_avail.overload2 more...]]``


[section:overload1 buffered_read_stream::in_avail (1 of 2 overloads)]


Determine the amount of data that may be read without blocking. 


  std::size_t in_avail();



[endsect]



[section:overload2 buffered_read_stream::in_avail (2 of 2 overloads)]


Determine the amount of data that may be read without blocking. 


  std::size_t in_avail(
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:lowest_layer buffered_read_stream::lowest_layer]

[indexterm2 boost_asio.indexterm.buffered_read_stream.lowest_layer..lowest_layer..buffered_read_stream] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.buffered_read_stream.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.buffered_read_stream.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.lowest_layer.overload2 more...]]``


[section:overload1 buffered_read_stream::lowest_layer (1 of 2 overloads)]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();



[endsect]



[section:overload2 buffered_read_stream::lowest_layer (2 of 2 overloads)]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;



[endsect]


[endsect]


[section:lowest_layer_type buffered_read_stream::lowest_layer_type]

[indexterm2 boost_asio.indexterm.buffered_read_stream.lowest_layer_type..lowest_layer_type..buffered_read_stream] 
The type of the lowest layer. 


  typedef next_layer_type::lowest_layer_type lowest_layer_type;



[heading Requirements]

['Header: ][^boost/asio/buffered_read_stream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:next_layer buffered_read_stream::next_layer]

[indexterm2 boost_asio.indexterm.buffered_read_stream.next_layer..next_layer..buffered_read_stream] 
Get a reference to the next layer. 


  next_layer_type & next_layer();



[endsect]



[section:next_layer_type buffered_read_stream::next_layer_type]

[indexterm2 boost_asio.indexterm.buffered_read_stream.next_layer_type..next_layer_type..buffered_read_stream] 
The type of the next layer. 


  typedef remove_reference< Stream >::type next_layer_type;



[heading Requirements]

['Header: ][^boost/asio/buffered_read_stream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:peek buffered_read_stream::peek]

[indexterm2 boost_asio.indexterm.buffered_read_stream.peek..peek..buffered_read_stream] 
Peek at the incoming data on the stream. Returns the number of bytes read. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_read_stream.peek.overload1 peek]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.peek.overload1 more...]]``


Peek at the incoming data on the stream. Returns the number of bytes read, or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_read_stream.peek.overload2 peek]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.peek.overload2 more...]]``


[section:overload1 buffered_read_stream::peek (1 of 2 overloads)]


Peek at the incoming data on the stream. Returns the number of bytes read. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t peek(
      const MutableBufferSequence & buffers);



[endsect]



[section:overload2 buffered_read_stream::peek (2 of 2 overloads)]


Peek at the incoming data on the stream. Returns the number of bytes read, or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t peek(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:read_some buffered_read_stream::read_some]

[indexterm2 boost_asio.indexterm.buffered_read_stream.read_some..read_some..buffered_read_stream] 
Read some data from the stream. Returns the number of bytes read. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_read_stream.read_some.overload1 read_some]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.read_some.overload1 more...]]``


Read some data from the stream. Returns the number of bytes read or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_read_stream.read_some.overload2 read_some]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.read_some.overload2 more...]]``


[section:overload1 buffered_read_stream::read_some (1 of 2 overloads)]


Read some data from the stream. Returns the number of bytes read. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers);



[endsect]



[section:overload2 buffered_read_stream::read_some (2 of 2 overloads)]


Read some data from the stream. Returns the number of bytes read or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:write_some buffered_read_stream::write_some]

[indexterm2 boost_asio.indexterm.buffered_read_stream.write_some..write_some..buffered_read_stream] 
Write the given data to the stream. Returns the number of bytes written. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_read_stream.write_some.overload1 write_some]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.write_some.overload1 more...]]``


Write the given data to the stream. Returns the number of bytes written, or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_read_stream.write_some.overload2 write_some]``(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_read_stream.write_some.overload2 more...]]``


[section:overload1 buffered_read_stream::write_some (1 of 2 overloads)]


Write the given data to the stream. Returns the number of bytes written. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers);



[endsect]



[section:overload2 buffered_read_stream::write_some (2 of 2 overloads)]


Write the given data to the stream. Returns the number of bytes written, or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);



[endsect]


[endsect]


[endsect]

[section:buffered_stream buffered_stream]

[indexterm1 boost_asio.indexterm.buffered_stream..buffered_stream]


Adds buffering to the read- and write-related operations of a stream. 


  template<
      typename Stream>
  class buffered_stream :
    noncopyable


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.buffered_stream.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.buffered_stream.lowest_layer_type [*lowest_layer_type]]]
    [The type of the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.buffered_stream.next_layer_type [*next_layer_type]]]
    [The type of the next layer. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.buffered_stream.async_fill [*async_fill]]]
    [Start an asynchronous fill. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.async_flush [*async_flush]]]
    [Start an asynchronous flush. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.async_read_some [*async_read_some]]]
    [Start an asynchronous read. The buffer into which the data will be read must be valid for the lifetime of the asynchronous operation. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.async_write_some [*async_write_some]]]
    [Start an asynchronous write. The data being written must be valid for the lifetime of the asynchronous operation. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.buffered_stream [*buffered_stream]] [constructor]]
    [Construct, passing the specified argument to initialise the next layer. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.close [*close]]]
    [Close the stream. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.fill [*fill]]]
    [Fill the buffer with some data. Returns the number of bytes placed in the buffer as a result of the operation. Throws an exception on failure. 
     [hr]
     Fill the buffer with some data. Returns the number of bytes placed in the buffer as a result of the operation, or 0 if an error occurred. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.flush [*flush]]]
    [Flush all data from the buffer to the next layer. Returns the number of bytes written to the next layer on the last write operation. Throws an exception on failure. 
     [hr]
     Flush all data from the buffer to the next layer. Returns the number of bytes written to the next layer on the last write operation, or 0 if an error occurred. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.in_avail [*in_avail]]]
    [Determine the amount of data that may be read without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.next_layer [*next_layer]]]
    [Get a reference to the next layer. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.peek [*peek]]]
    [Peek at the incoming data on the stream. Returns the number of bytes read. Throws an exception on failure. 
     [hr]
     Peek at the incoming data on the stream. Returns the number of bytes read, or 0 if an error occurred. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.read_some [*read_some]]]
    [Read some data from the stream. Returns the number of bytes read. Throws an exception on failure. 
     [hr]
     Read some data from the stream. Returns the number of bytes read or 0 if an error occurred. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_stream.write_some [*write_some]]]
    [Write the given data to the stream. Returns the number of bytes written. Throws an exception on failure. 
     [hr]
     Write the given data to the stream. Returns the number of bytes written, or 0 if an error occurred. ]
  ]
  
]

The [link boost_asio.reference.buffered_stream `buffered_stream`] class template can be used to add buffering to the synchronous and asynchronous read and write operations of a stream.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.




[heading Requirements]

['Header: ][^boost/asio/buffered_stream.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:async_fill buffered_stream::async_fill]

[indexterm2 boost_asio.indexterm.buffered_stream.async_fill..async_fill..buffered_stream] 
Start an asynchronous fill. 


  template<
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_fill(
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);



[endsect]



[section:async_flush buffered_stream::async_flush]

[indexterm2 boost_asio.indexterm.buffered_stream.async_flush..async_flush..buffered_stream] 
Start an asynchronous flush. 


  template<
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_flush(
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);



[endsect]



[section:async_read_some buffered_stream::async_read_some]

[indexterm2 boost_asio.indexterm.buffered_stream.async_read_some..async_read_some..buffered_stream] 
Start an asynchronous read. The buffer into which the data will be read must be valid for the lifetime of the asynchronous operation. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_some(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);



[endsect]



[section:async_write_some buffered_stream::async_write_some]

[indexterm2 boost_asio.indexterm.buffered_stream.async_write_some..async_write_some..buffered_stream] 
Start an asynchronous write. The data being written must be valid for the lifetime of the asynchronous operation. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_some(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);



[endsect]


[section:buffered_stream buffered_stream::buffered_stream]

[indexterm2 boost_asio.indexterm.buffered_stream.buffered_stream..buffered_stream..buffered_stream] 
Construct, passing the specified argument to initialise the next layer. 


  template<
      typename Arg>
  explicit ``[link boost_asio.reference.buffered_stream.buffered_stream.overload1 buffered_stream]``(
      Arg & a);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.buffered_stream.overload1 more...]]``

  template<
      typename Arg>
  explicit ``[link boost_asio.reference.buffered_stream.buffered_stream.overload2 buffered_stream]``(
      Arg & a,
      std::size_t read_buffer_size,
      std::size_t write_buffer_size);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.buffered_stream.overload2 more...]]``


[section:overload1 buffered_stream::buffered_stream (1 of 2 overloads)]


Construct, passing the specified argument to initialise the next layer. 


  template<
      typename Arg>
  buffered_stream(
      Arg & a);



[endsect]



[section:overload2 buffered_stream::buffered_stream (2 of 2 overloads)]


Construct, passing the specified argument to initialise the next layer. 


  template<
      typename Arg>
  buffered_stream(
      Arg & a,
      std::size_t read_buffer_size,
      std::size_t write_buffer_size);



[endsect]


[endsect]

[section:close buffered_stream::close]

[indexterm2 boost_asio.indexterm.buffered_stream.close..close..buffered_stream] 
Close the stream. 


  void ``[link boost_asio.reference.buffered_stream.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.close.overload1 more...]]``

  void ``[link boost_asio.reference.buffered_stream.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.close.overload2 more...]]``


[section:overload1 buffered_stream::close (1 of 2 overloads)]


Close the stream. 


  void close();



[endsect]



[section:overload2 buffered_stream::close (2 of 2 overloads)]


Close the stream. 


  void close(
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:executor_type buffered_stream::executor_type]

[indexterm2 boost_asio.indexterm.buffered_stream.executor_type..executor_type..buffered_stream] 
The type of the executor associated with the object. 


  typedef lowest_layer_type::executor_type executor_type;



[heading Requirements]

['Header: ][^boost/asio/buffered_stream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:fill buffered_stream::fill]

[indexterm2 boost_asio.indexterm.buffered_stream.fill..fill..buffered_stream] 
Fill the buffer with some data. Returns the number of bytes placed in the buffer as a result of the operation. Throws an exception on failure. 


  std::size_t ``[link boost_asio.reference.buffered_stream.fill.overload1 fill]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.fill.overload1 more...]]``


Fill the buffer with some data. Returns the number of bytes placed in the buffer as a result of the operation, or 0 if an error occurred. 


  std::size_t ``[link boost_asio.reference.buffered_stream.fill.overload2 fill]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.fill.overload2 more...]]``


[section:overload1 buffered_stream::fill (1 of 2 overloads)]


Fill the buffer with some data. Returns the number of bytes placed in the buffer as a result of the operation. Throws an exception on failure. 


  std::size_t fill();



[endsect]



[section:overload2 buffered_stream::fill (2 of 2 overloads)]


Fill the buffer with some data. Returns the number of bytes placed in the buffer as a result of the operation, or 0 if an error occurred. 


  std::size_t fill(
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:flush buffered_stream::flush]

[indexterm2 boost_asio.indexterm.buffered_stream.flush..flush..buffered_stream] 
Flush all data from the buffer to the next layer. Returns the number of bytes written to the next layer on the last write operation. Throws an exception on failure. 


  std::size_t ``[link boost_asio.reference.buffered_stream.flush.overload1 flush]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.flush.overload1 more...]]``


Flush all data from the buffer to the next layer. Returns the number of bytes written to the next layer on the last write operation, or 0 if an error occurred. 


  std::size_t ``[link boost_asio.reference.buffered_stream.flush.overload2 flush]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.flush.overload2 more...]]``


[section:overload1 buffered_stream::flush (1 of 2 overloads)]


Flush all data from the buffer to the next layer. Returns the number of bytes written to the next layer on the last write operation. Throws an exception on failure. 


  std::size_t flush();



[endsect]



[section:overload2 buffered_stream::flush (2 of 2 overloads)]


Flush all data from the buffer to the next layer. Returns the number of bytes written to the next layer on the last write operation, or 0 if an error occurred. 


  std::size_t flush(
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:get_executor buffered_stream::get_executor]

[indexterm2 boost_asio.indexterm.buffered_stream.get_executor..get_executor..buffered_stream] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:in_avail buffered_stream::in_avail]

[indexterm2 boost_asio.indexterm.buffered_stream.in_avail..in_avail..buffered_stream] 
Determine the amount of data that may be read without blocking. 


  std::size_t ``[link boost_asio.reference.buffered_stream.in_avail.overload1 in_avail]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.in_avail.overload1 more...]]``

  std::size_t ``[link boost_asio.reference.buffered_stream.in_avail.overload2 in_avail]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.in_avail.overload2 more...]]``


[section:overload1 buffered_stream::in_avail (1 of 2 overloads)]


Determine the amount of data that may be read without blocking. 


  std::size_t in_avail();



[endsect]



[section:overload2 buffered_stream::in_avail (2 of 2 overloads)]


Determine the amount of data that may be read without blocking. 


  std::size_t in_avail(
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:lowest_layer buffered_stream::lowest_layer]

[indexterm2 boost_asio.indexterm.buffered_stream.lowest_layer..lowest_layer..buffered_stream] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.buffered_stream.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.buffered_stream.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.lowest_layer.overload2 more...]]``


[section:overload1 buffered_stream::lowest_layer (1 of 2 overloads)]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();



[endsect]



[section:overload2 buffered_stream::lowest_layer (2 of 2 overloads)]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;



[endsect]


[endsect]


[section:lowest_layer_type buffered_stream::lowest_layer_type]

[indexterm2 boost_asio.indexterm.buffered_stream.lowest_layer_type..lowest_layer_type..buffered_stream] 
The type of the lowest layer. 


  typedef next_layer_type::lowest_layer_type lowest_layer_type;



[heading Requirements]

['Header: ][^boost/asio/buffered_stream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:next_layer buffered_stream::next_layer]

[indexterm2 boost_asio.indexterm.buffered_stream.next_layer..next_layer..buffered_stream] 
Get a reference to the next layer. 


  next_layer_type & next_layer();



[endsect]



[section:next_layer_type buffered_stream::next_layer_type]

[indexterm2 boost_asio.indexterm.buffered_stream.next_layer_type..next_layer_type..buffered_stream] 
The type of the next layer. 


  typedef remove_reference< Stream >::type next_layer_type;



[heading Requirements]

['Header: ][^boost/asio/buffered_stream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:peek buffered_stream::peek]

[indexterm2 boost_asio.indexterm.buffered_stream.peek..peek..buffered_stream] 
Peek at the incoming data on the stream. Returns the number of bytes read. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_stream.peek.overload1 peek]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.peek.overload1 more...]]``


Peek at the incoming data on the stream. Returns the number of bytes read, or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_stream.peek.overload2 peek]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.peek.overload2 more...]]``


[section:overload1 buffered_stream::peek (1 of 2 overloads)]


Peek at the incoming data on the stream. Returns the number of bytes read. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t peek(
      const MutableBufferSequence & buffers);



[endsect]



[section:overload2 buffered_stream::peek (2 of 2 overloads)]


Peek at the incoming data on the stream. Returns the number of bytes read, or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t peek(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:read_some buffered_stream::read_some]

[indexterm2 boost_asio.indexterm.buffered_stream.read_some..read_some..buffered_stream] 
Read some data from the stream. Returns the number of bytes read. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_stream.read_some.overload1 read_some]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.read_some.overload1 more...]]``


Read some data from the stream. Returns the number of bytes read or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_stream.read_some.overload2 read_some]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.read_some.overload2 more...]]``


[section:overload1 buffered_stream::read_some (1 of 2 overloads)]


Read some data from the stream. Returns the number of bytes read. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers);



[endsect]



[section:overload2 buffered_stream::read_some (2 of 2 overloads)]


Read some data from the stream. Returns the number of bytes read or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:write_some buffered_stream::write_some]

[indexterm2 boost_asio.indexterm.buffered_stream.write_some..write_some..buffered_stream] 
Write the given data to the stream. Returns the number of bytes written. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_stream.write_some.overload1 write_some]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.write_some.overload1 more...]]``


Write the given data to the stream. Returns the number of bytes written, or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_stream.write_some.overload2 write_some]``(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_stream.write_some.overload2 more...]]``


[section:overload1 buffered_stream::write_some (1 of 2 overloads)]


Write the given data to the stream. Returns the number of bytes written. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers);



[endsect]



[section:overload2 buffered_stream::write_some (2 of 2 overloads)]


Write the given data to the stream. Returns the number of bytes written, or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);



[endsect]


[endsect]


[endsect]

[section:buffered_write_stream buffered_write_stream]

[indexterm1 boost_asio.indexterm.buffered_write_stream..buffered_write_stream]


Adds buffering to the write-related operations of a stream. 


  template<
      typename Stream>
  class buffered_write_stream :
    noncopyable


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.buffered_write_stream.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.buffered_write_stream.lowest_layer_type [*lowest_layer_type]]]
    [The type of the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.buffered_write_stream.next_layer_type [*next_layer_type]]]
    [The type of the next layer. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.buffered_write_stream.async_flush [*async_flush]]]
    [Start an asynchronous flush. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_write_stream.async_read_some [*async_read_some]]]
    [Start an asynchronous read. The buffer into which the data will be read must be valid for the lifetime of the asynchronous operation. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_write_stream.async_write_some [*async_write_some]]]
    [Start an asynchronous write. The data being written must be valid for the lifetime of the asynchronous operation. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_write_stream.buffered_write_stream [*buffered_write_stream]] [constructor]]
    [Construct, passing the specified argument to initialise the next layer. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_write_stream.close [*close]]]
    [Close the stream. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_write_stream.flush [*flush]]]
    [Flush all data from the buffer to the next layer. Returns the number of bytes written to the next layer on the last write operation. Throws an exception on failure. 
     [hr]
     Flush all data from the buffer to the next layer. Returns the number of bytes written to the next layer on the last write operation, or 0 if an error occurred. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_write_stream.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_write_stream.in_avail [*in_avail]]]
    [Determine the amount of data that may be read without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_write_stream.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_write_stream.next_layer [*next_layer]]]
    [Get a reference to the next layer. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_write_stream.peek [*peek]]]
    [Peek at the incoming data on the stream. Returns the number of bytes read. Throws an exception on failure. 
     [hr]
     Peek at the incoming data on the stream. Returns the number of bytes read, or 0 if an error occurred. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_write_stream.read_some [*read_some]]]
    [Read some data from the stream. Returns the number of bytes read. Throws an exception on failure. 
     [hr]
     Read some data from the stream. Returns the number of bytes read or 0 if an error occurred. ]
  ]
  
  [
    [[link boost_asio.reference.buffered_write_stream.write_some [*write_some]]]
    [Write the given data to the stream. Returns the number of bytes written. Throws an exception on failure. 
     [hr]
     Write the given data to the stream. Returns the number of bytes written, or 0 if an error occurred and the error handler did not throw. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.buffered_write_stream.default_buffer_size [*default_buffer_size]] [static]]
    [The default buffer size. ]
  ]

]

The [link boost_asio.reference.buffered_write_stream `buffered_write_stream`] class template can be used to add buffering to the synchronous and asynchronous write operations of a stream.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.




[heading Requirements]

['Header: ][^boost/asio/buffered_write_stream.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:async_flush buffered_write_stream::async_flush]

[indexterm2 boost_asio.indexterm.buffered_write_stream.async_flush..async_flush..buffered_write_stream] 
Start an asynchronous flush. 


  template<
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_flush(
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);



[endsect]



[section:async_read_some buffered_write_stream::async_read_some]

[indexterm2 boost_asio.indexterm.buffered_write_stream.async_read_some..async_read_some..buffered_write_stream] 
Start an asynchronous read. The buffer into which the data will be read must be valid for the lifetime of the asynchronous operation. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_some(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);



[endsect]



[section:async_write_some buffered_write_stream::async_write_some]

[indexterm2 boost_asio.indexterm.buffered_write_stream.async_write_some..async_write_some..buffered_write_stream] 
Start an asynchronous write. The data being written must be valid for the lifetime of the asynchronous operation. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_some(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);



[endsect]


[section:buffered_write_stream buffered_write_stream::buffered_write_stream]

[indexterm2 boost_asio.indexterm.buffered_write_stream.buffered_write_stream..buffered_write_stream..buffered_write_stream] 
Construct, passing the specified argument to initialise the next layer. 


  template<
      typename Arg>
  explicit ``[link boost_asio.reference.buffered_write_stream.buffered_write_stream.overload1 buffered_write_stream]``(
      Arg & a);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.buffered_write_stream.overload1 more...]]``

  template<
      typename Arg>
  ``[link boost_asio.reference.buffered_write_stream.buffered_write_stream.overload2 buffered_write_stream]``(
      Arg & a,
      std::size_t buffer_size);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.buffered_write_stream.overload2 more...]]``


[section:overload1 buffered_write_stream::buffered_write_stream (1 of 2 overloads)]


Construct, passing the specified argument to initialise the next layer. 


  template<
      typename Arg>
  buffered_write_stream(
      Arg & a);



[endsect]



[section:overload2 buffered_write_stream::buffered_write_stream (2 of 2 overloads)]


Construct, passing the specified argument to initialise the next layer. 


  template<
      typename Arg>
  buffered_write_stream(
      Arg & a,
      std::size_t buffer_size);



[endsect]


[endsect]

[section:close buffered_write_stream::close]

[indexterm2 boost_asio.indexterm.buffered_write_stream.close..close..buffered_write_stream] 
Close the stream. 


  void ``[link boost_asio.reference.buffered_write_stream.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.close.overload1 more...]]``

  void ``[link boost_asio.reference.buffered_write_stream.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.close.overload2 more...]]``


[section:overload1 buffered_write_stream::close (1 of 2 overloads)]


Close the stream. 


  void close();



[endsect]



[section:overload2 buffered_write_stream::close (2 of 2 overloads)]


Close the stream. 


  void close(
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:default_buffer_size buffered_write_stream::default_buffer_size]

[indexterm2 boost_asio.indexterm.buffered_write_stream.default_buffer_size..default_buffer_size..buffered_write_stream] 
The default buffer size. 


  static const std::size_t default_buffer_size = implementation_defined;



[endsect]



[section:executor_type buffered_write_stream::executor_type]

[indexterm2 boost_asio.indexterm.buffered_write_stream.executor_type..executor_type..buffered_write_stream] 
The type of the executor associated with the object. 


  typedef lowest_layer_type::executor_type executor_type;



[heading Requirements]

['Header: ][^boost/asio/buffered_write_stream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:flush buffered_write_stream::flush]

[indexterm2 boost_asio.indexterm.buffered_write_stream.flush..flush..buffered_write_stream] 
Flush all data from the buffer to the next layer. Returns the number of bytes written to the next layer on the last write operation. Throws an exception on failure. 


  std::size_t ``[link boost_asio.reference.buffered_write_stream.flush.overload1 flush]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.flush.overload1 more...]]``


Flush all data from the buffer to the next layer. Returns the number of bytes written to the next layer on the last write operation, or 0 if an error occurred. 


  std::size_t ``[link boost_asio.reference.buffered_write_stream.flush.overload2 flush]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.flush.overload2 more...]]``


[section:overload1 buffered_write_stream::flush (1 of 2 overloads)]


Flush all data from the buffer to the next layer. Returns the number of bytes written to the next layer on the last write operation. Throws an exception on failure. 


  std::size_t flush();



[endsect]



[section:overload2 buffered_write_stream::flush (2 of 2 overloads)]


Flush all data from the buffer to the next layer. Returns the number of bytes written to the next layer on the last write operation, or 0 if an error occurred. 


  std::size_t flush(
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:get_executor buffered_write_stream::get_executor]

[indexterm2 boost_asio.indexterm.buffered_write_stream.get_executor..get_executor..buffered_write_stream] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:in_avail buffered_write_stream::in_avail]

[indexterm2 boost_asio.indexterm.buffered_write_stream.in_avail..in_avail..buffered_write_stream] 
Determine the amount of data that may be read without blocking. 


  std::size_t ``[link boost_asio.reference.buffered_write_stream.in_avail.overload1 in_avail]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.in_avail.overload1 more...]]``

  std::size_t ``[link boost_asio.reference.buffered_write_stream.in_avail.overload2 in_avail]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.in_avail.overload2 more...]]``


[section:overload1 buffered_write_stream::in_avail (1 of 2 overloads)]


Determine the amount of data that may be read without blocking. 


  std::size_t in_avail();



[endsect]



[section:overload2 buffered_write_stream::in_avail (2 of 2 overloads)]


Determine the amount of data that may be read without blocking. 


  std::size_t in_avail(
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:lowest_layer buffered_write_stream::lowest_layer]

[indexterm2 boost_asio.indexterm.buffered_write_stream.lowest_layer..lowest_layer..buffered_write_stream] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.buffered_write_stream.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.buffered_write_stream.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.lowest_layer.overload2 more...]]``


[section:overload1 buffered_write_stream::lowest_layer (1 of 2 overloads)]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();



[endsect]



[section:overload2 buffered_write_stream::lowest_layer (2 of 2 overloads)]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;



[endsect]


[endsect]


[section:lowest_layer_type buffered_write_stream::lowest_layer_type]

[indexterm2 boost_asio.indexterm.buffered_write_stream.lowest_layer_type..lowest_layer_type..buffered_write_stream] 
The type of the lowest layer. 


  typedef next_layer_type::lowest_layer_type lowest_layer_type;



[heading Requirements]

['Header: ][^boost/asio/buffered_write_stream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:next_layer buffered_write_stream::next_layer]

[indexterm2 boost_asio.indexterm.buffered_write_stream.next_layer..next_layer..buffered_write_stream] 
Get a reference to the next layer. 


  next_layer_type & next_layer();



[endsect]



[section:next_layer_type buffered_write_stream::next_layer_type]

[indexterm2 boost_asio.indexterm.buffered_write_stream.next_layer_type..next_layer_type..buffered_write_stream] 
The type of the next layer. 


  typedef remove_reference< Stream >::type next_layer_type;



[heading Requirements]

['Header: ][^boost/asio/buffered_write_stream.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:peek buffered_write_stream::peek]

[indexterm2 boost_asio.indexterm.buffered_write_stream.peek..peek..buffered_write_stream] 
Peek at the incoming data on the stream. Returns the number of bytes read. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_write_stream.peek.overload1 peek]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.peek.overload1 more...]]``


Peek at the incoming data on the stream. Returns the number of bytes read, or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_write_stream.peek.overload2 peek]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.peek.overload2 more...]]``


[section:overload1 buffered_write_stream::peek (1 of 2 overloads)]


Peek at the incoming data on the stream. Returns the number of bytes read. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t peek(
      const MutableBufferSequence & buffers);



[endsect]



[section:overload2 buffered_write_stream::peek (2 of 2 overloads)]


Peek at the incoming data on the stream. Returns the number of bytes read, or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t peek(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:read_some buffered_write_stream::read_some]

[indexterm2 boost_asio.indexterm.buffered_write_stream.read_some..read_some..buffered_write_stream] 
Read some data from the stream. Returns the number of bytes read. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_write_stream.read_some.overload1 read_some]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.read_some.overload1 more...]]``


Read some data from the stream. Returns the number of bytes read or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_write_stream.read_some.overload2 read_some]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.read_some.overload2 more...]]``


[section:overload1 buffered_write_stream::read_some (1 of 2 overloads)]


Read some data from the stream. Returns the number of bytes read. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers);



[endsect]



[section:overload2 buffered_write_stream::read_some (2 of 2 overloads)]


Read some data from the stream. Returns the number of bytes read or 0 if an error occurred. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:write_some buffered_write_stream::write_some]

[indexterm2 boost_asio.indexterm.buffered_write_stream.write_some..write_some..buffered_write_stream] 
Write the given data to the stream. Returns the number of bytes written. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_write_stream.write_some.overload1 write_some]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.write_some.overload1 more...]]``


Write the given data to the stream. Returns the number of bytes written, or 0 if an error occurred and the error handler did not throw. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.buffered_write_stream.write_some.overload2 write_some]``(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.buffered_write_stream.write_some.overload2 more...]]``


[section:overload1 buffered_write_stream::write_some (1 of 2 overloads)]


Write the given data to the stream. Returns the number of bytes written. Throws an exception on failure. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers);



[endsect]



[section:overload2 buffered_write_stream::write_some (2 of 2 overloads)]


Write the given data to the stream. Returns the number of bytes written, or 0 if an error occurred and the error handler did not throw. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);



[endsect]


[endsect]


[endsect]


[section:buffers_begin buffers_begin]

[indexterm1 boost_asio.indexterm.buffers_begin..buffers_begin] 
Construct an iterator representing the beginning of the buffers' data. 


  template<
      typename BufferSequence>
  buffers_iterator< BufferSequence > buffers_begin(
      const BufferSequence & buffers);


[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:buffers_end buffers_end]

[indexterm1 boost_asio.indexterm.buffers_end..buffers_end] 
Construct an iterator representing the end of the buffers' data. 


  template<
      typename BufferSequence>
  buffers_iterator< BufferSequence > buffers_end(
      const BufferSequence & buffers);


[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:buffers_iterator buffers_iterator]

[indexterm1 boost_asio.indexterm.buffers_iterator..buffers_iterator]


A random access iterator over the bytes in a buffer sequence. 


  template<
      typename BufferSequence,
      typename ByteType = char>
  class buffers_iterator


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.buffers_iterator.difference_type [*difference_type]]]
    [The type used for the distance between two iterators. ]
  
  ]

  [

    [[link boost_asio.reference.buffers_iterator.iterator_category [*iterator_category]]]
    [The iterator category. ]
  
  ]

  [

    [[link boost_asio.reference.buffers_iterator.pointer [*pointer]]]
    [The type of the result of applying operator->() to the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.buffers_iterator.reference [*reference]]]
    [The type of the result of applying operator*() to the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.buffers_iterator.value_type [*value_type]]]
    [The type of the value pointed to by the iterator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.buffers_iterator.begin [*begin]] [static]]
    [Construct an iterator representing the beginning of the buffers' data. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.buffers_iterator [*buffers_iterator]] [constructor]]
    [Default constructor. Creates an iterator in an undefined state. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.end [*end]] [static]]
    [Construct an iterator representing the end of the buffers' data. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator__star_ [*operator *]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator_plus__plus_ [*operator++]]]
    [Increment operator (prefix). 
     [hr]
     Increment operator (postfix). ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator_plus__eq_ [*operator+=]]]
    [Addition operator. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator_minus__minus_ [*operator--]]]
    [Decrement operator (prefix). 
     [hr]
     Decrement operator (postfix). ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator_minus__eq_ [*operator-=]]]
    [Subtraction operator. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator_arrow_ [*operator->]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator_lb__rb_ [*operator\[\]]]]
    [Access an individual element. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.buffers_iterator.operator_not__eq_ [*operator!=]]]
    [Test two iterators for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator_plus_ [*operator+]]]
    [Addition operator. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator_minus_ [*operator-]]]
    [Subtraction operator. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator_lt_ [*operator<]]]
    [Compare two iterators. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator_lt__eq_ [*operator<=]]]
    [Compare two iterators. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator_eq__eq_ [*operator==]]]
    [Test two iterators for equality. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator_gt_ [*operator>]]]
    [Compare two iterators. ]
  ]
  
  [
    [[link boost_asio.reference.buffers_iterator.operator_gt__eq_ [*operator>=]]]
    [Compare two iterators. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:begin buffers_iterator::begin]

[indexterm2 boost_asio.indexterm.buffers_iterator.begin..begin..buffers_iterator] 
Construct an iterator representing the beginning of the buffers' data. 


  static buffers_iterator begin(
      const BufferSequence & buffers);



[endsect]



[section:buffers_iterator buffers_iterator::buffers_iterator]

[indexterm2 boost_asio.indexterm.buffers_iterator.buffers_iterator..buffers_iterator..buffers_iterator] 
Default constructor. Creates an iterator in an undefined state. 


  buffers_iterator();



[endsect]



[section:difference_type buffers_iterator::difference_type]

[indexterm2 boost_asio.indexterm.buffers_iterator.difference_type..difference_type..buffers_iterator] 
The type used for the distance between two iterators. 


  typedef std::ptrdiff_t difference_type;



[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:end buffers_iterator::end]

[indexterm2 boost_asio.indexterm.buffers_iterator.end..end..buffers_iterator] 
Construct an iterator representing the end of the buffers' data. 


  static buffers_iterator end(
      const BufferSequence & buffers);



[endsect]



[section:iterator_category buffers_iterator::iterator_category]

[indexterm2 boost_asio.indexterm.buffers_iterator.iterator_category..iterator_category..buffers_iterator] 
The iterator category. 


  typedef std::random_access_iterator_tag iterator_category;



[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator__star_ buffers_iterator::operator *]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator__star_..operator *..buffers_iterator] 
Dereference an iterator. 


  reference operator *() const;



[endsect]



[section:operator_not__eq_ buffers_iterator::operator!=]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_not__eq_..operator!=..buffers_iterator] 
Test two iterators for inequality. 


  friend bool operator!=(
      const buffers_iterator & a,
      const buffers_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:operator_plus_ buffers_iterator::operator+]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_plus_..operator+..buffers_iterator] 
Addition operator. 


  friend buffers_iterator ``[link boost_asio.reference.buffers_iterator.operator_plus_.overload1 operator+]``(
      const buffers_iterator & iter,
      std::ptrdiff_t difference);
  ``  [''''&raquo;''' [link boost_asio.reference.buffers_iterator.operator_plus_.overload1 more...]]``

  friend buffers_iterator ``[link boost_asio.reference.buffers_iterator.operator_plus_.overload2 operator+]``(
      std::ptrdiff_t difference,
      const buffers_iterator & iter);
  ``  [''''&raquo;''' [link boost_asio.reference.buffers_iterator.operator_plus_.overload2 more...]]``


[section:overload1 buffers_iterator::operator+ (1 of 2 overloads)]


Addition operator. 


  friend buffers_iterator operator+(
      const buffers_iterator & iter,
      std::ptrdiff_t difference);


[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:overload2 buffers_iterator::operator+ (2 of 2 overloads)]


Addition operator. 


  friend buffers_iterator operator+(
      std::ptrdiff_t difference,
      const buffers_iterator & iter);


[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[endsect]

[section:operator_plus__plus_ buffers_iterator::operator++]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_plus__plus_..operator++..buffers_iterator] 
Increment operator (prefix). 


  buffers_iterator & ``[link boost_asio.reference.buffers_iterator.operator_plus__plus_.overload1 operator++]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffers_iterator.operator_plus__plus_.overload1 more...]]``


Increment operator (postfix). 


  buffers_iterator ``[link boost_asio.reference.buffers_iterator.operator_plus__plus_.overload2 operator++]``(
      int );
  ``  [''''&raquo;''' [link boost_asio.reference.buffers_iterator.operator_plus__plus_.overload2 more...]]``


[section:overload1 buffers_iterator::operator++ (1 of 2 overloads)]


Increment operator (prefix). 


  buffers_iterator & operator++();



[endsect]



[section:overload2 buffers_iterator::operator++ (2 of 2 overloads)]


Increment operator (postfix). 


  buffers_iterator operator++(
      int );



[endsect]


[endsect]


[section:operator_plus__eq_ buffers_iterator::operator+=]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_plus__eq_..operator+=..buffers_iterator] 
Addition operator. 


  buffers_iterator & operator+=(
      std::ptrdiff_t difference);



[endsect]


[section:operator_minus_ buffers_iterator::operator-]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_minus_..operator-..buffers_iterator] 
Subtraction operator. 


  friend buffers_iterator ``[link boost_asio.reference.buffers_iterator.operator_minus_.overload1 operator-]``(
      const buffers_iterator & iter,
      std::ptrdiff_t difference);
  ``  [''''&raquo;''' [link boost_asio.reference.buffers_iterator.operator_minus_.overload1 more...]]``

  friend std::ptrdiff_t ``[link boost_asio.reference.buffers_iterator.operator_minus_.overload2 operator-]``(
      const buffers_iterator & a,
      const buffers_iterator & b);
  ``  [''''&raquo;''' [link boost_asio.reference.buffers_iterator.operator_minus_.overload2 more...]]``


[section:overload1 buffers_iterator::operator- (1 of 2 overloads)]


Subtraction operator. 


  friend buffers_iterator operator-(
      const buffers_iterator & iter,
      std::ptrdiff_t difference);


[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:overload2 buffers_iterator::operator- (2 of 2 overloads)]


Subtraction operator. 


  friend std::ptrdiff_t operator-(
      const buffers_iterator & a,
      const buffers_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[endsect]

[section:operator_minus__minus_ buffers_iterator::operator--]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_minus__minus_..operator--..buffers_iterator] 
Decrement operator (prefix). 


  buffers_iterator & ``[link boost_asio.reference.buffers_iterator.operator_minus__minus_.overload1 operator--]``();
  ``  [''''&raquo;''' [link boost_asio.reference.buffers_iterator.operator_minus__minus_.overload1 more...]]``


Decrement operator (postfix). 


  buffers_iterator ``[link boost_asio.reference.buffers_iterator.operator_minus__minus_.overload2 operator--]``(
      int );
  ``  [''''&raquo;''' [link boost_asio.reference.buffers_iterator.operator_minus__minus_.overload2 more...]]``


[section:overload1 buffers_iterator::operator-- (1 of 2 overloads)]


Decrement operator (prefix). 


  buffers_iterator & operator--();



[endsect]



[section:overload2 buffers_iterator::operator-- (2 of 2 overloads)]


Decrement operator (postfix). 


  buffers_iterator operator--(
      int );



[endsect]


[endsect]


[section:operator_minus__eq_ buffers_iterator::operator-=]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_minus__eq_..operator-=..buffers_iterator] 
Subtraction operator. 


  buffers_iterator & operator-=(
      std::ptrdiff_t difference);



[endsect]



[section:operator_arrow_ buffers_iterator::operator->]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_arrow_..operator->..buffers_iterator] 
Dereference an iterator. 


  pointer operator->() const;



[endsect]



[section:operator_lt_ buffers_iterator::operator<]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_lt_..operator<..buffers_iterator] 
Compare two iterators. 


  friend bool operator<(
      const buffers_iterator & a,
      const buffers_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_lt__eq_ buffers_iterator::operator<=]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_lt__eq_..operator<=..buffers_iterator] 
Compare two iterators. 


  friend bool operator<=(
      const buffers_iterator & a,
      const buffers_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq__eq_ buffers_iterator::operator==]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_eq__eq_..operator==..buffers_iterator] 
Test two iterators for equality. 


  friend bool operator==(
      const buffers_iterator & a,
      const buffers_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt_ buffers_iterator::operator>]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_gt_..operator>..buffers_iterator] 
Compare two iterators. 


  friend bool operator>(
      const buffers_iterator & a,
      const buffers_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt__eq_ buffers_iterator::operator>=]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_gt__eq_..operator>=..buffers_iterator] 
Compare two iterators. 


  friend bool operator>=(
      const buffers_iterator & a,
      const buffers_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_lb__rb_ buffers_iterator::operator\[\]]

[indexterm2 boost_asio.indexterm.buffers_iterator.operator_lb__rb_..operator\[\]..buffers_iterator] 
Access an individual element. 


  reference operator[](
      std::ptrdiff_t difference) const;



[endsect]



[section:pointer buffers_iterator::pointer]

[indexterm2 boost_asio.indexterm.buffers_iterator.pointer..pointer..buffers_iterator] 
The type of the result of applying `operator->()` to the iterator. 


  typedef const_or_non_const_ByteType * pointer;



If the buffer sequence stores buffer objects that are convertible to [link boost_asio.reference.mutable_buffer `mutable_buffer`], this is a pointer to a non-const ByteType. Otherwise, a pointer to a const ByteType. 

[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:reference buffers_iterator::reference]

[indexterm2 boost_asio.indexterm.buffers_iterator.reference..reference..buffers_iterator] 
The type of the result of applying `operator*()` to the iterator. 


  typedef const_or_non_const_ByteType & reference;



If the buffer sequence stores buffer objects that are convertible to [link boost_asio.reference.mutable_buffer `mutable_buffer`], this is a reference to a non-const ByteType. Otherwise, a reference to a const ByteType. 

[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:value_type buffers_iterator::value_type]

[indexterm2 boost_asio.indexterm.buffers_iterator.value_type..value_type..buffers_iterator] 
The type of the value pointed to by the iterator. 


  typedef ByteType value_type;



[heading Requirements]

['Header: ][^boost/asio/buffers_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:can_prefer can_prefer]

[indexterm1 boost_asio.indexterm.can_prefer..can_prefer]


A type trait that determines whether a `prefer` expression is well-formed. 


  template<
      typename T,
      typename... Properties>
  struct can_prefer


Class template `can_prefer` is a trait that is derived from `true_type` if the expression `boost::asio::prefer(std::declval<T>(), std::declval<Properties>()...)` is well formed; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/prefer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:can_query can_query]

[indexterm1 boost_asio.indexterm.can_query..can_query]


A type trait that determines whether a `query` expression is well-formed. 


  template<
      typename T,
      typename Property>
  struct can_query


Class template `can_query` is a trait that is derived from `true_type` if the expression `boost::asio::query(std::declval<T>(), std::declval<Property>())` is well formed; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/query.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:can_require can_require]

[indexterm1 boost_asio.indexterm.can_require..can_require]


A type trait that determines whether a `require` expression is well-formed. 


  template<
      typename T,
      typename... Properties>
  struct can_require


Class template `can_require` is a trait that is derived from `true_type` if the expression `boost::asio::require(std::declval<T>(), std::declval<Properties>()...)` is well formed; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/require.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:can_require_concept can_require_concept]

[indexterm1 boost_asio.indexterm.can_require_concept..can_require_concept]


A type trait that determines whether a `require_concept` expression is well-formed. 


  template<
      typename T,
      typename Property>
  struct can_require_concept


Class template `can_require_concept` is a trait that is derived from `true_type` if the expression `boost::asio::require_concept(std::declval<T>(), std::declval<Property>())` is well formed; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/require_concept.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:cancellation_filter cancellation_filter]

[indexterm1 boost_asio.indexterm.cancellation_filter..cancellation_filter]


A simple cancellation signal propagation filter. 


  template<
      cancellation_type_t Mask>
  struct cancellation_filter


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.cancellation_filter.operator_lp__rp_ [*operator()]]]
    [Returns type & Mask. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/cancellation_state.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:operator_lp__rp_ cancellation_filter::operator()]

[indexterm2 boost_asio.indexterm.cancellation_filter.operator_lp__rp_..operator()..cancellation_filter] 
Returns `type & Mask`. 


  cancellation_type_t operator()(
      cancellation_type_t type) const;



[endsect]



[endsect]

[section:cancellation_signal cancellation_signal]

[indexterm1 boost_asio.indexterm.cancellation_signal..cancellation_signal]


A cancellation signal with a single slot. 


  class cancellation_signal


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.cancellation_signal.cancellation_signal [*cancellation_signal]] [constructor]]
    []
  ]
  
  [
    [[link boost_asio.reference.cancellation_signal.emit [*emit]]]
    [Emits the signal and causes invocation of the slot's handler, if any. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_signal.slot [*slot]]]
    [Returns the single slot associated with the signal. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_signal._cancellation_signal [*~cancellation_signal]] [destructor]]
    []
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/cancellation_signal.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:cancellation_signal cancellation_signal::cancellation_signal]

[indexterm2 boost_asio.indexterm.cancellation_signal.cancellation_signal..cancellation_signal..cancellation_signal] 

  constexpr cancellation_signal();



[endsect]



[section:emit cancellation_signal::emit]

[indexterm2 boost_asio.indexterm.cancellation_signal.emit..emit..cancellation_signal] 
Emits the signal and causes invocation of the slot's handler, if any. 


  void emit(
      cancellation_type_t type);



[endsect]



[section:slot cancellation_signal::slot]

[indexterm2 boost_asio.indexterm.cancellation_signal.slot..slot..cancellation_signal] 
Returns the single slot associated with the signal. 


  cancellation_slot slot();


The signal object must remain valid for as long the slot may be used. Destruction of the signal invalidates the slot. 


[endsect]



[section:_cancellation_signal cancellation_signal::~cancellation_signal]

[indexterm2 boost_asio.indexterm.cancellation_signal._cancellation_signal..~cancellation_signal..cancellation_signal] 

  ~cancellation_signal();



[endsect]



[endsect]

[section:cancellation_slot cancellation_slot]

[indexterm1 boost_asio.indexterm.cancellation_slot..cancellation_slot]


A slot associated with a cancellation signal. 


  class cancellation_slot


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.cancellation_slot.assign [*assign]]]
    [Installs a handler into the slot. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_slot.cancellation_slot [*cancellation_slot]] [constructor]]
    [Creates a slot that is not connected to any cancellation signal. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_slot.clear [*clear]]]
    [Clears the slot. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_slot.emplace [*emplace]]]
    [Installs a handler into the slot, constructing the new object directly. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_slot.has_handler [*has_handler]]]
    [Returns whether the slot is connected and has an installed handler. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_slot.is_connected [*is_connected]]]
    [Returns whether the slot is connected to a signal. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.cancellation_slot.operator_not__eq_ [*operator!=]]]
    [Compare two slots for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_slot.operator_eq__eq_ [*operator==]]]
    [Compare two slots for equality. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/cancellation_signal.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:assign cancellation_slot::assign]

[indexterm2 boost_asio.indexterm.cancellation_slot.assign..assign..cancellation_slot] 
Installs a handler into the slot. 


  template<
      typename ``[link boost_asio.reference.CancellationHandler CancellationHandler]``>
  decay< CancellationHandler >::type & assign(
      CancellationHandler && handler);


Destroys any existing handler in the slot, then installs the new handler, constructing it as a decay-copy of the supplied handler.

The handler is a function object to be called when the signal is emitted. The signature of the handler must be 

   void handler(boost::asio::cancellation_type_t); 





[heading Parameters]
    

[variablelist
  
[[handler][The handler to be installed.]]

]


[heading Return Value]
      
A reference to the newly installed handler. 




[endsect]



[section:cancellation_slot cancellation_slot::cancellation_slot]

[indexterm2 boost_asio.indexterm.cancellation_slot.cancellation_slot..cancellation_slot..cancellation_slot] 
Creates a slot that is not connected to any cancellation signal. 


  constexpr cancellation_slot();



[endsect]



[section:clear cancellation_slot::clear]

[indexterm2 boost_asio.indexterm.cancellation_slot.clear..clear..cancellation_slot] 
Clears the slot. 


  void clear();


Destroys any existing handler in the slot. 


[endsect]



[section:emplace cancellation_slot::emplace]

[indexterm2 boost_asio.indexterm.cancellation_slot.emplace..emplace..cancellation_slot] 
Installs a handler into the slot, constructing the new object directly. 


  template<
      typename ``[link boost_asio.reference.CancellationHandler CancellationHandler]``,
      typename... Args>
  CancellationHandler & emplace(
      Args &&... args);


Destroys any existing handler in the slot, then installs the new handler, constructing it with the supplied `args`.

The handler is a function object to be called when the signal is emitted. The signature of the handler must be 

   void handler(boost::asio::cancellation_type_t); 





[heading Parameters]
    

[variablelist
  
[[args][Arguments to be passed to the `CancellationHandler` object's constructor.]]

]


[heading Return Value]
      
A reference to the newly installed handler.


[heading Remarks]
      
Handlers installed into the slot via `emplace` are not required to be copy constructible or move constructible. 




[endsect]



[section:has_handler cancellation_slot::has_handler]

[indexterm2 boost_asio.indexterm.cancellation_slot.has_handler..has_handler..cancellation_slot] 
Returns whether the slot is connected and has an installed handler. 


  constexpr bool has_handler() const;



[endsect]



[section:is_connected cancellation_slot::is_connected]

[indexterm2 boost_asio.indexterm.cancellation_slot.is_connected..is_connected..cancellation_slot] 
Returns whether the slot is connected to a signal. 


  constexpr bool is_connected() const;



[endsect]



[section:operator_not__eq_ cancellation_slot::operator!=]

[indexterm2 boost_asio.indexterm.cancellation_slot.operator_not__eq_..operator!=..cancellation_slot] 
Compare two slots for inequality. 


  friend constexpr bool operator!=(
      const cancellation_slot & lhs,
      const cancellation_slot & rhs);


[heading Requirements]

['Header: ][^boost/asio/cancellation_signal.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq__eq_ cancellation_slot::operator==]

[indexterm2 boost_asio.indexterm.cancellation_slot.operator_eq__eq_..operator==..cancellation_slot] 
Compare two slots for equality. 


  friend constexpr bool operator==(
      const cancellation_slot & lhs,
      const cancellation_slot & rhs);


[heading Requirements]

['Header: ][^boost/asio/cancellation_signal.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:cancellation_slot_binder cancellation_slot_binder]

[indexterm1 boost_asio.indexterm.cancellation_slot_binder..cancellation_slot_binder]


A call wrapper type to bind a cancellation slot of type `CancellationSlot` to an object of type `T`. 


  template<
      typename T,
      typename ``[link boost_asio.reference.CancellationSlot CancellationSlot]``>
  class cancellation_slot_binder


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.cancellation_slot_binder.argument_type [*argument_type]]]
    [The type of the function's argument. ]
  
  ]

  [

    [[link boost_asio.reference.cancellation_slot_binder.cancellation_slot_type [*cancellation_slot_type]]]
    [The type of the associated cancellation slot. ]
  
  ]

  [

    [[link boost_asio.reference.cancellation_slot_binder.first_argument_type [*first_argument_type]]]
    [The type of the function's first argument. ]
  
  ]

  [

    [[link boost_asio.reference.cancellation_slot_binder.result_type [*result_type]]]
    [The return type if a function. ]
  
  ]

  [

    [[link boost_asio.reference.cancellation_slot_binder.second_argument_type [*second_argument_type]]]
    [The type of the function's second argument. ]
  
  ]

  [

    [[link boost_asio.reference.cancellation_slot_binder.target_type [*target_type]]]
    [The type of the target object. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder [*cancellation_slot_binder]] [constructor]]
    [Construct a cancellation slot wrapper for the specified object. 
     [hr]
     Copy constructor. 
     [hr]
     Construct a copy, but specify a different cancellation slot. 
     [hr]
     Construct a copy of a different cancellation slot wrapper type. 
     [hr]
     Construct a copy of a different cancellation slot wrapper type, but specify a different cancellation slot. 
     [hr]
     Move constructor. 
     [hr]
     Move construct the target object, but specify a different cancellation slot. 
     [hr]
     Move construct from a different cancellation slot wrapper type. 
     [hr]
     Move construct from a different cancellation slot wrapper type, but specify a different cancellation slot. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_slot_binder.get [*get]]]
    [Obtain a reference to the target object. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_slot_binder.get_cancellation_slot [*get_cancellation_slot]]]
    [Obtain the associated cancellation slot. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_slot_binder.operator_lp__rp_ [*operator()]]]
    []
  ]
  
  [
    [[link boost_asio.reference.cancellation_slot_binder._cancellation_slot_binder [*~cancellation_slot_binder]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/bind_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:argument_type cancellation_slot_binder::argument_type]

[indexterm2 boost_asio.indexterm.cancellation_slot_binder.argument_type..argument_type..cancellation_slot_binder] 
The type of the function's argument. 


  typedef see_below argument_type;



The type of `argument_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to a function type accepting a single argument, `argument_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `argument_type`, then `argument_type` is a synonym for `T::argument_type`;


* otherwise `argument_type` is not defined. 



[heading Requirements]

['Header: ][^boost/asio/bind_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:cancellation_slot_binder cancellation_slot_binder::cancellation_slot_binder]

[indexterm2 boost_asio.indexterm.cancellation_slot_binder.cancellation_slot_binder..cancellation_slot_binder..cancellation_slot_binder] 
Construct a cancellation slot wrapper for the specified object. 


  template<
      typename U>
  ``[link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload1 cancellation_slot_binder]``(
      const cancellation_slot_type & s,
      U && u);
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload1 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload2 cancellation_slot_binder]``(
      const cancellation_slot_binder & other);
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload2 more...]]``


Construct a copy, but specify a different cancellation slot. 


  ``[link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload3 cancellation_slot_binder]``(
      const cancellation_slot_type & s,
      const cancellation_slot_binder & other);
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload3 more...]]``


Construct a copy of a different cancellation slot wrapper type. 


  template<
      typename U,
      typename ``[link boost_asio.reference.CancellationSlot OtherCancellationSlot]``>
  ``[link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload4 cancellation_slot_binder]``(
      const cancellation_slot_binder< U, OtherCancellationSlot > & other);
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload4 more...]]``


Construct a copy of a different cancellation slot wrapper type, but specify a different cancellation slot. 


  template<
      typename U,
      typename ``[link boost_asio.reference.CancellationSlot OtherCancellationSlot]``>
  ``[link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload5 cancellation_slot_binder]``(
      const cancellation_slot_type & s,
      const cancellation_slot_binder< U, OtherCancellationSlot > & other);
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload5 more...]]``


Move constructor. 


  ``[link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload6 cancellation_slot_binder]``(
      cancellation_slot_binder && other);
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload6 more...]]``


Move construct the target object, but specify a different cancellation slot. 


  ``[link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload7 cancellation_slot_binder]``(
      const cancellation_slot_type & s,
      cancellation_slot_binder && other);
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload7 more...]]``


Move construct from a different cancellation slot wrapper type. 


  template<
      typename U,
      typename ``[link boost_asio.reference.CancellationSlot OtherCancellationSlot]``>
  ``[link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload8 cancellation_slot_binder]``(
      cancellation_slot_binder< U, OtherCancellationSlot > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload8 more...]]``


Move construct from a different cancellation slot wrapper type, but specify a different cancellation slot. 


  template<
      typename U,
      typename ``[link boost_asio.reference.CancellationSlot OtherCancellationSlot]``>
  ``[link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload9 cancellation_slot_binder]``(
      const cancellation_slot_type & s,
      cancellation_slot_binder< U, OtherCancellationSlot > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_slot_binder.cancellation_slot_binder.overload9 more...]]``


[section:overload1 cancellation_slot_binder::cancellation_slot_binder (1 of 9 overloads)]


Construct a cancellation slot wrapper for the specified object. 


  template<
      typename U>
  cancellation_slot_binder(
      const cancellation_slot_type & s,
      U && u);


This constructor is only valid if the type `T` is constructible from type `U`. 


[endsect]



[section:overload2 cancellation_slot_binder::cancellation_slot_binder (2 of 9 overloads)]


Copy constructor. 


  cancellation_slot_binder(
      const cancellation_slot_binder & other);



[endsect]



[section:overload3 cancellation_slot_binder::cancellation_slot_binder (3 of 9 overloads)]


Construct a copy, but specify a different cancellation slot. 


  cancellation_slot_binder(
      const cancellation_slot_type & s,
      const cancellation_slot_binder & other);



[endsect]



[section:overload4 cancellation_slot_binder::cancellation_slot_binder (4 of 9 overloads)]


Construct a copy of a different cancellation slot wrapper type. 


  template<
      typename U,
      typename ``[link boost_asio.reference.CancellationSlot OtherCancellationSlot]``>
  cancellation_slot_binder(
      const cancellation_slot_binder< U, OtherCancellationSlot > & other);


This constructor is only valid if the `CancellationSlot` type is constructible from type `OtherCancellationSlot`, and the type `T` is constructible from type `U`. 


[endsect]



[section:overload5 cancellation_slot_binder::cancellation_slot_binder (5 of 9 overloads)]


Construct a copy of a different cancellation slot wrapper type, but specify a different cancellation slot. 


  template<
      typename U,
      typename ``[link boost_asio.reference.CancellationSlot OtherCancellationSlot]``>
  cancellation_slot_binder(
      const cancellation_slot_type & s,
      const cancellation_slot_binder< U, OtherCancellationSlot > & other);


This constructor is only valid if the type `T` is constructible from type `U`. 


[endsect]



[section:overload6 cancellation_slot_binder::cancellation_slot_binder (6 of 9 overloads)]


Move constructor. 


  cancellation_slot_binder(
      cancellation_slot_binder && other);



[endsect]



[section:overload7 cancellation_slot_binder::cancellation_slot_binder (7 of 9 overloads)]


Move construct the target object, but specify a different cancellation slot. 


  cancellation_slot_binder(
      const cancellation_slot_type & s,
      cancellation_slot_binder && other);



[endsect]



[section:overload8 cancellation_slot_binder::cancellation_slot_binder (8 of 9 overloads)]


Move construct from a different cancellation slot wrapper type. 


  template<
      typename U,
      typename ``[link boost_asio.reference.CancellationSlot OtherCancellationSlot]``>
  cancellation_slot_binder(
      cancellation_slot_binder< U, OtherCancellationSlot > && other);



[endsect]



[section:overload9 cancellation_slot_binder::cancellation_slot_binder (9 of 9 overloads)]


Move construct from a different cancellation slot wrapper type, but specify a different cancellation slot. 


  template<
      typename U,
      typename ``[link boost_asio.reference.CancellationSlot OtherCancellationSlot]``>
  cancellation_slot_binder(
      const cancellation_slot_type & s,
      cancellation_slot_binder< U, OtherCancellationSlot > && other);



[endsect]


[endsect]


[section:cancellation_slot_type cancellation_slot_binder::cancellation_slot_type]

[indexterm2 boost_asio.indexterm.cancellation_slot_binder.cancellation_slot_type..cancellation_slot_type..cancellation_slot_binder] 
The type of the associated cancellation slot. 


  typedef CancellationSlot cancellation_slot_type;



[heading Requirements]

['Header: ][^boost/asio/bind_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:first_argument_type cancellation_slot_binder::first_argument_type]

[indexterm2 boost_asio.indexterm.cancellation_slot_binder.first_argument_type..first_argument_type..cancellation_slot_binder] 
The type of the function's first argument. 


  typedef see_below first_argument_type;



The type of `first_argument_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to a function type accepting two arguments, `first_argument_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `first_argument_type`, then `first_argument_type` is a synonym for `T::first_argument_type`;


* otherwise `first_argument_type` is not defined. 



[heading Requirements]

['Header: ][^boost/asio/bind_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:get cancellation_slot_binder::get]

[indexterm2 boost_asio.indexterm.cancellation_slot_binder.get..get..cancellation_slot_binder] 
Obtain a reference to the target object. 


  target_type & ``[link boost_asio.reference.cancellation_slot_binder.get.overload1 get]``();
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_slot_binder.get.overload1 more...]]``

  const target_type & ``[link boost_asio.reference.cancellation_slot_binder.get.overload2 get]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_slot_binder.get.overload2 more...]]``


[section:overload1 cancellation_slot_binder::get (1 of 2 overloads)]


Obtain a reference to the target object. 


  target_type & get();



[endsect]



[section:overload2 cancellation_slot_binder::get (2 of 2 overloads)]


Obtain a reference to the target object. 


  const target_type & get() const;



[endsect]


[endsect]


[section:get_cancellation_slot cancellation_slot_binder::get_cancellation_slot]

[indexterm2 boost_asio.indexterm.cancellation_slot_binder.get_cancellation_slot..get_cancellation_slot..cancellation_slot_binder] 
Obtain the associated cancellation slot. 


  cancellation_slot_type get_cancellation_slot() const;



[endsect]


[section:operator_lp__rp_ cancellation_slot_binder::operator()]

[indexterm2 boost_asio.indexterm.cancellation_slot_binder.operator_lp__rp_..operator()..cancellation_slot_binder] 

  template<
      typename... Args>
  auto ``[link boost_asio.reference.cancellation_slot_binder.operator_lp__rp_.overload1 operator()]``(
      Args && ...);
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_slot_binder.operator_lp__rp_.overload1 more...]]``

  template<
      typename... Args>
  auto ``[link boost_asio.reference.cancellation_slot_binder.operator_lp__rp_.overload2 operator()]``(
      Args && ...) const;
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_slot_binder.operator_lp__rp_.overload2 more...]]``


[section:overload1 cancellation_slot_binder::operator() (1 of 2 overloads)]



  template<
      typename... Args>
  auto operator()(
      Args && ...);



[endsect]



[section:overload2 cancellation_slot_binder::operator() (2 of 2 overloads)]



  template<
      typename... Args>
  auto operator()(
      Args && ...) const;



[endsect]


[endsect]


[section:result_type cancellation_slot_binder::result_type]

[indexterm2 boost_asio.indexterm.cancellation_slot_binder.result_type..result_type..cancellation_slot_binder] 
The return type if a function. 


  typedef see_below result_type;



The type of `result_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to function type, `result_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `result_type`, then `result_type` is a synonym for `T::result_type`;


* otherwise `result_type` is not defined. 



[heading Requirements]

['Header: ][^boost/asio/bind_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:second_argument_type cancellation_slot_binder::second_argument_type]

[indexterm2 boost_asio.indexterm.cancellation_slot_binder.second_argument_type..second_argument_type..cancellation_slot_binder] 
The type of the function's second argument. 


  typedef see_below second_argument_type;



The type of `second_argument_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to a function type accepting two arguments, `second_argument_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `first_argument_type`, then `second_argument_type` is a synonym for `T::second_argument_type`;


* otherwise `second_argument_type` is not defined. 



[heading Requirements]

['Header: ][^boost/asio/bind_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:target_type cancellation_slot_binder::target_type]

[indexterm2 boost_asio.indexterm.cancellation_slot_binder.target_type..target_type..cancellation_slot_binder] 
The type of the target object. 


  typedef T target_type;



[heading Requirements]

['Header: ][^boost/asio/bind_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:_cancellation_slot_binder cancellation_slot_binder::~cancellation_slot_binder]

[indexterm2 boost_asio.indexterm.cancellation_slot_binder._cancellation_slot_binder..~cancellation_slot_binder..cancellation_slot_binder] 
Destructor. 


  ~cancellation_slot_binder();



[endsect]



[endsect]

[section:cancellation_state cancellation_state]

[indexterm1 boost_asio.indexterm.cancellation_state..cancellation_state]


A cancellation state is used for chaining signals and slots in compositions. 


  class cancellation_state


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.cancellation_state.cancellation_state [*cancellation_state]] [constructor]]
    [Construct a disconnected cancellation state. 
     [hr]
     Construct and attach to a parent slot to create a new child slot. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_state.cancelled [*cancelled]]]
    [Returns the cancellation types that have been triggered. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_state.clear [*clear]]]
    [Clears the specified cancellation types, if they have been triggered. ]
  ]
  
  [
    [[link boost_asio.reference.cancellation_state.slot [*slot]]]
    [Returns the single child slot associated with the state. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/cancellation_state.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:cancellation_state cancellation_state::cancellation_state]

[indexterm2 boost_asio.indexterm.cancellation_state.cancellation_state..cancellation_state..cancellation_state] 
Construct a disconnected cancellation state. 


  constexpr ``[link boost_asio.reference.cancellation_state.cancellation_state.overload1 cancellation_state]``();
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_state.cancellation_state.overload1 more...]]``


Construct and attach to a parent slot to create a new child slot. 


  template<
      typename ``[link boost_asio.reference.CancellationSlot CancellationSlot]``>
  explicit constexpr ``[link boost_asio.reference.cancellation_state.cancellation_state.overload2 cancellation_state]``(
      CancellationSlot slot);
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_state.cancellation_state.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.CancellationSlot CancellationSlot]``,
      typename Filter>
  constexpr ``[link boost_asio.reference.cancellation_state.cancellation_state.overload3 cancellation_state]``(
      CancellationSlot slot,
      Filter filter);
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_state.cancellation_state.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.CancellationSlot CancellationSlot]``,
      typename InFilter,
      typename OutFilter>
  constexpr ``[link boost_asio.reference.cancellation_state.cancellation_state.overload4 cancellation_state]``(
      CancellationSlot slot,
      InFilter in_filter,
      OutFilter out_filter);
  ``  [''''&raquo;''' [link boost_asio.reference.cancellation_state.cancellation_state.overload4 more...]]``


[section:overload1 cancellation_state::cancellation_state (1 of 4 overloads)]


Construct a disconnected cancellation state. 


  constexpr cancellation_state();



[endsect]



[section:overload2 cancellation_state::cancellation_state (2 of 4 overloads)]


Construct and attach to a parent slot to create a new child slot. 


  template<
      typename ``[link boost_asio.reference.CancellationSlot CancellationSlot]``>
  constexpr cancellation_state(
      CancellationSlot slot);


Initialises the cancellation state so that it allows terminal cancellation only. Equivalent to `cancellation_state(slot, enable_terminal_cancellation())`.


[heading Parameters]
    

[variablelist
  
[[slot][The parent cancellation slot to which the state will be attached. ]]

]




[endsect]



[section:overload3 cancellation_state::cancellation_state (3 of 4 overloads)]


Construct and attach to a parent slot to create a new child slot. 


  template<
      typename ``[link boost_asio.reference.CancellationSlot CancellationSlot]``,
      typename Filter>
  constexpr cancellation_state(
      CancellationSlot slot,
      Filter filter);



[heading Parameters]
    

[variablelist
  
[[slot][The parent cancellation slot to which the state will be attached.]]

[[filter][A function object that is used to transform incoming cancellation signals as they are received from the parent slot. This function object must have the signature: 
``
   boost::asio::cancellation_type_t filter(
       boost::asio::cancellation_type_t); 
``
]]

]

The library provides the following pre-defined cancellation filters:


* [link boost_asio.reference.disable_cancellation `disable_cancellation`] 

* [link boost_asio.reference.enable_terminal_cancellation `enable_terminal_cancellation`] 

* [link boost_asio.reference.enable_partial_cancellation `enable_partial_cancellation`] 

* [link boost_asio.reference.enable_total_cancellation `enable_total_cancellation`] 




[endsect]



[section:overload4 cancellation_state::cancellation_state (4 of 4 overloads)]


Construct and attach to a parent slot to create a new child slot. 


  template<
      typename ``[link boost_asio.reference.CancellationSlot CancellationSlot]``,
      typename InFilter,
      typename OutFilter>
  constexpr cancellation_state(
      CancellationSlot slot,
      InFilter in_filter,
      OutFilter out_filter);



[heading Parameters]
    

[variablelist
  
[[slot][The parent cancellation slot to which the state will be attached.]]

[[in_filter][A function object that is used to transform incoming cancellation signals as they are received from the parent slot. This function object must have the signature: 
``
   boost::asio::cancellation_type_t in_filter(
       boost::asio::cancellation_type_t); 
``
]]

[[out_filter][A function object that is used to transform outcoming cancellation signals as they are relayed to the child slot. This function object must have the signature: 
``
   boost::asio::cancellation_type_t out_filter(
       boost::asio::cancellation_type_t); 
``
]]

]

The library provides the following pre-defined cancellation filters:


* [link boost_asio.reference.disable_cancellation `disable_cancellation`] 

* [link boost_asio.reference.enable_terminal_cancellation `enable_terminal_cancellation`] 

* [link boost_asio.reference.enable_partial_cancellation `enable_partial_cancellation`] 

* [link boost_asio.reference.enable_total_cancellation `enable_total_cancellation`] 




[endsect]


[endsect]


[section:cancelled cancellation_state::cancelled]

[indexterm2 boost_asio.indexterm.cancellation_state.cancelled..cancelled..cancellation_state] 
Returns the cancellation types that have been triggered. 


  cancellation_type_t cancelled() const;



[endsect]



[section:clear cancellation_state::clear]

[indexterm2 boost_asio.indexterm.cancellation_state.clear..clear..cancellation_state] 
Clears the specified cancellation types, if they have been triggered. 


  void clear(
      cancellation_type_t mask = cancellation_type::all);



[endsect]



[section:slot cancellation_state::slot]

[indexterm2 boost_asio.indexterm.cancellation_state.slot..slot..cancellation_state] 
Returns the single child slot associated with the state. 


  constexpr cancellation_slot slot() const;


This sub-slot is used with the operations that are being composed. 


[endsect]



[endsect]


[section:cancellation_type cancellation_type]

[indexterm1 boost_asio.indexterm.cancellation_type..cancellation_type] 
Enumeration representing the different types of cancellation that may be requested from or implemented by an asynchronous operation. 

  enum class cancellation_type : unsigned int

[indexterm2 boost_asio.indexterm.cancellation_type.none..none..cancellation_type]
[indexterm2 boost_asio.indexterm.cancellation_type.terminal..terminal..cancellation_type]
[indexterm2 boost_asio.indexterm.cancellation_type.partial..partial..cancellation_type]
[indexterm2 boost_asio.indexterm.cancellation_type.total..total..cancellation_type]
[indexterm2 boost_asio.indexterm.cancellation_type.all..all..cancellation_type]

[heading Values]
[variablelist

  [
    [none]
    [Bitmask representing no types of cancellation. ]
  ]

  [
    [terminal]
    [Requests cancellation where, following a successful cancellation, the only safe operations on the I/O object are closure or destruction. ]
  ]

  [
    [partial]
    [Requests cancellation where a successful cancellation may result in partial side effects or no side effects. Following cancellation, the I/O object is in a well-known state, and may be used for further operations. ]
  ]

  [
    [total]
    [Requests cancellation where a successful cancellation results in no apparent side effects. Following cancellation, the I/O object is in the same observable state as it was prior to the operation. ]
  ]

  [
    [all]
    [Bitmask representing all types of cancellation. ]
  ]

]


[heading Requirements]

['Header: ][^boost/asio/cancellation_type.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:cancellation_type_t cancellation_type_t]

[indexterm1 boost_asio.indexterm.cancellation_type_t..cancellation_type_t] 
Portability typedef. 


  typedef cancellation_type cancellation_type_t;



[heading Requirements]

['Header: ][^boost/asio/cancellation_type.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:co_spawn co_spawn]

[indexterm1 boost_asio.indexterm.co_spawn..co_spawn] 
Spawn a new coroutined-based thread of execution. 

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename T,
      typename ``[link boost_asio.reference.Executor1 AwaitableExecutor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.co_spawn.overload1 co_spawn]``(
      const Executor & ex,
      awaitable< T, AwaitableExecutor > a,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< (is_executor< Executor >::value||execution::is_executor< Executor >::value)&&is_convertible< Executor, AwaitableExecutor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.co_spawn.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.Executor1 AwaitableExecutor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.co_spawn.overload2 co_spawn]``(
      const Executor & ex,
      awaitable< void, AwaitableExecutor > a,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< (is_executor< Executor >::value||execution::is_executor< Executor >::value)&&is_convertible< Executor, AwaitableExecutor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.co_spawn.overload2 more...]]``

  template<
      typename ExecutionContext,
      typename T,
      typename ``[link boost_asio.reference.Executor1 AwaitableExecutor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.co_spawn.overload3 co_spawn]``(
      ExecutionContext & ctx,
      awaitable< T, AwaitableExecutor > a,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value &&is_convertible< typename ExecutionContext::executor_type, AwaitableExecutor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.co_spawn.overload3 more...]]``

  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.Executor1 AwaitableExecutor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.co_spawn.overload4 co_spawn]``(
      ExecutionContext & ctx,
      awaitable< void, AwaitableExecutor > a,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value &&is_convertible< typename ExecutionContext::executor_type, AwaitableExecutor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.co_spawn.overload4 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename F,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.co_spawn.overload5 co_spawn]``(
      const Executor & ex,
      F && f,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.co_spawn.overload5 more...]]``

  template<
      typename ExecutionContext,
      typename F,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.co_spawn.overload6 co_spawn]``(
      ExecutionContext & ctx,
      F && f,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.co_spawn.overload6 more...]]``

[heading Requirements]

['Header: ][^boost/asio/co_spawn.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 co_spawn (1 of 6 overloads)]


Spawn a new coroutined-based thread of execution. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename T,
      typename ``[link boost_asio.reference.Executor1 AwaitableExecutor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` co_spawn(
      const Executor & ex,
      awaitable< T, AwaitableExecutor > a,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< (is_executor< Executor >::value||execution::is_executor< Executor >::value)&&is_convertible< Executor, AwaitableExecutor >::value >::type  = 0);



[heading Parameters]
    

[variablelist
  
[[ex][The executor that will be used to schedule the new thread of execution.]]

[[a][The [link boost_asio.reference.awaitable `awaitable`] object that is the result of calling the coroutine's entry point function.]]

[[token][The completion token that will handle the notification that the thread of execution has completed. The function signature of the completion handler must be: 
``
   void handler(std::exception_ptr, T); 
``
]]

]


[heading Example]
  


   boost::asio::awaitable<std::size_t> echo(tcp::socket socket)
   {
     std::size_t bytes_transferred = 0;

     try
     {
       char data[1024];
       for (;;)
       {
         std::size_t n = co_await socket.async_read_some(
             boost::asio::buffer(data), boost::asio::use_awaitable);

         co_await boost::asio::async_write(socket,
             boost::asio::buffer(data, n), boost::asio::use_awaitable);

         bytes_transferred += n;
       }
     }
     catch (const std::exception&)
     {
     }

     co_return bytes_transferred;
   }

   // ...

   boost::asio::co_spawn(my_executor,
     echo(std::move(my_tcp_socket)),
     [](std::exception_ptr e, std::size_t n)
     {
       std::cout << "transferred " << n << "\n";
     });





[heading Per-Operation Cancellation]
  
The new thread of execution is created with a cancellation state that supports `cancellation_type::terminal` values only. To change the cancellation state, call [link boost_asio.reference.this_coro__reset_cancellation_state `this_coro::reset_cancellation_state`]. 




[endsect]



[section:overload2 co_spawn (2 of 6 overloads)]


Spawn a new coroutined-based thread of execution. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.Executor1 AwaitableExecutor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` co_spawn(
      const Executor & ex,
      awaitable< void, AwaitableExecutor > a,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< (is_executor< Executor >::value||execution::is_executor< Executor >::value)&&is_convertible< Executor, AwaitableExecutor >::value >::type  = 0);



[heading Parameters]
    

[variablelist
  
[[ex][The executor that will be used to schedule the new thread of execution.]]

[[a][The [link boost_asio.reference.awaitable `awaitable`] object that is the result of calling the coroutine's entry point function.]]

[[token][The completion token that will handle the notification that the thread of execution has completed. The function signature of the completion handler must be: 
``
   void handler(std::exception_ptr); 
``
]]

]


[heading Example]
  


   boost::asio::awaitable<void> echo(tcp::socket socket)
   {
     try
     {
       char data[1024];
       for (;;)
       {
         std::size_t n = co_await socket.async_read_some(
             boost::asio::buffer(data), boost::asio::use_awaitable);

         co_await boost::asio::async_write(socket,
             boost::asio::buffer(data, n), boost::asio::use_awaitable);
       }
     }
     catch (const std::exception& e)
     {
       std::cerr << "Exception: " << e.what() << "\n";
     }
   }

   // ...

   boost::asio::co_spawn(my_executor,
     echo(std::move(my_tcp_socket)),
     boost::asio::detached);





[heading Per-Operation Cancellation]
  
The new thread of execution is created with a cancellation state that supports `cancellation_type::terminal` values only. To change the cancellation state, call [link boost_asio.reference.this_coro__reset_cancellation_state `this_coro::reset_cancellation_state`]. 




[endsect]



[section:overload3 co_spawn (3 of 6 overloads)]


Spawn a new coroutined-based thread of execution. 


  template<
      typename ExecutionContext,
      typename T,
      typename ``[link boost_asio.reference.Executor1 AwaitableExecutor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` co_spawn(
      ExecutionContext & ctx,
      awaitable< T, AwaitableExecutor > a,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value &&is_convertible< typename ExecutionContext::executor_type, AwaitableExecutor >::value >::type  = 0);



[heading Parameters]
    

[variablelist
  
[[ctx][An execution context that will provide the executor to be used to schedule the new thread of execution.]]

[[a][The [link boost_asio.reference.awaitable `awaitable`] object that is the result of calling the coroutine's entry point function.]]

[[token][The completion token that will handle the notification that the thread of execution has completed. The function signature of the completion handler must be: 
``
   void handler(std::exception_ptr); 
``
]]

]


[heading Example]
  


   boost::asio::awaitable<std::size_t> echo(tcp::socket socket)
   {
     std::size_t bytes_transferred = 0;

     try
     {
       char data[1024];
       for (;;)
       {
         std::size_t n = co_await socket.async_read_some(
             boost::asio::buffer(data), boost::asio::use_awaitable);

         co_await boost::asio::async_write(socket,
             boost::asio::buffer(data, n), boost::asio::use_awaitable);

         bytes_transferred += n;
       }
     }
     catch (const std::exception&)
     {
     }

     co_return bytes_transferred;
   }

   // ...

   boost::asio::co_spawn(my_io_context,
     echo(std::move(my_tcp_socket)),
     [](std::exception_ptr e, std::size_t n)
     {
       std::cout << "transferred " << n << "\n";
     });





[heading Per-Operation Cancellation]
  
The new thread of execution is created with a cancellation state that supports `cancellation_type::terminal` values only. To change the cancellation state, call [link boost_asio.reference.this_coro__reset_cancellation_state `this_coro::reset_cancellation_state`]. 




[endsect]



[section:overload4 co_spawn (4 of 6 overloads)]


Spawn a new coroutined-based thread of execution. 


  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.Executor1 AwaitableExecutor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` co_spawn(
      ExecutionContext & ctx,
      awaitable< void, AwaitableExecutor > a,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value &&is_convertible< typename ExecutionContext::executor_type, AwaitableExecutor >::value >::type  = 0);



[heading Parameters]
    

[variablelist
  
[[ctx][An execution context that will provide the executor to be used to schedule the new thread of execution.]]

[[a][The [link boost_asio.reference.awaitable `awaitable`] object that is the result of calling the coroutine's entry point function.]]

[[token][The completion token that will handle the notification that the thread of execution has completed. The function signature of the completion handler must be: 
``
   void handler(std::exception_ptr); 
``
]]

]


[heading Example]
  


   boost::asio::awaitable<void> echo(tcp::socket socket)
   {
     try
     {
       char data[1024];
       for (;;)
       {
         std::size_t n = co_await socket.async_read_some(
             boost::asio::buffer(data), boost::asio::use_awaitable);

         co_await boost::asio::async_write(socket,
             boost::asio::buffer(data, n), boost::asio::use_awaitable);
       }
     }
     catch (const std::exception& e)
     {
       std::cerr << "Exception: " << e.what() << "\n";
     }
   }

   // ...

   boost::asio::co_spawn(my_io_context,
     echo(std::move(my_tcp_socket)),
     boost::asio::detached);





[heading Per-Operation Cancellation]
  
The new thread of execution is created with a cancellation state that supports `cancellation_type::terminal` values only. To change the cancellation state, call [link boost_asio.reference.this_coro__reset_cancellation_state `this_coro::reset_cancellation_state`]. 




[endsect]



[section:overload5 co_spawn (5 of 6 overloads)]


Spawn a new coroutined-based thread of execution. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename F,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` co_spawn(
      const Executor & ex,
      F && f,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);



[heading Parameters]
    

[variablelist
  
[[ex][The executor that will be used to schedule the new thread of execution.]]

[[f][A nullary function object with a return type of the form `boost::asio::awaitable<R,E>` that will be used as the coroutine's entry point.]]

[[token][The completion token that will handle the notification that the thread of execution has completed. If `R` is `void`, the function signature of the completion handler must be:]]

]



   void handler(std::exception_ptr); 


Otherwise, the function signature of the completion handler must be: 

   void handler(std::exception_ptr, R); 





[heading Example]
  


   boost::asio::awaitable<std::size_t> echo(tcp::socket socket)
   {
     std::size_t bytes_transferred = 0;

     try
     {
       char data[1024];
       for (;;)
       {
         std::size_t n = co_await socket.async_read_some(
             boost::asio::buffer(data), boost::asio::use_awaitable);

         co_await boost::asio::async_write(socket,
             boost::asio::buffer(data, n), boost::asio::use_awaitable);

         bytes_transferred += n;
       }
     }
     catch (const std::exception&)
     {
     }

     co_return bytes_transferred;
   }

   // ...

   boost::asio::co_spawn(my_executor,
     [socket = std::move(my_tcp_socket)]() mutable
       -> boost::asio::awaitable<void>
     {
       try
       {
         char data[1024];
         for (;;)
         {
           std::size_t n = co_await socket.async_read_some(
               boost::asio::buffer(data), boost::asio::use_awaitable);

           co_await boost::asio::async_write(socket,
               boost::asio::buffer(data, n), boost::asio::use_awaitable);
         }
       }
       catch (const std::exception& e)
       {
         std::cerr << "Exception: " << e.what() << "\n";
       }
     }, boost::asio::detached);





[heading Per-Operation Cancellation]
  
The new thread of execution is created with a cancellation state that supports `cancellation_type::terminal` values only. To change the cancellation state, call [link boost_asio.reference.this_coro__reset_cancellation_state `this_coro::reset_cancellation_state`]. 




[endsect]



[section:overload6 co_spawn (6 of 6 overloads)]


Spawn a new coroutined-based thread of execution. 


  template<
      typename ExecutionContext,
      typename F,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` co_spawn(
      ExecutionContext & ctx,
      F && f,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[heading Parameters]
    

[variablelist
  
[[ctx][An execution context that will provide the executor to be used to schedule the new thread of execution.]]

[[f][A nullary function object with a return type of the form `boost::asio::awaitable<R,E>` that will be used as the coroutine's entry point.]]

[[token][The completion token that will handle the notification that the thread of execution has completed. If `R` is `void`, the function signature of the completion handler must be:]]

]



   void handler(std::exception_ptr); 


Otherwise, the function signature of the completion handler must be: 

   void handler(std::exception_ptr, R); 





[heading Example]
  


   boost::asio::awaitable<std::size_t> echo(tcp::socket socket)
   {
     std::size_t bytes_transferred = 0;

     try
     {
       char data[1024];
       for (;;)
       {
         std::size_t n = co_await socket.async_read_some(
             boost::asio::buffer(data), boost::asio::use_awaitable);

         co_await boost::asio::async_write(socket,
             boost::asio::buffer(data, n), boost::asio::use_awaitable);

         bytes_transferred += n;
       }
     }
     catch (const std::exception&)
     {
     }

     co_return bytes_transferred;
   }

   // ...

   boost::asio::co_spawn(my_io_context,
     [socket = std::move(my_tcp_socket)]() mutable
       -> boost::asio::awaitable<void>
     {
       try
       {
         char data[1024];
         for (;;)
         {
           std::size_t n = co_await socket.async_read_some(
               boost::asio::buffer(data), boost::asio::use_awaitable);

           co_await boost::asio::async_write(socket,
               boost::asio::buffer(data, n), boost::asio::use_awaitable);
         }
       }
       catch (const std::exception& e)
       {
         std::cerr << "Exception: " << e.what() << "\n";
       }
     }, boost::asio::detached);





[heading Per-Operation Cancellation]
  
The new thread of execution is created with a cancellation state that supports `cancellation_type::terminal` values only. To change the cancellation state, call [link boost_asio.reference.this_coro__reset_cancellation_state `this_coro::reset_cancellation_state`]. 




[endsect]


[endsect]

[section:connect connect]

[indexterm1 boost_asio.indexterm.connect..connect] 
The `connect` function is a composed operation that establishes a socket connection by trying each endpoint in a sequence. 


Establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``>
  Protocol::endpoint ``[link boost_asio.reference.connect.overload1 connect]``(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.connect.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``>
  Protocol::endpoint ``[link boost_asio.reference.connect.overload2 connect]``(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      boost::system::error_code & ec,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.connect.overload2 more...]]``

(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator>
  Iterator ``[link boost_asio.reference.connect.overload3 connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.connect.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator>
  Iterator ``[link boost_asio.reference.connect.overload4 connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      boost::system::error_code & ec,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.connect.overload4 more...]]``

Establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator>
  Iterator ``[link boost_asio.reference.connect.overload5 connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end);
  ``  [''''&raquo;''' [link boost_asio.reference.connect.overload5 more...]]``

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator>
  Iterator ``[link boost_asio.reference.connect.overload6 connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.connect.overload6 more...]]``

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``>
  Protocol::endpoint ``[link boost_asio.reference.connect.overload7 connect]``(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.connect.overload7 more...]]``

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``>
  Protocol::endpoint ``[link boost_asio.reference.connect.overload8 connect]``(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      boost::system::error_code & ec,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.connect.overload8 more...]]``

(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``>
  Iterator ``[link boost_asio.reference.connect.overload9 connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      ConnectCondition connect_condition,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.connect.overload9 more...]]``

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``>
  Iterator ``[link boost_asio.reference.connect.overload10 connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      ConnectCondition connect_condition,
      boost::system::error_code & ec,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.connect.overload10 more...]]``

Establishes a socket connection by trying each endpoint in a sequence. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``>
  Iterator ``[link boost_asio.reference.connect.overload11 connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition);
  ``  [''''&raquo;''' [link boost_asio.reference.connect.overload11 more...]]``

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``>
  Iterator ``[link boost_asio.reference.connect.overload12 connect]``(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.connect.overload12 more...]]``

[heading Requirements]

['Header: ][^boost/asio/connect.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 connect (1 of 12 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``>
  Protocol::endpoint connect(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

]


[heading Return Value]
      
The successfully connected endpoint.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]

]


[heading Example]
  


   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(my_context);
   boost::asio::connect(s, r.resolve(q)); 







[endsect]



[section:overload2 connect (2 of 12 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``>
  Protocol::endpoint connect(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      boost::system::error_code & ec,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]

]


[heading Return Value]
      
On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint.


[heading Example]
  


   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(my_context);
   boost::system::error_code ec;
   boost::asio::connect(s, r.resolve(q), ec);
   if (ec)
   {
     // An error occurred.
   } 







[endsect]



[section:overload3 connect (3 of 12 overloads)]


(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator>
  Iterator connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

]


[heading Return Value]
      
On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]

]


[heading Remarks]
      
This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`. 




[endsect]



[section:overload4 connect (4 of 12 overloads)]


(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator>
  Iterator connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      boost::system::error_code & ec,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]

]


[heading Return Value]
      
On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.


[heading Remarks]
      
This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`. 




[endsect]



[section:overload5 connect (5 of 12 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator>
  Iterator connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

]


[heading Return Value]
      
An iterator denoting the successfully connected endpoint.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]

]


[heading Example]
  


   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::resolver::results_type e = r.resolve(q);
   tcp::socket s(my_context);
   boost::asio::connect(s, e.begin(), e.end()); 







[endsect]



[section:overload6 connect (6 of 12 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator>
  Iterator connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      boost::system::error_code & ec);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]

]


[heading Return Value]
      
On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.


[heading Example]
  


   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::resolver::results_type e = r.resolve(q);
   tcp::socket s(my_context);
   boost::system::error_code ec;
   boost::asio::connect(s, e.begin(), e.end(), ec);
   if (ec)
   {
     // An error occurred.
   } 







[endsect]



[section:overload7 connect (7 of 12 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``>
  Protocol::endpoint connect(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const boost::system::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

]


[heading Return Value]
      
The successfully connected endpoint.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]

]


[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const boost::system::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the `boost::asio::connect` function as follows: 

   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(my_context);
   tcp::endpoint e = boost::asio::connect(s,
       r.resolve(q), my_connect_condition());
   std::cout << "Connected to: " << e << std::endl; 







[endsect]



[section:overload8 connect (8 of 12 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.EndpointSequence EndpointSequence]``,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``>
  Protocol::endpoint connect(
      basic_socket< Protocol, Executor > & s,
      const EndpointSequence & endpoints,
      ConnectCondition connect_condition,
      boost::system::error_code & ec,
      typename constraint< is_endpoint_sequence< EndpointSequence >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[endpoints][A sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const boost::system::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]

]


[heading Return Value]
      
On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint.


[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const boost::system::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the `boost::asio::connect` function as follows: 

   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::socket s(my_context);
   boost::system::error_code ec;
   tcp::endpoint e = boost::asio::connect(s,
       r.resolve(q), my_connect_condition(), ec);
   if (ec)
   {
     // An error occurred.
   }
   else
   {
     std::cout << "Connected to: " << e << std::endl;
   } 







[endsect]



[section:overload9 connect (9 of 12 overloads)]


(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``>
  Iterator connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      ConnectCondition connect_condition,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const boost::system::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

]


[heading Return Value]
      
On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]

]


[heading Remarks]
      
This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`. 




[endsect]



[section:overload10 connect (10 of 12 overloads)]


(Deprecated: Use range overload.) Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``>
  Iterator connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      ConnectCondition connect_condition,
      boost::system::error_code & ec,
      typename constraint<!is_endpoint_sequence< Iterator >::value >::type  = 0);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const boost::system::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]

]


[heading Return Value]
      
On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.


[heading Remarks]
      
This overload assumes that a default constructed object of type `Iterator` represents the end of the sequence. This is a valid assumption for iterator types such as `boost::asio::ip::tcp::resolver::iterator`. 




[endsect]



[section:overload11 connect (11 of 12 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``>
  Iterator connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const boost::system::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

]


[heading Return Value]
      
An iterator denoting the successfully connected endpoint.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the sequence is empty, the associated `error_code` is `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]

]


[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const boost::system::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the `boost::asio::connect` function as follows: 

   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::resolver::results_type e = r.resolve(q);
   tcp::socket s(my_context);
   tcp::resolver::results_type::iterator i = boost::asio::connect(
       s, e.begin(), e.end(), my_connect_condition());
   std::cout << "Connected to: " << i->endpoint() << std::endl; 







[endsect]



[section:overload12 connect (12 of 12 overloads)]


Establishes a socket connection by trying each endpoint in a sequence. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Iterator,
      typename ``[link boost_asio.reference.ConnectCondition ConnectCondition]``>
  Iterator connect(
      basic_socket< Protocol, Executor > & s,
      Iterator begin,
      Iterator end,
      ConnectCondition connect_condition,
      boost::system::error_code & ec);


This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's `connect` member function, once for each endpoint in the sequence, until a connection is successfully established.


[heading Parameters]
    

[variablelist
  
[[s][The socket to be connected. If the socket is already open, it will be closed.]]

[[begin][An iterator pointing to the start of a sequence of endpoints.]]

[[end][An iterator pointing to the end of a sequence of endpoints.]]

[[connect_condition][A function object that is called prior to each connection attempt. The signature of the function object must be: 
``
   bool connect_condition(
       const boost::system::error_code& ec,
       const typename Protocol::endpoint& next); 
``
The `ec` parameter contains the result from the most recent connect operation. Before the first connection attempt, `ec` is always set to indicate success. The `next` parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.]]

[[ec][Set to indicate what error occurred, if any. If the sequence is empty, set to `boost::asio::error::not_found`. Otherwise, contains the error from the last connection attempt.]]

]


[heading Return Value]
      
On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.


[heading Example]
  
The following connect condition function object can be used to output information about the individual connection attempts: 

   struct my_connect_condition
   {
     bool operator()(
         const boost::system::error_code& ec,
         const::tcp::endpoint& next)
     {
       if (ec) std::cout << "Error: " << ec.message() << std::endl;
       std::cout << "Trying: " << next << std::endl;
       return true;
     }
   }; 


It would be used with the `boost::asio::connect` function as follows: 

   tcp::resolver r(my_context);
   tcp::resolver::query q("host", "service");
   tcp::resolver::results_type e = r.resolve(q);
   tcp::socket s(my_context);
   boost::system::error_code ec;
   tcp::resolver::results_type::iterator i = boost::asio::connect(
       s, e.begin(), e.end(), my_connect_condition());
   if (ec)
   {
     // An error occurred.
   }
   else
   {
     std::cout << "Connected to: " << i->endpoint() << std::endl;
   } 







[endsect]


[endsect]

[section:connect_pipe connect_pipe]

[indexterm1 boost_asio.indexterm.connect_pipe..connect_pipe] 
Connect two pipe ends using an anonymous pipe. 

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.Executor1 Executor2]``>
  void ``[link boost_asio.reference.connect_pipe.overload1 connect_pipe]``(
      basic_readable_pipe< Executor1 > & read_end,
      basic_writable_pipe< Executor2 > & write_end);
  ``  [''''&raquo;''' [link boost_asio.reference.connect_pipe.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.Executor1 Executor2]``>
  void ``[link boost_asio.reference.connect_pipe.overload2 connect_pipe]``(
      basic_readable_pipe< Executor1 > & read_end,
      basic_writable_pipe< Executor2 > & write_end,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.connect_pipe.overload2 more...]]``

[heading Requirements]

['Header: ][^boost/asio/connect_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 connect_pipe (1 of 2 overloads)]


Connect two pipe ends using an anonymous pipe. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.Executor1 Executor2]``>
  void connect_pipe(
      basic_readable_pipe< Executor1 > & read_end,
      basic_writable_pipe< Executor2 > & write_end);



[heading Parameters]
    

[variablelist
  
[[read_end][The read end of the pipe.]]

[[write_end][The write end of the pipe.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 connect_pipe (2 of 2 overloads)]


Connect two pipe ends using an anonymous pipe. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.Executor1 Executor2]``>
  void connect_pipe(
      basic_readable_pipe< Executor1 > & read_end,
      basic_writable_pipe< Executor2 > & write_end,
      boost::system::error_code & ec);



[heading Parameters]
    

[variablelist
  
[[read_end][The read end of the pipe.]]

[[write_end][The write end of the pipe.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:const_buffer const_buffer]

[indexterm1 boost_asio.indexterm.const_buffer..const_buffer]


Holds a buffer that cannot be modified. 


  class const_buffer


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.const_buffer.const_buffer [*const_buffer]] [constructor]]
    [Construct an empty buffer. 
     [hr]
     Construct a buffer to represent a given memory range. 
     [hr]
     Construct a non-modifiable buffer from a modifiable one. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.const_buffer.operator_plus_ [*operator+]]]
    [Create a new non-modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link boost_asio.reference.const_buffer `const_buffer`] class provides a safe representation of a buffer that cannot be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   boost::asio::const_buffer b1 = ...;
   std::size_t s1 = b1.size();
   const unsigned char* p1 = static_cast<const unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:const_buffer const_buffer::const_buffer]

[indexterm2 boost_asio.indexterm.const_buffer.const_buffer..const_buffer..const_buffer] 
Construct an empty buffer. 


  ``[link boost_asio.reference.const_buffer.const_buffer.overload1 const_buffer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.const_buffer.const_buffer.overload1 more...]]``


Construct a buffer to represent a given memory range. 


  ``[link boost_asio.reference.const_buffer.const_buffer.overload2 const_buffer]``(
      const void * data,
      std::size_t size);
  ``  [''''&raquo;''' [link boost_asio.reference.const_buffer.const_buffer.overload2 more...]]``


Construct a non-modifiable buffer from a modifiable one. 


  ``[link boost_asio.reference.const_buffer.const_buffer.overload3 const_buffer]``(
      const mutable_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.const_buffer.const_buffer.overload3 more...]]``


[section:overload1 const_buffer::const_buffer (1 of 3 overloads)]


Construct an empty buffer. 


  const_buffer();



[endsect]



[section:overload2 const_buffer::const_buffer (2 of 3 overloads)]


Construct a buffer to represent a given memory range. 


  const_buffer(
      const void * data,
      std::size_t size);



[endsect]



[section:overload3 const_buffer::const_buffer (3 of 3 overloads)]


Construct a non-modifiable buffer from a modifiable one. 


  const_buffer(
      const mutable_buffer & b);



[endsect]


[endsect]


[section:data const_buffer::data]

[indexterm2 boost_asio.indexterm.const_buffer.data..data..const_buffer] 
Get a pointer to the beginning of the memory range. 


  const void * data() const;



[endsect]


[section:operator_plus_ const_buffer::operator+]

[indexterm2 boost_asio.indexterm.const_buffer.operator_plus_..operator+..const_buffer] 
Create a new non-modifiable buffer that is offset from the start of another. 


  const_buffer ``[link boost_asio.reference.const_buffer.operator_plus_.overload1 operator+]``(
      const const_buffer & b,
      std::size_t n);
  ``  [''''&raquo;''' [link boost_asio.reference.const_buffer.operator_plus_.overload1 more...]]``

  const_buffer ``[link boost_asio.reference.const_buffer.operator_plus_.overload2 operator+]``(
      std::size_t n,
      const const_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.const_buffer.operator_plus_.overload2 more...]]``


[section:overload1 const_buffer::operator+ (1 of 2 overloads)]


Create a new non-modifiable buffer that is offset from the start of another. 


  const_buffer operator+(
      const const_buffer & b,
      std::size_t n);



[endsect]



[section:overload2 const_buffer::operator+ (2 of 2 overloads)]


Create a new non-modifiable buffer that is offset from the start of another. 


  const_buffer operator+(
      std::size_t n,
      const const_buffer & b);



[endsect]


[endsect]


[section:operator_plus__eq_ const_buffer::operator+=]

[indexterm2 boost_asio.indexterm.const_buffer.operator_plus__eq_..operator+=..const_buffer] 
Move the start of the buffer by the specified number of bytes. 


  const_buffer & operator+=(
      std::size_t n);



[endsect]



[section:size const_buffer::size]

[indexterm2 boost_asio.indexterm.const_buffer.size..size..const_buffer] 
Get the size of the memory range. 


  std::size_t size() const;



[endsect]



[endsect]

[section:const_buffers_1 const_buffers_1]

[indexterm1 boost_asio.indexterm.const_buffers_1..const_buffers_1]


(Deprecated: Use [link boost_asio.reference.const_buffer `const_buffer`].) Adapts a single non-modifiable buffer so that it meets the requirements of the ConstBufferSequence concept. 


  class const_buffers_1 :
    public const_buffer


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.const_buffers_1.const_iterator [*const_iterator]]]
    [A random-access iterator type that may be used to read elements. ]
  
  ]

  [

    [[link boost_asio.reference.const_buffers_1.value_type [*value_type]]]
    [The type for each element in the list of buffers. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.const_buffers_1.begin [*begin]]]
    [Get a random-access iterator to the first element. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffers_1.const_buffers_1 [*const_buffers_1]] [constructor]]
    [Construct to represent a given memory range. 
     [hr]
     Construct to represent a single non-modifiable buffer. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffers_1.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffers_1.end [*end]]]
    [Get a random-access iterator for one past the last element. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffers_1.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffers_1.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.const_buffers_1.operator_plus_ [*operator+]]]
    [Create a new non-modifiable buffer that is offset from the start of another. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:begin const_buffers_1::begin]

[indexterm2 boost_asio.indexterm.const_buffers_1.begin..begin..const_buffers_1] 
Get a random-access iterator to the first element. 


  const_iterator begin() const;



[endsect]


[section:const_buffers_1 const_buffers_1::const_buffers_1]

[indexterm2 boost_asio.indexterm.const_buffers_1.const_buffers_1..const_buffers_1..const_buffers_1] 
Construct to represent a given memory range. 


  ``[link boost_asio.reference.const_buffers_1.const_buffers_1.overload1 const_buffers_1]``(
      const void * data,
      std::size_t size);
  ``  [''''&raquo;''' [link boost_asio.reference.const_buffers_1.const_buffers_1.overload1 more...]]``


Construct to represent a single non-modifiable buffer. 


  explicit ``[link boost_asio.reference.const_buffers_1.const_buffers_1.overload2 const_buffers_1]``(
      const const_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.const_buffers_1.const_buffers_1.overload2 more...]]``


[section:overload1 const_buffers_1::const_buffers_1 (1 of 2 overloads)]


Construct to represent a given memory range. 


  const_buffers_1(
      const void * data,
      std::size_t size);



[endsect]



[section:overload2 const_buffers_1::const_buffers_1 (2 of 2 overloads)]


Construct to represent a single non-modifiable buffer. 


  const_buffers_1(
      const const_buffer & b);



[endsect]


[endsect]


[section:const_iterator const_buffers_1::const_iterator]

[indexterm2 boost_asio.indexterm.const_buffers_1.const_iterator..const_iterator..const_buffers_1] 
A random-access iterator type that may be used to read elements. 


  typedef const const_buffer * const_iterator;



[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:data const_buffers_1::data]


['Inherited from const_buffer.]

[indexterm2 boost_asio.indexterm.const_buffers_1.data..data..const_buffers_1] 
Get a pointer to the beginning of the memory range. 


  const void * data() const;



[endsect]



[section:end const_buffers_1::end]

[indexterm2 boost_asio.indexterm.const_buffers_1.end..end..const_buffers_1] 
Get a random-access iterator for one past the last element. 


  const_iterator end() const;



[endsect]


[section:operator_plus_ const_buffers_1::operator+]

[indexterm2 boost_asio.indexterm.const_buffers_1.operator_plus_..operator+..const_buffers_1] 
Create a new non-modifiable buffer that is offset from the start of another. 


  const_buffer ``[link boost_asio.reference.const_buffers_1.operator_plus_.overload1 operator+]``(
      const const_buffer & b,
      std::size_t n);
  ``  [''''&raquo;''' [link boost_asio.reference.const_buffers_1.operator_plus_.overload1 more...]]``

  const_buffer ``[link boost_asio.reference.const_buffers_1.operator_plus_.overload2 operator+]``(
      std::size_t n,
      const const_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.const_buffers_1.operator_plus_.overload2 more...]]``


[section:overload1 const_buffers_1::operator+ (1 of 2 overloads)]


['Inherited from const_buffer.]


Create a new non-modifiable buffer that is offset from the start of another. 


  const_buffer operator+(
      const const_buffer & b,
      std::size_t n);



[endsect]



[section:overload2 const_buffers_1::operator+ (2 of 2 overloads)]


['Inherited from const_buffer.]


Create a new non-modifiable buffer that is offset from the start of another. 


  const_buffer operator+(
      std::size_t n,
      const const_buffer & b);



[endsect]


[endsect]


[section:operator_plus__eq_ const_buffers_1::operator+=]


['Inherited from const_buffer.]

[indexterm2 boost_asio.indexterm.const_buffers_1.operator_plus__eq_..operator+=..const_buffers_1] 
Move the start of the buffer by the specified number of bytes. 


  const_buffer & operator+=(
      std::size_t n);



[endsect]



[section:size const_buffers_1::size]


['Inherited from const_buffer.]

[indexterm2 boost_asio.indexterm.const_buffers_1.size..size..const_buffers_1] 
Get the size of the memory range. 


  std::size_t size() const;



[endsect]



[section:value_type const_buffers_1::value_type]

[indexterm2 boost_asio.indexterm.const_buffers_1.value_type..value_type..const_buffers_1] 
The type for each element in the list of buffers. 


  typedef const_buffer value_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.const_buffer.const_buffer [*const_buffer]] [constructor]]
    [Construct an empty buffer. 
     [hr]
     Construct a buffer to represent a given memory range. 
     [hr]
     Construct a non-modifiable buffer from a modifiable one. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.const_buffer.operator_plus_ [*operator+]]]
    [Create a new non-modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link boost_asio.reference.const_buffer `const_buffer`] class provides a safe representation of a buffer that cannot be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   boost::asio::const_buffer b1 = ...;
   std::size_t s1 = b1.size();
   const unsigned char* p1 = static_cast<const unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 


[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:const_registered_buffer const_registered_buffer]

[indexterm1 boost_asio.indexterm.const_registered_buffer..const_registered_buffer]


Holds a registered buffer over non-modifiable data. 


  class const_registered_buffer


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.const_registered_buffer.buffer [*buffer]]]
    [Get the underlying constant buffer. ]
  ]
  
  [
    [[link boost_asio.reference.const_registered_buffer.const_registered_buffer [*const_registered_buffer]] [constructor]]
    [Default constructor creates an invalid registered buffer. 
     [hr]
     Construct a non-modifiable buffer from a modifiable one. ]
  ]
  
  [
    [[link boost_asio.reference.const_registered_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link boost_asio.reference.const_registered_buffer.id [*id]]]
    [Get the registered buffer identifier. ]
  ]
  
  [
    [[link boost_asio.reference.const_registered_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.const_registered_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.const_registered_buffer.operator_plus_ [*operator+]]]
    [Create a new non-modifiable registered buffer that is offset from the start of another. 

     Create a new non-modifiable buffer that is offset from the start of another. ]
  ]
  
]

Satisfies the `ConstBufferSequence` type requirements. 

[heading Requirements]

['Header: ][^boost/asio/registered_buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:buffer const_registered_buffer::buffer]

[indexterm2 boost_asio.indexterm.const_registered_buffer.buffer..buffer..const_registered_buffer] 
Get the underlying constant buffer. 


  const const_buffer & buffer() const;



[endsect]


[section:const_registered_buffer const_registered_buffer::const_registered_buffer]

[indexterm2 boost_asio.indexterm.const_registered_buffer.const_registered_buffer..const_registered_buffer..const_registered_buffer] 
Default constructor creates an invalid registered buffer. 


  ``[link boost_asio.reference.const_registered_buffer.const_registered_buffer.overload1 const_registered_buffer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.const_registered_buffer.const_registered_buffer.overload1 more...]]``


Construct a non-modifiable buffer from a modifiable one. 


  ``[link boost_asio.reference.const_registered_buffer.const_registered_buffer.overload2 const_registered_buffer]``(
      const mutable_registered_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.const_registered_buffer.const_registered_buffer.overload2 more...]]``


[section:overload1 const_registered_buffer::const_registered_buffer (1 of 2 overloads)]


Default constructor creates an invalid registered buffer. 


  const_registered_buffer();



[endsect]



[section:overload2 const_registered_buffer::const_registered_buffer (2 of 2 overloads)]


Construct a non-modifiable buffer from a modifiable one. 


  const_registered_buffer(
      const mutable_registered_buffer & b);



[endsect]


[endsect]


[section:data const_registered_buffer::data]

[indexterm2 boost_asio.indexterm.const_registered_buffer.data..data..const_registered_buffer] 
Get a pointer to the beginning of the memory range. 


  const void * data() const;



[heading Return Value]
      
`buffer().data()`. 




[endsect]



[section:id const_registered_buffer::id]

[indexterm2 boost_asio.indexterm.const_registered_buffer.id..id..const_registered_buffer] 
Get the registered buffer identifier. 


  const registered_buffer_id & id() const;



[endsect]


[section:operator_plus_ const_registered_buffer::operator+]

[indexterm2 boost_asio.indexterm.const_registered_buffer.operator_plus_..operator+..const_registered_buffer] 
Create a new non-modifiable registered buffer that is offset from the start of another. 


  const_registered_buffer ``[link boost_asio.reference.const_registered_buffer.operator_plus_.overload1 operator+]``(
      const const_registered_buffer & b,
      std::size_t n);
  ``  [''''&raquo;''' [link boost_asio.reference.const_registered_buffer.operator_plus_.overload1 more...]]``


Create a new non-modifiable buffer that is offset from the start of another. 


  const_registered_buffer ``[link boost_asio.reference.const_registered_buffer.operator_plus_.overload2 operator+]``(
      std::size_t n,
      const const_registered_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.const_registered_buffer.operator_plus_.overload2 more...]]``


[section:overload1 const_registered_buffer::operator+ (1 of 2 overloads)]


Create a new non-modifiable registered buffer that is offset from the start of another. 


  const_registered_buffer operator+(
      const const_registered_buffer & b,
      std::size_t n);



[endsect]



[section:overload2 const_registered_buffer::operator+ (2 of 2 overloads)]


Create a new non-modifiable buffer that is offset from the start of another. 


  const_registered_buffer operator+(
      std::size_t n,
      const const_registered_buffer & b);



[endsect]


[endsect]


[section:operator_plus__eq_ const_registered_buffer::operator+=]

[indexterm2 boost_asio.indexterm.const_registered_buffer.operator_plus__eq_..operator+=..const_registered_buffer] 
Move the start of the buffer by the specified number of bytes. 


  const_registered_buffer & operator+=(
      std::size_t n);



[endsect]



[section:size const_registered_buffer::size]

[indexterm2 boost_asio.indexterm.const_registered_buffer.size..size..const_registered_buffer] 
Get the size of the memory range. 


  std::size_t size() const;



[heading Return Value]
      
`buffer().size()`. 




[endsect]



[endsect]

[section:coroutine coroutine]

[indexterm1 boost_asio.indexterm.coroutine..coroutine]


Provides support for implementing stackless coroutines. 


  class coroutine


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.coroutine.coroutine [*coroutine]] [constructor]]
    [Constructs a coroutine in its initial state. ]
  ]
  
  [
    [[link boost_asio.reference.coroutine.is_child [*is_child]]]
    [Returns true if the coroutine is the child of a fork. ]
  ]
  
  [
    [[link boost_asio.reference.coroutine.is_complete [*is_complete]]]
    [Returns true if the coroutine has reached its terminal state. ]
  ]
  
  [
    [[link boost_asio.reference.coroutine.is_parent [*is_parent]]]
    [Returns true if the coroutine is the parent of a fork. ]
  ]
  
]

The `coroutine` class may be used to implement stackless coroutines. The class itself is used to store the current state of the coroutine.

Coroutines are copy-constructible and assignable, and the space overhead is a single int. They can be used as a base class:



   class session : coroutine
   {
     ...
   }; 




or as a data member:



   class session
   {
     ...
     coroutine coro_;
   }; 




or even bound in as a function argument using lambdas or `bind()`. The important thing is that as the application maintains a copy of the object for as long as the coroutine must be kept alive.


[heading Pseudo-keywords]
  


A coroutine is used in conjunction with certain "pseudo-keywords", which are implemented as macros. These macros are defined by a header file:



   #include <boost/asio/yield.hpp>




and may conversely be undefined as follows:



   #include <boost/asio/unyield.hpp>




[*reenter]

The `reenter` macro is used to define the body of a coroutine. It takes a single argument: a pointer or reference to a coroutine object. For example, if the base class is a coroutine object you may write:



   reenter (this)
   {
     ... coroutine body ...
   } 




and if a data member or other variable you can write:



   reenter (coro_)
   {
     ... coroutine body ...
   } 




When `reenter` is executed at runtime, control jumps to the location of the last `yield` or `fork`.

The coroutine body may also be a single statement, such as:



   reenter (this) for (;;)
   {
     ...
   } 




[*Limitation:] The `reenter` macro is implemented using a switch. This means that you must take care when using local variables within the coroutine body. The local variable is not allowed in a position where reentering the coroutine could bypass the variable definition.

[*yield ['statement]]

This form of the `yield` keyword is often used with asynchronous operations:



   yield socket_->async_read_some(buffer(*buffer_), *this); 




This divides into four logical steps:


* `yield` saves the current state of the coroutine. 

* The statement initiates the asynchronous operation. 

* The resume point is defined immediately following the statement. 

* Control is transferred to the end of the coroutine body.

When the asynchronous operation completes, the function object is invoked and `reenter` causes control to transfer to the resume point. It is important to remember to carry the coroutine state forward with the asynchronous operation. In the above snippet, the current class is a function object object with a coroutine object as base class or data member.

The statement may also be a compound statement, and this permits us to define local variables with limited scope:



   yield
   {
     mutable_buffers_1 b = buffer(*buffer_);
     socket_->async_read_some(b, *this);
   } 




[*yield return ['expression] ;]

This form of `yield` is often used in generators or coroutine-based parsers. For example, the function object:



   struct interleave : coroutine
   {
     istream& is1;
     istream& is2;
     char operator()(char c)
     {
       reenter (this) for (;;)
       {
         yield return is1.get();
         yield return is2.get();
       }
     }
   }; 




defines a trivial coroutine that interleaves the characters from two input streams.

This type of `yield` divides into three logical steps:


* `yield` saves the current state of the coroutine. 

* The resume point is defined immediately following the semicolon. 

* The value of the expression is returned from the function.

[*yield ;]

This form of `yield` is equivalent to the following steps:


* `yield` saves the current state of the coroutine. 

* The resume point is defined immediately following the semicolon. 

* Control is transferred to the end of the coroutine body.

This form might be applied when coroutines are used for cooperative threading and scheduling is explicitly managed. For example:



   struct task : coroutine
   {
     ...
     void operator()()
     {
       reenter (this)
       {
         while (... not finished ...)
         {
           ... do something ...
           yield;
           ... do some more ...
           yield;
         }
       }
     }
     ...
   };
   ...
   task t1, t2;
   for (;;)
   {
     t1();
     t2();
   } 




[*yield break ;]

The final form of `yield` is used to explicitly terminate the coroutine. This form is comprised of two steps:


* `yield` sets the coroutine state to indicate termination. 

* Control is transferred to the end of the coroutine body.

Once terminated, calls to `is_complete()` return true and the coroutine cannot be reentered.

Note that a coroutine may also be implicitly terminated if the coroutine body is exited without a yield, e.g. by return, throw or by running to the end of the body.

[*fork ['statement]]

The `fork` pseudo-keyword is used when "forking" a coroutine, i.e. splitting it into two (or more) copies. One use of `fork` is in a server, where a new coroutine is created to handle each client connection:



   reenter (this)
   {
     do
     {
       socket_.reset(new tcp::socket(my_context_));
       yield acceptor->async_accept(*socket_, *this);
       fork server(*this)();
     } while (is_parent());
     ... client-specific handling follows ...
   } 




The logical steps involved in a `fork` are:


* `fork` saves the current state of the coroutine. 

* The statement creates a copy of the coroutine and either executes it immediately or schedules it for later execution. 

* The resume point is defined immediately following the semicolon. 

* For the "parent", control immediately continues from the next line.

The functions `is_parent()` and `is_child()` can be used to differentiate between parent and child. You would use these functions to alter subsequent control flow.

Note that `fork` doesn't do the actual forking by itself. It is the application's responsibility to create a clone of the coroutine and call it. The clone can be called immediately, as above, or scheduled for delayed execution using something like [link boost_asio.reference.post `post`].


[heading Alternate macro names]
  


If preferred, an application can use macro names that follow a more typical naming convention, rather than the pseudo-keywords. These are:


* `BOOST_ASIO_CORO_REENTER` instead of `reenter` 

* `BOOST_ASIO_CORO_YIELD` instead of `yield` 

* `BOOST_ASIO_CORO_FORK` instead of `fork` 



[heading Requirements]

['Header: ][^boost/asio/coroutine.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:coroutine coroutine::coroutine]

[indexterm2 boost_asio.indexterm.coroutine.coroutine..coroutine..coroutine] 
Constructs a coroutine in its initial state. 


  coroutine();



[endsect]



[section:is_child coroutine::is_child]

[indexterm2 boost_asio.indexterm.coroutine.is_child..is_child..coroutine] 
Returns true if the coroutine is the child of a fork. 


  bool is_child() const;



[endsect]



[section:is_complete coroutine::is_complete]

[indexterm2 boost_asio.indexterm.coroutine.is_complete..is_complete..coroutine] 
Returns true if the coroutine has reached its terminal state. 


  bool is_complete() const;



[endsect]



[section:is_parent coroutine::is_parent]

[indexterm2 boost_asio.indexterm.coroutine.is_parent..is_parent..coroutine] 
Returns true if the coroutine is the parent of a fork. 


  bool is_parent() const;



[endsect]



[endsect]


[section:deadline_timer deadline_timer]

[indexterm1 boost_asio.indexterm.deadline_timer..deadline_timer] 
Typedef for the typical usage of timer. Uses a UTC clock. 


  typedef basic_deadline_timer< boost::posix_time::ptime > deadline_timer;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_deadline_timer__rebind_executor [*rebind_executor]]]
    [Rebinds the timer type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_deadline_timer.duration_type [*duration_type]]]
    [The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_deadline_timer.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_deadline_timer.time_type [*time_type]]]
    [The time type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_deadline_timer.traits_type [*traits_type]]]
    [The time traits type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_deadline_timer.async_wait [*async_wait]]]
    [Start an asynchronous wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.basic_deadline_timer [*basic_deadline_timer]] [constructor]]
    [Constructor. 
     [hr]
     Constructor to set a particular expiry time as an absolute time. 
     [hr]
     Constructor to set a particular expiry time relative to now. 
     [hr]
     Move-construct a basic_deadline_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.cancel_one [*cancel_one]]]
    [Cancels one asynchronous operation that is waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.expires_at [*expires_at]]]
    [Get the timer's expiry time as an absolute time. 
     [hr]
     Set the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.expires_from_now [*expires_from_now]]]
    [Get the timer's expiry time relative to now. 
     [hr]
     Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.operator_eq_ [*operator=]]]
    [Move-assign a basic_deadline_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer.wait [*wait]]]
    [Perform a blocking wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_deadline_timer._basic_deadline_timer [*~basic_deadline_timer]] [destructor]]
    [Destroys the timer. ]
  ]
  
]

The [link boost_asio.reference.basic_deadline_timer `basic_deadline_timer`] class template provides the ability to perform a blocking or asynchronous wait for a timer to expire.

A deadline timer is always in one of two states: "expired" or "not expired". If the `wait()` or `async_wait()` function is called on an expired timer, the wait operation will complete immediately.

Most applications will use the [link boost_asio.reference.deadline_timer `deadline_timer`] typedef.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.


[heading Examples]
  
Performing a blocking wait: 

   // Construct a timer without setting an expiry time.
   boost::asio::deadline_timer timer(my_context);

   // Set an expiry time relative to now.
   timer.expires_from_now(boost::posix_time::seconds(5));

   // Wait for the timer to expire.
   timer.wait();





Performing an asynchronous wait: 

   void handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Timer expired.
     }
   }

   ...

   // Construct a timer with an absolute expiry time.
   boost::asio::deadline_timer timer(my_context,
       boost::posix_time::time_from_string("2005-12-07 23:59:59.000"));

   // Start an asynchronous wait.
   timer.async_wait(handler);





[heading Changing an active deadline_timer's expiry time]
  


Changing the expiry time of a timer while there are pending asynchronous waits causes those wait operations to be cancelled. To ensure that the action associated with the timer is performed only once, use something like this: used:



   void on_some_event()
   {
     if (my_timer.expires_from_now(seconds(5)) > 0)
     {
       // We managed to cancel the timer. Start new asynchronous wait.
       my_timer.async_wait(on_timeout);
     }
     else
     {
       // Too late, timer has already expired!
     }
   }

   void on_timeout(const boost::system::error_code& e)
   {
     if (e != boost::asio::error::operation_aborted)
     {
       // Timer was not cancelled, take necessary action.
     }
   }





* The `boost::asio::basic_deadline_timer::expires_from_now()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.


* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 




[heading Requirements]

['Header: ][^boost/asio/deadline_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:default_completion_token default_completion_token]

[indexterm1 boost_asio.indexterm.default_completion_token..default_completion_token]


Traits type used to determine the default completion token type associated with a type (such as an executor). 


  template<
      typename T>
  struct default_completion_token


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.default_completion_token.type [*type]]]
    [If T has a nested type default_completion_token_type, T::default_completion_token_type. Otherwise the typedef type is not defined. ]
  
  ]

]

A program may specialise this traits type if the `T` template parameter in the specialisation is a user-defined type.

Specialisations of this trait may provide a nested typedef `type`, which is a default-constructible completion token type. 

[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:type default_completion_token::type]

[indexterm2 boost_asio.indexterm.default_completion_token.type..type..default_completion_token] 
If `T` has a nested type `default_completion_token_type`, `T::default_completion_token_type`. Otherwise the typedef `type` is not defined. 


  typedef see_below type;



[heading Requirements]

['Header: ][^boost/asio/async_result.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:defer defer]

[indexterm1 boost_asio.indexterm.defer..defer] 
Submits a completion token or function object for execution. 

  template<
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.defer.overload1 defer]``(
      CompletionToken && token);
  ``  [''''&raquo;''' [link boost_asio.reference.defer.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.defer.overload2 defer]``(
      const Executor & ex,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< execution::is_executor< Executor >::value||is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.defer.overload2 more...]]``

  template<
      typename ExecutionContext,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.defer.overload3 defer]``(
      ExecutionContext & ctx,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.defer.overload3 more...]]``

[heading Requirements]

['Header: ][^boost/asio/defer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 defer (1 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` defer(
      CompletionToken && token);


This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from `defer()`.

The use of `defer()`, rather than [link boost_asio.reference.post `post`] , indicates the caller's preference that the executor defer the queueing of the function object. This may allow the executor to optimise queueing for cases when the function object represents a continuation of the current call context.

This function has the following effects:


* Constructs a function object handler of type `Handler`, initialized with `handler(forward<CompletionToken>(token))`.


* Constructs an object `result` of type `async_result<Handler>`, initializing the object as `result(handler)`.


* Obtains the handler's associated executor object `ex` by performing `get_associated_executor(handler)`.


* Obtains the handler's associated allocator object `alloc` by performing `get_associated_allocator(handler)`.


* Performs `ex.defer(std::move(handler), alloc)`.


* Returns `result.get()`. 




[endsect]



[section:overload2 defer (2 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` defer(
      const Executor & ex,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< execution::is_executor< Executor >::value||is_executor< Executor >::value >::type  = 0);


This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from `defer()`.

The use of `defer()`, rather than [link boost_asio.reference.post `post`] , indicates the caller's preference that the executor defer the queueing of the function object. This may allow the executor to optimise queueing for cases when the function object represents a continuation of the current call context.

This function has the following effects:


* Constructs a function object handler of type `Handler`, initialized with `handler(forward<CompletionToken>(token))`.


* Constructs an object `result` of type `async_result<Handler>`, initializing the object as `result(handler)`.


* Obtains the handler's associated executor object `ex1` by performing `get_associated_executor(handler)`.


* Creates a work object `w` by performing `make_work(ex1)`.


* Obtains the handler's associated allocator object `alloc` by performing `get_associated_allocator(handler)`.


* Constructs a function object `f` with a function call operator that performs `ex1.dispatch(std::move(handler), alloc)` followed by `w.reset()`.


* Performs `Executor(ex).defer(std::move(f), alloc)`.


* Returns `result.get()`. 




[endsect]



[section:overload3 defer (3 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename ExecutionContext,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` defer(
      ExecutionContext & ctx,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[heading Return Value]
      
`defer(ctx.get_executor(), forward<CompletionToken>(token))`. 




[endsect]


[endsect]


[section:detached detached]

[indexterm1 boost_asio.indexterm.detached..detached] 
A special value, similar to std::nothrow. 


  constexpr detached_t detached;


See the documentation for [link boost_asio.reference.detached_t `detached_t`] for a usage example. 

[heading Requirements]

['Header: ][^boost/asio/detached.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:detached_t detached_t]

[indexterm1 boost_asio.indexterm.detached_t..detached_t]


Class used to specify that an asynchronous operation is detached. 


  class detached_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.detached_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the detached_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.detached_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use detached_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.detached_t.detached_t [*detached_t]] [constructor]]
    [Constructor. ]
  ]
  
]

The [link boost_asio.reference.detached_t `detached_t`] class is used to indicate that an asynchronous operation is detached. That is, there is no completion handler waiting for the operation's result. A [link boost_asio.reference.detached_t `detached_t`] object may be passed as a handler to an asynchronous operation, typically using the special value `boost::asio::detached`. For example:



   my_socket.async_send(my_buffer, boost::asio::detached);




[heading Requirements]

['Header: ][^boost/asio/detached.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:as_default_on detached_t::as_default_on]

[indexterm2 boost_asio.indexterm.detached_t.as_default_on..as_default_on..detached_t] 
Function helper to adapt an I/O object to use `detached_t` as its default completion token type. 


  template<
      typename T>
  static decay< T >::type::template rebind_executor< executor_with_default< typename decay< T >::type::executor_type > >::other as_default_on(
      T && object);



[endsect]



[section:detached_t detached_t::detached_t]

[indexterm2 boost_asio.indexterm.detached_t.detached_t..detached_t..detached_t] 
Constructor. 


  constexpr detached_t();



[endsect]



[endsect]

[section:detached_t__executor_with_default detached_t::executor_with_default]

[indexterm1 boost_asio.indexterm.detached_t__executor_with_default..detached_t::executor_with_default]


Adapts an executor to add the `detached_t` completion token as the default. 


  template<
      typename ``[link boost_asio.reference.Executor1 InnerExecutor]``>
  struct executor_with_default


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.detached_t__executor_with_default.default_completion_token_type [*default_completion_token_type]]]
    [Specify detached_t as the default completion token type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.detached_t__executor_with_default.executor_with_default [*executor_with_default]] [constructor]]
    [Construct the adapted executor from the inner executor type. 
     [hr]
     Convert the specified executor to the inner executor type, then use that to construct the adapted executor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/detached.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:default_completion_token_type detached_t::executor_with_default::default_completion_token_type]

[indexterm2 boost_asio.indexterm.detached_t__executor_with_default.default_completion_token_type..default_completion_token_type..detached_t::executor_with_default] 
Specify `detached_t` as the default completion token type. 


  typedef detached_t default_completion_token_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.detached_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the detached_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.detached_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use detached_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.detached_t.detached_t [*detached_t]] [constructor]]
    [Constructor. ]
  ]
  
]

The [link boost_asio.reference.detached_t `detached_t`] class is used to indicate that an asynchronous operation is detached. That is, there is no completion handler waiting for the operation's result. A [link boost_asio.reference.detached_t `detached_t`] object may be passed as a handler to an asynchronous operation, typically using the special value `boost::asio::detached`. For example:



   my_socket.async_send(my_buffer, boost::asio::detached);





[heading Requirements]

['Header: ][^boost/asio/detached.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:executor_with_default detached_t::executor_with_default::executor_with_default]

[indexterm2 boost_asio.indexterm.detached_t__executor_with_default.executor_with_default..executor_with_default..detached_t::executor_with_default] 
Construct the adapted executor from the inner executor type. 


  ``[link boost_asio.reference.detached_t__executor_with_default.executor_with_default.overload1 executor_with_default]``(
      const InnerExecutor & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.detached_t__executor_with_default.executor_with_default.overload1 more...]]``


Convert the specified executor to the inner executor type, then use that to construct the adapted executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  ``[link boost_asio.reference.detached_t__executor_with_default.executor_with_default.overload2 executor_with_default]``(
      const OtherExecutor & ex,
      typename constraint< is_convertible< OtherExecutor, InnerExecutor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.detached_t__executor_with_default.executor_with_default.overload2 more...]]``


[section:overload1 detached_t::executor_with_default::executor_with_default (1 of 2 overloads)]


Construct the adapted executor from the inner executor type. 


  executor_with_default(
      const InnerExecutor & ex);



[endsect]



[section:overload2 detached_t::executor_with_default::executor_with_default (2 of 2 overloads)]


Convert the specified executor to the inner executor type, then use that to construct the adapted executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  executor_with_default(
      const OtherExecutor & ex,
      typename constraint< is_convertible< OtherExecutor, InnerExecutor >::value >::type  = 0);



[endsect]


[endsect]


[endsect]


[section:disable_cancellation disable_cancellation]

[indexterm1 boost_asio.indexterm.disable_cancellation..disable_cancellation] 
A cancellation filter that disables cancellation. 


  typedef cancellation_filter< cancellation_type::none > disable_cancellation;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.cancellation_filter.operator_lp__rp_ [*operator()]]]
    [Returns type & Mask. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/cancellation_state.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:dispatch dispatch]

[indexterm1 boost_asio.indexterm.dispatch..dispatch] 
Submits a completion token or function object for execution. 

  template<
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.dispatch.overload1 dispatch]``(
      CompletionToken && token);
  ``  [''''&raquo;''' [link boost_asio.reference.dispatch.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.dispatch.overload2 dispatch]``(
      const Executor & ex,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< execution::is_executor< Executor >::value||is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.dispatch.overload2 more...]]``

  template<
      typename ExecutionContext,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.dispatch.overload3 dispatch]``(
      ExecutionContext & ctx,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.dispatch.overload3 more...]]``

[heading Requirements]

['Header: ][^boost/asio/dispatch.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 dispatch (1 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` dispatch(
      CompletionToken && token);


This function submits an object for execution using the object's associated executor. The function object may be called from the current thread prior to returning from `dispatch()`. Otherwise, it is queued for execution.

This function has the following effects:


* Constructs a function object handler of type `Handler`, initialized with `handler(forward<CompletionToken>(token))`.


* Constructs an object `result` of type `async_result<Handler>`, initializing the object as `result(handler)`.


* Obtains the handler's associated executor object `ex` by performing `get_associated_executor(handler)`.


* Obtains the handler's associated allocator object `alloc` by performing `get_associated_allocator(handler)`.


* Performs `ex.dispatch(std::move(handler), alloc)`.


* Returns `result.get()`. 




[endsect]



[section:overload2 dispatch (2 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` dispatch(
      const Executor & ex,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< execution::is_executor< Executor >::value||is_executor< Executor >::value >::type  = 0);


This function submits an object for execution using the specified executor. The function object may be called from the current thread prior to returning from `dispatch()`. Otherwise, it is queued for execution.

This function has the following effects:


* Constructs a function object handler of type `Handler`, initialized with `handler(forward<CompletionToken>(token))`.


* Constructs an object `result` of type `async_result<Handler>`, initializing the object as `result(handler)`.


* Obtains the handler's associated executor object `ex1` by performing `get_associated_executor(handler)`.


* Creates a work object `w` by performing `make_work(ex1)`.


* Obtains the handler's associated allocator object `alloc` by performing `get_associated_allocator(handler)`.


* Constructs a function object `f` with a function call operator that performs `ex1.dispatch(std::move(handler), alloc)` followed by `w.reset()`.


* Performs `Executor(ex).dispatch(std::move(f), alloc)`.


* Returns `result.get()`. 




[endsect]



[section:overload3 dispatch (3 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename ExecutionContext,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` dispatch(
      ExecutionContext & ctx,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[heading Return Value]
      
`dispatch(ctx.get_executor(), forward<CompletionToken>(token))`. 




[endsect]


[endsect]

[section:dynamic_buffer dynamic_buffer]

[indexterm1 boost_asio.indexterm.dynamic_buffer..dynamic_buffer] 
The `boost::asio::dynamic_buffer` function is used to create a dynamically resized buffer from a `std::basic_string` or `std::vector`. 


Create a new dynamic buffer that represents the given string. 

  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  dynamic_string_buffer< Elem, Traits, Allocator > ``[link boost_asio.reference.dynamic_buffer.overload1 dynamic_buffer]``(
      std::basic_string< Elem, Traits, Allocator > & data);
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_buffer.overload1 more...]]``

  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  dynamic_string_buffer< Elem, Traits, Allocator > ``[link boost_asio.reference.dynamic_buffer.overload2 dynamic_buffer]``(
      std::basic_string< Elem, Traits, Allocator > & data,
      std::size_t max_size);
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_buffer.overload2 more...]]``

Create a new dynamic buffer that represents the given vector. 

  template<
      typename Elem,
      typename Allocator>
  dynamic_vector_buffer< Elem, Allocator > ``[link boost_asio.reference.dynamic_buffer.overload3 dynamic_buffer]``(
      std::vector< Elem, Allocator > & data);
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_buffer.overload3 more...]]``

  template<
      typename Elem,
      typename Allocator>
  dynamic_vector_buffer< Elem, Allocator > ``[link boost_asio.reference.dynamic_buffer.overload4 dynamic_buffer]``(
      std::vector< Elem, Allocator > & data,
      std::size_t max_size);
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_buffer.overload4 more...]]``

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 dynamic_buffer (1 of 4 overloads)]


Create a new dynamic buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  dynamic_string_buffer< Elem, Traits, Allocator > dynamic_buffer(
      std::basic_string< Elem, Traits, Allocator > & data);



[heading Return Value]
      
`dynamic_string_buffer<Elem, Traits, Allocator>(data)`. 




[endsect]



[section:overload2 dynamic_buffer (2 of 4 overloads)]


Create a new dynamic buffer that represents the given string. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  dynamic_string_buffer< Elem, Traits, Allocator > dynamic_buffer(
      std::basic_string< Elem, Traits, Allocator > & data,
      std::size_t max_size);



[heading Return Value]
      
`dynamic_string_buffer<Elem, Traits, Allocator>(data, max_size)`. 




[endsect]



[section:overload3 dynamic_buffer (3 of 4 overloads)]


Create a new dynamic buffer that represents the given vector. 


  template<
      typename Elem,
      typename Allocator>
  dynamic_vector_buffer< Elem, Allocator > dynamic_buffer(
      std::vector< Elem, Allocator > & data);



[heading Return Value]
      
`dynamic_vector_buffer<Elem, Allocator>(data)`. 




[endsect]



[section:overload4 dynamic_buffer (4 of 4 overloads)]


Create a new dynamic buffer that represents the given vector. 


  template<
      typename Elem,
      typename Allocator>
  dynamic_vector_buffer< Elem, Allocator > dynamic_buffer(
      std::vector< Elem, Allocator > & data,
      std::size_t max_size);



[heading Return Value]
      
`dynamic_vector_buffer<Elem, Allocator>(data, max_size)`. 




[endsect]


[endsect]

[section:dynamic_string_buffer dynamic_string_buffer]

[indexterm1 boost_asio.indexterm.dynamic_string_buffer..dynamic_string_buffer]


Adapt a basic\_string to the DynamicBuffer requirements. 


  template<
      typename Elem,
      typename Traits,
      typename Allocator>
  class dynamic_string_buffer


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.dynamic_string_buffer.const_buffers_type [*const_buffers_type]]]
    [The type used to represent a sequence of constant buffers that refers to the underlying memory. ]
  
  ]

  [

    [[link boost_asio.reference.dynamic_string_buffer.mutable_buffers_type [*mutable_buffers_type]]]
    [The type used to represent a sequence of mutable buffers that refers to the underlying memory. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.dynamic_string_buffer.capacity [*capacity]]]
    [Get the maximum size that the buffer may grow to without triggering reallocation. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_string_buffer.commit [*commit]]]
    [DynamicBuffer_v1: Move bytes from the output sequence to the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_string_buffer.consume [*consume]]]
    [DynamicBuffer_v1: Remove characters from the input sequence. DynamicBuffer_v2: Consume the specified number of bytes from the beginning of the underlying memory. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_string_buffer.data [*data]]]
    [DynamicBuffer_v1: Get a list of buffers that represents the input sequence. 
     [hr]
     DynamicBuffer_v2: Get a sequence of buffers that represents the underlying memory. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_string_buffer.dynamic_string_buffer [*dynamic_string_buffer]] [constructor]]
    [Construct a dynamic buffer from a string. 
     [hr]
     DynamicBuffer_v2: Copy construct a dynamic buffer. 
     [hr]
     Move construct a dynamic buffer. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_string_buffer.grow [*grow]]]
    [DynamicBuffer_v2: Grow the underlying memory by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_string_buffer.max_size [*max_size]]]
    [Get the maximum size of the dynamic buffer. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_string_buffer.prepare [*prepare]]]
    [DynamicBuffer_v1: Get a list of buffers that represents the output sequence, with the given size. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_string_buffer.shrink [*shrink]]]
    [DynamicBuffer_v2: Shrink the underlying memory by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_string_buffer.size [*size]]]
    [DynamicBuffer_v1: Get the size of the input sequence. DynamicBuffer_v2: Get the current size of the underlying memory. ]
  ]
  
]

Requires that `sizeof(Elem) == 1`. 

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:capacity dynamic_string_buffer::capacity]

[indexterm2 boost_asio.indexterm.dynamic_string_buffer.capacity..capacity..dynamic_string_buffer] 
Get the maximum size that the buffer may grow to without triggering reallocation. 


  std::size_t capacity() const;



[heading Return Value]
      
The current capacity of the underlying string if less than `max_size()`. Otherwise returns `max_size()`. 




[endsect]



[section:commit dynamic_string_buffer::commit]

[indexterm2 boost_asio.indexterm.dynamic_string_buffer.commit..commit..dynamic_string_buffer] 
[*DynamicBuffer\_v1:] Move bytes from the output sequence to the input sequence. 


  void commit(
      std::size_t n);



[heading Parameters]
    

[variablelist
  
[[n][The number of bytes to append from the start of the output sequence to the end of the input sequence. The remainder of the output sequence is discarded.]]

]

Requires a preceding call `prepare(x)` where `x >= n`, and no intervening operations that modify the input or output sequence.


[heading Remarks]
      
If `n` is greater than the size of the output sequence, the entire output sequence is moved to the input sequence and no error is issued. 




[endsect]



[section:const_buffers_type dynamic_string_buffer::const_buffers_type]

[indexterm2 boost_asio.indexterm.dynamic_string_buffer.const_buffers_type..const_buffers_type..dynamic_string_buffer] 
The type used to represent a sequence of constant buffers that refers to the underlying memory. 


  typedef const_buffer const_buffers_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.const_buffer.const_buffer [*const_buffer]] [constructor]]
    [Construct an empty buffer. 
     [hr]
     Construct a buffer to represent a given memory range. 
     [hr]
     Construct a non-modifiable buffer from a modifiable one. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.const_buffer.operator_plus_ [*operator+]]]
    [Create a new non-modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link boost_asio.reference.const_buffer `const_buffer`] class provides a safe representation of a buffer that cannot be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   boost::asio::const_buffer b1 = ...;
   std::size_t s1 = b1.size();
   const unsigned char* p1 = static_cast<const unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 


[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:consume dynamic_string_buffer::consume]

[indexterm2 boost_asio.indexterm.dynamic_string_buffer.consume..consume..dynamic_string_buffer] 
[*DynamicBuffer\_v1:] Remove characters from the input sequence. [*DynamicBuffer\_v2:] Consume the specified number of bytes from the beginning of the underlying memory. 


  void consume(
      std::size_t n);


[*DynamicBuffer\_v1:] Removes `n` characters from the beginning of the input sequence.
[heading Remarks]
      
If `n` is greater than the size of the input sequence, the entire input sequence is consumed and no error is issued.

[*DynamicBuffer\_v2:] Erases `n` bytes from the beginning of the string. If `n` is greater than the current size of the string, the string is emptied. 


[endsect]


[section:data dynamic_string_buffer::data]

[indexterm2 boost_asio.indexterm.dynamic_string_buffer.data..data..dynamic_string_buffer] 
[*DynamicBuffer\_v1:] Get a list of buffers that represents the input sequence. 


  const_buffers_type ``[link boost_asio.reference.dynamic_string_buffer.data.overload1 data]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_string_buffer.data.overload1 more...]]``


[*DynamicBuffer\_v2:] Get a sequence of buffers that represents the underlying memory. 


  mutable_buffers_type ``[link boost_asio.reference.dynamic_string_buffer.data.overload2 data]``(
      std::size_t pos,
      std::size_t n);
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_string_buffer.data.overload2 more...]]``

  const_buffers_type ``[link boost_asio.reference.dynamic_string_buffer.data.overload3 data]``(
      std::size_t pos,
      std::size_t n) const;
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_string_buffer.data.overload3 more...]]``


[section:overload1 dynamic_string_buffer::data (1 of 3 overloads)]


[*DynamicBuffer\_v1:] Get a list of buffers that represents the input sequence. 


  const_buffers_type data() const;



[heading Return Value]
      
An object of type `const_buffers_type` that satisfies ConstBufferSequence requirements, representing the basic\_string memory in the input sequence.


[heading Remarks]
      
The returned object is invalidated by any `dynamic_string_buffer` or `basic_string` member function that resizes or erases the string. 




[endsect]



[section:overload2 dynamic_string_buffer::data (2 of 3 overloads)]


[*DynamicBuffer\_v2:] Get a sequence of buffers that represents the underlying memory. 


  mutable_buffers_type data(
      std::size_t pos,
      std::size_t n);



[heading Parameters]
    

[variablelist
  
[[pos][Position of the first byte to represent in the buffer sequence]]

[[n][The number of bytes to return in the buffer sequence. If the underlying memory is shorter, the buffer sequence represents as many bytes as are available.]]

]


[heading Return Value]
      
An object of type `mutable_buffers_type` that satisfies MutableBufferSequence requirements, representing the basic\_string memory.


[heading Remarks]
      
The returned object is invalidated by any `dynamic_string_buffer` or `basic_string` member function that resizes or erases the string. 




[endsect]



[section:overload3 dynamic_string_buffer::data (3 of 3 overloads)]


[*DynamicBuffer\_v2:] Get a sequence of buffers that represents the underlying memory. 


  const_buffers_type data(
      std::size_t pos,
      std::size_t n) const;



[heading Parameters]
    

[variablelist
  
[[pos][Position of the first byte to represent in the buffer sequence]]

[[n][The number of bytes to return in the buffer sequence. If the underlying memory is shorter, the buffer sequence represents as many bytes as are available.]]

]


[heading Remarks]
      
The returned object is invalidated by any `dynamic_string_buffer` or `basic_string` member function that resizes or erases the string. 




[endsect]


[endsect]

[section:dynamic_string_buffer dynamic_string_buffer::dynamic_string_buffer]

[indexterm2 boost_asio.indexterm.dynamic_string_buffer.dynamic_string_buffer..dynamic_string_buffer..dynamic_string_buffer] 
Construct a dynamic buffer from a string. 


  explicit ``[link boost_asio.reference.dynamic_string_buffer.dynamic_string_buffer.overload1 dynamic_string_buffer]``(
      std::basic_string< Elem, Traits, Allocator > & s,
      std::size_t maximum_size = (std::numeric_limits< std::size_t >::max)());
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_string_buffer.dynamic_string_buffer.overload1 more...]]``


[*DynamicBuffer\_v2:] Copy construct a dynamic buffer. 


  ``[link boost_asio.reference.dynamic_string_buffer.dynamic_string_buffer.overload2 dynamic_string_buffer]``(
      const dynamic_string_buffer & other);
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_string_buffer.dynamic_string_buffer.overload2 more...]]``


Move construct a dynamic buffer. 


  ``[link boost_asio.reference.dynamic_string_buffer.dynamic_string_buffer.overload3 dynamic_string_buffer]``(
      dynamic_string_buffer && other);
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_string_buffer.dynamic_string_buffer.overload3 more...]]``


[section:overload1 dynamic_string_buffer::dynamic_string_buffer (1 of 3 overloads)]


Construct a dynamic buffer from a string. 


  dynamic_string_buffer(
      std::basic_string< Elem, Traits, Allocator > & s,
      std::size_t maximum_size = (std::numeric_limits< std::size_t >::max)());



[heading Parameters]
    

[variablelist
  
[[s][The string to be used as backing storage for the dynamic buffer. The object stores a reference to the string and the user is responsible for ensuring that the string object remains valid while the [link boost_asio.reference.dynamic_string_buffer `dynamic_string_buffer`] object, and copies of the object, are in use.]]

]

[*DynamicBuffer\_v1:] Any existing data in the string is treated as the dynamic buffer's input sequence.


[heading Parameters]
    

[variablelist
  
[[maximum_size][Specifies a maximum size for the buffer, in bytes. ]]

]




[endsect]



[section:overload2 dynamic_string_buffer::dynamic_string_buffer (2 of 3 overloads)]


[*DynamicBuffer\_v2:] Copy construct a dynamic buffer. 


  dynamic_string_buffer(
      const dynamic_string_buffer & other);



[endsect]



[section:overload3 dynamic_string_buffer::dynamic_string_buffer (3 of 3 overloads)]


Move construct a dynamic buffer. 


  dynamic_string_buffer(
      dynamic_string_buffer && other);



[endsect]


[endsect]


[section:grow dynamic_string_buffer::grow]

[indexterm2 boost_asio.indexterm.dynamic_string_buffer.grow..grow..dynamic_string_buffer] 
[*DynamicBuffer\_v2:] Grow the underlying memory by the specified number of bytes. 


  void grow(
      std::size_t n);


Resizes the string to accommodate an additional `n` bytes at the end.


[heading Exceptions]
    

[variablelist
  
[[std::length_error][If `size() + n > max_size()`. ]]

]




[endsect]



[section:max_size dynamic_string_buffer::max_size]

[indexterm2 boost_asio.indexterm.dynamic_string_buffer.max_size..max_size..dynamic_string_buffer] 
Get the maximum size of the dynamic buffer. 


  std::size_t max_size() const;



[heading Return Value]
      
The allowed maximum size of the underlying memory. 




[endsect]



[section:mutable_buffers_type dynamic_string_buffer::mutable_buffers_type]

[indexterm2 boost_asio.indexterm.dynamic_string_buffer.mutable_buffers_type..mutable_buffers_type..dynamic_string_buffer] 
The type used to represent a sequence of mutable buffers that refers to the underlying memory. 


  typedef mutable_buffer mutable_buffers_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.mutable_buffer [*mutable_buffer]] [constructor]]
    [Construct an empty buffer. 
     [hr]
     Construct a buffer to represent a given memory range. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_buffer.operator_plus_ [*operator+]]]
    [Create a new modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link boost_asio.reference.mutable_buffer `mutable_buffer`] class provides a safe representation of a buffer that can be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   boost::asio::mutable_buffer b1 = ...;
   std::size_t s1 = b1.size();
   unsigned char* p1 = static_cast<unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 


[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:prepare dynamic_string_buffer::prepare]

[indexterm2 boost_asio.indexterm.dynamic_string_buffer.prepare..prepare..dynamic_string_buffer] 
[*DynamicBuffer\_v1:] Get a list of buffers that represents the output sequence, with the given size. 


  mutable_buffers_type prepare(
      std::size_t n);


Ensures that the output sequence can accommodate `n` bytes, resizing the basic\_string object as necessary.


[heading Return Value]
      
An object of type `mutable_buffers_type` that satisfies MutableBufferSequence requirements, representing basic\_string memory at the start of the output sequence of size `n`.


[heading Exceptions]
    

[variablelist
  
[[std::length_error][If `size() + n > max_size()`.]]

]


[heading Remarks]
      
The returned object is invalidated by any `dynamic_string_buffer` or `basic_string` member function that modifies the input sequence or output sequence. 




[endsect]



[section:shrink dynamic_string_buffer::shrink]

[indexterm2 boost_asio.indexterm.dynamic_string_buffer.shrink..shrink..dynamic_string_buffer] 
[*DynamicBuffer\_v2:] Shrink the underlying memory by the specified number of bytes. 


  void shrink(
      std::size_t n);


Erases `n` bytes from the end of the string by resizing the basic\_string object. If `n` is greater than the current size of the string, the string is emptied. 


[endsect]



[section:size dynamic_string_buffer::size]

[indexterm2 boost_asio.indexterm.dynamic_string_buffer.size..size..dynamic_string_buffer] 
[*DynamicBuffer\_v1:] Get the size of the input sequence. [*DynamicBuffer\_v2:] Get the current size of the underlying memory. 


  std::size_t size() const;



[heading Return Value]
      
[*DynamicBuffer\_v1] The current size of the input sequence. [*DynamicBuffer\_v2:] The current size of the underlying string if less than `max_size()`. Otherwise returns `max_size()`. 




[endsect]



[endsect]

[section:dynamic_vector_buffer dynamic_vector_buffer]

[indexterm1 boost_asio.indexterm.dynamic_vector_buffer..dynamic_vector_buffer]


Adapt a vector to the DynamicBuffer requirements. 


  template<
      typename Elem,
      typename Allocator>
  class dynamic_vector_buffer


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.dynamic_vector_buffer.const_buffers_type [*const_buffers_type]]]
    [The type used to represent a sequence of constant buffers that refers to the underlying memory. ]
  
  ]

  [

    [[link boost_asio.reference.dynamic_vector_buffer.mutable_buffers_type [*mutable_buffers_type]]]
    [The type used to represent a sequence of mutable buffers that refers to the underlying memory. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.dynamic_vector_buffer.capacity [*capacity]]]
    [Get the maximum size that the buffer may grow to without triggering reallocation. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_vector_buffer.commit [*commit]]]
    [DynamicBuffer_v1: Move bytes from the output sequence to the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_vector_buffer.consume [*consume]]]
    [DynamicBuffer_v1: Remove characters from the input sequence. DynamicBuffer_v2: Consume the specified number of bytes from the beginning of the underlying memory. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_vector_buffer.data [*data]]]
    [DynamicBuffer_v1: Get a list of buffers that represents the input sequence. 
     [hr]
     DynamicBuffer_v2: Get a sequence of buffers that represents the underlying memory. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_vector_buffer.dynamic_vector_buffer [*dynamic_vector_buffer]] [constructor]]
    [Construct a dynamic buffer from a vector. 
     [hr]
     DynamicBuffer_v2: Copy construct a dynamic buffer. 
     [hr]
     Move construct a dynamic buffer. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_vector_buffer.grow [*grow]]]
    [DynamicBuffer_v2: Grow the underlying memory by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_vector_buffer.max_size [*max_size]]]
    [Get the maximum size of the dynamic buffer. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_vector_buffer.prepare [*prepare]]]
    [DynamicBuffer_v1: Get a list of buffers that represents the output sequence, with the given size. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_vector_buffer.shrink [*shrink]]]
    [DynamicBuffer_v2: Shrink the underlying memory by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.dynamic_vector_buffer.size [*size]]]
    [DynamicBuffer_v1: Get the size of the input sequence. DynamicBuffer_v2: Get the current size of the underlying memory. ]
  ]
  
]

Requires that `sizeof(Elem) == 1`. 

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:capacity dynamic_vector_buffer::capacity]

[indexterm2 boost_asio.indexterm.dynamic_vector_buffer.capacity..capacity..dynamic_vector_buffer] 
Get the maximum size that the buffer may grow to without triggering reallocation. 


  std::size_t capacity() const;



[heading Return Value]
      
[*DynamicBuffer\_v1:] The current total capacity of the buffer, i.e. for both the input sequence and output sequence. [*DynamicBuffer\_v2:] The current capacity of the underlying vector if less than `max_size()`. Otherwise returns `max_size()`. 




[endsect]



[section:commit dynamic_vector_buffer::commit]

[indexterm2 boost_asio.indexterm.dynamic_vector_buffer.commit..commit..dynamic_vector_buffer] 
[*DynamicBuffer\_v1:] Move bytes from the output sequence to the input sequence. 


  void commit(
      std::size_t n);



[heading Parameters]
    

[variablelist
  
[[n][The number of bytes to append from the start of the output sequence to the end of the input sequence. The remainder of the output sequence is discarded.]]

]

Requires a preceding call `prepare(x)` where `x >= n`, and no intervening operations that modify the input or output sequence.


[heading Remarks]
      
If `n` is greater than the size of the output sequence, the entire output sequence is moved to the input sequence and no error is issued. 




[endsect]



[section:const_buffers_type dynamic_vector_buffer::const_buffers_type]

[indexterm2 boost_asio.indexterm.dynamic_vector_buffer.const_buffers_type..const_buffers_type..dynamic_vector_buffer] 
The type used to represent a sequence of constant buffers that refers to the underlying memory. 


  typedef const_buffer const_buffers_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.const_buffer.const_buffer [*const_buffer]] [constructor]]
    [Construct an empty buffer. 
     [hr]
     Construct a buffer to represent a given memory range. 
     [hr]
     Construct a non-modifiable buffer from a modifiable one. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.const_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.const_buffer.operator_plus_ [*operator+]]]
    [Create a new non-modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link boost_asio.reference.const_buffer `const_buffer`] class provides a safe representation of a buffer that cannot be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   boost::asio::const_buffer b1 = ...;
   std::size_t s1 = b1.size();
   const unsigned char* p1 = static_cast<const unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 


[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:consume dynamic_vector_buffer::consume]

[indexterm2 boost_asio.indexterm.dynamic_vector_buffer.consume..consume..dynamic_vector_buffer] 
[*DynamicBuffer\_v1:] Remove characters from the input sequence. [*DynamicBuffer\_v2:] Consume the specified number of bytes from the beginning of the underlying memory. 


  void consume(
      std::size_t n);


[*DynamicBuffer\_v1:] Removes `n` characters from the beginning of the input sequence.
[heading Remarks]
      
If `n` is greater than the size of the input sequence, the entire input sequence is consumed and no error is issued.

[*DynamicBuffer\_v2:] Erases `n` bytes from the beginning of the vector. If `n` is greater than the current size of the vector, the vector is emptied. 


[endsect]


[section:data dynamic_vector_buffer::data]

[indexterm2 boost_asio.indexterm.dynamic_vector_buffer.data..data..dynamic_vector_buffer] 
[*DynamicBuffer\_v1:] Get a list of buffers that represents the input sequence. 


  const_buffers_type ``[link boost_asio.reference.dynamic_vector_buffer.data.overload1 data]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_vector_buffer.data.overload1 more...]]``


[*DynamicBuffer\_v2:] Get a sequence of buffers that represents the underlying memory. 


  mutable_buffers_type ``[link boost_asio.reference.dynamic_vector_buffer.data.overload2 data]``(
      std::size_t pos,
      std::size_t n);
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_vector_buffer.data.overload2 more...]]``

  const_buffers_type ``[link boost_asio.reference.dynamic_vector_buffer.data.overload3 data]``(
      std::size_t pos,
      std::size_t n) const;
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_vector_buffer.data.overload3 more...]]``


[section:overload1 dynamic_vector_buffer::data (1 of 3 overloads)]


[*DynamicBuffer\_v1:] Get a list of buffers that represents the input sequence. 


  const_buffers_type data() const;



[heading Return Value]
      
An object of type `const_buffers_type` that satisfies ConstBufferSequence requirements, representing the vector memory in the input sequence.


[heading Remarks]
      
The returned object is invalidated by any `dynamic_vector_buffer` or `vector` member function that modifies the input sequence or output sequence. 




[endsect]



[section:overload2 dynamic_vector_buffer::data (2 of 3 overloads)]


[*DynamicBuffer\_v2:] Get a sequence of buffers that represents the underlying memory. 


  mutable_buffers_type data(
      std::size_t pos,
      std::size_t n);



[heading Parameters]
    

[variablelist
  
[[pos][Position of the first byte to represent in the buffer sequence]]

[[n][The number of bytes to return in the buffer sequence. If the underlying memory is shorter, the buffer sequence represents as many bytes as are available.]]

]


[heading Return Value]
      
An object of type `mutable_buffers_type` that satisfies MutableBufferSequence requirements, representing the vector memory.


[heading Remarks]
      
The returned object is invalidated by any `dynamic_vector_buffer` or `vector` member function that resizes or erases the vector. 




[endsect]



[section:overload3 dynamic_vector_buffer::data (3 of 3 overloads)]


[*DynamicBuffer\_v2:] Get a sequence of buffers that represents the underlying memory. 


  const_buffers_type data(
      std::size_t pos,
      std::size_t n) const;



[heading Parameters]
    

[variablelist
  
[[pos][Position of the first byte to represent in the buffer sequence]]

[[n][The number of bytes to return in the buffer sequence. If the underlying memory is shorter, the buffer sequence represents as many bytes as are available.]]

]


[heading Remarks]
      
The returned object is invalidated by any `dynamic_vector_buffer` or `vector` member function that resizes or erases the vector. 




[endsect]


[endsect]

[section:dynamic_vector_buffer dynamic_vector_buffer::dynamic_vector_buffer]

[indexterm2 boost_asio.indexterm.dynamic_vector_buffer.dynamic_vector_buffer..dynamic_vector_buffer..dynamic_vector_buffer] 
Construct a dynamic buffer from a vector. 


  explicit ``[link boost_asio.reference.dynamic_vector_buffer.dynamic_vector_buffer.overload1 dynamic_vector_buffer]``(
      std::vector< Elem, Allocator > & v,
      std::size_t maximum_size = (std::numeric_limits< std::size_t >::max)());
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_vector_buffer.dynamic_vector_buffer.overload1 more...]]``


[*DynamicBuffer\_v2:] Copy construct a dynamic buffer. 


  ``[link boost_asio.reference.dynamic_vector_buffer.dynamic_vector_buffer.overload2 dynamic_vector_buffer]``(
      const dynamic_vector_buffer & other);
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_vector_buffer.dynamic_vector_buffer.overload2 more...]]``


Move construct a dynamic buffer. 


  ``[link boost_asio.reference.dynamic_vector_buffer.dynamic_vector_buffer.overload3 dynamic_vector_buffer]``(
      dynamic_vector_buffer && other);
  ``  [''''&raquo;''' [link boost_asio.reference.dynamic_vector_buffer.dynamic_vector_buffer.overload3 more...]]``


[section:overload1 dynamic_vector_buffer::dynamic_vector_buffer (1 of 3 overloads)]


Construct a dynamic buffer from a vector. 


  dynamic_vector_buffer(
      std::vector< Elem, Allocator > & v,
      std::size_t maximum_size = (std::numeric_limits< std::size_t >::max)());



[heading Parameters]
    

[variablelist
  
[[v][The vector to be used as backing storage for the dynamic buffer. The object stores a reference to the vector and the user is responsible for ensuring that the vector object remains valid while the [link boost_asio.reference.dynamic_vector_buffer `dynamic_vector_buffer`] object, and copies of the object, are in use.]]

[[maximum_size][Specifies a maximum size for the buffer, in bytes. ]]

]




[endsect]



[section:overload2 dynamic_vector_buffer::dynamic_vector_buffer (2 of 3 overloads)]


[*DynamicBuffer\_v2:] Copy construct a dynamic buffer. 


  dynamic_vector_buffer(
      const dynamic_vector_buffer & other);



[endsect]



[section:overload3 dynamic_vector_buffer::dynamic_vector_buffer (3 of 3 overloads)]


Move construct a dynamic buffer. 


  dynamic_vector_buffer(
      dynamic_vector_buffer && other);



[endsect]


[endsect]


[section:grow dynamic_vector_buffer::grow]

[indexterm2 boost_asio.indexterm.dynamic_vector_buffer.grow..grow..dynamic_vector_buffer] 
[*DynamicBuffer\_v2:] Grow the underlying memory by the specified number of bytes. 


  void grow(
      std::size_t n);


Resizes the vector to accommodate an additional `n` bytes at the end.


[heading Exceptions]
    

[variablelist
  
[[std::length_error][If `size() + n > max_size()`. ]]

]




[endsect]



[section:max_size dynamic_vector_buffer::max_size]

[indexterm2 boost_asio.indexterm.dynamic_vector_buffer.max_size..max_size..dynamic_vector_buffer] 
Get the maximum size of the dynamic buffer. 


  std::size_t max_size() const;



[heading Return Value]
      
[*DynamicBuffer\_v1:] The allowed maximum of the sum of the sizes of the input sequence and output sequence. [*DynamicBuffer\_v2:] The allowed maximum size of the underlying memory. 




[endsect]



[section:mutable_buffers_type dynamic_vector_buffer::mutable_buffers_type]

[indexterm2 boost_asio.indexterm.dynamic_vector_buffer.mutable_buffers_type..mutable_buffers_type..dynamic_vector_buffer] 
The type used to represent a sequence of mutable buffers that refers to the underlying memory. 


  typedef mutable_buffer mutable_buffers_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.mutable_buffer [*mutable_buffer]] [constructor]]
    [Construct an empty buffer. 
     [hr]
     Construct a buffer to represent a given memory range. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_buffer.operator_plus_ [*operator+]]]
    [Create a new modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link boost_asio.reference.mutable_buffer `mutable_buffer`] class provides a safe representation of a buffer that can be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   boost::asio::mutable_buffer b1 = ...;
   std::size_t s1 = b1.size();
   unsigned char* p1 = static_cast<unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 


[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:prepare dynamic_vector_buffer::prepare]

[indexterm2 boost_asio.indexterm.dynamic_vector_buffer.prepare..prepare..dynamic_vector_buffer] 
[*DynamicBuffer\_v1:] Get a list of buffers that represents the output sequence, with the given size. 


  mutable_buffers_type prepare(
      std::size_t n);


Ensures that the output sequence can accommodate `n` bytes, resizing the vector object as necessary.


[heading Return Value]
      
An object of type `mutable_buffers_type` that satisfies MutableBufferSequence requirements, representing vector memory at the start of the output sequence of size `n`.


[heading Exceptions]
    

[variablelist
  
[[std::length_error][If `size() + n > max_size()`.]]

]


[heading Remarks]
      
The returned object is invalidated by any `dynamic_vector_buffer` or `vector` member function that modifies the input sequence or output sequence. 




[endsect]



[section:shrink dynamic_vector_buffer::shrink]

[indexterm2 boost_asio.indexterm.dynamic_vector_buffer.shrink..shrink..dynamic_vector_buffer] 
[*DynamicBuffer\_v2:] Shrink the underlying memory by the specified number of bytes. 


  void shrink(
      std::size_t n);


Erases `n` bytes from the end of the vector by resizing the vector object. If `n` is greater than the current size of the vector, the vector is emptied. 


[endsect]



[section:size dynamic_vector_buffer::size]

[indexterm2 boost_asio.indexterm.dynamic_vector_buffer.size..size..dynamic_vector_buffer] 
[*DynamicBuffer\_v1:] Get the size of the input sequence. [*DynamicBuffer\_v2:] Get the current size of the underlying memory. 


  std::size_t size() const;



[heading Return Value]
      
[*DynamicBuffer\_v1] The current size of the input sequence. [*DynamicBuffer\_v2:] The current size of the underlying vector if less than `max_size()`. Otherwise returns `max_size()`. 




[endsect]



[endsect]


[section:enable_partial_cancellation enable_partial_cancellation]

[indexterm1 boost_asio.indexterm.enable_partial_cancellation..enable_partial_cancellation] 
A cancellation filter that enables terminal and partial cancellation. 


  typedef cancellation_filter< cancellation_type::terminal|cancellation_type::partial > enable_partial_cancellation;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.cancellation_filter.operator_lp__rp_ [*operator()]]]
    [Returns type & Mask. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/cancellation_state.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:enable_terminal_cancellation enable_terminal_cancellation]

[indexterm1 boost_asio.indexterm.enable_terminal_cancellation..enable_terminal_cancellation] 
A cancellation filter that enables terminal cancellation only. 


  typedef cancellation_filter< cancellation_type::terminal > enable_terminal_cancellation;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.cancellation_filter.operator_lp__rp_ [*operator()]]]
    [Returns type & Mask. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/cancellation_state.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:enable_total_cancellation enable_total_cancellation]

[indexterm1 boost_asio.indexterm.enable_total_cancellation..enable_total_cancellation] 
A cancellation filter that enables terminal, partial and total cancellation. 


  typedef cancellation_filter< cancellation_type::terminal|cancellation_type::partial|cancellation_type::total > enable_total_cancellation;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.cancellation_filter.operator_lp__rp_ [*operator()]]]
    [Returns type & Mask. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/cancellation_state.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:error__addrinfo_category error::addrinfo_category]

[indexterm1 boost_asio.indexterm.error__addrinfo_category..error::addrinfo_category] 

  static const boost::system::error_category & addrinfo_category = boost::asio::error::get_addrinfo_category();


[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:error__addrinfo_errors error::addrinfo_errors]

[indexterm1 boost_asio.indexterm.error__addrinfo_errors..error::addrinfo_errors] 
  enum addrinfo_errors

[indexterm2 boost_asio.indexterm.error__addrinfo_errors.service_not_found..service_not_found..error::addrinfo_errors]
[indexterm2 boost_asio.indexterm.error__addrinfo_errors.socket_type_not_supported..socket_type_not_supported..error::addrinfo_errors]

[heading Values]
[variablelist

  [
    [service_not_found]
    [The service is not supported for the given socket type. ]
  ]

  [
    [socket_type_not_supported]
    [The socket type is not supported. ]
  ]

]


[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:error__basic_errors error::basic_errors]

[indexterm1 boost_asio.indexterm.error__basic_errors..error::basic_errors] 
  enum basic_errors

[indexterm2 boost_asio.indexterm.error__basic_errors.access_denied..access_denied..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.address_family_not_supported..address_family_not_supported..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.address_in_use..address_in_use..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.already_connected..already_connected..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.already_started..already_started..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.broken_pipe..broken_pipe..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.connection_aborted..connection_aborted..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.connection_refused..connection_refused..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.connection_reset..connection_reset..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.bad_descriptor..bad_descriptor..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.fault..fault..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.host_unreachable..host_unreachable..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.in_progress..in_progress..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.interrupted..interrupted..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.invalid_argument..invalid_argument..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.message_size..message_size..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.name_too_long..name_too_long..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.network_down..network_down..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.network_reset..network_reset..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.network_unreachable..network_unreachable..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.no_descriptors..no_descriptors..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.no_buffer_space..no_buffer_space..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.no_memory..no_memory..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.no_permission..no_permission..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.no_protocol_option..no_protocol_option..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.no_such_device..no_such_device..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.not_connected..not_connected..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.not_socket..not_socket..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.operation_aborted..operation_aborted..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.operation_not_supported..operation_not_supported..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.shut_down..shut_down..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.timed_out..timed_out..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.try_again..try_again..error::basic_errors]
[indexterm2 boost_asio.indexterm.error__basic_errors.would_block..would_block..error::basic_errors]

[heading Values]
[variablelist

  [
    [access_denied]
    [Permission denied. ]
  ]

  [
    [address_family_not_supported]
    [Address family not supported by protocol. ]
  ]

  [
    [address_in_use]
    [Address already in use. ]
  ]

  [
    [already_connected]
    [Transport endpoint is already connected. ]
  ]

  [
    [already_started]
    [Operation already in progress. ]
  ]

  [
    [broken_pipe]
    [Broken pipe. ]
  ]

  [
    [connection_aborted]
    [A connection has been aborted. ]
  ]

  [
    [connection_refused]
    [Connection refused. ]
  ]

  [
    [connection_reset]
    [Connection reset by peer. ]
  ]

  [
    [bad_descriptor]
    [Bad file descriptor. ]
  ]

  [
    [fault]
    [Bad address. ]
  ]

  [
    [host_unreachable]
    [No route to host. ]
  ]

  [
    [in_progress]
    [Operation now in progress. ]
  ]

  [
    [interrupted]
    [Interrupted system call. ]
  ]

  [
    [invalid_argument]
    [Invalid argument. ]
  ]

  [
    [message_size]
    [Message too long. ]
  ]

  [
    [name_too_long]
    [The name was too long. ]
  ]

  [
    [network_down]
    [Network is down. ]
  ]

  [
    [network_reset]
    [Network dropped connection on reset. ]
  ]

  [
    [network_unreachable]
    [Network is unreachable. ]
  ]

  [
    [no_descriptors]
    [Too many open files. ]
  ]

  [
    [no_buffer_space]
    [No buffer space available. ]
  ]

  [
    [no_memory]
    [Cannot allocate memory. ]
  ]

  [
    [no_permission]
    [Operation not permitted. ]
  ]

  [
    [no_protocol_option]
    [Protocol not available. ]
  ]

  [
    [no_such_device]
    [No such device. ]
  ]

  [
    [not_connected]
    [Transport endpoint is not connected. ]
  ]

  [
    [not_socket]
    [Socket operation on non-socket. ]
  ]

  [
    [operation_aborted]
    [Operation cancelled. ]
  ]

  [
    [operation_not_supported]
    [Operation not supported. ]
  ]

  [
    [shut_down]
    [Cannot send after transport endpoint shutdown. ]
  ]

  [
    [timed_out]
    [Connection timed out. ]
  ]

  [
    [try_again]
    [Resource temporarily unavailable. ]
  ]

  [
    [would_block]
    [The socket is marked non-blocking and the requested operation would block. ]
  ]

]


[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:error__get_addrinfo_category error::get_addrinfo_category]

[indexterm1 boost_asio.indexterm.error__get_addrinfo_category..error::get_addrinfo_category] 

  const boost::system::error_category & get_addrinfo_category();


[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:error__get_misc_category error::get_misc_category]

[indexterm1 boost_asio.indexterm.error__get_misc_category..error::get_misc_category] 

  const boost::system::error_category & get_misc_category();


[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:error__get_netdb_category error::get_netdb_category]

[indexterm1 boost_asio.indexterm.error__get_netdb_category..error::get_netdb_category] 

  const boost::system::error_category & get_netdb_category();


[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:error__get_ssl_category error::get_ssl_category]

[indexterm1 boost_asio.indexterm.error__get_ssl_category..error::get_ssl_category] 

  const boost::system::error_category & get_ssl_category();


[heading Requirements]

['Header: ][^boost/asio/ssl/error.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:error__get_system_category error::get_system_category]

[indexterm1 boost_asio.indexterm.error__get_system_category..error::get_system_category] 

  const boost::system::error_category & get_system_category();


[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:error__make_error_code error::make_error_code]

[indexterm1 boost_asio.indexterm.error__make_error_code..error::make_error_code] 
  boost::system::error_code ``[link boost_asio.reference.error__make_error_code.overload1 make_error_code]``(
      basic_errors e);
  ``  [''''&raquo;''' [link boost_asio.reference.error__make_error_code.overload1 more...]]``

  boost::system::error_code ``[link boost_asio.reference.error__make_error_code.overload2 make_error_code]``(
      netdb_errors e);
  ``  [''''&raquo;''' [link boost_asio.reference.error__make_error_code.overload2 more...]]``

  boost::system::error_code ``[link boost_asio.reference.error__make_error_code.overload3 make_error_code]``(
      addrinfo_errors e);
  ``  [''''&raquo;''' [link boost_asio.reference.error__make_error_code.overload3 more...]]``

  boost::system::error_code ``[link boost_asio.reference.error__make_error_code.overload4 make_error_code]``(
      misc_errors e);
  ``  [''''&raquo;''' [link boost_asio.reference.error__make_error_code.overload4 more...]]``

  boost::system::error_code ``[link boost_asio.reference.error__make_error_code.overload5 make_error_code]``(
      ssl_errors e);
  ``  [''''&raquo;''' [link boost_asio.reference.error__make_error_code.overload5 more...]]``

[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 error::make_error_code (1 of 5 overloads)]



  boost::system::error_code make_error_code(
      basic_errors e);



[endsect]



[section:overload2 error::make_error_code (2 of 5 overloads)]



  boost::system::error_code make_error_code(
      netdb_errors e);



[endsect]



[section:overload3 error::make_error_code (3 of 5 overloads)]



  boost::system::error_code make_error_code(
      addrinfo_errors e);



[endsect]



[section:overload4 error::make_error_code (4 of 5 overloads)]



  boost::system::error_code make_error_code(
      misc_errors e);



[endsect]



[section:overload5 error::make_error_code (5 of 5 overloads)]



  boost::system::error_code make_error_code(
      ssl_errors e);



[endsect]


[endsect]


[section:error__misc_category error::misc_category]

[indexterm1 boost_asio.indexterm.error__misc_category..error::misc_category] 

  static const boost::system::error_category & misc_category = boost::asio::error::get_misc_category();


[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:error__misc_errors error::misc_errors]

[indexterm1 boost_asio.indexterm.error__misc_errors..error::misc_errors] 
  enum misc_errors

[indexterm2 boost_asio.indexterm.error__misc_errors.already_open..already_open..error::misc_errors]
[indexterm2 boost_asio.indexterm.error__misc_errors.eof..eof..error::misc_errors]
[indexterm2 boost_asio.indexterm.error__misc_errors.not_found..not_found..error::misc_errors]
[indexterm2 boost_asio.indexterm.error__misc_errors.fd_set_failure..fd_set_failure..error::misc_errors]

[heading Values]
[variablelist

  [
    [already_open]
    [Already open. ]
  ]

  [
    [eof]
    [End of file or stream. ]
  ]

  [
    [not_found]
    [Element not found. ]
  ]

  [
    [fd_set_failure]
    [The descriptor cannot fit into the select system call's fd_set. ]
  ]

]


[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:error__netdb_category error::netdb_category]

[indexterm1 boost_asio.indexterm.error__netdb_category..error::netdb_category] 

  static const boost::system::error_category & netdb_category = boost::asio::error::get_netdb_category();


[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:error__netdb_errors error::netdb_errors]

[indexterm1 boost_asio.indexterm.error__netdb_errors..error::netdb_errors] 
  enum netdb_errors

[indexterm2 boost_asio.indexterm.error__netdb_errors.host_not_found..host_not_found..error::netdb_errors]
[indexterm2 boost_asio.indexterm.error__netdb_errors.host_not_found_try_again..host_not_found_try_again..error::netdb_errors]
[indexterm2 boost_asio.indexterm.error__netdb_errors.no_data..no_data..error::netdb_errors]
[indexterm2 boost_asio.indexterm.error__netdb_errors.no_recovery..no_recovery..error::netdb_errors]

[heading Values]
[variablelist

  [
    [host_not_found]
    [Host not found (authoritative). ]
  ]

  [
    [host_not_found_try_again]
    [Host not found (non-authoritative). ]
  ]

  [
    [no_data]
    [The query is valid but does not have associated address data. ]
  ]

  [
    [no_recovery]
    [A non-recoverable error occurred. ]
  ]

]


[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:error__ssl_category error::ssl_category]

[indexterm1 boost_asio.indexterm.error__ssl_category..error::ssl_category] 

  static const boost::system::error_category & ssl_category = boost::asio::error::get_ssl_category();


[heading Requirements]

['Header: ][^boost/asio/ssl/error.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:error__ssl_errors error::ssl_errors]

[indexterm1 boost_asio.indexterm.error__ssl_errors..error::ssl_errors] 
  enum ssl_errors


[heading Requirements]

['Header: ][^boost/asio/ssl/error.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:error__system_category error::system_category]

[indexterm1 boost_asio.indexterm.error__system_category..error::system_category] 

  static const boost::system::error_category & system_category = boost::asio::error::get_system_category();


[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:execution__allocator execution::allocator]

[indexterm1 boost_asio.indexterm.execution__allocator..execution::allocator] 
A special value used for accessing the [link boost_asio.reference.execution__allocator_t `execution::allocator_t`] property. 


  constexpr allocator_t< void > allocator;


[heading Requirements]

['Header: ][^boost/asio/execution/allocator.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__allocator_t execution::allocator_t]

[indexterm1 boost_asio.indexterm.execution__allocator_t..execution::allocator_t]


A property to describe which allocator an executor will use to allocate the memory required to store a submitted function object. 


  template<
      typename ``[link boost_asio.reference.ProtoAllocator ProtoAllocator]``>
  struct allocator_t


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__allocator_t.allocator_t [*allocator_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__allocator_t.value [*value]]]
    [Obtain the allocator stored in the allocator_t property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__allocator_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The allocator_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__allocator_t.is_preferable [*is_preferable]] [static]]
    [The allocator_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__allocator_t.is_requirable [*is_requirable]] [static]]
    [The allocator_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/allocator.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:allocator_t execution::allocator_t::allocator_t]

[indexterm2 boost_asio.indexterm.execution__allocator_t.allocator_t..allocator_t..execution::allocator_t] 
Default constructor. 


  constexpr allocator_t();



[endsect]



[section:is_applicable_property_v execution::allocator_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__allocator_t.is_applicable_property_v..is_applicable_property_v..execution::allocator_t] 
The [link boost_asio.reference.execution__allocator_t `execution::allocator_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
    is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::allocator_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__allocator_t.is_preferable..is_preferable..execution::allocator_t] 
The [link boost_asio.reference.execution__allocator_t `execution::allocator_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::allocator_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__allocator_t.is_requirable..is_requirable..execution::allocator_t] 
The [link boost_asio.reference.execution__allocator_t `execution::allocator_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:value execution::allocator_t::value]

[indexterm2 boost_asio.indexterm.execution__allocator_t.value..value..execution::allocator_t] 
Obtain the allocator stored in the [link boost_asio.reference.execution__allocator_t `execution::allocator_t`] property object. 


  constexpr ProtoAllocator value() const;


Present only if `ProtoAllocator` is non-void. 


[endsect]



[endsect]

[section:execution__any_executor execution::any_executor]

[indexterm1 boost_asio.indexterm.execution__any_executor..execution::any_executor]


Polymorphic executor wrapper. 


  template<
      typename... SupportableProperties>
  class any_executor


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__any_executor.any_executor [*any_executor]] [constructor]]
    [Default constructor. 
     [hr]
     Construct in an empty state. Equivalent effects to default constructor. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. 
     [hr]
     Construct to point to the same target as another any_executor. 
     [hr]
     Construct a polymorphic wrapper for the specified executor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__any_executor.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.execution__any_executor.execute [*execute]]]
    [Execute the function on the target executor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__any_executor.operator_bool [*operator bool]]]
    [Determine whether the wrapper has a target executor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__any_executor.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move assignment operator. 
     [hr]
     Assignment operator that sets the polymorphic wrapper to the empty state. 
     [hr]
     Assignment operator to create a polymorphic wrapper for the specified executor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__any_executor.prefer [*prefer]]]
    [Obtain a polymorphic wrapper with the specified property. ]
  ]
  
  [
    [[link boost_asio.reference.execution__any_executor.query [*query]]]
    [Obtain the value associated with the specified property. ]
  ]
  
  [
    [[link boost_asio.reference.execution__any_executor.require [*require]]]
    [Obtain a polymorphic wrapper with the specified property. ]
  ]
  
  [
    [[link boost_asio.reference.execution__any_executor.swap [*swap]]]
    [Swap targets with another polymorphic wrapper. ]
  ]
  
  [
    [[link boost_asio.reference.execution__any_executor.target [*target]]]
    [Get a pointer to the target executor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__any_executor.target_type [*target_type]]]
    [Get the type of the target executor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__any_executor._any_executor [*~any_executor]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__any_executor.operator_not__eq_ [*operator!=]]]
    [Inequality operator. ]
  ]
  
  [
    [[link boost_asio.reference.execution__any_executor.operator_eq__eq_ [*operator==]]]
    [Equality operator. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution/any_executor.hpp]

['Convenience header: ][^boost/asio/execution.hpp]

[section:any_executor execution::any_executor::any_executor]

[indexterm2 boost_asio.indexterm.execution__any_executor.any_executor..any_executor..execution::any_executor] 
Default constructor. 


  ``[link boost_asio.reference.execution__any_executor.any_executor.overload1 any_executor]``();
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.any_executor.overload1 more...]]``


Construct in an empty state. Equivalent effects to default constructor. 


  ``[link boost_asio.reference.execution__any_executor.any_executor.overload2 any_executor]``(
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.any_executor.overload2 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.execution__any_executor.any_executor.overload3 any_executor]``(
      const any_executor & e);
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.any_executor.overload3 more...]]``


Move constructor. 


  ``[link boost_asio.reference.execution__any_executor.any_executor.overload4 any_executor]``(
      any_executor && e);
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.any_executor.overload4 more...]]``


Construct to point to the same target as another [link boost_asio.reference.execution__any_executor `execution::any_executor`]. 


  template<
      class... OtherSupportableProperties>
  ``[link boost_asio.reference.execution__any_executor.any_executor.overload5 any_executor]``(
      any_executor< OtherSupportableProperties...> e);
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.any_executor.overload5 more...]]``


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  ``[link boost_asio.reference.execution__any_executor.any_executor.overload6 any_executor]``(
      Executor e);
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.any_executor.overload6 more...]]``


[section:overload1 execution::any_executor::any_executor (1 of 6 overloads)]


Default constructor. 


  any_executor();



[endsect]



[section:overload2 execution::any_executor::any_executor (2 of 6 overloads)]


Construct in an empty state. Equivalent effects to default constructor. 


  any_executor(
      nullptr_t );



[endsect]



[section:overload3 execution::any_executor::any_executor (3 of 6 overloads)]


Copy constructor. 


  any_executor(
      const any_executor & e);



[endsect]



[section:overload4 execution::any_executor::any_executor (4 of 6 overloads)]


Move constructor. 


  any_executor(
      any_executor && e);



[endsect]



[section:overload5 execution::any_executor::any_executor (5 of 6 overloads)]


Construct to point to the same target as another [link boost_asio.reference.execution__any_executor `execution::any_executor`]. 


  template<
      class... OtherSupportableProperties>
  any_executor(
      any_executor< OtherSupportableProperties...> e);



[endsect]



[section:overload6 execution::any_executor::any_executor (6 of 6 overloads)]


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  any_executor(
      Executor e);



[endsect]


[endsect]


[section:context execution::any_executor::context]

[indexterm2 boost_asio.indexterm.execution__any_executor.context..context..execution::any_executor] 
Obtain the underlying execution context. 


  automatically_determined context() const;


This function is provided for backward compatibility. It is automatically defined when the `SupportableProperties`... list includes a property of type `execution::context_as<U>`, for some type `U`. 


[endsect]



[section:execute execution::any_executor::execute]

[indexterm2 boost_asio.indexterm.execution__any_executor.execute..execute..execution::any_executor] 
Execute the function on the target executor. 


  template<
      typename Function>
  void execute(
      Function && f) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.execution__execute `execution::execute`] customisation point.

For example: 

   execution::any_executor<> ex = ...;
   execution::execute(ex, my_function_object); 




Throws [link boost_asio.reference.bad_executor `bad_executor`] if the polymorphic wrapper has no target. 


[endsect]



[section:operator_bool execution::any_executor::operator bool]

[indexterm2 boost_asio.indexterm.execution__any_executor.operator_bool..operator bool..execution::any_executor] 
Determine whether the wrapper has a target executor. 


  operator bool() const;



[heading Return Value]
      
`true` if the polymorphic wrapper has a target executor, otherwise false. 




[endsect]


[section:operator_not__eq_ execution::any_executor::operator!=]

[indexterm2 boost_asio.indexterm.execution__any_executor.operator_not__eq_..operator!=..execution::any_executor] 
Inequality operator. 


  bool ``[link boost_asio.reference.execution__any_executor.operator_not__eq_.overload1 operator!=]``(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.operator_not__eq_.overload1 more...]]``

  bool ``[link boost_asio.reference.execution__any_executor.operator_not__eq_.overload2 operator!=]``(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.operator_not__eq_.overload2 more...]]``

  bool ``[link boost_asio.reference.execution__any_executor.operator_not__eq_.overload3 operator!=]``(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.operator_not__eq_.overload3 more...]]``


[section:overload1 execution::any_executor::operator!= (1 of 3 overloads)]


Inequality operator. 


  bool operator!=(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);



[endsect]



[section:overload2 execution::any_executor::operator!= (2 of 3 overloads)]


Inequality operator. 


  bool operator!=(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );



[endsect]



[section:overload3 execution::any_executor::operator!= (3 of 3 overloads)]


Inequality operator. 


  bool operator!=(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);



[endsect]


[endsect]

[section:operator_eq_ execution::any_executor::operator=]

[indexterm2 boost_asio.indexterm.execution__any_executor.operator_eq_..operator=..execution::any_executor] 
Assignment operator. 


  any_executor & ``[link boost_asio.reference.execution__any_executor.operator_eq_.overload1 operator=]``(
      const any_executor & e);
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.operator_eq_.overload1 more...]]``


Move assignment operator. 


  any_executor & ``[link boost_asio.reference.execution__any_executor.operator_eq_.overload2 operator=]``(
      any_executor && e);
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.operator_eq_.overload2 more...]]``


Assignment operator that sets the polymorphic wrapper to the empty state. 


  any_executor & ``[link boost_asio.reference.execution__any_executor.operator_eq_.overload3 operator=]``(
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.operator_eq_.overload3 more...]]``


Assignment operator to create a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  any_executor & ``[link boost_asio.reference.execution__any_executor.operator_eq_.overload4 operator=]``(
      Executor e);
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.operator_eq_.overload4 more...]]``


[section:overload1 execution::any_executor::operator= (1 of 4 overloads)]


Assignment operator. 


  any_executor & operator=(
      const any_executor & e);



[endsect]



[section:overload2 execution::any_executor::operator= (2 of 4 overloads)]


Move assignment operator. 


  any_executor & operator=(
      any_executor && e);



[endsect]



[section:overload3 execution::any_executor::operator= (3 of 4 overloads)]


Assignment operator that sets the polymorphic wrapper to the empty state. 


  any_executor & operator=(
      nullptr_t );



[endsect]



[section:overload4 execution::any_executor::operator= (4 of 4 overloads)]


Assignment operator to create a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  any_executor & operator=(
      Executor e);



[endsect]


[endsect]

[section:operator_eq__eq_ execution::any_executor::operator==]

[indexterm2 boost_asio.indexterm.execution__any_executor.operator_eq__eq_..operator==..execution::any_executor] 
Equality operator. 


  bool ``[link boost_asio.reference.execution__any_executor.operator_eq__eq_.overload1 operator==]``(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.operator_eq__eq_.overload1 more...]]``

  bool ``[link boost_asio.reference.execution__any_executor.operator_eq__eq_.overload2 operator==]``(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.operator_eq__eq_.overload2 more...]]``

  bool ``[link boost_asio.reference.execution__any_executor.operator_eq__eq_.overload3 operator==]``(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.operator_eq__eq_.overload3 more...]]``


[section:overload1 execution::any_executor::operator== (1 of 3 overloads)]


Equality operator. 


  bool operator==(
      const any_executor< SupportableProperties...> & a,
      const any_executor< SupportableProperties...> & b);



[endsect]



[section:overload2 execution::any_executor::operator== (2 of 3 overloads)]


Equality operator. 


  bool operator==(
      const any_executor< SupportableProperties...> & a,
      nullptr_t );



[endsect]



[section:overload3 execution::any_executor::operator== (3 of 3 overloads)]


Equality operator. 


  bool operator==(
      nullptr_t ,
      const any_executor< SupportableProperties...> & b);



[endsect]


[endsect]


[section:prefer execution::any_executor::prefer]

[indexterm2 boost_asio.indexterm.execution__any_executor.prefer..prefer..execution::any_executor] 
Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_executor prefer(
      Property ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.prefer `prefer`] customisation point.

For example: 

   execution::any_executor<execution::blocking_t::possibly_t> ex = ...;
   auto ex2 = boost::asio::prefer(ex, execution::blocking.possibly); 





[endsect]



[section:query execution::any_executor::query]

[indexterm2 boost_asio.indexterm.execution__any_executor.query..query..execution::any_executor] 
Obtain the value associated with the specified property. 


  template<
      typename Property>
  Property::polymorphic_query_result_type query(
      Property ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   execution::any_executor<execution::occupancy_t> ex = ...;
   size_t n = boost::asio::query(ex, execution::occupancy); 





[endsect]



[section:require execution::any_executor::require]

[indexterm2 boost_asio.indexterm.execution__any_executor.require..require..execution::any_executor] 
Obtain a polymorphic wrapper with the specified property. 


  template<
      typename Property>
  any_executor require(
      Property ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] and [link boost_asio.reference.prefer `prefer`] customisation points.

For example: 

   execution::any_executor<execution::blocking_t::possibly_t> ex = ...;
   auto ex2 = boost::asio::requre(ex, execution::blocking.possibly); 





[endsect]



[section:swap execution::any_executor::swap]

[indexterm2 boost_asio.indexterm.execution__any_executor.swap..swap..execution::any_executor] 
Swap targets with another polymorphic wrapper. 


  void swap(
      any_executor & other);



[endsect]


[section:target execution::any_executor::target]

[indexterm2 boost_asio.indexterm.execution__any_executor.target..target..execution::any_executor] 
Get a pointer to the target executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  Executor * ``[link boost_asio.reference.execution__any_executor.target.overload1 target]``();
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.target.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  const Executor * ``[link boost_asio.reference.execution__any_executor.target.overload2 target]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.execution__any_executor.target.overload2 more...]]``


[section:overload1 execution::any_executor::target (1 of 2 overloads)]


Get a pointer to the target executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  Executor * target();



[endsect]



[section:overload2 execution::any_executor::target (2 of 2 overloads)]


Get a pointer to the target executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  const Executor * target() const;



[endsect]


[endsect]


[section:target_type execution::any_executor::target_type]

[indexterm2 boost_asio.indexterm.execution__any_executor.target_type..target_type..execution::any_executor] 
Get the type of the target executor. 


  const type_info & target_type() const;



[endsect]



[section:_any_executor execution::any_executor::~any_executor]

[indexterm2 boost_asio.indexterm.execution__any_executor._any_executor..~any_executor..execution::any_executor] 
Destructor. 


  ~any_executor();



[endsect]



[endsect]

[section:execution__bad_executor execution::bad_executor]

[indexterm1 boost_asio.indexterm.execution__bad_executor..execution::bad_executor]


Exception thrown when trying to access an empty polymorphic executor. 


  class bad_executor :
    public std::exception


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__bad_executor.bad_executor [*bad_executor]] [constructor]]
    [Constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__bad_executor.what [*what]]]
    [Obtain message associated with exception. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution/bad_executor.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:bad_executor execution::bad_executor::bad_executor]

[indexterm2 boost_asio.indexterm.execution__bad_executor.bad_executor..bad_executor..execution::bad_executor] 
Constructor. 


  bad_executor();



[endsect]



[section:what execution::bad_executor::what]

[indexterm2 boost_asio.indexterm.execution__bad_executor.what..what..execution::bad_executor] 
Obtain message associated with exception. 


  virtual const char * what() const;



[endsect]



[endsect]


[section:execution__blocking execution::blocking]

[indexterm1 boost_asio.indexterm.execution__blocking..execution::blocking] 
A special value used for accessing the [link boost_asio.reference.execution__blocking_t `execution::blocking_t`] property. 


  constexpr blocking_t blocking;


[heading Requirements]

['Header: ][^boost/asio/execution/blocking.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:execution__blocking_adaptation execution::blocking_adaptation]

[indexterm1 boost_asio.indexterm.execution__blocking_adaptation..execution::blocking_adaptation] 
A special value used for accessing the [link boost_asio.reference.execution__blocking_adaptation_t `execution::blocking_adaptation_t`] property. 


  constexpr blocking_adaptation_t blocking_adaptation;


[heading Requirements]

['Header: ][^boost/asio/execution/blocking_adaptation.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__blocking_adaptation_t execution::blocking_adaptation_t]

[indexterm1 boost_asio.indexterm.execution__blocking_adaptation_t..execution::blocking_adaptation_t]


A property to describe whether automatic adaptation of an executor is allowed in order to apply the [link boost_asio.reference.execution__blocking_adaptation_t__allowed_t `execution::blocking_adaptation_t::allowed_t`] property. 


  struct blocking_adaptation_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__blocking_adaptation_t__allowed_t [*allowed_t]]]
    [A sub-property that indicates that automatic adaptation is allowed. ]
  
  ]

  [

    [[link boost_asio.reference.execution__blocking_adaptation_t__disallowed_t [*disallowed_t]]]
    [A sub-property that indicates that automatic adaptation is not allowed. ]
  
  ]

  [

    [[link boost_asio.reference.execution__blocking_adaptation_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t.blocking_adaptation_t [*blocking_adaptation_t]] [constructor]]
    [Default constructor. 
     [hr]
     Construct from a sub-property value. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t.allowed [*allowed]] [static]]
    [A special value used for accessing the blocking_adaptation_t::allowed_t property. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t.disallowed [*disallowed]] [static]]
    [A special value used for accessing the blocking_adaptation_t::disallowed_t property. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The blocking_adaptation_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t.is_preferable [*is_preferable]] [static]]
    [The top-level blocking_adaptation_t property cannot be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t.is_requirable [*is_requirable]] [static]]
    [The top-level blocking_adaptation_t property cannot be required. ]
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t.operator_not__eq_ [*operator!=]]]
    [Compare property values for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.execution__blocking_adaptation_t.operator_eq__eq_ [*operator==]]]
    [Compare property values for equality. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution/blocking_adaptation.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:allowed execution::blocking_adaptation_t::allowed]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t.allowed..allowed..execution::blocking_adaptation_t] 
A special value used for accessing the [link boost_asio.reference.execution__blocking_adaptation_t__allowed_t `execution::blocking_adaptation_t::allowed_t`] property. 


  static constexpr allowed_t allowed;



[endsect]


[section:blocking_adaptation_t execution::blocking_adaptation_t::blocking_adaptation_t]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t.blocking_adaptation_t..blocking_adaptation_t..execution::blocking_adaptation_t] 
Default constructor. 


  constexpr ``[link boost_asio.reference.execution__blocking_adaptation_t.blocking_adaptation_t.overload1 blocking_adaptation_t]``();
  ``  [''''&raquo;''' [link boost_asio.reference.execution__blocking_adaptation_t.blocking_adaptation_t.overload1 more...]]``


Construct from a sub-property value. 


  constexpr ``[link boost_asio.reference.execution__blocking_adaptation_t.blocking_adaptation_t.overload2 blocking_adaptation_t]``(
      disallowed_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__blocking_adaptation_t.blocking_adaptation_t.overload2 more...]]``

  constexpr ``[link boost_asio.reference.execution__blocking_adaptation_t.blocking_adaptation_t.overload3 blocking_adaptation_t]``(
      allowed_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__blocking_adaptation_t.blocking_adaptation_t.overload3 more...]]``


[section:overload1 execution::blocking_adaptation_t::blocking_adaptation_t (1 of 3 overloads)]


Default constructor. 


  constexpr blocking_adaptation_t();



[endsect]



[section:overload2 execution::blocking_adaptation_t::blocking_adaptation_t (2 of 3 overloads)]


Construct from a sub-property value. 


  constexpr blocking_adaptation_t(
      disallowed_t );



[endsect]



[section:overload3 execution::blocking_adaptation_t::blocking_adaptation_t (3 of 3 overloads)]


Construct from a sub-property value. 


  constexpr blocking_adaptation_t(
      allowed_t );



[endsect]


[endsect]


[section:disallowed execution::blocking_adaptation_t::disallowed]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t.disallowed..disallowed..execution::blocking_adaptation_t] 
A special value used for accessing the [link boost_asio.reference.execution__blocking_adaptation_t__disallowed_t `execution::blocking_adaptation_t::disallowed_t`] property. 


  static constexpr disallowed_t disallowed;



[endsect]



[section:is_applicable_property_v execution::blocking_adaptation_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t.is_applicable_property_v..is_applicable_property_v..execution::blocking_adaptation_t] 
The [link boost_asio.reference.execution__blocking_adaptation_t `execution::blocking_adaptation_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
    is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::blocking_adaptation_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t.is_preferable..is_preferable..execution::blocking_adaptation_t] 
The top-level [link boost_asio.reference.execution__blocking_adaptation_t `execution::blocking_adaptation_t`] property cannot be preferred. 


  static constexpr bool is_preferable = false;



[endsect]



[section:is_requirable execution::blocking_adaptation_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t.is_requirable..is_requirable..execution::blocking_adaptation_t] 
The top-level [link boost_asio.reference.execution__blocking_adaptation_t `execution::blocking_adaptation_t`] property cannot be required. 


  static constexpr bool is_requirable = false;



[endsect]



[section:operator_not__eq_ execution::blocking_adaptation_t::operator!=]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t.operator_not__eq_..operator!=..execution::blocking_adaptation_t] 
Compare property values for inequality. 


  friend constexpr bool operator!=(
      const blocking_adaptation_t & a,
      const blocking_adaptation_t & b);


[heading Requirements]

['Header: ][^boost/asio/execution/blocking_adaptation.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:operator_eq__eq_ execution::blocking_adaptation_t::operator==]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t.operator_eq__eq_..operator==..execution::blocking_adaptation_t] 
Compare property values for equality. 


  friend constexpr bool operator==(
      const blocking_adaptation_t & a,
      const blocking_adaptation_t & b);


[heading Requirements]

['Header: ][^boost/asio/execution/blocking_adaptation.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:polymorphic_query_result_type execution::blocking_adaptation_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::blocking_adaptation_t] 
The type returned by queries against an `any_executor`. 


  typedef blocking_adaptation_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/blocking_adaptation.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[endsect]

[section:execution__blocking_adaptation_t__allowed_t execution::blocking_adaptation_t::allowed_t]

[indexterm1 boost_asio.indexterm.execution__blocking_adaptation_t__allowed_t..execution::blocking_adaptation_t::allowed_t]


A sub-property that indicates that automatic adaptation is allowed. 


  struct allowed_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__blocking_adaptation_t__allowed_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t__allowed_t.allowed_t [*allowed_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__blocking_adaptation_t__allowed_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t__allowed_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The blocking_adaptation_t::allowed_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t__allowed_t.is_preferable [*is_preferable]] [static]]
    [The blocking_adaptation_t::allowed_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t__allowed_t.is_requirable [*is_requirable]] [static]]
    [The blocking_adaptation_t::allowed_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/blocking_adaptation.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:allowed_t execution::blocking_adaptation_t::allowed_t::allowed_t]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t__allowed_t.allowed_t..allowed_t..execution::blocking_adaptation_t::allowed_t] 
Default constructor. 


  constexpr allowed_t();



[endsect]



[section:is_applicable_property_v execution::blocking_adaptation_t::allowed_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t__allowed_t.is_applicable_property_v..is_applicable_property_v..execution::blocking_adaptation_t::allowed_t] 
The [link boost_asio.reference.execution__blocking_adaptation_t__allowed_t `execution::blocking_adaptation_t::allowed_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::blocking_adaptation_t::allowed_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t__allowed_t.is_preferable..is_preferable..execution::blocking_adaptation_t::allowed_t] 
The [link boost_asio.reference.execution__blocking_adaptation_t__allowed_t `execution::blocking_adaptation_t::allowed_t`] property can be preferred. 


  static constexpr bool is_preferable = false;



[endsect]



[section:is_requirable execution::blocking_adaptation_t::allowed_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t__allowed_t.is_requirable..is_requirable..execution::blocking_adaptation_t::allowed_t] 
The [link boost_asio.reference.execution__blocking_adaptation_t__allowed_t `execution::blocking_adaptation_t::allowed_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:polymorphic_query_result_type execution::blocking_adaptation_t::allowed_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t__allowed_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::blocking_adaptation_t::allowed_t] 
The type returned by queries against an `any_executor`. 


  typedef blocking_adaptation_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/blocking_adaptation.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:value execution::blocking_adaptation_t::allowed_t::value]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t__allowed_t.value..value..execution::blocking_adaptation_t::allowed_t] 
Get the value associated with a property object. 


  static constexpr blocking_adaptation_t value();



[heading Return Value]
      
`allowed_t()`; 




[endsect]



[endsect]

[section:execution__blocking_adaptation_t__disallowed_t execution::blocking_adaptation_t::disallowed_t]

[indexterm1 boost_asio.indexterm.execution__blocking_adaptation_t__disallowed_t..execution::blocking_adaptation_t::disallowed_t]


A sub-property that indicates that automatic adaptation is not allowed. 


  struct disallowed_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__blocking_adaptation_t__disallowed_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t__disallowed_t.disallowed_t [*disallowed_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__blocking_adaptation_t__disallowed_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t__disallowed_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The blocking_adaptation_t::disallowed_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t__disallowed_t.is_preferable [*is_preferable]] [static]]
    [The blocking_adaptation_t::disallowed_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_adaptation_t__disallowed_t.is_requirable [*is_requirable]] [static]]
    [The blocking_adaptation_t::disallowed_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/blocking_adaptation.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:disallowed_t execution::blocking_adaptation_t::disallowed_t::disallowed_t]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t__disallowed_t.disallowed_t..disallowed_t..execution::blocking_adaptation_t::disallowed_t] 
Default constructor. 


  constexpr disallowed_t();



[endsect]



[section:is_applicable_property_v execution::blocking_adaptation_t::disallowed_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t__disallowed_t.is_applicable_property_v..is_applicable_property_v..execution::blocking_adaptation_t::disallowed_t] 
The [link boost_asio.reference.execution__blocking_adaptation_t__disallowed_t `execution::blocking_adaptation_t::disallowed_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::blocking_adaptation_t::disallowed_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t__disallowed_t.is_preferable..is_preferable..execution::blocking_adaptation_t::disallowed_t] 
The [link boost_asio.reference.execution__blocking_adaptation_t__disallowed_t `execution::blocking_adaptation_t::disallowed_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::blocking_adaptation_t::disallowed_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t__disallowed_t.is_requirable..is_requirable..execution::blocking_adaptation_t::disallowed_t] 
The [link boost_asio.reference.execution__blocking_adaptation_t__disallowed_t `execution::blocking_adaptation_t::disallowed_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:polymorphic_query_result_type execution::blocking_adaptation_t::disallowed_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t__disallowed_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::blocking_adaptation_t::disallowed_t] 
The type returned by queries against an `any_executor`. 


  typedef blocking_adaptation_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/blocking_adaptation.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:value execution::blocking_adaptation_t::disallowed_t::value]

[indexterm2 boost_asio.indexterm.execution__blocking_adaptation_t__disallowed_t.value..value..execution::blocking_adaptation_t::disallowed_t] 
Get the value associated with a property object. 


  static constexpr blocking_adaptation_t value();



[heading Return Value]
      
`disallowed_t()`; 




[endsect]



[endsect]

[section:execution__blocking_t execution::blocking_t]

[indexterm1 boost_asio.indexterm.execution__blocking_t..execution::blocking_t]


A property to describe what guarantees an executor makes about the blocking behaviour of their execution functions. 


  struct blocking_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__blocking_t__always_t [*always_t]]]
    [A sub-property that indicates that invocation of an executor's execution function shall block until completion of all invocations of the submitted function object. ]
  
  ]

  [

    [[link boost_asio.reference.execution__blocking_t__never_t [*never_t]]]
    [A sub-property that indicates that invocation of an executor's execution function shall not block pending completion of the invocations of the submitted function object. ]
  
  ]

  [

    [[link boost_asio.reference.execution__blocking_t__possibly_t [*possibly_t]]]
    [A sub-property that indicates that invocation of an executor's execution function may block pending completion of one or more invocations of the submitted function object. ]
  
  ]

  [

    [[link boost_asio.reference.execution__blocking_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_t.blocking_t [*blocking_t]] [constructor]]
    [Default constructor. 
     [hr]
     Construct from a sub-property value. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_t.always [*always]] [static]]
    [A special value used for accessing the blocking_t::always_t property. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The blocking_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_t.is_preferable [*is_preferable]] [static]]
    [The top-level blocking_t property cannot be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_t.is_requirable [*is_requirable]] [static]]
    [The top-level blocking_t property cannot be required. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_t.never [*never]] [static]]
    [A special value used for accessing the blocking_t::never_t property. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_t.possibly [*possibly]] [static]]
    [A special value used for accessing the blocking_t::possibly_t property. ]
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_t.operator_not__eq_ [*operator!=]]]
    [Compare property values for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.execution__blocking_t.operator_eq__eq_ [*operator==]]]
    [Compare property values for equality. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution/blocking.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:always execution::blocking_t::always]

[indexterm2 boost_asio.indexterm.execution__blocking_t.always..always..execution::blocking_t] 
A special value used for accessing the [link boost_asio.reference.execution__blocking_t__always_t `execution::blocking_t::always_t`] property. 


  static constexpr always_t always;



[endsect]


[section:blocking_t execution::blocking_t::blocking_t]

[indexterm2 boost_asio.indexterm.execution__blocking_t.blocking_t..blocking_t..execution::blocking_t] 
Default constructor. 


  constexpr ``[link boost_asio.reference.execution__blocking_t.blocking_t.overload1 blocking_t]``();
  ``  [''''&raquo;''' [link boost_asio.reference.execution__blocking_t.blocking_t.overload1 more...]]``


Construct from a sub-property value. 


  constexpr ``[link boost_asio.reference.execution__blocking_t.blocking_t.overload2 blocking_t]``(
      possibly_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__blocking_t.blocking_t.overload2 more...]]``

  constexpr ``[link boost_asio.reference.execution__blocking_t.blocking_t.overload3 blocking_t]``(
      always_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__blocking_t.blocking_t.overload3 more...]]``

  constexpr ``[link boost_asio.reference.execution__blocking_t.blocking_t.overload4 blocking_t]``(
      never_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__blocking_t.blocking_t.overload4 more...]]``


[section:overload1 execution::blocking_t::blocking_t (1 of 4 overloads)]


Default constructor. 


  constexpr blocking_t();



[endsect]



[section:overload2 execution::blocking_t::blocking_t (2 of 4 overloads)]


Construct from a sub-property value. 


  constexpr blocking_t(
      possibly_t );



[endsect]



[section:overload3 execution::blocking_t::blocking_t (3 of 4 overloads)]


Construct from a sub-property value. 


  constexpr blocking_t(
      always_t );



[endsect]



[section:overload4 execution::blocking_t::blocking_t (4 of 4 overloads)]


Construct from a sub-property value. 


  constexpr blocking_t(
      never_t );



[endsect]


[endsect]


[section:is_applicable_property_v execution::blocking_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__blocking_t.is_applicable_property_v..is_applicable_property_v..execution::blocking_t] 
The [link boost_asio.reference.execution__blocking_t `execution::blocking_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
    is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::blocking_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__blocking_t.is_preferable..is_preferable..execution::blocking_t] 
The top-level [link boost_asio.reference.execution__blocking_t `execution::blocking_t`] property cannot be preferred. 


  static constexpr bool is_preferable = false;



[endsect]



[section:is_requirable execution::blocking_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__blocking_t.is_requirable..is_requirable..execution::blocking_t] 
The top-level [link boost_asio.reference.execution__blocking_t `execution::blocking_t`] property cannot be required. 


  static constexpr bool is_requirable = false;



[endsect]



[section:never execution::blocking_t::never]

[indexterm2 boost_asio.indexterm.execution__blocking_t.never..never..execution::blocking_t] 
A special value used for accessing the [link boost_asio.reference.execution__blocking_t__never_t `execution::blocking_t::never_t`] property. 


  static constexpr never_t never;



[endsect]



[section:operator_not__eq_ execution::blocking_t::operator!=]

[indexterm2 boost_asio.indexterm.execution__blocking_t.operator_not__eq_..operator!=..execution::blocking_t] 
Compare property values for inequality. 


  friend constexpr bool operator!=(
      const blocking_t & a,
      const blocking_t & b);


[heading Requirements]

['Header: ][^boost/asio/execution/blocking.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:operator_eq__eq_ execution::blocking_t::operator==]

[indexterm2 boost_asio.indexterm.execution__blocking_t.operator_eq__eq_..operator==..execution::blocking_t] 
Compare property values for equality. 


  friend constexpr bool operator==(
      const blocking_t & a,
      const blocking_t & b);


[heading Requirements]

['Header: ][^boost/asio/execution/blocking.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:polymorphic_query_result_type execution::blocking_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__blocking_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::blocking_t] 
The type returned by queries against an `any_executor`. 


  typedef blocking_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/blocking.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:possibly execution::blocking_t::possibly]

[indexterm2 boost_asio.indexterm.execution__blocking_t.possibly..possibly..execution::blocking_t] 
A special value used for accessing the [link boost_asio.reference.execution__blocking_t__possibly_t `execution::blocking_t::possibly_t`] property. 


  static constexpr possibly_t possibly;



[endsect]



[endsect]

[section:execution__blocking_t__always_t execution::blocking_t::always_t]

[indexterm1 boost_asio.indexterm.execution__blocking_t__always_t..execution::blocking_t::always_t]


A sub-property that indicates that invocation of an executor's execution function shall block until completion of all invocations of the submitted function object. 


  struct always_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__blocking_t__always_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_t__always_t.always_t [*always_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__blocking_t__always_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_t__always_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The blocking_t::always_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_t__always_t.is_preferable [*is_preferable]] [static]]
    [The blocking_t::always_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_t__always_t.is_requirable [*is_requirable]] [static]]
    [The blocking_t::always_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/blocking.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:always_t execution::blocking_t::always_t::always_t]

[indexterm2 boost_asio.indexterm.execution__blocking_t__always_t.always_t..always_t..execution::blocking_t::always_t] 
Default constructor. 


  constexpr always_t();



[endsect]



[section:is_applicable_property_v execution::blocking_t::always_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__blocking_t__always_t.is_applicable_property_v..is_applicable_property_v..execution::blocking_t::always_t] 
The [link boost_asio.reference.execution__blocking_t__always_t `execution::blocking_t::always_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::blocking_t::always_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__blocking_t__always_t.is_preferable..is_preferable..execution::blocking_t::always_t] 
The [link boost_asio.reference.execution__blocking_t__always_t `execution::blocking_t::always_t`] property can be preferred. 


  static constexpr bool is_preferable = false;



[endsect]



[section:is_requirable execution::blocking_t::always_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__blocking_t__always_t.is_requirable..is_requirable..execution::blocking_t::always_t] 
The [link boost_asio.reference.execution__blocking_t__always_t `execution::blocking_t::always_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:polymorphic_query_result_type execution::blocking_t::always_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__blocking_t__always_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::blocking_t::always_t] 
The type returned by queries against an `any_executor`. 


  typedef blocking_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/blocking.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:value execution::blocking_t::always_t::value]

[indexterm2 boost_asio.indexterm.execution__blocking_t__always_t.value..value..execution::blocking_t::always_t] 
Get the value associated with a property object. 


  static constexpr blocking_t value();



[heading Return Value]
      
`always_t()`; 




[endsect]



[endsect]

[section:execution__blocking_t__never_t execution::blocking_t::never_t]

[indexterm1 boost_asio.indexterm.execution__blocking_t__never_t..execution::blocking_t::never_t]


A sub-property that indicates that invocation of an executor's execution function shall not block pending completion of the invocations of the submitted function object. 


  struct never_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__blocking_t__never_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_t__never_t.never_t [*never_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__blocking_t__never_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_t__never_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The blocking_t::never_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_t__never_t.is_preferable [*is_preferable]] [static]]
    [The blocking_t::never_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_t__never_t.is_requirable [*is_requirable]] [static]]
    [The blocking_t::never_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/blocking.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::blocking_t::never_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__blocking_t__never_t.is_applicable_property_v..is_applicable_property_v..execution::blocking_t::never_t] 
The [link boost_asio.reference.execution__blocking_t__never_t `execution::blocking_t::never_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::blocking_t::never_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__blocking_t__never_t.is_preferable..is_preferable..execution::blocking_t::never_t] 
The [link boost_asio.reference.execution__blocking_t__never_t `execution::blocking_t::never_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::blocking_t::never_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__blocking_t__never_t.is_requirable..is_requirable..execution::blocking_t::never_t] 
The [link boost_asio.reference.execution__blocking_t__never_t `execution::blocking_t::never_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:never_t execution::blocking_t::never_t::never_t]

[indexterm2 boost_asio.indexterm.execution__blocking_t__never_t.never_t..never_t..execution::blocking_t::never_t] 
Default constructor. 


  constexpr never_t();



[endsect]



[section:polymorphic_query_result_type execution::blocking_t::never_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__blocking_t__never_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::blocking_t::never_t] 
The type returned by queries against an `any_executor`. 


  typedef blocking_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/blocking.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:value execution::blocking_t::never_t::value]

[indexterm2 boost_asio.indexterm.execution__blocking_t__never_t.value..value..execution::blocking_t::never_t] 
Get the value associated with a property object. 


  static constexpr blocking_t value();



[heading Return Value]
      
`never_t()`; 




[endsect]



[endsect]

[section:execution__blocking_t__possibly_t execution::blocking_t::possibly_t]

[indexterm1 boost_asio.indexterm.execution__blocking_t__possibly_t..execution::blocking_t::possibly_t]


A sub-property that indicates that invocation of an executor's execution function may block pending completion of one or more invocations of the submitted function object. 


  struct possibly_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__blocking_t__possibly_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_t__possibly_t.possibly_t [*possibly_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__blocking_t__possibly_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__blocking_t__possibly_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The blocking_t::possibly_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_t__possibly_t.is_preferable [*is_preferable]] [static]]
    [The blocking_t::possibly_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__blocking_t__possibly_t.is_requirable [*is_requirable]] [static]]
    [The blocking_t::possibly_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/blocking.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::blocking_t::possibly_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__blocking_t__possibly_t.is_applicable_property_v..is_applicable_property_v..execution::blocking_t::possibly_t] 
The [link boost_asio.reference.execution__blocking_t__possibly_t `execution::blocking_t::possibly_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::blocking_t::possibly_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__blocking_t__possibly_t.is_preferable..is_preferable..execution::blocking_t::possibly_t] 
The [link boost_asio.reference.execution__blocking_t__possibly_t `execution::blocking_t::possibly_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::blocking_t::possibly_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__blocking_t__possibly_t.is_requirable..is_requirable..execution::blocking_t::possibly_t] 
The [link boost_asio.reference.execution__blocking_t__possibly_t `execution::blocking_t::possibly_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:polymorphic_query_result_type execution::blocking_t::possibly_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__blocking_t__possibly_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::blocking_t::possibly_t] 
The type returned by queries against an `any_executor`. 


  typedef blocking_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/blocking.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:possibly_t execution::blocking_t::possibly_t::possibly_t]

[indexterm2 boost_asio.indexterm.execution__blocking_t__possibly_t.possibly_t..possibly_t..execution::blocking_t::possibly_t] 
Default constructor. 


  constexpr possibly_t();



[endsect]



[section:value execution::blocking_t::possibly_t::value]

[indexterm2 boost_asio.indexterm.execution__blocking_t__possibly_t.value..value..execution::blocking_t::possibly_t] 
Get the value associated with a property object. 


  static constexpr blocking_t value();



[heading Return Value]
      
`possibly_t()`; 




[endsect]



[endsect]


[section:execution__bulk_execute execution::bulk_execute]

[indexterm1 boost_asio.indexterm.execution__bulk_execute..execution::bulk_execute] 
A customisation point that creates a bulk sender. 


  constexpr unspecified bulk_execute = unspecified;


The name `execution::bulk_execute` denotes a customisation point object. If `is_convertible_v<N, size_t>` is true, then the expression `execution::bulk_execute(S, F, N)` for some subexpressions `S`, `F`, and `N` is expression-equivalent to:


* `S.bulk_execute(F, N)`, if that expression is valid. If the function selected does not execute `N` invocations of the function object `F` on the executor `S` in bulk with forward progress guarantee `boost::asio::query(S, execution::bulk_guarantee)`, and the result of that function does not model `sender<void>`, the program is ill-formed with no diagnostic required.


* Otherwise, `bulk_execute(S, F, N)`, if that expression is valid, with overload resolution performed in a context that includes the declaration `void bulk_execute();` and that does not include a declaration of `execution::bulk_execute`. If the function selected by overload resolution does not execute `N` invocations of the function object `F` on the executor `S` in bulk with forward progress guarantee `boost::asio::query(E, execution::bulk_guarantee)`, and the result of that function does not model `sender<void>`, the program is ill-formed with no diagnostic required.


* Otherwise, if the types `F` and `executor_index_t<remove_cvref_t<S>>` model `invocable` and if `boost::asio::query(S, execution::bulk_guarantee)` equals `execution::bulk_guarantee.unsequenced`, then


* Evaluates `DECAY_COPY(std::forward<decltype(F)>(F))` on the calling thread to create a function object `cf`. [Note: Additional copies of `cf` may subsequently be created. --end note.]




* For each value of `i` in `N`, `cf(i)` (or copy of `cf`)) will be invoked at most once by an execution agent that is unique for each value of `i`.




* May block pending completion of one or more invocations of `cf`.




* Synchronizes with (C++Std [intro.multithread]) the invocations of `cf`.




* Otherwise, `execution::bulk_execute(S, F, N)` is ill-formed. 



[heading Requirements]

['Header: ][^boost/asio/execution/bulk_execute.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:execution__bulk_guarantee execution::bulk_guarantee]

[indexterm1 boost_asio.indexterm.execution__bulk_guarantee..execution::bulk_guarantee] 
A special value used for accessing the [link boost_asio.reference.execution__bulk_guarantee_t `execution::bulk_guarantee_t`] property. 


  constexpr bulk_guarantee_t bulk_guarantee;


[heading Requirements]

['Header: ][^boost/asio/execution/bulk_guarantee.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__bulk_guarantee_t execution::bulk_guarantee_t]

[indexterm1 boost_asio.indexterm.execution__bulk_guarantee_t..execution::bulk_guarantee_t]


A property to communicate the forward progress and ordering guarantees of execution agents associated with the bulk execution. 


  struct bulk_guarantee_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__bulk_guarantee_t__parallel_t [*parallel_t]]]
    [A sub-property that indicates that execution agents within the same bulk execution may be parallelised. ]
  
  ]

  [

    [[link boost_asio.reference.execution__bulk_guarantee_t__sequenced_t [*sequenced_t]]]
    [A sub-property that indicates that execution agents within the same bulk execution may not be parallelised and vectorised. ]
  
  ]

  [

    [[link boost_asio.reference.execution__bulk_guarantee_t__unsequenced_t [*unsequenced_t]]]
    [A sub-property that indicates that execution agents within the same bulk execution may be parallelised and vectorised. ]
  
  ]

  [

    [[link boost_asio.reference.execution__bulk_guarantee_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t.bulk_guarantee_t [*bulk_guarantee_t]] [constructor]]
    [Default constructor. 
     [hr]
     Construct from a sub-property value. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The bulk_guarantee_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t.is_preferable [*is_preferable]] [static]]
    [The top-level bulk_guarantee_t property cannot be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t.is_requirable [*is_requirable]] [static]]
    [The top-level bulk_guarantee_t property cannot be required. ]
  ]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t.parallel [*parallel]] [static]]
    [A special value used for accessing the bulk_guarantee_t::parallel_t property. ]
  ]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t.sequenced [*sequenced]] [static]]
    [A special value used for accessing the bulk_guarantee_t::sequenced_t property. ]
  ]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t.unsequenced [*unsequenced]] [static]]
    [A special value used for accessing the bulk_guarantee_t::unsequenced_t property. ]
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t.operator_not__eq_ [*operator!=]]]
    [Compare property values for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.execution__bulk_guarantee_t.operator_eq__eq_ [*operator==]]]
    [Compare property values for equality. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution/bulk_guarantee.hpp]

['Convenience header: ][^boost/asio/execution.hpp]

[section:bulk_guarantee_t execution::bulk_guarantee_t::bulk_guarantee_t]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t.bulk_guarantee_t..bulk_guarantee_t..execution::bulk_guarantee_t] 
Default constructor. 


  constexpr ``[link boost_asio.reference.execution__bulk_guarantee_t.bulk_guarantee_t.overload1 bulk_guarantee_t]``();
  ``  [''''&raquo;''' [link boost_asio.reference.execution__bulk_guarantee_t.bulk_guarantee_t.overload1 more...]]``


Construct from a sub-property value. 


  constexpr ``[link boost_asio.reference.execution__bulk_guarantee_t.bulk_guarantee_t.overload2 bulk_guarantee_t]``(
      unsequenced_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__bulk_guarantee_t.bulk_guarantee_t.overload2 more...]]``

  constexpr ``[link boost_asio.reference.execution__bulk_guarantee_t.bulk_guarantee_t.overload3 bulk_guarantee_t]``(
      sequenced_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__bulk_guarantee_t.bulk_guarantee_t.overload3 more...]]``

  constexpr ``[link boost_asio.reference.execution__bulk_guarantee_t.bulk_guarantee_t.overload4 bulk_guarantee_t]``(
      parallel_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__bulk_guarantee_t.bulk_guarantee_t.overload4 more...]]``


[section:overload1 execution::bulk_guarantee_t::bulk_guarantee_t (1 of 4 overloads)]


Default constructor. 


  constexpr bulk_guarantee_t();



[endsect]



[section:overload2 execution::bulk_guarantee_t::bulk_guarantee_t (2 of 4 overloads)]


Construct from a sub-property value. 


  constexpr bulk_guarantee_t(
      unsequenced_t );



[endsect]



[section:overload3 execution::bulk_guarantee_t::bulk_guarantee_t (3 of 4 overloads)]


Construct from a sub-property value. 


  constexpr bulk_guarantee_t(
      sequenced_t );



[endsect]



[section:overload4 execution::bulk_guarantee_t::bulk_guarantee_t (4 of 4 overloads)]


Construct from a sub-property value. 


  constexpr bulk_guarantee_t(
      parallel_t );



[endsect]


[endsect]


[section:is_applicable_property_v execution::bulk_guarantee_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t.is_applicable_property_v..is_applicable_property_v..execution::bulk_guarantee_t] 
The [link boost_asio.reference.execution__bulk_guarantee_t `execution::bulk_guarantee_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
    is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::bulk_guarantee_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t.is_preferable..is_preferable..execution::bulk_guarantee_t] 
The top-level [link boost_asio.reference.execution__bulk_guarantee_t `execution::bulk_guarantee_t`] property cannot be preferred. 


  static constexpr bool is_preferable = false;



[endsect]



[section:is_requirable execution::bulk_guarantee_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t.is_requirable..is_requirable..execution::bulk_guarantee_t] 
The top-level [link boost_asio.reference.execution__bulk_guarantee_t `execution::bulk_guarantee_t`] property cannot be required. 


  static constexpr bool is_requirable = false;



[endsect]



[section:operator_not__eq_ execution::bulk_guarantee_t::operator!=]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t.operator_not__eq_..operator!=..execution::bulk_guarantee_t] 
Compare property values for inequality. 


  friend constexpr bool operator!=(
      const bulk_guarantee_t & a,
      const bulk_guarantee_t & b);


[heading Requirements]

['Header: ][^boost/asio/execution/bulk_guarantee.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:operator_eq__eq_ execution::bulk_guarantee_t::operator==]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t.operator_eq__eq_..operator==..execution::bulk_guarantee_t] 
Compare property values for equality. 


  friend constexpr bool operator==(
      const bulk_guarantee_t & a,
      const bulk_guarantee_t & b);


[heading Requirements]

['Header: ][^boost/asio/execution/bulk_guarantee.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:parallel execution::bulk_guarantee_t::parallel]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t.parallel..parallel..execution::bulk_guarantee_t] 
A special value used for accessing the [link boost_asio.reference.execution__bulk_guarantee_t__parallel_t `execution::bulk_guarantee_t::parallel_t`] property. 


  static constexpr parallel_t parallel;



[endsect]



[section:polymorphic_query_result_type execution::bulk_guarantee_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::bulk_guarantee_t] 
The type returned by queries against an `any_executor`. 


  typedef bulk_guarantee_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/bulk_guarantee.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:sequenced execution::bulk_guarantee_t::sequenced]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t.sequenced..sequenced..execution::bulk_guarantee_t] 
A special value used for accessing the [link boost_asio.reference.execution__bulk_guarantee_t__sequenced_t `execution::bulk_guarantee_t::sequenced_t`] property. 


  static constexpr sequenced_t sequenced;



[endsect]



[section:unsequenced execution::bulk_guarantee_t::unsequenced]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t.unsequenced..unsequenced..execution::bulk_guarantee_t] 
A special value used for accessing the [link boost_asio.reference.execution__bulk_guarantee_t__unsequenced_t `execution::bulk_guarantee_t::unsequenced_t`] property. 


  static constexpr unsequenced_t unsequenced;



[endsect]



[endsect]

[section:execution__bulk_guarantee_t__parallel_t execution::bulk_guarantee_t::parallel_t]

[indexterm1 boost_asio.indexterm.execution__bulk_guarantee_t__parallel_t..execution::bulk_guarantee_t::parallel_t]


A sub-property that indicates that execution agents within the same bulk execution may be parallelised. 


  struct parallel_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__bulk_guarantee_t__parallel_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__parallel_t.parallel_t [*parallel_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__parallel_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__parallel_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The bulk_guarantee_t::parallel_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__parallel_t.is_preferable [*is_preferable]] [static]]
    [The bulk_guarantee_t::parallel_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__parallel_t.is_requirable [*is_requirable]] [static]]
    [The bulk_guarantee_t::parallel_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/bulk_guarantee.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::bulk_guarantee_t::parallel_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__parallel_t.is_applicable_property_v..is_applicable_property_v..execution::bulk_guarantee_t::parallel_t] 
The [link boost_asio.reference.execution__bulk_guarantee_t__parallel_t `execution::bulk_guarantee_t::parallel_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::bulk_guarantee_t::parallel_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__parallel_t.is_preferable..is_preferable..execution::bulk_guarantee_t::parallel_t] 
The [link boost_asio.reference.execution__bulk_guarantee_t__parallel_t `execution::bulk_guarantee_t::parallel_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::bulk_guarantee_t::parallel_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__parallel_t.is_requirable..is_requirable..execution::bulk_guarantee_t::parallel_t] 
The [link boost_asio.reference.execution__bulk_guarantee_t__parallel_t `execution::bulk_guarantee_t::parallel_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:parallel_t execution::bulk_guarantee_t::parallel_t::parallel_t]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__parallel_t.parallel_t..parallel_t..execution::bulk_guarantee_t::parallel_t] 
Default constructor. 


  constexpr parallel_t();



[endsect]



[section:polymorphic_query_result_type execution::bulk_guarantee_t::parallel_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__parallel_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::bulk_guarantee_t::parallel_t] 
The type returned by queries against an `any_executor`. 


  typedef bulk_guarantee_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/bulk_guarantee.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:value execution::bulk_guarantee_t::parallel_t::value]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__parallel_t.value..value..execution::bulk_guarantee_t::parallel_t] 
Get the value associated with a property object. 


  static constexpr bulk_guarantee_t value();



[heading Return Value]
      
`parallel_t()`; 




[endsect]



[endsect]

[section:execution__bulk_guarantee_t__sequenced_t execution::bulk_guarantee_t::sequenced_t]

[indexterm1 boost_asio.indexterm.execution__bulk_guarantee_t__sequenced_t..execution::bulk_guarantee_t::sequenced_t]


A sub-property that indicates that execution agents within the same bulk execution may not be parallelised and vectorised. 


  struct sequenced_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__bulk_guarantee_t__sequenced_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__sequenced_t.sequenced_t [*sequenced_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__sequenced_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__sequenced_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The bulk_guarantee_t::sequenced_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__sequenced_t.is_preferable [*is_preferable]] [static]]
    [The bulk_guarantee_t::sequenced_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__sequenced_t.is_requirable [*is_requirable]] [static]]
    [The bulk_guarantee_t::sequenced_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/bulk_guarantee.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::bulk_guarantee_t::sequenced_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__sequenced_t.is_applicable_property_v..is_applicable_property_v..execution::bulk_guarantee_t::sequenced_t] 
The [link boost_asio.reference.execution__bulk_guarantee_t__sequenced_t `execution::bulk_guarantee_t::sequenced_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::bulk_guarantee_t::sequenced_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__sequenced_t.is_preferable..is_preferable..execution::bulk_guarantee_t::sequenced_t] 
The [link boost_asio.reference.execution__bulk_guarantee_t__sequenced_t `execution::bulk_guarantee_t::sequenced_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::bulk_guarantee_t::sequenced_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__sequenced_t.is_requirable..is_requirable..execution::bulk_guarantee_t::sequenced_t] 
The [link boost_asio.reference.execution__bulk_guarantee_t__sequenced_t `execution::bulk_guarantee_t::sequenced_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:polymorphic_query_result_type execution::bulk_guarantee_t::sequenced_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__sequenced_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::bulk_guarantee_t::sequenced_t] 
The type returned by queries against an `any_executor`. 


  typedef bulk_guarantee_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/bulk_guarantee.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:sequenced_t execution::bulk_guarantee_t::sequenced_t::sequenced_t]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__sequenced_t.sequenced_t..sequenced_t..execution::bulk_guarantee_t::sequenced_t] 
Default constructor. 


  constexpr sequenced_t();



[endsect]



[section:value execution::bulk_guarantee_t::sequenced_t::value]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__sequenced_t.value..value..execution::bulk_guarantee_t::sequenced_t] 
Get the value associated with a property object. 


  static constexpr bulk_guarantee_t value();



[heading Return Value]
      
`sequenced_t()`; 




[endsect]



[endsect]

[section:execution__bulk_guarantee_t__unsequenced_t execution::bulk_guarantee_t::unsequenced_t]

[indexterm1 boost_asio.indexterm.execution__bulk_guarantee_t__unsequenced_t..execution::bulk_guarantee_t::unsequenced_t]


A sub-property that indicates that execution agents within the same bulk execution may be parallelised and vectorised. 


  struct unsequenced_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__bulk_guarantee_t__unsequenced_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__unsequenced_t.unsequenced_t [*unsequenced_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__unsequenced_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__unsequenced_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The bulk_guarantee_t::unsequenced_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__unsequenced_t.is_preferable [*is_preferable]] [static]]
    [The bulk_guarantee_t::unsequenced_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__bulk_guarantee_t__unsequenced_t.is_requirable [*is_requirable]] [static]]
    [The bulk_guarantee_t::unsequenced_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/bulk_guarantee.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::bulk_guarantee_t::unsequenced_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__unsequenced_t.is_applicable_property_v..is_applicable_property_v..execution::bulk_guarantee_t::unsequenced_t] 
The [link boost_asio.reference.execution__bulk_guarantee_t__unsequenced_t `execution::bulk_guarantee_t::unsequenced_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::bulk_guarantee_t::unsequenced_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__unsequenced_t.is_preferable..is_preferable..execution::bulk_guarantee_t::unsequenced_t] 
The [link boost_asio.reference.execution__bulk_guarantee_t__unsequenced_t `execution::bulk_guarantee_t::unsequenced_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::bulk_guarantee_t::unsequenced_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__unsequenced_t.is_requirable..is_requirable..execution::bulk_guarantee_t::unsequenced_t] 
The [link boost_asio.reference.execution__bulk_guarantee_t__unsequenced_t `execution::bulk_guarantee_t::unsequenced_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:polymorphic_query_result_type execution::bulk_guarantee_t::unsequenced_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__unsequenced_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::bulk_guarantee_t::unsequenced_t] 
The type returned by queries against an `any_executor`. 


  typedef bulk_guarantee_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/bulk_guarantee.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:unsequenced_t execution::bulk_guarantee_t::unsequenced_t::unsequenced_t]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__unsequenced_t.unsequenced_t..unsequenced_t..execution::bulk_guarantee_t::unsequenced_t] 
Default constructor. 


  constexpr unsequenced_t();



[endsect]



[section:value execution::bulk_guarantee_t::unsequenced_t::value]

[indexterm2 boost_asio.indexterm.execution__bulk_guarantee_t__unsequenced_t.value..value..execution::bulk_guarantee_t::unsequenced_t] 
Get the value associated with a property object. 


  static constexpr bulk_guarantee_t value();



[heading Return Value]
      
`unsequenced_t()`; 




[endsect]



[endsect]

[section:execution__can_bulk_execute execution::can_bulk_execute]

[indexterm1 boost_asio.indexterm.execution__can_bulk_execute..execution::can_bulk_execute]


A type trait that determines whether a `bulk_execute` expression is well-formed. 


  template<
      typename S,
      typename F,
      typename N>
  struct can_bulk_execute


Class template `can_bulk_execute` is a trait that is derived from `true_type` if the expression `execution::bulk_execute(std::declval<S>(), std::declval<F>(), std::declval<N>)` is well formed; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/bulk_execute.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__can_connect execution::can_connect]

[indexterm1 boost_asio.indexterm.execution__can_connect..execution::can_connect]


A type trait that determines whether a `connect` expression is well-formed. 


  template<
      typename S,
      typename R>
  struct can_connect


Class template `can_connect` is a trait that is derived from `true_type` if the expression `execution::connect(std::declval<S>(), std::declval<R>())` is well formed; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/connect.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__can_execute execution::can_execute]

[indexterm1 boost_asio.indexterm.execution__can_execute..execution::can_execute]


A type trait that determines whether a `execute` expression is well-formed. 


  template<
      typename T,
      typename F>
  struct can_execute


Class template `can_execute` is a trait that is derived from `true_type` if the expression `execution::execute(std::declval<T>(), std::declval<F>())` is well formed; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/execute.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__can_schedule execution::can_schedule]

[indexterm1 boost_asio.indexterm.execution__can_schedule..execution::can_schedule]


A type trait that determines whether a `schedule` expression is well-formed. 


  template<
      typename S>
  struct can_schedule


Class template `can_schedule` is a trait that is derived from `true_type` if the expression `execution::schedule(std::declval<S>())` is well formed; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/schedule.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__can_set_done execution::can_set_done]

[indexterm1 boost_asio.indexterm.execution__can_set_done..execution::can_set_done]


A type trait that determines whether a `set_done` expression is well-formed. 


  template<
      typename R>
  struct can_set_done


Class template `can_set_done` is a trait that is derived from `true_type` if the expression `execution::set_done(std::declval<R>(), std::declval<E>())` is well formed; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/set_done.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__can_set_error execution::can_set_error]

[indexterm1 boost_asio.indexterm.execution__can_set_error..execution::can_set_error]


A type trait that determines whether a `set_error` expression is well-formed. 


  template<
      typename R,
      typename E>
  struct can_set_error


Class template `can_set_error` is a trait that is derived from `true_type` if the expression `execution::set_error(std::declval<R>(), std::declval<E>())` is well formed; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/set_error.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__can_set_value execution::can_set_value]

[indexterm1 boost_asio.indexterm.execution__can_set_value..execution::can_set_value]


A type trait that determines whether a `set_value` expression is well-formed. 


  template<
      typename R,
      typename... Vs>
  struct can_set_value


Class template `can_set_value` is a trait that is derived from `true_type` if the expression `execution::set_value(std::declval<R>(), std::declval<Vs>()...)` is well formed; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/set_value.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__can_start execution::can_start]

[indexterm1 boost_asio.indexterm.execution__can_start..execution::can_start]


A type trait that determines whether a `start` expression is well-formed. 


  template<
      typename R>
  struct can_start


Class template `can_start` is a trait that is derived from `true_type` if the expression `execution::start(std::declval<R>(), std::declval<E>())` is well formed; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/start.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__can_submit execution::can_submit]

[indexterm1 boost_asio.indexterm.execution__can_submit..execution::can_submit]


A type trait that determines whether a `submit` expression is well-formed. 


  template<
      typename S,
      typename R>
  struct can_submit


Class template `can_submit` is a trait that is derived from `true_type` if the expression `execution::submit(std::declval<R>(), std::declval<E>())` is well formed; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/submit.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__connect execution::connect]

[indexterm1 boost_asio.indexterm.execution__connect..execution::connect] 
A customisation point that connects a sender to a receiver. 


  constexpr unspecified connect = unspecified;


The name `execution::connect` denotes a customisation point object. For some subexpressions `s` and `r`, let `S` be a type such that `decltype((s))` is `S` and let `R` be a type such that `decltype((r))` is `R`. The expression `execution::connect(s, r)` is expression-equivalent to:


* `s.connect(r)`, if that expression is valid, if its type satisfies `operation_state`, and if `S` satisfies `sender`.


* Otherwise, `connect(s, r)`, if that expression is valid, if its type satisfies `operation_state`, and if `S` satisfies `sender`, with overload resolution performed in a context that includes the declaration `void connect();` and that does not include a declaration of `execution::connect`.


* Otherwise, `as_operation{s, r}`, if `r` is not an instance of `as_receiver<F, S>` for some type `F`, and if `receiver_of<R> && executor_of<remove_cvref_t<S>, as_invocable<remove_cvref_t<R>, S>>` is `true`, where `as_operation` is an implementation-defined class equivalent to 

   template <class S, class R>
    struct as_operation
    {
      remove_cvref_t<S> e_;
      remove_cvref_t<R> r_;
      void start() noexcept try {
        execution::execute(std::move(e_),
            as_invocable<remove_cvref_t<R>, S>{r_});
      } catch(...) {
        execution::set_error(std::move(r_), current_exception());
      }
    }; 


and `as_invocable` is a class template equivalent to the following: 

   template<class R>
    struct as_invocable
    {
      R* r_;
      explicit as_invocable(R& r) noexcept
        : r_(std::addressof(r)) {}
      as_invocable(as_invocable && other) noexcept
        : r_(std::exchange(other.r_, nullptr)) {}
      ~as_invocable() {
        if(r_)
          execution::set_done(std::move(*r_));
      }
      void operator()() & noexcept try {
        execution::set_value(std::move(*r_));
        r_ = nullptr;
      } catch(...) {
        execution::set_error(std::move(*r_), current_exception());
        r_ = nullptr;
      }
    };





* Otherwise, `execution::connect(s, r)` is ill-formed. 



[heading Requirements]

['Header: ][^boost/asio/execution/connect.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__connect_result execution::connect_result]

[indexterm1 boost_asio.indexterm.execution__connect_result..execution::connect_result]


A type trait to determine the result of a `connect` expression. 


  template<
      typename S,
      typename R>
  struct connect_result


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__connect_result.type [*type]]]
    [The type of the connect expression. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/connect.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:type execution::connect_result::type]

[indexterm2 boost_asio.indexterm.execution__connect_result.type..type..execution::connect_result] 
The type of the connect expression. 


  typedef automatically_determined type;



The type of the expression `execution::connect(std::declval<S>(), std::declval<R>())`. 

[heading Requirements]

['Header: ][^boost/asio/execution/connect.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[endsect]


[section:execution__context execution::context]

[indexterm1 boost_asio.indexterm.execution__context..execution::context] 
A special value used for accessing the [link boost_asio.reference.execution__context_t `execution::context_t`] property. 


  constexpr context_t context;


[heading Requirements]

['Header: ][^boost/asio/execution/context.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:execution__context_as execution::context_as]

[indexterm1 boost_asio.indexterm.execution__context_as..execution::context_as] 
A special value used for accessing the [link boost_asio.reference.execution__context_as_t `execution::context_as_t`] property. 


  template <typename U>
  constexpr context_as_t context_as;


[heading Requirements]

['Header: ][^boost/asio/execution/context_as.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__context_as_t execution::context_as_t]

[indexterm1 boost_asio.indexterm.execution__context_as_t..execution::context_as_t]


A property that is used to obtain the execution context that is associated with an executor. 


  template<
      typename U>
  struct context_as_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__context_as_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__context_as_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The context_as_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__context_as_t.is_preferable [*is_preferable]] [static]]
    [The context_t property cannot be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__context_as_t.is_requirable [*is_requirable]] [static]]
    [The context_t property cannot be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/context_as.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::context_as_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__context_as_t.is_applicable_property_v..is_applicable_property_v..execution::context_as_t] 
The [link boost_asio.reference.execution__context_as_t `execution::context_as_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
    is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::context_as_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__context_as_t.is_preferable..is_preferable..execution::context_as_t] 
The [link boost_asio.reference.execution__context_t `execution::context_t`] property cannot be preferred. 


  static constexpr bool is_preferable = false;



[endsect]



[section:is_requirable execution::context_as_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__context_as_t.is_requirable..is_requirable..execution::context_as_t] 
The [link boost_asio.reference.execution__context_t `execution::context_t`] property cannot be required. 


  static constexpr bool is_requirable = false;



[endsect]



[section:polymorphic_query_result_type execution::context_as_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__context_as_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::context_as_t] 
The type returned by queries against an `any_executor`. 


  typedef T polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/context_as.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[endsect]

[section:execution__context_t execution::context_t]

[indexterm1 boost_asio.indexterm.execution__context_t..execution::context_t]


A property that is used to obtain the execution context that is associated with an executor. 


  struct context_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__context_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__context_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The context_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__context_t.is_preferable [*is_preferable]] [static]]
    [The context_t property cannot be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__context_t.is_requirable [*is_requirable]] [static]]
    [The context_t property cannot be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/context.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::context_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__context_t.is_applicable_property_v..is_applicable_property_v..execution::context_t] 
The [link boost_asio.reference.execution__context_t `execution::context_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
    is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::context_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__context_t.is_preferable..is_preferable..execution::context_t] 
The [link boost_asio.reference.execution__context_t `execution::context_t`] property cannot be preferred. 


  static constexpr bool is_preferable = false;



[endsect]



[section:is_requirable execution::context_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__context_t.is_requirable..is_requirable..execution::context_t] 
The [link boost_asio.reference.execution__context_t `execution::context_t`] property cannot be required. 


  static constexpr bool is_requirable = false;



[endsect]



[section:polymorphic_query_result_type execution::context_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__context_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::context_t] 
The type returned by queries against an `any_executor`. 


  typedef std::any polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/context.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[endsect]


[section:execution__execute execution::execute]

[indexterm1 boost_asio.indexterm.execution__execute..execution::execute] 
A customisation point that executes a function on an executor. 


  constexpr unspecified execute = unspecified;


The name `execution::execute` denotes a customisation point object.

For some subexpressions `e` and `f`, let `E` be a type such that `decltype((e))` is `E` and let `F` be a type such that `decltype((f))` is `F`. The expression `execution::execute(e, f)` is ill-formed if `F` does not model `invocable`, or if `E` does not model either `executor` or `sender`. Otherwise, it is expression-equivalent to:


* `e.execute(f)`, if that expression is valid. If the function selected does not execute the function object `f` on the executor `e`, the program is ill-formed with no diagnostic required.


* Otherwise, `execute(e, f)`, if that expression is valid, with overload resolution performed in a context that includes the declaration `void execute();` and that does not include a declaration of `execution::execute`. If the function selected by overload resolution does not execute the function object `f` on the executor `e`, the program is ill-formed with no diagnostic required. 



[heading Requirements]

['Header: ][^boost/asio/execution/execute.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__executor_index execution::executor_index]

[indexterm1 boost_asio.indexterm.execution__executor_index..execution::executor_index]


The [link boost_asio.reference.execution__executor_index `execution::executor_index`] trait detects the type used by an executor to represent an index within a bulk operation. 


  template<
      typename T>
  struct executor_index


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__executor_index.type [*type]]]
    [T::index_type if T::index_type is valid, otherwise executor_shape_t<T>. ]
  
  ]

]

Class template `executor_index` is a type trait with a nested type alias `type` whose type is `T::index_type` if `T::index_type` is valid, otherwise `executor_shape_t<T>`. 

[heading Requirements]

['Header: ][^boost/asio/execution/executor.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:type execution::executor_index::type]

[indexterm2 boost_asio.indexterm.execution__executor_index.type..type..execution::executor_index] 
`T::index_type` if `T::index_type` is valid, otherwise `executor_shape_t<T>`. 


  typedef automatically_determined type;



[heading Requirements]

['Header: ][^boost/asio/execution/executor.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[endsect]

[section:execution__executor_shape execution::executor_shape]

[indexterm1 boost_asio.indexterm.execution__executor_shape..execution::executor_shape]


The [link boost_asio.reference.execution__executor_shape `execution::executor_shape`] trait detects the type used by an executor to represent the shape of a bulk operation. 


  template<
      typename T>
  struct executor_shape


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__executor_shape.type [*type]]]
    [T::shape_type if T::shape_type is valid, otherwise std::size_t. ]
  
  ]

]

Class template `executor_shape` is a type trait with a nested type alias `type` whose type is `T::shape_type` if `T::shape_type` is valid, otherwise `std::size_t`. 

[heading Requirements]

['Header: ][^boost/asio/execution/executor.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:type execution::executor_shape::type]

[indexterm2 boost_asio.indexterm.execution__executor_shape.type..type..execution::executor_shape] 
`T::shape_type` if `T::shape_type` is valid, otherwise `std::size_t`. 


  typedef automatically_determined type;



[heading Requirements]

['Header: ][^boost/asio/execution/executor.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[endsect]

[section:execution__invocable_archetype execution::invocable_archetype]

[indexterm1 boost_asio.indexterm.execution__invocable_archetype..execution::invocable_archetype]


An archetypal function object used for determining adherence to the execution::executor concept. 


  struct invocable_archetype


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__invocable_archetype.operator_lp__rp_ [*operator()]]]
    [Function call operator. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution/invocable_archetype.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:operator_lp__rp_ execution::invocable_archetype::operator()]

[indexterm2 boost_asio.indexterm.execution__invocable_archetype.operator_lp__rp_..operator()..execution::invocable_archetype] 
Function call operator. 


  template<
      typename... Args>
  void operator()(
      Args && ...);



[endsect]



[endsect]

[section:execution__is_executor execution::is_executor]

[indexterm1 boost_asio.indexterm.execution__is_executor..execution::is_executor]


The [link boost_asio.reference.execution__is_executor `execution::is_executor`] trait detects whether a type T satisfies the execution::executor concept. 


  template<
      typename T>
  struct is_executor


Class template `is_executor` is a UnaryTypeTrait that is derived from `true_type` if the type `T` meets the concept definition for an executor, otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/executor.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__is_executor_of execution::is_executor_of]

[indexterm1 boost_asio.indexterm.execution__is_executor_of..execution::is_executor_of]


The [link boost_asio.reference.execution__is_executor_of `execution::is_executor_of`] trait detects whether a type T satisfies the execution::executor\_of concept for some set of value arguments. 


  template<
      typename T,
      typename F>
  struct is_executor_of


Class template `is_executor_of` is a type trait that is derived from `true_type` if the type `T` meets the concept definition for an executor that is invocable with a function object of type `F`, otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/executor.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__is_nothrow_receiver_of execution::is_nothrow_receiver_of]

[indexterm1 boost_asio.indexterm.execution__is_nothrow_receiver_of..execution::is_nothrow_receiver_of]


The [link boost_asio.reference.execution__is_nothrow_receiver_of `execution::is_nothrow_receiver_of`] trait detects whether a type T satisfies the execution::receiver\_of concept for some set of value arguments, with a noexcept `set_value` operation. 


  template<
      typename T,
      typename... Vs>
  struct is_nothrow_receiver_of


Class template `is_nothrow_receiver_of` is a type trait that is derived from `true_type` if the type `T` meets the concept definition for a receiver for value arguments `Vs`, and the expression `execution::set_value(declval<T>(), declval<Ts>()...)` is noexcept, otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/receiver.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__is_operation_state execution::is_operation_state]

[indexterm1 boost_asio.indexterm.execution__is_operation_state..execution::is_operation_state]


The [link boost_asio.reference.execution__is_operation_state `execution::is_operation_state`] trait detects whether a type T satisfies the execution::operation\_state concept. 


  template<
      typename T>
  struct is_operation_state


Class template `is_operation_state` is a type trait that is derived from `true_type` if the type `T` meets the concept definition for an `operation_state`, otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/operation_state.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__is_receiver execution::is_receiver]

[indexterm1 boost_asio.indexterm.execution__is_receiver..execution::is_receiver]


The [link boost_asio.reference.execution__is_receiver `execution::is_receiver`] trait detects whether a type T satisfies the execution::receiver concept. 


  template<
      typename T,
      typename E = std::exception_ptr>
  struct is_receiver


Class template `is_receiver` is a type trait that is derived from `true_type` if the type `T` meets the concept definition for a receiver for error type `E`, otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/receiver.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__is_receiver_of execution::is_receiver_of]

[indexterm1 boost_asio.indexterm.execution__is_receiver_of..execution::is_receiver_of]


The [link boost_asio.reference.execution__is_receiver_of `execution::is_receiver_of`] trait detects whether a type T satisfies the execution::receiver\_of concept for some set of value arguments. 


  template<
      typename T,
      typename... Vs>
  struct is_receiver_of


Class template `is_receiver_of` is a type trait that is derived from `true_type` if the type `T` meets the concept definition for a receiver for value arguments `Vs`, otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/receiver.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__is_scheduler execution::is_scheduler]

[indexterm1 boost_asio.indexterm.execution__is_scheduler..execution::is_scheduler]


The [link boost_asio.reference.execution__is_scheduler `execution::is_scheduler`] trait detects whether a type T satisfies the execution::scheduler concept. 


  template<
      typename T>
  struct is_scheduler


Class template `is_scheduler` is a type trait that is derived from `true_type` if the type `T` meets the concept definition for a scheduler for error type `E`, otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/scheduler.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__is_sender execution::is_sender]

[indexterm1 boost_asio.indexterm.execution__is_sender..execution::is_sender]


The [link boost_asio.reference.execution__is_sender `execution::is_sender`] trait detects whether a type T satisfies the execution::sender concept. 


  template<
      typename T>
  struct is_sender


Class template `is_sender` is a type trait that is derived from `true_type` if the type `T` meets the concept definition for a sender, otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/execution/sender.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__is_sender_to execution::is_sender_to]

[indexterm1 boost_asio.indexterm.execution__is_sender_to..execution::is_sender_to]


The [link boost_asio.reference.execution__is_sender_to `execution::is_sender_to`] trait detects whether a type T satisfies the execution::sender\_to concept for some receiver. 


  template<
      typename T,
      typename R>
  struct is_sender_to


Class template `is_sender_to` is a type trait that is derived from `true_type` if the type `T` meets the concept definition for a sender for some receiver type R, otherwise `false`. 

[heading Requirements]

['Header: ][^boost/asio/execution/sender.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]

[section:execution__is_typed_sender execution::is_typed_sender]

[indexterm1 boost_asio.indexterm.execution__is_typed_sender..execution::is_typed_sender]


The [link boost_asio.reference.execution__is_typed_sender `execution::is_typed_sender`] trait detects whether a type T satisfies the execution::typed\_sender concept. 


  template<
      typename T>
  struct is_typed_sender


Class template `is_typed_sender` is a type trait that is derived from `true_type` if the type `T` meets the concept definition for a typed sender, otherwise `false`. 

[heading Requirements]

['Header: ][^boost/asio/execution/sender.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__mapping execution::mapping]

[indexterm1 boost_asio.indexterm.execution__mapping..execution::mapping] 
A special value used for accessing the [link boost_asio.reference.execution__mapping_t `execution::mapping_t`] property. 


  constexpr mapping_t mapping;


[heading Requirements]

['Header: ][^boost/asio/execution/mapping.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__mapping_t execution::mapping_t]

[indexterm1 boost_asio.indexterm.execution__mapping_t..execution::mapping_t]


A property to describe what guarantees an executor makes about the mapping of execution agents on to threads of execution. 


  struct mapping_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__mapping_t__new_thread_t [*new_thread_t]]]
    [A sub-property that indicates that execution agents are mapped on to new threads of execution. ]
  
  ]

  [

    [[link boost_asio.reference.execution__mapping_t__other_t [*other_t]]]
    [A sub-property that indicates that the mapping of execution agents is implementation-defined. ]
  
  ]

  [

    [[link boost_asio.reference.execution__mapping_t__thread_t [*thread_t]]]
    [A sub-property that indicates that execution agents are mapped on to threads of execution. ]
  
  ]

  [

    [[link boost_asio.reference.execution__mapping_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__mapping_t.mapping_t [*mapping_t]] [constructor]]
    [Default constructor. 
     [hr]
     Construct from a sub-property value. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__mapping_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The mapping_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__mapping_t.is_preferable [*is_preferable]] [static]]
    [The top-level mapping_t property cannot be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__mapping_t.is_requirable [*is_requirable]] [static]]
    [The top-level mapping_t property cannot be required. ]
  ]

  [
    [[link boost_asio.reference.execution__mapping_t.new_thread [*new_thread]] [static]]
    [A special value used for accessing the mapping_t::new_thread_t property. ]
  ]

  [
    [[link boost_asio.reference.execution__mapping_t.other [*other]] [static]]
    [A special value used for accessing the mapping_t::other_t property. ]
  ]

  [
    [[link boost_asio.reference.execution__mapping_t.thread [*thread]] [static]]
    [A special value used for accessing the mapping_t::thread_t property. ]
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__mapping_t.operator_not__eq_ [*operator!=]]]
    [Compare property values for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.execution__mapping_t.operator_eq__eq_ [*operator==]]]
    [Compare property values for equality. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution/mapping.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::mapping_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__mapping_t.is_applicable_property_v..is_applicable_property_v..execution::mapping_t] 
The [link boost_asio.reference.execution__mapping_t `execution::mapping_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
    is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::mapping_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__mapping_t.is_preferable..is_preferable..execution::mapping_t] 
The top-level [link boost_asio.reference.execution__mapping_t `execution::mapping_t`] property cannot be preferred. 


  static constexpr bool is_preferable = false;



[endsect]



[section:is_requirable execution::mapping_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__mapping_t.is_requirable..is_requirable..execution::mapping_t] 
The top-level [link boost_asio.reference.execution__mapping_t `execution::mapping_t`] property cannot be required. 


  static constexpr bool is_requirable = false;



[endsect]


[section:mapping_t execution::mapping_t::mapping_t]

[indexterm2 boost_asio.indexterm.execution__mapping_t.mapping_t..mapping_t..execution::mapping_t] 
Default constructor. 


  constexpr ``[link boost_asio.reference.execution__mapping_t.mapping_t.overload1 mapping_t]``();
  ``  [''''&raquo;''' [link boost_asio.reference.execution__mapping_t.mapping_t.overload1 more...]]``


Construct from a sub-property value. 


  constexpr ``[link boost_asio.reference.execution__mapping_t.mapping_t.overload2 mapping_t]``(
      thread_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__mapping_t.mapping_t.overload2 more...]]``

  constexpr ``[link boost_asio.reference.execution__mapping_t.mapping_t.overload3 mapping_t]``(
      new_thread_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__mapping_t.mapping_t.overload3 more...]]``

  constexpr ``[link boost_asio.reference.execution__mapping_t.mapping_t.overload4 mapping_t]``(
      other_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__mapping_t.mapping_t.overload4 more...]]``


[section:overload1 execution::mapping_t::mapping_t (1 of 4 overloads)]


Default constructor. 


  constexpr mapping_t();



[endsect]



[section:overload2 execution::mapping_t::mapping_t (2 of 4 overloads)]


Construct from a sub-property value. 


  constexpr mapping_t(
      thread_t );



[endsect]



[section:overload3 execution::mapping_t::mapping_t (3 of 4 overloads)]


Construct from a sub-property value. 


  constexpr mapping_t(
      new_thread_t );



[endsect]



[section:overload4 execution::mapping_t::mapping_t (4 of 4 overloads)]


Construct from a sub-property value. 


  constexpr mapping_t(
      other_t );



[endsect]


[endsect]


[section:new_thread execution::mapping_t::new_thread]

[indexterm2 boost_asio.indexterm.execution__mapping_t.new_thread..new_thread..execution::mapping_t] 
A special value used for accessing the [link boost_asio.reference.execution__mapping_t__new_thread_t `execution::mapping_t::new_thread_t`] property. 


  static constexpr new_thread_t new_thread;



[endsect]



[section:operator_not__eq_ execution::mapping_t::operator!=]

[indexterm2 boost_asio.indexterm.execution__mapping_t.operator_not__eq_..operator!=..execution::mapping_t] 
Compare property values for inequality. 


  friend constexpr bool operator!=(
      const mapping_t & a,
      const mapping_t & b);


[heading Requirements]

['Header: ][^boost/asio/execution/mapping.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:operator_eq__eq_ execution::mapping_t::operator==]

[indexterm2 boost_asio.indexterm.execution__mapping_t.operator_eq__eq_..operator==..execution::mapping_t] 
Compare property values for equality. 


  friend constexpr bool operator==(
      const mapping_t & a,
      const mapping_t & b);


[heading Requirements]

['Header: ][^boost/asio/execution/mapping.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:other execution::mapping_t::other]

[indexterm2 boost_asio.indexterm.execution__mapping_t.other..other..execution::mapping_t] 
A special value used for accessing the [link boost_asio.reference.execution__mapping_t__other_t `execution::mapping_t::other_t`] property. 


  static constexpr other_t other;



[endsect]



[section:polymorphic_query_result_type execution::mapping_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__mapping_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::mapping_t] 
The type returned by queries against an `any_executor`. 


  typedef mapping_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/mapping.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:thread execution::mapping_t::thread]

[indexterm2 boost_asio.indexterm.execution__mapping_t.thread..thread..execution::mapping_t] 
A special value used for accessing the [link boost_asio.reference.execution__mapping_t__thread_t `execution::mapping_t::thread_t`] property. 


  static constexpr thread_t thread;



[endsect]



[endsect]

[section:execution__mapping_t__new_thread_t execution::mapping_t::new_thread_t]

[indexterm1 boost_asio.indexterm.execution__mapping_t__new_thread_t..execution::mapping_t::new_thread_t]


A sub-property that indicates that execution agents are mapped on to new threads of execution. 


  struct new_thread_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__mapping_t__new_thread_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__mapping_t__new_thread_t.new_thread_t [*new_thread_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__mapping_t__new_thread_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__mapping_t__new_thread_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The mapping_t::new_thread_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__mapping_t__new_thread_t.is_preferable [*is_preferable]] [static]]
    [The mapping_t::new_thread_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__mapping_t__new_thread_t.is_requirable [*is_requirable]] [static]]
    [The mapping_t::new_thread_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/mapping.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::mapping_t::new_thread_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__mapping_t__new_thread_t.is_applicable_property_v..is_applicable_property_v..execution::mapping_t::new_thread_t] 
The [link boost_asio.reference.execution__mapping_t__new_thread_t `execution::mapping_t::new_thread_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::mapping_t::new_thread_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__mapping_t__new_thread_t.is_preferable..is_preferable..execution::mapping_t::new_thread_t] 
The [link boost_asio.reference.execution__mapping_t__new_thread_t `execution::mapping_t::new_thread_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::mapping_t::new_thread_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__mapping_t__new_thread_t.is_requirable..is_requirable..execution::mapping_t::new_thread_t] 
The [link boost_asio.reference.execution__mapping_t__new_thread_t `execution::mapping_t::new_thread_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:new_thread_t execution::mapping_t::new_thread_t::new_thread_t]

[indexterm2 boost_asio.indexterm.execution__mapping_t__new_thread_t.new_thread_t..new_thread_t..execution::mapping_t::new_thread_t] 
Default constructor. 


  constexpr new_thread_t();



[endsect]



[section:polymorphic_query_result_type execution::mapping_t::new_thread_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__mapping_t__new_thread_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::mapping_t::new_thread_t] 
The type returned by queries against an `any_executor`. 


  typedef mapping_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/mapping.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:value execution::mapping_t::new_thread_t::value]

[indexterm2 boost_asio.indexterm.execution__mapping_t__new_thread_t.value..value..execution::mapping_t::new_thread_t] 
Get the value associated with a property object. 


  static constexpr mapping_t value();



[heading Return Value]
      
`new_thread_t()`; 




[endsect]



[endsect]

[section:execution__mapping_t__other_t execution::mapping_t::other_t]

[indexterm1 boost_asio.indexterm.execution__mapping_t__other_t..execution::mapping_t::other_t]


A sub-property that indicates that the mapping of execution agents is implementation-defined. 


  struct other_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__mapping_t__other_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__mapping_t__other_t.other_t [*other_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__mapping_t__other_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__mapping_t__other_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The mapping_t::other_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__mapping_t__other_t.is_preferable [*is_preferable]] [static]]
    [The mapping_t::other_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__mapping_t__other_t.is_requirable [*is_requirable]] [static]]
    [The mapping_t::other_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/mapping.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::mapping_t::other_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__mapping_t__other_t.is_applicable_property_v..is_applicable_property_v..execution::mapping_t::other_t] 
The [link boost_asio.reference.execution__mapping_t__other_t `execution::mapping_t::other_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::mapping_t::other_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__mapping_t__other_t.is_preferable..is_preferable..execution::mapping_t::other_t] 
The [link boost_asio.reference.execution__mapping_t__other_t `execution::mapping_t::other_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::mapping_t::other_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__mapping_t__other_t.is_requirable..is_requirable..execution::mapping_t::other_t] 
The [link boost_asio.reference.execution__mapping_t__other_t `execution::mapping_t::other_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:other_t execution::mapping_t::other_t::other_t]

[indexterm2 boost_asio.indexterm.execution__mapping_t__other_t.other_t..other_t..execution::mapping_t::other_t] 
Default constructor. 


  constexpr other_t();



[endsect]



[section:polymorphic_query_result_type execution::mapping_t::other_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__mapping_t__other_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::mapping_t::other_t] 
The type returned by queries against an `any_executor`. 


  typedef mapping_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/mapping.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:value execution::mapping_t::other_t::value]

[indexterm2 boost_asio.indexterm.execution__mapping_t__other_t.value..value..execution::mapping_t::other_t] 
Get the value associated with a property object. 


  static constexpr mapping_t value();



[heading Return Value]
      
`other_t()`; 




[endsect]



[endsect]

[section:execution__mapping_t__thread_t execution::mapping_t::thread_t]

[indexterm1 boost_asio.indexterm.execution__mapping_t__thread_t..execution::mapping_t::thread_t]


A sub-property that indicates that execution agents are mapped on to threads of execution. 


  struct thread_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__mapping_t__thread_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__mapping_t__thread_t.thread_t [*thread_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__mapping_t__thread_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__mapping_t__thread_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The mapping_t::thread_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__mapping_t__thread_t.is_preferable [*is_preferable]] [static]]
    [The mapping_t::thread_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__mapping_t__thread_t.is_requirable [*is_requirable]] [static]]
    [The mapping_t::thread_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/mapping.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::mapping_t::thread_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__mapping_t__thread_t.is_applicable_property_v..is_applicable_property_v..execution::mapping_t::thread_t] 
The [link boost_asio.reference.execution__mapping_t__thread_t `execution::mapping_t::thread_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::mapping_t::thread_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__mapping_t__thread_t.is_preferable..is_preferable..execution::mapping_t::thread_t] 
The [link boost_asio.reference.execution__mapping_t__thread_t `execution::mapping_t::thread_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::mapping_t::thread_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__mapping_t__thread_t.is_requirable..is_requirable..execution::mapping_t::thread_t] 
The [link boost_asio.reference.execution__mapping_t__thread_t `execution::mapping_t::thread_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:polymorphic_query_result_type execution::mapping_t::thread_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__mapping_t__thread_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::mapping_t::thread_t] 
The type returned by queries against an `any_executor`. 


  typedef mapping_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/mapping.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:thread_t execution::mapping_t::thread_t::thread_t]

[indexterm2 boost_asio.indexterm.execution__mapping_t__thread_t.thread_t..thread_t..execution::mapping_t::thread_t] 
Default constructor. 


  constexpr thread_t();



[endsect]



[section:value execution::mapping_t::thread_t::value]

[indexterm2 boost_asio.indexterm.execution__mapping_t__thread_t.value..value..execution::mapping_t::thread_t] 
Get the value associated with a property object. 


  static constexpr mapping_t value();



[heading Return Value]
      
`thread_t()`; 




[endsect]



[endsect]


[section:execution__occupancy execution::occupancy]

[indexterm1 boost_asio.indexterm.execution__occupancy..execution::occupancy] 
A special value used for accessing the [link boost_asio.reference.execution__occupancy_t `execution::occupancy_t`] property. 


  constexpr occupancy_t occupancy;


[heading Requirements]

['Header: ][^boost/asio/execution/occupancy.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__occupancy_t execution::occupancy_t]

[indexterm1 boost_asio.indexterm.execution__occupancy_t..execution::occupancy_t]


A property that gives an estimate of the number of execution agents that should occupy the associated execution context. 


  struct occupancy_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__occupancy_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__occupancy_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The occupancy_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__occupancy_t.is_preferable [*is_preferable]] [static]]
    [The occupancy_t property cannot be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__occupancy_t.is_requirable [*is_requirable]] [static]]
    [The occupancy_t property cannot be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/occupancy.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::occupancy_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__occupancy_t.is_applicable_property_v..is_applicable_property_v..execution::occupancy_t] 
The [link boost_asio.reference.execution__occupancy_t `execution::occupancy_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
    is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::occupancy_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__occupancy_t.is_preferable..is_preferable..execution::occupancy_t] 
The [link boost_asio.reference.execution__occupancy_t `execution::occupancy_t`] property cannot be preferred. 


  static constexpr bool is_preferable = false;



[endsect]



[section:is_requirable execution::occupancy_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__occupancy_t.is_requirable..is_requirable..execution::occupancy_t] 
The [link boost_asio.reference.execution__occupancy_t `execution::occupancy_t`] property cannot be required. 


  static constexpr bool is_requirable = false;



[endsect]



[section:polymorphic_query_result_type execution::occupancy_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__occupancy_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::occupancy_t] 
The type returned by queries against an `any_executor`. 


  typedef std::size_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/occupancy.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[endsect]


[section:execution__outstanding_work execution::outstanding_work]

[indexterm1 boost_asio.indexterm.execution__outstanding_work..execution::outstanding_work] 
A special value used for accessing the [link boost_asio.reference.execution__outstanding_work_t `execution::outstanding_work_t`] property. 


  constexpr outstanding_work_t outstanding_work;


[heading Requirements]

['Header: ][^boost/asio/execution/outstanding_work.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__outstanding_work_t execution::outstanding_work_t]

[indexterm1 boost_asio.indexterm.execution__outstanding_work_t..execution::outstanding_work_t]


A property to describe whether task submission is likely in the future. 


  struct outstanding_work_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__outstanding_work_t__tracked_t [*tracked_t]]]
    [A sub-property that indicates that the executor represents likely future submission of a function object. ]
  
  ]

  [

    [[link boost_asio.reference.execution__outstanding_work_t__untracked_t [*untracked_t]]]
    [A sub-property that indicates that the executor does not represent likely future submission of a function object. ]
  
  ]

  [

    [[link boost_asio.reference.execution__outstanding_work_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__outstanding_work_t.outstanding_work_t [*outstanding_work_t]] [constructor]]
    [Default constructor. 
     [hr]
     Construct from a sub-property value. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__outstanding_work_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The outstanding_work_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__outstanding_work_t.is_preferable [*is_preferable]] [static]]
    [The top-level outstanding_work_t property cannot be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__outstanding_work_t.is_requirable [*is_requirable]] [static]]
    [The top-level outstanding_work_t property cannot be required. ]
  ]

  [
    [[link boost_asio.reference.execution__outstanding_work_t.tracked [*tracked]] [static]]
    [A special value used for accessing the outstanding_work_t::tracked_t property. ]
  ]

  [
    [[link boost_asio.reference.execution__outstanding_work_t.untracked [*untracked]] [static]]
    [A special value used for accessing the outstanding_work_t::untracked_t property. ]
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__outstanding_work_t.operator_not__eq_ [*operator!=]]]
    [Compare property values for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.execution__outstanding_work_t.operator_eq__eq_ [*operator==]]]
    [Compare property values for equality. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution/outstanding_work.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::outstanding_work_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t.is_applicable_property_v..is_applicable_property_v..execution::outstanding_work_t] 
The [link boost_asio.reference.execution__outstanding_work_t `execution::outstanding_work_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
    is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::outstanding_work_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t.is_preferable..is_preferable..execution::outstanding_work_t] 
The top-level [link boost_asio.reference.execution__outstanding_work_t `execution::outstanding_work_t`] property cannot be preferred. 


  static constexpr bool is_preferable = false;



[endsect]



[section:is_requirable execution::outstanding_work_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t.is_requirable..is_requirable..execution::outstanding_work_t] 
The top-level [link boost_asio.reference.execution__outstanding_work_t `execution::outstanding_work_t`] property cannot be required. 


  static constexpr bool is_requirable = false;



[endsect]



[section:operator_not__eq_ execution::outstanding_work_t::operator!=]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t.operator_not__eq_..operator!=..execution::outstanding_work_t] 
Compare property values for inequality. 


  friend constexpr bool operator!=(
      const outstanding_work_t & a,
      const outstanding_work_t & b);


[heading Requirements]

['Header: ][^boost/asio/execution/outstanding_work.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:operator_eq__eq_ execution::outstanding_work_t::operator==]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t.operator_eq__eq_..operator==..execution::outstanding_work_t] 
Compare property values for equality. 


  friend constexpr bool operator==(
      const outstanding_work_t & a,
      const outstanding_work_t & b);


[heading Requirements]

['Header: ][^boost/asio/execution/outstanding_work.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:outstanding_work_t execution::outstanding_work_t::outstanding_work_t]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t.outstanding_work_t..outstanding_work_t..execution::outstanding_work_t] 
Default constructor. 


  constexpr ``[link boost_asio.reference.execution__outstanding_work_t.outstanding_work_t.overload1 outstanding_work_t]``();
  ``  [''''&raquo;''' [link boost_asio.reference.execution__outstanding_work_t.outstanding_work_t.overload1 more...]]``


Construct from a sub-property value. 


  constexpr ``[link boost_asio.reference.execution__outstanding_work_t.outstanding_work_t.overload2 outstanding_work_t]``(
      untracked_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__outstanding_work_t.outstanding_work_t.overload2 more...]]``

  constexpr ``[link boost_asio.reference.execution__outstanding_work_t.outstanding_work_t.overload3 outstanding_work_t]``(
      tracked_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__outstanding_work_t.outstanding_work_t.overload3 more...]]``


[section:overload1 execution::outstanding_work_t::outstanding_work_t (1 of 3 overloads)]


Default constructor. 


  constexpr outstanding_work_t();



[endsect]



[section:overload2 execution::outstanding_work_t::outstanding_work_t (2 of 3 overloads)]


Construct from a sub-property value. 


  constexpr outstanding_work_t(
      untracked_t );



[endsect]



[section:overload3 execution::outstanding_work_t::outstanding_work_t (3 of 3 overloads)]


Construct from a sub-property value. 


  constexpr outstanding_work_t(
      tracked_t );



[endsect]


[endsect]


[section:polymorphic_query_result_type execution::outstanding_work_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::outstanding_work_t] 
The type returned by queries against an `any_executor`. 


  typedef outstanding_work_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/outstanding_work.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:tracked execution::outstanding_work_t::tracked]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t.tracked..tracked..execution::outstanding_work_t] 
A special value used for accessing the [link boost_asio.reference.execution__outstanding_work_t__tracked_t `execution::outstanding_work_t::tracked_t`] property. 


  static constexpr tracked_t tracked;



[endsect]



[section:untracked execution::outstanding_work_t::untracked]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t.untracked..untracked..execution::outstanding_work_t] 
A special value used for accessing the [link boost_asio.reference.execution__outstanding_work_t__untracked_t `execution::outstanding_work_t::untracked_t`] property. 


  static constexpr untracked_t untracked;



[endsect]



[endsect]

[section:execution__outstanding_work_t__tracked_t execution::outstanding_work_t::tracked_t]

[indexterm1 boost_asio.indexterm.execution__outstanding_work_t__tracked_t..execution::outstanding_work_t::tracked_t]


A sub-property that indicates that the executor represents likely future submission of a function object. 


  struct tracked_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__outstanding_work_t__tracked_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__outstanding_work_t__tracked_t.tracked_t [*tracked_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__outstanding_work_t__tracked_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__outstanding_work_t__tracked_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The outstanding_work_t::untracked_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__outstanding_work_t__tracked_t.is_preferable [*is_preferable]] [static]]
    [The outstanding_work_t::tracked_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__outstanding_work_t__tracked_t.is_requirable [*is_requirable]] [static]]
    [The outstanding_work_t::tracked_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/outstanding_work.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::outstanding_work_t::tracked_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t__tracked_t.is_applicable_property_v..is_applicable_property_v..execution::outstanding_work_t::tracked_t] 
The [link boost_asio.reference.execution__outstanding_work_t__untracked_t `execution::outstanding_work_t::untracked_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::outstanding_work_t::tracked_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t__tracked_t.is_preferable..is_preferable..execution::outstanding_work_t::tracked_t] 
The [link boost_asio.reference.execution__outstanding_work_t__tracked_t `execution::outstanding_work_t::tracked_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::outstanding_work_t::tracked_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t__tracked_t.is_requirable..is_requirable..execution::outstanding_work_t::tracked_t] 
The [link boost_asio.reference.execution__outstanding_work_t__tracked_t `execution::outstanding_work_t::tracked_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:polymorphic_query_result_type execution::outstanding_work_t::tracked_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t__tracked_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::outstanding_work_t::tracked_t] 
The type returned by queries against an `any_executor`. 


  typedef outstanding_work_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/outstanding_work.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:tracked_t execution::outstanding_work_t::tracked_t::tracked_t]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t__tracked_t.tracked_t..tracked_t..execution::outstanding_work_t::tracked_t] 
Default constructor. 


  constexpr tracked_t();



[endsect]



[section:value execution::outstanding_work_t::tracked_t::value]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t__tracked_t.value..value..execution::outstanding_work_t::tracked_t] 
Get the value associated with a property object. 


  static constexpr outstanding_work_t value();



[heading Return Value]
      
`tracked_t()`; 




[endsect]



[endsect]

[section:execution__outstanding_work_t__untracked_t execution::outstanding_work_t::untracked_t]

[indexterm1 boost_asio.indexterm.execution__outstanding_work_t__untracked_t..execution::outstanding_work_t::untracked_t]


A sub-property that indicates that the executor does not represent likely future submission of a function object. 


  struct untracked_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__outstanding_work_t__untracked_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__outstanding_work_t__untracked_t.untracked_t [*untracked_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__outstanding_work_t__untracked_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__outstanding_work_t__untracked_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The outstanding_work_t::untracked_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__outstanding_work_t__untracked_t.is_preferable [*is_preferable]] [static]]
    [The outstanding_work_t::untracked_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__outstanding_work_t__untracked_t.is_requirable [*is_requirable]] [static]]
    [The outstanding_work_t::untracked_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/outstanding_work.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::outstanding_work_t::untracked_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t__untracked_t.is_applicable_property_v..is_applicable_property_v..execution::outstanding_work_t::untracked_t] 
The [link boost_asio.reference.execution__outstanding_work_t__untracked_t `execution::outstanding_work_t::untracked_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::outstanding_work_t::untracked_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t__untracked_t.is_preferable..is_preferable..execution::outstanding_work_t::untracked_t] 
The [link boost_asio.reference.execution__outstanding_work_t__untracked_t `execution::outstanding_work_t::untracked_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::outstanding_work_t::untracked_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t__untracked_t.is_requirable..is_requirable..execution::outstanding_work_t::untracked_t] 
The [link boost_asio.reference.execution__outstanding_work_t__untracked_t `execution::outstanding_work_t::untracked_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:polymorphic_query_result_type execution::outstanding_work_t::untracked_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t__untracked_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::outstanding_work_t::untracked_t] 
The type returned by queries against an `any_executor`. 


  typedef outstanding_work_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/outstanding_work.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:untracked_t execution::outstanding_work_t::untracked_t::untracked_t]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t__untracked_t.untracked_t..untracked_t..execution::outstanding_work_t::untracked_t] 
Default constructor. 


  constexpr untracked_t();



[endsect]



[section:value execution::outstanding_work_t::untracked_t::value]

[indexterm2 boost_asio.indexterm.execution__outstanding_work_t__untracked_t.value..value..execution::outstanding_work_t::untracked_t] 
Get the value associated with a property object. 


  static constexpr outstanding_work_t value();



[heading Return Value]
      
`untracked_t()`; 




[endsect]



[endsect]

[section:execution__prefer_only execution::prefer_only]

[indexterm1 boost_asio.indexterm.execution__prefer_only..execution::prefer_only]


A property adapter that is used with the polymorphic executor wrapper to mark properties as preferable, but not requirable. 


  template<
      typename Property>
  struct prefer_only


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__prefer_only.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__prefer_only.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The prefer_only adapter applies to the same types as the nested property. ]
  ]

  [
    [[link boost_asio.reference.execution__prefer_only.is_preferable [*is_preferable]] [static]]
    [The context_t property can be preferred, it the underlying property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__prefer_only.is_requirable [*is_requirable]] [static]]
    [The context_t property cannot be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/prefer_only.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:is_applicable_property_v execution::prefer_only::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__prefer_only.is_applicable_property_v..is_applicable_property_v..execution::prefer_only] 
The [link boost_asio.reference.execution__prefer_only `execution::prefer_only`] adapter applies to the same types as the nested property. 


  template <typename T>
  static constexpr bool is_applicable_property_v =is_applicable_property<T, Property>::value;



[endsect]



[section:is_preferable execution::prefer_only::is_preferable]

[indexterm2 boost_asio.indexterm.execution__prefer_only.is_preferable..is_preferable..execution::prefer_only] 
The [link boost_asio.reference.execution__context_t `execution::context_t`] property can be preferred, it the underlying property can be preferred. 


  static constexpr bool is_preferable = automatically_determined;


`true` if `Property::is_preferable` is `true`, otherwise `false`. 


[endsect]



[section:is_requirable execution::prefer_only::is_requirable]

[indexterm2 boost_asio.indexterm.execution__prefer_only.is_requirable..is_requirable..execution::prefer_only] 
The [link boost_asio.reference.execution__context_t `execution::context_t`] property cannot be required. 


  static constexpr bool is_requirable = false;



[endsect]



[section:polymorphic_query_result_type execution::prefer_only::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__prefer_only.polymorphic_query_result_type..polymorphic_query_result_type..execution::prefer_only] 
The type returned by queries against an `any_executor`. 


  typedef Property::polymorphic_query_result_type polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/prefer_only.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[endsect]

[section:execution__receiver_invocation_error execution::receiver_invocation_error]

[indexterm1 boost_asio.indexterm.execution__receiver_invocation_error..execution::receiver_invocation_error]


Exception reported via `set_error` when an exception escapes from `set_value`. 


  class receiver_invocation_error


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__receiver_invocation_error.receiver_invocation_error [*receiver_invocation_error]] [constructor]]
    [Constructor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution/receiver_invocation_error.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:receiver_invocation_error execution::receiver_invocation_error::receiver_invocation_error]

[indexterm2 boost_asio.indexterm.execution__receiver_invocation_error.receiver_invocation_error..receiver_invocation_error..execution::receiver_invocation_error] 
Constructor. 


  receiver_invocation_error();



[endsect]



[endsect]


[section:execution__relationship execution::relationship]

[indexterm1 boost_asio.indexterm.execution__relationship..execution::relationship] 
A special value used for accessing the [link boost_asio.reference.execution__relationship_t `execution::relationship_t`] property. 


  constexpr relationship_t relationship;


[heading Requirements]

['Header: ][^boost/asio/execution/relationship.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__relationship_t execution::relationship_t]

[indexterm1 boost_asio.indexterm.execution__relationship_t..execution::relationship_t]


A property to describe whether submitted tasks represent continuations of the calling context. 


  struct relationship_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__relationship_t__continuation_t [*continuation_t]]]
    [A sub-property that indicates that the executor represents a continuation of the calling context. ]
  
  ]

  [

    [[link boost_asio.reference.execution__relationship_t__fork_t [*fork_t]]]
    [A sub-property that indicates that the executor does not represent a continuation of the calling context. ]
  
  ]

  [

    [[link boost_asio.reference.execution__relationship_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__relationship_t.relationship_t [*relationship_t]] [constructor]]
    [Default constructor. 
     [hr]
     Construct from a sub-property value. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__relationship_t.continuation [*continuation]] [static]]
    [A special value used for accessing the relationship_t::continuation_t property. ]
  ]

  [
    [[link boost_asio.reference.execution__relationship_t.fork [*fork]] [static]]
    [A special value used for accessing the relationship_t::fork_t property. ]
  ]

  [
    [[link boost_asio.reference.execution__relationship_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The relationship_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__relationship_t.is_preferable [*is_preferable]] [static]]
    [The top-level relationship_t property cannot be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__relationship_t.is_requirable [*is_requirable]] [static]]
    [The top-level relationship_t property cannot be required. ]
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__relationship_t.operator_not__eq_ [*operator!=]]]
    [Compare property values for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.execution__relationship_t.operator_eq__eq_ [*operator==]]]
    [Compare property values for equality. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution/relationship.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:continuation execution::relationship_t::continuation]

[indexterm2 boost_asio.indexterm.execution__relationship_t.continuation..continuation..execution::relationship_t] 
A special value used for accessing the [link boost_asio.reference.execution__relationship_t__continuation_t `execution::relationship_t::continuation_t`] property. 


  static constexpr continuation_t continuation;



[endsect]



[section:fork execution::relationship_t::fork]

[indexterm2 boost_asio.indexterm.execution__relationship_t.fork..fork..execution::relationship_t] 
A special value used for accessing the [link boost_asio.reference.execution__relationship_t__fork_t `execution::relationship_t::fork_t`] property. 


  static constexpr fork_t fork;



[endsect]



[section:is_applicable_property_v execution::relationship_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__relationship_t.is_applicable_property_v..is_applicable_property_v..execution::relationship_t] 
The [link boost_asio.reference.execution__relationship_t `execution::relationship_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
    is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::relationship_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__relationship_t.is_preferable..is_preferable..execution::relationship_t] 
The top-level [link boost_asio.reference.execution__relationship_t `execution::relationship_t`] property cannot be preferred. 


  static constexpr bool is_preferable = false;



[endsect]



[section:is_requirable execution::relationship_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__relationship_t.is_requirable..is_requirable..execution::relationship_t] 
The top-level [link boost_asio.reference.execution__relationship_t `execution::relationship_t`] property cannot be required. 


  static constexpr bool is_requirable = false;



[endsect]



[section:operator_not__eq_ execution::relationship_t::operator!=]

[indexterm2 boost_asio.indexterm.execution__relationship_t.operator_not__eq_..operator!=..execution::relationship_t] 
Compare property values for inequality. 


  friend constexpr bool operator!=(
      const relationship_t & a,
      const relationship_t & b);


[heading Requirements]

['Header: ][^boost/asio/execution/relationship.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:operator_eq__eq_ execution::relationship_t::operator==]

[indexterm2 boost_asio.indexterm.execution__relationship_t.operator_eq__eq_..operator==..execution::relationship_t] 
Compare property values for equality. 


  friend constexpr bool operator==(
      const relationship_t & a,
      const relationship_t & b);


[heading Requirements]

['Header: ][^boost/asio/execution/relationship.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:polymorphic_query_result_type execution::relationship_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__relationship_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::relationship_t] 
The type returned by queries against an `any_executor`. 


  typedef relationship_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/relationship.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:relationship_t execution::relationship_t::relationship_t]

[indexterm2 boost_asio.indexterm.execution__relationship_t.relationship_t..relationship_t..execution::relationship_t] 
Default constructor. 


  constexpr ``[link boost_asio.reference.execution__relationship_t.relationship_t.overload1 relationship_t]``();
  ``  [''''&raquo;''' [link boost_asio.reference.execution__relationship_t.relationship_t.overload1 more...]]``


Construct from a sub-property value. 


  constexpr ``[link boost_asio.reference.execution__relationship_t.relationship_t.overload2 relationship_t]``(
      fork_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__relationship_t.relationship_t.overload2 more...]]``

  constexpr ``[link boost_asio.reference.execution__relationship_t.relationship_t.overload3 relationship_t]``(
      continuation_t );
  ``  [''''&raquo;''' [link boost_asio.reference.execution__relationship_t.relationship_t.overload3 more...]]``


[section:overload1 execution::relationship_t::relationship_t (1 of 3 overloads)]


Default constructor. 


  constexpr relationship_t();



[endsect]



[section:overload2 execution::relationship_t::relationship_t (2 of 3 overloads)]


Construct from a sub-property value. 


  constexpr relationship_t(
      fork_t );



[endsect]



[section:overload3 execution::relationship_t::relationship_t (3 of 3 overloads)]


Construct from a sub-property value. 


  constexpr relationship_t(
      continuation_t );



[endsect]


[endsect]


[endsect]

[section:execution__relationship_t__continuation_t execution::relationship_t::continuation_t]

[indexterm1 boost_asio.indexterm.execution__relationship_t__continuation_t..execution::relationship_t::continuation_t]


A sub-property that indicates that the executor represents a continuation of the calling context. 


  struct continuation_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__relationship_t__continuation_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__relationship_t__continuation_t.continuation_t [*continuation_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__relationship_t__continuation_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__relationship_t__continuation_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The relationship_t::continuation_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__relationship_t__continuation_t.is_preferable [*is_preferable]] [static]]
    [The relationship_t::continuation_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__relationship_t__continuation_t.is_requirable [*is_requirable]] [static]]
    [The relationship_t::continuation_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/relationship.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:continuation_t execution::relationship_t::continuation_t::continuation_t]

[indexterm2 boost_asio.indexterm.execution__relationship_t__continuation_t.continuation_t..continuation_t..execution::relationship_t::continuation_t] 
Default constructor. 


  constexpr continuation_t();



[endsect]



[section:is_applicable_property_v execution::relationship_t::continuation_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__relationship_t__continuation_t.is_applicable_property_v..is_applicable_property_v..execution::relationship_t::continuation_t] 
The [link boost_asio.reference.execution__relationship_t__continuation_t `execution::relationship_t::continuation_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::relationship_t::continuation_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__relationship_t__continuation_t.is_preferable..is_preferable..execution::relationship_t::continuation_t] 
The [link boost_asio.reference.execution__relationship_t__continuation_t `execution::relationship_t::continuation_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::relationship_t::continuation_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__relationship_t__continuation_t.is_requirable..is_requirable..execution::relationship_t::continuation_t] 
The [link boost_asio.reference.execution__relationship_t__continuation_t `execution::relationship_t::continuation_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:polymorphic_query_result_type execution::relationship_t::continuation_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__relationship_t__continuation_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::relationship_t::continuation_t] 
The type returned by queries against an `any_executor`. 


  typedef relationship_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/relationship.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:value execution::relationship_t::continuation_t::value]

[indexterm2 boost_asio.indexterm.execution__relationship_t__continuation_t.value..value..execution::relationship_t::continuation_t] 
Get the value associated with a property object. 


  static constexpr relationship_t value();



[heading Return Value]
      
`continuation_t()`; 




[endsect]



[endsect]

[section:execution__relationship_t__fork_t execution::relationship_t::fork_t]

[indexterm1 boost_asio.indexterm.execution__relationship_t__fork_t..execution::relationship_t::fork_t]


A sub-property that indicates that the executor does not represent a continuation of the calling context. 


  struct fork_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution__relationship_t__fork_t.polymorphic_query_result_type [*polymorphic_query_result_type]]]
    [The type returned by queries against an any_executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__relationship_t__fork_t.fork_t [*fork_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution__relationship_t__fork_t.value [*value]] [static]]
    [Get the value associated with a property object. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution__relationship_t__fork_t.is_applicable_property_v [*is_applicable_property_v]] [static]]
    [The relationship_t::fork_t property applies to executors, senders, and schedulers. ]
  ]

  [
    [[link boost_asio.reference.execution__relationship_t__fork_t.is_preferable [*is_preferable]] [static]]
    [The relationship_t::fork_t property can be preferred. ]
  ]

  [
    [[link boost_asio.reference.execution__relationship_t__fork_t.is_requirable [*is_requirable]] [static]]
    [The relationship_t::fork_t property can be required. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/execution/relationship.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:fork_t execution::relationship_t::fork_t::fork_t]

[indexterm2 boost_asio.indexterm.execution__relationship_t__fork_t.fork_t..fork_t..execution::relationship_t::fork_t] 
Default constructor. 


  constexpr fork_t();



[endsect]



[section:is_applicable_property_v execution::relationship_t::fork_t::is_applicable_property_v]

[indexterm2 boost_asio.indexterm.execution__relationship_t__fork_t.is_applicable_property_v..is_applicable_property_v..execution::relationship_t::fork_t] 
The [link boost_asio.reference.execution__relationship_t__fork_t `execution::relationship_t::fork_t`] property applies to executors, senders, and schedulers. 


  template <typename T>
  static constexpr bool is_applicable_property_v =
      is_executor_v<T> || is_sender_v<T> || is_scheduler_v<T>;



[endsect]



[section:is_preferable execution::relationship_t::fork_t::is_preferable]

[indexterm2 boost_asio.indexterm.execution__relationship_t__fork_t.is_preferable..is_preferable..execution::relationship_t::fork_t] 
The [link boost_asio.reference.execution__relationship_t__fork_t `execution::relationship_t::fork_t`] property can be preferred. 


  static constexpr bool is_preferable = true;



[endsect]



[section:is_requirable execution::relationship_t::fork_t::is_requirable]

[indexterm2 boost_asio.indexterm.execution__relationship_t__fork_t.is_requirable..is_requirable..execution::relationship_t::fork_t] 
The [link boost_asio.reference.execution__relationship_t__fork_t `execution::relationship_t::fork_t`] property can be required. 


  static constexpr bool is_requirable = true;



[endsect]



[section:polymorphic_query_result_type execution::relationship_t::fork_t::polymorphic_query_result_type]

[indexterm2 boost_asio.indexterm.execution__relationship_t__fork_t.polymorphic_query_result_type..polymorphic_query_result_type..execution::relationship_t::fork_t] 
The type returned by queries against an `any_executor`. 


  typedef relationship_t polymorphic_query_result_type;



[heading Requirements]

['Header: ][^boost/asio/execution/relationship.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:value execution::relationship_t::fork_t::value]

[indexterm2 boost_asio.indexterm.execution__relationship_t__fork_t.value..value..execution::relationship_t::fork_t] 
Get the value associated with a property object. 


  static constexpr relationship_t value();



[heading Return Value]
      
`fork_t()`; 




[endsect]



[endsect]


[section:execution__schedule execution::schedule]

[indexterm1 boost_asio.indexterm.execution__schedule..execution::schedule] 
A customisation point that is used to obtain a sender from a scheduler. 


  constexpr unspecified schedule = unspecified;


The name `execution::schedule` denotes a customisation point object. For some subexpression `s`, let `S` be a type such that `decltype((s))` is `S`. The expression `execution::schedule(s)` is expression-equivalent to:


* `s.schedule()`, if that expression is valid and its type models `sender`.


* Otherwise, `schedule(s)`, if that expression is valid and its type models `sender` with overload resolution performed in a context that includes the declaration `void schedule();` and that does not include a declaration of `execution::schedule`.


* Otherwise, `S` if `S` satisfies `executor`.


* Otherwise, `execution::schedule(s)` is ill-formed. 



[heading Requirements]

['Header: ][^boost/asio/execution/schedule.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:execution__sender_base execution::sender_base]

[indexterm1 boost_asio.indexterm.execution__sender_base..execution::sender_base] 
Base class used for tagging senders. 


  typedef unspecified sender_base;



[heading Requirements]

['Header: ][^boost/asio/execution/sender.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__sender_traits execution::sender_traits]

[indexterm1 boost_asio.indexterm.execution__sender_traits..execution::sender_traits]


Traits for senders. 


  template<
      typename S>
  struct sender_traits


[heading Requirements]

['Header: ][^boost/asio/execution/sender.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution__set_done execution::set_done]

[indexterm1 boost_asio.indexterm.execution__set_done..execution::set_done] 
A customisation point that delivers a done notification to a receiver. 


  constexpr unspecified set_done = unspecified;


The name `execution::set_done` denotes a customisation point object. The expression `execution::set_done(R)` for some subexpression `R` is expression-equivalent to:


* `R.set_done()`, if that expression is valid. If the function selected does not signal the receiver `R`'s done channel, the program is ill-formed with no diagnostic required.


* Otherwise, `set_done(R)`, if that expression is valid, with overload resolution performed in a context that includes the declaration `void set_done();` and that does not include a declaration of `execution::set_done`. If the function selected by overload resolution does not signal the receiver `R`'s done channel, the program is ill-formed with no diagnostic required.


* Otherwise, `execution::set_done(R)` is ill-formed. 



[heading Requirements]

['Header: ][^boost/asio/execution/set_done.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:execution__set_error execution::set_error]

[indexterm1 boost_asio.indexterm.execution__set_error..execution::set_error] 
A customisation point that delivers an error notification to a receiver. 


  constexpr unspecified set_error = unspecified;


The name `execution::set_error` denotes a customisation point object. The expression `execution::set_error(R, E)` for some subexpressions `R` and `E` are expression-equivalent to:


* `R.set_error(E)`, if that expression is valid. If the function selected does not send the error `E` to the receiver `R`'s error channel, the program is ill-formed with no diagnostic required.


* Otherwise, `set_error(R, E)`, if that expression is valid, with overload resolution performed in a context that includes the declaration `void set_error();` and that does not include a declaration of `execution::set_error`. If the function selected by overload resolution does not send the error `E` to the receiver `R`'s error channel, the program is ill-formed with no diagnostic required.


* Otherwise, `execution::set_error(R, E)` is ill-formed. 



[heading Requirements]

['Header: ][^boost/asio/execution/set_error.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:execution__set_value execution::set_value]

[indexterm1 boost_asio.indexterm.execution__set_value..execution::set_value] 
A customisation point that delivers a value to a receiver. 


  constexpr unspecified set_value = unspecified;


The name `execution::set_value` denotes a customisation point object. The expression `execution::set_value(R, Vs...)` for some subexpressions `R` and `Vs...` is expression-equivalent to:


* `R.set_value(Vs...)`, if that expression is valid. If the function selected does not send the value(s) `Vs...` to the receiver `R`'s value channel, the program is ill-formed with no diagnostic required.


* Otherwise, `set_value(R, Vs...)`, if that expression is valid, with overload resolution performed in a context that includes the declaration `void set_value();` and that does not include a declaration of `execution::set_value`. If the function selected by overload resolution does not send the value(s) `Vs...` to the receiver `R`'s value channel, the program is ill-formed with no diagnostic required.


* Otherwise, `execution::set_value(R, Vs...)` is ill-formed. 



[heading Requirements]

['Header: ][^boost/asio/execution/set_value.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:execution__start execution::start]

[indexterm1 boost_asio.indexterm.execution__start..execution::start] 
A customisation point that notifies an operation state object to start its associated operation. 


  constexpr unspecified start = unspecified;


The name `execution::start` denotes a customisation point object. The expression `execution::start(R)` for some subexpression `R` is expression-equivalent to:


* `R.start()`, if that expression is valid.


* Otherwise, `start(R)`, if that expression is valid, with overload resolution performed in a context that includes the declaration `void start();` and that does not include a declaration of `execution::start`.


* Otherwise, `execution::start(R)` is ill-formed. 



[heading Requirements]

['Header: ][^boost/asio/execution/start.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:execution__submit execution::submit]

[indexterm1 boost_asio.indexterm.execution__submit..execution::submit] 
A customisation point that submits a sender to a receiver. 


  constexpr unspecified submit = unspecified;


The name `execution::submit` denotes a customisation point object. For some subexpressions `s` and `r`, let `S` be a type such that `decltype((s))` is `S` and let `R` be a type such that `decltype((r))` is `R`. The expression `execution::submit(s, r)` is ill-formed if `sender_to<S, R>` is not `true`. Otherwise, it is expression-equivalent to:


* `s.submit(r)`, if that expression is valid and `S` models `sender`. If the function selected does not submit the receiver object `r` via the sender `s`, the program is ill-formed with no diagnostic required.


* Otherwise, `submit(s, r)`, if that expression is valid and `S` models `sender`, with overload resolution performed in a context that includes the declaration `void submit();` and that does not include a declaration of `execution::submit`. If the function selected by overload resolution does not submit the receiver object `r` via the sender `s`, the program is ill-formed with no diagnostic required.


* Otherwise, `execution::start((new submit_receiver<S, R>{s,r})->state_)`, where `submit_receiver` is an implementation-defined class template equivalent to: 

   template<class S, class R>
     struct submit_receiver {
       struct wrap {
         submit_receiver * p_;
         template<class...As>
           requires receiver_of<R, As...>
         void set_value(As&&... as) &&
           noexcept(is_nothrow_receiver_of_v<R, As...>) {
           execution::set_value(std::move(p_->r_), (As&&) as...);
           delete p_;
         }
         template<class E>
           requires receiver<R, E>
         void set_error(E&& e) && noexcept {
           execution::set_error(std::move(p_->r_), (E&&) e);
           delete p_;
         }
         void set_done() && noexcept {
           execution::set_done(std::move(p_->r_));
           delete p_;
         }
       };
       remove_cvref_t<R> r_;
       connect_result_t<S, wrap> state_;
       submit_receiver(S&& s, R&& r)
         : r_((R&&) r)
         , state_(execution::connect((S&&) s, wrap{this})) {}
     };






[heading Requirements]

['Header: ][^boost/asio/execution/submit.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[section:execution_context execution_context]

[indexterm1 boost_asio.indexterm.execution_context..execution_context]


A context for function object execution. 


  class execution_context :
    noncopyable


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.execution_context__id [*id]]]
    [Class used to uniquely identify a service. ]
  
  ]

  [

    [[link boost_asio.reference.execution_context__service [*service]]]
    [Base class for all io_context services. ]
  
  ]

  [

    [[link boost_asio.reference.execution_context.fork_event [*fork_event]]]
    [Fork-related event notifications. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution_context.execution_context [*execution_context]] [constructor]]
    [Constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution_context.notify_fork [*notify_fork]]]
    [Notify the execution_context of a fork-related event. ]
  ]
  
  [
    [[link boost_asio.reference.execution_context._execution_context [*~execution_context]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution_context.destroy [*destroy]]]
    [Destroys all services in the context. ]
  ]
  
  [
    [[link boost_asio.reference.execution_context.shutdown [*shutdown]]]
    [Shuts down all services in the context. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution_context.add_service [*add_service]]]
    [(Deprecated: Use make_service().) Add a service object to the execution_context. ]
  ]
  
  [
    [[link boost_asio.reference.execution_context.has_service [*has_service]]]
    [Determine if an execution_context contains a specified service type. ]
  ]
  
  [
    [[link boost_asio.reference.execution_context.make_service [*make_service]]]
    [Creates a service object and adds it to the execution_context. ]
  ]
  
  [
    [[link boost_asio.reference.execution_context.use_service [*use_service]]]
    [Obtain the service object corresponding to the given type. ]
  ]
  
]

An execution context represents a place where function objects will be executed. An `io_context` is an example of an execution context.


[heading The execution_context class and services]
  


Class [link boost_asio.reference.execution_context `execution_context`] implements an extensible, type-safe, polymorphic set of services, indexed by service type.

Services exist to manage the resources that are shared across an execution context. For example, timers may be implemented in terms of a single timer queue, and this queue would be stored in a service.

Access to the services of an [link boost_asio.reference.execution_context `execution_context`] is via three function templates, `use_service()`, `add_service()` and `has_service()`.

In a call to `use_service<Service>()`, the type argument chooses a service, making available all members of the named type. If `Service` is not present in an [link boost_asio.reference.execution_context `execution_context`], an object of type `Service` is created and added to the [link boost_asio.reference.execution_context `execution_context`]. A C++ program can check if an [link boost_asio.reference.execution_context `execution_context`] implements a particular service with the function template `has_service<Service>()`.

Service objects may be explicitly added to an [link boost_asio.reference.execution_context `execution_context`] using the function template `add_service<Service>()`. If the `Service` is already present, the [link boost_asio.reference.service_already_exists `service_already_exists`] exception is thrown. If the owner of the service is not the same object as the [link boost_asio.reference.execution_context `execution_context`] parameter, the [link boost_asio.reference.invalid_service_owner `invalid_service_owner`] exception is thrown.

Once a service reference is obtained from an [link boost_asio.reference.execution_context `execution_context`] object by calling `use_service()`, that reference remains usable as long as the owning [link boost_asio.reference.execution_context `execution_context`] object exists.

All service implementations have [link boost_asio.reference.execution_context__service `execution_context::service`] as a public base class. Custom services may be implemented by deriving from this class and then added to an [link boost_asio.reference.execution_context `execution_context`] using the facilities described above.


[heading The execution_context as a base class]
  


Class [link boost_asio.reference.execution_context `execution_context`] may be used only as a base class for concrete execution context types. The `io_context` is an example of such a derived type.

On destruction, a class that is derived from [link boost_asio.reference.execution_context `execution_context`] must perform `execution_context::shutdown()` followed by `execution_context::destroy()`.

This destruction sequence permits programs to simplify their resource management by using `shared_ptr<>`. Where an object's lifetime is tied to the lifetime of a connection (or some other sequence of asynchronous operations), a `shared_ptr` to the object would be bound into the handlers for all asynchronous operations associated with it. This works as follows:


* When a single connection ends, all associated asynchronous operations complete. The corresponding handler objects are destroyed, and all `shared_ptr` references to the objects are destroyed.


* To shut down the whole program, the [link boost_asio.reference.io_context `io_context`] function stop() is called to terminate any run() calls as soon as possible. The [link boost_asio.reference.io_context `io_context`] destructor calls `shutdown()` and `destroy()` to destroy all pending handlers, causing all `shared_ptr` references to all connection objects to be destroyed. 



[heading Requirements]

['Header: ][^boost/asio/execution_context.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:add_service execution_context::add_service]

[indexterm2 boost_asio.indexterm.execution_context.add_service..add_service..execution_context] 
(Deprecated: Use `make_service()`.) Add a service object to the [link boost_asio.reference.execution_context `execution_context`]. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend void add_service(
      execution_context & e,
      Service * svc);


This function is used to add a service to the [link boost_asio.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

[[svc][The service object. On success, ownership of the service object is transferred to the [link boost_asio.reference.execution_context `execution_context`]. When the [link boost_asio.reference.execution_context `execution_context`] object is destroyed, it will destroy the service object by performing:
``
   delete static_cast<execution_context::service*>(svc) 
``
]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`].]]

[[boost::asio::invalid_service_owner][Thrown if the service's owning [link boost_asio.reference.execution_context `execution_context`] is not the [link boost_asio.reference.execution_context `execution_context`] object specified by the `e` parameter. ]]

]



[heading Requirements]

['Header: ][^boost/asio/execution_context.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:destroy execution_context::destroy]

[indexterm2 boost_asio.indexterm.execution_context.destroy..destroy..execution_context] 
Destroys all services in the context. 


  void destroy();


This function is implemented as follows:


* For each service object `svc` in the [link boost_asio.reference.execution_context `execution_context`] set, in reverse order * of the beginning of service object lifetime, performs `delete static_cast<execution_context::service*>(svc)`. 




[endsect]



[section:execution_context execution_context::execution_context]

[indexterm2 boost_asio.indexterm.execution_context.execution_context..execution_context..execution_context] 
Constructor. 


  execution_context();



[endsect]



[section:fork_event execution_context::fork_event]

[indexterm2 boost_asio.indexterm.execution_context.fork_event..fork_event..execution_context] 
Fork-related event notifications. 

  enum fork_event

[indexterm2 boost_asio.indexterm.execution_context.fork_event.fork_prepare..fork_prepare..execution_context]
[indexterm2 boost_asio.indexterm.execution_context.fork_event.fork_parent..fork_parent..execution_context]
[indexterm2 boost_asio.indexterm.execution_context.fork_event.fork_child..fork_child..execution_context]

[heading Values]
[variablelist

  [
    [fork_prepare]
    [Notify the context that the process is about to fork. ]
  ]

  [
    [fork_parent]
    [Notify the context that the process has forked and is the parent. ]
  ]

  [
    [fork_child]
    [Notify the context that the process has forked and is the child. ]
  ]

]



[endsect]



[section:has_service execution_context::has_service]

[indexterm2 boost_asio.indexterm.execution_context.has_service..has_service..execution_context] 
Determine if an [link boost_asio.reference.execution_context `execution_context`] contains a specified service type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend bool has_service(
      execution_context & e);


This function is used to determine whether the [link boost_asio.reference.execution_context `execution_context`] contains a service object corresponding to the given service type.


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
A boolean indicating whether the [link boost_asio.reference.execution_context `execution_context`] contains the service. 



[heading Requirements]

['Header: ][^boost/asio/execution_context.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:make_service execution_context::make_service]

[indexterm2 boost_asio.indexterm.execution_context.make_service..make_service..execution_context] 
Creates a service object and adds it to the [link boost_asio.reference.execution_context `execution_context`]. 


  template<
      typename ``[link boost_asio.reference.Service Service]``,
      typename... Args>
  friend Service & make_service(
      execution_context & e,
      Args &&... args);


This function is used to add a service to the [link boost_asio.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

[[args][Zero or more arguments to be passed to the service constructor.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`]. ]]

]



[heading Requirements]

['Header: ][^boost/asio/execution_context.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:notify_fork execution_context::notify_fork]

[indexterm2 boost_asio.indexterm.execution_context.notify_fork..notify_fork..execution_context] 
Notify the [link boost_asio.reference.execution_context `execution_context`] of a fork-related event. 


  void notify_fork(
      fork_event event);


This function is used to inform the [link boost_asio.reference.execution_context `execution_context`] that the process is about to fork, or has just forked. This allows the [link boost_asio.reference.execution_context `execution_context`], and the services it contains, to perform any necessary housekeeping to ensure correct operation following a fork.

This function must not be called while any other [link boost_asio.reference.execution_context `execution_context`] function, or any function associated with the execution\_context's derived class, is being called in another thread. It is, however, safe to call this function from within a completion handler, provided no other thread is accessing the [link boost_asio.reference.execution_context `execution_context`] or its derived class.


[heading Parameters]
    

[variablelist
  
[[event][A fork-related event.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the notification fails the [link boost_asio.reference.execution_context `execution_context`] object should no longer be used and should be destroyed.]]

]


[heading Example]
  
The following code illustrates how to incorporate the `notify_fork()` function: 

   my_execution_context.notify_fork(execution_context::fork_prepare);
   if (fork() == 0)
   {
     // This is the child process.
     my_execution_context.notify_fork(execution_context::fork_child);
   }
   else
   {
     // This is the parent process.
     my_execution_context.notify_fork(execution_context::fork_parent);
   } 





[heading Remarks]
      
For each service object `svc` in the [link boost_asio.reference.execution_context `execution_context`] set, performs `svc->notify_fork();`. When processing the fork\_prepare event, services are visited in reverse order of the beginning of service object lifetime. Otherwise, services are visited in order of the beginning of service object lifetime. 




[endsect]



[section:shutdown execution_context::shutdown]

[indexterm2 boost_asio.indexterm.execution_context.shutdown..shutdown..execution_context] 
Shuts down all services in the context. 


  void shutdown();


This function is implemented as follows:


* For each service object `svc` in the [link boost_asio.reference.execution_context `execution_context`] set, in reverse order of the beginning of service object lifetime, performs `svc->shutdown()`. 




[endsect]


[section:use_service execution_context::use_service]

[indexterm2 boost_asio.indexterm.execution_context.use_service..use_service..execution_context] 
Obtain the service object corresponding to the given type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & ``[link boost_asio.reference.execution_context.use_service.overload1 use_service]``(
      execution_context & e);
  ``  [''''&raquo;''' [link boost_asio.reference.execution_context.use_service.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & ``[link boost_asio.reference.execution_context.use_service.overload2 use_service]``(
      io_context & ioc);
  ``  [''''&raquo;''' [link boost_asio.reference.execution_context.use_service.overload2 more...]]``


[section:overload1 execution_context::use_service (1 of 2 overloads)]


Obtain the service object corresponding to the given type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & use_service(
      execution_context & e);


This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the [link boost_asio.reference.execution_context `execution_context`] will create a new instance of the service.


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller. 



[heading Requirements]

['Header: ][^boost/asio/execution_context.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]



[section:overload2 execution_context::use_service (2 of 2 overloads)]


Obtain the service object corresponding to the given type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & use_service(
      io_context & ioc);


This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the [link boost_asio.reference.io_context `io_context`] will create a new instance of the service.


[heading Parameters]
    

[variablelist
  
[[ioc][The [link boost_asio.reference.io_context `io_context`] object that owns the service.]]

]


[heading Return Value]
      
The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller.


[heading Remarks]
      
This overload is preserved for backwards compatibility with services that inherit from [link boost_asio.reference.io_context__service `io_context::service`]. 



[heading Requirements]

['Header: ][^boost/asio/execution_context.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[endsect]


[endsect]


[section:_execution_context execution_context::~execution_context]

[indexterm2 boost_asio.indexterm.execution_context._execution_context..~execution_context..execution_context] 
Destructor. 


  ~execution_context();



[endsect]



[endsect]

[section:execution_context__id execution_context::id]

[indexterm1 boost_asio.indexterm.execution_context__id..execution_context::id]


Class used to uniquely identify a service. 


  class id :
    noncopyable


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution_context__id.id [*id]] [constructor]]
    [Constructor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution_context.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:id execution_context::id::id]

[indexterm2 boost_asio.indexterm.execution_context__id.id..id..execution_context::id] 
Constructor. 


  id();



[endsect]



[endsect]

[section:execution_context__service execution_context::service]

[indexterm1 boost_asio.indexterm.execution_context__service..execution_context::service]


Base class for all [link boost_asio.reference.io_context `io_context`] services. 


  class service :
    noncopyable


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution_context__service.context [*context]]]
    [Get the context object that owns the service. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution_context__service.service [*service]] [constructor]]
    [Constructor. ]
  ]
  
  [
    [[link boost_asio.reference.execution_context__service._service [*~service]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Private Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.execution_context__service.notify_fork [*notify_fork]]]
    [Handle notification of a fork-related event to perform any necessary housekeeping. ]
  ]
  
  [
    [[link boost_asio.reference.execution_context__service.shutdown [*shutdown]]]
    [Destroy all user-defined handler objects owned by the service. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution_context.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:context execution_context::service::context]

[indexterm2 boost_asio.indexterm.execution_context__service.context..context..execution_context::service] 
Get the context object that owns the service. 


  execution_context & context();



[endsect]



[section:service execution_context::service::service]

[indexterm2 boost_asio.indexterm.execution_context__service.service..service..execution_context::service] 
Constructor. 


  service(
      execution_context & owner);



[heading Parameters]
    

[variablelist
  
[[owner][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service. ]]

]




[endsect]



[section:_service execution_context::service::~service]

[indexterm2 boost_asio.indexterm.execution_context__service._service..~service..execution_context::service] 
Destructor. 


  virtual ~service();



[endsect]



[section:notify_fork execution_context::service::notify_fork]

[indexterm2 boost_asio.indexterm.execution_context__service.notify_fork..notify_fork..execution_context::service] 
Handle notification of a fork-related event to perform any necessary housekeeping. 


  virtual void notify_fork(
      execution_context::fork_event event);


This function is not a pure virtual so that services only have to implement it if necessary. The default implementation does nothing. 


[endsect]



[section:shutdown execution_context::service::shutdown]

[indexterm2 boost_asio.indexterm.execution_context__service.shutdown..shutdown..execution_context::service] 
Destroy all user-defined handler objects owned by the service. 


  void shutdown();



[endsect]



[endsect]

[section:executor executor]

[indexterm1 boost_asio.indexterm.executor..executor]


Polymorphic wrapper for executors. 


  class executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.executor__unspecified_bool_type_t [*unspecified_bool_type_t]]]
    []
  
  ]

  [

    [[link boost_asio.reference.executor.unspecified_bool_type [*unspecified_bool_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.executor.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.executor.defer [*defer]]]
    [Request the executor to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.executor.dispatch [*dispatch]]]
    [Request the executor to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.executor.executor [*executor]] [constructor]]
    [Default constructor. 
     [hr]
     Construct from nullptr. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. 
     [hr]
     Construct a polymorphic wrapper for the specified executor. 
     [hr]
     Allocator-aware constructor to create a polymorphic wrapper for the specified executor. ]
  ]
  
  [
    [[link boost_asio.reference.executor.on_work_finished [*on_work_finished]]]
    [Inform the executor that some work is no longer outstanding. ]
  ]
  
  [
    [[link boost_asio.reference.executor.on_work_started [*on_work_started]]]
    [Inform the executor that it has some outstanding work to do. ]
  ]
  
  [
    [[link boost_asio.reference.executor.operator_unspecified_bool_type [*operator unspecified_bool_type]]]
    [Operator to test if the executor contains a valid target. ]
  ]
  
  [
    [[link boost_asio.reference.executor.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     
     [hr]
     Assignment operator for nullptr_t. 
     [hr]
     Assignment operator to create a polymorphic wrapper for the specified executor. ]
  ]
  
  [
    [[link boost_asio.reference.executor.post [*post]]]
    [Request the executor to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.executor.target [*target]]]
    [Obtain a pointer to the target executor object. ]
  ]
  
  [
    [[link boost_asio.reference.executor.target_type [*target_type]]]
    [Obtain type information for the target executor object. ]
  ]
  
  [
    [[link boost_asio.reference.executor.unspecified_bool_true [*unspecified_bool_true]] [static]]
    []
  ]
  
  [
    [[link boost_asio.reference.executor._executor [*~executor]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.executor.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.executor.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:context executor::context]

[indexterm2 boost_asio.indexterm.executor.context..context..executor] 
Obtain the underlying execution context. 


  execution_context & context() const;



[endsect]



[section:defer executor::defer]

[indexterm2 boost_asio.indexterm.executor.defer..defer..executor] 
Request the executor to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void defer(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object is executed according to the rules of the target executor object.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:dispatch executor::dispatch]

[indexterm2 boost_asio.indexterm.executor.dispatch..dispatch..executor] 
Request the executor to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void dispatch(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object is executed according to the rules of the target executor object.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]


[section:executor executor::executor]

[indexterm2 boost_asio.indexterm.executor.executor..executor..executor] 
Default constructor. 


  ``[link boost_asio.reference.executor.executor.overload1 executor]``();
  ``  [''''&raquo;''' [link boost_asio.reference.executor.executor.overload1 more...]]``


Construct from nullptr. 


  ``[link boost_asio.reference.executor.executor.overload2 executor]``(
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.executor.executor.overload2 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.executor.executor.overload3 executor]``(
      const executor & other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor.executor.overload3 more...]]``


Move constructor. 


  ``[link boost_asio.reference.executor.executor.overload4 executor]``(
      executor && other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor.executor.overload4 more...]]``


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  ``[link boost_asio.reference.executor.executor.overload5 executor]``(
      Executor e);
  ``  [''''&raquo;''' [link boost_asio.reference.executor.executor.overload5 more...]]``


Allocator-aware constructor to create a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Allocator>
  ``[link boost_asio.reference.executor.executor.overload6 executor]``(
      allocator_arg_t ,
      const Allocator & a,
      Executor e);
  ``  [''''&raquo;''' [link boost_asio.reference.executor.executor.overload6 more...]]``


[section:overload1 executor::executor (1 of 6 overloads)]


Default constructor. 


  executor();



[endsect]



[section:overload2 executor::executor (2 of 6 overloads)]


Construct from nullptr. 


  executor(
      nullptr_t );



[endsect]



[section:overload3 executor::executor (3 of 6 overloads)]


Copy constructor. 


  executor(
      const executor & other);



[endsect]



[section:overload4 executor::executor (4 of 6 overloads)]


Move constructor. 


  executor(
      executor && other);



[endsect]



[section:overload5 executor::executor (5 of 6 overloads)]


Construct a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  executor(
      Executor e);



[endsect]



[section:overload6 executor::executor (6 of 6 overloads)]


Allocator-aware constructor to create a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Allocator>
  executor(
      allocator_arg_t ,
      const Allocator & a,
      Executor e);



[endsect]


[endsect]


[section:on_work_finished executor::on_work_finished]

[indexterm2 boost_asio.indexterm.executor.on_work_finished..on_work_finished..executor] 
Inform the executor that some work is no longer outstanding. 


  void on_work_finished() const;



[endsect]



[section:on_work_started executor::on_work_started]

[indexterm2 boost_asio.indexterm.executor.on_work_started..on_work_started..executor] 
Inform the executor that it has some outstanding work to do. 


  void on_work_started() const;



[endsect]



[section:operator_unspecified_bool_type executor::operator unspecified_bool_type]

[indexterm2 boost_asio.indexterm.executor.operator_unspecified_bool_type..operator unspecified_bool_type..executor] 
Operator to test if the executor contains a valid target. 


  operator unspecified_bool_type() const;



[endsect]



[section:operator_not__eq_ executor::operator!=]

[indexterm2 boost_asio.indexterm.executor.operator_not__eq_..operator!=..executor] 
Compare two executors for inequality. 


  friend bool operator!=(
      const executor & a,
      const executor & b);


[heading Requirements]

['Header: ][^boost/asio/executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:operator_eq_ executor::operator=]

[indexterm2 boost_asio.indexterm.executor.operator_eq_..operator=..executor] 
Assignment operator. 


  executor & ``[link boost_asio.reference.executor.operator_eq_.overload1 operator=]``(
      const executor & other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor.operator_eq_.overload1 more...]]``



  executor & ``[link boost_asio.reference.executor.operator_eq_.overload2 operator=]``(
      executor && other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor.operator_eq_.overload2 more...]]``


Assignment operator for nullptr\_t. 


  executor & ``[link boost_asio.reference.executor.operator_eq_.overload3 operator=]``(
      nullptr_t );
  ``  [''''&raquo;''' [link boost_asio.reference.executor.operator_eq_.overload3 more...]]``


Assignment operator to create a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  executor & ``[link boost_asio.reference.executor.operator_eq_.overload4 operator=]``(
      Executor && e);
  ``  [''''&raquo;''' [link boost_asio.reference.executor.operator_eq_.overload4 more...]]``


[section:overload1 executor::operator= (1 of 4 overloads)]


Assignment operator. 


  executor & operator=(
      const executor & other);



[endsect]



[section:overload2 executor::operator= (2 of 4 overloads)]



  executor & operator=(
      executor && other);



[endsect]



[section:overload3 executor::operator= (3 of 4 overloads)]


Assignment operator for nullptr\_t. 


  executor & operator=(
      nullptr_t );



[endsect]



[section:overload4 executor::operator= (4 of 4 overloads)]


Assignment operator to create a polymorphic wrapper for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  executor & operator=(
      Executor && e);



[endsect]


[endsect]


[section:operator_eq__eq_ executor::operator==]

[indexterm2 boost_asio.indexterm.executor.operator_eq__eq_..operator==..executor] 
Compare two executors for equality. 


  friend bool operator==(
      const executor & a,
      const executor & b);


[heading Requirements]

['Header: ][^boost/asio/executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:post executor::post]

[indexterm2 boost_asio.indexterm.executor.post..post..executor] 
Request the executor to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void post(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object is executed according to the rules of the target executor object.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]


[section:target executor::target]

[indexterm2 boost_asio.indexterm.executor.target..target..executor] 
Obtain a pointer to the target executor object. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  Executor * ``[link boost_asio.reference.executor.target.overload1 target]``();
  ``  [''''&raquo;''' [link boost_asio.reference.executor.target.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  const Executor * ``[link boost_asio.reference.executor.target.overload2 target]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.executor.target.overload2 more...]]``


[section:overload1 executor::target (1 of 2 overloads)]


Obtain a pointer to the target executor object. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  Executor * target();



[heading Return Value]
      
If `target_type() == typeid(T)`, a pointer to the stored executor target; otherwise, a null pointer. 




[endsect]



[section:overload2 executor::target (2 of 2 overloads)]


Obtain a pointer to the target executor object. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  const Executor * target() const;



[heading Return Value]
      
If `target_type() == typeid(T)`, a pointer to the stored executor target; otherwise, a null pointer. 




[endsect]


[endsect]


[section:target_type executor::target_type]

[indexterm2 boost_asio.indexterm.executor.target_type..target_type..executor] 
Obtain type information for the target executor object. 


  const std::type_info & target_type() const;



[heading Return Value]
      
If `*this` has a target type of type `T`, `typeid(T)`; otherwise, `typeid(void)`. 




[endsect]



[section:unspecified_bool_true executor::unspecified_bool_true]

[indexterm2 boost_asio.indexterm.executor.unspecified_bool_true..unspecified_bool_true..executor] 

  static void unspecified_bool_true(
      unspecified_bool_type_t );



[endsect]



[section:unspecified_bool_type executor::unspecified_bool_type]

[indexterm2 boost_asio.indexterm.executor.unspecified_bool_type..unspecified_bool_type..executor] 

  typedef void(*) unspecified_bool_type;



[heading Requirements]

['Header: ][^boost/asio/executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:_executor executor::~executor]

[indexterm2 boost_asio.indexterm.executor._executor..~executor..executor] 
Destructor. 


  ~executor();



[endsect]



[endsect]

[section:executor__unspecified_bool_type_t executor::unspecified_bool_type_t]

[indexterm1 boost_asio.indexterm.executor__unspecified_bool_type_t..executor::unspecified_bool_type_t]



  struct unspecified_bool_type_t


[heading Requirements]

['Header: ][^boost/asio/executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:executor_arg executor_arg]

[indexterm1 boost_asio.indexterm.executor_arg..executor_arg] 
A special value, similar to std::nothrow, used to disambiguate constructors that accept executor arguments. 


  constexpr executor_arg_t executor_arg;


See [link boost_asio.reference.executor_arg_t `executor_arg_t`] and [link boost_asio.reference.uses_executor `uses_executor`] for more information. 

[heading Requirements]

['Header: ][^boost/asio/uses_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:executor_arg_t executor_arg_t]

[indexterm1 boost_asio.indexterm.executor_arg_t..executor_arg_t]


A special type, similar to std::nothrow\_t, used to disambiguate constructors that accept executor arguments. 


  struct executor_arg_t


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.executor_arg_t.executor_arg_t [*executor_arg_t]] [constructor]]
    [Constructor. ]
  ]
  
]

The [link boost_asio.reference.executor_arg_t `executor_arg_t`] struct is an empty structure type used as a unique type to disambiguate constructor and function overloading. Specifically, some types have constructors with [link boost_asio.reference.executor_arg_t `executor_arg_t`] as the first argument, immediately followed by an argument of a type that satisfies the Executor type requirements. 

[heading Requirements]

['Header: ][^boost/asio/uses_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:executor_arg_t executor_arg_t::executor_arg_t]

[indexterm2 boost_asio.indexterm.executor_arg_t.executor_arg_t..executor_arg_t..executor_arg_t] 
Constructor. 


  constexpr executor_arg_t();



[endsect]



[endsect]

[section:executor_binder executor_binder]

[indexterm1 boost_asio.indexterm.executor_binder..executor_binder]


A call wrapper type to bind an executor of type `Executor` to an object of type `T`. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class executor_binder


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.executor_binder.argument_type [*argument_type]]]
    [The type of the function's argument. ]
  
  ]

  [

    [[link boost_asio.reference.executor_binder.executor_type [*executor_type]]]
    [The type of the associated executor. ]
  
  ]

  [

    [[link boost_asio.reference.executor_binder.first_argument_type [*first_argument_type]]]
    [The type of the function's first argument. ]
  
  ]

  [

    [[link boost_asio.reference.executor_binder.result_type [*result_type]]]
    [The return type if a function. ]
  
  ]

  [

    [[link boost_asio.reference.executor_binder.second_argument_type [*second_argument_type]]]
    [The type of the function's second argument. ]
  
  ]

  [

    [[link boost_asio.reference.executor_binder.target_type [*target_type]]]
    [The type of the target object. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.executor_binder.executor_binder [*executor_binder]] [constructor]]
    [Construct an executor wrapper for the specified object. 
     [hr]
     Copy constructor. 
     [hr]
     Construct a copy, but specify a different executor. 
     [hr]
     Construct a copy of a different executor wrapper type. 
     [hr]
     Construct a copy of a different executor wrapper type, but specify a different executor. 
     [hr]
     Move constructor. 
     [hr]
     Move construct the target object, but specify a different executor. 
     [hr]
     Move construct from a different executor wrapper type. 
     [hr]
     Move construct from a different executor wrapper type, but specify a different executor. ]
  ]
  
  [
    [[link boost_asio.reference.executor_binder.get [*get]]]
    [Obtain a reference to the target object. ]
  ]
  
  [
    [[link boost_asio.reference.executor_binder.get_executor [*get_executor]]]
    [Obtain the associated executor. ]
  ]
  
  [
    [[link boost_asio.reference.executor_binder.operator_lp__rp_ [*operator()]]]
    []
  ]
  
  [
    [[link boost_asio.reference.executor_binder._executor_binder [*~executor_binder]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/bind_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:argument_type executor_binder::argument_type]

[indexterm2 boost_asio.indexterm.executor_binder.argument_type..argument_type..executor_binder] 
The type of the function's argument. 


  typedef see_below argument_type;



The type of `argument_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to a function type accepting a single argument, `argument_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `argument_type`, then `argument_type` is a synonym for `T::argument_type`;


* otherwise `argument_type` is not defined. 



[heading Requirements]

['Header: ][^boost/asio/bind_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:executor_binder executor_binder::executor_binder]

[indexterm2 boost_asio.indexterm.executor_binder.executor_binder..executor_binder..executor_binder] 
Construct an executor wrapper for the specified object. 


  template<
      typename U>
  ``[link boost_asio.reference.executor_binder.executor_binder.overload1 executor_binder]``(
      executor_arg_t ,
      const executor_type & e,
      U && u);
  ``  [''''&raquo;''' [link boost_asio.reference.executor_binder.executor_binder.overload1 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.executor_binder.executor_binder.overload2 executor_binder]``(
      const executor_binder & other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor_binder.executor_binder.overload2 more...]]``


Construct a copy, but specify a different executor. 


  ``[link boost_asio.reference.executor_binder.executor_binder.overload3 executor_binder]``(
      executor_arg_t ,
      const executor_type & e,
      const executor_binder & other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor_binder.executor_binder.overload3 more...]]``


Construct a copy of a different executor wrapper type. 


  template<
      typename U,
      typename ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  ``[link boost_asio.reference.executor_binder.executor_binder.overload4 executor_binder]``(
      const executor_binder< U, OtherExecutor > & other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor_binder.executor_binder.overload4 more...]]``


Construct a copy of a different executor wrapper type, but specify a different executor. 


  template<
      typename U,
      typename ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  ``[link boost_asio.reference.executor_binder.executor_binder.overload5 executor_binder]``(
      executor_arg_t ,
      const executor_type & e,
      const executor_binder< U, OtherExecutor > & other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor_binder.executor_binder.overload5 more...]]``


Move constructor. 


  ``[link boost_asio.reference.executor_binder.executor_binder.overload6 executor_binder]``(
      executor_binder && other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor_binder.executor_binder.overload6 more...]]``


Move construct the target object, but specify a different executor. 


  ``[link boost_asio.reference.executor_binder.executor_binder.overload7 executor_binder]``(
      executor_arg_t ,
      const executor_type & e,
      executor_binder && other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor_binder.executor_binder.overload7 more...]]``


Move construct from a different executor wrapper type. 


  template<
      typename U,
      typename ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  ``[link boost_asio.reference.executor_binder.executor_binder.overload8 executor_binder]``(
      executor_binder< U, OtherExecutor > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor_binder.executor_binder.overload8 more...]]``


Move construct from a different executor wrapper type, but specify a different executor. 


  template<
      typename U,
      typename ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  ``[link boost_asio.reference.executor_binder.executor_binder.overload9 executor_binder]``(
      executor_arg_t ,
      const executor_type & e,
      executor_binder< U, OtherExecutor > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor_binder.executor_binder.overload9 more...]]``


[section:overload1 executor_binder::executor_binder (1 of 9 overloads)]


Construct an executor wrapper for the specified object. 


  template<
      typename U>
  executor_binder(
      executor_arg_t ,
      const executor_type & e,
      U && u);


This constructor is only valid if the type `T` is constructible from type `U`. 


[endsect]



[section:overload2 executor_binder::executor_binder (2 of 9 overloads)]


Copy constructor. 


  executor_binder(
      const executor_binder & other);



[endsect]



[section:overload3 executor_binder::executor_binder (3 of 9 overloads)]


Construct a copy, but specify a different executor. 


  executor_binder(
      executor_arg_t ,
      const executor_type & e,
      const executor_binder & other);



[endsect]



[section:overload4 executor_binder::executor_binder (4 of 9 overloads)]


Construct a copy of a different executor wrapper type. 


  template<
      typename U,
      typename ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  executor_binder(
      const executor_binder< U, OtherExecutor > & other);


This constructor is only valid if the `Executor` type is constructible from type `OtherExecutor`, and the type `T` is constructible from type `U`. 


[endsect]



[section:overload5 executor_binder::executor_binder (5 of 9 overloads)]


Construct a copy of a different executor wrapper type, but specify a different executor. 


  template<
      typename U,
      typename ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  executor_binder(
      executor_arg_t ,
      const executor_type & e,
      const executor_binder< U, OtherExecutor > & other);


This constructor is only valid if the type `T` is constructible from type `U`. 


[endsect]



[section:overload6 executor_binder::executor_binder (6 of 9 overloads)]


Move constructor. 


  executor_binder(
      executor_binder && other);



[endsect]



[section:overload7 executor_binder::executor_binder (7 of 9 overloads)]


Move construct the target object, but specify a different executor. 


  executor_binder(
      executor_arg_t ,
      const executor_type & e,
      executor_binder && other);



[endsect]



[section:overload8 executor_binder::executor_binder (8 of 9 overloads)]


Move construct from a different executor wrapper type. 


  template<
      typename U,
      typename ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  executor_binder(
      executor_binder< U, OtherExecutor > && other);



[endsect]



[section:overload9 executor_binder::executor_binder (9 of 9 overloads)]


Move construct from a different executor wrapper type, but specify a different executor. 


  template<
      typename U,
      typename ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  executor_binder(
      executor_arg_t ,
      const executor_type & e,
      executor_binder< U, OtherExecutor > && other);



[endsect]


[endsect]


[section:executor_type executor_binder::executor_type]

[indexterm2 boost_asio.indexterm.executor_binder.executor_type..executor_type..executor_binder] 
The type of the associated executor. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/bind_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:first_argument_type executor_binder::first_argument_type]

[indexterm2 boost_asio.indexterm.executor_binder.first_argument_type..first_argument_type..executor_binder] 
The type of the function's first argument. 


  typedef see_below first_argument_type;



The type of `first_argument_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to a function type accepting two arguments, `first_argument_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `first_argument_type`, then `first_argument_type` is a synonym for `T::first_argument_type`;


* otherwise `first_argument_type` is not defined. 



[heading Requirements]

['Header: ][^boost/asio/bind_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:get executor_binder::get]

[indexterm2 boost_asio.indexterm.executor_binder.get..get..executor_binder] 
Obtain a reference to the target object. 


  target_type & ``[link boost_asio.reference.executor_binder.get.overload1 get]``();
  ``  [''''&raquo;''' [link boost_asio.reference.executor_binder.get.overload1 more...]]``

  const target_type & ``[link boost_asio.reference.executor_binder.get.overload2 get]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.executor_binder.get.overload2 more...]]``


[section:overload1 executor_binder::get (1 of 2 overloads)]


Obtain a reference to the target object. 


  target_type & get();



[endsect]



[section:overload2 executor_binder::get (2 of 2 overloads)]


Obtain a reference to the target object. 


  const target_type & get() const;



[endsect]


[endsect]


[section:get_executor executor_binder::get_executor]

[indexterm2 boost_asio.indexterm.executor_binder.get_executor..get_executor..executor_binder] 
Obtain the associated executor. 


  executor_type get_executor() const;



[endsect]


[section:operator_lp__rp_ executor_binder::operator()]

[indexterm2 boost_asio.indexterm.executor_binder.operator_lp__rp_..operator()..executor_binder] 

  template<
      typename... Args>
  auto ``[link boost_asio.reference.executor_binder.operator_lp__rp_.overload1 operator()]``(
      Args && ...);
  ``  [''''&raquo;''' [link boost_asio.reference.executor_binder.operator_lp__rp_.overload1 more...]]``

  template<
      typename... Args>
  auto ``[link boost_asio.reference.executor_binder.operator_lp__rp_.overload2 operator()]``(
      Args && ...) const;
  ``  [''''&raquo;''' [link boost_asio.reference.executor_binder.operator_lp__rp_.overload2 more...]]``


[section:overload1 executor_binder::operator() (1 of 2 overloads)]



  template<
      typename... Args>
  auto operator()(
      Args && ...);



[endsect]



[section:overload2 executor_binder::operator() (2 of 2 overloads)]



  template<
      typename... Args>
  auto operator()(
      Args && ...) const;



[endsect]


[endsect]


[section:result_type executor_binder::result_type]

[indexterm2 boost_asio.indexterm.executor_binder.result_type..result_type..executor_binder] 
The return type if a function. 


  typedef see_below result_type;



The type of `result_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to function type, `result_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `result_type`, then `result_type` is a synonym for `T::result_type`;


* otherwise `result_type` is not defined. 



[heading Requirements]

['Header: ][^boost/asio/bind_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:second_argument_type executor_binder::second_argument_type]

[indexterm2 boost_asio.indexterm.executor_binder.second_argument_type..second_argument_type..executor_binder] 
The type of the function's second argument. 


  typedef see_below second_argument_type;



The type of `second_argument_type` is based on the type `T` of the wrapper's target object:


* if `T` is a pointer to a function type accepting two arguments, `second_argument_type` is a synonym for the return type of `T`;


* if `T` is a class type with a member type `first_argument_type`, then `second_argument_type` is a synonym for `T::second_argument_type`;


* otherwise `second_argument_type` is not defined. 



[heading Requirements]

['Header: ][^boost/asio/bind_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:target_type executor_binder::target_type]

[indexterm2 boost_asio.indexterm.executor_binder.target_type..target_type..executor_binder] 
The type of the target object. 


  typedef T target_type;



[heading Requirements]

['Header: ][^boost/asio/bind_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:_executor_binder executor_binder::~executor_binder]

[indexterm2 boost_asio.indexterm.executor_binder._executor_binder..~executor_binder..executor_binder] 
Destructor. 


  ~executor_binder();



[endsect]



[endsect]

[section:executor_work_guard executor_work_guard]

[indexterm1 boost_asio.indexterm.executor_work_guard..executor_work_guard]


An object of type `executor_work_guard` controls ownership of executor work within a scope. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class executor_work_guard


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.executor_work_guard.executor_type [*executor_type]]]
    [The underlying executor type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.executor_work_guard.executor_work_guard [*executor_work_guard]] [constructor]]
    [Constructs a executor_work_guard object for the specified executor. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.executor_work_guard.get_executor [*get_executor]]]
    [Obtain the associated executor. ]
  ]
  
  [
    [[link boost_asio.reference.executor_work_guard.owns_work [*owns_work]]]
    [Whether the executor_work_guard object owns some outstanding work. ]
  ]
  
  [
    [[link boost_asio.reference.executor_work_guard.reset [*reset]]]
    [Indicate that the work is no longer outstanding. ]
  ]
  
  [
    [[link boost_asio.reference.executor_work_guard._executor_work_guard [*~executor_work_guard]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/executor_work_guard.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:executor_type executor_work_guard::executor_type]

[indexterm2 boost_asio.indexterm.executor_work_guard.executor_type..executor_type..executor_work_guard] 
The underlying executor type. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/executor_work_guard.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:executor_work_guard executor_work_guard::executor_work_guard]

[indexterm2 boost_asio.indexterm.executor_work_guard.executor_work_guard..executor_work_guard..executor_work_guard] 
Constructs a `executor_work_guard` object for the specified executor. 


  explicit ``[link boost_asio.reference.executor_work_guard.executor_work_guard.overload1 executor_work_guard]``(
      const executor_type & e);
  ``  [''''&raquo;''' [link boost_asio.reference.executor_work_guard.executor_work_guard.overload1 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.executor_work_guard.executor_work_guard.overload2 executor_work_guard]``(
      const executor_work_guard & other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor_work_guard.executor_work_guard.overload2 more...]]``


Move constructor. 


  ``[link boost_asio.reference.executor_work_guard.executor_work_guard.overload3 executor_work_guard]``(
      executor_work_guard && other);
  ``  [''''&raquo;''' [link boost_asio.reference.executor_work_guard.executor_work_guard.overload3 more...]]``


[section:overload1 executor_work_guard::executor_work_guard (1 of 3 overloads)]


Constructs a `executor_work_guard` object for the specified executor. 


  executor_work_guard(
      const executor_type & e);


Stores a copy of `e` and calls `on_work_started()` on it. 


[endsect]



[section:overload2 executor_work_guard::executor_work_guard (2 of 3 overloads)]


Copy constructor. 


  executor_work_guard(
      const executor_work_guard & other);



[endsect]



[section:overload3 executor_work_guard::executor_work_guard (3 of 3 overloads)]


Move constructor. 


  executor_work_guard(
      executor_work_guard && other);



[endsect]


[endsect]


[section:get_executor executor_work_guard::get_executor]

[indexterm2 boost_asio.indexterm.executor_work_guard.get_executor..get_executor..executor_work_guard] 
Obtain the associated executor. 


  executor_type get_executor() const;



[endsect]



[section:owns_work executor_work_guard::owns_work]

[indexterm2 boost_asio.indexterm.executor_work_guard.owns_work..owns_work..executor_work_guard] 
Whether the [link boost_asio.reference.executor_work_guard `executor_work_guard`] object owns some outstanding work. 


  bool owns_work() const;



[endsect]



[section:reset executor_work_guard::reset]

[indexterm2 boost_asio.indexterm.executor_work_guard.reset..reset..executor_work_guard] 
Indicate that the work is no longer outstanding. 


  void reset();


Unless the object has already been reset, or is in a moved-from state, calls `on_work_finished()` on the stored executor. 


[endsect]



[section:_executor_work_guard executor_work_guard::~executor_work_guard]

[indexterm2 boost_asio.indexterm.executor_work_guard._executor_work_guard..~executor_work_guard..executor_work_guard] 
Destructor. 


  ~executor_work_guard();


Unless the object has already been reset, or is in a moved-from state, calls `on_work_finished()` on the stored executor. 


[endsect]



[endsect]


[section:experimental__append experimental::append]

[indexterm1 boost_asio.indexterm.experimental__append..experimental::append] 
Completion token type used to specify that the completion handler arguments should be passed additional values after the results of the operation. 


  template<
      typename CompletionToken,
      typename... Values>
  constexpr append_t< typename decay< CompletionToken >::type, typename decay< Values >::type...> append(
      CompletionToken && completion_token,
      Values &&... values);


[heading Requirements]

['Header: ][^boost/asio/experimental/append.hpp]

['Convenience header: ]None


[endsect]


[section:experimental__append_t experimental::append_t]

[indexterm1 boost_asio.indexterm.experimental__append_t..experimental::append_t]


Completion token type used to specify that the completion handler arguments should be passed additional values after the results of the operation. 


  template<
      typename CompletionToken,
      typename... Values>
  class append_t


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__append_t.append_t [*append_t]] [constructor]]
    [Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__append_t.token_ [*token_]]]
    []
  ]

  [
    [[link boost_asio.reference.experimental__append_t.values_ [*values_]]]
    []
  ]

]

[heading Requirements]

['Header: ][^boost/asio/experimental/append.hpp]

['Convenience header: ]None


[section:append_t experimental::append_t::append_t]

[indexterm2 boost_asio.indexterm.experimental__append_t.append_t..append_t..experimental::append_t] 
Constructor. 


  template<
      typename T,
      typename... V>
  constexpr append_t(
      T && completion_token,
      V &&... values);



[endsect]



[section:token_ experimental::append_t::token_]

[indexterm2 boost_asio.indexterm.experimental__append_t.token_..token_..experimental::append_t] 

  CompletionToken token_;



[endsect]



[section:values_ experimental::append_t::values_]

[indexterm2 boost_asio.indexterm.experimental__append_t.values_..values_..experimental::append_t] 

  std::tuple< Values...> values_;



[endsect]



[endsect]


[section:experimental__as_single experimental::as_single]

[indexterm1 boost_asio.indexterm.experimental__as_single..experimental::as_single] 
Create a completion token to specify that the completion handler arguments should be combined into a single argument. 


  template<
      typename CompletionToken>
  constexpr as_single_t< typename decay< CompletionToken >::type > as_single(
      CompletionToken && completion_token);


[heading Requirements]

['Header: ][^boost/asio/experimental/as_single.hpp]

['Convenience header: ]None


[endsect]


[section:experimental__as_single_t experimental::as_single_t]

[indexterm1 boost_asio.indexterm.experimental__as_single_t..experimental::as_single_t]


Completion token type used to specify that the completion handler arguments should be combined into a single argument. 


  template<
      typename CompletionToken>
  class as_single_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__as_single_t__default_constructor_tag [*default_constructor_tag]]]
    [Tag type used to prevent the "default" constructor from being used for conversions. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__as_single_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the as_single_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__as_single_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use as_single_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__as_single_t.as_single_t [*as_single_t]] [constructor]]
    [Default constructor. 
     [hr]
     Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__as_single_t.token_ [*token_]]]
    []
  ]

]

The [link boost_asio.reference.experimental__as_single_t `experimental::as_single_t`] class is used to indicate that any arguments to the completion handler should be combined and passed as a single argument. If there is already one argument, that argument is passed as-is. If there is more than argument, the arguments are first moved into a `std::tuple` and that tuple is then passed to the completion handler. 

[heading Requirements]

['Header: ][^boost/asio/experimental/as_single.hpp]

['Convenience header: ]None


[section:as_default_on experimental::as_single_t::as_default_on]

[indexterm2 boost_asio.indexterm.experimental__as_single_t.as_default_on..as_default_on..experimental::as_single_t] 
Function helper to adapt an I/O object to use `as_single_t` as its default completion token type. 


  template<
      typename T>
  static decay< T >::type::template rebind_executor< executor_with_default< typename decay< T >::type::executor_type > >::other as_default_on(
      T && object);



[endsect]


[section:as_single_t experimental::as_single_t::as_single_t]

[indexterm2 boost_asio.indexterm.experimental__as_single_t.as_single_t..as_single_t..experimental::as_single_t] 
Default constructor. 


  constexpr ``[link boost_asio.reference.experimental__as_single_t.as_single_t.overload1 as_single_t]``(
      default_constructor_tag  = default_constructor_tag(),
      CompletionToken token = CompletionToken());
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__as_single_t.as_single_t.overload1 more...]]``


Constructor. 


  template<
      typename T>
  explicit constexpr ``[link boost_asio.reference.experimental__as_single_t.as_single_t.overload2 as_single_t]``(
      T && completion_token);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__as_single_t.as_single_t.overload2 more...]]``


[section:overload1 experimental::as_single_t::as_single_t (1 of 2 overloads)]


Default constructor. 


  constexpr as_single_t(
      default_constructor_tag  = default_constructor_tag(),
      CompletionToken token = CompletionToken());


This constructor is only valid if the underlying completion token is default constructible and move constructible. The underlying completion token is itself defaulted as an argument to allow it to capture a source location. 


[endsect]



[section:overload2 experimental::as_single_t::as_single_t (2 of 2 overloads)]


Constructor. 


  template<
      typename T>
  constexpr as_single_t(
      T && completion_token);



[endsect]


[endsect]


[section:token_ experimental::as_single_t::token_]

[indexterm2 boost_asio.indexterm.experimental__as_single_t.token_..token_..experimental::as_single_t] 

  CompletionToken token_;



[endsect]



[endsect]

[section:experimental__as_single_t__default_constructor_tag experimental::as_single_t::default_constructor_tag]

[indexterm1 boost_asio.indexterm.experimental__as_single_t__default_constructor_tag..experimental::as_single_t::default_constructor_tag]


Tag type used to prevent the "default" constructor from being used for conversions. 


  struct default_constructor_tag


[heading Requirements]

['Header: ][^boost/asio/experimental/as_single.hpp]

['Convenience header: ]None


[endsect]

[section:experimental__as_single_t__executor_with_default experimental::as_single_t::executor_with_default]

[indexterm1 boost_asio.indexterm.experimental__as_single_t__executor_with_default..experimental::as_single_t::executor_with_default]


Adapts an executor to add the `as_single_t` completion token as the default. 


  template<
      typename ``[link boost_asio.reference.Executor1 InnerExecutor]``>
  struct executor_with_default


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__as_single_t__executor_with_default.default_completion_token_type [*default_completion_token_type]]]
    [Specify as_single_t as the default completion token type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__as_single_t__executor_with_default.executor_with_default [*executor_with_default]] [constructor]]
    [Construct the adapted executor from the inner executor type. 
     [hr]
     Convert the specified executor to the inner executor type, then use that to construct the adapted executor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/as_single.hpp]

['Convenience header: ]None


[section:default_completion_token_type experimental::as_single_t::executor_with_default::default_completion_token_type]

[indexterm2 boost_asio.indexterm.experimental__as_single_t__executor_with_default.default_completion_token_type..default_completion_token_type..experimental::as_single_t::executor_with_default] 
Specify `as_single_t` as the default completion token type. 


  typedef as_single_t default_completion_token_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__as_single_t__default_constructor_tag [*default_constructor_tag]]]
    [Tag type used to prevent the "default" constructor from being used for conversions. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__as_single_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the as_single_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__as_single_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use as_single_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__as_single_t.as_single_t [*as_single_t]] [constructor]]
    [Default constructor. 
     [hr]
     Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__as_single_t.token_ [*token_]]]
    []
  ]

]

The [link boost_asio.reference.experimental__as_single_t `experimental::as_single_t`] class is used to indicate that any arguments to the completion handler should be combined and passed as a single argument. If there is already one argument, that argument is passed as-is. If there is more than argument, the arguments are first moved into a `std::tuple` and that tuple is then passed to the completion handler. 


[heading Requirements]

['Header: ][^boost/asio/experimental/as_single.hpp]

['Convenience header: ]None


[endsect]


[section:executor_with_default experimental::as_single_t::executor_with_default::executor_with_default]

[indexterm2 boost_asio.indexterm.experimental__as_single_t__executor_with_default.executor_with_default..executor_with_default..experimental::as_single_t::executor_with_default] 
Construct the adapted executor from the inner executor type. 


  ``[link boost_asio.reference.experimental__as_single_t__executor_with_default.executor_with_default.overload1 executor_with_default]``(
      const InnerExecutor & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__as_single_t__executor_with_default.executor_with_default.overload1 more...]]``


Convert the specified executor to the inner executor type, then use that to construct the adapted executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  ``[link boost_asio.reference.experimental__as_single_t__executor_with_default.executor_with_default.overload2 executor_with_default]``(
      const OtherExecutor & ex,
      typename constraint< is_convertible< OtherExecutor, InnerExecutor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__as_single_t__executor_with_default.executor_with_default.overload2 more...]]``


[section:overload1 experimental::as_single_t::executor_with_default::executor_with_default (1 of 2 overloads)]


Construct the adapted executor from the inner executor type. 


  executor_with_default(
      const InnerExecutor & ex);



[endsect]



[section:overload2 experimental::as_single_t::executor_with_default::executor_with_default (2 of 2 overloads)]


Convert the specified executor to the inner executor type, then use that to construct the adapted executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  executor_with_default(
      const OtherExecutor & ex,
      typename constraint< is_convertible< OtherExecutor, InnerExecutor >::value >::type  = 0);



[endsect]


[endsect]


[endsect]


[section:experimental__as_tuple experimental::as_tuple]

[indexterm1 boost_asio.indexterm.experimental__as_tuple..experimental::as_tuple] 
Create a completion token to specify that the completion handler arguments should be combined into a single tuple argument. 


  template<
      typename CompletionToken>
  constexpr as_tuple_t< typename decay< CompletionToken >::type > as_tuple(
      CompletionToken && completion_token);


[heading Requirements]

['Header: ][^boost/asio/experimental/as_tuple.hpp]

['Convenience header: ]None


[endsect]


[section:experimental__as_tuple_t experimental::as_tuple_t]

[indexterm1 boost_asio.indexterm.experimental__as_tuple_t..experimental::as_tuple_t]


Completion token type used to specify that the completion handler arguments should be combined into a single tuple argument. 


  template<
      typename CompletionToken>
  class as_tuple_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__as_tuple_t__default_constructor_tag [*default_constructor_tag]]]
    [Tag type used to prevent the "default" constructor from being used for conversions. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__as_tuple_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the as_tuple_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__as_tuple_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use as_tuple_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__as_tuple_t.as_tuple_t [*as_tuple_t]] [constructor]]
    [Default constructor. 
     [hr]
     Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__as_tuple_t.token_ [*token_]]]
    []
  ]

]

The [link boost_asio.reference.experimental__as_tuple_t `experimental::as_tuple_t`] class is used to indicate that any arguments to the completion handler should be combined and passed as a single tuple argument. The arguments are first moved into a `std::tuple` and that tuple is then passed to the completion handler. 

[heading Requirements]

['Header: ][^boost/asio/experimental/as_tuple.hpp]

['Convenience header: ]None


[section:as_default_on experimental::as_tuple_t::as_default_on]

[indexterm2 boost_asio.indexterm.experimental__as_tuple_t.as_default_on..as_default_on..experimental::as_tuple_t] 
Function helper to adapt an I/O object to use `as_tuple_t` as its default completion token type. 


  template<
      typename T>
  static decay< T >::type::template rebind_executor< executor_with_default< typename decay< T >::type::executor_type > >::other as_default_on(
      T && object);



[endsect]


[section:as_tuple_t experimental::as_tuple_t::as_tuple_t]

[indexterm2 boost_asio.indexterm.experimental__as_tuple_t.as_tuple_t..as_tuple_t..experimental::as_tuple_t] 
Default constructor. 


  constexpr ``[link boost_asio.reference.experimental__as_tuple_t.as_tuple_t.overload1 as_tuple_t]``(
      default_constructor_tag  = default_constructor_tag(),
      CompletionToken token = CompletionToken());
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__as_tuple_t.as_tuple_t.overload1 more...]]``


Constructor. 


  template<
      typename T>
  explicit constexpr ``[link boost_asio.reference.experimental__as_tuple_t.as_tuple_t.overload2 as_tuple_t]``(
      T && completion_token);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__as_tuple_t.as_tuple_t.overload2 more...]]``


[section:overload1 experimental::as_tuple_t::as_tuple_t (1 of 2 overloads)]


Default constructor. 


  constexpr as_tuple_t(
      default_constructor_tag  = default_constructor_tag(),
      CompletionToken token = CompletionToken());


This constructor is only valid if the underlying completion token is default constructible and move constructible. The underlying completion token is itself defaulted as an argument to allow it to capture a source location. 


[endsect]



[section:overload2 experimental::as_tuple_t::as_tuple_t (2 of 2 overloads)]


Constructor. 


  template<
      typename T>
  constexpr as_tuple_t(
      T && completion_token);



[endsect]


[endsect]


[section:token_ experimental::as_tuple_t::token_]

[indexterm2 boost_asio.indexterm.experimental__as_tuple_t.token_..token_..experimental::as_tuple_t] 

  CompletionToken token_;



[endsect]



[endsect]

[section:experimental__as_tuple_t__default_constructor_tag experimental::as_tuple_t::default_constructor_tag]

[indexterm1 boost_asio.indexterm.experimental__as_tuple_t__default_constructor_tag..experimental::as_tuple_t::default_constructor_tag]


Tag type used to prevent the "default" constructor from being used for conversions. 


  struct default_constructor_tag


[heading Requirements]

['Header: ][^boost/asio/experimental/as_tuple.hpp]

['Convenience header: ]None


[endsect]

[section:experimental__as_tuple_t__executor_with_default experimental::as_tuple_t::executor_with_default]

[indexterm1 boost_asio.indexterm.experimental__as_tuple_t__executor_with_default..experimental::as_tuple_t::executor_with_default]


Adapts an executor to add the `as_tuple_t` completion token as the default. 


  template<
      typename ``[link boost_asio.reference.Executor1 InnerExecutor]``>
  struct executor_with_default


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__as_tuple_t__executor_with_default.default_completion_token_type [*default_completion_token_type]]]
    [Specify as_tuple_t as the default completion token type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__as_tuple_t__executor_with_default.executor_with_default [*executor_with_default]] [constructor]]
    [Construct the adapted executor from the inner executor type. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/as_tuple.hpp]

['Convenience header: ]None


[section:default_completion_token_type experimental::as_tuple_t::executor_with_default::default_completion_token_type]

[indexterm2 boost_asio.indexterm.experimental__as_tuple_t__executor_with_default.default_completion_token_type..default_completion_token_type..experimental::as_tuple_t::executor_with_default] 
Specify `as_tuple_t` as the default completion token type. 


  typedef as_tuple_t default_completion_token_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__as_tuple_t__default_constructor_tag [*default_constructor_tag]]]
    [Tag type used to prevent the "default" constructor from being used for conversions. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__as_tuple_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the as_tuple_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__as_tuple_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use as_tuple_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__as_tuple_t.as_tuple_t [*as_tuple_t]] [constructor]]
    [Default constructor. 
     [hr]
     Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__as_tuple_t.token_ [*token_]]]
    []
  ]

]

The [link boost_asio.reference.experimental__as_tuple_t `experimental::as_tuple_t`] class is used to indicate that any arguments to the completion handler should be combined and passed as a single tuple argument. The arguments are first moved into a `std::tuple` and that tuple is then passed to the completion handler. 


[heading Requirements]

['Header: ][^boost/asio/experimental/as_tuple.hpp]

['Convenience header: ]None


[endsect]



[section:executor_with_default experimental::as_tuple_t::executor_with_default::executor_with_default]

[indexterm2 boost_asio.indexterm.experimental__as_tuple_t__executor_with_default.executor_with_default..executor_with_default..experimental::as_tuple_t::executor_with_default] 
Construct the adapted executor from the inner executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 InnerExecutor1]``>
  executor_with_default(
      const InnerExecutor1 & ex,
      typename constraint< conditional< !is_same< InnerExecutor1, executor_with_default >::value, is_convertible< InnerExecutor1, InnerExecutor >, false_type >::type::value >::type  = 0);



[endsect]



[endsect]

[section:experimental__awaitable_operators__operator__amp__amp_ experimental::awaitable_operators::operator &&]

[indexterm1 boost_asio.indexterm.experimental__awaitable_operators__operator__amp__amp_..experimental::awaitable_operators::operator &&] 
Wait for both operations to succeed. 

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< void, Executor > ``[link boost_asio.reference.experimental__awaitable_operators__operator__amp__amp_.overload1 operator &&]``(
      awaitable< void, Executor > t,
      awaitable< void, Executor > u);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__awaitable_operators__operator__amp__amp_.overload1 more...]]``

  template<
      typename U,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< U, Executor > ``[link boost_asio.reference.experimental__awaitable_operators__operator__amp__amp_.overload2 operator &&]``(
      awaitable< void, Executor > t,
      awaitable< U, Executor > u);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__awaitable_operators__operator__amp__amp_.overload2 more...]]``

  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< T, Executor > ``[link boost_asio.reference.experimental__awaitable_operators__operator__amp__amp_.overload3 operator &&]``(
      awaitable< T, Executor > t,
      awaitable< void, Executor > u);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__awaitable_operators__operator__amp__amp_.overload3 more...]]``

  template<
      typename T,
      typename U,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::tuple< T, U >, Executor > ``[link boost_asio.reference.experimental__awaitable_operators__operator__amp__amp_.overload4 operator &&]``(
      awaitable< T, Executor > t,
      awaitable< U, Executor > u);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__awaitable_operators__operator__amp__amp_.overload4 more...]]``

  template<
      typename... T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::tuple< T..., std::monostate >, Executor > ``[link boost_asio.reference.experimental__awaitable_operators__operator__amp__amp_.overload5 operator &&]``(
      awaitable< std::tuple< T...>, Executor > t,
      awaitable< void, Executor > u);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__awaitable_operators__operator__amp__amp_.overload5 more...]]``

  template<
      typename... T,
      typename U,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::tuple< T..., U >, Executor > ``[link boost_asio.reference.experimental__awaitable_operators__operator__amp__amp_.overload6 operator &&]``(
      awaitable< std::tuple< T...>, Executor > t,
      awaitable< U, Executor > u);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__awaitable_operators__operator__amp__amp_.overload6 more...]]``

[heading Requirements]

['Header: ][^boost/asio/experimental/awaitable_operators.hpp]

['Convenience header: ]None


[section:overload1 experimental::awaitable_operators::operator && (1 of 6 overloads)]


Wait for both operations to succeed. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< void, Executor > operator &&(
      awaitable< void, Executor > t,
      awaitable< void, Executor > u);


If one operations fails, the other is cancelled as the AND-condition can no longer be satisfied. 


[endsect]



[section:overload2 experimental::awaitable_operators::operator && (2 of 6 overloads)]


Wait for both operations to succeed. 


  template<
      typename U,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< U, Executor > operator &&(
      awaitable< void, Executor > t,
      awaitable< U, Executor > u);


If one operations fails, the other is cancelled as the AND-condition can no longer be satisfied. 


[endsect]



[section:overload3 experimental::awaitable_operators::operator && (3 of 6 overloads)]


Wait for both operations to succeed. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< T, Executor > operator &&(
      awaitable< T, Executor > t,
      awaitable< void, Executor > u);


If one operations fails, the other is cancelled as the AND-condition can no longer be satisfied. 


[endsect]



[section:overload4 experimental::awaitable_operators::operator && (4 of 6 overloads)]


Wait for both operations to succeed. 


  template<
      typename T,
      typename U,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::tuple< T, U >, Executor > operator &&(
      awaitable< T, Executor > t,
      awaitable< U, Executor > u);


If one operations fails, the other is cancelled as the AND-condition can no longer be satisfied. 


[endsect]



[section:overload5 experimental::awaitable_operators::operator && (5 of 6 overloads)]


Wait for both operations to succeed. 


  template<
      typename... T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::tuple< T..., std::monostate >, Executor > operator &&(
      awaitable< std::tuple< T...>, Executor > t,
      awaitable< void, Executor > u);


If one operations fails, the other is cancelled as the AND-condition can no longer be satisfied. 


[endsect]



[section:overload6 experimental::awaitable_operators::operator && (6 of 6 overloads)]


Wait for both operations to succeed. 


  template<
      typename... T,
      typename U,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::tuple< T..., U >, Executor > operator &&(
      awaitable< std::tuple< T...>, Executor > t,
      awaitable< U, Executor > u);


If one operations fails, the other is cancelled as the AND-condition can no longer be satisfied. 


[endsect]


[endsect]

[section:experimental__awaitable_operators__operator_pipe__pipe_ experimental::awaitable_operators::operator||]

[indexterm1 boost_asio.indexterm.experimental__awaitable_operators__operator_pipe__pipe_..experimental::awaitable_operators::operator||] 
Wait for one operation to succeed. 

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::variant< std::monostate, std::monostate >, Executor > ``[link boost_asio.reference.experimental__awaitable_operators__operator_pipe__pipe_.overload1 operator||]``(
      awaitable< void, Executor > t,
      awaitable< void, Executor > u);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__awaitable_operators__operator_pipe__pipe_.overload1 more...]]``

  template<
      typename U,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::variant< std::monostate, U >, Executor > ``[link boost_asio.reference.experimental__awaitable_operators__operator_pipe__pipe_.overload2 operator||]``(
      awaitable< void, Executor > t,
      awaitable< U, Executor > u);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__awaitable_operators__operator_pipe__pipe_.overload2 more...]]``

  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::variant< T, std::monostate >, Executor > ``[link boost_asio.reference.experimental__awaitable_operators__operator_pipe__pipe_.overload3 operator||]``(
      awaitable< T, Executor > t,
      awaitable< void, Executor > u);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__awaitable_operators__operator_pipe__pipe_.overload3 more...]]``

  template<
      typename T,
      typename U,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::variant< T, U >, Executor > ``[link boost_asio.reference.experimental__awaitable_operators__operator_pipe__pipe_.overload4 operator||]``(
      awaitable< T, Executor > t,
      awaitable< U, Executor > u);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__awaitable_operators__operator_pipe__pipe_.overload4 more...]]``

  template<
      typename... T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::variant< T..., std::monostate >, Executor > ``[link boost_asio.reference.experimental__awaitable_operators__operator_pipe__pipe_.overload5 operator||]``(
      awaitable< std::variant< T...>, Executor > t,
      awaitable< void, Executor > u);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__awaitable_operators__operator_pipe__pipe_.overload5 more...]]``

  template<
      typename... T,
      typename U,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::variant< T..., U >, Executor > ``[link boost_asio.reference.experimental__awaitable_operators__operator_pipe__pipe_.overload6 operator||]``(
      awaitable< std::variant< T...>, Executor > t,
      awaitable< U, Executor > u);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__awaitable_operators__operator_pipe__pipe_.overload6 more...]]``

[heading Requirements]

['Header: ][^boost/asio/experimental/awaitable_operators.hpp]

['Convenience header: ]None


[section:overload1 experimental::awaitable_operators::operator|| (1 of 6 overloads)]


Wait for one operation to succeed. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::variant< std::monostate, std::monostate >, Executor > operator||(
      awaitable< void, Executor > t,
      awaitable< void, Executor > u);


If one operations succeeds, the other is cancelled as the OR-condition is already satisfied. 


[endsect]



[section:overload2 experimental::awaitable_operators::operator|| (2 of 6 overloads)]


Wait for one operation to succeed. 


  template<
      typename U,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::variant< std::monostate, U >, Executor > operator||(
      awaitable< void, Executor > t,
      awaitable< U, Executor > u);


If one operations succeeds, the other is cancelled as the OR-condition is already satisfied. 


[endsect]



[section:overload3 experimental::awaitable_operators::operator|| (3 of 6 overloads)]


Wait for one operation to succeed. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::variant< T, std::monostate >, Executor > operator||(
      awaitable< T, Executor > t,
      awaitable< void, Executor > u);


If one operations succeeds, the other is cancelled as the OR-condition is already satisfied. 


[endsect]



[section:overload4 experimental::awaitable_operators::operator|| (4 of 6 overloads)]


Wait for one operation to succeed. 


  template<
      typename T,
      typename U,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::variant< T, U >, Executor > operator||(
      awaitable< T, Executor > t,
      awaitable< U, Executor > u);


If one operations succeeds, the other is cancelled as the OR-condition is already satisfied. 


[endsect]



[section:overload5 experimental::awaitable_operators::operator|| (5 of 6 overloads)]


Wait for one operation to succeed. 


  template<
      typename... T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::variant< T..., std::monostate >, Executor > operator||(
      awaitable< std::variant< T...>, Executor > t,
      awaitable< void, Executor > u);


If one operations succeeds, the other is cancelled as the OR-condition is already satisfied. 


[endsect]



[section:overload6 experimental::awaitable_operators::operator|| (6 of 6 overloads)]


Wait for one operation to succeed. 


  template<
      typename... T,
      typename U,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  awaitable< std::variant< T..., U >, Executor > operator||(
      awaitable< std::variant< T...>, Executor > t,
      awaitable< U, Executor > u);


If one operations succeeds, the other is cancelled as the OR-condition is already satisfied. 


[endsect]


[endsect]

[section:experimental__basic_channel experimental::basic_channel]

[indexterm1 boost_asio.indexterm.experimental__basic_channel..experimental::basic_channel]


A channel for messages. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Traits,
      typename... Signatures>
  class basic_channel


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__basic_channel__rebind_executor [*rebind_executor]]]
    [Rebinds the channel type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__basic_channel.executor_type [*executor_type]]]
    [The type of the executor associated with the channel. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__basic_channel.traits_type [*traits_type]]]
    [The traits type associated with the channel. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__basic_channel.async_receive [*async_receive]]]
    [Asynchronously receive a message. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.async_send [*async_send]]]
    [Asynchronously send a message. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.basic_channel [*basic_channel]] [constructor]]
    [Construct a basic_channel. 
     [hr]
     Construct and open a basic_channel. 
     [hr]
     Move-construct a basic_channel from another. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.cancel [*cancel]]]
    [Cancel all asynchronous operations waiting on the channel. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.capacity [*capacity]]]
    [Get the capacity of the channel's buffer. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.close [*close]]]
    [Close the channel. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.is_open [*is_open]]]
    [Determine whether the channel is open. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.operator_eq_ [*operator=]]]
    [Move-assign a basic_channel from another. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.ready [*ready]]]
    [Determine whether a message can be received without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.reset [*reset]]]
    [Reset the channel to its initial state. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.try_receive [*try_receive]]]
    [Try to receive a message without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.try_send [*try_send]]]
    [Try to send a message without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.try_send_n [*try_send_n]]]
    [Try to send a number of messages without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel._basic_channel [*~basic_channel]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/basic_channel.hpp]

['Convenience header: ]None


[section:async_receive experimental::basic_channel::async_receive]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.async_receive..async_receive..experimental::basic_channel] 
Asynchronously receive a message. 


  template<
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  auto async_receive(
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);



[endsect]



[section:async_send experimental::basic_channel::async_send]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.async_send..async_send..experimental::basic_channel] 
Asynchronously send a message. 


  template<
      typename... Args,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  auto async_send(
      Args &&... args,
      CompletionToken && token);



[endsect]


[section:basic_channel experimental::basic_channel::basic_channel]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.basic_channel..basic_channel..experimental::basic_channel] 
Construct a [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`]. 


  ``[link boost_asio.reference.experimental__basic_channel.basic_channel.overload1 basic_channel]``(
      const executor_type & ex,
      std::size_t max_buffer_size = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__basic_channel.basic_channel.overload1 more...]]``


Construct and open a [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`]. 


  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.experimental__basic_channel.basic_channel.overload2 basic_channel]``(
      ExecutionContext & context,
      std::size_t max_buffer_size = 0,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__basic_channel.basic_channel.overload2 more...]]``


Move-construct a [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`] from another. 


  ``[link boost_asio.reference.experimental__basic_channel.basic_channel.overload3 basic_channel]``(
      basic_channel && other);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__basic_channel.basic_channel.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.experimental__basic_channel.basic_channel.overload4 basic_channel]``(
      basic_channel< Executor1, Traits, Signatures...> && other,
      typename constraint< is_convertible< Executor1, Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__basic_channel.basic_channel.overload4 more...]]``


[section:overload1 experimental::basic_channel::basic_channel (1 of 4 overloads)]


Construct a [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`]. 


  basic_channel(
      const executor_type & ex,
      std::size_t max_buffer_size = 0);


This constructor creates and channel.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the channel will use, by default, to dispatch handlers for any asynchronous operations performed on the channel.]]

[[max_buffer_size][The maximum number of messages that may be buffered in the channel. ]]

]




[endsect]



[section:overload2 experimental::basic_channel::basic_channel (2 of 4 overloads)]


Construct and open a [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`]. 


  template<
      typename ExecutionContext>
  basic_channel(
      ExecutionContext & context,
      std::size_t max_buffer_size = 0,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates and opens a channel.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the channel will use, by default, to dispatch handlers for any asynchronous operations performed on the channel.]]

[[max_buffer_size][The maximum number of messages that may be buffered in the channel. ]]

]




[endsect]



[section:overload3 experimental::basic_channel::basic_channel (3 of 4 overloads)]


Move-construct a [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`] from another. 


  basic_channel(
      basic_channel && other);


This constructor moves a channel from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_channel(const executor_type&) constructor`. 




[endsect]



[section:overload4 experimental::basic_channel::basic_channel (4 of 4 overloads)]


Move-construct a [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`] from another. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_channel(
      basic_channel< Executor1, Traits, Signatures...> && other,
      typename constraint< is_convertible< Executor1, Executor >::value >::type  = 0);


This constructor moves a channel from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_channel(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:cancel experimental::basic_channel::cancel]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.cancel..cancel..experimental::basic_channel] 
Cancel all asynchronous operations waiting on the channel. 


  void cancel();


All outstanding send operations will complete with the error `boost::asio::experimental::error::channel_canceld`. Outstanding receive operations complete with the result as determined by the channel traits. 


[endsect]



[section:capacity experimental::basic_channel::capacity]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.capacity..capacity..experimental::basic_channel] 
Get the capacity of the channel's buffer. 


  std::size_t capacity();



[endsect]



[section:close experimental::basic_channel::close]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.close..close..experimental::basic_channel] 
Close the channel. 


  void close();



[endsect]



[section:executor_type experimental::basic_channel::executor_type]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.executor_type..executor_type..experimental::basic_channel] 
The type of the executor associated with the channel. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/experimental/basic_channel.hpp]

['Convenience header: ]None


[endsect]



[section:get_executor experimental::basic_channel::get_executor]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.get_executor..get_executor..experimental::basic_channel] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:is_open experimental::basic_channel::is_open]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.is_open..is_open..experimental::basic_channel] 
Determine whether the channel is open. 


  bool is_open() const;



[endsect]


[section:operator_eq_ experimental::basic_channel::operator=]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.operator_eq_..operator=..experimental::basic_channel] 
Move-assign a [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`] from another. 


  basic_channel & ``[link boost_asio.reference.experimental__basic_channel.operator_eq_.overload1 operator=]``(
      basic_channel && other);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__basic_channel.operator_eq_.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_channel & >::type ``[link boost_asio.reference.experimental__basic_channel.operator_eq_.overload2 operator=]``(
      basic_channel< Executor1, Traits, Signatures...> && other);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__basic_channel.operator_eq_.overload2 more...]]``


[section:overload1 experimental::basic_channel::operator= (1 of 2 overloads)]


Move-assign a [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`] from another. 


  basic_channel & operator=(
      basic_channel && other);


This assignment operator moves a channel from one object to another. Cancels any outstanding asynchronous operations associated with the target object.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_channel(const executor_type&)` constructor. 




[endsect]



[section:overload2 experimental::basic_channel::operator= (2 of 2 overloads)]


Move-assign a [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`] from another. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_channel & >::type operator=(
      basic_channel< Executor1, Traits, Signatures...> && other);


This assignment operator moves a channel from one object to another. Cancels any outstanding asynchronous operations associated with the target object.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.experimental__basic_channel `experimental::basic_channel`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_channel(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:ready experimental::basic_channel::ready]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.ready..ready..experimental::basic_channel] 
Determine whether a message can be received without blocking. 


  bool ready() const;



[endsect]



[section:reset experimental::basic_channel::reset]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.reset..reset..experimental::basic_channel] 
Reset the channel to its initial state. 


  void reset();



[endsect]



[section:traits_type experimental::basic_channel::traits_type]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.traits_type..traits_type..experimental::basic_channel] 
The traits type associated with the channel. 


  typedef Traits::template rebind< Signatures...>::other traits_type;



[heading Requirements]

['Header: ][^boost/asio/experimental/basic_channel.hpp]

['Convenience header: ]None


[endsect]



[section:try_receive experimental::basic_channel::try_receive]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.try_receive..try_receive..experimental::basic_channel] 
Try to receive a message without blocking. 


  template<
      typename ``[link boost_asio.reference.Handler Handler]``>
  bool try_receive(
      Handler && handler);


Fails if the buffer is full and there are no waiting receive operations.


[heading Return Value]
      
`true` on success, `false` on failure. 




[endsect]



[section:try_send experimental::basic_channel::try_send]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.try_send..try_send..experimental::basic_channel] 
Try to send a message without blocking. 


  template<
      typename... Args>
  bool try_send(
      Args &&... args);


Fails if the buffer is full and there are no waiting receive operations.


[heading Return Value]
      
`true` on success, `false` on failure. 




[endsect]



[section:try_send_n experimental::basic_channel::try_send_n]

[indexterm2 boost_asio.indexterm.experimental__basic_channel.try_send_n..try_send_n..experimental::basic_channel] 
Try to send a number of messages without blocking. 


  template<
      typename... Args>
  std::size_t try_send_n(
      std::size_t count,
      Args &&... args);



[heading Return Value]
      
The number of messages that were sent. 




[endsect]



[section:_basic_channel experimental::basic_channel::~basic_channel]

[indexterm2 boost_asio.indexterm.experimental__basic_channel._basic_channel..~basic_channel..experimental::basic_channel] 
Destructor. 


  ~basic_channel();



[endsect]



[endsect]

[section:experimental__basic_channel__rebind_executor experimental::basic_channel::rebind_executor]

[indexterm1 boost_asio.indexterm.experimental__basic_channel__rebind_executor..experimental::basic_channel::rebind_executor]


Rebinds the channel type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__basic_channel__rebind_executor.other [*other]]]
    [The channel type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/experimental/basic_channel.hpp]

['Convenience header: ]None


[section:other experimental::basic_channel::rebind_executor::other]

[indexterm2 boost_asio.indexterm.experimental__basic_channel__rebind_executor.other..other..experimental::basic_channel::rebind_executor] 
The channel type when rebound to the specified executor. 


  typedef basic_channel< Executor1, Traits, Signatures...> other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__basic_channel__rebind_executor [*rebind_executor]]]
    [Rebinds the channel type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__basic_channel.executor_type [*executor_type]]]
    [The type of the executor associated with the channel. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__basic_channel.traits_type [*traits_type]]]
    [The traits type associated with the channel. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__basic_channel.async_receive [*async_receive]]]
    [Asynchronously receive a message. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.async_send [*async_send]]]
    [Asynchronously send a message. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.basic_channel [*basic_channel]] [constructor]]
    [Construct a basic_channel. 
     [hr]
     Construct and open a basic_channel. 
     [hr]
     Move-construct a basic_channel from another. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.cancel [*cancel]]]
    [Cancel all asynchronous operations waiting on the channel. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.capacity [*capacity]]]
    [Get the capacity of the channel's buffer. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.close [*close]]]
    [Close the channel. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.is_open [*is_open]]]
    [Determine whether the channel is open. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.operator_eq_ [*operator=]]]
    [Move-assign a basic_channel from another. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.ready [*ready]]]
    [Determine whether a message can be received without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.reset [*reset]]]
    [Reset the channel to its initial state. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.try_receive [*try_receive]]]
    [Try to receive a message without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.try_send [*try_send]]]
    [Try to send a message without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel.try_send_n [*try_send_n]]]
    [Try to send a number of messages without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_channel._basic_channel [*~basic_channel]] [destructor]]
    [Destructor. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/experimental/basic_channel.hpp]

['Convenience header: ]None


[endsect]



[endsect]

[section:experimental__basic_concurrent_channel experimental::basic_concurrent_channel]

[indexterm1 boost_asio.indexterm.experimental__basic_concurrent_channel..experimental::basic_concurrent_channel]


A channel for messages. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename Traits,
      typename... Signatures>
  class basic_concurrent_channel


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__basic_concurrent_channel__rebind_executor [*rebind_executor]]]
    [Rebinds the channel type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__basic_concurrent_channel.executor_type [*executor_type]]]
    [The type of the executor associated with the channel. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__basic_concurrent_channel.traits_type [*traits_type]]]
    [The traits type associated with the channel. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.async_receive [*async_receive]]]
    [Asynchronously receive a message. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.async_send [*async_send]]]
    [Asynchronously send a message. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.basic_concurrent_channel [*basic_concurrent_channel]] [constructor]]
    [Construct a basic_concurrent_channel. 
     [hr]
     Construct and open a basic_concurrent_channel. 
     [hr]
     Move-construct a basic_concurrent_channel from another. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.cancel [*cancel]]]
    [Cancel all asynchronous operations waiting on the channel. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.capacity [*capacity]]]
    [Get the capacity of the channel's buffer. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.close [*close]]]
    [Close the channel. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.is_open [*is_open]]]
    [Determine whether the channel is open. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.operator_eq_ [*operator=]]]
    [Move-assign a basic_concurrent_channel from another. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.ready [*ready]]]
    [Determine whether a message can be received without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.reset [*reset]]]
    [Reset the channel to its initial state. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.try_receive [*try_receive]]]
    [Try to receive a message without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.try_send [*try_send]]]
    [Try to send a message without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.try_send_n [*try_send_n]]]
    [Try to send a number of messages without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel._basic_concurrent_channel [*~basic_concurrent_channel]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/basic_concurrent_channel.hpp]

['Convenience header: ]None


[section:async_receive experimental::basic_concurrent_channel::async_receive]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.async_receive..async_receive..experimental::basic_concurrent_channel] 
Asynchronously receive a message. 


  template<
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  auto async_receive(
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);



[endsect]



[section:async_send experimental::basic_concurrent_channel::async_send]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.async_send..async_send..experimental::basic_concurrent_channel] 
Asynchronously send a message. 


  template<
      typename... Args,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  auto async_send(
      Args &&... args,
      CompletionToken && token);



[endsect]


[section:basic_concurrent_channel experimental::basic_concurrent_channel::basic_concurrent_channel]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.basic_concurrent_channel..basic_concurrent_channel..experimental::basic_concurrent_channel] 
Construct a [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`]. 


  ``[link boost_asio.reference.experimental__basic_concurrent_channel.basic_concurrent_channel.overload1 basic_concurrent_channel]``(
      const executor_type & ex,
      std::size_t max_buffer_size = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__basic_concurrent_channel.basic_concurrent_channel.overload1 more...]]``


Construct and open a [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`]. 


  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.experimental__basic_concurrent_channel.basic_concurrent_channel.overload2 basic_concurrent_channel]``(
      ExecutionContext & context,
      std::size_t max_buffer_size = 0,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__basic_concurrent_channel.basic_concurrent_channel.overload2 more...]]``


Move-construct a [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`] from another. 


  ``[link boost_asio.reference.experimental__basic_concurrent_channel.basic_concurrent_channel.overload3 basic_concurrent_channel]``(
      basic_concurrent_channel && other);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__basic_concurrent_channel.basic_concurrent_channel.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.experimental__basic_concurrent_channel.basic_concurrent_channel.overload4 basic_concurrent_channel]``(
      basic_concurrent_channel< Executor1, Traits, Signatures...> && other,
      typename constraint< is_convertible< Executor1, Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__basic_concurrent_channel.basic_concurrent_channel.overload4 more...]]``


[section:overload1 experimental::basic_concurrent_channel::basic_concurrent_channel (1 of 4 overloads)]


Construct a [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`]. 


  basic_concurrent_channel(
      const executor_type & ex,
      std::size_t max_buffer_size = 0);


This constructor creates and channel.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the channel will use, by default, to dispatch handlers for any asynchronous operations performed on the channel.]]

[[max_buffer_size][The maximum number of messages that may be buffered in the channel. ]]

]




[endsect]



[section:overload2 experimental::basic_concurrent_channel::basic_concurrent_channel (2 of 4 overloads)]


Construct and open a [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`]. 


  template<
      typename ExecutionContext>
  basic_concurrent_channel(
      ExecutionContext & context,
      std::size_t max_buffer_size = 0,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates and opens a channel.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the channel will use, by default, to dispatch handlers for any asynchronous operations performed on the channel.]]

[[max_buffer_size][The maximum number of messages that may be buffered in the channel. ]]

]




[endsect]



[section:overload3 experimental::basic_concurrent_channel::basic_concurrent_channel (3 of 4 overloads)]


Move-construct a [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`] from another. 


  basic_concurrent_channel(
      basic_concurrent_channel && other);


This constructor moves a channel from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_concurrent_channel(const executor_type&)` constructor. 




[endsect]



[section:overload4 experimental::basic_concurrent_channel::basic_concurrent_channel (4 of 4 overloads)]


Move-construct a [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`] from another. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_concurrent_channel(
      basic_concurrent_channel< Executor1, Traits, Signatures...> && other,
      typename constraint< is_convertible< Executor1, Executor >::value >::type  = 0);


This constructor moves a channel from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_concurrent_channel(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:cancel experimental::basic_concurrent_channel::cancel]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.cancel..cancel..experimental::basic_concurrent_channel] 
Cancel all asynchronous operations waiting on the channel. 


  void cancel();


All outstanding send operations will complete with the error `boost::asio::experimental::error::channel_canceld`. Outstanding receive operations complete with the result as determined by the channel traits. 


[endsect]



[section:capacity experimental::basic_concurrent_channel::capacity]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.capacity..capacity..experimental::basic_concurrent_channel] 
Get the capacity of the channel's buffer. 


  std::size_t capacity();



[endsect]



[section:close experimental::basic_concurrent_channel::close]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.close..close..experimental::basic_concurrent_channel] 
Close the channel. 


  void close();



[endsect]



[section:executor_type experimental::basic_concurrent_channel::executor_type]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.executor_type..executor_type..experimental::basic_concurrent_channel] 
The type of the executor associated with the channel. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/experimental/basic_concurrent_channel.hpp]

['Convenience header: ]None


[endsect]



[section:get_executor experimental::basic_concurrent_channel::get_executor]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.get_executor..get_executor..experimental::basic_concurrent_channel] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:is_open experimental::basic_concurrent_channel::is_open]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.is_open..is_open..experimental::basic_concurrent_channel] 
Determine whether the channel is open. 


  bool is_open() const;



[endsect]


[section:operator_eq_ experimental::basic_concurrent_channel::operator=]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.operator_eq_..operator=..experimental::basic_concurrent_channel] 
Move-assign a [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`] from another. 


  basic_concurrent_channel & ``[link boost_asio.reference.experimental__basic_concurrent_channel.operator_eq_.overload1 operator=]``(
      basic_concurrent_channel && other);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__basic_concurrent_channel.operator_eq_.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_concurrent_channel & >::type ``[link boost_asio.reference.experimental__basic_concurrent_channel.operator_eq_.overload2 operator=]``(
      basic_concurrent_channel< Executor1, Traits, Signatures...> && other);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__basic_concurrent_channel.operator_eq_.overload2 more...]]``


[section:overload1 experimental::basic_concurrent_channel::operator= (1 of 2 overloads)]


Move-assign a [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`] from another. 


  basic_concurrent_channel & operator=(
      basic_concurrent_channel && other);


This assignment operator moves a channel from one object to another. Cancels any outstanding asynchronous operations associated with the target object.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_concurrent_channel(const executor_type&)` constructor. 




[endsect]



[section:overload2 experimental::basic_concurrent_channel::operator= (2 of 2 overloads)]


Move-assign a [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`] from another. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_concurrent_channel & >::type operator=(
      basic_concurrent_channel< Executor1, Traits, Signatures...> && other);


This assignment operator moves a channel from one object to another. Cancels any outstanding asynchronous operations associated with the target object.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.experimental__basic_concurrent_channel `experimental::basic_concurrent_channel`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_concurrent_channel(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:ready experimental::basic_concurrent_channel::ready]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.ready..ready..experimental::basic_concurrent_channel] 
Determine whether a message can be received without blocking. 


  bool ready() const;



[endsect]



[section:reset experimental::basic_concurrent_channel::reset]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.reset..reset..experimental::basic_concurrent_channel] 
Reset the channel to its initial state. 


  void reset();



[endsect]



[section:traits_type experimental::basic_concurrent_channel::traits_type]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.traits_type..traits_type..experimental::basic_concurrent_channel] 
The traits type associated with the channel. 


  typedef Traits::template rebind< Signatures...>::other traits_type;



[heading Requirements]

['Header: ][^boost/asio/experimental/basic_concurrent_channel.hpp]

['Convenience header: ]None


[endsect]



[section:try_receive experimental::basic_concurrent_channel::try_receive]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.try_receive..try_receive..experimental::basic_concurrent_channel] 
Try to receive a message without blocking. 


  template<
      typename ``[link boost_asio.reference.Handler Handler]``>
  bool try_receive(
      Handler && handler);


Fails if the buffer is full and there are no waiting receive operations.


[heading Return Value]
      
`true` on success, `false` on failure. 




[endsect]



[section:try_send experimental::basic_concurrent_channel::try_send]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.try_send..try_send..experimental::basic_concurrent_channel] 
Try to send a message without blocking. 


  template<
      typename... Args>
  bool try_send(
      Args &&... args);


Fails if the buffer is full and there are no waiting receive operations.


[heading Return Value]
      
`true` on success, `false` on failure. 




[endsect]



[section:try_send_n experimental::basic_concurrent_channel::try_send_n]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel.try_send_n..try_send_n..experimental::basic_concurrent_channel] 
Try to send a number of messages without blocking. 


  template<
      typename... Args>
  std::size_t try_send_n(
      std::size_t count,
      Args &&... args);



[heading Return Value]
      
The number of messages that were sent. 




[endsect]



[section:_basic_concurrent_channel experimental::basic_concurrent_channel::~basic_concurrent_channel]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel._basic_concurrent_channel..~basic_concurrent_channel..experimental::basic_concurrent_channel] 
Destructor. 


  ~basic_concurrent_channel();



[endsect]



[endsect]

[section:experimental__basic_concurrent_channel__rebind_executor experimental::basic_concurrent_channel::rebind_executor]

[indexterm1 boost_asio.indexterm.experimental__basic_concurrent_channel__rebind_executor..experimental::basic_concurrent_channel::rebind_executor]


Rebinds the channel type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__basic_concurrent_channel__rebind_executor.other [*other]]]
    [The channel type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/experimental/basic_concurrent_channel.hpp]

['Convenience header: ]None


[section:other experimental::basic_concurrent_channel::rebind_executor::other]

[indexterm2 boost_asio.indexterm.experimental__basic_concurrent_channel__rebind_executor.other..other..experimental::basic_concurrent_channel::rebind_executor] 
The channel type when rebound to the specified executor. 


  typedef basic_concurrent_channel< Executor1, Traits, Signatures...> other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__basic_concurrent_channel__rebind_executor [*rebind_executor]]]
    [Rebinds the channel type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__basic_concurrent_channel.executor_type [*executor_type]]]
    [The type of the executor associated with the channel. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__basic_concurrent_channel.traits_type [*traits_type]]]
    [The traits type associated with the channel. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.async_receive [*async_receive]]]
    [Asynchronously receive a message. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.async_send [*async_send]]]
    [Asynchronously send a message. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.basic_concurrent_channel [*basic_concurrent_channel]] [constructor]]
    [Construct a basic_concurrent_channel. 
     [hr]
     Construct and open a basic_concurrent_channel. 
     [hr]
     Move-construct a basic_concurrent_channel from another. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.cancel [*cancel]]]
    [Cancel all asynchronous operations waiting on the channel. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.capacity [*capacity]]]
    [Get the capacity of the channel's buffer. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.close [*close]]]
    [Close the channel. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.is_open [*is_open]]]
    [Determine whether the channel is open. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.operator_eq_ [*operator=]]]
    [Move-assign a basic_concurrent_channel from another. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.ready [*ready]]]
    [Determine whether a message can be received without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.reset [*reset]]]
    [Reset the channel to its initial state. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.try_receive [*try_receive]]]
    [Try to receive a message without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.try_send [*try_send]]]
    [Try to send a message without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel.try_send_n [*try_send_n]]]
    [Try to send a number of messages without blocking. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__basic_concurrent_channel._basic_concurrent_channel [*~basic_concurrent_channel]] [destructor]]
    [Destructor. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/experimental/basic_concurrent_channel.hpp]

['Convenience header: ]None


[endsect]



[endsect]

[section:experimental__channel_traits experimental::channel_traits]

[indexterm1 boost_asio.indexterm.experimental__channel_traits..experimental::channel_traits]



  template<
      typename... Signatures>
  struct channel_traits


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__channel_traits__container [*container]]]
    [Determine the container for the specified elements. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__channel_traits__rebind [*rebind]]]
    [Rebind the traits to a new set of signatures. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__channel_traits.receive_cancelled_signature [*receive_cancelled_signature]]]
    [The signature of a channel cancellation notification. ]
  
  ]

  [

    [[link boost_asio.reference.experimental__channel_traits.receive_closed_signature [*receive_closed_signature]]]
    [The signature of a channel closed notification. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__channel_traits.invoke_receive_cancelled [*invoke_receive_cancelled]] [static]]
    [Invoke the specified handler with a cancellation notification. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__channel_traits.invoke_receive_closed [*invoke_receive_closed]] [static]]
    [Invoke the specified handler with a closed notification. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/channel_traits.hpp]

['Convenience header: ]None


[section:invoke_receive_cancelled experimental::channel_traits::invoke_receive_cancelled]

[indexterm2 boost_asio.indexterm.experimental__channel_traits.invoke_receive_cancelled..invoke_receive_cancelled..experimental::channel_traits] 
Invoke the specified handler with a cancellation notification. 


  template<
      typename F>
  static void invoke_receive_cancelled(
      F f);



[endsect]



[section:invoke_receive_closed experimental::channel_traits::invoke_receive_closed]

[indexterm2 boost_asio.indexterm.experimental__channel_traits.invoke_receive_closed..invoke_receive_closed..experimental::channel_traits] 
Invoke the specified handler with a closed notification. 


  template<
      typename F>
  static void invoke_receive_closed(
      F f);



[endsect]



[section:receive_cancelled_signature experimental::channel_traits::receive_cancelled_signature]

[indexterm2 boost_asio.indexterm.experimental__channel_traits.receive_cancelled_signature..receive_cancelled_signature..experimental::channel_traits] 
The signature of a channel cancellation notification. 


  typedef void receive_cancelled_signature;



[heading Requirements]

['Header: ][^boost/asio/experimental/channel_traits.hpp]

['Convenience header: ]None


[endsect]



[section:receive_closed_signature experimental::channel_traits::receive_closed_signature]

[indexterm2 boost_asio.indexterm.experimental__channel_traits.receive_closed_signature..receive_closed_signature..experimental::channel_traits] 
The signature of a channel closed notification. 


  typedef void receive_closed_signature;



[heading Requirements]

['Header: ][^boost/asio/experimental/channel_traits.hpp]

['Convenience header: ]None


[endsect]



[endsect]

[section:experimental__channel_traits__container experimental::channel_traits::container]

[indexterm1 boost_asio.indexterm.experimental__channel_traits__container..experimental::channel_traits::container]


Determine the container for the specified elements. 


  template<
      typename Element>
  struct container


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__channel_traits__container.type [*type]]]
    []
  
  ]

]

This nested structure must have a single nested type `other` that aliases a container type for the specified element type. 

[heading Requirements]

['Header: ][^boost/asio/experimental/channel_traits.hpp]

['Convenience header: ]None


[section:type experimental::channel_traits::container::type]

[indexterm2 boost_asio.indexterm.experimental__channel_traits__container.type..type..experimental::channel_traits::container] 

  typedef user_defined type;



[heading Requirements]

['Header: ][^boost/asio/experimental/channel_traits.hpp]

['Convenience header: ]None


[endsect]



[endsect]

[section:experimental__channel_traits__rebind experimental::channel_traits::rebind]

[indexterm1 boost_asio.indexterm.experimental__channel_traits__rebind..experimental::channel_traits::rebind]


Rebind the traits to a new set of signatures. 


  template<
      typename... NewSignatures>
  struct rebind


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__channel_traits__rebind.other [*other]]]
    []
  
  ]

]

This nested structure must have a single nested type `other` that aliases a traits type with the specified set of signatures. 

[heading Requirements]

['Header: ][^boost/asio/experimental/channel_traits.hpp]

['Convenience header: ]None


[section:other experimental::channel_traits::rebind::other]

[indexterm2 boost_asio.indexterm.experimental__channel_traits__rebind.other..other..experimental::channel_traits::rebind] 

  typedef user_defined other;



[heading Requirements]

['Header: ][^boost/asio/experimental/channel_traits.hpp]

['Convenience header: ]None


[endsect]



[endsect]

[section:experimental__co_spawn experimental::co_spawn]

[indexterm1 boost_asio.indexterm.experimental__co_spawn..experimental::co_spawn] 
Spawn a resumable coroutine. 

  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.experimental__co_spawn.overload1 co_spawn]``(
      coro< void, T, Executor > c,
      CompletionToken && token);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__co_spawn.overload1 more...]]``

  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.experimental__co_spawn.overload2 co_spawn]``(
      coro< void(), T, Executor > c,
      CompletionToken && token);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__co_spawn.overload2 more...]]``

  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.experimental__co_spawn.overload3 co_spawn]``(
      coro< void() noexcept, T, Executor > c,
      CompletionToken && token);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__co_spawn.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.experimental__co_spawn.overload4 co_spawn]``(
      coro< void, void, Executor > c,
      CompletionToken && token);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__co_spawn.overload4 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.experimental__co_spawn.overload5 co_spawn]``(
      coro< void(), void, Executor > c,
      CompletionToken && token);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__co_spawn.overload5 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.experimental__co_spawn.overload6 co_spawn]``(
      coro< void() noexcept, void, Executor > c,
      CompletionToken && token);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__co_spawn.overload6 more...]]``

[heading Requirements]

['Header: ][^boost/asio/experimental/co_spawn.hpp]

['Convenience header: ]None


[section:overload1 experimental::co_spawn (1 of 6 overloads)]


Spawn a resumable coroutine. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` co_spawn(
      coro< void, T, Executor > c,
      CompletionToken && token);


This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.


[heading Parameters]
    

[variablelist
  
[[c][The coroutine]]

[[token][The completion token]]

]


[heading Return Value]
      
Implementation defined 




[endsect]



[section:overload2 experimental::co_spawn (2 of 6 overloads)]


Spawn a resumable coroutine. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` co_spawn(
      coro< void(), T, Executor > c,
      CompletionToken && token);


This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.


[heading Parameters]
    

[variablelist
  
[[c][The coroutine]]

[[token][The completion token]]

]


[heading Return Value]
      
Implementation defined 




[endsect]



[section:overload3 experimental::co_spawn (3 of 6 overloads)]


Spawn a resumable coroutine. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` co_spawn(
      coro< void() noexcept, T, Executor > c,
      CompletionToken && token);


This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.


[heading Parameters]
    

[variablelist
  
[[c][The coroutine]]

[[token][The completion token]]

]


[heading Return Value]
      
Implementation defined 




[endsect]



[section:overload4 experimental::co_spawn (4 of 6 overloads)]


Spawn a resumable coroutine. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` co_spawn(
      coro< void, void, Executor > c,
      CompletionToken && token);


This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.


[heading Parameters]
    

[variablelist
  
[[c][The coroutine]]

[[token][The completion token]]

]


[heading Return Value]
      
Implementation defined 




[endsect]



[section:overload5 experimental::co_spawn (5 of 6 overloads)]


Spawn a resumable coroutine. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` co_spawn(
      coro< void(), void, Executor > c,
      CompletionToken && token);


This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.


[heading Parameters]
    

[variablelist
  
[[c][The coroutine]]

[[token][The completion token]]

]


[heading Return Value]
      
Implementation defined 




[endsect]



[section:overload6 experimental::co_spawn (6 of 6 overloads)]


Spawn a resumable coroutine. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` co_spawn(
      coro< void() noexcept, void, Executor > c,
      CompletionToken && token);


This function spawns the coroutine for execution on its executor. It binds the lifetime of the coroutine to the executor.


[heading Parameters]
    

[variablelist
  
[[c][The coroutine]]

[[token][The completion token]]

]


[heading Return Value]
      
Implementation defined 




[endsect]


[endsect]

[section:experimental__coro experimental::coro]

[indexterm1 boost_asio.indexterm.experimental__coro..experimental::coro]


The main type of a resumable coroutine. 


  template<
      typename Yield = void,
      typename Return = void,
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  struct coro


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__coro.async_resume [*async_resume]]]
    [Resume the coroutine. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__coro.coro [*coro]] [constructor]]
    [The default constructor, gives an invalid coroutine. 
     [hr]
     Move constructor. 
     [hr]
     ]
  ]
  
  [
    [[link boost_asio.reference.experimental__coro.get_executor [*get_executor]]]
    [Get the used executor. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__coro.is_open [*is_open]]]
    [Check whether the coroutine is open, i.e. can be resumed. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__coro.operator_bool [*operator bool]]]
    [Check whether the coroutine is open, i.e. can be resumed. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__coro.operator_co_await [*operator co_await]]]
    [Operator used for coroutines without input value. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__coro.operator_lp__rp_ [*operator()]]]
    [Operator used for coroutines with input value. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__coro.operator_eq_ [*operator=]]]
    [Move assignment. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__coro._coro [*~coro]] [destructor]]
    [Destructor. Destroys the coroutine, if it holds a valid one. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__coro.is_noexcept [*is_noexcept]] [static]]
    [Whether or not the coroutine is noexcept. ]
  ]

]

Template parameter `Yield` specifies type or signature used by co\_yield, `Return` specifies the type used for co\_return, and `Executor` specifies the underlying executor type. 

[heading Requirements]

['Header: ][^boost/asio/experimental/coro.hpp]

['Convenience header: ]None

[section:async_resume experimental::coro::async_resume]

[indexterm2 boost_asio.indexterm.experimental__coro.async_resume..async_resume..experimental::coro] 
Resume the coroutine. 


  template<
      typename CompletionToken>
  requires std::is_void_v< input_type > auto ``[link boost_asio.reference.experimental__coro.async_resume.overload1 async_resume]``(
      CompletionToken && token);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__coro.async_resume.overload1 more...]]``

  template<
      typename CompletionToken,
      detail::convertible_to< input_type > T>
  auto ``[link boost_asio.reference.experimental__coro.async_resume.overload2 async_resume]``(
      T && ip,
      CompletionToken && token);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__coro.async_resume.overload2 more...]]``


[section:overload1 experimental::coro::async_resume (1 of 2 overloads)]


Resume the coroutine. 


  template<
      typename CompletionToken>
  requires std::is_void_v< input_type > auto async_resume(
      CompletionToken && token);



[heading Parameters]
    

[variablelist
  
[[token][The completion token of the async resume.]]

]


[heading Attention]
      
Calling an invalid coroutine with a noexcept signature is undefined behaviour.


[heading Remarks]
      
This overload is only available for coroutines without an input value. 




[endsect]



[section:overload2 experimental::coro::async_resume (2 of 2 overloads)]


Resume the coroutine. 


  template<
      typename CompletionToken,
      detail::convertible_to< input_type > T>
  auto async_resume(
      T && ip,
      CompletionToken && token);



[heading Parameters]
    

[variablelist
  
[[token][The completion token of the async resume.]]

]


[heading Attention]
      
Calling an invalid coroutine with a noexcept signature is undefined behaviour.


[heading Remarks]
      
This overload is only available for coroutines with an input value. 




[endsect]


[endsect]

[section:coro experimental::coro::coro]

[indexterm2 boost_asio.indexterm.experimental__coro.coro..coro..experimental::coro] 
The default constructor, gives an invalid coroutine. 


  ``[link boost_asio.reference.experimental__coro.coro.overload1 coro]``();
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__coro.coro.overload1 more...]]``


Move constructor. 


  ``[link boost_asio.reference.experimental__coro.coro.overload2 coro]``(
      coro && lhs);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__coro.coro.overload2 more...]]``



  ``[link boost_asio.reference.experimental__coro.coro.overload3 coro]``(
      const coro & );
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__coro.coro.overload3 more...]]``


[section:overload1 experimental::coro::coro (1 of 3 overloads)]


The default constructor, gives an invalid coroutine. 


  coro();



[endsect]



[section:overload2 experimental::coro::coro (2 of 3 overloads)]


Move constructor. 


  coro(
      coro && lhs);



[endsect]



[section:overload3 experimental::coro::coro (3 of 3 overloads)]



  coro(
      const coro & );



[endsect]


[endsect]


[section:get_executor experimental::coro::get_executor]

[indexterm2 boost_asio.indexterm.experimental__coro.get_executor..get_executor..experimental::coro] 
Get the used executor. 


  executor_type get_executor() const;



[endsect]



[section:is_noexcept experimental::coro::is_noexcept]

[indexterm2 boost_asio.indexterm.experimental__coro.is_noexcept..is_noexcept..experimental::coro] 
Whether or not the coroutine is noexcept. 


  static constexpr bool is_noexcept = traits::is_noexcept;



[endsect]



[section:is_open experimental::coro::is_open]

[indexterm2 boost_asio.indexterm.experimental__coro.is_open..is_open..experimental::coro] 
Check whether the coroutine is open, i.e. can be resumed. 


  bool is_open() const;



[endsect]



[section:operator_bool experimental::coro::operator bool]

[indexterm2 boost_asio.indexterm.experimental__coro.operator_bool..operator bool..experimental::coro] 
Check whether the coroutine is open, i.e. can be resumed. 


  operator bool() const;



[endsect]



[section:operator_co_await experimental::coro::operator co_await]

[indexterm2 boost_asio.indexterm.experimental__coro.operator_co_await..operator co_await..experimental::coro] 
Operator used for coroutines without input value. 


  auto operator co_await();



[endsect]



[section:operator_lp__rp_ experimental::coro::operator()]

[indexterm2 boost_asio.indexterm.experimental__coro.operator_lp__rp_..operator()..experimental::coro] 
Operator used for coroutines with input value. 


  template<
      detail::convertible_to< input_type > T>
  auto operator()(
      T && ip);



[heading Parameters]
    

[variablelist
  
[[ip][The input value]]

]


[heading Return Value]
      
An awaitable handle.



   coro<void> push_values(coro<double(int)> c)
   {
      std::optional<double> res = co_await c(42);
   }





[endsect]


[section:operator_eq_ experimental::coro::operator=]

[indexterm2 boost_asio.indexterm.experimental__coro.operator_eq_..operator=..experimental::coro] 
Move assignment. 


  coro & ``[link boost_asio.reference.experimental__coro.operator_eq_.overload1 operator=]``(
      coro && lhs);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__coro.operator_eq_.overload1 more...]]``

  coro & ``[link boost_asio.reference.experimental__coro.operator_eq_.overload2 operator=]``(
      const coro & );
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__coro.operator_eq_.overload2 more...]]``


[section:overload1 experimental::coro::operator= (1 of 2 overloads)]


Move assignment. 


  coro & operator=(
      coro && lhs);



[endsect]



[section:overload2 experimental::coro::operator= (2 of 2 overloads)]



  coro & operator=(
      const coro & );



[endsect]


[endsect]


[section:_coro experimental::coro::~coro]

[indexterm2 boost_asio.indexterm.experimental__coro._coro..~coro..experimental::coro] 
Destructor. Destroys the coroutine, if it holds a valid one. 


  ~coro();



[heading Remarks]
      
This does not cancel an active coroutine. Destructing a resumable coroutine, i.e. one with a call to async\_resume that has not completed, is undefined behaviour. 




[endsect]



[endsect]

[section:experimental__coro_traits experimental::coro_traits]

[indexterm1 boost_asio.indexterm.experimental__coro_traits..experimental::coro_traits]


The traits describing the resumable coroutine behaviour. 


  template<
      typename Yield,
      typename Return,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  struct coro_traits


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__coro_traits.is_noexcept [*is_noexcept]] [static]]
    [Whether or not the coroutine is noexcept. ]
  ]

]

Template parameter `Yield` specifies type or signature used by co\_yield, `Return` specifies the type used for co\_return, and `Executor` specifies the underlying executor type. 

[heading Requirements]

['Header: ][^boost/asio/experimental/coro_traits.hpp]

['Convenience header: ]None


[section:is_noexcept experimental::coro_traits::is_noexcept]

[indexterm2 boost_asio.indexterm.experimental__coro_traits.is_noexcept..is_noexcept..experimental::coro_traits] 
Whether or not the coroutine is noexcept. 


  static constexpr bool is_noexcept = argument_dependent;



[endsect]



[endsect]


[section:experimental__deferred experimental::deferred]

[indexterm1 boost_asio.indexterm.experimental__deferred..experimental::deferred] 
A special value, similar to std::nothrow. 


  constexpr deferred_t deferred;


See the documentation for [link boost_asio.reference.experimental__deferred_t `experimental::deferred_t`] for a usage example. 

[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[endsect]


[section:experimental__deferred_async_operation experimental::deferred_async_operation]

[indexterm1 boost_asio.indexterm.experimental__deferred_async_operation..experimental::deferred_async_operation]


Encapsulates a deferred asynchronous operation. 


  template<
      typename Signature,
      typename Initiation,
      typename... InitArgs>
  class deferred_async_operation


[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[endsect]

[section:experimental__deferred_conditional experimental::deferred_conditional]

[indexterm1 boost_asio.indexterm.experimental__deferred_conditional..experimental::deferred_conditional]


Used to represent a deferred conditional branch. 


  template<
      typename OnTrue = deferred_noop,
      typename OnFalse = deferred_noop>
  class deferred_conditional


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__deferred_conditional.deferred_conditional [*deferred_conditional]] [constructor]]
    [Construct a deferred conditional with the value to determine which branch will be executed. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__deferred_conditional.operator_lp__rp_ [*operator()]]]
    [Invoke the conditional branch bsaed on the stored alue. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__deferred_conditional.otherwise [*otherwise]]]
    [Set the false branch of the conditional. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__deferred_conditional.then [*then]]]
    [Set the true branch of the conditional. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[section:deferred_conditional experimental::deferred_conditional::deferred_conditional]

[indexterm2 boost_asio.indexterm.experimental__deferred_conditional.deferred_conditional..deferred_conditional..experimental::deferred_conditional] 
Construct a deferred conditional with the value to determine which branch will be executed. 


  constexpr deferred_conditional(
      bool b);



[endsect]



[section:operator_lp__rp_ experimental::deferred_conditional::operator()]

[indexterm2 boost_asio.indexterm.experimental__deferred_conditional.operator_lp__rp_..operator()..experimental::deferred_conditional] 
Invoke the conditional branch bsaed on the stored alue. 


  template<
      typename... Args>
  auto operator()(
      Args &&... args);



[endsect]



[section:otherwise experimental::deferred_conditional::otherwise]

[indexterm2 boost_asio.indexterm.experimental__deferred_conditional.otherwise..otherwise..experimental::deferred_conditional] 
Set the false branch of the conditional. 


  template<
      typename T>
  deferred_conditional< OnTrue, T > otherwise(
      T on_false,
      typename constraint< is_deferred< T >::value >::type *  = 0,
      typename constraint< !is_same< typename conditional< true, OnTrue, T >::type, deferred_noop >::value >::type *  = 0,
      typename constraint< is_same< typename conditional< true, OnFalse, T >::type, deferred_noop >::value >::type *  = 0);



[endsect]



[section:then experimental::deferred_conditional::then]

[indexterm2 boost_asio.indexterm.experimental__deferred_conditional.then..then..experimental::deferred_conditional] 
Set the true branch of the conditional. 


  template<
      typename T>
  deferred_conditional< T, OnFalse > then(
      T on_true,
      typename constraint< is_deferred< T >::value >::type *  = 0,
      typename constraint< is_same< typename conditional< true, OnTrue, T >::type, deferred_noop >::value >::type *  = 0);



[endsect]



[endsect]

[section:experimental__deferred_function experimental::deferred_function]

[indexterm1 boost_asio.indexterm.experimental__deferred_function..experimental::deferred_function]


Wraps a function object so that it may be used as an element in a deferred composition. 


  template<
      typename Function>
  class deferred_function


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__deferred_function.decltype [*decltype]]]
    []
  ]
  
  [
    [[link boost_asio.reference.experimental__deferred_function.deferred_function [*deferred_function]] [constructor]]
    [Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__deferred_function.function_ [*function_]]]
    []
  ]

]

[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[section:decltype experimental::deferred_function::decltype]

[indexterm2 boost_asio.indexterm.experimental__deferred_function.decltype..decltype..experimental::deferred_function] 

  template<
      typename... Args>
  decltype(
      auto );



[endsect]



[section:deferred_function experimental::deferred_function::deferred_function]

[indexterm2 boost_asio.indexterm.experimental__deferred_function.deferred_function..deferred_function..experimental::deferred_function] 
Constructor. 


  template<
      typename F>
  constexpr deferred_function(
      deferred_init_tag ,
      F && function);



[endsect]



[section:function_ experimental::deferred_function::function_]

[indexterm2 boost_asio.indexterm.experimental__deferred_function.function_..function_..experimental::deferred_function] 

  Function function_;



[endsect]



[endsect]

[section:experimental__deferred_init_tag experimental::deferred_init_tag]

[indexterm1 boost_asio.indexterm.experimental__deferred_init_tag..experimental::deferred_init_tag]


Tag type to disambiguate deferred constructors. 


  struct deferred_init_tag


[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[endsect]

[section:experimental__deferred_noop experimental::deferred_noop]

[indexterm1 boost_asio.indexterm.experimental__deferred_noop..experimental::deferred_noop]


Used to represent an empty deferred action. 


  struct deferred_noop


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__deferred_noop.operator_lp__rp_ [*operator()]]]
    [No effect. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[section:operator_lp__rp_ experimental::deferred_noop::operator()]

[indexterm2 boost_asio.indexterm.experimental__deferred_noop.operator_lp__rp_..operator()..experimental::deferred_noop] 
No effect. 


  template<
      typename... Args>
  void operator()(
      Args && ...);



[endsect]



[endsect]

[section:experimental__deferred_sequence experimental::deferred_sequence]

[indexterm1 boost_asio.indexterm.experimental__deferred_sequence..experimental::deferred_sequence]


Defines a link between two consecutive operations in a sequence. 


  template<
      typename Head,
      typename Tail>
  class deferred_sequence


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__deferred_sequence.decltype [*decltype]]]
    []
  ]
  
  [
    [[link boost_asio.reference.experimental__deferred_sequence.deferred_sequence [*deferred_sequence]] [constructor]]
    []
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[section:decltype experimental::deferred_sequence::decltype]

[indexterm2 boost_asio.indexterm.experimental__deferred_sequence.decltype..decltype..experimental::deferred_sequence] 

  template<
      typename CompletionToken>
  decltype(
      auto );



[endsect]



[section:deferred_sequence experimental::deferred_sequence::deferred_sequence]

[indexterm2 boost_asio.indexterm.experimental__deferred_sequence.deferred_sequence..deferred_sequence..experimental::deferred_sequence] 

  template<
      typename H,
      typename T>
  constexpr deferred_sequence(
      deferred_init_tag ,
      H && head,
      T && tail);



[endsect]



[endsect]

[section:experimental__deferred_sequence__initiate experimental::deferred_sequence::initiate]

[indexterm1 boost_asio.indexterm.experimental__deferred_sequence__initiate..experimental::deferred_sequence::initiate]



  struct initiate


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__deferred_sequence__initiate.operator_lp__rp_ [*operator()]]]
    []
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[section:operator_lp__rp_ experimental::deferred_sequence::initiate::operator()]

[indexterm2 boost_asio.indexterm.experimental__deferred_sequence__initiate.operator_lp__rp_..operator()..experimental::deferred_sequence::initiate] 

  template<
      typename ``[link boost_asio.reference.Handler Handler]``>
  void operator()(
      Handler && handler,
      Head head,
      Tail && tail);



[endsect]



[endsect]

[section:experimental__deferred_t experimental::deferred_t]

[indexterm1 boost_asio.indexterm.experimental__deferred_t..experimental::deferred_t]


Class used to specify that an asynchronous operation should return a function object to lazily launch the operation. 


  class deferred_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__deferred_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the deferred_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__deferred_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use deferred_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__deferred_t.deferred_t [*deferred_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__deferred_t.operator_lp__rp_ [*operator()]]]
    [Creates a new deferred from a function. 
     [hr]
     Passes through anything that is already deferred. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__deferred_t.values [*values]] [static]]
    [Returns a deferred operation that returns the provided values. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__deferred_t.when [*when]] [static]]
    [Creates a conditional object for branching deferred operations. ]
  ]
  
]

The [link boost_asio.reference.experimental__deferred_t `experimental::deferred_t`] class is used to indicate that an asynchronous operation should return a function object which is itself an initiation function. A [link boost_asio.reference.experimental__deferred_t `experimental::deferred_t`] object may be passed as a completion token to an asynchronous operation, typically using the special value `boost::asio::deferred`. For example:



   auto my_sender
     = my_socket.async_read_some(my_buffer,
         boost::asio::experimental::deferred); 




The initiating function (async\_read\_some in the above example) returns a function object that will lazily initiate the operation. 

[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[section:as_default_on experimental::deferred_t::as_default_on]

[indexterm2 boost_asio.indexterm.experimental__deferred_t.as_default_on..as_default_on..experimental::deferred_t] 
Function helper to adapt an I/O object to use `deferred_t` as its default completion token type. 


  template<
      typename T>
  static decay< T >::type::template rebind_executor< executor_with_default< typename decay< T >::type::executor_type > >::other as_default_on(
      T && object);



[endsect]



[section:deferred_t experimental::deferred_t::deferred_t]

[indexterm2 boost_asio.indexterm.experimental__deferred_t.deferred_t..deferred_t..experimental::deferred_t] 
Default constructor. 


  constexpr deferred_t();



[endsect]


[section:operator_lp__rp_ experimental::deferred_t::operator()]

[indexterm2 boost_asio.indexterm.experimental__deferred_t.operator_lp__rp_..operator()..experimental::deferred_t] 
Creates a new deferred from a function. 


  template<
      typename Function>
  constraint< !is_deferred< typename decay< Function >::type >::value, deferred_function< typename decay< Function >::type > >::type ``[link boost_asio.reference.experimental__deferred_t.operator_lp__rp_.overload1 operator()]``(
      Function && function) const;
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__deferred_t.operator_lp__rp_.overload1 more...]]``


Passes through anything that is already deferred. 


  template<
      typename T>
  constraint< is_deferred< typename decay< T >::type >::value, typename decay< T >::type >::type ``[link boost_asio.reference.experimental__deferred_t.operator_lp__rp_.overload2 operator()]``(
      T && t) const;
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__deferred_t.operator_lp__rp_.overload2 more...]]``


[section:overload1 experimental::deferred_t::operator() (1 of 2 overloads)]


Creates a new deferred from a function. 


  template<
      typename Function>
  constraint< !is_deferred< typename decay< Function >::type >::value, deferred_function< typename decay< Function >::type > >::type operator()(
      Function && function) const;



[endsect]



[section:overload2 experimental::deferred_t::operator() (2 of 2 overloads)]


Passes through anything that is already deferred. 


  template<
      typename T>
  constraint< is_deferred< typename decay< T >::type >::value, typename decay< T >::type >::type operator()(
      T && t) const;



[endsect]


[endsect]


[section:values experimental::deferred_t::values]

[indexterm2 boost_asio.indexterm.experimental__deferred_t.values..values..experimental::deferred_t] 
Returns a deferred operation that returns the provided values. 


  template<
      typename... Args>
  static constexpr deferred_values< typename decay< Args >::type...> values(
      Args &&... args);



[endsect]



[section:when experimental::deferred_t::when]

[indexterm2 boost_asio.indexterm.experimental__deferred_t.when..when..experimental::deferred_t] 
Creates a conditional object for branching deferred operations. 


  static constexpr deferred_conditional when(
      bool b);



[endsect]



[endsect]

[section:experimental__deferred_t__executor_with_default experimental::deferred_t::executor_with_default]

[indexterm1 boost_asio.indexterm.experimental__deferred_t__executor_with_default..experimental::deferred_t::executor_with_default]


Adapts an executor to add the `deferred_t` completion token as the default. 


  template<
      typename ``[link boost_asio.reference.Executor1 InnerExecutor]``>
  struct executor_with_default


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__deferred_t__executor_with_default.default_completion_token_type [*default_completion_token_type]]]
    [Specify deferred_t as the default completion token type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__deferred_t__executor_with_default.executor_with_default [*executor_with_default]] [constructor]]
    [Construct the adapted executor from the inner executor type. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[section:default_completion_token_type experimental::deferred_t::executor_with_default::default_completion_token_type]

[indexterm2 boost_asio.indexterm.experimental__deferred_t__executor_with_default.default_completion_token_type..default_completion_token_type..experimental::deferred_t::executor_with_default] 
Specify `deferred_t` as the default completion token type. 


  typedef deferred_t default_completion_token_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__deferred_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the deferred_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__deferred_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use deferred_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__deferred_t.deferred_t [*deferred_t]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__deferred_t.operator_lp__rp_ [*operator()]]]
    [Creates a new deferred from a function. 
     [hr]
     Passes through anything that is already deferred. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__deferred_t.values [*values]] [static]]
    [Returns a deferred operation that returns the provided values. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__deferred_t.when [*when]] [static]]
    [Creates a conditional object for branching deferred operations. ]
  ]
  
]

The [link boost_asio.reference.experimental__deferred_t `experimental::deferred_t`] class is used to indicate that an asynchronous operation should return a function object which is itself an initiation function. A [link boost_asio.reference.experimental__deferred_t `experimental::deferred_t`] object may be passed as a completion token to an asynchronous operation, typically using the special value `boost::asio::deferred`. For example:



   auto my_sender
     = my_socket.async_read_some(my_buffer,
         boost::asio::experimental::deferred); 




The initiating function (async\_read\_some in the above example) returns a function object that will lazily initiate the operation. 


[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[endsect]



[section:executor_with_default experimental::deferred_t::executor_with_default::executor_with_default]

[indexterm2 boost_asio.indexterm.experimental__deferred_t__executor_with_default.executor_with_default..executor_with_default..experimental::deferred_t::executor_with_default] 
Construct the adapted executor from the inner executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 InnerExecutor1]``>
  executor_with_default(
      const InnerExecutor1 & ex,
      typename constraint< conditional< !is_same< InnerExecutor1, executor_with_default >::value, is_convertible< InnerExecutor1, InnerExecutor >, false_type >::type::value >::type  = 0);



[endsect]



[endsect]

[section:experimental__deferred_values experimental::deferred_values]

[indexterm1 boost_asio.indexterm.experimental__deferred_values..experimental::deferred_values]


Encapsulates deferred values. 


  template<
      typename... Values>
  class deferred_values


[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[endsect]

[section:experimental__deferred_values__initiate experimental::deferred_values::initiate]

[indexterm1 boost_asio.indexterm.experimental__deferred_values__initiate..experimental::deferred_values::initiate]



  struct initiate


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__deferred_values__initiate.operator_lp__rp_ [*operator()]]]
    []
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[section:operator_lp__rp_ experimental::deferred_values::initiate::operator()]

[indexterm2 boost_asio.indexterm.experimental__deferred_values__initiate.operator_lp__rp_..operator()..experimental::deferred_values::initiate] 

  template<
      typename ``[link boost_asio.reference.Handler Handler]``,
      typename... V>
  void operator()(
      Handler handler,
      V &&... values);



[endsect]



[endsect]


[section:experimental__error__channel_category experimental::error::channel_category]

[indexterm1 boost_asio.indexterm.experimental__error__channel_category..experimental::error::channel_category] 

  static const boost::system::error_category & channel_category = boost::asio::experimental::error::get_channel_category();


[heading Requirements]

['Header: ][^boost/asio/experimental/channel_error.hpp]

['Convenience header: ]None


[endsect]



[section:experimental__error__channel_errors experimental::error::channel_errors]

[indexterm1 boost_asio.indexterm.experimental__error__channel_errors..experimental::error::channel_errors] 
  enum channel_errors

[indexterm2 boost_asio.indexterm.experimental__error__channel_errors.channel_closed..channel_closed..experimental::error::channel_errors]
[indexterm2 boost_asio.indexterm.experimental__error__channel_errors.channel_cancelled..channel_cancelled..experimental::error::channel_errors]

[heading Values]
[variablelist

  [
    [channel_closed]
    [The channel was closed. ]
  ]

  [
    [channel_cancelled]
    [The channel was cancelled. ]
  ]

]


[heading Requirements]

['Header: ][^boost/asio/experimental/channel_error.hpp]

['Convenience header: ]None


[endsect]



[section:experimental__error__get_channel_category experimental::error::get_channel_category]

[indexterm1 boost_asio.indexterm.experimental__error__get_channel_category..experimental::error::get_channel_category] 

  const boost::system::error_category & get_channel_category();


[heading Requirements]

['Header: ][^boost/asio/experimental/channel_error.hpp]

['Convenience header: ]None


[endsect]



[section:experimental__error__make_error_code experimental::error::make_error_code]

[indexterm1 boost_asio.indexterm.experimental__error__make_error_code..experimental::error::make_error_code] 

  boost::system::error_code make_error_code(
      channel_errors e);


[heading Requirements]

['Header: ][^boost/asio/experimental/channel_error.hpp]

['Convenience header: ]None


[endsect]


[section:experimental__is_deferred experimental::is_deferred]

[indexterm1 boost_asio.indexterm.experimental__is_deferred..experimental::is_deferred]


Trait for detecting objects that are usable as deferred operations. 


  template<
      typename T>
  struct is_deferred :
    public false_type


[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[endsect]

[section:experimental__is_promise experimental::is_promise]

[indexterm1 boost_asio.indexterm.experimental__is_promise..experimental::is_promise]



  template<
      typename T>
  struct is_promise


[heading Requirements]

['Header: ][^boost/asio/experimental/promise.hpp]

['Convenience header: ]None


[endsect]

[section:experimental__is_promise_lt__promise_lt__Ts_ellipsis__gt__gt_ experimental::is_promise< promise< Ts...>>]

[indexterm1 boost_asio.indexterm.experimental__is_promise_lt__promise_lt__Ts_ellipsis__gt__gt_..experimental::is_promise< promise< Ts\.\.\.>>]



  template<
      typename... Ts>
  struct is_promise< promise< Ts...>>


[heading Requirements]

['Header: ][^boost/asio/experimental/promise.hpp]

['Convenience header: ]None


[endsect]


[section:experimental__is_promise_c experimental::is_promise_c]

[indexterm1 boost_asio.indexterm.experimental__is_promise_c..experimental::is_promise_c] 

  concept is_promise_c =is_promise_v<std::remove_reference_t<T>>;


[heading Requirements]

['Header: ][^boost/asio/experimental/promise.hpp]

['Convenience header: ]None


[endsect]



[section:experimental__is_promise_v experimental::is_promise_v]

[indexterm1 boost_asio.indexterm.experimental__is_promise_v..experimental::is_promise_v] 

  constexpr bool is_promise_v =is_promise<T>::value;


[heading Requirements]

['Header: ][^boost/asio/experimental/promise.hpp]

['Convenience header: ]None


[endsect]



[section:experimental__make_parallel_group experimental::make_parallel_group]

[indexterm1 boost_asio.indexterm.experimental__make_parallel_group..experimental::make_parallel_group] 
Create a group of operations that may be launched in parallel. 


  template<
      typename... Ops>
  parallel_group< Ops...> make_parallel_group(
      Ops... ops);


For example: 

   boost::asio::experimental::make_parallel_group(
      [&](auto token)
      {
        return in.async_read_some(boost::asio::buffer(data), token);
      },
      [&](auto token)
      {
        return timer.async_wait(token);
      }
    ).async_wait(
      boost::asio::experimental::wait_for_all(),
      [](
          std::array<std::size_t, 2> completion_order,
          boost::system::error_code ec1, std::size_t n1,
          boost::system::error_code ec2
      )
      {
        switch (completion_order[0])
        {
        case 0:
          {
            std::cout << "descriptor finished: " << ec1 << ", " << n1 << "\n";
          }
          break;
        case 1:
          {
            std::cout << "timer finished: " << ec2 << "\n";
          }
          break;
        }
      }
    );




[heading Requirements]

['Header: ][^boost/asio/experimental/parallel_group.hpp]

['Convenience header: ]None


[endsect]



[section:experimental__operator_pipe_ experimental::operator|]

[indexterm1 boost_asio.indexterm.experimental__operator_pipe_..experimental::operator|] 
Pipe operator used to chain deferred operations. 


  template<
      typename Head,
      typename Tail>
  auto operator|(
      Head head,
      Tail && tail) const;


[heading Requirements]

['Header: ][^boost/asio/experimental/deferred.hpp]

['Convenience header: ]None


[endsect]


[section:experimental__parallel_group experimental::parallel_group]

[indexterm1 boost_asio.indexterm.experimental__parallel_group..experimental::parallel_group]


A group of asynchronous operations that may be launched in parallel. 


  template<
      typename... Ops>
  class parallel_group


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__parallel_group.signature [*signature]]]
    [The completion signature for the group of operations. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__parallel_group.async_wait [*async_wait]]]
    [Initiate an asynchronous wait for the group of operations. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__parallel_group.parallel_group [*parallel_group]] [constructor]]
    [Constructor. ]
  ]
  
]

See the documentation for [link boost_asio.reference.experimental__make_parallel_group `experimental::make_parallel_group`] for a usage example. 

[heading Requirements]

['Header: ][^boost/asio/experimental/parallel_group.hpp]

['Convenience header: ]None


[section:async_wait experimental::parallel_group::async_wait]

[indexterm2 boost_asio.indexterm.experimental__parallel_group.async_wait..async_wait..experimental::parallel_group] 
Initiate an asynchronous wait for the group of operations. 


  template<
      typename CancellationCondition,
      typename CompletionToken>
  auto async_wait(
      CancellationCondition cancellation_condition,
      CompletionToken && token);


Launches the group and asynchronously waits for completion.


[heading Parameters]
    

[variablelist
  
[[cancellation_condition][A function object, called on completion of an operation within the group, that is used to determine whether to cancel the remaining operations. The function object is passed the arguments of the completed operation's handler. To trigger cancellation of the remaining operations, it must return a [link boost_asio.reference.cancellation_type `cancellation_type`] value other than `boost::asio::cancellation_type::none`.]]

[[token][A completion token whose signature is comprised of a `std::array<std::size_t, N>` indicating the completion order of the operations, followed by all operations' completion handler arguments.]]

]

The library provides the following `cancellation_condition` types:


* [link boost_asio.reference.experimental__wait_for_all `experimental::wait_for_all`] 

* [link boost_asio.reference.experimental__wait_for_one `experimental::wait_for_one`] 

* [link boost_asio.reference.experimental__wait_for_one_error `experimental::wait_for_one_error`] 

* [link boost_asio.reference.experimental__wait_for_one_success `experimental::wait_for_one_success`] 




[endsect]



[section:parallel_group experimental::parallel_group::parallel_group]

[indexterm2 boost_asio.indexterm.experimental__parallel_group.parallel_group..parallel_group..experimental::parallel_group] 
Constructor. 


  parallel_group(
      Ops... ops);



[endsect]



[section:signature experimental::parallel_group::signature]

[indexterm2 boost_asio.indexterm.experimental__parallel_group.signature..signature..experimental::parallel_group] 
The completion signature for the group of operations. 


  typedef detail::parallel_group_signature< sizeof...(Ops), typename detail::parallel_op_signature< Ops >::type...>::type signature;



[heading Requirements]

['Header: ][^boost/asio/experimental/parallel_group.hpp]

['Convenience header: ]None


[endsect]



[endsect]


[section:experimental__prepend experimental::prepend]

[indexterm1 boost_asio.indexterm.experimental__prepend..experimental::prepend] 
Completion token type used to specify that the completion handler arguments should be passed additional values before the results of the operation. 


  template<
      typename CompletionToken,
      typename... Values>
  constexpr prepend_t< typename decay< CompletionToken >::type, typename decay< Values >::type...> prepend(
      CompletionToken && completion_token,
      Values &&... values);


[heading Requirements]

['Header: ][^boost/asio/experimental/prepend.hpp]

['Convenience header: ]None


[endsect]


[section:experimental__prepend_t experimental::prepend_t]

[indexterm1 boost_asio.indexterm.experimental__prepend_t..experimental::prepend_t]


Completion token type used to specify that the completion handler arguments should be passed additional values before the results of the operation. 


  template<
      typename CompletionToken,
      typename... Values>
  class prepend_t


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__prepend_t.prepend_t [*prepend_t]] [constructor]]
    [Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__prepend_t.token_ [*token_]]]
    []
  ]

  [
    [[link boost_asio.reference.experimental__prepend_t.values_ [*values_]]]
    []
  ]

]

[heading Requirements]

['Header: ][^boost/asio/experimental/prepend.hpp]

['Convenience header: ]None


[section:prepend_t experimental::prepend_t::prepend_t]

[indexterm2 boost_asio.indexterm.experimental__prepend_t.prepend_t..prepend_t..experimental::prepend_t] 
Constructor. 


  template<
      typename T,
      typename... V>
  constexpr prepend_t(
      T && completion_token,
      V &&... values);



[endsect]



[section:token_ experimental::prepend_t::token_]

[indexterm2 boost_asio.indexterm.experimental__prepend_t.token_..token_..experimental::prepend_t] 

  CompletionToken token_;



[endsect]



[section:values_ experimental::prepend_t::values_]

[indexterm2 boost_asio.indexterm.experimental__prepend_t.values_..values_..experimental::prepend_t] 

  std::tuple< Values...> values_;



[endsect]



[endsect]

[section:experimental__promise experimental::promise]

[indexterm1 boost_asio.indexterm.experimental__promise..experimental::promise]


The primary template is not defined. 


  template<
      typename Signature = void(),
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  struct promise


[heading Requirements]

['Header: ][^boost/asio/experimental/promise.hpp]

['Convenience header: ]None


[endsect]

[section:experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_ experimental::promise< void(Ts...), Executor >]

[indexterm1 boost_asio.indexterm.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_..experimental::promise< void(Ts\.\.\.), Executor >]



  template<
      typename... Ts,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  struct promise< void(Ts...), Executor >


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.all [*all]] [static]]
    []
  ]
  
  [
    [[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.async_wait [*async_wait]]]
    []
  ]
  
  [
    [[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.cancel [*cancel]]]
    []
  ]
  
  [
    [[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.complete [*complete]]]
    []
  ]
  
  [
    [[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.get_executor [*get_executor]]]
    []
  ]
  
  [
    [[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.promise [*promise]]]
    []
  ]
  
  [
    [[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.race [*race]] [static]]
    []
  ]
  
  [
    [[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_._promise [*~promise]] [destructor]]
    []
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/promise.hpp]

['Convenience header: ]None

[section:all experimental::promise< void(Ts...), Executor >::all]

[indexterm2 boost_asio.indexterm.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.all..all..experimental::promise< void(Ts\.\.\.), Executor >] 

  template<
      execution::executor ``[link boost_asio.reference.Executor1 Executor1]``,
      is_promise_c... Ps>
  static auto ``[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.all.overload1 all]``(
      Executor1 exec,
      Ps... ps);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.all.overload1 more...]]``

  template<
      is_promise_c... Ps>
  static auto ``[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.all.overload2 all]``(
      Ps... ps);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.all.overload2 more...]]``

  template<
      execution::executor ``[link boost_asio.reference.Executor1 Executor1]``,
      typename Range>
  static auto ``[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.all.overload3 all]``(
      Executor1 exec,
      Range range);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.all.overload3 more...]]``

  template<
      typename Range>
  static auto ``[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.all.overload4 all]``(
      Range range);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.all.overload4 more...]]``


[section:overload1 experimental::promise< void(Ts...), Executor >::all (1 of 4 overloads)]



  template<
      execution::executor ``[link boost_asio.reference.Executor1 Executor1]``,
      is_promise_c... Ps>
  static auto all(
      Executor1 exec,
      Ps... ps);



[endsect]



[section:overload2 experimental::promise< void(Ts...), Executor >::all (2 of 4 overloads)]



  template<
      is_promise_c... Ps>
  static auto all(
      Ps... ps);



[endsect]



[section:overload3 experimental::promise< void(Ts...), Executor >::all (3 of 4 overloads)]



  template<
      execution::executor ``[link boost_asio.reference.Executor1 Executor1]``,
      typename Range>
  static auto all(
      Executor1 exec,
      Range range);



[endsect]



[section:overload4 experimental::promise< void(Ts...), Executor >::all (4 of 4 overloads)]



  template<
      typename Range>
  static auto all(
      Range range);



[endsect]


[endsect]


[section:async_wait experimental::promise< void(Ts...), Executor >::async_wait]

[indexterm2 boost_asio.indexterm.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.async_wait..async_wait..experimental::promise< void(Ts\.\.\.), Executor >] 

  template<
      typename CompletionToken>
  auto async_wait(
      CompletionToken && token);



[endsect]



[section:cancel experimental::promise< void(Ts...), Executor >::cancel]

[indexterm2 boost_asio.indexterm.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.cancel..cancel..experimental::promise< void(Ts\.\.\.), Executor >] 

  void cancel(
      cancellation_type level = cancellation_type::all);



[endsect]



[section:complete experimental::promise< void(Ts...), Executor >::complete]

[indexterm2 boost_asio.indexterm.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.complete..complete..experimental::promise< void(Ts\.\.\.), Executor >] 

  bool complete() const;



[endsect]



[section:get_executor experimental::promise< void(Ts...), Executor >::get_executor]

[indexterm2 boost_asio.indexterm.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.get_executor..get_executor..experimental::promise< void(Ts\.\.\.), Executor >] 

  executor_type get_executor() const;



[endsect]


[section:promise experimental::promise< void(Ts...), Executor >::promise]

[indexterm2 boost_asio.indexterm.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.promise..promise..experimental::promise< void(Ts\.\.\.), Executor >] 

  ``[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.promise.overload1 promise]``();
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.promise.overload1 more...]]``

  ``[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.promise.overload2 promise]``(
      const promise & );
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.promise.overload2 more...]]``

  ``[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.promise.overload3 promise]``(
      promise && );
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.promise.overload3 more...]]``


[section:overload1 experimental::promise< void(Ts...), Executor >::promise (1 of 3 overloads)]



  promise();



[endsect]



[section:overload2 experimental::promise< void(Ts...), Executor >::promise (2 of 3 overloads)]



  promise(
      const promise & );



[endsect]



[section:overload3 experimental::promise< void(Ts...), Executor >::promise (3 of 3 overloads)]



  promise(
      promise && );



[endsect]


[endsect]

[section:race experimental::promise< void(Ts...), Executor >::race]

[indexterm2 boost_asio.indexterm.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.race..race..experimental::promise< void(Ts\.\.\.), Executor >] 

  template<
      execution::executor ``[link boost_asio.reference.Executor1 Executor1]``,
      is_promise_c... Ps>
  static auto ``[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.race.overload1 race]``(
      Executor1 exec,
      Ps... ps);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.race.overload1 more...]]``

  template<
      is_promise_c... Ps>
  static auto ``[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.race.overload2 race]``(
      Ps... ps);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.race.overload2 more...]]``

  template<
      execution::executor ``[link boost_asio.reference.Executor1 Executor1]``,
      typename Range>
  static auto ``[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.race.overload3 race]``(
      Executor1 exec,
      Range range);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.race.overload3 more...]]``

  template<
      typename Range>
  static auto ``[link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.race.overload4 race]``(
      Range range);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_.race.overload4 more...]]``


[section:overload1 experimental::promise< void(Ts...), Executor >::race (1 of 4 overloads)]



  template<
      execution::executor ``[link boost_asio.reference.Executor1 Executor1]``,
      is_promise_c... Ps>
  static auto race(
      Executor1 exec,
      Ps... ps);



[endsect]



[section:overload2 experimental::promise< void(Ts...), Executor >::race (2 of 4 overloads)]



  template<
      is_promise_c... Ps>
  static auto race(
      Ps... ps);



[endsect]



[section:overload3 experimental::promise< void(Ts...), Executor >::race (3 of 4 overloads)]



  template<
      execution::executor ``[link boost_asio.reference.Executor1 Executor1]``,
      typename Range>
  static auto race(
      Executor1 exec,
      Range range);



[endsect]



[section:overload4 experimental::promise< void(Ts...), Executor >::race (4 of 4 overloads)]



  template<
      typename Range>
  static auto race(
      Range range);



[endsect]


[endsect]


[section:_promise experimental::promise< void(Ts...), Executor >::~promise]

[indexterm2 boost_asio.indexterm.experimental__promise_lt__void_lp_Ts_ellipsis__rp__comma__Executor__gt_._promise..~promise..experimental::promise< void(Ts\.\.\.), Executor >] 

  ~promise();



[endsect]



[endsect]

[section:experimental__promise_value_type experimental::promise_value_type]

[indexterm1 boost_asio.indexterm.experimental__promise_value_type..experimental::promise_value_type]



  template<
      typename... Ts>
  struct promise_value_type


[heading Requirements]

['Header: ][^boost/asio/experimental/promise.hpp]

['Convenience header: ]None


[endsect]

[section:experimental__promise_value_type_lt__T__gt_ experimental::promise_value_type< T >]

[indexterm1 boost_asio.indexterm.experimental__promise_value_type_lt__T__gt_..experimental::promise_value_type< T >]



  template<
      typename T>
  struct promise_value_type< T >


[heading Requirements]

['Header: ][^boost/asio/experimental/promise.hpp]

['Convenience header: ]None


[endsect]

[section:experimental__promise_value_type_lt__gt_ experimental::promise_value_type<>]

[indexterm1 boost_asio.indexterm.experimental__promise_value_type_lt__gt_..experimental::promise_value_type<>]



  template<>
  struct promise_value_type<>


[heading Requirements]

['Header: ][^boost/asio/experimental/promise.hpp]

['Convenience header: ]None


[endsect]


[section:experimental__use_coro experimental::use_coro]

[indexterm1 boost_asio.indexterm.experimental__use_coro..experimental::use_coro] 
A completion token object that represents the currently executing resumable coroutine. 


  constexpr use_coro_t use_coro;


See the documentation for boost::asio::use\_coro\_t for a usage example. 

[heading Requirements]

['Header: ][^boost/asio/experimental/use_coro.hpp]

['Convenience header: ]None


[endsect]


[section:experimental__use_coro_t experimental::use_coro_t]

[indexterm1 boost_asio.indexterm.experimental__use_coro_t..experimental::use_coro_t]


A completion token that represents the currently executing resumable coroutine. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  struct use_coro_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__use_coro_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the use_coro_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__use_coro_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use use_coro_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__use_coro_t.use_coro_t [*use_coro_t]] [constructor]]
    [Default constructor. 
     [hr]
     Constructor used to specify file name, line, and function name. ]
  ]
  
]

The `use_coro_t` class, with its value `use_coro`, is used to represent an operation that can be awaited by the current resumable coroutine. This completion token may be passed as a handler to an asynchronous operation. For example:



   coro<void> my_coroutine(tcp::socket my_socket)
   {
     std::size_t n = co_await my_socket.async_read_some(buffer, use_coro);
     ...
   } 




When used with co\_await, the initiating function (`async_read_some` in the above example) suspends the current coroutine. The coroutine is resumed when the asynchronous operation completes, and the result of the operation is returned. 

[heading Requirements]

['Header: ][^boost/asio/experimental/use_coro.hpp]

['Convenience header: ]None


[section:as_default_on experimental::use_coro_t::as_default_on]

[indexterm2 boost_asio.indexterm.experimental__use_coro_t.as_default_on..as_default_on..experimental::use_coro_t] 
Function helper to adapt an I/O object to use `use_coro_t` as its default completion token type. 


  template<
      typename T>
  static decay< T >::type::template rebind_executor< executor_with_default< typename decay< T >::type::executor_type > >::other as_default_on(
      T && object);



[endsect]


[section:use_coro_t experimental::use_coro_t::use_coro_t]

[indexterm2 boost_asio.indexterm.experimental__use_coro_t.use_coro_t..use_coro_t..experimental::use_coro_t] 
Default constructor. 


  constexpr ``[link boost_asio.reference.experimental__use_coro_t.use_coro_t.overload1 use_coro_t]``();
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__use_coro_t.use_coro_t.overload1 more...]]``


Constructor used to specify file name, line, and function name. 


  constexpr ``[link boost_asio.reference.experimental__use_coro_t.use_coro_t.overload2 use_coro_t]``(
      const char * file_name,
      int line,
      const char * function_name);
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__use_coro_t.use_coro_t.overload2 more...]]``


[section:overload1 experimental::use_coro_t::use_coro_t (1 of 2 overloads)]


Default constructor. 


  constexpr use_coro_t();



[endsect]



[section:overload2 experimental::use_coro_t::use_coro_t (2 of 2 overloads)]


Constructor used to specify file name, line, and function name. 


  constexpr use_coro_t(
      const char * file_name,
      int line,
      const char * function_name);



[endsect]


[endsect]


[endsect]

[section:experimental__use_coro_t__executor_with_default experimental::use_coro_t::executor_with_default]

[indexterm1 boost_asio.indexterm.experimental__use_coro_t__executor_with_default..experimental::use_coro_t::executor_with_default]


Adapts an executor to add the `use_coro_t` completion token as the default. 


  template<
      typename ``[link boost_asio.reference.Executor1 InnerExecutor]``>
  struct executor_with_default


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__use_coro_t__executor_with_default.default_completion_token_type [*default_completion_token_type]]]
    [Specify use_coro_t as the default completion token type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__use_coro_t__executor_with_default.executor_with_default [*executor_with_default]] [constructor]]
    [Construct the adapted executor from the inner executor type. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/use_coro.hpp]

['Convenience header: ]None


[section:default_completion_token_type experimental::use_coro_t::executor_with_default::default_completion_token_type]

[indexterm2 boost_asio.indexterm.experimental__use_coro_t__executor_with_default.default_completion_token_type..default_completion_token_type..experimental::use_coro_t::executor_with_default] 
Specify `use_coro_t` as the default completion token type. 


  typedef use_coro_t default_completion_token_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.experimental__use_coro_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the use_coro_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__use_coro_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use use_coro_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.experimental__use_coro_t.use_coro_t [*use_coro_t]] [constructor]]
    [Default constructor. 
     [hr]
     Constructor used to specify file name, line, and function name. ]
  ]
  
]

The `use_coro_t` class, with its value `use_coro`, is used to represent an operation that can be awaited by the current resumable coroutine. This completion token may be passed as a handler to an asynchronous operation. For example:



   coro<void> my_coroutine(tcp::socket my_socket)
   {
     std::size_t n = co_await my_socket.async_read_some(buffer, use_coro);
     ...
   } 




When used with co\_await, the initiating function (`async_read_some` in the above example) suspends the current coroutine. The coroutine is resumed when the asynchronous operation completes, and the result of the operation is returned. 


[heading Requirements]

['Header: ][^boost/asio/experimental/use_coro.hpp]

['Convenience header: ]None


[endsect]



[section:executor_with_default experimental::use_coro_t::executor_with_default::executor_with_default]

[indexterm2 boost_asio.indexterm.experimental__use_coro_t__executor_with_default.executor_with_default..executor_with_default..experimental::use_coro_t::executor_with_default] 
Construct the adapted executor from the inner executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 InnerExecutor1]``>
  executor_with_default(
      const InnerExecutor1 & ex,
      typename constraint< conditional< !is_same< InnerExecutor1, executor_with_default >::value, is_convertible< InnerExecutor1, InnerExecutor >, false_type >::type::value >::type  = 0);



[endsect]



[endsect]


[section:experimental__use_promise experimental::use_promise]

[indexterm1 boost_asio.indexterm.experimental__use_promise..experimental::use_promise] 

  constexpr use_promise_t use_promise;


[heading Requirements]

['Header: ][^boost/asio/experimental/promise.hpp]

['Convenience header: ]None


[endsect]


[section:experimental__use_promise_t experimental::use_promise_t]

[indexterm1 boost_asio.indexterm.experimental__use_promise_t..experimental::use_promise_t]



  template<
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  struct use_promise_t


[heading Requirements]

['Header: ][^boost/asio/experimental/promise.hpp]

['Convenience header: ]None


[endsect]

[section:experimental__wait_for_all experimental::wait_for_all]

[indexterm1 boost_asio.indexterm.experimental__wait_for_all..experimental::wait_for_all]


Wait for all operations to complete. 


  class wait_for_all


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__wait_for_all.operator_lp__rp_ [*operator()]]]
    []
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/cancellation_condition.hpp]

['Convenience header: ]None


[section:operator_lp__rp_ experimental::wait_for_all::operator()]

[indexterm2 boost_asio.indexterm.experimental__wait_for_all.operator_lp__rp_..operator()..experimental::wait_for_all] 

  template<
      typename... Args>
  constexpr cancellation_type_t operator()(
      Args && ...) const;



[endsect]



[endsect]

[section:experimental__wait_for_one experimental::wait_for_one]

[indexterm1 boost_asio.indexterm.experimental__wait_for_one..experimental::wait_for_one]


Wait until an operation completes, then cancel the others. 


  class wait_for_one


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__wait_for_one.operator_lp__rp_ [*operator()]]]
    []
  ]
  
  [
    [[link boost_asio.reference.experimental__wait_for_one.wait_for_one [*wait_for_one]] [constructor]]
    []
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/experimental/cancellation_condition.hpp]

['Convenience header: ]None


[section:operator_lp__rp_ experimental::wait_for_one::operator()]

[indexterm2 boost_asio.indexterm.experimental__wait_for_one.operator_lp__rp_..operator()..experimental::wait_for_one] 

  template<
      typename... Args>
  constexpr cancellation_type_t operator()(
      Args && ...) const;



[endsect]



[section:wait_for_one experimental::wait_for_one::wait_for_one]

[indexterm2 boost_asio.indexterm.experimental__wait_for_one.wait_for_one..wait_for_one..experimental::wait_for_one] 

  constexpr wait_for_one(
      cancellation_type_t cancel_type = cancellation_type::all);



[endsect]



[endsect]

[section:experimental__wait_for_one_error experimental::wait_for_one_error]

[indexterm1 boost_asio.indexterm.experimental__wait_for_one_error..experimental::wait_for_one_error]


Wait until an operation completes with an error, then cancel the others. 


  class wait_for_one_error


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__wait_for_one_error.operator_lp__rp_ [*operator()]]]
    []
  ]
  
  [
    [[link boost_asio.reference.experimental__wait_for_one_error.wait_for_one_error [*wait_for_one_error]] [constructor]]
    []
  ]
  
]

If no operation completes with an error, waits for completion of all operations. 

[heading Requirements]

['Header: ][^boost/asio/experimental/cancellation_condition.hpp]

['Convenience header: ]None

[section:operator_lp__rp_ experimental::wait_for_one_error::operator()]

[indexterm2 boost_asio.indexterm.experimental__wait_for_one_error.operator_lp__rp_..operator()..experimental::wait_for_one_error] 

  constexpr cancellation_type_t ``[link boost_asio.reference.experimental__wait_for_one_error.operator_lp__rp_.overload1 operator()]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__wait_for_one_error.operator_lp__rp_.overload1 more...]]``

  template<
      typename E,
      typename... Args>
  constexpr constraint< !is_same< typename decay< E >::type, boost::system::error_code >::value &&!is_same< typename decay< E >::type, std::exception_ptr >::value, cancellation_type_t >::type ``[link boost_asio.reference.experimental__wait_for_one_error.operator_lp__rp_.overload2 operator()]``(
      const E & ,
      Args && ...) const;
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__wait_for_one_error.operator_lp__rp_.overload2 more...]]``

  template<
      typename E,
      typename... Args>
  constexpr constraint< is_same< typename decay< E >::type, boost::system::error_code >::value||is_same< typename decay< E >::type, std::exception_ptr >::value, cancellation_type_t >::type ``[link boost_asio.reference.experimental__wait_for_one_error.operator_lp__rp_.overload3 operator()]``(
      const E & e,
      Args && ...) const;
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__wait_for_one_error.operator_lp__rp_.overload3 more...]]``


[section:overload1 experimental::wait_for_one_error::operator() (1 of 3 overloads)]



  constexpr cancellation_type_t operator()() const;



[endsect]



[section:overload2 experimental::wait_for_one_error::operator() (2 of 3 overloads)]



  template<
      typename E,
      typename... Args>
  constexpr constraint< !is_same< typename decay< E >::type, boost::system::error_code >::value &&!is_same< typename decay< E >::type, std::exception_ptr >::value, cancellation_type_t >::type operator()(
      const E & ,
      Args && ...) const;



[endsect]



[section:overload3 experimental::wait_for_one_error::operator() (3 of 3 overloads)]



  template<
      typename E,
      typename... Args>
  constexpr constraint< is_same< typename decay< E >::type, boost::system::error_code >::value||is_same< typename decay< E >::type, std::exception_ptr >::value, cancellation_type_t >::type operator()(
      const E & e,
      Args && ...) const;



[endsect]


[endsect]


[section:wait_for_one_error experimental::wait_for_one_error::wait_for_one_error]

[indexterm2 boost_asio.indexterm.experimental__wait_for_one_error.wait_for_one_error..wait_for_one_error..experimental::wait_for_one_error] 

  constexpr wait_for_one_error(
      cancellation_type_t cancel_type = cancellation_type::all);



[endsect]



[endsect]

[section:experimental__wait_for_one_success experimental::wait_for_one_success]

[indexterm1 boost_asio.indexterm.experimental__wait_for_one_success..experimental::wait_for_one_success]


Wait until an operation completes without an error, then cancel the others. 


  class wait_for_one_success


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.experimental__wait_for_one_success.operator_lp__rp_ [*operator()]]]
    []
  ]
  
  [
    [[link boost_asio.reference.experimental__wait_for_one_success.wait_for_one_success [*wait_for_one_success]] [constructor]]
    []
  ]
  
]

If no operation completes without an error, waits for completion of all operations. 

[heading Requirements]

['Header: ][^boost/asio/experimental/cancellation_condition.hpp]

['Convenience header: ]None

[section:operator_lp__rp_ experimental::wait_for_one_success::operator()]

[indexterm2 boost_asio.indexterm.experimental__wait_for_one_success.operator_lp__rp_..operator()..experimental::wait_for_one_success] 

  constexpr cancellation_type_t ``[link boost_asio.reference.experimental__wait_for_one_success.operator_lp__rp_.overload1 operator()]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__wait_for_one_success.operator_lp__rp_.overload1 more...]]``

  template<
      typename E,
      typename... Args>
  constexpr constraint< !is_same< typename decay< E >::type, boost::system::error_code >::value &&!is_same< typename decay< E >::type, std::exception_ptr >::value, cancellation_type_t >::type ``[link boost_asio.reference.experimental__wait_for_one_success.operator_lp__rp_.overload2 operator()]``(
      const E & ,
      Args && ...) const;
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__wait_for_one_success.operator_lp__rp_.overload2 more...]]``

  template<
      typename E,
      typename... Args>
  constexpr constraint< is_same< typename decay< E >::type, boost::system::error_code >::value||is_same< typename decay< E >::type, std::exception_ptr >::value, cancellation_type_t >::type ``[link boost_asio.reference.experimental__wait_for_one_success.operator_lp__rp_.overload3 operator()]``(
      const E & e,
      Args && ...) const;
  ``  [''''&raquo;''' [link boost_asio.reference.experimental__wait_for_one_success.operator_lp__rp_.overload3 more...]]``


[section:overload1 experimental::wait_for_one_success::operator() (1 of 3 overloads)]



  constexpr cancellation_type_t operator()() const;



[endsect]



[section:overload2 experimental::wait_for_one_success::operator() (2 of 3 overloads)]



  template<
      typename E,
      typename... Args>
  constexpr constraint< !is_same< typename decay< E >::type, boost::system::error_code >::value &&!is_same< typename decay< E >::type, std::exception_ptr >::value, cancellation_type_t >::type operator()(
      const E & ,
      Args && ...) const;



[endsect]



[section:overload3 experimental::wait_for_one_success::operator() (3 of 3 overloads)]



  template<
      typename E,
      typename... Args>
  constexpr constraint< is_same< typename decay< E >::type, boost::system::error_code >::value||is_same< typename decay< E >::type, std::exception_ptr >::value, cancellation_type_t >::type operator()(
      const E & e,
      Args && ...) const;



[endsect]


[endsect]


[section:wait_for_one_success experimental::wait_for_one_success::wait_for_one_success]

[indexterm2 boost_asio.indexterm.experimental__wait_for_one_success.wait_for_one_success..wait_for_one_success..experimental::wait_for_one_success] 

  constexpr wait_for_one_success(
      cancellation_type_t cancel_type = cancellation_type::all);



[endsect]



[endsect]

[section:file_base file_base]

[indexterm1 boost_asio.indexterm.file_base..file_base]


The [link boost_asio.reference.file_base `file_base`] class is used as a base for the [link boost_asio.reference.basic_stream_file `basic_stream_file`] and [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] class templates so that we have a common place to define flags. 


  class file_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.file_base.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.file_base.seek_basis [*seek_basis]]]
    [Basis for seeking in a file. ]
  
  ]

]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.file_base._file_base [*~file_base]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.file_base.append [*append]] [static]]
    [Open the file in append mode. ]
  ]

  [
    [[link boost_asio.reference.file_base.create [*create]] [static]]
    [Create the file if it does not exist. ]
  ]

  [
    [[link boost_asio.reference.file_base.exclusive [*exclusive]] [static]]
    [Ensure a new file is created. Must be combined with create. ]
  ]

  [
    [[link boost_asio.reference.file_base.read_only [*read_only]] [static]]
    [Open the file for reading. ]
  ]

  [
    [[link boost_asio.reference.file_base.read_write [*read_write]] [static]]
    [Open the file for reading and writing. ]
  ]

  [
    [[link boost_asio.reference.file_base.truncate [*truncate]] [static]]
    [Open the file with any existing contents truncated. ]
  ]

  [
    [[link boost_asio.reference.file_base.write_only [*write_only]] [static]]
    [Open the file for writing. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/file_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:append file_base::append]

[indexterm2 boost_asio.indexterm.file_base.append..append..file_base] 
Open the file in append mode. 


  static const flags append = implementation_defined;



[endsect]



[section:create file_base::create]

[indexterm2 boost_asio.indexterm.file_base.create..create..file_base] 
Create the file if it does not exist. 


  static const flags create = implementation_defined;



[endsect]



[section:exclusive file_base::exclusive]

[indexterm2 boost_asio.indexterm.file_base.exclusive..exclusive..file_base] 
Ensure a new file is created. Must be combined with `create`. 


  static const flags exclusive = implementation_defined;



[endsect]



[section:flags file_base::flags]

[indexterm2 boost_asio.indexterm.file_base.flags..flags..file_base] 
A bitmask type (C++ Std [lib.bitmask.types]). 


  typedef unspecified flags;



[heading Requirements]

['Header: ][^boost/asio/file_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:read_only file_base::read_only]

[indexterm2 boost_asio.indexterm.file_base.read_only..read_only..file_base] 
Open the file for reading. 


  static const flags read_only = implementation_defined;



[endsect]



[section:read_write file_base::read_write]

[indexterm2 boost_asio.indexterm.file_base.read_write..read_write..file_base] 
Open the file for reading and writing. 


  static const flags read_write = implementation_defined;



[endsect]



[section:seek_basis file_base::seek_basis]

[indexterm2 boost_asio.indexterm.file_base.seek_basis..seek_basis..file_base] 
Basis for seeking in a file. 

  enum seek_basis

[indexterm2 boost_asio.indexterm.file_base.seek_basis.seek_set..seek_set..file_base]
[indexterm2 boost_asio.indexterm.file_base.seek_basis.seek_cur..seek_cur..file_base]
[indexterm2 boost_asio.indexterm.file_base.seek_basis.seek_end..seek_end..file_base]

[heading Values]
[variablelist

  [
    [seek_set]
    [Seek to an absolute position. ]
  ]

  [
    [seek_cur]
    [Seek to an offset relative to the current file position. ]
  ]

  [
    [seek_end]
    [Seek to an offset relative to the end of the file. ]
  ]

]



[endsect]



[section:truncate file_base::truncate]

[indexterm2 boost_asio.indexterm.file_base.truncate..truncate..file_base] 
Open the file with any existing contents truncated. 


  static const flags truncate = implementation_defined;



[endsect]



[section:write_only file_base::write_only]

[indexterm2 boost_asio.indexterm.file_base.write_only..write_only..file_base] 
Open the file for writing. 


  static const flags write_only = implementation_defined;



[endsect]



[section:_file_base file_base::~file_base]

[indexterm2 boost_asio.indexterm.file_base._file_base..~file_base..file_base] 
Protected destructor to prevent deletion through this type. 


  ~file_base();



[endsect]



[endsect]

[section:generic__basic_endpoint generic::basic_endpoint]

[indexterm1 boost_asio.indexterm.generic__basic_endpoint..generic::basic_endpoint]


Describes an endpoint for any socket type. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``>
  class basic_endpoint


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.generic__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link boost_asio.reference.generic__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__basic_endpoint.basic_endpoint [*basic_endpoint]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an endpoint from the specified socket address. 
     [hr]
     Construct an endpoint from the specific endpoint type. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

The [link boost_asio.reference.generic__basic_endpoint `generic::basic_endpoint`] class template describes an endpoint that may be associated with any socket type.


[heading Remarks]
      
The socket types sockaddr type must be able to fit into a `sockaddr_storage` structure.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.




[heading Requirements]

['Header: ][^boost/asio/generic/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_endpoint generic::basic_endpoint::basic_endpoint]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.basic_endpoint..basic_endpoint..generic::basic_endpoint] 
Default constructor. 


  ``[link boost_asio.reference.generic__basic_endpoint.basic_endpoint.overload1 basic_endpoint]``();
  ``  [''''&raquo;''' [link boost_asio.reference.generic__basic_endpoint.basic_endpoint.overload1 more...]]``


Construct an endpoint from the specified socket address. 


  ``[link boost_asio.reference.generic__basic_endpoint.basic_endpoint.overload2 basic_endpoint]``(
      const void * socket_address,
      std::size_t socket_address_size,
      int socket_protocol = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.generic__basic_endpoint.basic_endpoint.overload2 more...]]``


Construct an endpoint from the specific endpoint type. 


  template<
      typename ``[link boost_asio.reference.Endpoint Endpoint]``>
  ``[link boost_asio.reference.generic__basic_endpoint.basic_endpoint.overload3 basic_endpoint]``(
      const Endpoint & endpoint);
  ``  [''''&raquo;''' [link boost_asio.reference.generic__basic_endpoint.basic_endpoint.overload3 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.generic__basic_endpoint.basic_endpoint.overload4 basic_endpoint]``(
      const basic_endpoint & other);
  ``  [''''&raquo;''' [link boost_asio.reference.generic__basic_endpoint.basic_endpoint.overload4 more...]]``


[section:overload1 generic::basic_endpoint::basic_endpoint (1 of 4 overloads)]


Default constructor. 


  basic_endpoint();



[endsect]



[section:overload2 generic::basic_endpoint::basic_endpoint (2 of 4 overloads)]


Construct an endpoint from the specified socket address. 


  basic_endpoint(
      const void * socket_address,
      std::size_t socket_address_size,
      int socket_protocol = 0);



[endsect]



[section:overload3 generic::basic_endpoint::basic_endpoint (3 of 4 overloads)]


Construct an endpoint from the specific endpoint type. 


  template<
      typename ``[link boost_asio.reference.Endpoint Endpoint]``>
  basic_endpoint(
      const Endpoint & endpoint);



[endsect]



[section:overload4 generic::basic_endpoint::basic_endpoint (4 of 4 overloads)]


Copy constructor. 


  basic_endpoint(
      const basic_endpoint & other);



[endsect]


[endsect]


[section:capacity generic::basic_endpoint::capacity]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.capacity..capacity..generic::basic_endpoint] 
Get the capacity of the endpoint in the native type. 


  std::size_t capacity() const;



[endsect]


[section:data generic::basic_endpoint::data]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.data..data..generic::basic_endpoint] 
Get the underlying endpoint in the native type. 


  data_type * ``[link boost_asio.reference.generic__basic_endpoint.data.overload1 data]``();
  ``  [''''&raquo;''' [link boost_asio.reference.generic__basic_endpoint.data.overload1 more...]]``

  const data_type * ``[link boost_asio.reference.generic__basic_endpoint.data.overload2 data]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.generic__basic_endpoint.data.overload2 more...]]``


[section:overload1 generic::basic_endpoint::data (1 of 2 overloads)]


Get the underlying endpoint in the native type. 


  data_type * data();



[endsect]



[section:overload2 generic::basic_endpoint::data (2 of 2 overloads)]


Get the underlying endpoint in the native type. 


  const data_type * data() const;



[endsect]


[endsect]


[section:data_type generic::basic_endpoint::data_type]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.data_type..data_type..generic::basic_endpoint] 
The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. 


  typedef implementation_defined data_type;



[heading Requirements]

['Header: ][^boost/asio/generic/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_not__eq_ generic::basic_endpoint::operator!=]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.operator_not__eq_..operator!=..generic::basic_endpoint] 
Compare two endpoints for inequality. 


  friend bool operator!=(
      const basic_endpoint< Protocol > & e1,
      const basic_endpoint< Protocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/generic/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_lt_ generic::basic_endpoint::operator<]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.operator_lt_..operator<..generic::basic_endpoint] 
Compare endpoints for ordering. 


  friend bool operator<(
      const basic_endpoint< Protocol > & e1,
      const basic_endpoint< Protocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/generic/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_lt__eq_ generic::basic_endpoint::operator<=]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.operator_lt__eq_..operator<=..generic::basic_endpoint] 
Compare endpoints for ordering. 


  friend bool operator<=(
      const basic_endpoint< Protocol > & e1,
      const basic_endpoint< Protocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/generic/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ generic::basic_endpoint::operator=]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.operator_eq_..operator=..generic::basic_endpoint] 
Assign from another endpoint. 


  basic_endpoint & operator=(
      const basic_endpoint & other);



[endsect]



[section:operator_eq__eq_ generic::basic_endpoint::operator==]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.operator_eq__eq_..operator==..generic::basic_endpoint] 
Compare two endpoints for equality. 


  friend bool operator==(
      const basic_endpoint< Protocol > & e1,
      const basic_endpoint< Protocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/generic/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt_ generic::basic_endpoint::operator>]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.operator_gt_..operator>..generic::basic_endpoint] 
Compare endpoints for ordering. 


  friend bool operator>(
      const basic_endpoint< Protocol > & e1,
      const basic_endpoint< Protocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/generic/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt__eq_ generic::basic_endpoint::operator>=]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.operator_gt__eq_..operator>=..generic::basic_endpoint] 
Compare endpoints for ordering. 


  friend bool operator>=(
      const basic_endpoint< Protocol > & e1,
      const basic_endpoint< Protocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/generic/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol generic::basic_endpoint::protocol]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.protocol..protocol..generic::basic_endpoint] 
The protocol associated with the endpoint. 


  protocol_type protocol() const;



[endsect]



[section:protocol_type generic::basic_endpoint::protocol_type]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.protocol_type..protocol_type..generic::basic_endpoint] 
The protocol type associated with the endpoint. 


  typedef Protocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/generic/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:resize generic::basic_endpoint::resize]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.resize..resize..generic::basic_endpoint] 
Set the underlying size of the endpoint in the native type. 


  void resize(
      std::size_t new_size);



[endsect]



[section:size generic::basic_endpoint::size]

[indexterm2 boost_asio.indexterm.generic__basic_endpoint.size..size..generic::basic_endpoint] 
Get the underlying size of the endpoint in the native type. 


  std::size_t size() const;



[endsect]



[endsect]

[section:generic__datagram_protocol generic::datagram_protocol]

[indexterm1 boost_asio.indexterm.generic__datagram_protocol..generic::datagram_protocol]


Encapsulates the flags needed for a generic datagram-oriented socket. 


  class datagram_protocol


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.generic__datagram_protocol.endpoint [*endpoint]]]
    [The type of an endpoint. ]
  
  ]

  [

    [[link boost_asio.reference.generic__datagram_protocol.socket [*socket]]]
    [The generic socket type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__datagram_protocol.datagram_protocol [*datagram_protocol]] [constructor]]
    [Construct a protocol object for a specific address family and protocol. 
     [hr]
     Construct a generic protocol object from a specific protocol. ]
  ]
  
  [
    [[link boost_asio.reference.generic__datagram_protocol.family [*family]]]
    [Obtain an identifier for the protocol family. ]
  ]
  
  [
    [[link boost_asio.reference.generic__datagram_protocol.protocol [*protocol]]]
    [Obtain an identifier for the protocol. ]
  ]
  
  [
    [[link boost_asio.reference.generic__datagram_protocol.type [*type]]]
    [Obtain an identifier for the type of the protocol. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__datagram_protocol.operator_not__eq_ [*operator!=]]]
    [Compare two protocols for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__datagram_protocol.operator_eq__eq_ [*operator==]]]
    [Compare two protocols for equality. ]
  ]
  
]

The [link boost_asio.reference.generic__datagram_protocol `generic::datagram_protocol`] class contains flags necessary for datagram-oriented sockets of any address family and protocol.


[heading Examples]
  
Constructing using a native address family and socket protocol: 

   datagram_protocol p(AF_INET, IPPROTO_UDP); 


Constructing from a specific protocol type: 

   datagram_protocol p(boost::asio::ip::udp::v4()); 





[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Safe.




[heading Requirements]

['Header: ][^boost/asio/generic/datagram_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:datagram_protocol generic::datagram_protocol::datagram_protocol]

[indexterm2 boost_asio.indexterm.generic__datagram_protocol.datagram_protocol..datagram_protocol..generic::datagram_protocol] 
Construct a protocol object for a specific address family and protocol. 


  ``[link boost_asio.reference.generic__datagram_protocol.datagram_protocol.overload1 datagram_protocol]``(
      int address_family,
      int socket_protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.generic__datagram_protocol.datagram_protocol.overload1 more...]]``


Construct a generic protocol object from a specific protocol. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``>
  ``[link boost_asio.reference.generic__datagram_protocol.datagram_protocol.overload2 datagram_protocol]``(
      const Protocol & source_protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.generic__datagram_protocol.datagram_protocol.overload2 more...]]``


[section:overload1 generic::datagram_protocol::datagram_protocol (1 of 2 overloads)]


Construct a protocol object for a specific address family and protocol. 


  datagram_protocol(
      int address_family,
      int socket_protocol);



[endsect]



[section:overload2 generic::datagram_protocol::datagram_protocol (2 of 2 overloads)]


Construct a generic protocol object from a specific protocol. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``>
  datagram_protocol(
      const Protocol & source_protocol);



[heading Exceptions]
    

[variablelist
  
[[@c][bad\_cast Thrown if the source protocol is not datagram-oriented. ]]

]




[endsect]


[endsect]


[section:endpoint generic::datagram_protocol::endpoint]

[indexterm2 boost_asio.indexterm.generic__datagram_protocol.endpoint..endpoint..generic::datagram_protocol] 
The type of an endpoint. 


  typedef basic_endpoint< datagram_protocol > endpoint;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.generic__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link boost_asio.reference.generic__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__basic_endpoint.basic_endpoint [*basic_endpoint]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an endpoint from the specified socket address. 
     [hr]
     Construct an endpoint from the specific endpoint type. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

The [link boost_asio.reference.generic__basic_endpoint `generic::basic_endpoint`] class template describes an endpoint that may be associated with any socket type.


[heading Remarks]
      
The socket types sockaddr type must be able to fit into a `sockaddr_storage` structure.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.





[heading Requirements]

['Header: ][^boost/asio/generic/datagram_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:family generic::datagram_protocol::family]

[indexterm2 boost_asio.indexterm.generic__datagram_protocol.family..family..generic::datagram_protocol] 
Obtain an identifier for the protocol family. 


  int family() const;



[endsect]



[section:operator_not__eq_ generic::datagram_protocol::operator!=]

[indexterm2 boost_asio.indexterm.generic__datagram_protocol.operator_not__eq_..operator!=..generic::datagram_protocol] 
Compare two protocols for inequality. 


  friend bool operator!=(
      const datagram_protocol & p1,
      const datagram_protocol & p2);


[heading Requirements]

['Header: ][^boost/asio/generic/datagram_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq__eq_ generic::datagram_protocol::operator==]

[indexterm2 boost_asio.indexterm.generic__datagram_protocol.operator_eq__eq_..operator==..generic::datagram_protocol] 
Compare two protocols for equality. 


  friend bool operator==(
      const datagram_protocol & p1,
      const datagram_protocol & p2);


[heading Requirements]

['Header: ][^boost/asio/generic/datagram_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol generic::datagram_protocol::protocol]

[indexterm2 boost_asio.indexterm.generic__datagram_protocol.protocol..protocol..generic::datagram_protocol] 
Obtain an identifier for the protocol. 


  int protocol() const;



[endsect]



[section:socket generic::datagram_protocol::socket]

[indexterm2 boost_asio.indexterm.generic__datagram_protocol.socket..socket..generic::datagram_protocol] 
The generic socket type. 


  typedef basic_datagram_socket< datagram_protocol > socket;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_datagram_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_datagram_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_receive_from [*async_receive_from]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_send [*async_send]]]
    [Start an asynchronous send on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_send_to [*async_send_to]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket [*basic_datagram_socket]] [constructor]]
    [Construct a basic_datagram_socket without opening it. 
     [hr]
     Construct and open a basic_datagram_socket. 
     [hr]
     Construct a basic_datagram_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_datagram_socket on an existing native socket. 
     [hr]
     Move-construct a basic_datagram_socket from another. 
     [hr]
     Move-construct a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_datagram_socket from another. 
     [hr]
     Move-assign a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.receive [*receive]]]
    [Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.receive_from [*receive_from]]]
    [Receive a datagram with the endpoint of the sender. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.send [*send]]]
    [Send some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.send_to [*send_to]]]
    [Send a datagram to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket._basic_datagram_socket [*~basic_datagram_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_datagram_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] class template provides asynchronous and blocking datagram-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `send_to`, `receive`, `receive_from`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe. 


[heading Requirements]

['Header: ][^boost/asio/generic/datagram_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:type generic::datagram_protocol::type]

[indexterm2 boost_asio.indexterm.generic__datagram_protocol.type..type..generic::datagram_protocol] 
Obtain an identifier for the type of the protocol. 


  int type() const;



[endsect]



[endsect]

[section:generic__raw_protocol generic::raw_protocol]

[indexterm1 boost_asio.indexterm.generic__raw_protocol..generic::raw_protocol]


Encapsulates the flags needed for a generic raw socket. 


  class raw_protocol


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.generic__raw_protocol.endpoint [*endpoint]]]
    [The type of an endpoint. ]
  
  ]

  [

    [[link boost_asio.reference.generic__raw_protocol.socket [*socket]]]
    [The generic socket type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__raw_protocol.family [*family]]]
    [Obtain an identifier for the protocol family. ]
  ]
  
  [
    [[link boost_asio.reference.generic__raw_protocol.protocol [*protocol]]]
    [Obtain an identifier for the protocol. ]
  ]
  
  [
    [[link boost_asio.reference.generic__raw_protocol.raw_protocol [*raw_protocol]] [constructor]]
    [Construct a protocol object for a specific address family and protocol. 
     [hr]
     Construct a generic protocol object from a specific protocol. ]
  ]
  
  [
    [[link boost_asio.reference.generic__raw_protocol.type [*type]]]
    [Obtain an identifier for the type of the protocol. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__raw_protocol.operator_not__eq_ [*operator!=]]]
    [Compare two protocols for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__raw_protocol.operator_eq__eq_ [*operator==]]]
    [Compare two protocols for equality. ]
  ]
  
]

The [link boost_asio.reference.generic__raw_protocol `generic::raw_protocol`] class contains flags necessary for raw sockets of any address family and protocol.


[heading Examples]
  
Constructing using a native address family and socket protocol: 

   raw_protocol p(AF_INET, IPPROTO_ICMP); 


Constructing from a specific protocol type: 

   raw_protocol p(boost::asio::ip::icmp::v4()); 





[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Safe.




[heading Requirements]

['Header: ][^boost/asio/generic/raw_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:endpoint generic::raw_protocol::endpoint]

[indexterm2 boost_asio.indexterm.generic__raw_protocol.endpoint..endpoint..generic::raw_protocol] 
The type of an endpoint. 


  typedef basic_endpoint< raw_protocol > endpoint;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.generic__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link boost_asio.reference.generic__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__basic_endpoint.basic_endpoint [*basic_endpoint]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an endpoint from the specified socket address. 
     [hr]
     Construct an endpoint from the specific endpoint type. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

The [link boost_asio.reference.generic__basic_endpoint `generic::basic_endpoint`] class template describes an endpoint that may be associated with any socket type.


[heading Remarks]
      
The socket types sockaddr type must be able to fit into a `sockaddr_storage` structure.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.





[heading Requirements]

['Header: ][^boost/asio/generic/raw_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:family generic::raw_protocol::family]

[indexterm2 boost_asio.indexterm.generic__raw_protocol.family..family..generic::raw_protocol] 
Obtain an identifier for the protocol family. 


  int family() const;



[endsect]



[section:operator_not__eq_ generic::raw_protocol::operator!=]

[indexterm2 boost_asio.indexterm.generic__raw_protocol.operator_not__eq_..operator!=..generic::raw_protocol] 
Compare two protocols for inequality. 


  friend bool operator!=(
      const raw_protocol & p1,
      const raw_protocol & p2);


[heading Requirements]

['Header: ][^boost/asio/generic/raw_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq__eq_ generic::raw_protocol::operator==]

[indexterm2 boost_asio.indexterm.generic__raw_protocol.operator_eq__eq_..operator==..generic::raw_protocol] 
Compare two protocols for equality. 


  friend bool operator==(
      const raw_protocol & p1,
      const raw_protocol & p2);


[heading Requirements]

['Header: ][^boost/asio/generic/raw_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol generic::raw_protocol::protocol]

[indexterm2 boost_asio.indexterm.generic__raw_protocol.protocol..protocol..generic::raw_protocol] 
Obtain an identifier for the protocol. 


  int protocol() const;



[endsect]


[section:raw_protocol generic::raw_protocol::raw_protocol]

[indexterm2 boost_asio.indexterm.generic__raw_protocol.raw_protocol..raw_protocol..generic::raw_protocol] 
Construct a protocol object for a specific address family and protocol. 


  ``[link boost_asio.reference.generic__raw_protocol.raw_protocol.overload1 raw_protocol]``(
      int address_family,
      int socket_protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.generic__raw_protocol.raw_protocol.overload1 more...]]``


Construct a generic protocol object from a specific protocol. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``>
  ``[link boost_asio.reference.generic__raw_protocol.raw_protocol.overload2 raw_protocol]``(
      const Protocol & source_protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.generic__raw_protocol.raw_protocol.overload2 more...]]``


[section:overload1 generic::raw_protocol::raw_protocol (1 of 2 overloads)]


Construct a protocol object for a specific address family and protocol. 


  raw_protocol(
      int address_family,
      int socket_protocol);



[endsect]



[section:overload2 generic::raw_protocol::raw_protocol (2 of 2 overloads)]


Construct a generic protocol object from a specific protocol. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``>
  raw_protocol(
      const Protocol & source_protocol);



[heading Exceptions]
    

[variablelist
  
[[@c][bad\_cast Thrown if the source protocol is not raw-oriented. ]]

]




[endsect]


[endsect]


[section:socket generic::raw_protocol::socket]

[indexterm2 boost_asio.indexterm.generic__raw_protocol.socket..socket..generic::raw_protocol] 
The generic socket type. 


  typedef basic_raw_socket< raw_protocol > socket;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_raw_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_raw_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_receive_from [*async_receive_from]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_send [*async_send]]]
    [Start an asynchronous send on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_send_to [*async_send_to]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.basic_raw_socket [*basic_raw_socket]] [constructor]]
    [Construct a basic_raw_socket without opening it. 
     [hr]
     Construct and open a basic_raw_socket. 
     [hr]
     Construct a basic_raw_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_raw_socket on an existing native socket. 
     [hr]
     Move-construct a basic_raw_socket from another. 
     [hr]
     Move-construct a basic_raw_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_raw_socket from another. 
     [hr]
     Move-assign a basic_raw_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.receive [*receive]]]
    [Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.receive_from [*receive_from]]]
    [Receive raw data with the endpoint of the sender. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.send [*send]]]
    [Send some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.send_to [*send_to]]]
    [Send raw data to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket._basic_raw_socket [*~basic_raw_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_raw_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] class template provides asynchronous and blocking raw-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `send_to`, `receive`, `receive_from`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe. 


[heading Requirements]

['Header: ][^boost/asio/generic/raw_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:type generic::raw_protocol::type]

[indexterm2 boost_asio.indexterm.generic__raw_protocol.type..type..generic::raw_protocol] 
Obtain an identifier for the type of the protocol. 


  int type() const;



[endsect]



[endsect]

[section:generic__seq_packet_protocol generic::seq_packet_protocol]

[indexterm1 boost_asio.indexterm.generic__seq_packet_protocol..generic::seq_packet_protocol]


Encapsulates the flags needed for a generic sequenced packet socket. 


  class seq_packet_protocol


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.generic__seq_packet_protocol.endpoint [*endpoint]]]
    [The type of an endpoint. ]
  
  ]

  [

    [[link boost_asio.reference.generic__seq_packet_protocol.socket [*socket]]]
    [The generic socket type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__seq_packet_protocol.family [*family]]]
    [Obtain an identifier for the protocol family. ]
  ]
  
  [
    [[link boost_asio.reference.generic__seq_packet_protocol.protocol [*protocol]]]
    [Obtain an identifier for the protocol. ]
  ]
  
  [
    [[link boost_asio.reference.generic__seq_packet_protocol.seq_packet_protocol [*seq_packet_protocol]] [constructor]]
    [Construct a protocol object for a specific address family and protocol. 
     [hr]
     Construct a generic protocol object from a specific protocol. ]
  ]
  
  [
    [[link boost_asio.reference.generic__seq_packet_protocol.type [*type]]]
    [Obtain an identifier for the type of the protocol. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__seq_packet_protocol.operator_not__eq_ [*operator!=]]]
    [Compare two protocols for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__seq_packet_protocol.operator_eq__eq_ [*operator==]]]
    [Compare two protocols for equality. ]
  ]
  
]

The [link boost_asio.reference.generic__seq_packet_protocol `generic::seq_packet_protocol`] class contains flags necessary for seq\_packet-oriented sockets of any address family and protocol.


[heading Examples]
  
Constructing using a native address family and socket protocol: 

   seq_packet_protocol p(AF_INET, IPPROTO_SCTP); 





[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Safe.




[heading Requirements]

['Header: ][^boost/asio/generic/seq_packet_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:endpoint generic::seq_packet_protocol::endpoint]

[indexterm2 boost_asio.indexterm.generic__seq_packet_protocol.endpoint..endpoint..generic::seq_packet_protocol] 
The type of an endpoint. 


  typedef basic_endpoint< seq_packet_protocol > endpoint;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.generic__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link boost_asio.reference.generic__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__basic_endpoint.basic_endpoint [*basic_endpoint]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an endpoint from the specified socket address. 
     [hr]
     Construct an endpoint from the specific endpoint type. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

The [link boost_asio.reference.generic__basic_endpoint `generic::basic_endpoint`] class template describes an endpoint that may be associated with any socket type.


[heading Remarks]
      
The socket types sockaddr type must be able to fit into a `sockaddr_storage` structure.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.





[heading Requirements]

['Header: ][^boost/asio/generic/seq_packet_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:family generic::seq_packet_protocol::family]

[indexterm2 boost_asio.indexterm.generic__seq_packet_protocol.family..family..generic::seq_packet_protocol] 
Obtain an identifier for the protocol family. 


  int family() const;



[endsect]



[section:operator_not__eq_ generic::seq_packet_protocol::operator!=]

[indexterm2 boost_asio.indexterm.generic__seq_packet_protocol.operator_not__eq_..operator!=..generic::seq_packet_protocol] 
Compare two protocols for inequality. 


  friend bool operator!=(
      const seq_packet_protocol & p1,
      const seq_packet_protocol & p2);


[heading Requirements]

['Header: ][^boost/asio/generic/seq_packet_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq__eq_ generic::seq_packet_protocol::operator==]

[indexterm2 boost_asio.indexterm.generic__seq_packet_protocol.operator_eq__eq_..operator==..generic::seq_packet_protocol] 
Compare two protocols for equality. 


  friend bool operator==(
      const seq_packet_protocol & p1,
      const seq_packet_protocol & p2);


[heading Requirements]

['Header: ][^boost/asio/generic/seq_packet_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol generic::seq_packet_protocol::protocol]

[indexterm2 boost_asio.indexterm.generic__seq_packet_protocol.protocol..protocol..generic::seq_packet_protocol] 
Obtain an identifier for the protocol. 


  int protocol() const;



[endsect]


[section:seq_packet_protocol generic::seq_packet_protocol::seq_packet_protocol]

[indexterm2 boost_asio.indexterm.generic__seq_packet_protocol.seq_packet_protocol..seq_packet_protocol..generic::seq_packet_protocol] 
Construct a protocol object for a specific address family and protocol. 


  ``[link boost_asio.reference.generic__seq_packet_protocol.seq_packet_protocol.overload1 seq_packet_protocol]``(
      int address_family,
      int socket_protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.generic__seq_packet_protocol.seq_packet_protocol.overload1 more...]]``


Construct a generic protocol object from a specific protocol. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``>
  ``[link boost_asio.reference.generic__seq_packet_protocol.seq_packet_protocol.overload2 seq_packet_protocol]``(
      const Protocol & source_protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.generic__seq_packet_protocol.seq_packet_protocol.overload2 more...]]``


[section:overload1 generic::seq_packet_protocol::seq_packet_protocol (1 of 2 overloads)]


Construct a protocol object for a specific address family and protocol. 


  seq_packet_protocol(
      int address_family,
      int socket_protocol);



[endsect]



[section:overload2 generic::seq_packet_protocol::seq_packet_protocol (2 of 2 overloads)]


Construct a generic protocol object from a specific protocol. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``>
  seq_packet_protocol(
      const Protocol & source_protocol);



[heading Exceptions]
    

[variablelist
  
[[@c][bad\_cast Thrown if the source protocol is not based around sequenced packets. ]]

]




[endsect]


[endsect]


[section:socket generic::seq_packet_protocol::socket]

[indexterm2 boost_asio.indexterm.generic__seq_packet_protocol.socket..socket..generic::seq_packet_protocol] 
The generic socket type. 


  typedef basic_seq_packet_socket< seq_packet_protocol > socket;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_seq_packet_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_seq_packet_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.async_send [*async_send]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.basic_seq_packet_socket [*basic_seq_packet_socket]] [constructor]]
    [Construct a basic_seq_packet_socket without opening it. 
     [hr]
     Construct and open a basic_seq_packet_socket. 
     [hr]
     Construct a basic_seq_packet_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_seq_packet_socket on an existing native socket. 
     [hr]
     Move-construct a basic_seq_packet_socket from another. 
     [hr]
     Move-construct a basic_seq_packet_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_seq_packet_socket from another. 
     [hr]
     Move-assign a basic_seq_packet_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.receive [*receive]]]
    [Receive some data on the socket. 
     [hr]
     Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.send [*send]]]
    [Send some data on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_seq_packet_socket._basic_seq_packet_socket [*~basic_seq_packet_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_seq_packet_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_seq_packet_socket `basic_seq_packet_socket`] class template provides asynchronous and blocking sequenced packet socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `receive`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe. 


[heading Requirements]

['Header: ][^boost/asio/generic/seq_packet_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:type generic::seq_packet_protocol::type]

[indexterm2 boost_asio.indexterm.generic__seq_packet_protocol.type..type..generic::seq_packet_protocol] 
Obtain an identifier for the type of the protocol. 


  int type() const;



[endsect]



[endsect]

[section:generic__stream_protocol generic::stream_protocol]

[indexterm1 boost_asio.indexterm.generic__stream_protocol..generic::stream_protocol]


Encapsulates the flags needed for a generic stream-oriented socket. 


  class stream_protocol


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.generic__stream_protocol.endpoint [*endpoint]]]
    [The type of an endpoint. ]
  
  ]

  [

    [[link boost_asio.reference.generic__stream_protocol.iostream [*iostream]]]
    [The generic socket iostream type. ]
  
  ]

  [

    [[link boost_asio.reference.generic__stream_protocol.socket [*socket]]]
    [The generic socket type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__stream_protocol.family [*family]]]
    [Obtain an identifier for the protocol family. ]
  ]
  
  [
    [[link boost_asio.reference.generic__stream_protocol.protocol [*protocol]]]
    [Obtain an identifier for the protocol. ]
  ]
  
  [
    [[link boost_asio.reference.generic__stream_protocol.stream_protocol [*stream_protocol]] [constructor]]
    [Construct a protocol object for a specific address family and protocol. 
     [hr]
     Construct a generic protocol object from a specific protocol. ]
  ]
  
  [
    [[link boost_asio.reference.generic__stream_protocol.type [*type]]]
    [Obtain an identifier for the type of the protocol. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__stream_protocol.operator_not__eq_ [*operator!=]]]
    [Compare two protocols for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__stream_protocol.operator_eq__eq_ [*operator==]]]
    [Compare two protocols for equality. ]
  ]
  
]

The [link boost_asio.reference.generic__stream_protocol `generic::stream_protocol`] class contains flags necessary for stream-oriented sockets of any address family and protocol.


[heading Examples]
  
Constructing using a native address family and socket protocol: 

   stream_protocol p(AF_INET, IPPROTO_TCP); 


Constructing from a specific protocol type: 

   stream_protocol p(boost::asio::ip::tcp::v4()); 





[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Safe.




[heading Requirements]

['Header: ][^boost/asio/generic/stream_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:endpoint generic::stream_protocol::endpoint]

[indexterm2 boost_asio.indexterm.generic__stream_protocol.endpoint..endpoint..generic::stream_protocol] 
The type of an endpoint. 


  typedef basic_endpoint< stream_protocol > endpoint;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.generic__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link boost_asio.reference.generic__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__basic_endpoint.basic_endpoint [*basic_endpoint]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an endpoint from the specified socket address. 
     [hr]
     Construct an endpoint from the specific endpoint type. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.generic__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

The [link boost_asio.reference.generic__basic_endpoint `generic::basic_endpoint`] class template describes an endpoint that may be associated with any socket type.


[heading Remarks]
      
The socket types sockaddr type must be able to fit into a `sockaddr_storage` structure.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.





[heading Requirements]

['Header: ][^boost/asio/generic/stream_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:family generic::stream_protocol::family]

[indexterm2 boost_asio.indexterm.generic__stream_protocol.family..family..generic::stream_protocol] 
Obtain an identifier for the protocol family. 


  int family() const;



[endsect]



[section:iostream generic::stream_protocol::iostream]

[indexterm2 boost_asio.indexterm.generic__stream_protocol.iostream..iostream..generic::stream_protocol] 
The generic socket iostream type. 


  typedef basic_socket_iostream< stream_protocol > iostream;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket_iostream.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.duration [*duration]]]
    [The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.duration_type [*duration_type]]]
    [(Deprecated: Use duration.) The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.time_point [*time_point]]]
    [The time type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.time_type [*time_type]]]
    [(Deprecated: Use time_point.) The time type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_iostream.basic_socket_iostream [*basic_socket_iostream]] [constructor]]
    [Construct a basic_socket_iostream without establishing a connection. 
     [hr]
     Construct a basic_socket_iostream from the supplied socket. 
     [hr]
     Move-construct a basic_socket_iostream from another. 
     [hr]
     Establish a connection to an endpoint corresponding to a resolver query. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.close [*close]]]
    [Close the connection. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.connect [*connect]]]
    [Establish a connection to an endpoint corresponding to a resolver query. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.error [*error]]]
    [Get the last error associated with the stream. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expires_after [*expires_after]]]
    [Set the stream's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expires_at [*expires_at]]]
    [(Deprecated: Use expiry().) Get the stream's expiry time as an absolute time. 
     [hr]
     Set the stream's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expires_from_now [*expires_from_now]]]
    [(Deprecated: Use expiry().) Get the stream's expiry time relative to now. 
     [hr]
     (Deprecated: Use expires_after().) Set the stream's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expiry [*expiry]]]
    [Get the stream's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_iostream from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.rdbuf [*rdbuf]]]
    [Return a pointer to the underlying streambuf. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.socket [*socket]]]
    [Get a reference to the underlying socket. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/generic/stream_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_not__eq_ generic::stream_protocol::operator!=]

[indexterm2 boost_asio.indexterm.generic__stream_protocol.operator_not__eq_..operator!=..generic::stream_protocol] 
Compare two protocols for inequality. 


  friend bool operator!=(
      const stream_protocol & p1,
      const stream_protocol & p2);


[heading Requirements]

['Header: ][^boost/asio/generic/stream_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq__eq_ generic::stream_protocol::operator==]

[indexterm2 boost_asio.indexterm.generic__stream_protocol.operator_eq__eq_..operator==..generic::stream_protocol] 
Compare two protocols for equality. 


  friend bool operator==(
      const stream_protocol & p1,
      const stream_protocol & p2);


[heading Requirements]

['Header: ][^boost/asio/generic/stream_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol generic::stream_protocol::protocol]

[indexterm2 boost_asio.indexterm.generic__stream_protocol.protocol..protocol..generic::stream_protocol] 
Obtain an identifier for the protocol. 


  int protocol() const;



[endsect]



[section:socket generic::stream_protocol::socket]

[indexterm2 boost_asio.indexterm.generic__stream_protocol.socket..socket..generic::stream_protocol] 
The generic socket type. 


  typedef basic_stream_socket< stream_protocol > socket;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_stream_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_send [*async_send]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.basic_stream_socket [*basic_stream_socket]] [constructor]]
    [Construct a basic_stream_socket without opening it. 
     [hr]
     Construct and open a basic_stream_socket. 
     [hr]
     Construct a basic_stream_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_stream_socket on an existing native socket. 
     [hr]
     Move-construct a basic_stream_socket from another. 
     [hr]
     Move-construct a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_stream_socket from another. 
     [hr]
     Move-assign a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.read_some [*read_some]]]
    [Read some data from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.receive [*receive]]]
    [Receive some data on the socket. 
     [hr]
     Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.send [*send]]]
    [Send some data on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.write_some [*write_some]]]
    [Write some data to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket._basic_stream_socket [*~basic_stream_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] class template provides asynchronous and blocking stream-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `receive`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe.





[heading Requirements]

['Header: ][^boost/asio/generic/stream_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:stream_protocol generic::stream_protocol::stream_protocol]

[indexterm2 boost_asio.indexterm.generic__stream_protocol.stream_protocol..stream_protocol..generic::stream_protocol] 
Construct a protocol object for a specific address family and protocol. 


  ``[link boost_asio.reference.generic__stream_protocol.stream_protocol.overload1 stream_protocol]``(
      int address_family,
      int socket_protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.generic__stream_protocol.stream_protocol.overload1 more...]]``


Construct a generic protocol object from a specific protocol. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``>
  ``[link boost_asio.reference.generic__stream_protocol.stream_protocol.overload2 stream_protocol]``(
      const Protocol & source_protocol);
  ``  [''''&raquo;''' [link boost_asio.reference.generic__stream_protocol.stream_protocol.overload2 more...]]``


[section:overload1 generic::stream_protocol::stream_protocol (1 of 2 overloads)]


Construct a protocol object for a specific address family and protocol. 


  stream_protocol(
      int address_family,
      int socket_protocol);



[endsect]



[section:overload2 generic::stream_protocol::stream_protocol (2 of 2 overloads)]


Construct a generic protocol object from a specific protocol. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``>
  stream_protocol(
      const Protocol & source_protocol);



[heading Exceptions]
    

[variablelist
  
[[@c][bad\_cast Thrown if the source protocol is not stream-oriented. ]]

]




[endsect]


[endsect]


[section:type generic::stream_protocol::type]

[indexterm2 boost_asio.indexterm.generic__stream_protocol.type..type..generic::stream_protocol] 
Obtain an identifier for the type of the protocol. 


  int type() const;



[endsect]



[endsect]

[section:get_associated_allocator get_associated_allocator]

[indexterm1 boost_asio.indexterm.get_associated_allocator..get_associated_allocator] 
Helper function to obtain an object's associated allocator. 

  template<
      typename T>
  associated_allocator< T >::type ``[link boost_asio.reference.get_associated_allocator.overload1 get_associated_allocator]``(
      const T & t);
  ``  [''''&raquo;''' [link boost_asio.reference.get_associated_allocator.overload1 more...]]``

  template<
      typename T,
      typename Allocator>
  associated_allocator< T, Allocator >::type ``[link boost_asio.reference.get_associated_allocator.overload2 get_associated_allocator]``(
      const T & t,
      const Allocator & a);
  ``  [''''&raquo;''' [link boost_asio.reference.get_associated_allocator.overload2 more...]]``

[heading Requirements]

['Header: ][^boost/asio/associated_allocator.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 get_associated_allocator (1 of 2 overloads)]


Helper function to obtain an object's associated allocator. 


  template<
      typename T>
  associated_allocator< T >::type get_associated_allocator(
      const T & t);



[heading Return Value]
      
`associated_allocator<T>::get(t)` 




[endsect]



[section:overload2 get_associated_allocator (2 of 2 overloads)]


Helper function to obtain an object's associated allocator. 


  template<
      typename T,
      typename Allocator>
  associated_allocator< T, Allocator >::type get_associated_allocator(
      const T & t,
      const Allocator & a);



[heading Return Value]
      
`associated_allocator<T, Allocator>::get(t, a)` 




[endsect]


[endsect]

[section:get_associated_cancellation_slot get_associated_cancellation_slot]

[indexterm1 boost_asio.indexterm.get_associated_cancellation_slot..get_associated_cancellation_slot] 
Helper function to obtain an object's associated [link boost_asio.reference.cancellation_slot `cancellation_slot`]. 

  template<
      typename T>
  associated_cancellation_slot< T >::type ``[link boost_asio.reference.get_associated_cancellation_slot.overload1 get_associated_cancellation_slot]``(
      const T & t);
  ``  [''''&raquo;''' [link boost_asio.reference.get_associated_cancellation_slot.overload1 more...]]``

  template<
      typename T,
      typename ``[link boost_asio.reference.CancellationSlot CancellationSlot]``>
  associated_cancellation_slot< T, CancellationSlot >::type ``[link boost_asio.reference.get_associated_cancellation_slot.overload2 get_associated_cancellation_slot]``(
      const T & t,
      const CancellationSlot & st);
  ``  [''''&raquo;''' [link boost_asio.reference.get_associated_cancellation_slot.overload2 more...]]``

[heading Requirements]

['Header: ][^boost/asio/associated_cancellation_slot.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 get_associated_cancellation_slot (1 of 2 overloads)]


Helper function to obtain an object's associated [link boost_asio.reference.cancellation_slot `cancellation_slot`]. 


  template<
      typename T>
  associated_cancellation_slot< T >::type get_associated_cancellation_slot(
      const T & t);



[heading Return Value]
      
`associated_cancellation_slot<T>::get(t)` 




[endsect]



[section:overload2 get_associated_cancellation_slot (2 of 2 overloads)]


Helper function to obtain an object's associated [link boost_asio.reference.cancellation_slot `cancellation_slot`]. 


  template<
      typename T,
      typename ``[link boost_asio.reference.CancellationSlot CancellationSlot]``>
  associated_cancellation_slot< T, CancellationSlot >::type get_associated_cancellation_slot(
      const T & t,
      const CancellationSlot & st);



[heading Return Value]
      
`associated_cancellation_slot<T, CancellationSlot>get(t, st)` 




[endsect]


[endsect]

[section:get_associated_executor get_associated_executor]

[indexterm1 boost_asio.indexterm.get_associated_executor..get_associated_executor] 
Helper function to obtain an object's associated executor. 

  template<
      typename T>
  associated_executor< T >::type ``[link boost_asio.reference.get_associated_executor.overload1 get_associated_executor]``(
      const T & t);
  ``  [''''&raquo;''' [link boost_asio.reference.get_associated_executor.overload1 more...]]``

  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  associated_executor< T, Executor >::type ``[link boost_asio.reference.get_associated_executor.overload2 get_associated_executor]``(
      const T & t,
      const Executor & ex,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.get_associated_executor.overload2 more...]]``

  template<
      typename T,
      typename ExecutionContext>
  associated_executor< T, typename ExecutionContext::executor_type >::type ``[link boost_asio.reference.get_associated_executor.overload3 get_associated_executor]``(
      const T & t,
      ExecutionContext & ctx,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.get_associated_executor.overload3 more...]]``

[heading Requirements]

['Header: ][^boost/asio/associated_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 get_associated_executor (1 of 3 overloads)]


Helper function to obtain an object's associated executor. 


  template<
      typename T>
  associated_executor< T >::type get_associated_executor(
      const T & t);



[heading Return Value]
      
`associated_executor<T>::get(t)` 




[endsect]



[section:overload2 get_associated_executor (2 of 3 overloads)]


Helper function to obtain an object's associated executor. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  associated_executor< T, Executor >::type get_associated_executor(
      const T & t,
      const Executor & ex,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);



[heading Return Value]
      
`associated_executor<T, Executor>::get(t, ex)` 




[endsect]



[section:overload3 get_associated_executor (3 of 3 overloads)]


Helper function to obtain an object's associated executor. 


  template<
      typename T,
      typename ExecutionContext>
  associated_executor< T, typename ExecutionContext::executor_type >::type get_associated_executor(
      const T & t,
      ExecutionContext & ctx,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[heading Return Value]
      
`associated_executor<T, typename ExecutionContext::executor_type>get(t, ctx.get_executor())` 




[endsect]


[endsect]


[section:high_resolution_timer high_resolution_timer]

[indexterm1 boost_asio.indexterm.high_resolution_timer..high_resolution_timer] 
Typedef for a timer based on the high resolution clock. 


  typedef basic_waitable_timer< chrono::high_resolution_clock > high_resolution_timer;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_waitable_timer__rebind_executor [*rebind_executor]]]
    [Rebinds the timer type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.duration [*duration]]]
    [The duration type of the clock. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.time_point [*time_point]]]
    [The time point type of the clock. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.traits_type [*traits_type]]]
    [The wait traits type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_waitable_timer.async_wait [*async_wait]]]
    [Start an asynchronous wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.basic_waitable_timer [*basic_waitable_timer]] [constructor]]
    [Constructor. 
     [hr]
     Constructor to set a particular expiry time as an absolute time. 
     [hr]
     Constructor to set a particular expiry time relative to now. 
     [hr]
     Move-construct a basic_waitable_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the timer. 
     [hr]
     (Deprecated: Use non-error_code overload.) Cancel any asynchronous operations that are waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.cancel_one [*cancel_one]]]
    [Cancels one asynchronous operation that is waiting on the timer. 
     [hr]
     (Deprecated: Use non-error_code overload.) Cancels one asynchronous operation that is waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_after [*expires_after]]]
    [Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_at [*expires_at]]]
    [(Deprecated: Use expiry().) Get the timer's expiry time as an absolute time. 
     [hr]
     Set the timer's expiry time as an absolute time. 
     [hr]
     (Deprecated: Use non-error_code overload.) Set the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_from_now [*expires_from_now]]]
    [(Deprecated: Use expiry().) Get the timer's expiry time relative to now. 
     [hr]
     (Deprecated: Use expires_after().) Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expiry [*expiry]]]
    [Get the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.operator_eq_ [*operator=]]]
    [Move-assign a basic_waitable_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.wait [*wait]]]
    [Perform a blocking wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer._basic_waitable_timer [*~basic_waitable_timer]] [destructor]]
    [Destroys the timer. ]
  ]
  
]

The [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] class template provides the ability to perform a blocking or asynchronous wait for a timer to expire.

A waitable timer is always in one of two states: "expired" or "not expired". If the `wait()` or `async_wait()` function is called on an expired timer, the wait operation will complete immediately.

Most applications will use one of the [link boost_asio.reference.steady_timer `steady_timer`], [link boost_asio.reference.system_timer `system_timer`] or [link boost_asio.reference.high_resolution_timer `high_resolution_timer`] typedefs.


[heading Remarks]
      
This waitable timer functionality is for use with the C++11 standard library's `<chrono>` facility, or with the Boost.Chrono library.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.


[heading Examples]
  
Performing a blocking wait (C++11): 

   // Construct a timer without setting an expiry time.
   boost::asio::steady_timer timer(my_context);

   // Set an expiry time relative to now.
   timer.expires_after(std::chrono::seconds(5));

   // Wait for the timer to expire.
   timer.wait();





Performing an asynchronous wait (C++11): 

   void handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Timer expired.
     }
   }

   ...

   // Construct a timer with an absolute expiry time.
   boost::asio::steady_timer timer(my_context,
       std::chrono::steady_clock::now() + std::chrono::seconds(60));

   // Start an asynchronous wait.
   timer.async_wait(handler);





[heading Changing an active waitable timer's expiry time]
  


Changing the expiry time of a timer while there are pending asynchronous waits causes those wait operations to be cancelled. To ensure that the action associated with the timer is performed only once, use something like this: used:



   void on_some_event()
   {
     if (my_timer.expires_after(seconds(5)) > 0)
     {
       // We managed to cancel the timer. Start new asynchronous wait.
       my_timer.async_wait(on_timeout);
     }
     else
     {
       // Too late, timer has already expired!
     }
   }

   void on_timeout(const boost::system::error_code& e)
   {
     if (e != boost::asio::error::operation_aborted)
     {
       // Timer was not cancelled, take necessary action.
     }
   }





* The `boost::asio::basic_waitable_timer::expires_after()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.


* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 




This typedef uses the C++11 `<chrono>` standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] template directly: 

   typedef basic_waitable_timer<boost::chrono::high_resolution_clock> timer;




[heading Requirements]

['Header: ][^boost/asio/high_resolution_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:invalid_service_owner invalid_service_owner]

[indexterm1 boost_asio.indexterm.invalid_service_owner..invalid_service_owner]


Exception thrown when trying to add a service object to an [link boost_asio.reference.execution_context `execution_context`] where the service has a different owner. 


  class invalid_service_owner


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.invalid_service_owner.invalid_service_owner [*invalid_service_owner]] [constructor]]
    []
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution_context.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:invalid_service_owner invalid_service_owner::invalid_service_owner]

[indexterm2 boost_asio.indexterm.invalid_service_owner.invalid_service_owner..invalid_service_owner..invalid_service_owner] 

  invalid_service_owner();



[endsect]



[endsect]

[section:io_context io_context]

[indexterm1 boost_asio.indexterm.io_context..io_context]


Provides core I/O functionality. 


  class io_context :
    public execution_context


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.io_context__basic_executor_type [*basic_executor_type]]]
    [Executor implementation type used to submit functions to an io_context. ]
  
  ]

  [

    [[link boost_asio.reference.io_context__service [*service]]]
    [Base class for all io_context services. ]
  
  ]

  [

    [[link boost_asio.reference.io_context__strand [*strand]]]
    [Provides serialised handler execution. ]
  
  ]

  [

    [[link boost_asio.reference.io_context__work [*work]]]
    [(Deprecated: Use executor_work_guard.) Class to inform the io_context when it has work to do. ]
  
  ]

  [

    [[link boost_asio.reference.io_context.count_type [*count_type]]]
    [The type used to count the number of handlers executed by the context. ]
  
  ]

  [

    [[link boost_asio.reference.io_context.executor_type [*executor_type]]]
    [Executor used to submit functions to an io_context. ]
  
  ]

  [

    [[link boost_asio.reference.io_context.fork_event [*fork_event]]]
    [Fork-related event notifications. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context.dispatch [*dispatch]]]
    [(Deprecated: Use boost::asio::dispatch().) Request the io_context to invoke the given handler. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.get_executor [*get_executor]]]
    [Obtains the executor associated with the io_context. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.io_context [*io_context]] [constructor]]
    [Constructor. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.notify_fork [*notify_fork]]]
    [Notify the execution_context of a fork-related event. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.poll [*poll]]]
    [Run the io_context object's event processing loop to execute ready handlers. 
     [hr]
     (Deprecated: Use non-error_code overload.) Run the io_context object's event processing loop to execute ready handlers. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.poll_one [*poll_one]]]
    [Run the io_context object's event processing loop to execute one ready handler. 
     [hr]
     (Deprecated: Use non-error_code overload.) Run the io_context object's event processing loop to execute one ready handler. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.post [*post]]]
    [(Deprecated: Use boost::asio::post().) Request the io_context to invoke the given handler and return immediately. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.reset [*reset]]]
    [(Deprecated: Use restart().) Reset the io_context in preparation for a subsequent run() invocation. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.restart [*restart]]]
    [Restart the io_context in preparation for a subsequent run() invocation. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.run [*run]]]
    [Run the io_context object's event processing loop. 
     [hr]
     (Deprecated: Use non-error_code overload.) Run the io_context object's event processing loop. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.run_for [*run_for]]]
    [Run the io_context object's event processing loop for a specified duration. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.run_one [*run_one]]]
    [Run the io_context object's event processing loop to execute at most one handler. 
     [hr]
     (Deprecated: Use non-error_code overload.) Run the io_context object's event processing loop to execute at most one handler. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.run_one_for [*run_one_for]]]
    [Run the io_context object's event processing loop for a specified duration to execute at most one handler. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.run_one_until [*run_one_until]]]
    [Run the io_context object's event processing loop until a specified time to execute at most one handler. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.run_until [*run_until]]]
    [Run the io_context object's event processing loop until a specified time. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.stop [*stop]]]
    [Stop the io_context object's event processing loop. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.stopped [*stopped]]]
    [Determine whether the io_context object has been stopped. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.wrap [*wrap]]]
    [(Deprecated: Use boost::asio::bind_executor().) Create a new handler that automatically dispatches the wrapped handler on the io_context. ]
  ]
  
  [
    [[link boost_asio.reference.io_context._io_context [*~io_context]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context.destroy [*destroy]]]
    [Destroys all services in the context. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.shutdown [*shutdown]]]
    [Shuts down all services in the context. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context.add_service [*add_service]]]
    [(Deprecated: Use make_service().) Add a service object to the execution_context. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.has_service [*has_service]]]
    [Determine if an execution_context contains a specified service type. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.make_service [*make_service]]]
    [Creates a service object and adds it to the execution_context. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.use_service [*use_service]]]
    [
     [hr]
     Obtain the service object corresponding to the given type. ]
  ]
  
]

The [link boost_asio.reference.io_context `io_context`] class provides the core I/O functionality for users of the asynchronous I/O objects, including:


* `boost::asio::ip::tcp::socket` 

* `boost::asio::ip::tcp::acceptor` 

* `boost::asio::ip::udp::socket` 

* [link boost_asio.reference.deadline_timer `deadline_timer`].

The [link boost_asio.reference.io_context `io_context`] class also includes facilities intended for developers of custom asynchronous services.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Safe, with the specific exceptions of the `restart()` and `notify_fork()` functions. Calling `restart()` while there are unfinished `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` calls results in undefined behaviour. The `notify_fork()` function should not be called while any [link boost_asio.reference.io_context `io_context`] function, or any function on an I/O object that is associated with the [link boost_asio.reference.io_context `io_context`], is being called in another thread.



[heading Synchronous and asynchronous operations]
  


Synchronous operations on I/O objects implicitly run the [link boost_asio.reference.io_context `io_context`] object for an individual operation. The [link boost_asio.reference.io_context `io_context`] functions `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` must be called for the [link boost_asio.reference.io_context `io_context`] to perform asynchronous operations on behalf of a C++ program. Notification that an asynchronous operation has completed is delivered by invocation of the associated handler. Handlers are invoked only by a thread that is currently calling any overload of `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` for the [link boost_asio.reference.io_context `io_context`].


[heading Effect of exceptions thrown from handlers]
  


If an exception is thrown from a handler, the exception is allowed to propagate through the throwing thread's invocation of `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()`. No other threads that are calling any of these functions are affected. It is then the responsibility of the application to catch the exception.

After the exception has been caught, the `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` call may be restarted ['without] the need for an intervening call to `restart()`. This allows the thread to rejoin the [link boost_asio.reference.io_context `io_context`] object's thread pool without impacting any other threads in the pool.

For example:



   boost::asio::io_context io_context;
   ...
   for (;;)
   {
     try
     {
       io_context.run();
       break; // run() exited normally
     }
     catch (my_exception& e)
     {
       // Deal with exception as appropriate.
     }
   }





[heading Submitting arbitrary tasks to the io_context]
  


To submit functions to the [link boost_asio.reference.io_context `io_context`], use the [link boost_asio.reference.dispatch `dispatch`] , [link boost_asio.reference.post `post`]  or [link boost_asio.reference.defer `defer`]  free functions.

For example:



   void my_task()
   {
     ...
   }

   ...

   boost::asio::io_context io_context;

   // Submit a function to the io_context.
   boost::asio::post(io_context, my_task);

   // Submit a lambda object to the io_context.
   boost::asio::post(io_context,
       []()
       {
         ...
       });

   // Run the io_context until it runs out of work.
   io_context.run(); 





[heading Stopping the io_context from running out of work]
  


Some applications may need to prevent an [link boost_asio.reference.io_context `io_context`] object's `run()` call from returning when there is no more work to do. For example, the [link boost_asio.reference.io_context `io_context`] may be being run in a background thread that is launched prior to the application's asynchronous operations. The `run()` call may be kept running by creating an executor that tracks work against the [link boost_asio.reference.io_context `io_context`]:



   boost::asio::io_context io_context;
   auto work = boost::asio::require(io_context.get_executor(),
       boost::asio::execution::outstanding_work.tracked);
   ... 




If using C++03, which lacks automatic variable type deduction, you may compute the return type of the require call:



   boost::asio::io_context io_context;
   typename boost::asio::require_result<
       boost::asio::io_context::executor_type,
       boost::asio::exeution::outstanding_work_t::tracked_t>
     work = boost::asio::require(io_context.get_executor(),
       boost::asio::execution::outstanding_work.tracked);
   ... 




or store the result in the type-erasing executor wrapper, [link boost_asio.reference.any_io_executor `any_io_executor`]:



   boost::asio::io_context io_context;
   boost::asio::any_io_executor work
     = boost::asio::require(io_context.get_executor(),
         boost::asio::execution::outstanding_work.tracked);
   ... 




To effect a shutdown, the application will then need to call the [link boost_asio.reference.io_context `io_context`] object's `stop()` member function. This will cause the [link boost_asio.reference.io_context `io_context`] `run()` call to return as soon as possible, abandoning unfinished operations and without permitting ready handlers to be dispatched.

Alternatively, if the application requires that all operations and handlers be allowed to finish normally, store the work-tracking executor in an [link boost_asio.reference.any_io_executor `any_io_executor`] object, so that it may be explicitly reset.



   boost::asio::io_context io_context;
   boost::asio::any_io_executor work
     = boost::asio::require(io_context.get_executor(),
         boost::asio::execution::outstanding_work.tracked);
   ...
   work = boost::asio::any_io_executor(); // Allow run() to exit. 




[heading Requirements]

['Header: ][^boost/asio/io_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:add_service io_context::add_service]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.io_context.add_service..add_service..io_context] 
(Deprecated: Use `make_service()`.) Add a service object to the [link boost_asio.reference.execution_context `execution_context`]. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend void add_service(
      execution_context & e,
      Service * svc);


This function is used to add a service to the [link boost_asio.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

[[svc][The service object. On success, ownership of the service object is transferred to the [link boost_asio.reference.execution_context `execution_context`]. When the [link boost_asio.reference.execution_context `execution_context`] object is destroyed, it will destroy the service object by performing:
``
   delete static_cast<execution_context::service*>(svc) 
``
]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`].]]

[[boost::asio::invalid_service_owner][Thrown if the service's owning [link boost_asio.reference.execution_context `execution_context`] is not the [link boost_asio.reference.execution_context `execution_context`] object specified by the `e` parameter. ]]

]



[heading Requirements]

['Header: ][^boost/asio/io_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:count_type io_context::count_type]

[indexterm2 boost_asio.indexterm.io_context.count_type..count_type..io_context] 
The type used to count the number of handlers executed by the context. 


  typedef std::size_t count_type;



[heading Requirements]

['Header: ][^boost/asio/io_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:destroy io_context::destroy]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.io_context.destroy..destroy..io_context] 
Destroys all services in the context. 


  void destroy();


This function is implemented as follows:


* For each service object `svc` in the [link boost_asio.reference.execution_context `execution_context`] set, in reverse order * of the beginning of service object lifetime, performs `delete static_cast<execution_context::service*>(svc)`. 




[endsect]



[section:dispatch io_context::dispatch]

[indexterm2 boost_asio.indexterm.io_context.dispatch..dispatch..io_context] 
(Deprecated: Use [link boost_asio.reference.dispatch `dispatch`].) Request the [link boost_asio.reference.io_context `io_context`] to invoke the given handler. 


  template<
      typename ``[link boost_asio.reference.LegacyCompletionHandler LegacyCompletionHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` dispatch(
      LegacyCompletionHandler && handler);


This function is used to ask the [link boost_asio.reference.io_context `io_context`] to execute the given handler.

The [link boost_asio.reference.io_context `io_context`] guarantees that the handler will only be called in a thread in which the `run()`, `run_one()`, `poll()` or `poll_one()` member functions is currently being invoked. The handler may be executed inside this function if the guarantee can be met.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be called. The [link boost_asio.reference.io_context `io_context`] will make a copy of the handler object as required. The function signature of the handler must be:
``
   void handler(); 
``
]]

]


[heading Remarks]
      
This function throws an exception only if:


* the handler's `asio_handler_allocate` function; or


* the handler's copy constructor

throws an exception. 


[endsect]



[section:executor_type io_context::executor_type]

[indexterm2 boost_asio.indexterm.io_context.executor_type..executor_type..io_context] 
Executor used to submit functions to an [link boost_asio.reference.io_context `io_context`]. 


  typedef basic_executor_type< std::allocator< void >, 0 > executor_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context__basic_executor_type.basic_executor_type [*basic_executor_type]] [constructor]]
    [Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.defer [*defer]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.dispatch [*dispatch]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.execute [*execute]]]
    [Execution function. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.on_work_finished [*on_work_finished]]]
    [Inform the io_context that some work is no longer outstanding. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.on_work_started [*on_work_started]]]
    [Inform the io_context that it has some outstanding work to do. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move assignment operator. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.post [*post]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.query [*query]]]
    [Query the current value of the context property. 
     [hr]
     Query the current value of the blocking property. 
     [hr]
     Query the current value of the relationship property. 
     [hr]
     Query the current value of the allocator property. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.query__static [*query]] [static]]
    [Query the current value of the mapping property. 
     [hr]
     Query the current value of the outstanding_work property. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.require [*require]]]
    [Obtain an executor with the blocking.possibly property. 
     [hr]
     Obtain an executor with the blocking.never property. 
     [hr]
     Obtain an executor with the relationship.fork property. 
     [hr]
     Obtain an executor with the relationship.continuation property. 
     [hr]
     Obtain an executor with the outstanding_work.tracked property. 
     [hr]
     Obtain an executor with the outstanding_work.untracked property. 
     [hr]
     Obtain an executor with the specified allocator property. 
     [hr]
     Obtain an executor with the default allocator property. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the io_context is running in the current thread. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type._basic_executor_type [*~basic_executor_type]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context__basic_executor_type.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/io_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:fork_event io_context::fork_event]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.io_context.fork_event..fork_event..io_context] 
Fork-related event notifications. 

  enum fork_event

[indexterm2 boost_asio.indexterm.io_context.fork_event.fork_prepare..fork_prepare..io_context]
[indexterm2 boost_asio.indexterm.io_context.fork_event.fork_parent..fork_parent..io_context]
[indexterm2 boost_asio.indexterm.io_context.fork_event.fork_child..fork_child..io_context]

[heading Values]
[variablelist

  [
    [fork_prepare]
    [Notify the context that the process is about to fork. ]
  ]

  [
    [fork_parent]
    [Notify the context that the process has forked and is the parent. ]
  ]

  [
    [fork_child]
    [Notify the context that the process has forked and is the child. ]
  ]

]



[endsect]



[section:get_executor io_context::get_executor]

[indexterm2 boost_asio.indexterm.io_context.get_executor..get_executor..io_context] 
Obtains the executor associated with the [link boost_asio.reference.io_context `io_context`]. 


  executor_type get_executor();



[endsect]



[section:has_service io_context::has_service]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.io_context.has_service..has_service..io_context] 
Determine if an [link boost_asio.reference.execution_context `execution_context`] contains a specified service type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend bool has_service(
      execution_context & e);


This function is used to determine whether the [link boost_asio.reference.execution_context `execution_context`] contains a service object corresponding to the given service type.


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
A boolean indicating whether the [link boost_asio.reference.execution_context `execution_context`] contains the service. 



[heading Requirements]

['Header: ][^boost/asio/io_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:io_context io_context::io_context]

[indexterm2 boost_asio.indexterm.io_context.io_context..io_context..io_context] 
Constructor. 


  ``[link boost_asio.reference.io_context.io_context.overload1 io_context]``();
  ``  [''''&raquo;''' [link boost_asio.reference.io_context.io_context.overload1 more...]]``

  explicit ``[link boost_asio.reference.io_context.io_context.overload2 io_context]``(
      int concurrency_hint);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context.io_context.overload2 more...]]``


[section:overload1 io_context::io_context (1 of 2 overloads)]


Constructor. 


  io_context();



[endsect]



[section:overload2 io_context::io_context (2 of 2 overloads)]


Constructor. 


  io_context(
      int concurrency_hint);


Construct with a hint about the required level of concurrency.


[heading Parameters]
    

[variablelist
  
[[concurrency_hint][A suggestion to the implementation on how many threads it should allow to run simultaneously. ]]

]




[endsect]


[endsect]


[section:make_service io_context::make_service]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.io_context.make_service..make_service..io_context] 
Creates a service object and adds it to the [link boost_asio.reference.execution_context `execution_context`]. 


  template<
      typename ``[link boost_asio.reference.Service Service]``,
      typename... Args>
  friend Service & make_service(
      execution_context & e,
      Args &&... args);


This function is used to add a service to the [link boost_asio.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

[[args][Zero or more arguments to be passed to the service constructor.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`]. ]]

]



[heading Requirements]

['Header: ][^boost/asio/io_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:notify_fork io_context::notify_fork]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.io_context.notify_fork..notify_fork..io_context] 
Notify the [link boost_asio.reference.execution_context `execution_context`] of a fork-related event. 


  void notify_fork(
      fork_event event);


This function is used to inform the [link boost_asio.reference.execution_context `execution_context`] that the process is about to fork, or has just forked. This allows the [link boost_asio.reference.execution_context `execution_context`], and the services it contains, to perform any necessary housekeeping to ensure correct operation following a fork.

This function must not be called while any other [link boost_asio.reference.execution_context `execution_context`] function, or any function associated with the execution\_context's derived class, is being called in another thread. It is, however, safe to call this function from within a completion handler, provided no other thread is accessing the [link boost_asio.reference.execution_context `execution_context`] or its derived class.


[heading Parameters]
    

[variablelist
  
[[event][A fork-related event.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the notification fails the [link boost_asio.reference.execution_context `execution_context`] object should no longer be used and should be destroyed.]]

]


[heading Example]
  
The following code illustrates how to incorporate the `notify_fork()` function: 

   my_execution_context.notify_fork(execution_context::fork_prepare);
   if (fork() == 0)
   {
     // This is the child process.
     my_execution_context.notify_fork(execution_context::fork_child);
   }
   else
   {
     // This is the parent process.
     my_execution_context.notify_fork(execution_context::fork_parent);
   } 





[heading Remarks]
      
For each service object `svc` in the [link boost_asio.reference.execution_context `execution_context`] set, performs `svc->notify_fork();`. When processing the fork\_prepare event, services are visited in reverse order of the beginning of service object lifetime. Otherwise, services are visited in order of the beginning of service object lifetime. 




[endsect]


[section:poll io_context::poll]

[indexterm2 boost_asio.indexterm.io_context.poll..poll..io_context] 
Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop to execute ready handlers. 


  count_type ``[link boost_asio.reference.io_context.poll.overload1 poll]``();
  ``  [''''&raquo;''' [link boost_asio.reference.io_context.poll.overload1 more...]]``


(Deprecated: Use non-error\_code overload.) Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop to execute ready handlers. 


  count_type ``[link boost_asio.reference.io_context.poll.overload2 poll]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context.poll.overload2 more...]]``


[section:overload1 io_context::poll (1 of 2 overloads)]


Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop to execute ready handlers. 


  count_type poll();


The `poll()` function runs handlers that are ready to run, without blocking, until the [link boost_asio.reference.io_context `io_context`] has been stopped or there are no more ready handlers.


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]



[section:overload2 io_context::poll (2 of 2 overloads)]


(Deprecated: Use non-error\_code overload.) Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop to execute ready handlers. 


  count_type poll(
      boost::system::error_code & ec);


The `poll()` function runs handlers that are ready to run, without blocking, until the [link boost_asio.reference.io_context `io_context`] has been stopped or there are no more ready handlers.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]


[endsect]

[section:poll_one io_context::poll_one]

[indexterm2 boost_asio.indexterm.io_context.poll_one..poll_one..io_context] 
Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop to execute one ready handler. 


  count_type ``[link boost_asio.reference.io_context.poll_one.overload1 poll_one]``();
  ``  [''''&raquo;''' [link boost_asio.reference.io_context.poll_one.overload1 more...]]``


(Deprecated: Use non-error\_code overload.) Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop to execute one ready handler. 


  count_type ``[link boost_asio.reference.io_context.poll_one.overload2 poll_one]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context.poll_one.overload2 more...]]``


[section:overload1 io_context::poll_one (1 of 2 overloads)]


Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop to execute one ready handler. 


  count_type poll_one();


The `poll_one()` function runs at most one handler that is ready to run, without blocking.


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]



[section:overload2 io_context::poll_one (2 of 2 overloads)]


(Deprecated: Use non-error\_code overload.) Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop to execute one ready handler. 


  count_type poll_one(
      boost::system::error_code & ec);


The `poll_one()` function runs at most one handler that is ready to run, without blocking.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]


[endsect]


[section:post io_context::post]

[indexterm2 boost_asio.indexterm.io_context.post..post..io_context] 
(Deprecated: Use [link boost_asio.reference.post `post`].) Request the [link boost_asio.reference.io_context `io_context`] to invoke the given handler and return immediately. 


  template<
      typename ``[link boost_asio.reference.LegacyCompletionHandler LegacyCompletionHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` post(
      LegacyCompletionHandler && handler);


This function is used to ask the [link boost_asio.reference.io_context `io_context`] to execute the given handler, but without allowing the [link boost_asio.reference.io_context `io_context`] to call the handler from inside this function.

The [link boost_asio.reference.io_context `io_context`] guarantees that the handler will only be called in a thread in which the `run()`, `run_one()`, `poll()` or `poll_one()` member functions is currently being invoked.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be called. The [link boost_asio.reference.io_context `io_context`] will make a copy of the handler object as required. The function signature of the handler must be:
``
   void handler(); 
``
]]

]


[heading Remarks]
      
This function throws an exception only if:


* the handler's `asio_handler_allocate` function; or


* the handler's copy constructor

throws an exception. 


[endsect]



[section:reset io_context::reset]

[indexterm2 boost_asio.indexterm.io_context.reset..reset..io_context] 
(Deprecated: Use `restart()`.) Reset the [link boost_asio.reference.io_context `io_context`] in preparation for a subsequent `run()` invocation. 


  void reset();


This function must be called prior to any second or later set of invocations of the `run()`, `run_one()`, `poll()` or `poll_one()` functions when a previous invocation of these functions returned due to the [link boost_asio.reference.io_context `io_context`] being stopped or running out of work. After a call to `restart()`, the [link boost_asio.reference.io_context `io_context`] object's `stopped()` function will return `false`.

This function must not be called while there are any unfinished calls to the `run()`, `run_one()`, `poll()` or `poll_one()` functions. 


[endsect]



[section:restart io_context::restart]

[indexterm2 boost_asio.indexterm.io_context.restart..restart..io_context] 
Restart the [link boost_asio.reference.io_context `io_context`] in preparation for a subsequent `run()` invocation. 


  void restart();


This function must be called prior to any second or later set of invocations of the `run()`, `run_one()`, `poll()` or `poll_one()` functions when a previous invocation of these functions returned due to the [link boost_asio.reference.io_context `io_context`] being stopped or running out of work. After a call to `restart()`, the [link boost_asio.reference.io_context `io_context`] object's `stopped()` function will return `false`.

This function must not be called while there are any unfinished calls to the `run()`, `run_one()`, `poll()` or `poll_one()` functions. 


[endsect]


[section:run io_context::run]

[indexterm2 boost_asio.indexterm.io_context.run..run..io_context] 
Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop. 


  count_type ``[link boost_asio.reference.io_context.run.overload1 run]``();
  ``  [''''&raquo;''' [link boost_asio.reference.io_context.run.overload1 more...]]``


(Deprecated: Use non-error\_code overload.) Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop. 


  count_type ``[link boost_asio.reference.io_context.run.overload2 run]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context.run.overload2 more...]]``


[section:overload1 io_context::run (1 of 2 overloads)]


Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop. 


  count_type run();


The `run()` function blocks until all work has finished and there are no more handlers to be dispatched, or until the [link boost_asio.reference.io_context `io_context`] has been stopped.

Multiple threads may call the `run()` function to set up a pool of threads from which the [link boost_asio.reference.io_context `io_context`] may execute handlers. All threads that are waiting in the pool are equivalent and the [link boost_asio.reference.io_context `io_context`] may choose any one of them to invoke a handler.

A normal exit from the `run()` function implies that the [link boost_asio.reference.io_context `io_context`] object is stopped (the `stopped()` function returns `true`). Subsequent calls to `run()`, `run_one()`, `poll()` or `poll_one()` will return immediately unless there is a prior call to `restart()`.


[heading Return Value]
      
The number of handlers that were executed.


[heading Remarks]
      
Calling the `run()` function from a thread that is currently calling one of `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` on the same [link boost_asio.reference.io_context `io_context`] object may introduce the potential for deadlock. It is the caller's reponsibility to avoid this.

The `poll()` function may also be used to dispatch ready handlers, but without blocking. 


[endsect]



[section:overload2 io_context::run (2 of 2 overloads)]


(Deprecated: Use non-error\_code overload.) Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop. 


  count_type run(
      boost::system::error_code & ec);


The `run()` function blocks until all work has finished and there are no more handlers to be dispatched, or until the [link boost_asio.reference.io_context `io_context`] has been stopped.

Multiple threads may call the `run()` function to set up a pool of threads from which the [link boost_asio.reference.io_context `io_context`] may execute handlers. All threads that are waiting in the pool are equivalent and the [link boost_asio.reference.io_context `io_context`] may choose any one of them to invoke a handler.

A normal exit from the `run()` function implies that the [link boost_asio.reference.io_context `io_context`] object is stopped (the `stopped()` function returns `true`). Subsequent calls to `run()`, `run_one()`, `poll()` or `poll_one()` will return immediately unless there is a prior call to `restart()`.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of handlers that were executed.


[heading Remarks]
      
Calling the `run()` function from a thread that is currently calling one of `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` on the same [link boost_asio.reference.io_context `io_context`] object may introduce the potential for deadlock. It is the caller's reponsibility to avoid this.

The `poll()` function may also be used to dispatch ready handlers, but without blocking. 


[endsect]


[endsect]


[section:run_for io_context::run_for]

[indexterm2 boost_asio.indexterm.io_context.run_for..run_for..io_context] 
Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop for a specified duration. 


  template<
      typename Rep,
      typename Period>
  std::size_t run_for(
      const chrono::duration< Rep, Period > & rel_time);


The `run_for()` function blocks until all work has finished and there are no more handlers to be dispatched, until the [link boost_asio.reference.io_context `io_context`] has been stopped, or until the specified duration has elapsed.


[heading Parameters]
    

[variablelist
  
[[rel_time][The duration for which the call may block.]]

]


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]


[section:run_one io_context::run_one]

[indexterm2 boost_asio.indexterm.io_context.run_one..run_one..io_context] 
Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop to execute at most one handler. 


  count_type ``[link boost_asio.reference.io_context.run_one.overload1 run_one]``();
  ``  [''''&raquo;''' [link boost_asio.reference.io_context.run_one.overload1 more...]]``


(Deprecated: Use non-error\_code overload.) Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop to execute at most one handler. 


  count_type ``[link boost_asio.reference.io_context.run_one.overload2 run_one]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context.run_one.overload2 more...]]``


[section:overload1 io_context::run_one (1 of 2 overloads)]


Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop to execute at most one handler. 


  count_type run_one();


The `run_one()` function blocks until one handler has been dispatched, or until the [link boost_asio.reference.io_context `io_context`] has been stopped.


[heading Return Value]
      
The number of handlers that were executed. A zero return value implies that the [link boost_asio.reference.io_context `io_context`] object is stopped (the `stopped()` function returns `true`). Subsequent calls to `run()`, `run_one()`, `poll()` or `poll_one()` will return immediately unless there is a prior call to `restart()`.


[heading Remarks]
      
Calling the `run_one()` function from a thread that is currently calling one of `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` on the same [link boost_asio.reference.io_context `io_context`] object may introduce the potential for deadlock. It is the caller's reponsibility to avoid this. 




[endsect]



[section:overload2 io_context::run_one (2 of 2 overloads)]


(Deprecated: Use non-error\_code overload.) Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop to execute at most one handler. 


  count_type run_one(
      boost::system::error_code & ec);


The `run_one()` function blocks until one handler has been dispatched, or until the [link boost_asio.reference.io_context `io_context`] has been stopped.


[heading Return Value]
      
The number of handlers that were executed. A zero return value implies that the [link boost_asio.reference.io_context `io_context`] object is stopped (the `stopped()` function returns `true`). Subsequent calls to `run()`, `run_one()`, `poll()` or `poll_one()` will return immediately unless there is a prior call to `restart()`.

The number of handlers that were executed.


[heading Remarks]
      
Calling the `run_one()` function from a thread that is currently calling one of `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` on the same [link boost_asio.reference.io_context `io_context`] object may introduce the potential for deadlock. It is the caller's reponsibility to avoid this. 




[endsect]


[endsect]


[section:run_one_for io_context::run_one_for]

[indexterm2 boost_asio.indexterm.io_context.run_one_for..run_one_for..io_context] 
Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop for a specified duration to execute at most one handler. 


  template<
      typename Rep,
      typename Period>
  std::size_t run_one_for(
      const chrono::duration< Rep, Period > & rel_time);


The `run_one_for()` function blocks until one handler has been dispatched, until the [link boost_asio.reference.io_context `io_context`] has been stopped, or until the specified duration has elapsed.


[heading Parameters]
    

[variablelist
  
[[rel_time][The duration for which the call may block.]]

]


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]



[section:run_one_until io_context::run_one_until]

[indexterm2 boost_asio.indexterm.io_context.run_one_until..run_one_until..io_context] 
Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop until a specified time to execute at most one handler. 


  template<
      typename Clock,
      typename Duration>
  std::size_t run_one_until(
      const chrono::time_point< Clock, Duration > & abs_time);


The `run_one_until()` function blocks until one handler has been dispatched, until the [link boost_asio.reference.io_context `io_context`] has been stopped, or until the specified time has been reached.


[heading Parameters]
    

[variablelist
  
[[abs_time][The time point until which the call may block.]]

]


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]



[section:run_until io_context::run_until]

[indexterm2 boost_asio.indexterm.io_context.run_until..run_until..io_context] 
Run the [link boost_asio.reference.io_context `io_context`] object's event processing loop until a specified time. 


  template<
      typename Clock,
      typename Duration>
  std::size_t run_until(
      const chrono::time_point< Clock, Duration > & abs_time);


The `run_until()` function blocks until all work has finished and there are no more handlers to be dispatched, until the [link boost_asio.reference.io_context `io_context`] has been stopped, or until the specified time has been reached.


[heading Parameters]
    

[variablelist
  
[[abs_time][The time point until which the call may block.]]

]


[heading Return Value]
      
The number of handlers that were executed. 




[endsect]



[section:shutdown io_context::shutdown]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.io_context.shutdown..shutdown..io_context] 
Shuts down all services in the context. 


  void shutdown();


This function is implemented as follows:


* For each service object `svc` in the [link boost_asio.reference.execution_context `execution_context`] set, in reverse order of the beginning of service object lifetime, performs `svc->shutdown()`. 




[endsect]



[section:stop io_context::stop]

[indexterm2 boost_asio.indexterm.io_context.stop..stop..io_context] 
Stop the [link boost_asio.reference.io_context `io_context`] object's event processing loop. 


  void stop();


This function does not block, but instead simply signals the [link boost_asio.reference.io_context `io_context`] to stop. All invocations of its `run()` or `run_one()` member functions should return as soon as possible. Subsequent calls to `run()`, `run_one()`, `poll()` or `poll_one()` will return immediately until `restart()` is called. 


[endsect]



[section:stopped io_context::stopped]

[indexterm2 boost_asio.indexterm.io_context.stopped..stopped..io_context] 
Determine whether the [link boost_asio.reference.io_context `io_context`] object has been stopped. 


  bool stopped() const;


This function is used to determine whether an [link boost_asio.reference.io_context `io_context`] object has been stopped, either through an explicit call to `stop()`, or due to running out of work. When an [link boost_asio.reference.io_context `io_context`] object is stopped, calls to `run()`, `run_one()`, `poll()` or `poll_one()` will return immediately without invoking any handlers.


[heading Return Value]
      
`true` if the [link boost_asio.reference.io_context `io_context`] object is stopped, otherwise `false`. 




[endsect]


[section:use_service io_context::use_service]

[indexterm2 boost_asio.indexterm.io_context.use_service..use_service..io_context] 

  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & ``[link boost_asio.reference.io_context.use_service.overload1 use_service]``(
      io_context & ioc);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context.use_service.overload1 more...]]``


Obtain the service object corresponding to the given type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & ``[link boost_asio.reference.io_context.use_service.overload2 use_service]``(
      execution_context & e);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context.use_service.overload2 more...]]``


[section:overload1 io_context::use_service (1 of 2 overloads)]



  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & use_service(
      io_context & ioc);


[heading Requirements]

['Header: ][^boost/asio/io_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:overload2 io_context::use_service (2 of 2 overloads)]


['Inherited from execution_context.]


Obtain the service object corresponding to the given type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & use_service(
      execution_context & e);


This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the [link boost_asio.reference.execution_context `execution_context`] will create a new instance of the service.


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller. 



[heading Requirements]

['Header: ][^boost/asio/io_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[endsect]


[section:wrap io_context::wrap]

[indexterm2 boost_asio.indexterm.io_context.wrap..wrap..io_context] 
(Deprecated: Use [link boost_asio.reference.bind_executor `bind_executor`].) Create a new handler that automatically dispatches the wrapped handler on the [link boost_asio.reference.io_context `io_context`]. 


  template<
      typename ``[link boost_asio.reference.Handler Handler]``>
  unspecified wrap(
      Handler handler);


This function is used to create a new handler function object that, when invoked, will automatically pass the wrapped handler to the [link boost_asio.reference.io_context `io_context`] object's dispatch function.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be wrapped. The [link boost_asio.reference.io_context `io_context`] will make a copy of the handler object as required. The function signature of the handler must be:
``
   void handler(A1 a1, ... An an); 
``
]]

]


[heading Return Value]
      
A function object that, when invoked, passes the wrapped handler to the [link boost_asio.reference.io_context `io_context`] object's dispatch function. Given a function object with the signature: 

   R f(A1 a1, ... An an); 


If this function object is passed to the wrap function like so: 

   io_context.wrap(f); 


then the return value is a function object with the signature 

   void g(A1 a1, ... An an); 


that, when invoked, executes code equivalent to: 

   io_context.dispatch(boost::bind(f, a1, ... an)); 







[endsect]



[section:_io_context io_context::~io_context]

[indexterm2 boost_asio.indexterm.io_context._io_context..~io_context..io_context] 
Destructor. 


  ~io_context();


On destruction, the [link boost_asio.reference.io_context `io_context`] performs the following sequence of operations:


* For each service object `svc` in the [link boost_asio.reference.io_context `io_context`] set, in reverse order of the beginning of service object lifetime, performs `svc->shutdown()`.


* Uninvoked handler objects that were scheduled for deferred invocation on the [link boost_asio.reference.io_context `io_context`], or any associated strand, are destroyed.


* For each service object `svc` in the [link boost_asio.reference.io_context `io_context`] set, in reverse order of the beginning of service object lifetime, performs `delete static_cast<io_context::service*>(svc)`.


[heading Remarks]
      
The destruction sequence described above permits programs to simplify their resource management by using `shared_ptr<>`. Where an object's lifetime is tied to the lifetime of a connection (or some other sequence of asynchronous operations), a `shared_ptr` to the object would be bound into the handlers for all asynchronous operations associated with it. This works as follows:


* When a single connection ends, all associated asynchronous operations complete. The corresponding handler objects are destroyed, and all `shared_ptr` references to the objects are destroyed.


* To shut down the whole program, the [link boost_asio.reference.io_context `io_context`] function `stop()` is called to terminate any `run()` calls as soon as possible. The [link boost_asio.reference.io_context `io_context`] destructor defined above destroys all handlers, causing all `shared_ptr` references to all connection objects to be destroyed. 




[endsect]



[endsect]

[section:io_context__basic_executor_type io_context::basic_executor_type]

[indexterm1 boost_asio.indexterm.io_context__basic_executor_type..io_context::basic_executor_type]


Executor implementation type used to submit functions to an [link boost_asio.reference.io_context `io_context`]. 


  template<
      typename Allocator,
      uintptr_t Bits>
  class basic_executor_type


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context__basic_executor_type.basic_executor_type [*basic_executor_type]] [constructor]]
    [Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.defer [*defer]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.dispatch [*dispatch]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.execute [*execute]]]
    [Execution function. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.on_work_finished [*on_work_finished]]]
    [Inform the io_context that some work is no longer outstanding. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.on_work_started [*on_work_started]]]
    [Inform the io_context that it has some outstanding work to do. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move assignment operator. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.post [*post]]]
    [Request the io_context to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.query [*query]]]
    [Query the current value of the context property. 
     [hr]
     Query the current value of the blocking property. 
     [hr]
     Query the current value of the relationship property. 
     [hr]
     Query the current value of the allocator property. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.query__static [*query]] [static]]
    [Query the current value of the mapping property. 
     [hr]
     Query the current value of the outstanding_work property. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.require [*require]]]
    [Obtain an executor with the blocking.possibly property. 
     [hr]
     Obtain an executor with the blocking.never property. 
     [hr]
     Obtain an executor with the relationship.fork property. 
     [hr]
     Obtain an executor with the relationship.continuation property. 
     [hr]
     Obtain an executor with the outstanding_work.tracked property. 
     [hr]
     Obtain an executor with the outstanding_work.untracked property. 
     [hr]
     Obtain an executor with the specified allocator property. 
     [hr]
     Obtain an executor with the default allocator property. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the io_context is running in the current thread. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type._basic_executor_type [*~basic_executor_type]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context__basic_executor_type.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__basic_executor_type.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/io_context.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_executor_type io_context::basic_executor_type::basic_executor_type]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.basic_executor_type..basic_executor_type..io_context::basic_executor_type] 
Copy constructor. 


  ``[link boost_asio.reference.io_context__basic_executor_type.basic_executor_type.overload1 basic_executor_type]``(
      const basic_executor_type & other);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.basic_executor_type.overload1 more...]]``


Move constructor. 


  ``[link boost_asio.reference.io_context__basic_executor_type.basic_executor_type.overload2 basic_executor_type]``(
      basic_executor_type && other);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.basic_executor_type.overload2 more...]]``


[section:overload1 io_context::basic_executor_type::basic_executor_type (1 of 2 overloads)]


Copy constructor. 


  basic_executor_type(
      const basic_executor_type & other);



[endsect]



[section:overload2 io_context::basic_executor_type::basic_executor_type (2 of 2 overloads)]


Move constructor. 


  basic_executor_type(
      basic_executor_type && other);



[endsect]


[endsect]


[section:context io_context::basic_executor_type::context]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.context..context..io_context::basic_executor_type] 
Obtain the underlying execution context. 


  io_context & context() const;



[endsect]



[section:defer io_context::basic_executor_type::defer]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.defer..defer..io_context::basic_executor_type] 
Request the [link boost_asio.reference.io_context `io_context`] to invoke the given function object. 


  template<
      typename Function,
      typename OtherAllocator>
  void defer(
      Function && f,
      const OtherAllocator & a) const;


This function is used to ask the [link boost_asio.reference.io_context `io_context`] to execute the given function object. The function object will never be executed inside `defer()`. Instead, it will be scheduled to run on the [link boost_asio.reference.io_context `io_context`].

If the current thread belongs to the [link boost_asio.reference.io_context `io_context`], `defer()` will delay scheduling the function object until the current thread returns control to the pool.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:dispatch io_context::basic_executor_type::dispatch]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.dispatch..dispatch..io_context::basic_executor_type] 
Request the [link boost_asio.reference.io_context `io_context`] to invoke the given function object. 


  template<
      typename Function,
      typename OtherAllocator>
  void dispatch(
      Function && f,
      const OtherAllocator & a) const;


This function is used to ask the [link boost_asio.reference.io_context `io_context`] to execute the given function object. If the current thread is running the [link boost_asio.reference.io_context `io_context`], `dispatch()` executes the function before returning. Otherwise, the function will be scheduled to run on the [link boost_asio.reference.io_context `io_context`].


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:execute io_context::basic_executor_type::execute]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.execute..execute..io_context::basic_executor_type] 
Execution function. 


  template<
      typename Function>
  void execute(
      Function && f) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.execution__execute `execution::execute`] customisation point.

For example: 

   auto ex = my_io_context.get_executor();
   execution::execute(ex, my_function_object); 





[endsect]



[section:on_work_finished io_context::basic_executor_type::on_work_finished]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.on_work_finished..on_work_finished..io_context::basic_executor_type] 
Inform the [link boost_asio.reference.io_context `io_context`] that some work is no longer outstanding. 


  void on_work_finished() const;


This function is used to inform the [link boost_asio.reference.io_context `io_context`] that some work has finished. Once the count of unfinished work reaches zero, the [link boost_asio.reference.io_context `io_context`] is stopped and the `run()` and `run_one()` functions may exit. 


[endsect]



[section:on_work_started io_context::basic_executor_type::on_work_started]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.on_work_started..on_work_started..io_context::basic_executor_type] 
Inform the [link boost_asio.reference.io_context `io_context`] that it has some outstanding work to do. 


  void on_work_started() const;


This function is used to inform the [link boost_asio.reference.io_context `io_context`] that some work has begun. This ensures that the io\_context's `run()` and `run_one()` functions do not exit while the work is underway. 


[endsect]



[section:operator_not__eq_ io_context::basic_executor_type::operator!=]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.operator_not__eq_..operator!=..io_context::basic_executor_type] 
Compare two executors for inequality. 


  friend bool operator!=(
      const basic_executor_type & a,
      const basic_executor_type & b);


Two executors are equal if they refer to the same underlying [link boost_asio.reference.io_context `io_context`]. 

[heading Requirements]

['Header: ][^boost/asio/io_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:operator_eq_ io_context::basic_executor_type::operator=]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.operator_eq_..operator=..io_context::basic_executor_type] 
Assignment operator. 


  basic_executor_type & ``[link boost_asio.reference.io_context__basic_executor_type.operator_eq_.overload1 operator=]``(
      const basic_executor_type & other);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.operator_eq_.overload1 more...]]``


Move assignment operator. 


  basic_executor_type & ``[link boost_asio.reference.io_context__basic_executor_type.operator_eq_.overload2 operator=]``(
      basic_executor_type && other);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.operator_eq_.overload2 more...]]``


[section:overload1 io_context::basic_executor_type::operator= (1 of 2 overloads)]


Assignment operator. 


  basic_executor_type & operator=(
      const basic_executor_type & other);



[endsect]



[section:overload2 io_context::basic_executor_type::operator= (2 of 2 overloads)]


Move assignment operator. 


  basic_executor_type & operator=(
      basic_executor_type && other);



[endsect]


[endsect]


[section:operator_eq__eq_ io_context::basic_executor_type::operator==]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.operator_eq__eq_..operator==..io_context::basic_executor_type] 
Compare two executors for equality. 


  friend bool operator==(
      const basic_executor_type & a,
      const basic_executor_type & b);


Two executors are equal if they refer to the same underlying [link boost_asio.reference.io_context `io_context`]. 

[heading Requirements]

['Header: ][^boost/asio/io_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:post io_context::basic_executor_type::post]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.post..post..io_context::basic_executor_type] 
Request the [link boost_asio.reference.io_context `io_context`] to invoke the given function object. 


  template<
      typename Function,
      typename OtherAllocator>
  void post(
      Function && f,
      const OtherAllocator & a) const;


This function is used to ask the [link boost_asio.reference.io_context `io_context`] to execute the given function object. The function object will never be executed inside `post()`. Instead, it will be scheduled to run on the [link boost_asio.reference.io_context `io_context`].


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]


[section:query io_context::basic_executor_type::query]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.query..query..io_context::basic_executor_type] 
Query the current value of the `context` property. 


  io_context & ``[link boost_asio.reference.io_context__basic_executor_type.query.overload1 query]``(
      execution::context_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.query.overload1 more...]]``


Query the current value of the `blocking` property. 


  constexpr execution::blocking_t ``[link boost_asio.reference.io_context__basic_executor_type.query.overload2 query]``(
      execution::blocking_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.query.overload2 more...]]``


Query the current value of the `relationship` property. 


  constexpr execution::relationship_t ``[link boost_asio.reference.io_context__basic_executor_type.query.overload3 query]``(
      execution::relationship_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.query.overload3 more...]]``


Query the current value of the `allocator` property. 


  template<
      typename OtherAllocator>
  constexpr Allocator ``[link boost_asio.reference.io_context__basic_executor_type.query.overload4 query]``(
      execution::allocator_t< OtherAllocator > ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.query.overload4 more...]]``

  constexpr Allocator ``[link boost_asio.reference.io_context__basic_executor_type.query.overload5 query]``(
      execution::allocator_t< void > ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.query.overload5 more...]]``


[section:overload1 io_context::basic_executor_type::query (1 of 5 overloads)]


Query the current value of the `context` property. 


  io_context & query(
      execution::context_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_io_context.get_executor();
   boost::asio::io_context& ctx = boost::asio::query(
       ex, boost::asio::execution::context); 





[endsect]



[section:overload2 io_context::basic_executor_type::query (2 of 5 overloads)]


Query the current value of the `blocking` property. 


  constexpr execution::blocking_t query(
      execution::blocking_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_io_context.get_executor();
   if (boost::asio::query(ex, boost::asio::execution::blocking)
         == boost::asio::execution::blocking.always)
     ... 





[endsect]



[section:overload3 io_context::basic_executor_type::query (3 of 5 overloads)]


Query the current value of the `relationship` property. 


  constexpr execution::relationship_t query(
      execution::relationship_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_io_context.get_executor();
   if (boost::asio::query(ex, boost::asio::execution::relationship)
         == boost::asio::execution::relationship.continuation)
     ... 





[endsect]



[section:overload4 io_context::basic_executor_type::query (4 of 5 overloads)]


Query the current value of the `allocator` property. 


  template<
      typename OtherAllocator>
  constexpr Allocator query(
      execution::allocator_t< OtherAllocator > ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_io_context.get_executor();
   auto alloc = boost::asio::query(ex,
       boost::asio::execution::allocator); 





[endsect]



[section:overload5 io_context::basic_executor_type::query (5 of 5 overloads)]


Query the current value of the `allocator` property. 


  constexpr Allocator query(
      execution::allocator_t< void > ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_io_context.get_executor();
   auto alloc = boost::asio::query(ex,
       boost::asio::execution::allocator); 





[endsect]


[endsect]

[section:query__static io_context::basic_executor_type::query]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.query__static..query..io_context::basic_executor_type] 
Query the current value of the `mapping` property. 


  static constexpr execution::mapping_t ``[link boost_asio.reference.io_context__basic_executor_type.query__static.overload1 query]``(
      execution::mapping_t );
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.query__static.overload1 more...]]``


Query the current value of the `outstanding_work` property. 


  static constexpr execution::outstanding_work_t ``[link boost_asio.reference.io_context__basic_executor_type.query__static.overload2 query]``(
      execution::outstanding_work_t );
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.query__static.overload2 more...]]``


[section:overload1 io_context::basic_executor_type::query (1 of 2 overloads)]


Query the current value of the `mapping` property. 


  static constexpr execution::mapping_t query(
      execution::mapping_t );


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_io_context.get_executor();
   if (boost::asio::query(ex, boost::asio::execution::mapping)
         == boost::asio::execution::mapping.thread)
     ... 





[endsect]



[section:overload2 io_context::basic_executor_type::query (2 of 2 overloads)]


Query the current value of the `outstanding_work` property. 


  static constexpr execution::outstanding_work_t query(
      execution::outstanding_work_t );


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_io_context.get_executor();
   if (boost::asio::query(ex, boost::asio::execution::outstanding_work)
         == boost::asio::execution::outstanding_work.tracked)
     ... 





[endsect]


[endsect]

[section:require io_context::basic_executor_type::require]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.require..require..io_context::basic_executor_type] 
Obtain an executor with the `blocking.possibly` property. 


  constexpr basic_executor_type ``[link boost_asio.reference.io_context__basic_executor_type.require.overload1 require]``(
      execution::blocking_t::possibly_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.require.overload1 more...]]``


Obtain an executor with the `blocking.never` property. 


  constexpr basic_executor_type ``[link boost_asio.reference.io_context__basic_executor_type.require.overload2 require]``(
      execution::blocking_t::never_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.require.overload2 more...]]``


Obtain an executor with the `relationship.fork` property. 


  constexpr basic_executor_type ``[link boost_asio.reference.io_context__basic_executor_type.require.overload3 require]``(
      execution::relationship_t::fork_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.require.overload3 more...]]``


Obtain an executor with the `relationship.continuation` property. 


  constexpr basic_executor_type ``[link boost_asio.reference.io_context__basic_executor_type.require.overload4 require]``(
      execution::relationship_t::continuation_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.require.overload4 more...]]``


Obtain an executor with the `outstanding_work.tracked` property. 


  constexpr basic_executor_type< Allocator, unspecified > ``[link boost_asio.reference.io_context__basic_executor_type.require.overload5 require]``(
      execution::outstanding_work_t::tracked_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.require.overload5 more...]]``


Obtain an executor with the `outstanding_work.untracked` property. 


  constexpr basic_executor_type< Allocator, unspecified > ``[link boost_asio.reference.io_context__basic_executor_type.require.overload6 require]``(
      execution::outstanding_work_t::untracked_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.require.overload6 more...]]``


Obtain an executor with the specified `allocator` property. 


  template<
      typename OtherAllocator>
  constexpr basic_executor_type< OtherAllocator, Bits > ``[link boost_asio.reference.io_context__basic_executor_type.require.overload7 require]``(
      execution::allocator_t< OtherAllocator > a) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.require.overload7 more...]]``


Obtain an executor with the default `allocator` property. 


  constexpr basic_executor_type< std::allocator< void >, Bits > ``[link boost_asio.reference.io_context__basic_executor_type.require.overload8 require]``(
      execution::allocator_t< void > ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__basic_executor_type.require.overload8 more...]]``


[section:overload1 io_context::basic_executor_type::require (1 of 8 overloads)]


Obtain an executor with the `blocking.possibly` property. 


  constexpr basic_executor_type require(
      execution::blocking_t::possibly_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_io_context.get_executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::blocking.possibly); 





[endsect]



[section:overload2 io_context::basic_executor_type::require (2 of 8 overloads)]


Obtain an executor with the `blocking.never` property. 


  constexpr basic_executor_type require(
      execution::blocking_t::never_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_io_context.get_executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::blocking.never); 





[endsect]



[section:overload3 io_context::basic_executor_type::require (3 of 8 overloads)]


Obtain an executor with the `relationship.fork` property. 


  constexpr basic_executor_type require(
      execution::relationship_t::fork_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_io_context.get_executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::relationship.fork); 





[endsect]



[section:overload4 io_context::basic_executor_type::require (4 of 8 overloads)]


Obtain an executor with the `relationship.continuation` property. 


  constexpr basic_executor_type require(
      execution::relationship_t::continuation_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_io_context.get_executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::relationship.continuation); 





[endsect]



[section:overload5 io_context::basic_executor_type::require (5 of 8 overloads)]


Obtain an executor with the `outstanding_work.tracked` property. 


  constexpr basic_executor_type< Allocator, unspecified > require(
      execution::outstanding_work_t::tracked_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_io_context.get_executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::outstanding_work.tracked); 





[endsect]



[section:overload6 io_context::basic_executor_type::require (6 of 8 overloads)]


Obtain an executor with the `outstanding_work.untracked` property. 


  constexpr basic_executor_type< Allocator, unspecified > require(
      execution::outstanding_work_t::untracked_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_io_context.get_executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::outstanding_work.untracked); 





[endsect]



[section:overload7 io_context::basic_executor_type::require (7 of 8 overloads)]


Obtain an executor with the specified `allocator` property. 


  template<
      typename OtherAllocator>
  constexpr basic_executor_type< OtherAllocator, Bits > require(
      execution::allocator_t< OtherAllocator > a) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_io_context.get_executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::allocator(my_allocator)); 





[endsect]



[section:overload8 io_context::basic_executor_type::require (8 of 8 overloads)]


Obtain an executor with the default `allocator` property. 


  constexpr basic_executor_type< std::allocator< void >, Bits > require(
      execution::allocator_t< void > ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_io_context.get_executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::allocator); 





[endsect]


[endsect]


[section:running_in_this_thread io_context::basic_executor_type::running_in_this_thread]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type.running_in_this_thread..running_in_this_thread..io_context::basic_executor_type] 
Determine whether the [link boost_asio.reference.io_context `io_context`] is running in the current thread. 


  bool running_in_this_thread() const;



[heading Return Value]
      
`true` if the current thread is running the [link boost_asio.reference.io_context `io_context`]. Otherwise returns `false`. 




[endsect]



[section:_basic_executor_type io_context::basic_executor_type::~basic_executor_type]

[indexterm2 boost_asio.indexterm.io_context__basic_executor_type._basic_executor_type..~basic_executor_type..io_context::basic_executor_type] 
Destructor. 


  ~basic_executor_type();



[endsect]



[endsect]

[section:io_context__service io_context::service]

[indexterm1 boost_asio.indexterm.io_context__service..io_context::service]


Base class for all [link boost_asio.reference.io_context `io_context`] services. 


  class service


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context__service.get_io_context [*get_io_context]]]
    [Get the io_context object that owns the service. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context__service.service [*service]] [constructor]]
    [Constructor. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__service._service [*~service]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/io_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:get_io_context io_context::service::get_io_context]

[indexterm2 boost_asio.indexterm.io_context__service.get_io_context..get_io_context..io_context::service] 
Get the [link boost_asio.reference.io_context `io_context`] object that owns the service. 


  boost::asio::io_context & get_io_context();



[endsect]



[section:service io_context::service::service]

[indexterm2 boost_asio.indexterm.io_context__service.service..service..io_context::service] 
Constructor. 


  service(
      boost::asio::io_context & owner);



[heading Parameters]
    

[variablelist
  
[[owner][The [link boost_asio.reference.io_context `io_context`] object that owns the service. ]]

]




[endsect]



[section:_service io_context::service::~service]

[indexterm2 boost_asio.indexterm.io_context__service._service..~service..io_context::service] 
Destructor. 


  virtual ~service();



[endsect]



[endsect]

[section:io_context__strand io_context::strand]

[indexterm1 boost_asio.indexterm.io_context__strand..io_context::strand]


Provides serialised handler execution. 


  class strand


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context__strand.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__strand.defer [*defer]]]
    [Request the strand to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__strand.dispatch [*dispatch]]]
    [Request the strand to invoke the given function object. 
     [hr]
     (Deprecated: Use boost::asio::dispatch().) Request the strand to invoke the given handler. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__strand.on_work_finished [*on_work_finished]]]
    [Inform the strand that some work is no longer outstanding. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__strand.on_work_started [*on_work_started]]]
    [Inform the strand that it has some outstanding work to do. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__strand.post [*post]]]
    [Request the strand to invoke the given function object. 
     [hr]
     (Deprecated: Use boost::asio::post().) Request the strand to invoke the given handler and return immediately. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__strand.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the strand is running in the current thread. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__strand.strand [*strand]] [constructor]]
    [Constructor. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__strand.wrap [*wrap]]]
    [(Deprecated: Use boost::asio::bind_executor().) Create a new handler that automatically dispatches the wrapped handler on the strand. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__strand._strand [*~strand]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context__strand.operator_not__eq_ [*operator!=]]]
    [Compare two strands for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__strand.operator_eq__eq_ [*operator==]]]
    [Compare two strands for equality. ]
  ]
  
]

The [link boost_asio.reference.io_context__strand `io_context::strand`] class provides the ability to post and dispatch handlers with the guarantee that none of those handlers will execute concurrently.


[heading Order of handler invocation]
  
Given:


* a strand object `s` 


* an object `a` meeting completion handler requirements


* an object `a1` which is an arbitrary copy of `a` made by the implementation


* an object `b` meeting completion handler requirements


* an object `b1` which is an arbitrary copy of `b` made by the implementation

if any of the following conditions are true:


* `s.post(a)` happens-before `s.post(b)` 


* `s.post(a)` happens-before `s.dispatch(b)`, where the latter is performed outside the strand


* `s.dispatch(a)` happens-before `s.post(b)`, where the former is performed outside the strand


* `s.dispatch(a)` happens-before `s.dispatch(b)`, where both are performed outside the strand

then `asio_handler_invoke(a1, &a1)` happens-before `asio_handler_invoke(b1, &b1)`.

Note that in the following case: 

   async_op_1(..., s.wrap(a));
   async_op_2(..., s.wrap(b)); 


the completion of the first async operation will perform `s.dispatch(a)`, and the second will perform `s.dispatch(b)`, but the order in which those are performed is unspecified. That is, you cannot state whether one happens-before the other. Therefore none of the above conditions are met and no ordering guarantee is made.


[heading Remarks]
      
The implementation makes no guarantee that handlers posted or dispatched through different `strand` objects will be invoked concurrently.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Safe.




[heading Requirements]

['Header: ][^boost/asio/io_context_strand.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:context io_context::strand::context]

[indexterm2 boost_asio.indexterm.io_context__strand.context..context..io_context::strand] 
Obtain the underlying execution context. 


  boost::asio::io_context & context() const;



[endsect]



[section:defer io_context::strand::defer]

[indexterm2 boost_asio.indexterm.io_context__strand.defer..defer..io_context::strand] 
Request the strand to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void defer(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object will never be executed inside this function. Instead, it will be scheduled to run by the underlying [link boost_asio.reference.io_context `io_context`].


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]


[section:dispatch io_context::strand::dispatch]

[indexterm2 boost_asio.indexterm.io_context__strand.dispatch..dispatch..io_context::strand] 
Request the strand to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void ``[link boost_asio.reference.io_context__strand.dispatch.overload1 dispatch]``(
      Function && f,
      const Allocator & a) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__strand.dispatch.overload1 more...]]``


(Deprecated: Use [link boost_asio.reference.dispatch `dispatch`].) Request the strand to invoke the given handler. 


  template<
      typename ``[link boost_asio.reference.LegacyCompletionHandler LegacyCompletionHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.io_context__strand.dispatch.overload2 dispatch]``(
      LegacyCompletionHandler && handler);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__strand.dispatch.overload2 more...]]``


[section:overload1 io_context::strand::dispatch (1 of 2 overloads)]


Request the strand to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void dispatch(
      Function && f,
      const Allocator & a) const;


This function is used to ask the strand to execute the given function object on its underlying [link boost_asio.reference.io_context `io_context`]. The function object will be executed inside this function if the strand is not otherwise busy and if the underlying io\_context's executor's `dispatch()` function is also able to execute the function before returning.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:overload2 io_context::strand::dispatch (2 of 2 overloads)]


(Deprecated: Use [link boost_asio.reference.dispatch `dispatch`].) Request the strand to invoke the given handler. 


  template<
      typename ``[link boost_asio.reference.LegacyCompletionHandler LegacyCompletionHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` dispatch(
      LegacyCompletionHandler && handler);


This function is used to ask the strand to execute the given handler.

The strand object guarantees that handlers posted or dispatched through the strand will not be executed concurrently. The handler may be executed inside this function if the guarantee can be met. If this function is called from within a handler that was posted or dispatched through the same strand, then the new handler will be executed immediately.

The strand's guarantee is in addition to the guarantee provided by the underlying [link boost_asio.reference.io_context `io_context`]. The [link boost_asio.reference.io_context `io_context`] guarantees that the handler will only be called in a thread in which the io\_context's run member function is currently being invoked.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be called. The strand will make a copy of the handler object as required. The function signature of the handler must be: 
``
   void handler(); 
``
]]

]




[endsect]


[endsect]


[section:on_work_finished io_context::strand::on_work_finished]

[indexterm2 boost_asio.indexterm.io_context__strand.on_work_finished..on_work_finished..io_context::strand] 
Inform the strand that some work is no longer outstanding. 


  void on_work_finished() const;


The strand delegates this call to its underlying [link boost_asio.reference.io_context `io_context`]. 


[endsect]



[section:on_work_started io_context::strand::on_work_started]

[indexterm2 boost_asio.indexterm.io_context__strand.on_work_started..on_work_started..io_context::strand] 
Inform the strand that it has some outstanding work to do. 


  void on_work_started() const;


The strand delegates this call to its underlying [link boost_asio.reference.io_context `io_context`]. 


[endsect]



[section:operator_not__eq_ io_context::strand::operator!=]

[indexterm2 boost_asio.indexterm.io_context__strand.operator_not__eq_..operator!=..io_context::strand] 
Compare two strands for inequality. 


  friend bool operator!=(
      const strand & a,
      const strand & b);


Two strands are equal if they refer to the same ordered, non-concurrent state. 

[heading Requirements]

['Header: ][^boost/asio/io_context_strand.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq__eq_ io_context::strand::operator==]

[indexterm2 boost_asio.indexterm.io_context__strand.operator_eq__eq_..operator==..io_context::strand] 
Compare two strands for equality. 


  friend bool operator==(
      const strand & a,
      const strand & b);


Two strands are equal if they refer to the same ordered, non-concurrent state. 

[heading Requirements]

['Header: ][^boost/asio/io_context_strand.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:post io_context::strand::post]

[indexterm2 boost_asio.indexterm.io_context__strand.post..post..io_context::strand] 
Request the strand to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void ``[link boost_asio.reference.io_context__strand.post.overload1 post]``(
      Function && f,
      const Allocator & a) const;
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__strand.post.overload1 more...]]``


(Deprecated: Use [link boost_asio.reference.post `post`].) Request the strand to invoke the given handler and return immediately. 


  template<
      typename ``[link boost_asio.reference.LegacyCompletionHandler LegacyCompletionHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.io_context__strand.post.overload2 post]``(
      LegacyCompletionHandler && handler);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__strand.post.overload2 more...]]``


[section:overload1 io_context::strand::post (1 of 2 overloads)]


Request the strand to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void post(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object will never be executed inside this function. Instead, it will be scheduled to run by the underlying [link boost_asio.reference.io_context `io_context`].


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:overload2 io_context::strand::post (2 of 2 overloads)]


(Deprecated: Use [link boost_asio.reference.post `post`].) Request the strand to invoke the given handler and return immediately. 


  template<
      typename ``[link boost_asio.reference.LegacyCompletionHandler LegacyCompletionHandler]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` post(
      LegacyCompletionHandler && handler);


This function is used to ask the strand to execute the given handler, but without allowing the strand to call the handler from inside this function.

The strand object guarantees that handlers posted or dispatched through the strand will not be executed concurrently. The strand's guarantee is in addition to the guarantee provided by the underlying [link boost_asio.reference.io_context `io_context`]. The [link boost_asio.reference.io_context `io_context`] guarantees that the handler will only be called in a thread in which the io\_context's run member function is currently being invoked.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be called. The strand will make a copy of the handler object as required. The function signature of the handler must be: 
``
   void handler(); 
``
]]

]




[endsect]


[endsect]


[section:running_in_this_thread io_context::strand::running_in_this_thread]

[indexterm2 boost_asio.indexterm.io_context__strand.running_in_this_thread..running_in_this_thread..io_context::strand] 
Determine whether the strand is running in the current thread. 


  bool running_in_this_thread() const;



[heading Return Value]
      
`true` if the current thread is executing a handler that was submitted to the strand using `post()`, `dispatch()` or `wrap()`. Otherwise returns `false`. 




[endsect]



[section:strand io_context::strand::strand]

[indexterm2 boost_asio.indexterm.io_context__strand.strand..strand..io_context::strand] 
Constructor. 


  strand(
      boost::asio::io_context & io_context);


Constructs the strand.


[heading Parameters]
    

[variablelist
  
[[io_context][The [link boost_asio.reference.io_context `io_context`] object that the strand will use to dispatch handlers that are ready to be run. ]]

]




[endsect]



[section:wrap io_context::strand::wrap]

[indexterm2 boost_asio.indexterm.io_context__strand.wrap..wrap..io_context::strand] 
(Deprecated: Use [link boost_asio.reference.bind_executor `bind_executor`].) Create a new handler that automatically dispatches the wrapped handler on the strand. 


  template<
      typename ``[link boost_asio.reference.Handler Handler]``>
  unspecified wrap(
      Handler handler);


This function is used to create a new handler function object that, when invoked, will automatically pass the wrapped handler to the strand's dispatch function.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be wrapped. The strand will make a copy of the handler object as required. The function signature of the handler must be:
``
   void handler(A1 a1, ... An an); 
``
]]

]


[heading Return Value]
      
A function object that, when invoked, passes the wrapped handler to the strand's dispatch function. Given a function object with the signature: 

   R f(A1 a1, ... An an); 


If this function object is passed to the wrap function like so: 

   strand.wrap(f); 


then the return value is a function object with the signature 

   void g(A1 a1, ... An an); 


that, when invoked, executes code equivalent to: 

   strand.dispatch(boost::bind(f, a1, ... an)); 







[endsect]



[section:_strand io_context::strand::~strand]

[indexterm2 boost_asio.indexterm.io_context__strand._strand..~strand..io_context::strand] 
Destructor. 


  ~strand();


Destroys a strand.

Handlers posted through the strand that have not yet been invoked will still be dispatched in a way that meets the guarantee of non-concurrency. 


[endsect]



[endsect]

[section:io_context__work io_context::work]

[indexterm1 boost_asio.indexterm.io_context__work..io_context::work]


(Deprecated: Use [link boost_asio.reference.executor_work_guard `executor_work_guard`].) Class to inform the [link boost_asio.reference.io_context `io_context`] when it has work to do. 


  class work


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context__work.get_io_context [*get_io_context]]]
    [Get the io_context associated with the work. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__work.work [*work]] [constructor]]
    [Constructor notifies the io_context that work is starting. 
     [hr]
     Copy constructor notifies the io_context that work is starting. ]
  ]
  
  [
    [[link boost_asio.reference.io_context__work._work [*~work]] [destructor]]
    [Destructor notifies the io_context that the work is complete. ]
  ]
  
]

The work class is used to inform the [link boost_asio.reference.io_context `io_context`] when work starts and finishes. This ensures that the [link boost_asio.reference.io_context `io_context`] object's `run()` function will not exit while work is underway, and that it does exit when there is no unfinished work remaining.

The work class is copy-constructible so that it may be used as a data member in a handler class. It is not assignable. 

[heading Requirements]

['Header: ][^boost/asio/io_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:get_io_context io_context::work::get_io_context]

[indexterm2 boost_asio.indexterm.io_context__work.get_io_context..get_io_context..io_context::work] 
Get the [link boost_asio.reference.io_context `io_context`] associated with the work. 


  boost::asio::io_context & get_io_context();



[endsect]


[section:work io_context::work::work]

[indexterm2 boost_asio.indexterm.io_context__work.work..work..io_context::work] 
Constructor notifies the [link boost_asio.reference.io_context `io_context`] that work is starting. 


  explicit ``[link boost_asio.reference.io_context__work.work.overload1 work]``(
      boost::asio::io_context & io_context);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__work.work.overload1 more...]]``


Copy constructor notifies the [link boost_asio.reference.io_context `io_context`] that work is starting. 


  ``[link boost_asio.reference.io_context__work.work.overload2 work]``(
      const work & other);
  ``  [''''&raquo;''' [link boost_asio.reference.io_context__work.work.overload2 more...]]``


[section:overload1 io_context::work::work (1 of 2 overloads)]


Constructor notifies the [link boost_asio.reference.io_context `io_context`] that work is starting. 


  work(
      boost::asio::io_context & io_context);


The constructor is used to inform the [link boost_asio.reference.io_context `io_context`] that some work has begun. This ensures that the [link boost_asio.reference.io_context `io_context`] object's `run()` function will not exit while the work is underway. 


[endsect]



[section:overload2 io_context::work::work (2 of 2 overloads)]


Copy constructor notifies the [link boost_asio.reference.io_context `io_context`] that work is starting. 


  work(
      const work & other);


The constructor is used to inform the [link boost_asio.reference.io_context `io_context`] that some work has begun. This ensures that the [link boost_asio.reference.io_context `io_context`] object's `run()` function will not exit while the work is underway. 


[endsect]


[endsect]


[section:_work io_context::work::~work]

[indexterm2 boost_asio.indexterm.io_context__work._work..~work..io_context::work] 
Destructor notifies the [link boost_asio.reference.io_context `io_context`] that the work is complete. 


  ~work();


The destructor is used to inform the [link boost_asio.reference.io_context `io_context`] that some work has finished. Once the count of unfinished work reaches zero, the [link boost_asio.reference.io_context `io_context`] object's `run()` function is permitted to exit. 


[endsect]



[endsect]


[section:io_service io_service]

[indexterm1 boost_asio.indexterm.io_service..io_service] 
Typedef for backwards compatibility. 


  typedef io_context io_service;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.io_context__basic_executor_type [*basic_executor_type]]]
    [Executor implementation type used to submit functions to an io_context. ]
  
  ]

  [

    [[link boost_asio.reference.io_context__service [*service]]]
    [Base class for all io_context services. ]
  
  ]

  [

    [[link boost_asio.reference.io_context__strand [*strand]]]
    [Provides serialised handler execution. ]
  
  ]

  [

    [[link boost_asio.reference.io_context__work [*work]]]
    [(Deprecated: Use executor_work_guard.) Class to inform the io_context when it has work to do. ]
  
  ]

  [

    [[link boost_asio.reference.io_context.count_type [*count_type]]]
    [The type used to count the number of handlers executed by the context. ]
  
  ]

  [

    [[link boost_asio.reference.io_context.executor_type [*executor_type]]]
    [Executor used to submit functions to an io_context. ]
  
  ]

  [

    [[link boost_asio.reference.io_context.fork_event [*fork_event]]]
    [Fork-related event notifications. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context.dispatch [*dispatch]]]
    [(Deprecated: Use boost::asio::dispatch().) Request the io_context to invoke the given handler. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.get_executor [*get_executor]]]
    [Obtains the executor associated with the io_context. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.io_context [*io_context]] [constructor]]
    [Constructor. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.notify_fork [*notify_fork]]]
    [Notify the execution_context of a fork-related event. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.poll [*poll]]]
    [Run the io_context object's event processing loop to execute ready handlers. 
     [hr]
     (Deprecated: Use non-error_code overload.) Run the io_context object's event processing loop to execute ready handlers. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.poll_one [*poll_one]]]
    [Run the io_context object's event processing loop to execute one ready handler. 
     [hr]
     (Deprecated: Use non-error_code overload.) Run the io_context object's event processing loop to execute one ready handler. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.post [*post]]]
    [(Deprecated: Use boost::asio::post().) Request the io_context to invoke the given handler and return immediately. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.reset [*reset]]]
    [(Deprecated: Use restart().) Reset the io_context in preparation for a subsequent run() invocation. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.restart [*restart]]]
    [Restart the io_context in preparation for a subsequent run() invocation. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.run [*run]]]
    [Run the io_context object's event processing loop. 
     [hr]
     (Deprecated: Use non-error_code overload.) Run the io_context object's event processing loop. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.run_for [*run_for]]]
    [Run the io_context object's event processing loop for a specified duration. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.run_one [*run_one]]]
    [Run the io_context object's event processing loop to execute at most one handler. 
     [hr]
     (Deprecated: Use non-error_code overload.) Run the io_context object's event processing loop to execute at most one handler. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.run_one_for [*run_one_for]]]
    [Run the io_context object's event processing loop for a specified duration to execute at most one handler. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.run_one_until [*run_one_until]]]
    [Run the io_context object's event processing loop until a specified time to execute at most one handler. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.run_until [*run_until]]]
    [Run the io_context object's event processing loop until a specified time. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.stop [*stop]]]
    [Stop the io_context object's event processing loop. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.stopped [*stopped]]]
    [Determine whether the io_context object has been stopped. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.wrap [*wrap]]]
    [(Deprecated: Use boost::asio::bind_executor().) Create a new handler that automatically dispatches the wrapped handler on the io_context. ]
  ]
  
  [
    [[link boost_asio.reference.io_context._io_context [*~io_context]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context.destroy [*destroy]]]
    [Destroys all services in the context. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.shutdown [*shutdown]]]
    [Shuts down all services in the context. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.io_context.add_service [*add_service]]]
    [(Deprecated: Use make_service().) Add a service object to the execution_context. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.has_service [*has_service]]]
    [Determine if an execution_context contains a specified service type. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.make_service [*make_service]]]
    [Creates a service object and adds it to the execution_context. ]
  ]
  
  [
    [[link boost_asio.reference.io_context.use_service [*use_service]]]
    [
     [hr]
     Obtain the service object corresponding to the given type. ]
  ]
  
]

The [link boost_asio.reference.io_context `io_context`] class provides the core I/O functionality for users of the asynchronous I/O objects, including:


* `boost::asio::ip::tcp::socket` 

* `boost::asio::ip::tcp::acceptor` 

* `boost::asio::ip::udp::socket` 

* [link boost_asio.reference.deadline_timer `deadline_timer`].

The [link boost_asio.reference.io_context `io_context`] class also includes facilities intended for developers of custom asynchronous services.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Safe, with the specific exceptions of the `restart()` and `notify_fork()` functions. Calling `restart()` while there are unfinished `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` calls results in undefined behaviour. The `notify_fork()` function should not be called while any [link boost_asio.reference.io_context `io_context`] function, or any function on an I/O object that is associated with the [link boost_asio.reference.io_context `io_context`], is being called in another thread.



[heading Synchronous and asynchronous operations]
  


Synchronous operations on I/O objects implicitly run the [link boost_asio.reference.io_context `io_context`] object for an individual operation. The [link boost_asio.reference.io_context `io_context`] functions `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` must be called for the [link boost_asio.reference.io_context `io_context`] to perform asynchronous operations on behalf of a C++ program. Notification that an asynchronous operation has completed is delivered by invocation of the associated handler. Handlers are invoked only by a thread that is currently calling any overload of `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` for the [link boost_asio.reference.io_context `io_context`].


[heading Effect of exceptions thrown from handlers]
  


If an exception is thrown from a handler, the exception is allowed to propagate through the throwing thread's invocation of `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()`. No other threads that are calling any of these functions are affected. It is then the responsibility of the application to catch the exception.

After the exception has been caught, the `run()`, `run_one()`, `run_for()`, `run_until()`, `poll()` or `poll_one()` call may be restarted ['without] the need for an intervening call to `restart()`. This allows the thread to rejoin the [link boost_asio.reference.io_context `io_context`] object's thread pool without impacting any other threads in the pool.

For example:



   boost::asio::io_context io_context;
   ...
   for (;;)
   {
     try
     {
       io_context.run();
       break; // run() exited normally
     }
     catch (my_exception& e)
     {
       // Deal with exception as appropriate.
     }
   }





[heading Submitting arbitrary tasks to the io_context]
  


To submit functions to the [link boost_asio.reference.io_context `io_context`], use the [link boost_asio.reference.dispatch `dispatch`] , [link boost_asio.reference.post `post`]  or [link boost_asio.reference.defer `defer`]  free functions.

For example:



   void my_task()
   {
     ...
   }

   ...

   boost::asio::io_context io_context;

   // Submit a function to the io_context.
   boost::asio::post(io_context, my_task);

   // Submit a lambda object to the io_context.
   boost::asio::post(io_context,
       []()
       {
         ...
       });

   // Run the io_context until it runs out of work.
   io_context.run(); 





[heading Stopping the io_context from running out of work]
  


Some applications may need to prevent an [link boost_asio.reference.io_context `io_context`] object's `run()` call from returning when there is no more work to do. For example, the [link boost_asio.reference.io_context `io_context`] may be being run in a background thread that is launched prior to the application's asynchronous operations. The `run()` call may be kept running by creating an executor that tracks work against the [link boost_asio.reference.io_context `io_context`]:



   boost::asio::io_context io_context;
   auto work = boost::asio::require(io_context.get_executor(),
       boost::asio::execution::outstanding_work.tracked);
   ... 




If using C++03, which lacks automatic variable type deduction, you may compute the return type of the require call:



   boost::asio::io_context io_context;
   typename boost::asio::require_result<
       boost::asio::io_context::executor_type,
       boost::asio::exeution::outstanding_work_t::tracked_t>
     work = boost::asio::require(io_context.get_executor(),
       boost::asio::execution::outstanding_work.tracked);
   ... 




or store the result in the type-erasing executor wrapper, [link boost_asio.reference.any_io_executor `any_io_executor`]:



   boost::asio::io_context io_context;
   boost::asio::any_io_executor work
     = boost::asio::require(io_context.get_executor(),
         boost::asio::execution::outstanding_work.tracked);
   ... 




To effect a shutdown, the application will then need to call the [link boost_asio.reference.io_context `io_context`] object's `stop()` member function. This will cause the [link boost_asio.reference.io_context `io_context`] `run()` call to return as soon as possible, abandoning unfinished operations and without permitting ready handlers to be dispatched.

Alternatively, if the application requires that all operations and handlers be allowed to finish normally, store the work-tracking executor in an [link boost_asio.reference.any_io_executor `any_io_executor`] object, so that it may be explicitly reset.



   boost::asio::io_context io_context;
   boost::asio::any_io_executor work
     = boost::asio::require(io_context.get_executor(),
         boost::asio::execution::outstanding_work.tracked);
   ...
   work = boost::asio::any_io_executor(); // Allow run() to exit. 





[heading Requirements]

['Header: ][^boost/asio/io_service.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:ip__address ip::address]

[indexterm1 boost_asio.indexterm.ip__address..ip::address]


Implements version-independent IP addresses. 


  class address


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address.address [*address]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an address from an IPv4 address. 
     [hr]
     Construct an address from an IPv6 address. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.from_string [*from_string]] [static]]
    [(Deprecated: Use make_address().) Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.is_v4 [*is_v4]]]
    [Get whether the address is an IP version 4 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.is_v6 [*is_v6]]]
    [Get whether the address is an IP version 6 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.operator_eq_ [*operator=]]]
    [Assign from another address. 
     [hr]
     Assign from an IPv4 address. 
     [hr]
     Assign from an IPv6 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.to_string [*to_string]]]
    [Get the address as a string. 
     [hr]
     (Deprecated: Use other overload.) Get the address as a string. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.to_v4 [*to_v4]]]
    [Get the address as an IP version 4 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.to_v6 [*to_v6]]]
    [Get the address as an IP version 6 address. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address.make_address [*make_address]]]
    [Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address.operator_lt__lt_ [*operator<<]]]
    [Output an address as a string. ]
  ]
  
]

The [link boost_asio.reference.ip__address `ip::address`] class provides the ability to use either IP version 4 or version 6 addresses.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/address.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:address ip::address::address]

[indexterm2 boost_asio.indexterm.ip__address.address..address..ip::address] 
Default constructor. 


  ``[link boost_asio.reference.ip__address.address.overload1 address]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.address.overload1 more...]]``


Construct an address from an IPv4 address. 


  ``[link boost_asio.reference.ip__address.address.overload2 address]``(
      const boost::asio::ip::address_v4 & ipv4_address);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.address.overload2 more...]]``


Construct an address from an IPv6 address. 


  ``[link boost_asio.reference.ip__address.address.overload3 address]``(
      const boost::asio::ip::address_v6 & ipv6_address);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.address.overload3 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.ip__address.address.overload4 address]``(
      const address & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.address.overload4 more...]]``


[section:overload1 ip::address::address (1 of 4 overloads)]


Default constructor. 


  address();



[endsect]



[section:overload2 ip::address::address (2 of 4 overloads)]


Construct an address from an IPv4 address. 


  address(
      const boost::asio::ip::address_v4 & ipv4_address);



[endsect]



[section:overload3 ip::address::address (3 of 4 overloads)]


Construct an address from an IPv6 address. 


  address(
      const boost::asio::ip::address_v6 & ipv6_address);



[endsect]



[section:overload4 ip::address::address (4 of 4 overloads)]


Copy constructor. 


  address(
      const address & other);



[endsect]


[endsect]

[section:from_string ip::address::from_string]

[indexterm2 boost_asio.indexterm.ip__address.from_string..from_string..ip::address] 
(Deprecated: Use `make_address()`.) Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  static address ``[link boost_asio.reference.ip__address.from_string.overload1 from_string]``(
      const char * str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.from_string.overload1 more...]]``

  static address ``[link boost_asio.reference.ip__address.from_string.overload2 from_string]``(
      const char * str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.from_string.overload2 more...]]``

  static address ``[link boost_asio.reference.ip__address.from_string.overload3 from_string]``(
      const std::string & str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.from_string.overload3 more...]]``

  static address ``[link boost_asio.reference.ip__address.from_string.overload4 from_string]``(
      const std::string & str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.from_string.overload4 more...]]``


[section:overload1 ip::address::from_string (1 of 4 overloads)]


(Deprecated: Use `make_address()`.) Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  static address from_string(
      const char * str);



[endsect]



[section:overload2 ip::address::from_string (2 of 4 overloads)]


(Deprecated: Use `make_address()`.) Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  static address from_string(
      const char * str,
      boost::system::error_code & ec);



[endsect]



[section:overload3 ip::address::from_string (3 of 4 overloads)]


(Deprecated: Use `make_address()`.) Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  static address from_string(
      const std::string & str);



[endsect]



[section:overload4 ip::address::from_string (4 of 4 overloads)]


(Deprecated: Use `make_address()`.) Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  static address from_string(
      const std::string & str,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:is_loopback ip::address::is_loopback]

[indexterm2 boost_asio.indexterm.ip__address.is_loopback..is_loopback..ip::address] 
Determine whether the address is a loopback address. 


  bool is_loopback() const;



[endsect]



[section:is_multicast ip::address::is_multicast]

[indexterm2 boost_asio.indexterm.ip__address.is_multicast..is_multicast..ip::address] 
Determine whether the address is a multicast address. 


  bool is_multicast() const;



[endsect]



[section:is_unspecified ip::address::is_unspecified]

[indexterm2 boost_asio.indexterm.ip__address.is_unspecified..is_unspecified..ip::address] 
Determine whether the address is unspecified. 


  bool is_unspecified() const;



[endsect]



[section:is_v4 ip::address::is_v4]

[indexterm2 boost_asio.indexterm.ip__address.is_v4..is_v4..ip::address] 
Get whether the address is an IP version 4 address. 


  bool is_v4() const;



[endsect]



[section:is_v6 ip::address::is_v6]

[indexterm2 boost_asio.indexterm.ip__address.is_v6..is_v6..ip::address] 
Get whether the address is an IP version 6 address. 


  bool is_v6() const;



[endsect]


[section:make_address ip::address::make_address]

[indexterm2 boost_asio.indexterm.ip__address.make_address..make_address..ip::address] 
Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address ``[link boost_asio.reference.ip__address.make_address.overload1 make_address]``(
      const char * str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.make_address.overload1 more...]]``

  address ``[link boost_asio.reference.ip__address.make_address.overload2 make_address]``(
      const char * str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.make_address.overload2 more...]]``

  address ``[link boost_asio.reference.ip__address.make_address.overload3 make_address]``(
      const std::string & str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.make_address.overload3 more...]]``

  address ``[link boost_asio.reference.ip__address.make_address.overload4 make_address]``(
      const std::string & str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.make_address.overload4 more...]]``

  address ``[link boost_asio.reference.ip__address.make_address.overload5 make_address]``(
      string_view str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.make_address.overload5 more...]]``

  address ``[link boost_asio.reference.ip__address.make_address.overload6 make_address]``(
      string_view str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.make_address.overload6 more...]]``


[section:overload1 ip::address::make_address (1 of 6 overloads)]


Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address make_address(
      const char * str);



[endsect]



[section:overload2 ip::address::make_address (2 of 6 overloads)]


Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address make_address(
      const char * str,
      boost::system::error_code & ec);



[endsect]



[section:overload3 ip::address::make_address (3 of 6 overloads)]


Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address make_address(
      const std::string & str);



[endsect]



[section:overload4 ip::address::make_address (4 of 6 overloads)]


Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address make_address(
      const std::string & str,
      boost::system::error_code & ec);



[endsect]



[section:overload5 ip::address::make_address (5 of 6 overloads)]


Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address make_address(
      string_view str);



[endsect]



[section:overload6 ip::address::make_address (6 of 6 overloads)]


Create an address from an IPv4 address string in dotted decimal form, or from an IPv6 address in hexadecimal notation. 


  address make_address(
      string_view str,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:operator_not__eq_ ip::address::operator!=]

[indexterm2 boost_asio.indexterm.ip__address.operator_not__eq_..operator!=..ip::address] 
Compare two addresses for inequality. 


  friend bool operator!=(
      const address & a1,
      const address & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_lt_ ip::address::operator<]

[indexterm2 boost_asio.indexterm.ip__address.operator_lt_..operator<..ip::address] 
Compare addresses for ordering. 


  friend bool operator<(
      const address & a1,
      const address & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_lt__lt_ ip::address::operator<<]

[indexterm2 boost_asio.indexterm.ip__address.operator_lt__lt_..operator<<..ip::address] 
Output an address as a string. 


  template<
      typename Elem,
      typename Traits>
  std::basic_ostream< Elem, Traits > & operator<<(
      std::basic_ostream< Elem, Traits > & os,
      const address & addr);


Used to output a human-readable string for a specified address.


[heading Parameters]
    

[variablelist
  
[[os][The output stream to which the string will be written.]]

[[addr][The address to be written.]]

]


[heading Return Value]
      
The output stream. 




[endsect]



[section:operator_lt__eq_ ip::address::operator<=]

[indexterm2 boost_asio.indexterm.ip__address.operator_lt__eq_..operator<=..ip::address] 
Compare addresses for ordering. 


  friend bool operator<=(
      const address & a1,
      const address & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:operator_eq_ ip::address::operator=]

[indexterm2 boost_asio.indexterm.ip__address.operator_eq_..operator=..ip::address] 
Assign from another address. 


  address & ``[link boost_asio.reference.ip__address.operator_eq_.overload1 operator=]``(
      const address & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.operator_eq_.overload1 more...]]``


Assign from an IPv4 address. 


  address & ``[link boost_asio.reference.ip__address.operator_eq_.overload2 operator=]``(
      const boost::asio::ip::address_v4 & ipv4_address);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.operator_eq_.overload2 more...]]``


Assign from an IPv6 address. 


  address & ``[link boost_asio.reference.ip__address.operator_eq_.overload3 operator=]``(
      const boost::asio::ip::address_v6 & ipv6_address);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.operator_eq_.overload3 more...]]``


[section:overload1 ip::address::operator= (1 of 3 overloads)]


Assign from another address. 


  address & operator=(
      const address & other);



[endsect]



[section:overload2 ip::address::operator= (2 of 3 overloads)]


Assign from an IPv4 address. 


  address & operator=(
      const boost::asio::ip::address_v4 & ipv4_address);



[endsect]



[section:overload3 ip::address::operator= (3 of 3 overloads)]


Assign from an IPv6 address. 


  address & operator=(
      const boost::asio::ip::address_v6 & ipv6_address);



[endsect]


[endsect]


[section:operator_eq__eq_ ip::address::operator==]

[indexterm2 boost_asio.indexterm.ip__address.operator_eq__eq_..operator==..ip::address] 
Compare two addresses for equality. 


  friend bool operator==(
      const address & a1,
      const address & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt_ ip::address::operator>]

[indexterm2 boost_asio.indexterm.ip__address.operator_gt_..operator>..ip::address] 
Compare addresses for ordering. 


  friend bool operator>(
      const address & a1,
      const address & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt__eq_ ip::address::operator>=]

[indexterm2 boost_asio.indexterm.ip__address.operator_gt__eq_..operator>=..ip::address] 
Compare addresses for ordering. 


  friend bool operator>=(
      const address & a1,
      const address & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:to_string ip::address::to_string]

[indexterm2 boost_asio.indexterm.ip__address.to_string..to_string..ip::address] 
Get the address as a string. 


  std::string ``[link boost_asio.reference.ip__address.to_string.overload1 to_string]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.to_string.overload1 more...]]``


(Deprecated: Use other overload.) Get the address as a string. 


  std::string ``[link boost_asio.reference.ip__address.to_string.overload2 to_string]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address.to_string.overload2 more...]]``


[section:overload1 ip::address::to_string (1 of 2 overloads)]


Get the address as a string. 


  std::string to_string() const;



[endsect]



[section:overload2 ip::address::to_string (2 of 2 overloads)]


(Deprecated: Use other overload.) Get the address as a string. 


  std::string to_string(
      boost::system::error_code & ec) const;



[endsect]


[endsect]


[section:to_v4 ip::address::to_v4]

[indexterm2 boost_asio.indexterm.ip__address.to_v4..to_v4..ip::address] 
Get the address as an IP version 4 address. 


  boost::asio::ip::address_v4 to_v4() const;



[endsect]



[section:to_v6 ip::address::to_v6]

[indexterm2 boost_asio.indexterm.ip__address.to_v6..to_v6..ip::address] 
Get the address as an IP version 6 address. 


  boost::asio::ip::address_v6 to_v6() const;



[endsect]



[endsect]

[section:ip__address_v4 ip::address_v4]

[indexterm1 boost_asio.indexterm.ip__address_v4..ip::address_v4]


Implements IP version 4 style addresses. 


  class address_v4


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__address_v4.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

  [

    [[link boost_asio.reference.ip__address_v4.uint_type [*uint_type]]]
    [The type used to represent an address as an unsigned integer. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v4.address_v4 [*address_v4]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an address from raw bytes. 
     [hr]
     Construct an address from an unsigned integer in host byte order. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.any [*any]] [static]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.broadcast [*broadcast]] [static]]
    [Obtain an address object that represents the broadcast address. 
     [hr]
     (Deprecated: Use network_v4 class.) Obtain an address object that represents the broadcast address that corresponds to the specified address and netmask. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.from_string [*from_string]] [static]]
    [(Deprecated: Use make_address_v4().) Create an address from an IP address string in dotted decimal form. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_class_a [*is_class_a]]]
    [(Deprecated: Use network_v4 class.) Determine whether the address is a class A address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_class_b [*is_class_b]]]
    [(Deprecated: Use network_v4 class.) Determine whether the address is a class B address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_class_c [*is_class_c]]]
    [(Deprecated: Use network_v4 class.) Determine whether the address is a class C address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.loopback [*loopback]] [static]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.netmask [*netmask]] [static]]
    [(Deprecated: Use network_v4 class.) Obtain the netmask that corresponds to the address, based on its address class. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.to_string [*to_string]]]
    [Get the address as a string in dotted decimal format. 
     [hr]
     (Deprecated: Use other overload.) Get the address as a string in dotted decimal format. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.to_uint [*to_uint]]]
    [Get the address as an unsigned integer in host byte order. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.to_ulong [*to_ulong]]]
    [Get the address as an unsigned long in host byte order. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v4.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v4.make_address_v4 [*make_address_v4]]]
    [Create an IPv4 address from raw bytes in network order. 

     Create an IPv4 address from an unsigned integer in host byte order. 

     Create an IPv4 address from an IP address string in dotted decimal form. 

     Create an IPv4 address from a IPv4-mapped IPv6 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.make_network_v4 [*make_network_v4]]]
    [Create an IPv4 network from an address and prefix length. 

     Create an IPv4 network from an address and netmask. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_lt__lt_ [*operator<<]]]
    [Output an address as a string. 

     Output a network as a string. ]
  ]
  
]

The [link boost_asio.reference.ip__address_v4 `ip::address_v4`] class provides the ability to use and manipulate IP version 4 addresses.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/address_v4.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:address_v4 ip::address_v4::address_v4]

[indexterm2 boost_asio.indexterm.ip__address_v4.address_v4..address_v4..ip::address_v4] 
Default constructor. 


  ``[link boost_asio.reference.ip__address_v4.address_v4.overload1 address_v4]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.address_v4.overload1 more...]]``


Construct an address from raw bytes. 


  explicit ``[link boost_asio.reference.ip__address_v4.address_v4.overload2 address_v4]``(
      const bytes_type & bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.address_v4.overload2 more...]]``


Construct an address from an unsigned integer in host byte order. 


  explicit ``[link boost_asio.reference.ip__address_v4.address_v4.overload3 address_v4]``(
      uint_type addr);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.address_v4.overload3 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.ip__address_v4.address_v4.overload4 address_v4]``(
      const address_v4 & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.address_v4.overload4 more...]]``


[section:overload1 ip::address_v4::address_v4 (1 of 4 overloads)]


Default constructor. 


  address_v4();



[endsect]



[section:overload2 ip::address_v4::address_v4 (2 of 4 overloads)]


Construct an address from raw bytes. 


  address_v4(
      const bytes_type & bytes);



[endsect]



[section:overload3 ip::address_v4::address_v4 (3 of 4 overloads)]


Construct an address from an unsigned integer in host byte order. 


  address_v4(
      uint_type addr);



[endsect]



[section:overload4 ip::address_v4::address_v4 (4 of 4 overloads)]


Copy constructor. 


  address_v4(
      const address_v4 & other);



[endsect]


[endsect]


[section:any ip::address_v4::any]

[indexterm2 boost_asio.indexterm.ip__address_v4.any..any..ip::address_v4] 
Obtain an address object that represents any address. 


  static address_v4 any();



[endsect]


[section:broadcast ip::address_v4::broadcast]

[indexterm2 boost_asio.indexterm.ip__address_v4.broadcast..broadcast..ip::address_v4] 
Obtain an address object that represents the broadcast address. 


  static address_v4 ``[link boost_asio.reference.ip__address_v4.broadcast.overload1 broadcast]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.broadcast.overload1 more...]]``


(Deprecated: Use [link boost_asio.reference.ip__network_v4 `ip::network_v4`] class.) Obtain an address object that represents the broadcast address that corresponds to the specified address and netmask. 


  static address_v4 ``[link boost_asio.reference.ip__address_v4.broadcast.overload2 broadcast]``(
      const address_v4 & addr,
      const address_v4 & mask);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.broadcast.overload2 more...]]``


[section:overload1 ip::address_v4::broadcast (1 of 2 overloads)]


Obtain an address object that represents the broadcast address. 


  static address_v4 broadcast();



[endsect]



[section:overload2 ip::address_v4::broadcast (2 of 2 overloads)]


(Deprecated: Use [link boost_asio.reference.ip__network_v4 `ip::network_v4`] class.) Obtain an address object that represents the broadcast address that corresponds to the specified address and netmask. 


  static address_v4 broadcast(
      const address_v4 & addr,
      const address_v4 & mask);



[endsect]


[endsect]


[section:bytes_type ip::address_v4::bytes_type]

[indexterm2 boost_asio.indexterm.ip__address_v4.bytes_type..bytes_type..ip::address_v4] 
The type used to represent an address as an array of bytes. 


  typedef array< unsigned char, 4 > bytes_type;




[heading Remarks]
      
This type is defined in terms of the C++0x template `std::array` when it is available. Otherwise, it uses `boost:array`. 



[heading Requirements]

['Header: ][^boost/asio/ip/address_v4.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:from_string ip::address_v4::from_string]

[indexterm2 boost_asio.indexterm.ip__address_v4.from_string..from_string..ip::address_v4] 
(Deprecated: Use `make_address_v4()`.) Create an address from an IP address string in dotted decimal form. 


  static address_v4 ``[link boost_asio.reference.ip__address_v4.from_string.overload1 from_string]``(
      const char * str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.from_string.overload1 more...]]``

  static address_v4 ``[link boost_asio.reference.ip__address_v4.from_string.overload2 from_string]``(
      const char * str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.from_string.overload2 more...]]``

  static address_v4 ``[link boost_asio.reference.ip__address_v4.from_string.overload3 from_string]``(
      const std::string & str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.from_string.overload3 more...]]``

  static address_v4 ``[link boost_asio.reference.ip__address_v4.from_string.overload4 from_string]``(
      const std::string & str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.from_string.overload4 more...]]``


[section:overload1 ip::address_v4::from_string (1 of 4 overloads)]


(Deprecated: Use `make_address_v4()`.) Create an address from an IP address string in dotted decimal form. 


  static address_v4 from_string(
      const char * str);



[endsect]



[section:overload2 ip::address_v4::from_string (2 of 4 overloads)]


(Deprecated: Use `make_address_v4()`.) Create an address from an IP address string in dotted decimal form. 


  static address_v4 from_string(
      const char * str,
      boost::system::error_code & ec);



[endsect]



[section:overload3 ip::address_v4::from_string (3 of 4 overloads)]


(Deprecated: Use `make_address_v4()`.) Create an address from an IP address string in dotted decimal form. 


  static address_v4 from_string(
      const std::string & str);



[endsect]



[section:overload4 ip::address_v4::from_string (4 of 4 overloads)]


(Deprecated: Use `make_address_v4()`.) Create an address from an IP address string in dotted decimal form. 


  static address_v4 from_string(
      const std::string & str,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:is_class_a ip::address_v4::is_class_a]

[indexterm2 boost_asio.indexterm.ip__address_v4.is_class_a..is_class_a..ip::address_v4] 
(Deprecated: Use [link boost_asio.reference.ip__network_v4 `ip::network_v4`] class.) Determine whether the address is a class A address. 


  bool is_class_a() const;



[endsect]



[section:is_class_b ip::address_v4::is_class_b]

[indexterm2 boost_asio.indexterm.ip__address_v4.is_class_b..is_class_b..ip::address_v4] 
(Deprecated: Use [link boost_asio.reference.ip__network_v4 `ip::network_v4`] class.) Determine whether the address is a class B address. 


  bool is_class_b() const;



[endsect]



[section:is_class_c ip::address_v4::is_class_c]

[indexterm2 boost_asio.indexterm.ip__address_v4.is_class_c..is_class_c..ip::address_v4] 
(Deprecated: Use [link boost_asio.reference.ip__network_v4 `ip::network_v4`] class.) Determine whether the address is a class C address. 


  bool is_class_c() const;



[endsect]



[section:is_loopback ip::address_v4::is_loopback]

[indexterm2 boost_asio.indexterm.ip__address_v4.is_loopback..is_loopback..ip::address_v4] 
Determine whether the address is a loopback address. 


  bool is_loopback() const;



[endsect]



[section:is_multicast ip::address_v4::is_multicast]

[indexterm2 boost_asio.indexterm.ip__address_v4.is_multicast..is_multicast..ip::address_v4] 
Determine whether the address is a multicast address. 


  bool is_multicast() const;



[endsect]



[section:is_unspecified ip::address_v4::is_unspecified]

[indexterm2 boost_asio.indexterm.ip__address_v4.is_unspecified..is_unspecified..ip::address_v4] 
Determine whether the address is unspecified. 


  bool is_unspecified() const;



[endsect]



[section:loopback ip::address_v4::loopback]

[indexterm2 boost_asio.indexterm.ip__address_v4.loopback..loopback..ip::address_v4] 
Obtain an address object that represents the loopback address. 


  static address_v4 loopback();



[endsect]


[section:make_address_v4 ip::address_v4::make_address_v4]

[indexterm2 boost_asio.indexterm.ip__address_v4.make_address_v4..make_address_v4..ip::address_v4] 
Create an IPv4 address from raw bytes in network order. 


  address_v4 ``[link boost_asio.reference.ip__address_v4.make_address_v4.overload1 make_address_v4]``(
      const address_v4::bytes_type & bytes);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.make_address_v4.overload1 more...]]``


Create an IPv4 address from an unsigned integer in host byte order. 


  address_v4 ``[link boost_asio.reference.ip__address_v4.make_address_v4.overload2 make_address_v4]``(
      address_v4::uint_type addr);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.make_address_v4.overload2 more...]]``


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 ``[link boost_asio.reference.ip__address_v4.make_address_v4.overload3 make_address_v4]``(
      const char * str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.make_address_v4.overload3 more...]]``

  address_v4 ``[link boost_asio.reference.ip__address_v4.make_address_v4.overload4 make_address_v4]``(
      const char * str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.make_address_v4.overload4 more...]]``

  address_v4 ``[link boost_asio.reference.ip__address_v4.make_address_v4.overload5 make_address_v4]``(
      const std::string & str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.make_address_v4.overload5 more...]]``

  address_v4 ``[link boost_asio.reference.ip__address_v4.make_address_v4.overload6 make_address_v4]``(
      const std::string & str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.make_address_v4.overload6 more...]]``

  address_v4 ``[link boost_asio.reference.ip__address_v4.make_address_v4.overload7 make_address_v4]``(
      string_view str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.make_address_v4.overload7 more...]]``

  address_v4 ``[link boost_asio.reference.ip__address_v4.make_address_v4.overload8 make_address_v4]``(
      string_view str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.make_address_v4.overload8 more...]]``


Create an IPv4 address from a IPv4-mapped IPv6 address. 


  address_v4 ``[link boost_asio.reference.ip__address_v4.make_address_v4.overload9 make_address_v4]``(
      v4_mapped_t ,
      const address_v6 & v6_addr);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.make_address_v4.overload9 more...]]``


[section:overload1 ip::address_v4::make_address_v4 (1 of 9 overloads)]


Create an IPv4 address from raw bytes in network order. 


  address_v4 make_address_v4(
      const address_v4::bytes_type & bytes);



[endsect]



[section:overload2 ip::address_v4::make_address_v4 (2 of 9 overloads)]


Create an IPv4 address from an unsigned integer in host byte order. 


  address_v4 make_address_v4(
      address_v4::uint_type addr);



[endsect]



[section:overload3 ip::address_v4::make_address_v4 (3 of 9 overloads)]


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 make_address_v4(
      const char * str);



[endsect]



[section:overload4 ip::address_v4::make_address_v4 (4 of 9 overloads)]


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 make_address_v4(
      const char * str,
      boost::system::error_code & ec);



[endsect]



[section:overload5 ip::address_v4::make_address_v4 (5 of 9 overloads)]


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 make_address_v4(
      const std::string & str);



[endsect]



[section:overload6 ip::address_v4::make_address_v4 (6 of 9 overloads)]


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 make_address_v4(
      const std::string & str,
      boost::system::error_code & ec);



[endsect]



[section:overload7 ip::address_v4::make_address_v4 (7 of 9 overloads)]


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 make_address_v4(
      string_view str);



[endsect]



[section:overload8 ip::address_v4::make_address_v4 (8 of 9 overloads)]


Create an IPv4 address from an IP address string in dotted decimal form. 


  address_v4 make_address_v4(
      string_view str,
      boost::system::error_code & ec);



[endsect]



[section:overload9 ip::address_v4::make_address_v4 (9 of 9 overloads)]


Create an IPv4 address from a IPv4-mapped IPv6 address. 


  address_v4 make_address_v4(
      v4_mapped_t ,
      const address_v6 & v6_addr);



[endsect]


[endsect]

[section:make_network_v4 ip::address_v4::make_network_v4]

[indexterm2 boost_asio.indexterm.ip__address_v4.make_network_v4..make_network_v4..ip::address_v4] 
Create an IPv4 network from an address and prefix length. 


  network_v4 ``[link boost_asio.reference.ip__address_v4.make_network_v4.overload1 make_network_v4]``(
      const address_v4 & addr,
      unsigned short prefix_len);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.make_network_v4.overload1 more...]]``


Create an IPv4 network from an address and netmask. 


  network_v4 ``[link boost_asio.reference.ip__address_v4.make_network_v4.overload2 make_network_v4]``(
      const address_v4 & addr,
      const address_v4 & mask);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.make_network_v4.overload2 more...]]``


[section:overload1 ip::address_v4::make_network_v4 (1 of 2 overloads)]


Create an IPv4 network from an address and prefix length. 


  network_v4 make_network_v4(
      const address_v4 & addr,
      unsigned short prefix_len);



[endsect]



[section:overload2 ip::address_v4::make_network_v4 (2 of 2 overloads)]


Create an IPv4 network from an address and netmask. 


  network_v4 make_network_v4(
      const address_v4 & addr,
      const address_v4 & mask);



[endsect]


[endsect]


[section:netmask ip::address_v4::netmask]

[indexterm2 boost_asio.indexterm.ip__address_v4.netmask..netmask..ip::address_v4] 
(Deprecated: Use [link boost_asio.reference.ip__network_v4 `ip::network_v4`] class.) Obtain the netmask that corresponds to the address, based on its address class. 


  static address_v4 netmask(
      const address_v4 & addr);



[endsect]



[section:operator_not__eq_ ip::address_v4::operator!=]

[indexterm2 boost_asio.indexterm.ip__address_v4.operator_not__eq_..operator!=..ip::address_v4] 
Compare two addresses for inequality. 


  friend bool operator!=(
      const address_v4 & a1,
      const address_v4 & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v4.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_lt_ ip::address_v4::operator<]

[indexterm2 boost_asio.indexterm.ip__address_v4.operator_lt_..operator<..ip::address_v4] 
Compare addresses for ordering. 


  friend bool operator<(
      const address_v4 & a1,
      const address_v4 & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v4.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:operator_lt__lt_ ip::address_v4::operator<<]

[indexterm2 boost_asio.indexterm.ip__address_v4.operator_lt__lt_..operator<<..ip::address_v4] 
Output an address as a string. 


  template<
      typename Elem,
      typename Traits>
  std::basic_ostream< Elem, Traits > & ``[link boost_asio.reference.ip__address_v4.operator_lt__lt_.overload1 operator<<]``(
      std::basic_ostream< Elem, Traits > & os,
      const address_v4 & addr);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.operator_lt__lt_.overload1 more...]]``


Output a network as a string. 


  template<
      typename Elem,
      typename Traits>
  std::basic_ostream< Elem, Traits > & ``[link boost_asio.reference.ip__address_v4.operator_lt__lt_.overload2 operator<<]``(
      std::basic_ostream< Elem, Traits > & os,
      const network_v4 & net);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.operator_lt__lt_.overload2 more...]]``


[section:overload1 ip::address_v4::operator<< (1 of 2 overloads)]


Output an address as a string. 


  template<
      typename Elem,
      typename Traits>
  std::basic_ostream< Elem, Traits > & operator<<(
      std::basic_ostream< Elem, Traits > & os,
      const address_v4 & addr);


Used to output a human-readable string for a specified address.


[heading Parameters]
    

[variablelist
  
[[os][The output stream to which the string will be written.]]

[[addr][The address to be written.]]

]


[heading Return Value]
      
The output stream. 




[endsect]



[section:overload2 ip::address_v4::operator<< (2 of 2 overloads)]


Output a network as a string. 


  template<
      typename Elem,
      typename Traits>
  std::basic_ostream< Elem, Traits > & operator<<(
      std::basic_ostream< Elem, Traits > & os,
      const network_v4 & net);


Used to output a human-readable string for a specified network.


[heading Parameters]
    

[variablelist
  
[[os][The output stream to which the string will be written.]]

[[net][The network to be written.]]

]


[heading Return Value]
      
The output stream. 




[endsect]


[endsect]


[section:operator_lt__eq_ ip::address_v4::operator<=]

[indexterm2 boost_asio.indexterm.ip__address_v4.operator_lt__eq_..operator<=..ip::address_v4] 
Compare addresses for ordering. 


  friend bool operator<=(
      const address_v4 & a1,
      const address_v4 & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v4.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ ip::address_v4::operator=]

[indexterm2 boost_asio.indexterm.ip__address_v4.operator_eq_..operator=..ip::address_v4] 
Assign from another address. 


  address_v4 & operator=(
      const address_v4 & other);



[endsect]



[section:operator_eq__eq_ ip::address_v4::operator==]

[indexterm2 boost_asio.indexterm.ip__address_v4.operator_eq__eq_..operator==..ip::address_v4] 
Compare two addresses for equality. 


  friend bool operator==(
      const address_v4 & a1,
      const address_v4 & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v4.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt_ ip::address_v4::operator>]

[indexterm2 boost_asio.indexterm.ip__address_v4.operator_gt_..operator>..ip::address_v4] 
Compare addresses for ordering. 


  friend bool operator>(
      const address_v4 & a1,
      const address_v4 & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v4.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt__eq_ ip::address_v4::operator>=]

[indexterm2 boost_asio.indexterm.ip__address_v4.operator_gt__eq_..operator>=..ip::address_v4] 
Compare addresses for ordering. 


  friend bool operator>=(
      const address_v4 & a1,
      const address_v4 & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v4.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:to_bytes ip::address_v4::to_bytes]

[indexterm2 boost_asio.indexterm.ip__address_v4.to_bytes..to_bytes..ip::address_v4] 
Get the address in bytes, in network byte order. 


  bytes_type to_bytes() const;



[endsect]


[section:to_string ip::address_v4::to_string]

[indexterm2 boost_asio.indexterm.ip__address_v4.to_string..to_string..ip::address_v4] 
Get the address as a string in dotted decimal format. 


  std::string ``[link boost_asio.reference.ip__address_v4.to_string.overload1 to_string]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.to_string.overload1 more...]]``


(Deprecated: Use other overload.) Get the address as a string in dotted decimal format. 


  std::string ``[link boost_asio.reference.ip__address_v4.to_string.overload2 to_string]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v4.to_string.overload2 more...]]``


[section:overload1 ip::address_v4::to_string (1 of 2 overloads)]


Get the address as a string in dotted decimal format. 


  std::string to_string() const;



[endsect]



[section:overload2 ip::address_v4::to_string (2 of 2 overloads)]


(Deprecated: Use other overload.) Get the address as a string in dotted decimal format. 


  std::string to_string(
      boost::system::error_code & ec) const;



[endsect]


[endsect]


[section:to_uint ip::address_v4::to_uint]

[indexterm2 boost_asio.indexterm.ip__address_v4.to_uint..to_uint..ip::address_v4] 
Get the address as an unsigned integer in host byte order. 


  uint_type to_uint() const;



[endsect]



[section:to_ulong ip::address_v4::to_ulong]

[indexterm2 boost_asio.indexterm.ip__address_v4.to_ulong..to_ulong..ip::address_v4] 
Get the address as an unsigned long in host byte order. 


  unsigned long to_ulong() const;



[endsect]



[section:uint_type ip::address_v4::uint_type]

[indexterm2 boost_asio.indexterm.ip__address_v4.uint_type..uint_type..ip::address_v4] 
The type used to represent an address as an unsigned integer. 


  typedef uint_least32_t uint_type;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v4.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]


[section:ip__address_v4_iterator ip::address_v4_iterator]

[indexterm1 boost_asio.indexterm.ip__address_v4_iterator..ip::address_v4_iterator] 
An input iterator that can be used for traversing IPv4 addresses. 


  typedef basic_address_iterator< address_v4 > address_v4_iterator;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v4_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:ip__address_v4_range ip::address_v4_range]

[indexterm1 boost_asio.indexterm.ip__address_v4_range..ip::address_v4_range] 
Represents a range of IPv4 addresses. 


  typedef basic_address_range< address_v4 > address_v4_range;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v4_range.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:ip__address_v6 ip::address_v6]

[indexterm1 boost_asio.indexterm.ip__address_v6..ip::address_v6]


Implements IP version 6 style addresses. 


  class address_v6


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__address_v6.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v6.address_v6 [*address_v6]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an address from raw bytes and scope ID. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.any [*any]] [static]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.from_string [*from_string]] [static]]
    [(Deprecated: Use make_address_v6().) Create an IPv6 address from an IP address string. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_link_local [*is_link_local]]]
    [Determine whether the address is link local. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_global [*is_multicast_global]]]
    [Determine whether the address is a global multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_link_local [*is_multicast_link_local]]]
    [Determine whether the address is a link-local multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_node_local [*is_multicast_node_local]]]
    [Determine whether the address is a node-local multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_org_local [*is_multicast_org_local]]]
    [Determine whether the address is a org-local multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_site_local [*is_multicast_site_local]]]
    [Determine whether the address is a site-local multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_site_local [*is_site_local]]]
    [Determine whether the address is site local. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_v4_compatible [*is_v4_compatible]]]
    [(Deprecated: No replacement.) Determine whether the address is an IPv4-compatible address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_v4_mapped [*is_v4_mapped]]]
    [Determine whether the address is a mapped IPv4 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.loopback [*loopback]] [static]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.scope_id [*scope_id]]]
    [The scope ID of the address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.to_string [*to_string]]]
    [Get the address as a string. 
     [hr]
     (Deprecated: Use other overload.) Get the address as a string. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.to_v4 [*to_v4]]]
    [(Deprecated: Use make_address_v4().) Converts an IPv4-mapped or IPv4-compatible address to an IPv4 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.v4_compatible [*v4_compatible]] [static]]
    [(Deprecated: No replacement.) Create an IPv4-compatible IPv6 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.v4_mapped [*v4_mapped]] [static]]
    [(Deprecated: Use make_address_v6().) Create an IPv4-mapped IPv6 address. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v6.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v6.make_address_v6 [*make_address_v6]]]
    [Create an IPv6 address from raw bytes and scope ID. 

     Create an IPv6 address from an IP address string. 

     Createan IPv6 address from an IP address string. 

     Create an IPv4-mapped IPv6 address from an IPv4 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.make_network_v6 [*make_network_v6]]]
    [Create an IPv6 network from an address and prefix length. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_lt__lt_ [*operator<<]]]
    [Output an address as a string. 

     Output a network as a string. ]
  ]
  
]

The [link boost_asio.reference.ip__address_v6 `ip::address_v6`] class provides the ability to use and manipulate IP version 6 addresses.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/address_v6.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:address_v6 ip::address_v6::address_v6]

[indexterm2 boost_asio.indexterm.ip__address_v6.address_v6..address_v6..ip::address_v6] 
Default constructor. 


  ``[link boost_asio.reference.ip__address_v6.address_v6.overload1 address_v6]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.address_v6.overload1 more...]]``


Construct an address from raw bytes and scope ID. 


  explicit ``[link boost_asio.reference.ip__address_v6.address_v6.overload2 address_v6]``(
      const bytes_type & bytes,
      scope_id_type scope_id = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.address_v6.overload2 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.ip__address_v6.address_v6.overload3 address_v6]``(
      const address_v6 & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.address_v6.overload3 more...]]``


[section:overload1 ip::address_v6::address_v6 (1 of 3 overloads)]


Default constructor. 


  address_v6();



[endsect]



[section:overload2 ip::address_v6::address_v6 (2 of 3 overloads)]


Construct an address from raw bytes and scope ID. 


  address_v6(
      const bytes_type & bytes,
      scope_id_type scope_id = 0);



[endsect]



[section:overload3 ip::address_v6::address_v6 (3 of 3 overloads)]


Copy constructor. 


  address_v6(
      const address_v6 & other);



[endsect]


[endsect]


[section:any ip::address_v6::any]

[indexterm2 boost_asio.indexterm.ip__address_v6.any..any..ip::address_v6] 
Obtain an address object that represents any address. 


  static address_v6 any();



[endsect]



[section:bytes_type ip::address_v6::bytes_type]

[indexterm2 boost_asio.indexterm.ip__address_v6.bytes_type..bytes_type..ip::address_v6] 
The type used to represent an address as an array of bytes. 


  typedef array< unsigned char, 16 > bytes_type;




[heading Remarks]
      
This type is defined in terms of the C++0x template `std::array` when it is available. Otherwise, it uses `boost:array`. 



[heading Requirements]

['Header: ][^boost/asio/ip/address_v6.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:from_string ip::address_v6::from_string]

[indexterm2 boost_asio.indexterm.ip__address_v6.from_string..from_string..ip::address_v6] 
(Deprecated: Use `make_address_v6()`.) Create an IPv6 address from an IP address string. 


  static address_v6 ``[link boost_asio.reference.ip__address_v6.from_string.overload1 from_string]``(
      const char * str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.from_string.overload1 more...]]``

  static address_v6 ``[link boost_asio.reference.ip__address_v6.from_string.overload2 from_string]``(
      const char * str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.from_string.overload2 more...]]``

  static address_v6 ``[link boost_asio.reference.ip__address_v6.from_string.overload3 from_string]``(
      const std::string & str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.from_string.overload3 more...]]``

  static address_v6 ``[link boost_asio.reference.ip__address_v6.from_string.overload4 from_string]``(
      const std::string & str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.from_string.overload4 more...]]``


[section:overload1 ip::address_v6::from_string (1 of 4 overloads)]


(Deprecated: Use `make_address_v6()`.) Create an IPv6 address from an IP address string. 


  static address_v6 from_string(
      const char * str);



[endsect]



[section:overload2 ip::address_v6::from_string (2 of 4 overloads)]


(Deprecated: Use `make_address_v6()`.) Create an IPv6 address from an IP address string. 


  static address_v6 from_string(
      const char * str,
      boost::system::error_code & ec);



[endsect]



[section:overload3 ip::address_v6::from_string (3 of 4 overloads)]


(Deprecated: Use `make_address_v6()`.) Create an IPv6 address from an IP address string. 


  static address_v6 from_string(
      const std::string & str);



[endsect]



[section:overload4 ip::address_v6::from_string (4 of 4 overloads)]


(Deprecated: Use `make_address_v6()`.) Create an IPv6 address from an IP address string. 


  static address_v6 from_string(
      const std::string & str,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:is_link_local ip::address_v6::is_link_local]

[indexterm2 boost_asio.indexterm.ip__address_v6.is_link_local..is_link_local..ip::address_v6] 
Determine whether the address is link local. 


  bool is_link_local() const;



[endsect]



[section:is_loopback ip::address_v6::is_loopback]

[indexterm2 boost_asio.indexterm.ip__address_v6.is_loopback..is_loopback..ip::address_v6] 
Determine whether the address is a loopback address. 


  bool is_loopback() const;



[endsect]



[section:is_multicast ip::address_v6::is_multicast]

[indexterm2 boost_asio.indexterm.ip__address_v6.is_multicast..is_multicast..ip::address_v6] 
Determine whether the address is a multicast address. 


  bool is_multicast() const;



[endsect]



[section:is_multicast_global ip::address_v6::is_multicast_global]

[indexterm2 boost_asio.indexterm.ip__address_v6.is_multicast_global..is_multicast_global..ip::address_v6] 
Determine whether the address is a global multicast address. 


  bool is_multicast_global() const;



[endsect]



[section:is_multicast_link_local ip::address_v6::is_multicast_link_local]

[indexterm2 boost_asio.indexterm.ip__address_v6.is_multicast_link_local..is_multicast_link_local..ip::address_v6] 
Determine whether the address is a link-local multicast address. 


  bool is_multicast_link_local() const;



[endsect]



[section:is_multicast_node_local ip::address_v6::is_multicast_node_local]

[indexterm2 boost_asio.indexterm.ip__address_v6.is_multicast_node_local..is_multicast_node_local..ip::address_v6] 
Determine whether the address is a node-local multicast address. 


  bool is_multicast_node_local() const;



[endsect]



[section:is_multicast_org_local ip::address_v6::is_multicast_org_local]

[indexterm2 boost_asio.indexterm.ip__address_v6.is_multicast_org_local..is_multicast_org_local..ip::address_v6] 
Determine whether the address is a org-local multicast address. 


  bool is_multicast_org_local() const;



[endsect]



[section:is_multicast_site_local ip::address_v6::is_multicast_site_local]

[indexterm2 boost_asio.indexterm.ip__address_v6.is_multicast_site_local..is_multicast_site_local..ip::address_v6] 
Determine whether the address is a site-local multicast address. 


  bool is_multicast_site_local() const;



[endsect]



[section:is_site_local ip::address_v6::is_site_local]

[indexterm2 boost_asio.indexterm.ip__address_v6.is_site_local..is_site_local..ip::address_v6] 
Determine whether the address is site local. 


  bool is_site_local() const;



[endsect]



[section:is_unspecified ip::address_v6::is_unspecified]

[indexterm2 boost_asio.indexterm.ip__address_v6.is_unspecified..is_unspecified..ip::address_v6] 
Determine whether the address is unspecified. 


  bool is_unspecified() const;



[endsect]



[section:is_v4_compatible ip::address_v6::is_v4_compatible]

[indexterm2 boost_asio.indexterm.ip__address_v6.is_v4_compatible..is_v4_compatible..ip::address_v6] 
(Deprecated: No replacement.) Determine whether the address is an IPv4-compatible address. 


  bool is_v4_compatible() const;



[endsect]



[section:is_v4_mapped ip::address_v6::is_v4_mapped]

[indexterm2 boost_asio.indexterm.ip__address_v6.is_v4_mapped..is_v4_mapped..ip::address_v6] 
Determine whether the address is a mapped IPv4 address. 


  bool is_v4_mapped() const;



[endsect]



[section:loopback ip::address_v6::loopback]

[indexterm2 boost_asio.indexterm.ip__address_v6.loopback..loopback..ip::address_v6] 
Obtain an address object that represents the loopback address. 


  static address_v6 loopback();



[endsect]


[section:make_address_v6 ip::address_v6::make_address_v6]

[indexterm2 boost_asio.indexterm.ip__address_v6.make_address_v6..make_address_v6..ip::address_v6] 
Create an IPv6 address from raw bytes and scope ID. 


  address_v6 ``[link boost_asio.reference.ip__address_v6.make_address_v6.overload1 make_address_v6]``(
      const address_v6::bytes_type & bytes,
      scope_id_type scope_id = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.make_address_v6.overload1 more...]]``


Create an IPv6 address from an IP address string. 


  address_v6 ``[link boost_asio.reference.ip__address_v6.make_address_v6.overload2 make_address_v6]``(
      const char * str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.make_address_v6.overload2 more...]]``

  address_v6 ``[link boost_asio.reference.ip__address_v6.make_address_v6.overload3 make_address_v6]``(
      const char * str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.make_address_v6.overload3 more...]]``


Createan IPv6 address from an IP address string. 


  address_v6 ``[link boost_asio.reference.ip__address_v6.make_address_v6.overload4 make_address_v6]``(
      const std::string & str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.make_address_v6.overload4 more...]]``

  address_v6 ``[link boost_asio.reference.ip__address_v6.make_address_v6.overload5 make_address_v6]``(
      const std::string & str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.make_address_v6.overload5 more...]]``

  address_v6 ``[link boost_asio.reference.ip__address_v6.make_address_v6.overload6 make_address_v6]``(
      string_view str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.make_address_v6.overload6 more...]]``

  address_v6 ``[link boost_asio.reference.ip__address_v6.make_address_v6.overload7 make_address_v6]``(
      string_view str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.make_address_v6.overload7 more...]]``


Create an IPv4-mapped IPv6 address from an IPv4 address. 


  address_v6 ``[link boost_asio.reference.ip__address_v6.make_address_v6.overload8 make_address_v6]``(
      v4_mapped_t ,
      const address_v4 & v4_addr);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.make_address_v6.overload8 more...]]``


[section:overload1 ip::address_v6::make_address_v6 (1 of 8 overloads)]


Create an IPv6 address from raw bytes and scope ID. 


  address_v6 make_address_v6(
      const address_v6::bytes_type & bytes,
      scope_id_type scope_id = 0);



[endsect]



[section:overload2 ip::address_v6::make_address_v6 (2 of 8 overloads)]


Create an IPv6 address from an IP address string. 


  address_v6 make_address_v6(
      const char * str);



[endsect]



[section:overload3 ip::address_v6::make_address_v6 (3 of 8 overloads)]


Create an IPv6 address from an IP address string. 


  address_v6 make_address_v6(
      const char * str,
      boost::system::error_code & ec);



[endsect]



[section:overload4 ip::address_v6::make_address_v6 (4 of 8 overloads)]


Createan IPv6 address from an IP address string. 


  address_v6 make_address_v6(
      const std::string & str);



[endsect]



[section:overload5 ip::address_v6::make_address_v6 (5 of 8 overloads)]


Create an IPv6 address from an IP address string. 


  address_v6 make_address_v6(
      const std::string & str,
      boost::system::error_code & ec);



[endsect]



[section:overload6 ip::address_v6::make_address_v6 (6 of 8 overloads)]


Create an IPv6 address from an IP address string. 


  address_v6 make_address_v6(
      string_view str);



[endsect]



[section:overload7 ip::address_v6::make_address_v6 (7 of 8 overloads)]


Create an IPv6 address from an IP address string. 


  address_v6 make_address_v6(
      string_view str,
      boost::system::error_code & ec);



[endsect]



[section:overload8 ip::address_v6::make_address_v6 (8 of 8 overloads)]


Create an IPv4-mapped IPv6 address from an IPv4 address. 


  address_v6 make_address_v6(
      v4_mapped_t ,
      const address_v4 & v4_addr);



[endsect]


[endsect]


[section:make_network_v6 ip::address_v6::make_network_v6]

[indexterm2 boost_asio.indexterm.ip__address_v6.make_network_v6..make_network_v6..ip::address_v6] 
Create an IPv6 network from an address and prefix length. 


  network_v6 make_network_v6(
      const address_v6 & addr,
      unsigned short prefix_len);



[endsect]



[section:operator_not__eq_ ip::address_v6::operator!=]

[indexterm2 boost_asio.indexterm.ip__address_v6.operator_not__eq_..operator!=..ip::address_v6] 
Compare two addresses for inequality. 


  friend bool operator!=(
      const address_v6 & a1,
      const address_v6 & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v6.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_lt_ ip::address_v6::operator<]

[indexterm2 boost_asio.indexterm.ip__address_v6.operator_lt_..operator<..ip::address_v6] 
Compare addresses for ordering. 


  friend bool operator<(
      const address_v6 & a1,
      const address_v6 & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v6.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:operator_lt__lt_ ip::address_v6::operator<<]

[indexterm2 boost_asio.indexterm.ip__address_v6.operator_lt__lt_..operator<<..ip::address_v6] 
Output an address as a string. 


  template<
      typename Elem,
      typename Traits>
  std::basic_ostream< Elem, Traits > & ``[link boost_asio.reference.ip__address_v6.operator_lt__lt_.overload1 operator<<]``(
      std::basic_ostream< Elem, Traits > & os,
      const address_v6 & addr);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.operator_lt__lt_.overload1 more...]]``


Output a network as a string. 


  template<
      typename Elem,
      typename Traits>
  std::basic_ostream< Elem, Traits > & ``[link boost_asio.reference.ip__address_v6.operator_lt__lt_.overload2 operator<<]``(
      std::basic_ostream< Elem, Traits > & os,
      const network_v6 & net);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.operator_lt__lt_.overload2 more...]]``


[section:overload1 ip::address_v6::operator<< (1 of 2 overloads)]


Output an address as a string. 


  template<
      typename Elem,
      typename Traits>
  std::basic_ostream< Elem, Traits > & operator<<(
      std::basic_ostream< Elem, Traits > & os,
      const address_v6 & addr);


Used to output a human-readable string for a specified address.


[heading Parameters]
    

[variablelist
  
[[os][The output stream to which the string will be written.]]

[[addr][The address to be written.]]

]


[heading Return Value]
      
The output stream. 




[endsect]



[section:overload2 ip::address_v6::operator<< (2 of 2 overloads)]


Output a network as a string. 


  template<
      typename Elem,
      typename Traits>
  std::basic_ostream< Elem, Traits > & operator<<(
      std::basic_ostream< Elem, Traits > & os,
      const network_v6 & net);


Used to output a human-readable string for a specified network.


[heading Parameters]
    

[variablelist
  
[[os][The output stream to which the string will be written.]]

[[net][The network to be written.]]

]


[heading Return Value]
      
The output stream. 




[endsect]


[endsect]


[section:operator_lt__eq_ ip::address_v6::operator<=]

[indexterm2 boost_asio.indexterm.ip__address_v6.operator_lt__eq_..operator<=..ip::address_v6] 
Compare addresses for ordering. 


  friend bool operator<=(
      const address_v6 & a1,
      const address_v6 & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v6.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ ip::address_v6::operator=]

[indexterm2 boost_asio.indexterm.ip__address_v6.operator_eq_..operator=..ip::address_v6] 
Assign from another address. 


  address_v6 & operator=(
      const address_v6 & other);



[endsect]



[section:operator_eq__eq_ ip::address_v6::operator==]

[indexterm2 boost_asio.indexterm.ip__address_v6.operator_eq__eq_..operator==..ip::address_v6] 
Compare two addresses for equality. 


  friend bool operator==(
      const address_v6 & a1,
      const address_v6 & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v6.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt_ ip::address_v6::operator>]

[indexterm2 boost_asio.indexterm.ip__address_v6.operator_gt_..operator>..ip::address_v6] 
Compare addresses for ordering. 


  friend bool operator>(
      const address_v6 & a1,
      const address_v6 & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v6.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt__eq_ ip::address_v6::operator>=]

[indexterm2 boost_asio.indexterm.ip__address_v6.operator_gt__eq_..operator>=..ip::address_v6] 
Compare addresses for ordering. 


  friend bool operator>=(
      const address_v6 & a1,
      const address_v6 & a2);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v6.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:scope_id ip::address_v6::scope_id]

[indexterm2 boost_asio.indexterm.ip__address_v6.scope_id..scope_id..ip::address_v6] 
The scope ID of the address. 


  scope_id_type ``[link boost_asio.reference.ip__address_v6.scope_id.overload1 scope_id]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.scope_id.overload1 more...]]``

  void ``[link boost_asio.reference.ip__address_v6.scope_id.overload2 scope_id]``(
      scope_id_type id);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.scope_id.overload2 more...]]``


[section:overload1 ip::address_v6::scope_id (1 of 2 overloads)]


The scope ID of the address. 


  scope_id_type scope_id() const;


Returns the scope ID associated with the IPv6 address. 


[endsect]



[section:overload2 ip::address_v6::scope_id (2 of 2 overloads)]


The scope ID of the address. 


  void scope_id(
      scope_id_type id);


Modifies the scope ID associated with the IPv6 address. 


[endsect]


[endsect]


[section:to_bytes ip::address_v6::to_bytes]

[indexterm2 boost_asio.indexterm.ip__address_v6.to_bytes..to_bytes..ip::address_v6] 
Get the address in bytes, in network byte order. 


  bytes_type to_bytes() const;



[endsect]


[section:to_string ip::address_v6::to_string]

[indexterm2 boost_asio.indexterm.ip__address_v6.to_string..to_string..ip::address_v6] 
Get the address as a string. 


  std::string ``[link boost_asio.reference.ip__address_v6.to_string.overload1 to_string]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.to_string.overload1 more...]]``


(Deprecated: Use other overload.) Get the address as a string. 


  std::string ``[link boost_asio.reference.ip__address_v6.to_string.overload2 to_string]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__address_v6.to_string.overload2 more...]]``


[section:overload1 ip::address_v6::to_string (1 of 2 overloads)]


Get the address as a string. 


  std::string to_string() const;



[endsect]



[section:overload2 ip::address_v6::to_string (2 of 2 overloads)]


(Deprecated: Use other overload.) Get the address as a string. 


  std::string to_string(
      boost::system::error_code & ec) const;



[endsect]


[endsect]


[section:to_v4 ip::address_v6::to_v4]

[indexterm2 boost_asio.indexterm.ip__address_v6.to_v4..to_v4..ip::address_v6] 
(Deprecated: Use `make_address_v4()`.) Converts an IPv4-mapped or IPv4-compatible address to an IPv4 address. 


  address_v4 to_v4() const;



[endsect]



[section:v4_compatible ip::address_v6::v4_compatible]

[indexterm2 boost_asio.indexterm.ip__address_v6.v4_compatible..v4_compatible..ip::address_v6] 
(Deprecated: No replacement.) Create an IPv4-compatible IPv6 address. 


  static address_v6 v4_compatible(
      const address_v4 & addr);



[endsect]



[section:v4_mapped ip::address_v6::v4_mapped]

[indexterm2 boost_asio.indexterm.ip__address_v6.v4_mapped..v4_mapped..ip::address_v6] 
(Deprecated: Use `make_address_v6()`.) Create an IPv4-mapped IPv6 address. 


  static address_v6 v4_mapped(
      const address_v4 & addr);



[endsect]



[endsect]


[section:ip__address_v6_iterator ip::address_v6_iterator]

[indexterm1 boost_asio.indexterm.ip__address_v6_iterator..ip::address_v6_iterator] 
An input iterator that can be used for traversing IPv6 addresses. 


  typedef basic_address_iterator< address_v6 > address_v6_iterator;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v6_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:ip__address_v6_range ip::address_v6_range]

[indexterm1 boost_asio.indexterm.ip__address_v6_range..ip::address_v6_range] 
Represents a range of IPv6 addresses. 


  typedef basic_address_range< address_v6 > address_v6_range;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v6_range.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:ip__bad_address_cast ip::bad_address_cast]

[indexterm1 boost_asio.indexterm.ip__bad_address_cast..ip::bad_address_cast]


Thrown to indicate a failed address conversion. 


  class bad_address_cast


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__bad_address_cast.bad_address_cast [*bad_address_cast]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__bad_address_cast.what [*what]]]
    [Get the message associated with the exception. ]
  ]
  
  [
    [[link boost_asio.reference.ip__bad_address_cast._bad_address_cast [*~bad_address_cast]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/ip/bad_address_cast.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:bad_address_cast ip::bad_address_cast::bad_address_cast]

[indexterm2 boost_asio.indexterm.ip__bad_address_cast.bad_address_cast..bad_address_cast..ip::bad_address_cast] 
Default constructor. 


  bad_address_cast();



[endsect]



[section:what ip::bad_address_cast::what]

[indexterm2 boost_asio.indexterm.ip__bad_address_cast.what..what..ip::bad_address_cast] 
Get the message associated with the exception. 


  virtual const char * what() const;



[endsect]



[section:_bad_address_cast ip::bad_address_cast::~bad_address_cast]

[indexterm2 boost_asio.indexterm.ip__bad_address_cast._bad_address_cast..~bad_address_cast..ip::bad_address_cast] 
Destructor. 


  virtual ~bad_address_cast();



[endsect]



[endsect]

[section:ip__basic_address_iterator_lt__address_v4__gt_ ip::basic_address_iterator< address_v4 >]

[indexterm1 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_..ip::basic_address_iterator< address_v4 >]


An input iterator that can be used for traversing IPv4 addresses. 


  template<>
  class basic_address_iterator< address_v4 >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.difference_type [*difference_type]]]
    [Distance between two iterators. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.iterator_category [*iterator_category]]]
    [Denotes that the iterator satisfies the input iterator requirements. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.pointer [*pointer]]]
    [The type of a pointer to an element pointed to by the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.reference [*reference]]]
    [The type of a reference to an element pointed to by the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.value_type [*value_type]]]
    [The type of the elements pointed to by the iterator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.basic_address_iterator [*basic_address_iterator]]]
    [Construct an iterator that points to the specified address. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator__star_ [*operator *]]]
    [Dereference the iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_plus__plus_ [*operator++]]]
    [Pre-increment operator. 
     [hr]
     Post-increment operator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_minus__minus_ [*operator--]]]
    [Pre-decrement operator. 
     [hr]
     Post-decrement operator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_arrow_ [*operator->]]]
    [Dereference the iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_eq_ [*operator=]]]
    [Assignment operator. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
]

In addition to satisfying the input iterator requirements, this iterator also supports decrement.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/address_v4_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_address_iterator ip::basic_address_iterator< address_v4 >::basic_address_iterator]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_.basic_address_iterator..basic_address_iterator..ip::basic_address_iterator< address_v4 >] 
Construct an iterator that points to the specified address. 


  ``[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.basic_address_iterator.overload1 basic_address_iterator]``(
      const address_v4 & addr);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.basic_address_iterator.overload1 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.basic_address_iterator.overload2 basic_address_iterator]``(
      const basic_address_iterator & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.basic_address_iterator.overload2 more...]]``


[section:overload1 ip::basic_address_iterator< address_v4 >::basic_address_iterator (1 of 2 overloads)]


Construct an iterator that points to the specified address. 


  basic_address_iterator(
      const address_v4 & addr);



[endsect]



[section:overload2 ip::basic_address_iterator< address_v4 >::basic_address_iterator (2 of 2 overloads)]


Copy constructor. 


  basic_address_iterator(
      const basic_address_iterator & other);



[endsect]


[endsect]


[section:difference_type ip::basic_address_iterator< address_v4 >::difference_type]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_.difference_type..difference_type..ip::basic_address_iterator< address_v4 >] 
Distance between two iterators. 


  typedef std::ptrdiff_t difference_type;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v4_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:iterator_category ip::basic_address_iterator< address_v4 >::iterator_category]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_.iterator_category..iterator_category..ip::basic_address_iterator< address_v4 >] 
Denotes that the iterator satisfies the input iterator requirements. 


  typedef std::input_iterator_tag iterator_category;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v4_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator__star_ ip::basic_address_iterator< address_v4 >::operator *]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_.operator__star_..operator *..ip::basic_address_iterator< address_v4 >] 
Dereference the iterator. 


  const address_v4 & operator *() const;



[endsect]



[section:operator_not__eq_ ip::basic_address_iterator< address_v4 >::operator!=]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_.operator_not__eq_..operator!=..ip::basic_address_iterator< address_v4 >] 
Compare two addresses for inequality. 


  friend bool operator!=(
      const basic_address_iterator & a,
      const basic_address_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v4_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:operator_plus__plus_ ip::basic_address_iterator< address_v4 >::operator++]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_.operator_plus__plus_..operator++..ip::basic_address_iterator< address_v4 >] 
Pre-increment operator. 


  basic_address_iterator & ``[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_plus__plus_.overload1 operator++]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_plus__plus_.overload1 more...]]``


Post-increment operator. 


  basic_address_iterator ``[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_plus__plus_.overload2 operator++]``(
      int );
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_plus__plus_.overload2 more...]]``


[section:overload1 ip::basic_address_iterator< address_v4 >::operator++ (1 of 2 overloads)]


Pre-increment operator. 


  basic_address_iterator & operator++();



[endsect]



[section:overload2 ip::basic_address_iterator< address_v4 >::operator++ (2 of 2 overloads)]


Post-increment operator. 


  basic_address_iterator operator++(
      int );



[endsect]


[endsect]

[section:operator_minus__minus_ ip::basic_address_iterator< address_v4 >::operator--]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_.operator_minus__minus_..operator--..ip::basic_address_iterator< address_v4 >] 
Pre-decrement operator. 


  basic_address_iterator & ``[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_minus__minus_.overload1 operator--]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_minus__minus_.overload1 more...]]``


Post-decrement operator. 


  basic_address_iterator ``[link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_minus__minus_.overload2 operator--]``(
      int );
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_iterator_lt__address_v4__gt_.operator_minus__minus_.overload2 more...]]``


[section:overload1 ip::basic_address_iterator< address_v4 >::operator-- (1 of 2 overloads)]


Pre-decrement operator. 


  basic_address_iterator & operator--();



[endsect]



[section:overload2 ip::basic_address_iterator< address_v4 >::operator-- (2 of 2 overloads)]


Post-decrement operator. 


  basic_address_iterator operator--(
      int );



[endsect]


[endsect]


[section:operator_arrow_ ip::basic_address_iterator< address_v4 >::operator->]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_.operator_arrow_..operator->..ip::basic_address_iterator< address_v4 >] 
Dereference the iterator. 


  const address_v4 * operator->() const;



[endsect]



[section:operator_eq_ ip::basic_address_iterator< address_v4 >::operator=]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_.operator_eq_..operator=..ip::basic_address_iterator< address_v4 >] 
Assignment operator. 


  basic_address_iterator & operator=(
      const basic_address_iterator & other);



[endsect]



[section:operator_eq__eq_ ip::basic_address_iterator< address_v4 >::operator==]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_.operator_eq__eq_..operator==..ip::basic_address_iterator< address_v4 >] 
Compare two addresses for equality. 


  friend bool operator==(
      const basic_address_iterator & a,
      const basic_address_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v4_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:pointer ip::basic_address_iterator< address_v4 >::pointer]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_.pointer..pointer..ip::basic_address_iterator< address_v4 >] 
The type of a pointer to an element pointed to by the iterator. 


  typedef const address_v4 * pointer;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v4_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:reference ip::basic_address_iterator< address_v4 >::reference]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_.reference..reference..ip::basic_address_iterator< address_v4 >] 
The type of a reference to an element pointed to by the iterator. 


  typedef const address_v4 & reference;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__address_v4.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

  [

    [[link boost_asio.reference.ip__address_v4.uint_type [*uint_type]]]
    [The type used to represent an address as an unsigned integer. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v4.address_v4 [*address_v4]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an address from raw bytes. 
     [hr]
     Construct an address from an unsigned integer in host byte order. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.any [*any]] [static]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.broadcast [*broadcast]] [static]]
    [Obtain an address object that represents the broadcast address. 
     [hr]
     (Deprecated: Use network_v4 class.) Obtain an address object that represents the broadcast address that corresponds to the specified address and netmask. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.from_string [*from_string]] [static]]
    [(Deprecated: Use make_address_v4().) Create an address from an IP address string in dotted decimal form. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_class_a [*is_class_a]]]
    [(Deprecated: Use network_v4 class.) Determine whether the address is a class A address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_class_b [*is_class_b]]]
    [(Deprecated: Use network_v4 class.) Determine whether the address is a class B address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_class_c [*is_class_c]]]
    [(Deprecated: Use network_v4 class.) Determine whether the address is a class C address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.loopback [*loopback]] [static]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.netmask [*netmask]] [static]]
    [(Deprecated: Use network_v4 class.) Obtain the netmask that corresponds to the address, based on its address class. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.to_string [*to_string]]]
    [Get the address as a string in dotted decimal format. 
     [hr]
     (Deprecated: Use other overload.) Get the address as a string in dotted decimal format. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.to_uint [*to_uint]]]
    [Get the address as an unsigned integer in host byte order. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.to_ulong [*to_ulong]]]
    [Get the address as an unsigned long in host byte order. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v4.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v4.make_address_v4 [*make_address_v4]]]
    [Create an IPv4 address from raw bytes in network order. 

     Create an IPv4 address from an unsigned integer in host byte order. 

     Create an IPv4 address from an IP address string in dotted decimal form. 

     Create an IPv4 address from a IPv4-mapped IPv6 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.make_network_v4 [*make_network_v4]]]
    [Create an IPv4 network from an address and prefix length. 

     Create an IPv4 network from an address and netmask. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_lt__lt_ [*operator<<]]]
    [Output an address as a string. 

     Output a network as a string. ]
  ]
  
]

The [link boost_asio.reference.ip__address_v4 `ip::address_v4`] class provides the ability to use and manipulate IP version 4 addresses.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/address_v4_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:value_type ip::basic_address_iterator< address_v4 >::value_type]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v4__gt_.value_type..value_type..ip::basic_address_iterator< address_v4 >] 
The type of the elements pointed to by the iterator. 


  typedef address_v4 value_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__address_v4.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

  [

    [[link boost_asio.reference.ip__address_v4.uint_type [*uint_type]]]
    [The type used to represent an address as an unsigned integer. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v4.address_v4 [*address_v4]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an address from raw bytes. 
     [hr]
     Construct an address from an unsigned integer in host byte order. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.any [*any]] [static]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.broadcast [*broadcast]] [static]]
    [Obtain an address object that represents the broadcast address. 
     [hr]
     (Deprecated: Use network_v4 class.) Obtain an address object that represents the broadcast address that corresponds to the specified address and netmask. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.from_string [*from_string]] [static]]
    [(Deprecated: Use make_address_v4().) Create an address from an IP address string in dotted decimal form. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_class_a [*is_class_a]]]
    [(Deprecated: Use network_v4 class.) Determine whether the address is a class A address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_class_b [*is_class_b]]]
    [(Deprecated: Use network_v4 class.) Determine whether the address is a class B address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_class_c [*is_class_c]]]
    [(Deprecated: Use network_v4 class.) Determine whether the address is a class C address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.loopback [*loopback]] [static]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.netmask [*netmask]] [static]]
    [(Deprecated: Use network_v4 class.) Obtain the netmask that corresponds to the address, based on its address class. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.to_string [*to_string]]]
    [Get the address as a string in dotted decimal format. 
     [hr]
     (Deprecated: Use other overload.) Get the address as a string in dotted decimal format. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.to_uint [*to_uint]]]
    [Get the address as an unsigned integer in host byte order. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.to_ulong [*to_ulong]]]
    [Get the address as an unsigned long in host byte order. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v4.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v4.make_address_v4 [*make_address_v4]]]
    [Create an IPv4 address from raw bytes in network order. 

     Create an IPv4 address from an unsigned integer in host byte order. 

     Create an IPv4 address from an IP address string in dotted decimal form. 

     Create an IPv4 address from a IPv4-mapped IPv6 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.make_network_v4 [*make_network_v4]]]
    [Create an IPv4 network from an address and prefix length. 

     Create an IPv4 network from an address and netmask. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v4.operator_lt__lt_ [*operator<<]]]
    [Output an address as a string. 

     Output a network as a string. ]
  ]
  
]

The [link boost_asio.reference.ip__address_v4 `ip::address_v4`] class provides the ability to use and manipulate IP version 4 addresses.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/address_v4_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:ip__basic_address_iterator_lt__address_v6__gt_ ip::basic_address_iterator< address_v6 >]

[indexterm1 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_..ip::basic_address_iterator< address_v6 >]


An input iterator that can be used for traversing IPv6 addresses. 


  template<>
  class basic_address_iterator< address_v6 >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.difference_type [*difference_type]]]
    [Distance between two iterators. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.iterator_category [*iterator_category]]]
    [Denotes that the iterator satisfies the input iterator requirements. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.pointer [*pointer]]]
    [The type of a pointer to an element pointed to by the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.reference [*reference]]]
    [The type of a reference to an element pointed to by the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.value_type [*value_type]]]
    [The type of the elements pointed to by the iterator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.basic_address_iterator [*basic_address_iterator]]]
    [Construct an iterator that points to the specified address. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator__star_ [*operator *]]]
    [Dereference the iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_plus__plus_ [*operator++]]]
    [Pre-increment operator. 
     [hr]
     Post-increment operator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_minus__minus_ [*operator--]]]
    [Pre-decrement operator. 
     [hr]
     Post-decrement operator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_arrow_ [*operator->]]]
    [Dereference the iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_eq_ [*operator=]]]
    [Assignment operator. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
]

In addition to satisfying the input iterator requirements, this iterator also supports decrement.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/address_v6_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_address_iterator ip::basic_address_iterator< address_v6 >::basic_address_iterator]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_.basic_address_iterator..basic_address_iterator..ip::basic_address_iterator< address_v6 >] 
Construct an iterator that points to the specified address. 


  ``[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.basic_address_iterator.overload1 basic_address_iterator]``(
      const address_v6 & addr);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.basic_address_iterator.overload1 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.basic_address_iterator.overload2 basic_address_iterator]``(
      const basic_address_iterator & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.basic_address_iterator.overload2 more...]]``


[section:overload1 ip::basic_address_iterator< address_v6 >::basic_address_iterator (1 of 2 overloads)]


Construct an iterator that points to the specified address. 


  basic_address_iterator(
      const address_v6 & addr);



[endsect]



[section:overload2 ip::basic_address_iterator< address_v6 >::basic_address_iterator (2 of 2 overloads)]


Copy constructor. 


  basic_address_iterator(
      const basic_address_iterator & other);



[endsect]


[endsect]


[section:difference_type ip::basic_address_iterator< address_v6 >::difference_type]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_.difference_type..difference_type..ip::basic_address_iterator< address_v6 >] 
Distance between two iterators. 


  typedef std::ptrdiff_t difference_type;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v6_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:iterator_category ip::basic_address_iterator< address_v6 >::iterator_category]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_.iterator_category..iterator_category..ip::basic_address_iterator< address_v6 >] 
Denotes that the iterator satisfies the input iterator requirements. 


  typedef std::input_iterator_tag iterator_category;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v6_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator__star_ ip::basic_address_iterator< address_v6 >::operator *]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_.operator__star_..operator *..ip::basic_address_iterator< address_v6 >] 
Dereference the iterator. 


  const address_v6 & operator *() const;



[endsect]



[section:operator_not__eq_ ip::basic_address_iterator< address_v6 >::operator!=]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_.operator_not__eq_..operator!=..ip::basic_address_iterator< address_v6 >] 
Compare two addresses for inequality. 


  friend bool operator!=(
      const basic_address_iterator & a,
      const basic_address_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v6_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:operator_plus__plus_ ip::basic_address_iterator< address_v6 >::operator++]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_.operator_plus__plus_..operator++..ip::basic_address_iterator< address_v6 >] 
Pre-increment operator. 


  basic_address_iterator & ``[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_plus__plus_.overload1 operator++]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_plus__plus_.overload1 more...]]``


Post-increment operator. 


  basic_address_iterator ``[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_plus__plus_.overload2 operator++]``(
      int );
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_plus__plus_.overload2 more...]]``


[section:overload1 ip::basic_address_iterator< address_v6 >::operator++ (1 of 2 overloads)]


Pre-increment operator. 


  basic_address_iterator & operator++();



[endsect]



[section:overload2 ip::basic_address_iterator< address_v6 >::operator++ (2 of 2 overloads)]


Post-increment operator. 


  basic_address_iterator operator++(
      int );



[endsect]


[endsect]

[section:operator_minus__minus_ ip::basic_address_iterator< address_v6 >::operator--]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_.operator_minus__minus_..operator--..ip::basic_address_iterator< address_v6 >] 
Pre-decrement operator. 


  basic_address_iterator & ``[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_minus__minus_.overload1 operator--]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_minus__minus_.overload1 more...]]``


Post-decrement operator. 


  basic_address_iterator ``[link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_minus__minus_.overload2 operator--]``(
      int );
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_iterator_lt__address_v6__gt_.operator_minus__minus_.overload2 more...]]``


[section:overload1 ip::basic_address_iterator< address_v6 >::operator-- (1 of 2 overloads)]


Pre-decrement operator. 


  basic_address_iterator & operator--();



[endsect]



[section:overload2 ip::basic_address_iterator< address_v6 >::operator-- (2 of 2 overloads)]


Post-decrement operator. 


  basic_address_iterator operator--(
      int );



[endsect]


[endsect]


[section:operator_arrow_ ip::basic_address_iterator< address_v6 >::operator->]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_.operator_arrow_..operator->..ip::basic_address_iterator< address_v6 >] 
Dereference the iterator. 


  const address_v6 * operator->() const;



[endsect]



[section:operator_eq_ ip::basic_address_iterator< address_v6 >::operator=]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_.operator_eq_..operator=..ip::basic_address_iterator< address_v6 >] 
Assignment operator. 


  basic_address_iterator & operator=(
      const basic_address_iterator & other);



[endsect]



[section:operator_eq__eq_ ip::basic_address_iterator< address_v6 >::operator==]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_.operator_eq__eq_..operator==..ip::basic_address_iterator< address_v6 >] 
Compare two addresses for equality. 


  friend bool operator==(
      const basic_address_iterator & a,
      const basic_address_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/ip/address_v6_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:pointer ip::basic_address_iterator< address_v6 >::pointer]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_.pointer..pointer..ip::basic_address_iterator< address_v6 >] 
The type of a pointer to an element pointed to by the iterator. 


  typedef const address_v6 * pointer;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v6_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:reference ip::basic_address_iterator< address_v6 >::reference]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_.reference..reference..ip::basic_address_iterator< address_v6 >] 
The type of a reference to an element pointed to by the iterator. 


  typedef const address_v6 & reference;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__address_v6.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v6.address_v6 [*address_v6]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an address from raw bytes and scope ID. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.any [*any]] [static]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.from_string [*from_string]] [static]]
    [(Deprecated: Use make_address_v6().) Create an IPv6 address from an IP address string. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_link_local [*is_link_local]]]
    [Determine whether the address is link local. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_global [*is_multicast_global]]]
    [Determine whether the address is a global multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_link_local [*is_multicast_link_local]]]
    [Determine whether the address is a link-local multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_node_local [*is_multicast_node_local]]]
    [Determine whether the address is a node-local multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_org_local [*is_multicast_org_local]]]
    [Determine whether the address is a org-local multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_site_local [*is_multicast_site_local]]]
    [Determine whether the address is a site-local multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_site_local [*is_site_local]]]
    [Determine whether the address is site local. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_v4_compatible [*is_v4_compatible]]]
    [(Deprecated: No replacement.) Determine whether the address is an IPv4-compatible address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_v4_mapped [*is_v4_mapped]]]
    [Determine whether the address is a mapped IPv4 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.loopback [*loopback]] [static]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.scope_id [*scope_id]]]
    [The scope ID of the address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.to_string [*to_string]]]
    [Get the address as a string. 
     [hr]
     (Deprecated: Use other overload.) Get the address as a string. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.to_v4 [*to_v4]]]
    [(Deprecated: Use make_address_v4().) Converts an IPv4-mapped or IPv4-compatible address to an IPv4 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.v4_compatible [*v4_compatible]] [static]]
    [(Deprecated: No replacement.) Create an IPv4-compatible IPv6 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.v4_mapped [*v4_mapped]] [static]]
    [(Deprecated: Use make_address_v6().) Create an IPv4-mapped IPv6 address. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v6.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v6.make_address_v6 [*make_address_v6]]]
    [Create an IPv6 address from raw bytes and scope ID. 

     Create an IPv6 address from an IP address string. 

     Createan IPv6 address from an IP address string. 

     Create an IPv4-mapped IPv6 address from an IPv4 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.make_network_v6 [*make_network_v6]]]
    [Create an IPv6 network from an address and prefix length. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_lt__lt_ [*operator<<]]]
    [Output an address as a string. 

     Output a network as a string. ]
  ]
  
]

The [link boost_asio.reference.ip__address_v6 `ip::address_v6`] class provides the ability to use and manipulate IP version 6 addresses.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/address_v6_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:value_type ip::basic_address_iterator< address_v6 >::value_type]

[indexterm2 boost_asio.indexterm.ip__basic_address_iterator_lt__address_v6__gt_.value_type..value_type..ip::basic_address_iterator< address_v6 >] 
The type of the elements pointed to by the iterator. 


  typedef address_v6 value_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__address_v6.bytes_type [*bytes_type]]]
    [The type used to represent an address as an array of bytes. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v6.address_v6 [*address_v6]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an address from raw bytes and scope ID. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.any [*any]] [static]]
    [Obtain an address object that represents any address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.from_string [*from_string]] [static]]
    [(Deprecated: Use make_address_v6().) Create an IPv6 address from an IP address string. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_link_local [*is_link_local]]]
    [Determine whether the address is link local. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_loopback [*is_loopback]]]
    [Determine whether the address is a loopback address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast [*is_multicast]]]
    [Determine whether the address is a multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_global [*is_multicast_global]]]
    [Determine whether the address is a global multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_link_local [*is_multicast_link_local]]]
    [Determine whether the address is a link-local multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_node_local [*is_multicast_node_local]]]
    [Determine whether the address is a node-local multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_org_local [*is_multicast_org_local]]]
    [Determine whether the address is a org-local multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_multicast_site_local [*is_multicast_site_local]]]
    [Determine whether the address is a site-local multicast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_site_local [*is_site_local]]]
    [Determine whether the address is site local. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_unspecified [*is_unspecified]]]
    [Determine whether the address is unspecified. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_v4_compatible [*is_v4_compatible]]]
    [(Deprecated: No replacement.) Determine whether the address is an IPv4-compatible address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.is_v4_mapped [*is_v4_mapped]]]
    [Determine whether the address is a mapped IPv4 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.loopback [*loopback]] [static]]
    [Obtain an address object that represents the loopback address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_eq_ [*operator=]]]
    [Assign from another address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.scope_id [*scope_id]]]
    [The scope ID of the address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.to_bytes [*to_bytes]]]
    [Get the address in bytes, in network byte order. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.to_string [*to_string]]]
    [Get the address as a string. 
     [hr]
     (Deprecated: Use other overload.) Get the address as a string. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.to_v4 [*to_v4]]]
    [(Deprecated: Use make_address_v4().) Converts an IPv4-mapped or IPv4-compatible address to an IPv4 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.v4_compatible [*v4_compatible]] [static]]
    [(Deprecated: No replacement.) Create an IPv4-compatible IPv6 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.v4_mapped [*v4_mapped]] [static]]
    [(Deprecated: Use make_address_v6().) Create an IPv4-mapped IPv6 address. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v6.operator_not__eq_ [*operator!=]]]
    [Compare two addresses for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_lt_ [*operator<]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_lt__eq_ [*operator<=]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_eq__eq_ [*operator==]]]
    [Compare two addresses for equality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_gt_ [*operator>]]]
    [Compare addresses for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_gt__eq_ [*operator>=]]]
    [Compare addresses for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__address_v6.make_address_v6 [*make_address_v6]]]
    [Create an IPv6 address from raw bytes and scope ID. 

     Create an IPv6 address from an IP address string. 

     Createan IPv6 address from an IP address string. 

     Create an IPv4-mapped IPv6 address from an IPv4 address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.make_network_v6 [*make_network_v6]]]
    [Create an IPv6 network from an address and prefix length. ]
  ]
  
  [
    [[link boost_asio.reference.ip__address_v6.operator_lt__lt_ [*operator<<]]]
    [Output an address as a string. 

     Output a network as a string. ]
  ]
  
]

The [link boost_asio.reference.ip__address_v6 `ip::address_v6`] class provides the ability to use and manipulate IP version 6 addresses.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/address_v6_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:ip__basic_address_range_lt__address_v4__gt_ ip::basic_address_range< address_v4 >]

[indexterm1 boost_asio.indexterm.ip__basic_address_range_lt__address_v4__gt_..ip::basic_address_range< address_v4 >]


Represents a range of IPv4 addresses. 


  template<>
  class basic_address_range< address_v4 >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.iterator [*iterator]]]
    [The type of an iterator that points into the range. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range [*basic_address_range]]]
    [Construct an empty range. 
     [hr]
     Construct an range that represents the given range of addresses. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.begin [*begin]]]
    [Obtain an iterator that points to the start of the range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.empty [*empty]]]
    [Determine whether the range is empty. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.end [*end]]]
    [Obtain an iterator that points to the end of the range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.find [*find]]]
    [Find an address in the range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.operator_eq_ [*operator=]]]
    [Assignment operator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.size [*size]]]
    [Return the size of the range. ]
  ]
  
]


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/address_v4_range.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_address_range ip::basic_address_range< address_v4 >::basic_address_range]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v4__gt_.basic_address_range..basic_address_range..ip::basic_address_range< address_v4 >] 
Construct an empty range. 


  ``[link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range.overload1 basic_address_range]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range.overload1 more...]]``


Construct an range that represents the given range of addresses. 


  explicit ``[link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range.overload2 basic_address_range]``(
      const iterator & first,
      const iterator & last);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range.overload2 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range.overload3 basic_address_range]``(
      const basic_address_range & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_range_lt__address_v4__gt_.basic_address_range.overload3 more...]]``


[section:overload1 ip::basic_address_range< address_v4 >::basic_address_range (1 of 3 overloads)]


Construct an empty range. 


  basic_address_range();



[endsect]



[section:overload2 ip::basic_address_range< address_v4 >::basic_address_range (2 of 3 overloads)]


Construct an range that represents the given range of addresses. 


  basic_address_range(
      const iterator & first,
      const iterator & last);



[endsect]



[section:overload3 ip::basic_address_range< address_v4 >::basic_address_range (3 of 3 overloads)]


Copy constructor. 


  basic_address_range(
      const basic_address_range & other);



[endsect]


[endsect]


[section:begin ip::basic_address_range< address_v4 >::begin]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v4__gt_.begin..begin..ip::basic_address_range< address_v4 >] 
Obtain an iterator that points to the start of the range. 


  iterator begin() const;



[endsect]



[section:empty ip::basic_address_range< address_v4 >::empty]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v4__gt_.empty..empty..ip::basic_address_range< address_v4 >] 
Determine whether the range is empty. 


  bool empty() const;



[endsect]



[section:end ip::basic_address_range< address_v4 >::end]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v4__gt_.end..end..ip::basic_address_range< address_v4 >] 
Obtain an iterator that points to the end of the range. 


  iterator end() const;



[endsect]



[section:find ip::basic_address_range< address_v4 >::find]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v4__gt_.find..find..ip::basic_address_range< address_v4 >] 
Find an address in the range. 


  iterator find(
      const address_v4 & addr) const;



[endsect]



[section:iterator ip::basic_address_range< address_v4 >::iterator]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v4__gt_.iterator..iterator..ip::basic_address_range< address_v4 >] 
The type of an iterator that points into the range. 


  typedef basic_address_iterator< address_v4 > iterator;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v4_range.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ ip::basic_address_range< address_v4 >::operator=]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v4__gt_.operator_eq_..operator=..ip::basic_address_range< address_v4 >] 
Assignment operator. 


  basic_address_range & operator=(
      const basic_address_range & other);



[endsect]



[section:size ip::basic_address_range< address_v4 >::size]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v4__gt_.size..size..ip::basic_address_range< address_v4 >] 
Return the size of the range. 


  std::size_t size() const;



[endsect]



[endsect]

[section:ip__basic_address_range_lt__address_v6__gt_ ip::basic_address_range< address_v6 >]

[indexterm1 boost_asio.indexterm.ip__basic_address_range_lt__address_v6__gt_..ip::basic_address_range< address_v6 >]


Represents a range of IPv6 addresses. 


  template<>
  class basic_address_range< address_v6 >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_address_range_lt__address_v6__gt_.iterator [*iterator]]]
    [The type of an iterator that points into the range. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range [*basic_address_range]]]
    [Construct an empty range. 
     [hr]
     Construct an range that represents the given range of addresses. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_range_lt__address_v6__gt_.begin [*begin]]]
    [Obtain an iterator that points to the start of the range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_range_lt__address_v6__gt_.empty [*empty]]]
    [Determine whether the range is empty. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_range_lt__address_v6__gt_.end [*end]]]
    [Obtain an iterator that points to the end of the range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_range_lt__address_v6__gt_.find [*find]]]
    [Find an address in the range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_address_range_lt__address_v6__gt_.operator_eq_ [*operator=]]]
    [Assignment operator. ]
  ]
  
]


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/address_v6_range.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_address_range ip::basic_address_range< address_v6 >::basic_address_range]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v6__gt_.basic_address_range..basic_address_range..ip::basic_address_range< address_v6 >] 
Construct an empty range. 


  ``[link boost_asio.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range.overload1 basic_address_range]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range.overload1 more...]]``


Construct an range that represents the given range of addresses. 


  explicit ``[link boost_asio.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range.overload2 basic_address_range]``(
      const iterator & first,
      const iterator & last);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range.overload2 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range.overload3 basic_address_range]``(
      const basic_address_range & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_address_range_lt__address_v6__gt_.basic_address_range.overload3 more...]]``


[section:overload1 ip::basic_address_range< address_v6 >::basic_address_range (1 of 3 overloads)]


Construct an empty range. 


  basic_address_range();



[endsect]



[section:overload2 ip::basic_address_range< address_v6 >::basic_address_range (2 of 3 overloads)]


Construct an range that represents the given range of addresses. 


  basic_address_range(
      const iterator & first,
      const iterator & last);



[endsect]



[section:overload3 ip::basic_address_range< address_v6 >::basic_address_range (3 of 3 overloads)]


Copy constructor. 


  basic_address_range(
      const basic_address_range & other);



[endsect]


[endsect]


[section:begin ip::basic_address_range< address_v6 >::begin]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v6__gt_.begin..begin..ip::basic_address_range< address_v6 >] 
Obtain an iterator that points to the start of the range. 


  iterator begin() const;



[endsect]



[section:empty ip::basic_address_range< address_v6 >::empty]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v6__gt_.empty..empty..ip::basic_address_range< address_v6 >] 
Determine whether the range is empty. 


  bool empty() const;



[endsect]



[section:end ip::basic_address_range< address_v6 >::end]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v6__gt_.end..end..ip::basic_address_range< address_v6 >] 
Obtain an iterator that points to the end of the range. 


  iterator end() const;



[endsect]



[section:find ip::basic_address_range< address_v6 >::find]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v6__gt_.find..find..ip::basic_address_range< address_v6 >] 
Find an address in the range. 


  iterator find(
      const address_v6 & addr) const;



[endsect]



[section:iterator ip::basic_address_range< address_v6 >::iterator]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v6__gt_.iterator..iterator..ip::basic_address_range< address_v6 >] 
The type of an iterator that points into the range. 


  typedef basic_address_iterator< address_v6 > iterator;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v6_range.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ ip::basic_address_range< address_v6 >::operator=]

[indexterm2 boost_asio.indexterm.ip__basic_address_range_lt__address_v6__gt_.operator_eq_..operator=..ip::basic_address_range< address_v6 >] 
Assignment operator. 


  basic_address_range & operator=(
      const basic_address_range & other);



[endsect]



[endsect]

[section:ip__basic_endpoint ip::basic_endpoint]

[indexterm1 boost_asio.indexterm.ip__basic_endpoint..ip::basic_endpoint]


Describes an endpoint for a version-independent IP socket. 


  template<
      typename ``[link boost_asio.reference.InternetProtocol InternetProtocol]``>
  class basic_endpoint


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_endpoint.address [*address]]]
    [Get the IP address associated with the endpoint. 
     [hr]
     Set the IP address associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.basic_endpoint [*basic_endpoint]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an endpoint using a port number, specified in the host's byte order. The IP address will be the any address (i.e. INADDR_ANY or in6addr_any). This constructor would typically be used for accepting new connections. 
     [hr]
     Construct an endpoint using a port number and an IP address. This constructor may be used for accepting connections on a specific interface or for making a connection to a remote endpoint. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. 
     [hr]
     Move-assign from another endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.port [*port]]]
    [Get the port associated with the endpoint. The port number is always in the host's byte order. 
     [hr]
     Set the port associated with the endpoint. The port number is always in the host's byte order. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_lt__lt_ [*operator<<]]]
    [Output an endpoint as a string. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_endpoint `ip::basic_endpoint`] class template describes an endpoint that may be associated with a particular socket.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.




[heading Requirements]

['Header: ][^boost/asio/ip/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:address ip::basic_endpoint::address]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.address..address..ip::basic_endpoint] 
Get the IP address associated with the endpoint. 


  boost::asio::ip::address ``[link boost_asio.reference.ip__basic_endpoint.address.overload1 address]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_endpoint.address.overload1 more...]]``


Set the IP address associated with the endpoint. 


  void ``[link boost_asio.reference.ip__basic_endpoint.address.overload2 address]``(
      const boost::asio::ip::address & addr);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_endpoint.address.overload2 more...]]``


[section:overload1 ip::basic_endpoint::address (1 of 2 overloads)]


Get the IP address associated with the endpoint. 


  boost::asio::ip::address address() const;



[endsect]



[section:overload2 ip::basic_endpoint::address (2 of 2 overloads)]


Set the IP address associated with the endpoint. 


  void address(
      const boost::asio::ip::address & addr);



[endsect]


[endsect]

[section:basic_endpoint ip::basic_endpoint::basic_endpoint]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.basic_endpoint..basic_endpoint..ip::basic_endpoint] 
Default constructor. 


  ``[link boost_asio.reference.ip__basic_endpoint.basic_endpoint.overload1 basic_endpoint]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_endpoint.basic_endpoint.overload1 more...]]``


Construct an endpoint using a port number, specified in the host's byte order. The IP address will be the any address (i.e. INADDR\_ANY or in6addr\_any). This constructor would typically be used for accepting new connections. 


  ``[link boost_asio.reference.ip__basic_endpoint.basic_endpoint.overload2 basic_endpoint]``(
      const InternetProtocol & internet_protocol,
      port_type port_num);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_endpoint.basic_endpoint.overload2 more...]]``


Construct an endpoint using a port number and an IP address. This constructor may be used for accepting connections on a specific interface or for making a connection to a remote endpoint. 


  ``[link boost_asio.reference.ip__basic_endpoint.basic_endpoint.overload3 basic_endpoint]``(
      const boost::asio::ip::address & addr,
      port_type port_num);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_endpoint.basic_endpoint.overload3 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.ip__basic_endpoint.basic_endpoint.overload4 basic_endpoint]``(
      const basic_endpoint & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_endpoint.basic_endpoint.overload4 more...]]``


Move constructor. 


  ``[link boost_asio.reference.ip__basic_endpoint.basic_endpoint.overload5 basic_endpoint]``(
      basic_endpoint && other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_endpoint.basic_endpoint.overload5 more...]]``


[section:overload1 ip::basic_endpoint::basic_endpoint (1 of 5 overloads)]


Default constructor. 


  basic_endpoint();



[endsect]



[section:overload2 ip::basic_endpoint::basic_endpoint (2 of 5 overloads)]


Construct an endpoint using a port number, specified in the host's byte order. The IP address will be the any address (i.e. INADDR\_ANY or in6addr\_any). This constructor would typically be used for accepting new connections. 


  basic_endpoint(
      const InternetProtocol & internet_protocol,
      port_type port_num);



[heading Examples]
  
To initialise an IPv4 TCP endpoint for port 1234, use: 

   boost::asio::ip::tcp::endpoint ep(boost::asio::ip::tcp::v4(), 1234);




To specify an IPv6 UDP endpoint for port 9876, use: 

   boost::asio::ip::udp::endpoint ep(boost::asio::ip::udp::v6(), 9876);





[endsect]



[section:overload3 ip::basic_endpoint::basic_endpoint (3 of 5 overloads)]


Construct an endpoint using a port number and an IP address. This constructor may be used for accepting connections on a specific interface or for making a connection to a remote endpoint. 


  basic_endpoint(
      const boost::asio::ip::address & addr,
      port_type port_num);



[endsect]



[section:overload4 ip::basic_endpoint::basic_endpoint (4 of 5 overloads)]


Copy constructor. 


  basic_endpoint(
      const basic_endpoint & other);



[endsect]



[section:overload5 ip::basic_endpoint::basic_endpoint (5 of 5 overloads)]


Move constructor. 


  basic_endpoint(
      basic_endpoint && other);



[endsect]


[endsect]


[section:capacity ip::basic_endpoint::capacity]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.capacity..capacity..ip::basic_endpoint] 
Get the capacity of the endpoint in the native type. 


  std::size_t capacity() const;



[endsect]


[section:data ip::basic_endpoint::data]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.data..data..ip::basic_endpoint] 
Get the underlying endpoint in the native type. 


  data_type * ``[link boost_asio.reference.ip__basic_endpoint.data.overload1 data]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_endpoint.data.overload1 more...]]``

  const data_type * ``[link boost_asio.reference.ip__basic_endpoint.data.overload2 data]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_endpoint.data.overload2 more...]]``


[section:overload1 ip::basic_endpoint::data (1 of 2 overloads)]


Get the underlying endpoint in the native type. 


  data_type * data();



[endsect]



[section:overload2 ip::basic_endpoint::data (2 of 2 overloads)]


Get the underlying endpoint in the native type. 


  const data_type * data() const;



[endsect]


[endsect]


[section:data_type ip::basic_endpoint::data_type]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.data_type..data_type..ip::basic_endpoint] 
The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. 


  typedef implementation_defined data_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_not__eq_ ip::basic_endpoint::operator!=]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.operator_not__eq_..operator!=..ip::basic_endpoint] 
Compare two endpoints for inequality. 


  friend bool operator!=(
      const basic_endpoint< InternetProtocol > & e1,
      const basic_endpoint< InternetProtocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/ip/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_lt_ ip::basic_endpoint::operator<]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.operator_lt_..operator<..ip::basic_endpoint] 
Compare endpoints for ordering. 


  friend bool operator<(
      const basic_endpoint< InternetProtocol > & e1,
      const basic_endpoint< InternetProtocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/ip/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_lt__lt_ ip::basic_endpoint::operator<<]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.operator_lt__lt_..operator<<..ip::basic_endpoint] 
Output an endpoint as a string. 


  std::basic_ostream< Elem, Traits > & operator<<(
      std::basic_ostream< Elem, Traits > & os,
      const basic_endpoint< InternetProtocol > & endpoint);


Used to output a human-readable string for a specified endpoint.


[heading Parameters]
    

[variablelist
  
[[os][The output stream to which the string will be written.]]

[[endpoint][The endpoint to be written.]]

]


[heading Return Value]
      
The output stream. 




[endsect]



[section:operator_lt__eq_ ip::basic_endpoint::operator<=]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.operator_lt__eq_..operator<=..ip::basic_endpoint] 
Compare endpoints for ordering. 


  friend bool operator<=(
      const basic_endpoint< InternetProtocol > & e1,
      const basic_endpoint< InternetProtocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/ip/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:operator_eq_ ip::basic_endpoint::operator=]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.operator_eq_..operator=..ip::basic_endpoint] 
Assign from another endpoint. 


  basic_endpoint & ``[link boost_asio.reference.ip__basic_endpoint.operator_eq_.overload1 operator=]``(
      const basic_endpoint & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_endpoint.operator_eq_.overload1 more...]]``


Move-assign from another endpoint. 


  basic_endpoint & ``[link boost_asio.reference.ip__basic_endpoint.operator_eq_.overload2 operator=]``(
      basic_endpoint && other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_endpoint.operator_eq_.overload2 more...]]``


[section:overload1 ip::basic_endpoint::operator= (1 of 2 overloads)]


Assign from another endpoint. 


  basic_endpoint & operator=(
      const basic_endpoint & other);



[endsect]



[section:overload2 ip::basic_endpoint::operator= (2 of 2 overloads)]


Move-assign from another endpoint. 


  basic_endpoint & operator=(
      basic_endpoint && other);



[endsect]


[endsect]


[section:operator_eq__eq_ ip::basic_endpoint::operator==]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.operator_eq__eq_..operator==..ip::basic_endpoint] 
Compare two endpoints for equality. 


  friend bool operator==(
      const basic_endpoint< InternetProtocol > & e1,
      const basic_endpoint< InternetProtocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/ip/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt_ ip::basic_endpoint::operator>]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.operator_gt_..operator>..ip::basic_endpoint] 
Compare endpoints for ordering. 


  friend bool operator>(
      const basic_endpoint< InternetProtocol > & e1,
      const basic_endpoint< InternetProtocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/ip/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt__eq_ ip::basic_endpoint::operator>=]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.operator_gt__eq_..operator>=..ip::basic_endpoint] 
Compare endpoints for ordering. 


  friend bool operator>=(
      const basic_endpoint< InternetProtocol > & e1,
      const basic_endpoint< InternetProtocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/ip/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:port ip::basic_endpoint::port]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.port..port..ip::basic_endpoint] 
Get the port associated with the endpoint. The port number is always in the host's byte order. 


  port_type ``[link boost_asio.reference.ip__basic_endpoint.port.overload1 port]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_endpoint.port.overload1 more...]]``


Set the port associated with the endpoint. The port number is always in the host's byte order. 


  void ``[link boost_asio.reference.ip__basic_endpoint.port.overload2 port]``(
      port_type port_num);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_endpoint.port.overload2 more...]]``


[section:overload1 ip::basic_endpoint::port (1 of 2 overloads)]


Get the port associated with the endpoint. The port number is always in the host's byte order. 


  port_type port() const;



[endsect]



[section:overload2 ip::basic_endpoint::port (2 of 2 overloads)]


Set the port associated with the endpoint. The port number is always in the host's byte order. 


  void port(
      port_type port_num);



[endsect]


[endsect]


[section:protocol ip::basic_endpoint::protocol]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.protocol..protocol..ip::basic_endpoint] 
The protocol associated with the endpoint. 


  protocol_type protocol() const;



[endsect]



[section:protocol_type ip::basic_endpoint::protocol_type]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.protocol_type..protocol_type..ip::basic_endpoint] 
The protocol type associated with the endpoint. 


  typedef InternetProtocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:resize ip::basic_endpoint::resize]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.resize..resize..ip::basic_endpoint] 
Set the underlying size of the endpoint in the native type. 


  void resize(
      std::size_t new_size);



[endsect]



[section:size ip::basic_endpoint::size]

[indexterm2 boost_asio.indexterm.ip__basic_endpoint.size..size..ip::basic_endpoint] 
Get the underlying size of the endpoint in the native type. 


  std::size_t size() const;



[endsect]



[endsect]

[section:ip__basic_resolver ip::basic_resolver]

[indexterm1 boost_asio.indexterm.ip__basic_resolver..ip::basic_resolver]


Provides endpoint resolution functionality. 


  template<
      typename ``[link boost_asio.reference.InternetProtocol InternetProtocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class basic_resolver :
    public ip::resolver_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver__rebind_executor [*rebind_executor]]]
    [Rebinds the resolver type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.iterator [*iterator]]]
    [(Deprecated.) The iterator type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.query [*query]]]
    [(Deprecated.) The query type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.results_type [*results_type]]]
    [The results type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver.async_resolve [*async_resolve]]]
    [(Deprecated: Use overload with separate host and service parameters.) Asynchronously perform forward resolution of a query to a list of entries. 
     [hr]
     Asynchronously perform forward resolution of a query to a list of entries. 
     [hr]
     Asynchronously perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.basic_resolver [*basic_resolver]] [constructor]]
    [Construct with executor. 
     [hr]
     Construct with execution context. 
     [hr]
     Move-construct a basic_resolver from another. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the resolver. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.operator_eq_ [*operator=]]]
    [Move-assign a basic_resolver from another. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.resolve [*resolve]]]
    [(Deprecated: Use overload with separate host and service parameters.) Perform forward resolution of a query to a list of entries. 
     [hr]
     Perform forward resolution of a query to a list of entries. 
     [hr]
     Perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver._basic_resolver [*~basic_resolver]] [destructor]]
    [Destroys the resolver. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver.address_configured [*address_configured]] [static]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.all_matching [*all_matching]] [static]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.canonical_name [*canonical_name]] [static]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.numeric_host [*numeric_host]] [static]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.numeric_service [*numeric_service]] [static]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.passive [*passive]] [static]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.v4_mapped [*v4_mapped]] [static]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]

The [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] class template provides the ability to resolve a query to a list of endpoints.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:address_configured ip::basic_resolver::address_configured]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.address_configured..address_configured..ip::basic_resolver] 
Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. 


  static const flags address_configured = implementation_defined;



[endsect]



[section:all_matching ip::basic_resolver::all_matching]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.all_matching..all_matching..ip::basic_resolver] 
If used with v4\_mapped, return all matching IPv6 and IPv4 addresses. 


  static const flags all_matching = implementation_defined;



[endsect]


[section:async_resolve ip::basic_resolver::async_resolve]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.async_resolve..async_resolve..ip::basic_resolver] 
(Deprecated: Use overload with separate host and service parameters.) Asynchronously perform forward resolution of a query to a list of entries. 


  template<
      typename ``[link boost_asio.reference.ResolveHandler ResolveHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.ip__basic_resolver.async_resolve.overload1 async_resolve]``(
      const query & q,
      ResolveHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.async_resolve.overload1 more...]]``


Asynchronously perform forward resolution of a query to a list of entries. 


  template<
      typename ``[link boost_asio.reference.ResolveHandler ResolveHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.ip__basic_resolver.async_resolve.overload2 async_resolve]``(
      string_view host,
      string_view service,
      ResolveHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.async_resolve.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.ResolveHandler ResolveHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.ip__basic_resolver.async_resolve.overload3 async_resolve]``(
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      ResolveHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.async_resolve.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.ResolveHandler ResolveHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.ip__basic_resolver.async_resolve.overload4 async_resolve]``(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      ResolveHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.async_resolve.overload4 more...]]``

  template<
      typename ``[link boost_asio.reference.ResolveHandler ResolveHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.ip__basic_resolver.async_resolve.overload5 async_resolve]``(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      ResolveHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.async_resolve.overload5 more...]]``


Asynchronously perform reverse resolution of an endpoint to a list of entries. 


  template<
      typename ``[link boost_asio.reference.ResolveHandler ResolveHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.ip__basic_resolver.async_resolve.overload6 async_resolve]``(
      const endpoint_type & e,
      ResolveHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.async_resolve.overload6 more...]]``


[section:overload1 ip::basic_resolver::async_resolve (1 of 6 overloads)]


(Deprecated: Use overload with separate host and service parameters.) Asynchronously perform forward resolution of a query to a list of entries. 


  template<
      typename ``[link boost_asio.reference.ResolveHandler ResolveHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_resolve(
      const query & q,
      ResolveHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously resolve a query into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[q][A query object that determines what endpoints will be returned.]]

[[handler][The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     resolver::results_type results // Resolved endpoints as a range.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]

A successful resolve operation is guaranteed to pass a non-empty range to the handler. 


[endsect]



[section:overload2 ip::basic_resolver::async_resolve (2 of 6 overloads)]


Asynchronously perform forward resolution of a query to a list of entries. 


  template<
      typename ``[link boost_asio.reference.ResolveHandler ResolveHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_resolve(
      string_view host,
      string_view service,
      ResolveHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[handler][The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     resolver::results_type results // Resolved endpoints as a range.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]

A successful resolve operation is guaranteed to pass a non-empty range to the handler.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload3 ip::basic_resolver::async_resolve (3 of 6 overloads)]


Asynchronously perform forward resolution of a query to a list of entries. 


  template<
      typename ``[link boost_asio.reference.ResolveHandler ResolveHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_resolve(
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      ResolveHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the [link boost_asio.reference.ip__resolver_base `ip::resolver_base`]  documentation for the set of available flags.]]

[[handler][The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     resolver::results_type results // Resolved endpoints as a range.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]

A successful resolve operation is guaranteed to pass a non-empty range to the handler.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload4 ip::basic_resolver::async_resolve (4 of 6 overloads)]


Asynchronously perform forward resolution of a query to a list of entries. 


  template<
      typename ``[link boost_asio.reference.ResolveHandler ResolveHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_resolve(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      ResolveHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[handler][The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     resolver::results_type results // Resolved endpoints as a range.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]

A successful resolve operation is guaranteed to pass a non-empty range to the handler.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload5 ip::basic_resolver::async_resolve (5 of 6 overloads)]


Asynchronously perform forward resolution of a query to a list of entries. 


  template<
      typename ``[link boost_asio.reference.ResolveHandler ResolveHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_resolve(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      ResolveHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the [link boost_asio.reference.ip__resolver_base `ip::resolver_base`]  documentation for the set of available flags.]]

[[handler][The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     resolver::results_type results // Resolved endpoints as a range.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]

A successful resolve operation is guaranteed to pass a non-empty range to the handler.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload6 ip::basic_resolver::async_resolve (6 of 6 overloads)]


Asynchronously perform reverse resolution of an endpoint to a list of entries. 


  template<
      typename ``[link boost_asio.reference.ResolveHandler ResolveHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_resolve(
      const endpoint_type & e,
      ResolveHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously resolve an endpoint into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[e][An endpoint object that determines what endpoints will be returned.]]

[[handler][The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     resolver::results_type results // Resolved endpoints as a range.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]

A successful resolve operation is guaranteed to pass a non-empty range to the handler. 


[endsect]


[endsect]

[section:basic_resolver ip::basic_resolver::basic_resolver]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.basic_resolver..basic_resolver..ip::basic_resolver] 
Construct with executor. 


  explicit ``[link boost_asio.reference.ip__basic_resolver.basic_resolver.overload1 basic_resolver]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.basic_resolver.overload1 more...]]``


Construct with execution context. 


  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.ip__basic_resolver.basic_resolver.overload2 basic_resolver]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.basic_resolver.overload2 more...]]``


Move-construct a [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] from another. 


  ``[link boost_asio.reference.ip__basic_resolver.basic_resolver.overload3 basic_resolver]``(
      basic_resolver && other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.basic_resolver.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  ``[link boost_asio.reference.ip__basic_resolver.basic_resolver.overload4 basic_resolver]``(
      basic_resolver< InternetProtocol, Executor1 > && other,
      typename constraint< is_convertible< Executor1, Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.basic_resolver.overload4 more...]]``


[section:overload1 ip::basic_resolver::basic_resolver (1 of 4 overloads)]


Construct with executor. 


  basic_resolver(
      const executor_type & ex);


This constructor creates a [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`].


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the resolver will use, by default, to dispatch handlers for any asynchronous operations performed on the resolver. ]]

]




[endsect]



[section:overload2 ip::basic_resolver::basic_resolver (2 of 4 overloads)]


Construct with execution context. 


  template<
      typename ExecutionContext>
  basic_resolver(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`].


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the resolver will use, by default, to dispatch handlers for any asynchronous operations performed on the resolver. ]]

]




[endsect]



[section:overload3 ip::basic_resolver::basic_resolver (3 of 4 overloads)]


Move-construct a [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] from another. 


  basic_resolver(
      basic_resolver && other);


This constructor moves a resolver from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_resolver(const executor_type&) constructor`. 




[endsect]



[section:overload4 ip::basic_resolver::basic_resolver (4 of 4 overloads)]


Move-construct a [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] from another. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  basic_resolver(
      basic_resolver< InternetProtocol, Executor1 > && other,
      typename constraint< is_convertible< Executor1, Executor >::value >::type  = 0);


This constructor moves a resolver from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_resolver(const executor_type&) constructor`. 




[endsect]


[endsect]


[section:cancel ip::basic_resolver::cancel]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.cancel..cancel..ip::basic_resolver] 
Cancel any asynchronous operations that are waiting on the resolver. 


  void cancel();


This function forces the completion of any pending asynchronous operations on the host resolver. The handler for each cancelled operation will be invoked with the `boost::asio::error::operation_aborted` error code. 


[endsect]



[section:canonical_name ip::basic_resolver::canonical_name]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.canonical_name..canonical_name..ip::basic_resolver] 
Determine the canonical name of the host specified in the query. 


  static const flags canonical_name = implementation_defined;



[endsect]



[section:endpoint_type ip::basic_resolver::endpoint_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.endpoint_type..endpoint_type..ip::basic_resolver] 
The endpoint type. 


  typedef InternetProtocol::endpoint endpoint_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:executor_type ip::basic_resolver::executor_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.executor_type..executor_type..ip::basic_resolver] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:flags ip::basic_resolver::flags]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.flags..flags..ip::basic_resolver] 
A bitmask type (C++ Std [lib.bitmask.types]). 


  typedef unspecified flags;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor ip::basic_resolver::get_executor]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.get_executor..get_executor..ip::basic_resolver] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:iterator ip::basic_resolver::iterator]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.iterator..iterator..ip::basic_resolver] 
(Deprecated.) The iterator type. 


  typedef basic_resolver_iterator< InternetProtocol > iterator;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.difference_type [*difference_type]]]
    [The type used for the distance between two iterators. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.iterator_category [*iterator_category]]]
    [The iterator category. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.pointer [*pointer]]]
    [The type of the result of applying operator->() to the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.reference [*reference]]]
    [The type of the result of applying operator*() to the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.value_type [*value_type]]]
    [The type of the value pointed to by the iterator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.basic_resolver_iterator [*basic_resolver_iterator]] [constructor]]
    [Default constructor creates an end iterator. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator__star_ [*operator *]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_plus__plus_ [*operator++]]]
    [Increment operator (prefix). 
     [hr]
     Increment operator (postfix). ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_arrow_ [*operator->]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move-assignment operator. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.dereference [*dereference]]]
    []
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.equal [*equal]]]
    []
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.increment [*increment]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.index_ [*index_]]]
    []
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.values_ [*values_]]]
    []
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_not__eq_ [*operator!=]]]
    [Test two iterators for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_eq__eq_ [*operator==]]]
    [Test two iterators for equality. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_resolver_iterator `ip::basic_resolver_iterator`] class template is used to define iterators over the results returned by a resolver.

The iterator's value\_type, obtained when the iterator is dereferenced, is: 

   const basic_resolver_entry<InternetProtocol> 





[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:numeric_host ip::basic_resolver::numeric_host]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.numeric_host..numeric_host..ip::basic_resolver] 
Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. 


  static const flags numeric_host = implementation_defined;



[endsect]



[section:numeric_service ip::basic_resolver::numeric_service]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.numeric_service..numeric_service..ip::basic_resolver] 
Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. 


  static const flags numeric_service = implementation_defined;



[endsect]


[section:operator_eq_ ip::basic_resolver::operator=]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.operator_eq_..operator=..ip::basic_resolver] 
Move-assign a [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] from another. 


  basic_resolver & ``[link boost_asio.reference.ip__basic_resolver.operator_eq_.overload1 operator=]``(
      basic_resolver && other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.operator_eq_.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_resolver & >::type ``[link boost_asio.reference.ip__basic_resolver.operator_eq_.overload2 operator=]``(
      basic_resolver< InternetProtocol, Executor1 > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.operator_eq_.overload2 more...]]``


[section:overload1 ip::basic_resolver::operator= (1 of 2 overloads)]


Move-assign a [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] from another. 


  basic_resolver & operator=(
      basic_resolver && other);


This assignment operator moves a resolver from one object to another. Cancels any outstanding asynchronous operations associated with the target object.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_resolver(const executor_type&) constructor`. 




[endsect]



[section:overload2 ip::basic_resolver::operator= (2 of 2 overloads)]


Move-assign a [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] from another. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  constraint< is_convertible< Executor1, Executor >::value, basic_resolver & >::type operator=(
      basic_resolver< InternetProtocol, Executor1 > && other);


This assignment operator moves a resolver from one object to another. Cancels any outstanding asynchronous operations associated with the target object.


[heading Parameters]
    

[variablelist
  
[[other][The other [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_resolver(const executor_type&) constructor`. 




[endsect]


[endsect]


[section:passive ip::basic_resolver::passive]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.passive..passive..ip::basic_resolver] 
Indicate that returned endpoint is intended for use as a locally bound socket endpoint. 


  static const flags passive = implementation_defined;



[endsect]



[section:protocol_type ip::basic_resolver::protocol_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.protocol_type..protocol_type..ip::basic_resolver] 
The protocol type. 


  typedef InternetProtocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:query ip::basic_resolver::query]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.query..query..ip::basic_resolver] 
(Deprecated.) The query type. 


  typedef basic_resolver_query< InternetProtocol > query;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_query.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_query.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint query. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.basic_resolver_query [*basic_resolver_query]] [constructor]]
    [Construct with specified service name for any protocol. 
     [hr]
     Construct with specified service name for a given protocol. 
     [hr]
     Construct with specified host name and service name for any protocol. 
     [hr]
     Construct with specified host name and service name for a given protocol. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_query.hints [*hints]]]
    [Get the hints associated with the query. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_query.host_name [*host_name]]]
    [Get the host name associated with the query. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_query.service_name [*service_name]]]
    [Get the service name associated with the query. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.address_configured [*address_configured]] [static]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.all_matching [*all_matching]] [static]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.canonical_name [*canonical_name]] [static]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.numeric_host [*numeric_host]] [static]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.numeric_service [*numeric_service]] [static]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.passive [*passive]] [static]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.v4_mapped [*v4_mapped]] [static]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]

The [link boost_asio.reference.ip__basic_resolver_query `ip::basic_resolver_query`] class template describes a query that can be passed to a resolver.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:resolve ip::basic_resolver::resolve]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.resolve..resolve..ip::basic_resolver] 
(Deprecated: Use overload with separate host and service parameters.) Perform forward resolution of a query to a list of entries. 


  results_type ``[link boost_asio.reference.ip__basic_resolver.resolve.overload1 resolve]``(
      const query & q);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.resolve.overload1 more...]]``

  results_type ``[link boost_asio.reference.ip__basic_resolver.resolve.overload2 resolve]``(
      const query & q,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.resolve.overload2 more...]]``


Perform forward resolution of a query to a list of entries. 


  results_type ``[link boost_asio.reference.ip__basic_resolver.resolve.overload3 resolve]``(
      string_view host,
      string_view service);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.resolve.overload3 more...]]``

  results_type ``[link boost_asio.reference.ip__basic_resolver.resolve.overload4 resolve]``(
      string_view host,
      string_view service,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.resolve.overload4 more...]]``

  results_type ``[link boost_asio.reference.ip__basic_resolver.resolve.overload5 resolve]``(
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.resolve.overload5 more...]]``

  results_type ``[link boost_asio.reference.ip__basic_resolver.resolve.overload6 resolve]``(
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.resolve.overload6 more...]]``

  results_type ``[link boost_asio.reference.ip__basic_resolver.resolve.overload7 resolve]``(
      const protocol_type & protocol,
      string_view host,
      string_view service);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.resolve.overload7 more...]]``

  results_type ``[link boost_asio.reference.ip__basic_resolver.resolve.overload8 resolve]``(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.resolve.overload8 more...]]``

  results_type ``[link boost_asio.reference.ip__basic_resolver.resolve.overload9 resolve]``(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.resolve.overload9 more...]]``

  results_type ``[link boost_asio.reference.ip__basic_resolver.resolve.overload10 resolve]``(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.resolve.overload10 more...]]``


Perform reverse resolution of an endpoint to a list of entries. 


  results_type ``[link boost_asio.reference.ip__basic_resolver.resolve.overload11 resolve]``(
      const endpoint_type & e);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.resolve.overload11 more...]]``

  results_type ``[link boost_asio.reference.ip__basic_resolver.resolve.overload12 resolve]``(
      const endpoint_type & e,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver.resolve.overload12 more...]]``


[section:overload1 ip::basic_resolver::resolve (1 of 12 overloads)]


(Deprecated: Use overload with separate host and service parameters.) Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      const query & q);


This function is used to resolve a query into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[q][A query object that determines what endpoints will be returned.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 ip::basic_resolver::resolve (2 of 12 overloads)]


(Deprecated: Use overload with separate host and service parameters.) Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      const query & q,
      boost::system::error_code & ec);


This function is used to resolve a query into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[q][A query object that determines what endpoints will be returned.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range. 




[endsect]



[section:overload3 ip::basic_resolver::resolve (3 of 12 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      string_view host,
      string_view service);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload4 ip::basic_resolver::resolve (4 of 12 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      string_view host,
      string_view service,
      boost::system::error_code & ec);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload5 ip::basic_resolver::resolve (5 of 12 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the [link boost_asio.reference.ip__resolver_base `ip::resolver_base`]  documentation for the set of available flags.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload6 ip::basic_resolver::resolve (6 of 12 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      boost::system::error_code & ec);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the [link boost_asio.reference.ip__resolver_base `ip::resolver_base`]  documentation for the set of available flags.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload7 ip::basic_resolver::resolve (7 of 12 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      const protocol_type & protocol,
      string_view host,
      string_view service);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload8 ip::basic_resolver::resolve (8 of 12 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      boost::system::error_code & ec);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload9 ip::basic_resolver::resolve (9 of 12 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the [link boost_asio.reference.ip__resolver_base `ip::resolver_base`]  documentation for the set of available flags.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload10 ip::basic_resolver::resolve (10 of 12 overloads)]


Perform forward resolution of a query to a list of entries. 


  results_type resolve(
      const protocol_type & protocol,
      string_view host,
      string_view service,
      resolver_base::flags resolve_flags,
      boost::system::error_code & ec);


This function is used to resolve host and service names into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts. See the [link boost_asio.reference.ip__resolver_base `ip::resolver_base`]  documentation for the set of available flags.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range.


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload11 ip::basic_resolver::resolve (11 of 12 overloads)]


Perform reverse resolution of an endpoint to a list of entries. 


  results_type resolve(
      const endpoint_type & e);


This function is used to resolve an endpoint into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[e][An endpoint object that determines what endpoints will be returned.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. A successful call to this function is guaranteed to return a non-empty range.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload12 ip::basic_resolver::resolve (12 of 12 overloads)]


Perform reverse resolution of an endpoint to a list of entries. 


  results_type resolve(
      const endpoint_type & e,
      boost::system::error_code & ec);


This function is used to resolve an endpoint into a list of endpoint entries.


[heading Parameters]
    

[variablelist
  
[[e][An endpoint object that determines what endpoints will be returned.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
A range object representing the list of endpoint entries. An empty range is returned if an error occurs. A successful call to this function is guaranteed to return a non-empty range. 




[endsect]


[endsect]


[section:results_type ip::basic_resolver::results_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.results_type..results_type..ip::basic_resolver] 
The results type. 


  typedef basic_resolver_results< InternetProtocol > results_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.const_iterator [*const_iterator]]]
    [The type of an iterator into the range. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.const_reference [*const_reference]]]
    [The type of a const reference to a value in the range. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.difference_type [*difference_type]]]
    [Type used to represent the distance between two iterators in the range. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the results. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.iterator [*iterator]]]
    [The type of an iterator into the range. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.iterator_category [*iterator_category]]]
    [The iterator category. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.pointer [*pointer]]]
    [The type of the result of applying operator->() to the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.protocol_type [*protocol_type]]]
    [The protocol type associated with the results. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.reference [*reference]]]
    [The type of a non-const reference to a value in the range. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.size_type [*size_type]]]
    [Type used to represent a count of the elements in the range. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.value_type [*value_type]]]
    [The type of a value in the results range. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_results.basic_resolver_results [*basic_resolver_results]] [constructor]]
    [Default constructor creates an empty range. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.begin [*begin]]]
    [Obtain a begin iterator for the results range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.cbegin [*cbegin]]]
    [Obtain a begin iterator for the results range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.cend [*cend]]]
    [Obtain an end iterator for the results range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.empty [*empty]]]
    [Determine whether the results range is empty. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.end [*end]]]
    [Obtain an end iterator for the results range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.max_size [*max_size]]]
    [Get the maximum number of entries permitted in a results range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.operator__star_ [*operator *]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.operator_plus__plus_ [*operator++]]]
    [Increment operator (prefix). 
     [hr]
     Increment operator (postfix). ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.operator_arrow_ [*operator->]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move-assignment operator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.size [*size]]]
    [Get the number of entries in the results range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.swap [*swap]]]
    [Swap the results range with another. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_results.dereference [*dereference]]]
    []
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.equal [*equal]]]
    []
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.increment [*increment]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_results.index_ [*index_]]]
    []
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_results.values_ [*values_]]]
    []
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_results.operator_not__eq_ [*operator!=]]]
    [Test two iterators for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.operator_eq__eq_ [*operator==]]]
    [Test two iterators for equality. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_resolver_results `ip::basic_resolver_results`] class template is used to define a range over the results returned by a resolver.

The iterator's value\_type, obtained when a results iterator is dereferenced, is:

   const basic_resolver_entry<InternetProtocol> 





[heading Remarks]
      
For backward compatibility, [link boost_asio.reference.ip__basic_resolver_results `ip::basic_resolver_results`] is derived from [link boost_asio.reference.ip__basic_resolver_iterator `ip::basic_resolver_iterator`]. This derivation is deprecated.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:v4_mapped ip::basic_resolver::v4_mapped]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver.v4_mapped..v4_mapped..ip::basic_resolver] 
If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. 


  static const flags v4_mapped = implementation_defined;



[endsect]



[section:_basic_resolver ip::basic_resolver::~basic_resolver]

[indexterm2 boost_asio.indexterm.ip__basic_resolver._basic_resolver..~basic_resolver..ip::basic_resolver] 
Destroys the resolver. 


  ~basic_resolver();


This function destroys the resolver, cancelling any outstanding asynchronous wait operations associated with the resolver as if by calling `cancel`. 


[endsect]



[endsect]

[section:ip__basic_resolver__rebind_executor ip::basic_resolver::rebind_executor]

[indexterm1 boost_asio.indexterm.ip__basic_resolver__rebind_executor..ip::basic_resolver::rebind_executor]


Rebinds the resolver type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver__rebind_executor.other [*other]]]
    [The resolver type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other ip::basic_resolver::rebind_executor::other]

[indexterm2 boost_asio.indexterm.ip__basic_resolver__rebind_executor.other..other..ip::basic_resolver::rebind_executor] 
The resolver type when rebound to the specified executor. 


  typedef basic_resolver< InternetProtocol, Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver__rebind_executor [*rebind_executor]]]
    [Rebinds the resolver type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.iterator [*iterator]]]
    [(Deprecated.) The iterator type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.query [*query]]]
    [(Deprecated.) The query type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.results_type [*results_type]]]
    [The results type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver.async_resolve [*async_resolve]]]
    [(Deprecated: Use overload with separate host and service parameters.) Asynchronously perform forward resolution of a query to a list of entries. 
     [hr]
     Asynchronously perform forward resolution of a query to a list of entries. 
     [hr]
     Asynchronously perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.basic_resolver [*basic_resolver]] [constructor]]
    [Construct with executor. 
     [hr]
     Construct with execution context. 
     [hr]
     Move-construct a basic_resolver from another. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the resolver. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.operator_eq_ [*operator=]]]
    [Move-assign a basic_resolver from another. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.resolve [*resolve]]]
    [(Deprecated: Use overload with separate host and service parameters.) Perform forward resolution of a query to a list of entries. 
     [hr]
     Perform forward resolution of a query to a list of entries. 
     [hr]
     Perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver._basic_resolver [*~basic_resolver]] [destructor]]
    [Destroys the resolver. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver.address_configured [*address_configured]] [static]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.all_matching [*all_matching]] [static]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.canonical_name [*canonical_name]] [static]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.numeric_host [*numeric_host]] [static]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.numeric_service [*numeric_service]] [static]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.passive [*passive]] [static]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.v4_mapped [*v4_mapped]] [static]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]

The [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] class template provides the ability to resolve a query to a list of endpoints.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:ip__basic_resolver_entry ip::basic_resolver_entry]

[indexterm1 boost_asio.indexterm.ip__basic_resolver_entry..ip::basic_resolver_entry]


An entry produced by a resolver. 


  template<
      typename ``[link boost_asio.reference.InternetProtocol InternetProtocol]``>
  class basic_resolver_entry


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_entry.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the endpoint entry. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_entry.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint entry. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_entry.basic_resolver_entry [*basic_resolver_entry]] [constructor]]
    [Default constructor. 
     [hr]
     Construct with specified endpoint, host name and service name. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.endpoint [*endpoint]]]
    [Get the endpoint associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.host_name [*host_name]]]
    [Get the host name associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.operator_endpoint_type [*operator endpoint_type]]]
    [Convert to the endpoint associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.service_name [*service_name]]]
    [Get the service name associated with the entry. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_resolver_entry `ip::basic_resolver_entry`] class template describes an entry as returned by a resolver.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_entry.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_resolver_entry ip::basic_resolver_entry::basic_resolver_entry]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_entry.basic_resolver_entry..basic_resolver_entry..ip::basic_resolver_entry] 
Default constructor. 


  ``[link boost_asio.reference.ip__basic_resolver_entry.basic_resolver_entry.overload1 basic_resolver_entry]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_entry.basic_resolver_entry.overload1 more...]]``


Construct with specified endpoint, host name and service name. 


  ``[link boost_asio.reference.ip__basic_resolver_entry.basic_resolver_entry.overload2 basic_resolver_entry]``(
      const endpoint_type & ep,
      string_view host,
      string_view service);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_entry.basic_resolver_entry.overload2 more...]]``


[section:overload1 ip::basic_resolver_entry::basic_resolver_entry (1 of 2 overloads)]


Default constructor. 


  basic_resolver_entry();



[endsect]



[section:overload2 ip::basic_resolver_entry::basic_resolver_entry (2 of 2 overloads)]


Construct with specified endpoint, host name and service name. 


  basic_resolver_entry(
      const endpoint_type & ep,
      string_view host,
      string_view service);



[endsect]


[endsect]


[section:endpoint ip::basic_resolver_entry::endpoint]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_entry.endpoint..endpoint..ip::basic_resolver_entry] 
Get the endpoint associated with the entry. 


  endpoint_type endpoint() const;



[endsect]



[section:endpoint_type ip::basic_resolver_entry::endpoint_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_entry.endpoint_type..endpoint_type..ip::basic_resolver_entry] 
The endpoint type associated with the endpoint entry. 


  typedef InternetProtocol::endpoint endpoint_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_entry.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:host_name ip::basic_resolver_entry::host_name]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_entry.host_name..host_name..ip::basic_resolver_entry] 
Get the host name associated with the entry. 


  std::string ``[link boost_asio.reference.ip__basic_resolver_entry.host_name.overload1 host_name]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_entry.host_name.overload1 more...]]``

  template<
      class Allocator>
  std::basic_string< char, std::char_traits< char >, Allocator > ``[link boost_asio.reference.ip__basic_resolver_entry.host_name.overload2 host_name]``(
      const Allocator & alloc = Allocator()) const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_entry.host_name.overload2 more...]]``


[section:overload1 ip::basic_resolver_entry::host_name (1 of 2 overloads)]


Get the host name associated with the entry. 


  std::string host_name() const;



[endsect]



[section:overload2 ip::basic_resolver_entry::host_name (2 of 2 overloads)]


Get the host name associated with the entry. 


  template<
      class Allocator>
  std::basic_string< char, std::char_traits< char >, Allocator > host_name(
      const Allocator & alloc = Allocator()) const;



[endsect]


[endsect]


[section:operator_endpoint_type ip::basic_resolver_entry::operator endpoint_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_entry.operator_endpoint_type..operator endpoint_type..ip::basic_resolver_entry] 
Convert to the endpoint associated with the entry. 


  operator endpoint_type() const;



[endsect]



[section:protocol_type ip::basic_resolver_entry::protocol_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_entry.protocol_type..protocol_type..ip::basic_resolver_entry] 
The protocol type associated with the endpoint entry. 


  typedef InternetProtocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_entry.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:service_name ip::basic_resolver_entry::service_name]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_entry.service_name..service_name..ip::basic_resolver_entry] 
Get the service name associated with the entry. 


  std::string ``[link boost_asio.reference.ip__basic_resolver_entry.service_name.overload1 service_name]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_entry.service_name.overload1 more...]]``

  template<
      class Allocator>
  std::basic_string< char, std::char_traits< char >, Allocator > ``[link boost_asio.reference.ip__basic_resolver_entry.service_name.overload2 service_name]``(
      const Allocator & alloc = Allocator()) const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_entry.service_name.overload2 more...]]``


[section:overload1 ip::basic_resolver_entry::service_name (1 of 2 overloads)]


Get the service name associated with the entry. 


  std::string service_name() const;



[endsect]



[section:overload2 ip::basic_resolver_entry::service_name (2 of 2 overloads)]


Get the service name associated with the entry. 


  template<
      class Allocator>
  std::basic_string< char, std::char_traits< char >, Allocator > service_name(
      const Allocator & alloc = Allocator()) const;



[endsect]


[endsect]


[endsect]

[section:ip__basic_resolver_iterator ip::basic_resolver_iterator]

[indexterm1 boost_asio.indexterm.ip__basic_resolver_iterator..ip::basic_resolver_iterator]


An iterator over the entries produced by a resolver. 


  template<
      typename ``[link boost_asio.reference.InternetProtocol InternetProtocol]``>
  class basic_resolver_iterator


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.difference_type [*difference_type]]]
    [The type used for the distance between two iterators. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.iterator_category [*iterator_category]]]
    [The iterator category. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.pointer [*pointer]]]
    [The type of the result of applying operator->() to the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.reference [*reference]]]
    [The type of the result of applying operator*() to the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.value_type [*value_type]]]
    [The type of the value pointed to by the iterator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.basic_resolver_iterator [*basic_resolver_iterator]] [constructor]]
    [Default constructor creates an end iterator. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator__star_ [*operator *]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_plus__plus_ [*operator++]]]
    [Increment operator (prefix). 
     [hr]
     Increment operator (postfix). ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_arrow_ [*operator->]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move-assignment operator. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.dereference [*dereference]]]
    []
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.equal [*equal]]]
    []
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.increment [*increment]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.index_ [*index_]]]
    []
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.values_ [*values_]]]
    []
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_not__eq_ [*operator!=]]]
    [Test two iterators for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_eq__eq_ [*operator==]]]
    [Test two iterators for equality. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_resolver_iterator `ip::basic_resolver_iterator`] class template is used to define iterators over the results returned by a resolver.

The iterator's value\_type, obtained when the iterator is dereferenced, is: 

   const basic_resolver_entry<InternetProtocol> 





[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_resolver_iterator ip::basic_resolver_iterator::basic_resolver_iterator]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.basic_resolver_iterator..basic_resolver_iterator..ip::basic_resolver_iterator] 
Default constructor creates an end iterator. 


  ``[link boost_asio.reference.ip__basic_resolver_iterator.basic_resolver_iterator.overload1 basic_resolver_iterator]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_iterator.basic_resolver_iterator.overload1 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.ip__basic_resolver_iterator.basic_resolver_iterator.overload2 basic_resolver_iterator]``(
      const basic_resolver_iterator & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_iterator.basic_resolver_iterator.overload2 more...]]``


Move constructor. 


  ``[link boost_asio.reference.ip__basic_resolver_iterator.basic_resolver_iterator.overload3 basic_resolver_iterator]``(
      basic_resolver_iterator && other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_iterator.basic_resolver_iterator.overload3 more...]]``


[section:overload1 ip::basic_resolver_iterator::basic_resolver_iterator (1 of 3 overloads)]


Default constructor creates an end iterator. 


  basic_resolver_iterator();



[endsect]



[section:overload2 ip::basic_resolver_iterator::basic_resolver_iterator (2 of 3 overloads)]


Copy constructor. 


  basic_resolver_iterator(
      const basic_resolver_iterator & other);



[endsect]



[section:overload3 ip::basic_resolver_iterator::basic_resolver_iterator (3 of 3 overloads)]


Move constructor. 


  basic_resolver_iterator(
      basic_resolver_iterator && other);



[endsect]


[endsect]


[section:dereference ip::basic_resolver_iterator::dereference]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.dereference..dereference..ip::basic_resolver_iterator] 

  const basic_resolver_entry< InternetProtocol > & dereference() const;



[endsect]



[section:difference_type ip::basic_resolver_iterator::difference_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.difference_type..difference_type..ip::basic_resolver_iterator] 
The type used for the distance between two iterators. 


  typedef std::ptrdiff_t difference_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:equal ip::basic_resolver_iterator::equal]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.equal..equal..ip::basic_resolver_iterator] 

  bool equal(
      const basic_resolver_iterator & other) const;



[endsect]



[section:increment ip::basic_resolver_iterator::increment]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.increment..increment..ip::basic_resolver_iterator] 

  void increment();



[endsect]



[section:index_ ip::basic_resolver_iterator::index_]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.index_..index_..ip::basic_resolver_iterator] 

  std::size_t index_;



[endsect]



[section:iterator_category ip::basic_resolver_iterator::iterator_category]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.iterator_category..iterator_category..ip::basic_resolver_iterator] 
The iterator category. 


  typedef std::forward_iterator_tag iterator_category;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator__star_ ip::basic_resolver_iterator::operator *]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.operator__star_..operator *..ip::basic_resolver_iterator] 
Dereference an iterator. 


  const basic_resolver_entry< InternetProtocol > & operator *() const;



[endsect]



[section:operator_not__eq_ ip::basic_resolver_iterator::operator!=]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.operator_not__eq_..operator!=..ip::basic_resolver_iterator] 
Test two iterators for inequality. 


  friend bool operator!=(
      const basic_resolver_iterator & a,
      const basic_resolver_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:operator_plus__plus_ ip::basic_resolver_iterator::operator++]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.operator_plus__plus_..operator++..ip::basic_resolver_iterator] 
Increment operator (prefix). 


  basic_resolver_iterator & ``[link boost_asio.reference.ip__basic_resolver_iterator.operator_plus__plus_.overload1 operator++]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_iterator.operator_plus__plus_.overload1 more...]]``


Increment operator (postfix). 


  basic_resolver_iterator ``[link boost_asio.reference.ip__basic_resolver_iterator.operator_plus__plus_.overload2 operator++]``(
      int );
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_iterator.operator_plus__plus_.overload2 more...]]``


[section:overload1 ip::basic_resolver_iterator::operator++ (1 of 2 overloads)]


Increment operator (prefix). 


  basic_resolver_iterator & operator++();



[endsect]



[section:overload2 ip::basic_resolver_iterator::operator++ (2 of 2 overloads)]


Increment operator (postfix). 


  basic_resolver_iterator operator++(
      int );



[endsect]


[endsect]


[section:operator_arrow_ ip::basic_resolver_iterator::operator->]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.operator_arrow_..operator->..ip::basic_resolver_iterator] 
Dereference an iterator. 


  const basic_resolver_entry< InternetProtocol > * operator->() const;



[endsect]


[section:operator_eq_ ip::basic_resolver_iterator::operator=]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.operator_eq_..operator=..ip::basic_resolver_iterator] 
Assignment operator. 


  basic_resolver_iterator & ``[link boost_asio.reference.ip__basic_resolver_iterator.operator_eq_.overload1 operator=]``(
      const basic_resolver_iterator & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_iterator.operator_eq_.overload1 more...]]``


Move-assignment operator. 


  basic_resolver_iterator & ``[link boost_asio.reference.ip__basic_resolver_iterator.operator_eq_.overload2 operator=]``(
      basic_resolver_iterator && other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_iterator.operator_eq_.overload2 more...]]``


[section:overload1 ip::basic_resolver_iterator::operator= (1 of 2 overloads)]


Assignment operator. 


  basic_resolver_iterator & operator=(
      const basic_resolver_iterator & other);



[endsect]



[section:overload2 ip::basic_resolver_iterator::operator= (2 of 2 overloads)]


Move-assignment operator. 


  basic_resolver_iterator & operator=(
      basic_resolver_iterator && other);



[endsect]


[endsect]


[section:operator_eq__eq_ ip::basic_resolver_iterator::operator==]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.operator_eq__eq_..operator==..ip::basic_resolver_iterator] 
Test two iterators for equality. 


  friend bool operator==(
      const basic_resolver_iterator & a,
      const basic_resolver_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:pointer ip::basic_resolver_iterator::pointer]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.pointer..pointer..ip::basic_resolver_iterator] 
The type of the result of applying `operator->()` to the iterator. 


  typedef const basic_resolver_entry< InternetProtocol > * pointer;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:reference ip::basic_resolver_iterator::reference]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.reference..reference..ip::basic_resolver_iterator] 
The type of the result of applying `operator*()` to the iterator. 


  typedef const basic_resolver_entry< InternetProtocol > & reference;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_entry.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the endpoint entry. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_entry.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint entry. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_entry.basic_resolver_entry [*basic_resolver_entry]] [constructor]]
    [Default constructor. 
     [hr]
     Construct with specified endpoint, host name and service name. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.endpoint [*endpoint]]]
    [Get the endpoint associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.host_name [*host_name]]]
    [Get the host name associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.operator_endpoint_type [*operator endpoint_type]]]
    [Convert to the endpoint associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.service_name [*service_name]]]
    [Get the service name associated with the entry. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_resolver_entry `ip::basic_resolver_entry`] class template describes an entry as returned by a resolver.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:value_type ip::basic_resolver_iterator::value_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.value_type..value_type..ip::basic_resolver_iterator] 
The type of the value pointed to by the iterator. 


  typedef basic_resolver_entry< InternetProtocol > value_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_entry.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the endpoint entry. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_entry.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint entry. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_entry.basic_resolver_entry [*basic_resolver_entry]] [constructor]]
    [Default constructor. 
     [hr]
     Construct with specified endpoint, host name and service name. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.endpoint [*endpoint]]]
    [Get the endpoint associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.host_name [*host_name]]]
    [Get the host name associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.operator_endpoint_type [*operator endpoint_type]]]
    [Convert to the endpoint associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.service_name [*service_name]]]
    [Get the service name associated with the entry. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_resolver_entry `ip::basic_resolver_entry`] class template describes an entry as returned by a resolver.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_iterator.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:values_ ip::basic_resolver_iterator::values_]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_iterator.values_..values_..ip::basic_resolver_iterator] 

  values_ptr_type values_;



[endsect]



[endsect]

[section:ip__basic_resolver_query ip::basic_resolver_query]

[indexterm1 boost_asio.indexterm.ip__basic_resolver_query..ip::basic_resolver_query]


An query to be passed to a resolver. 


  template<
      typename ``[link boost_asio.reference.InternetProtocol InternetProtocol]``>
  class basic_resolver_query :
    public ip::resolver_query_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_query.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_query.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint query. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.basic_resolver_query [*basic_resolver_query]] [constructor]]
    [Construct with specified service name for any protocol. 
     [hr]
     Construct with specified service name for a given protocol. 
     [hr]
     Construct with specified host name and service name for any protocol. 
     [hr]
     Construct with specified host name and service name for a given protocol. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_query.hints [*hints]]]
    [Get the hints associated with the query. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_query.host_name [*host_name]]]
    [Get the host name associated with the query. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_query.service_name [*service_name]]]
    [Get the service name associated with the query. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.address_configured [*address_configured]] [static]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.all_matching [*all_matching]] [static]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.canonical_name [*canonical_name]] [static]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.numeric_host [*numeric_host]] [static]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.numeric_service [*numeric_service]] [static]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.passive [*passive]] [static]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_query.v4_mapped [*v4_mapped]] [static]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]

The [link boost_asio.reference.ip__basic_resolver_query `ip::basic_resolver_query`] class template describes a query that can be passed to a resolver.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_query.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:address_configured ip::basic_resolver_query::address_configured]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_query.address_configured..address_configured..ip::basic_resolver_query] 
Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. 


  static const flags address_configured = implementation_defined;



[endsect]



[section:all_matching ip::basic_resolver_query::all_matching]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_query.all_matching..all_matching..ip::basic_resolver_query] 
If used with v4\_mapped, return all matching IPv6 and IPv4 addresses. 


  static const flags all_matching = implementation_defined;



[endsect]


[section:basic_resolver_query ip::basic_resolver_query::basic_resolver_query]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_query.basic_resolver_query..basic_resolver_query..ip::basic_resolver_query] 
Construct with specified service name for any protocol. 


  ``[link boost_asio.reference.ip__basic_resolver_query.basic_resolver_query.overload1 basic_resolver_query]``(
      const std::string & service,
      resolver_query_base::flags resolve_flags = passive|address_configured);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_query.basic_resolver_query.overload1 more...]]``


Construct with specified service name for a given protocol. 


  ``[link boost_asio.reference.ip__basic_resolver_query.basic_resolver_query.overload2 basic_resolver_query]``(
      const protocol_type & protocol,
      const std::string & service,
      resolver_query_base::flags resolve_flags = passive|address_configured);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_query.basic_resolver_query.overload2 more...]]``


Construct with specified host name and service name for any protocol. 


  ``[link boost_asio.reference.ip__basic_resolver_query.basic_resolver_query.overload3 basic_resolver_query]``(
      const std::string & host,
      const std::string & service,
      resolver_query_base::flags resolve_flags = address_configured);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_query.basic_resolver_query.overload3 more...]]``


Construct with specified host name and service name for a given protocol. 


  ``[link boost_asio.reference.ip__basic_resolver_query.basic_resolver_query.overload4 basic_resolver_query]``(
      const protocol_type & protocol,
      const std::string & host,
      const std::string & service,
      resolver_query_base::flags resolve_flags = address_configured);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_query.basic_resolver_query.overload4 more...]]``


[section:overload1 ip::basic_resolver_query::basic_resolver_query (1 of 4 overloads)]


Construct with specified service name for any protocol. 


  basic_resolver_query(
      const std::string & service,
      resolver_query_base::flags resolve_flags = passive|address_configured);


This constructor is typically used to perform name resolution for local service binding.


[heading Parameters]
    

[variablelist
  
[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for local service binding.]]

]


[heading Remarks]
      
On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 




[endsect]



[section:overload2 ip::basic_resolver_query::basic_resolver_query (2 of 4 overloads)]


Construct with specified service name for a given protocol. 


  basic_resolver_query(
      const protocol_type & protocol,
      const std::string & service,
      resolver_query_base::flags resolve_flags = passive|address_configured);


This constructor is typically used to perform name resolution for local service binding with a specific protocol version.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for local service binding.]]

]


[heading Remarks]
      
On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 




[endsect]



[section:overload3 ip::basic_resolver_query::basic_resolver_query (3 of 4 overloads)]


Construct with specified host name and service name for any protocol. 


  basic_resolver_query(
      const std::string & host,
      const std::string & service,
      resolver_query_base::flags resolve_flags = address_configured);


This constructor is typically used to perform name resolution for communication with remote hosts.


[heading Parameters]
    

[variablelist
  
[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts.]]

]


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]



[section:overload4 ip::basic_resolver_query::basic_resolver_query (4 of 4 overloads)]


Construct with specified host name and service name for a given protocol. 


  basic_resolver_query(
      const protocol_type & protocol,
      const std::string & host,
      const std::string & service,
      resolver_query_base::flags resolve_flags = address_configured);


This constructor is typically used to perform name resolution for communication with remote hosts.


[heading Parameters]
    

[variablelist
  
[[protocol][A protocol object, normally representing either the IPv4 or IPv6 version of an internet protocol.]]

[[host][A string identifying a location. May be a descriptive name or a numeric address string. If an empty string and the passive flag has been specified, the resolved endpoints are suitable for local service binding. If an empty string and passive is not specified, the resolved endpoints will use the loopback address.]]

[[service][A string identifying the requested service. This may be a descriptive name or a numeric string corresponding to a port number. May be an empty string, in which case all resolved endpoints will have a port number of 0.]]

[[resolve_flags][A set of flags that determine how name resolution should be performed. The default flags are suitable for communication with remote hosts.]]

]


[heading Remarks]
      
On POSIX systems, host names may be locally defined in the file `/etc/hosts`. On Windows, host names may be defined in the file `c:\windows\system32\drivers\etc\hosts`. Remote host name resolution is performed using DNS. Operating systems may use additional locations when resolving host names (such as NETBIOS names on Windows).

On POSIX systems, service names are typically defined in the file `/etc/services`. On Windows, service names may be found in the file `c:\windows\system32\drivers\etc\services`. Operating systems may use additional locations when resolving service names. 


[endsect]


[endsect]


[section:canonical_name ip::basic_resolver_query::canonical_name]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_query.canonical_name..canonical_name..ip::basic_resolver_query] 
Determine the canonical name of the host specified in the query. 


  static const flags canonical_name = implementation_defined;



[endsect]



[section:flags ip::basic_resolver_query::flags]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_query.flags..flags..ip::basic_resolver_query] 
A bitmask type (C++ Std [lib.bitmask.types]). 


  typedef unspecified flags;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_query.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:hints ip::basic_resolver_query::hints]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_query.hints..hints..ip::basic_resolver_query] 
Get the hints associated with the query. 


  const boost::asio::detail::addrinfo_type & hints() const;



[endsect]



[section:host_name ip::basic_resolver_query::host_name]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_query.host_name..host_name..ip::basic_resolver_query] 
Get the host name associated with the query. 


  std::string host_name() const;



[endsect]



[section:numeric_host ip::basic_resolver_query::numeric_host]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_query.numeric_host..numeric_host..ip::basic_resolver_query] 
Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. 


  static const flags numeric_host = implementation_defined;



[endsect]



[section:numeric_service ip::basic_resolver_query::numeric_service]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_query.numeric_service..numeric_service..ip::basic_resolver_query] 
Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. 


  static const flags numeric_service = implementation_defined;



[endsect]



[section:passive ip::basic_resolver_query::passive]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_query.passive..passive..ip::basic_resolver_query] 
Indicate that returned endpoint is intended for use as a locally bound socket endpoint. 


  static const flags passive = implementation_defined;



[endsect]



[section:protocol_type ip::basic_resolver_query::protocol_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_query.protocol_type..protocol_type..ip::basic_resolver_query] 
The protocol type associated with the endpoint query. 


  typedef InternetProtocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_query.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:service_name ip::basic_resolver_query::service_name]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_query.service_name..service_name..ip::basic_resolver_query] 
Get the service name associated with the query. 


  std::string service_name() const;



[endsect]



[section:v4_mapped ip::basic_resolver_query::v4_mapped]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_query.v4_mapped..v4_mapped..ip::basic_resolver_query] 
If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. 


  static const flags v4_mapped = implementation_defined;



[endsect]



[endsect]

[section:ip__basic_resolver_results ip::basic_resolver_results]

[indexterm1 boost_asio.indexterm.ip__basic_resolver_results..ip::basic_resolver_results]


A range of entries produced by a resolver. 


  template<
      typename ``[link boost_asio.reference.InternetProtocol InternetProtocol]``>
  class basic_resolver_results :
    public ip::basic_resolver_iterator< InternetProtocol >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.const_iterator [*const_iterator]]]
    [The type of an iterator into the range. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.const_reference [*const_reference]]]
    [The type of a const reference to a value in the range. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.difference_type [*difference_type]]]
    [Type used to represent the distance between two iterators in the range. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the results. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.iterator [*iterator]]]
    [The type of an iterator into the range. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.iterator_category [*iterator_category]]]
    [The iterator category. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.pointer [*pointer]]]
    [The type of the result of applying operator->() to the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.protocol_type [*protocol_type]]]
    [The protocol type associated with the results. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.reference [*reference]]]
    [The type of a non-const reference to a value in the range. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.size_type [*size_type]]]
    [Type used to represent a count of the elements in the range. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_results.value_type [*value_type]]]
    [The type of a value in the results range. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_results.basic_resolver_results [*basic_resolver_results]] [constructor]]
    [Default constructor creates an empty range. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.begin [*begin]]]
    [Obtain a begin iterator for the results range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.cbegin [*cbegin]]]
    [Obtain a begin iterator for the results range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.cend [*cend]]]
    [Obtain an end iterator for the results range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.empty [*empty]]]
    [Determine whether the results range is empty. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.end [*end]]]
    [Obtain an end iterator for the results range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.max_size [*max_size]]]
    [Get the maximum number of entries permitted in a results range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.operator__star_ [*operator *]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.operator_plus__plus_ [*operator++]]]
    [Increment operator (prefix). 
     [hr]
     Increment operator (postfix). ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.operator_arrow_ [*operator->]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move-assignment operator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.size [*size]]]
    [Get the number of entries in the results range. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.swap [*swap]]]
    [Swap the results range with another. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_results.dereference [*dereference]]]
    []
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.equal [*equal]]]
    []
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.increment [*increment]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_results.index_ [*index_]]]
    []
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_results.values_ [*values_]]]
    []
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_results.operator_not__eq_ [*operator!=]]]
    [Test two iterators for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_results.operator_eq__eq_ [*operator==]]]
    [Test two iterators for equality. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_resolver_results `ip::basic_resolver_results`] class template is used to define a range over the results returned by a resolver.

The iterator's value\_type, obtained when a results iterator is dereferenced, is:

   const basic_resolver_entry<InternetProtocol> 





[heading Remarks]
      
For backward compatibility, [link boost_asio.reference.ip__basic_resolver_results `ip::basic_resolver_results`] is derived from [link boost_asio.reference.ip__basic_resolver_iterator `ip::basic_resolver_iterator`]. This derivation is deprecated.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_resolver_results ip::basic_resolver_results::basic_resolver_results]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.basic_resolver_results..basic_resolver_results..ip::basic_resolver_results] 
Default constructor creates an empty range. 


  ``[link boost_asio.reference.ip__basic_resolver_results.basic_resolver_results.overload1 basic_resolver_results]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_results.basic_resolver_results.overload1 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.ip__basic_resolver_results.basic_resolver_results.overload2 basic_resolver_results]``(
      const basic_resolver_results & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_results.basic_resolver_results.overload2 more...]]``


Move constructor. 


  ``[link boost_asio.reference.ip__basic_resolver_results.basic_resolver_results.overload3 basic_resolver_results]``(
      basic_resolver_results && other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_results.basic_resolver_results.overload3 more...]]``


[section:overload1 ip::basic_resolver_results::basic_resolver_results (1 of 3 overloads)]


Default constructor creates an empty range. 


  basic_resolver_results();



[endsect]



[section:overload2 ip::basic_resolver_results::basic_resolver_results (2 of 3 overloads)]


Copy constructor. 


  basic_resolver_results(
      const basic_resolver_results & other);



[endsect]



[section:overload3 ip::basic_resolver_results::basic_resolver_results (3 of 3 overloads)]


Move constructor. 


  basic_resolver_results(
      basic_resolver_results && other);



[endsect]


[endsect]


[section:begin ip::basic_resolver_results::begin]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.begin..begin..ip::basic_resolver_results] 
Obtain a begin iterator for the results range. 


  const_iterator begin() const;



[endsect]



[section:cbegin ip::basic_resolver_results::cbegin]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.cbegin..cbegin..ip::basic_resolver_results] 
Obtain a begin iterator for the results range. 


  const_iterator cbegin() const;



[endsect]



[section:cend ip::basic_resolver_results::cend]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.cend..cend..ip::basic_resolver_results] 
Obtain an end iterator for the results range. 


  const_iterator cend() const;



[endsect]



[section:const_iterator ip::basic_resolver_results::const_iterator]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.const_iterator..const_iterator..ip::basic_resolver_results] 
The type of an iterator into the range. 


  typedef basic_resolver_iterator< protocol_type > const_iterator;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.difference_type [*difference_type]]]
    [The type used for the distance between two iterators. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.iterator_category [*iterator_category]]]
    [The iterator category. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.pointer [*pointer]]]
    [The type of the result of applying operator->() to the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.reference [*reference]]]
    [The type of the result of applying operator*() to the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.value_type [*value_type]]]
    [The type of the value pointed to by the iterator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.basic_resolver_iterator [*basic_resolver_iterator]] [constructor]]
    [Default constructor creates an end iterator. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator__star_ [*operator *]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_plus__plus_ [*operator++]]]
    [Increment operator (prefix). 
     [hr]
     Increment operator (postfix). ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_arrow_ [*operator->]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move-assignment operator. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.dereference [*dereference]]]
    []
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.equal [*equal]]]
    []
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.increment [*increment]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.index_ [*index_]]]
    []
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.values_ [*values_]]]
    []
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_not__eq_ [*operator!=]]]
    [Test two iterators for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_eq__eq_ [*operator==]]]
    [Test two iterators for equality. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_resolver_iterator `ip::basic_resolver_iterator`] class template is used to define iterators over the results returned by a resolver.

The iterator's value\_type, obtained when the iterator is dereferenced, is: 

   const basic_resolver_entry<InternetProtocol> 





[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:const_reference ip::basic_resolver_results::const_reference]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.const_reference..const_reference..ip::basic_resolver_results] 
The type of a const reference to a value in the range. 


  typedef const value_type & const_reference;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_entry.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the endpoint entry. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_entry.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint entry. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_entry.basic_resolver_entry [*basic_resolver_entry]] [constructor]]
    [Default constructor. 
     [hr]
     Construct with specified endpoint, host name and service name. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.endpoint [*endpoint]]]
    [Get the endpoint associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.host_name [*host_name]]]
    [Get the host name associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.operator_endpoint_type [*operator endpoint_type]]]
    [Convert to the endpoint associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.service_name [*service_name]]]
    [Get the service name associated with the entry. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_resolver_entry `ip::basic_resolver_entry`] class template describes an entry as returned by a resolver.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:dereference ip::basic_resolver_results::dereference]


['Inherited from ip::basic_resolver.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.dereference..dereference..ip::basic_resolver_results] 

  const basic_resolver_entry< InternetProtocol > & dereference() const;



[endsect]



[section:difference_type ip::basic_resolver_results::difference_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.difference_type..difference_type..ip::basic_resolver_results] 
Type used to represent the distance between two iterators in the range. 


  typedef std::ptrdiff_t difference_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:empty ip::basic_resolver_results::empty]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.empty..empty..ip::basic_resolver_results] 
Determine whether the results range is empty. 


  bool empty() const;



[endsect]



[section:end ip::basic_resolver_results::end]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.end..end..ip::basic_resolver_results] 
Obtain an end iterator for the results range. 


  const_iterator end() const;



[endsect]



[section:endpoint_type ip::basic_resolver_results::endpoint_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.endpoint_type..endpoint_type..ip::basic_resolver_results] 
The endpoint type associated with the results. 


  typedef protocol_type::endpoint endpoint_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:equal ip::basic_resolver_results::equal]


['Inherited from ip::basic_resolver.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.equal..equal..ip::basic_resolver_results] 

  bool equal(
      const basic_resolver_iterator & other) const;



[endsect]



[section:increment ip::basic_resolver_results::increment]


['Inherited from ip::basic_resolver.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.increment..increment..ip::basic_resolver_results] 

  void increment();



[endsect]



[section:index_ ip::basic_resolver_results::index_]


['Inherited from ip::basic_resolver.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.index_..index_..ip::basic_resolver_results] 

  std::size_t index_;



[endsect]



[section:iterator ip::basic_resolver_results::iterator]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.iterator..iterator..ip::basic_resolver_results] 
The type of an iterator into the range. 


  typedef const_iterator iterator;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.difference_type [*difference_type]]]
    [The type used for the distance between two iterators. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.iterator_category [*iterator_category]]]
    [The iterator category. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.pointer [*pointer]]]
    [The type of the result of applying operator->() to the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.reference [*reference]]]
    [The type of the result of applying operator*() to the iterator. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_iterator.value_type [*value_type]]]
    [The type of the value pointed to by the iterator. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.basic_resolver_iterator [*basic_resolver_iterator]] [constructor]]
    [Default constructor creates an end iterator. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator__star_ [*operator *]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_plus__plus_ [*operator++]]]
    [Increment operator (prefix). 
     [hr]
     Increment operator (postfix). ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_arrow_ [*operator->]]]
    [Dereference an iterator. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move-assignment operator. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.dereference [*dereference]]]
    []
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.equal [*equal]]]
    []
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.increment [*increment]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.index_ [*index_]]]
    []
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.values_ [*values_]]]
    []
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_not__eq_ [*operator!=]]]
    [Test two iterators for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_iterator.operator_eq__eq_ [*operator==]]]
    [Test two iterators for equality. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_resolver_iterator `ip::basic_resolver_iterator`] class template is used to define iterators over the results returned by a resolver.

The iterator's value\_type, obtained when the iterator is dereferenced, is: 

   const basic_resolver_entry<InternetProtocol> 





[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:iterator_category ip::basic_resolver_results::iterator_category]


['Inherited from ip::basic_resolver.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.iterator_category..iterator_category..ip::basic_resolver_results] 
The iterator category. 


  typedef std::forward_iterator_tag iterator_category;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:max_size ip::basic_resolver_results::max_size]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.max_size..max_size..ip::basic_resolver_results] 
Get the maximum number of entries permitted in a results range. 


  size_type max_size() const;



[endsect]



[section:operator__star_ ip::basic_resolver_results::operator *]


['Inherited from ip::basic_resolver.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.operator__star_..operator *..ip::basic_resolver_results] 
Dereference an iterator. 


  const basic_resolver_entry< InternetProtocol > & operator *() const;



[endsect]


[section:operator_not__eq_ ip::basic_resolver_results::operator!=]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.operator_not__eq_..operator!=..ip::basic_resolver_results] 
Test two iterators for inequality. 


  friend bool ``[link boost_asio.reference.ip__basic_resolver_results.operator_not__eq_.overload1 operator!=]``(
      const basic_resolver_results & a,
      const basic_resolver_results & b);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_results.operator_not__eq_.overload1 more...]]``

  friend bool ``[link boost_asio.reference.ip__basic_resolver_results.operator_not__eq_.overload2 operator!=]``(
      const basic_resolver_iterator & a,
      const basic_resolver_iterator & b);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_results.operator_not__eq_.overload2 more...]]``


[section:overload1 ip::basic_resolver_results::operator!= (1 of 2 overloads)]


Test two iterators for inequality. 


  friend bool operator!=(
      const basic_resolver_results & a,
      const basic_resolver_results & b);


[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:overload2 ip::basic_resolver_results::operator!= (2 of 2 overloads)]


['Inherited from ip::basic_resolver.]


Test two iterators for inequality. 


  friend bool operator!=(
      const basic_resolver_iterator & a,
      const basic_resolver_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[endsect]

[section:operator_plus__plus_ ip::basic_resolver_results::operator++]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.operator_plus__plus_..operator++..ip::basic_resolver_results] 
Increment operator (prefix). 


  basic_resolver_iterator & ``[link boost_asio.reference.ip__basic_resolver_results.operator_plus__plus_.overload1 operator++]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_results.operator_plus__plus_.overload1 more...]]``


Increment operator (postfix). 


  basic_resolver_iterator ``[link boost_asio.reference.ip__basic_resolver_results.operator_plus__plus_.overload2 operator++]``(
      int );
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_results.operator_plus__plus_.overload2 more...]]``


[section:overload1 ip::basic_resolver_results::operator++ (1 of 2 overloads)]


['Inherited from ip::basic_resolver.]


Increment operator (prefix). 


  basic_resolver_iterator & operator++();



[endsect]



[section:overload2 ip::basic_resolver_results::operator++ (2 of 2 overloads)]


['Inherited from ip::basic_resolver.]


Increment operator (postfix). 


  basic_resolver_iterator operator++(
      int );



[endsect]


[endsect]


[section:operator_arrow_ ip::basic_resolver_results::operator->]


['Inherited from ip::basic_resolver.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.operator_arrow_..operator->..ip::basic_resolver_results] 
Dereference an iterator. 


  const basic_resolver_entry< InternetProtocol > * operator->() const;



[endsect]


[section:operator_eq_ ip::basic_resolver_results::operator=]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.operator_eq_..operator=..ip::basic_resolver_results] 
Assignment operator. 


  basic_resolver_results & ``[link boost_asio.reference.ip__basic_resolver_results.operator_eq_.overload1 operator=]``(
      const basic_resolver_results & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_results.operator_eq_.overload1 more...]]``


Move-assignment operator. 


  basic_resolver_results & ``[link boost_asio.reference.ip__basic_resolver_results.operator_eq_.overload2 operator=]``(
      basic_resolver_results && other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_results.operator_eq_.overload2 more...]]``


[section:overload1 ip::basic_resolver_results::operator= (1 of 2 overloads)]


Assignment operator. 


  basic_resolver_results & operator=(
      const basic_resolver_results & other);



[endsect]



[section:overload2 ip::basic_resolver_results::operator= (2 of 2 overloads)]


Move-assignment operator. 


  basic_resolver_results & operator=(
      basic_resolver_results && other);



[endsect]


[endsect]

[section:operator_eq__eq_ ip::basic_resolver_results::operator==]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.operator_eq__eq_..operator==..ip::basic_resolver_results] 
Test two iterators for equality. 


  friend bool ``[link boost_asio.reference.ip__basic_resolver_results.operator_eq__eq_.overload1 operator==]``(
      const basic_resolver_results & a,
      const basic_resolver_results & b);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_results.operator_eq__eq_.overload1 more...]]``

  friend bool ``[link boost_asio.reference.ip__basic_resolver_results.operator_eq__eq_.overload2 operator==]``(
      const basic_resolver_iterator & a,
      const basic_resolver_iterator & b);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__basic_resolver_results.operator_eq__eq_.overload2 more...]]``


[section:overload1 ip::basic_resolver_results::operator== (1 of 2 overloads)]


Test two iterators for equality. 


  friend bool operator==(
      const basic_resolver_results & a,
      const basic_resolver_results & b);


[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:overload2 ip::basic_resolver_results::operator== (2 of 2 overloads)]


['Inherited from ip::basic_resolver.]


Test two iterators for equality. 


  friend bool operator==(
      const basic_resolver_iterator & a,
      const basic_resolver_iterator & b);


[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[endsect]


[section:pointer ip::basic_resolver_results::pointer]


['Inherited from ip::basic_resolver.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.pointer..pointer..ip::basic_resolver_results] 
The type of the result of applying `operator->()` to the iterator. 


  typedef const basic_resolver_entry< InternetProtocol > * pointer;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol_type ip::basic_resolver_results::protocol_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.protocol_type..protocol_type..ip::basic_resolver_results] 
The protocol type associated with the results. 


  typedef InternetProtocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:reference ip::basic_resolver_results::reference]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.reference..reference..ip::basic_resolver_results] 
The type of a non-const reference to a value in the range. 


  typedef value_type & reference;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_entry.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the endpoint entry. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_entry.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint entry. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_entry.basic_resolver_entry [*basic_resolver_entry]] [constructor]]
    [Default constructor. 
     [hr]
     Construct with specified endpoint, host name and service name. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.endpoint [*endpoint]]]
    [Get the endpoint associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.host_name [*host_name]]]
    [Get the host name associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.operator_endpoint_type [*operator endpoint_type]]]
    [Convert to the endpoint associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.service_name [*service_name]]]
    [Get the service name associated with the entry. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_resolver_entry `ip::basic_resolver_entry`] class template describes an entry as returned by a resolver.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:size ip::basic_resolver_results::size]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.size..size..ip::basic_resolver_results] 
Get the number of entries in the results range. 


  size_type size() const;



[endsect]



[section:size_type ip::basic_resolver_results::size_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.size_type..size_type..ip::basic_resolver_results] 
Type used to represent a count of the elements in the range. 


  typedef std::size_t size_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:swap ip::basic_resolver_results::swap]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.swap..swap..ip::basic_resolver_results] 
Swap the results range with another. 


  void swap(
      basic_resolver_results & that);



[endsect]



[section:value_type ip::basic_resolver_results::value_type]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.value_type..value_type..ip::basic_resolver_results] 
The type of a value in the results range. 


  typedef basic_resolver_entry< protocol_type > value_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver_entry.endpoint_type [*endpoint_type]]]
    [The endpoint type associated with the endpoint entry. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver_entry.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint entry. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver_entry.basic_resolver_entry [*basic_resolver_entry]] [constructor]]
    [Default constructor. 
     [hr]
     Construct with specified endpoint, host name and service name. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.endpoint [*endpoint]]]
    [Get the endpoint associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.host_name [*host_name]]]
    [Get the host name associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.operator_endpoint_type [*operator endpoint_type]]]
    [Convert to the endpoint associated with the entry. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver_entry.service_name [*service_name]]]
    [Get the service name associated with the entry. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_resolver_entry `ip::basic_resolver_entry`] class template describes an entry as returned by a resolver.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/basic_resolver_results.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:values_ ip::basic_resolver_results::values_]


['Inherited from ip::basic_resolver.]

[indexterm2 boost_asio.indexterm.ip__basic_resolver_results.values_..values_..ip::basic_resolver_results] 

  values_ptr_type values_;



[endsect]



[endsect]

[section:ip__host_name ip::host_name]

[indexterm1 boost_asio.indexterm.ip__host_name..ip::host_name] 
Get the current host name. 

  std::string ``[link boost_asio.reference.ip__host_name.overload1 host_name]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__host_name.overload1 more...]]``

  std::string ``[link boost_asio.reference.ip__host_name.overload2 host_name]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__host_name.overload2 more...]]``

[heading Requirements]

['Header: ][^boost/asio/ip/host_name.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 ip::host_name (1 of 2 overloads)]


Get the current host name. 


  std::string host_name();



[endsect]



[section:overload2 ip::host_name (2 of 2 overloads)]


Get the current host name. 


  std::string host_name(
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:ip__icmp ip::icmp]

[indexterm1 boost_asio.indexterm.ip__icmp..ip::icmp]


Encapsulates the flags needed for ICMP. 


  class icmp


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__icmp.endpoint [*endpoint]]]
    [The type of a ICMP endpoint. ]
  
  ]

  [

    [[link boost_asio.reference.ip__icmp.resolver [*resolver]]]
    [The ICMP resolver type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__icmp.socket [*socket]]]
    [The ICMP socket type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__icmp.family [*family]]]
    [Obtain an identifier for the protocol family. ]
  ]
  
  [
    [[link boost_asio.reference.ip__icmp.protocol [*protocol]]]
    [Obtain an identifier for the protocol. ]
  ]
  
  [
    [[link boost_asio.reference.ip__icmp.type [*type]]]
    [Obtain an identifier for the type of the protocol. ]
  ]
  
  [
    [[link boost_asio.reference.ip__icmp.v4 [*v4]] [static]]
    [Construct to represent the IPv4 ICMP protocol. ]
  ]
  
  [
    [[link boost_asio.reference.ip__icmp.v6 [*v6]] [static]]
    [Construct to represent the IPv6 ICMP protocol. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__icmp.operator_not__eq_ [*operator!=]]]
    [Compare two protocols for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__icmp.operator_eq__eq_ [*operator==]]]
    [Compare two protocols for equality. ]
  ]
  
]

The [link boost_asio.reference.ip__icmp `ip::icmp`] class contains flags necessary for ICMP sockets.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Safe.




[heading Requirements]

['Header: ][^boost/asio/ip/icmp.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:endpoint ip::icmp::endpoint]

[indexterm2 boost_asio.indexterm.ip__icmp.endpoint..endpoint..ip::icmp] 
The type of a ICMP endpoint. 


  typedef basic_endpoint< icmp > endpoint;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_endpoint.address [*address]]]
    [Get the IP address associated with the endpoint. 
     [hr]
     Set the IP address associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.basic_endpoint [*basic_endpoint]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an endpoint using a port number, specified in the host's byte order. The IP address will be the any address (i.e. INADDR_ANY or in6addr_any). This constructor would typically be used for accepting new connections. 
     [hr]
     Construct an endpoint using a port number and an IP address. This constructor may be used for accepting connections on a specific interface or for making a connection to a remote endpoint. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. 
     [hr]
     Move-assign from another endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.port [*port]]]
    [Get the port associated with the endpoint. The port number is always in the host's byte order. 
     [hr]
     Set the port associated with the endpoint. The port number is always in the host's byte order. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_lt__lt_ [*operator<<]]]
    [Output an endpoint as a string. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_endpoint `ip::basic_endpoint`] class template describes an endpoint that may be associated with a particular socket.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.





[heading Requirements]

['Header: ][^boost/asio/ip/icmp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:family ip::icmp::family]

[indexterm2 boost_asio.indexterm.ip__icmp.family..family..ip::icmp] 
Obtain an identifier for the protocol family. 


  int family() const;



[endsect]



[section:operator_not__eq_ ip::icmp::operator!=]

[indexterm2 boost_asio.indexterm.ip__icmp.operator_not__eq_..operator!=..ip::icmp] 
Compare two protocols for inequality. 


  friend bool operator!=(
      const icmp & p1,
      const icmp & p2);


[heading Requirements]

['Header: ][^boost/asio/ip/icmp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq__eq_ ip::icmp::operator==]

[indexterm2 boost_asio.indexterm.ip__icmp.operator_eq__eq_..operator==..ip::icmp] 
Compare two protocols for equality. 


  friend bool operator==(
      const icmp & p1,
      const icmp & p2);


[heading Requirements]

['Header: ][^boost/asio/ip/icmp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol ip::icmp::protocol]

[indexterm2 boost_asio.indexterm.ip__icmp.protocol..protocol..ip::icmp] 
Obtain an identifier for the protocol. 


  int protocol() const;



[endsect]



[section:resolver ip::icmp::resolver]

[indexterm2 boost_asio.indexterm.ip__icmp.resolver..resolver..ip::icmp] 
The ICMP resolver type. 


  typedef basic_resolver< icmp > resolver;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver__rebind_executor [*rebind_executor]]]
    [Rebinds the resolver type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.iterator [*iterator]]]
    [(Deprecated.) The iterator type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.query [*query]]]
    [(Deprecated.) The query type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.results_type [*results_type]]]
    [The results type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver.async_resolve [*async_resolve]]]
    [(Deprecated: Use overload with separate host and service parameters.) Asynchronously perform forward resolution of a query to a list of entries. 
     [hr]
     Asynchronously perform forward resolution of a query to a list of entries. 
     [hr]
     Asynchronously perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.basic_resolver [*basic_resolver]] [constructor]]
    [Construct with executor. 
     [hr]
     Construct with execution context. 
     [hr]
     Move-construct a basic_resolver from another. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the resolver. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.operator_eq_ [*operator=]]]
    [Move-assign a basic_resolver from another. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.resolve [*resolve]]]
    [(Deprecated: Use overload with separate host and service parameters.) Perform forward resolution of a query to a list of entries. 
     [hr]
     Perform forward resolution of a query to a list of entries. 
     [hr]
     Perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver._basic_resolver [*~basic_resolver]] [destructor]]
    [Destroys the resolver. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver.address_configured [*address_configured]] [static]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.all_matching [*all_matching]] [static]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.canonical_name [*canonical_name]] [static]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.numeric_host [*numeric_host]] [static]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.numeric_service [*numeric_service]] [static]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.passive [*passive]] [static]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.v4_mapped [*v4_mapped]] [static]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]

The [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] class template provides the ability to resolve a query to a list of endpoints.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/icmp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:socket ip::icmp::socket]

[indexterm2 boost_asio.indexterm.ip__icmp.socket..socket..ip::icmp] 
The ICMP socket type. 


  typedef basic_raw_socket< icmp > socket;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_raw_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_raw_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_raw_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_receive_from [*async_receive_from]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_send [*async_send]]]
    [Start an asynchronous send on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_send_to [*async_send_to]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.basic_raw_socket [*basic_raw_socket]] [constructor]]
    [Construct a basic_raw_socket without opening it. 
     [hr]
     Construct and open a basic_raw_socket. 
     [hr]
     Construct a basic_raw_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_raw_socket on an existing native socket. 
     [hr]
     Move-construct a basic_raw_socket from another. 
     [hr]
     Move-construct a basic_raw_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_raw_socket from another. 
     [hr]
     Move-assign a basic_raw_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.receive [*receive]]]
    [Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.receive_from [*receive_from]]]
    [Receive raw data with the endpoint of the sender. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.send [*send]]]
    [Send some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.send_to [*send_to]]]
    [Send raw data to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_raw_socket._basic_raw_socket [*~basic_raw_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_raw_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_raw_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_raw_socket `basic_raw_socket`] class template provides asynchronous and blocking raw-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `send_to`, `receive`, `receive_from`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe. 


[heading Requirements]

['Header: ][^boost/asio/ip/icmp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:type ip::icmp::type]

[indexterm2 boost_asio.indexterm.ip__icmp.type..type..ip::icmp] 
Obtain an identifier for the type of the protocol. 


  int type() const;



[endsect]



[section:v4 ip::icmp::v4]

[indexterm2 boost_asio.indexterm.ip__icmp.v4..v4..ip::icmp] 
Construct to represent the IPv4 ICMP protocol. 


  static icmp v4();



[endsect]



[section:v6 ip::icmp::v6]

[indexterm2 boost_asio.indexterm.ip__icmp.v6..v6..ip::icmp] 
Construct to represent the IPv6 ICMP protocol. 


  static icmp v6();



[endsect]



[endsect]


[section:ip__multicast__enable_loopback ip::multicast::enable_loopback]

[indexterm1 boost_asio.indexterm.ip__multicast__enable_loopback..ip::multicast::enable_loopback] 
Socket option determining whether outgoing multicast packets will be received on the same socket if it is a member of the multicast group. 


  typedef implementation_defined enable_loopback;



Implements the IPPROTO\_IP/IP\_MULTICAST\_LOOP socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::ip::multicast::enable_loopback option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::ip::multicast::enable_loopback option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/ip/multicast.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:ip__multicast__hops ip::multicast::hops]

[indexterm1 boost_asio.indexterm.ip__multicast__hops..ip::multicast::hops] 
Socket option for time-to-live associated with outgoing multicast packets. 


  typedef implementation_defined hops;



Implements the IPPROTO\_IP/IP\_MULTICAST\_TTL socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::ip::multicast::hops option(4);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::ip::multicast::hops option;
   socket.get_option(option);
   int ttl = option.value();







[heading Requirements]

['Header: ][^boost/asio/ip/multicast.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:ip__multicast__join_group ip::multicast::join_group]

[indexterm1 boost_asio.indexterm.ip__multicast__join_group..ip::multicast::join_group] 
Socket option to join a multicast group on a specified interface. 


  typedef implementation_defined join_group;



Implements the IPPROTO\_IP/IP\_ADD\_MEMBERSHIP socket option.


[heading Examples]
  
Setting the option to join a multicast group: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::ip::address multicast_address =
     boost::asio::ip::address::from_string("225.0.0.1");
   boost::asio::ip::multicast::join_group option(multicast_address);
   socket.set_option(option);







[heading Requirements]

['Header: ][^boost/asio/ip/multicast.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:ip__multicast__leave_group ip::multicast::leave_group]

[indexterm1 boost_asio.indexterm.ip__multicast__leave_group..ip::multicast::leave_group] 
Socket option to leave a multicast group on a specified interface. 


  typedef implementation_defined leave_group;



Implements the IPPROTO\_IP/IP\_DROP\_MEMBERSHIP socket option.


[heading Examples]
  
Setting the option to leave a multicast group: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::ip::address multicast_address =
     boost::asio::ip::address::from_string("225.0.0.1");
   boost::asio::ip::multicast::leave_group option(multicast_address);
   socket.set_option(option);







[heading Requirements]

['Header: ][^boost/asio/ip/multicast.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:ip__multicast__outbound_interface ip::multicast::outbound_interface]

[indexterm1 boost_asio.indexterm.ip__multicast__outbound_interface..ip::multicast::outbound_interface] 
Socket option for local interface to use for outgoing multicast packets. 


  typedef implementation_defined outbound_interface;



Implements the IPPROTO\_IP/IP\_MULTICAST\_IF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::ip::address_v4 local_interface =
     boost::asio::ip::address_v4::from_string("1.2.3.4");
   boost::asio::ip::multicast::outbound_interface option(local_interface);
   socket.set_option(option);







[heading Requirements]

['Header: ][^boost/asio/ip/multicast.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:ip__network_v4 ip::network_v4]

[indexterm1 boost_asio.indexterm.ip__network_v4..ip::network_v4]


Represents an IPv4 network. 


  class network_v4


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__network_v4.address [*address]]]
    [Obtain the address object specified when the network object was created. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v4.broadcast [*broadcast]]]
    [Obtain an address object that represents the network's broadcast address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v4.canonical [*canonical]]]
    [Obtain the true network address, omitting any host bits. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v4.hosts [*hosts]]]
    [Obtain an address range corresponding to the hosts in the network. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v4.is_host [*is_host]]]
    [Test if network is a valid host address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v4.is_subnet_of [*is_subnet_of]]]
    [Test if a network is a real subnet of another network. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v4.netmask [*netmask]]]
    [Obtain the netmask that was specified when the network object was created. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v4.network [*network]]]
    [Obtain an address object that represents the network address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v4.network_v4 [*network_v4]] [constructor]]
    [Default constructor. 
     [hr]
     Construct a network based on the specified address and prefix length. 
     [hr]
     Construct network based on the specified address and netmask. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v4.operator_eq_ [*operator=]]]
    [Assign from another network. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v4.prefix_length [*prefix_length]]]
    [Obtain the prefix length that was specified when the network object was created. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v4.to_string [*to_string]]]
    [Get the network as an address in dotted decimal format. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__network_v4.operator_not__eq_ [*operator!=]]]
    [Compare two networks for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v4.operator_eq__eq_ [*operator==]]]
    [Compare two networks for equality. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__network_v4.make_network_v4 [*make_network_v4]]]
    [Create an IPv4 network from a string containing IP address and prefix length. ]
  ]
  
]

The [link boost_asio.reference.ip__network_v4 `ip::network_v4`] class provides the ability to use and manipulate IP version 4 networks.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/network_v4.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:address ip::network_v4::address]

[indexterm2 boost_asio.indexterm.ip__network_v4.address..address..ip::network_v4] 
Obtain the address object specified when the network object was created. 


  address_v4 address() const;



[endsect]



[section:broadcast ip::network_v4::broadcast]

[indexterm2 boost_asio.indexterm.ip__network_v4.broadcast..broadcast..ip::network_v4] 
Obtain an address object that represents the network's broadcast address. 


  address_v4 broadcast() const;



[endsect]



[section:canonical ip::network_v4::canonical]

[indexterm2 boost_asio.indexterm.ip__network_v4.canonical..canonical..ip::network_v4] 
Obtain the true network address, omitting any host bits. 


  network_v4 canonical() const;



[endsect]



[section:hosts ip::network_v4::hosts]

[indexterm2 boost_asio.indexterm.ip__network_v4.hosts..hosts..ip::network_v4] 
Obtain an address range corresponding to the hosts in the network. 


  address_v4_range hosts() const;



[endsect]



[section:is_host ip::network_v4::is_host]

[indexterm2 boost_asio.indexterm.ip__network_v4.is_host..is_host..ip::network_v4] 
Test if network is a valid host address. 


  bool is_host() const;



[endsect]



[section:is_subnet_of ip::network_v4::is_subnet_of]

[indexterm2 boost_asio.indexterm.ip__network_v4.is_subnet_of..is_subnet_of..ip::network_v4] 
Test if a network is a real subnet of another network. 


  bool is_subnet_of(
      const network_v4 & other) const;



[endsect]


[section:make_network_v4 ip::network_v4::make_network_v4]

[indexterm2 boost_asio.indexterm.ip__network_v4.make_network_v4..make_network_v4..ip::network_v4] 
Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 ``[link boost_asio.reference.ip__network_v4.make_network_v4.overload1 make_network_v4]``(
      const char * str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v4.make_network_v4.overload1 more...]]``

  network_v4 ``[link boost_asio.reference.ip__network_v4.make_network_v4.overload2 make_network_v4]``(
      const char * str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v4.make_network_v4.overload2 more...]]``

  network_v4 ``[link boost_asio.reference.ip__network_v4.make_network_v4.overload3 make_network_v4]``(
      const std::string & str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v4.make_network_v4.overload3 more...]]``

  network_v4 ``[link boost_asio.reference.ip__network_v4.make_network_v4.overload4 make_network_v4]``(
      const std::string & str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v4.make_network_v4.overload4 more...]]``

  network_v4 ``[link boost_asio.reference.ip__network_v4.make_network_v4.overload5 make_network_v4]``(
      string_view str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v4.make_network_v4.overload5 more...]]``

  network_v4 ``[link boost_asio.reference.ip__network_v4.make_network_v4.overload6 make_network_v4]``(
      string_view str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v4.make_network_v4.overload6 more...]]``


[section:overload1 ip::network_v4::make_network_v4 (1 of 6 overloads)]


Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 make_network_v4(
      const char * str);



[endsect]



[section:overload2 ip::network_v4::make_network_v4 (2 of 6 overloads)]


Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 make_network_v4(
      const char * str,
      boost::system::error_code & ec);



[endsect]



[section:overload3 ip::network_v4::make_network_v4 (3 of 6 overloads)]


Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 make_network_v4(
      const std::string & str);



[endsect]



[section:overload4 ip::network_v4::make_network_v4 (4 of 6 overloads)]


Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 make_network_v4(
      const std::string & str,
      boost::system::error_code & ec);



[endsect]



[section:overload5 ip::network_v4::make_network_v4 (5 of 6 overloads)]


Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 make_network_v4(
      string_view str);



[endsect]



[section:overload6 ip::network_v4::make_network_v4 (6 of 6 overloads)]


Create an IPv4 network from a string containing IP address and prefix length. 


  network_v4 make_network_v4(
      string_view str,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:netmask ip::network_v4::netmask]

[indexterm2 boost_asio.indexterm.ip__network_v4.netmask..netmask..ip::network_v4] 
Obtain the netmask that was specified when the network object was created. 


  address_v4 netmask() const;



[endsect]



[section:network ip::network_v4::network]

[indexterm2 boost_asio.indexterm.ip__network_v4.network..network..ip::network_v4] 
Obtain an address object that represents the network address. 


  address_v4 network() const;



[endsect]


[section:network_v4 ip::network_v4::network_v4]

[indexterm2 boost_asio.indexterm.ip__network_v4.network_v4..network_v4..ip::network_v4] 
Default constructor. 


  ``[link boost_asio.reference.ip__network_v4.network_v4.overload1 network_v4]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v4.network_v4.overload1 more...]]``


Construct a network based on the specified address and prefix length. 


  ``[link boost_asio.reference.ip__network_v4.network_v4.overload2 network_v4]``(
      const address_v4 & addr,
      unsigned short prefix_len);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v4.network_v4.overload2 more...]]``


Construct network based on the specified address and netmask. 


  ``[link boost_asio.reference.ip__network_v4.network_v4.overload3 network_v4]``(
      const address_v4 & addr,
      const address_v4 & mask);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v4.network_v4.overload3 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.ip__network_v4.network_v4.overload4 network_v4]``(
      const network_v4 & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v4.network_v4.overload4 more...]]``


[section:overload1 ip::network_v4::network_v4 (1 of 4 overloads)]


Default constructor. 


  network_v4();



[endsect]



[section:overload2 ip::network_v4::network_v4 (2 of 4 overloads)]


Construct a network based on the specified address and prefix length. 


  network_v4(
      const address_v4 & addr,
      unsigned short prefix_len);



[endsect]



[section:overload3 ip::network_v4::network_v4 (3 of 4 overloads)]


Construct network based on the specified address and netmask. 


  network_v4(
      const address_v4 & addr,
      const address_v4 & mask);



[endsect]



[section:overload4 ip::network_v4::network_v4 (4 of 4 overloads)]


Copy constructor. 


  network_v4(
      const network_v4 & other);



[endsect]


[endsect]


[section:operator_not__eq_ ip::network_v4::operator!=]

[indexterm2 boost_asio.indexterm.ip__network_v4.operator_not__eq_..operator!=..ip::network_v4] 
Compare two networks for inequality. 


  friend bool operator!=(
      const network_v4 & a,
      const network_v4 & b);


[heading Requirements]

['Header: ][^boost/asio/ip/network_v4.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ ip::network_v4::operator=]

[indexterm2 boost_asio.indexterm.ip__network_v4.operator_eq_..operator=..ip::network_v4] 
Assign from another network. 


  network_v4 & operator=(
      const network_v4 & other);



[endsect]



[section:operator_eq__eq_ ip::network_v4::operator==]

[indexterm2 boost_asio.indexterm.ip__network_v4.operator_eq__eq_..operator==..ip::network_v4] 
Compare two networks for equality. 


  friend bool operator==(
      const network_v4 & a,
      const network_v4 & b);


[heading Requirements]

['Header: ][^boost/asio/ip/network_v4.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:prefix_length ip::network_v4::prefix_length]

[indexterm2 boost_asio.indexterm.ip__network_v4.prefix_length..prefix_length..ip::network_v4] 
Obtain the prefix length that was specified when the network object was created. 


  unsigned short prefix_length() const;



[endsect]


[section:to_string ip::network_v4::to_string]

[indexterm2 boost_asio.indexterm.ip__network_v4.to_string..to_string..ip::network_v4] 
Get the network as an address in dotted decimal format. 


  std::string ``[link boost_asio.reference.ip__network_v4.to_string.overload1 to_string]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v4.to_string.overload1 more...]]``

  std::string ``[link boost_asio.reference.ip__network_v4.to_string.overload2 to_string]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v4.to_string.overload2 more...]]``


[section:overload1 ip::network_v4::to_string (1 of 2 overloads)]


Get the network as an address in dotted decimal format. 


  std::string to_string() const;



[endsect]



[section:overload2 ip::network_v4::to_string (2 of 2 overloads)]


Get the network as an address in dotted decimal format. 


  std::string to_string(
      boost::system::error_code & ec) const;



[endsect]


[endsect]


[endsect]

[section:ip__network_v6 ip::network_v6]

[indexterm1 boost_asio.indexterm.ip__network_v6..ip::network_v6]


Represents an IPv6 network. 


  class network_v6


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__network_v6.address [*address]]]
    [Obtain the address object specified when the network object was created. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v6.canonical [*canonical]]]
    [Obtain the true network address, omitting any host bits. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v6.hosts [*hosts]]]
    [Obtain an address range corresponding to the hosts in the network. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v6.is_host [*is_host]]]
    [Test if network is a valid host address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v6.is_subnet_of [*is_subnet_of]]]
    [Test if a network is a real subnet of another network. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v6.network [*network]]]
    [Obtain an address object that represents the network address. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v6.network_v6 [*network_v6]] [constructor]]
    [Default constructor. 
     [hr]
     Construct a network based on the specified address and prefix length. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v6.operator_eq_ [*operator=]]]
    [Assign from another network. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v6.prefix_length [*prefix_length]]]
    [Obtain the prefix length that was specified when the network object was created. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v6.to_string [*to_string]]]
    [Get the network as an address in dotted decimal format. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__network_v6.operator_not__eq_ [*operator!=]]]
    [Compare two networks for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__network_v6.operator_eq__eq_ [*operator==]]]
    [Compare two networks for equality. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__network_v6.make_network_v6 [*make_network_v6]]]
    [Create an IPv6 network from a string containing IP address and prefix length. ]
  ]
  
]

The [link boost_asio.reference.ip__network_v6 `ip::network_v6`] class provides the ability to use and manipulate IP version 6 networks.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/ip/network_v6.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:address ip::network_v6::address]

[indexterm2 boost_asio.indexterm.ip__network_v6.address..address..ip::network_v6] 
Obtain the address object specified when the network object was created. 


  address_v6 address() const;



[endsect]



[section:canonical ip::network_v6::canonical]

[indexterm2 boost_asio.indexterm.ip__network_v6.canonical..canonical..ip::network_v6] 
Obtain the true network address, omitting any host bits. 


  network_v6 canonical() const;



[endsect]



[section:hosts ip::network_v6::hosts]

[indexterm2 boost_asio.indexterm.ip__network_v6.hosts..hosts..ip::network_v6] 
Obtain an address range corresponding to the hosts in the network. 


  address_v6_range hosts() const;



[endsect]



[section:is_host ip::network_v6::is_host]

[indexterm2 boost_asio.indexterm.ip__network_v6.is_host..is_host..ip::network_v6] 
Test if network is a valid host address. 


  bool is_host() const;



[endsect]



[section:is_subnet_of ip::network_v6::is_subnet_of]

[indexterm2 boost_asio.indexterm.ip__network_v6.is_subnet_of..is_subnet_of..ip::network_v6] 
Test if a network is a real subnet of another network. 


  bool is_subnet_of(
      const network_v6 & other) const;



[endsect]


[section:make_network_v6 ip::network_v6::make_network_v6]

[indexterm2 boost_asio.indexterm.ip__network_v6.make_network_v6..make_network_v6..ip::network_v6] 
Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 ``[link boost_asio.reference.ip__network_v6.make_network_v6.overload1 make_network_v6]``(
      const char * str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v6.make_network_v6.overload1 more...]]``

  network_v6 ``[link boost_asio.reference.ip__network_v6.make_network_v6.overload2 make_network_v6]``(
      const char * str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v6.make_network_v6.overload2 more...]]``

  network_v6 ``[link boost_asio.reference.ip__network_v6.make_network_v6.overload3 make_network_v6]``(
      const std::string & str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v6.make_network_v6.overload3 more...]]``

  network_v6 ``[link boost_asio.reference.ip__network_v6.make_network_v6.overload4 make_network_v6]``(
      const std::string & str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v6.make_network_v6.overload4 more...]]``

  network_v6 ``[link boost_asio.reference.ip__network_v6.make_network_v6.overload5 make_network_v6]``(
      string_view str);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v6.make_network_v6.overload5 more...]]``

  network_v6 ``[link boost_asio.reference.ip__network_v6.make_network_v6.overload6 make_network_v6]``(
      string_view str,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v6.make_network_v6.overload6 more...]]``


[section:overload1 ip::network_v6::make_network_v6 (1 of 6 overloads)]


Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 make_network_v6(
      const char * str);



[endsect]



[section:overload2 ip::network_v6::make_network_v6 (2 of 6 overloads)]


Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 make_network_v6(
      const char * str,
      boost::system::error_code & ec);



[endsect]



[section:overload3 ip::network_v6::make_network_v6 (3 of 6 overloads)]


Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 make_network_v6(
      const std::string & str);



[endsect]



[section:overload4 ip::network_v6::make_network_v6 (4 of 6 overloads)]


Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 make_network_v6(
      const std::string & str,
      boost::system::error_code & ec);



[endsect]



[section:overload5 ip::network_v6::make_network_v6 (5 of 6 overloads)]


Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 make_network_v6(
      string_view str);



[endsect]



[section:overload6 ip::network_v6::make_network_v6 (6 of 6 overloads)]


Create an IPv6 network from a string containing IP address and prefix length. 


  network_v6 make_network_v6(
      string_view str,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:network ip::network_v6::network]

[indexterm2 boost_asio.indexterm.ip__network_v6.network..network..ip::network_v6] 
Obtain an address object that represents the network address. 


  address_v6 network() const;



[endsect]


[section:network_v6 ip::network_v6::network_v6]

[indexterm2 boost_asio.indexterm.ip__network_v6.network_v6..network_v6..ip::network_v6] 
Default constructor. 


  ``[link boost_asio.reference.ip__network_v6.network_v6.overload1 network_v6]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v6.network_v6.overload1 more...]]``


Construct a network based on the specified address and prefix length. 


  ``[link boost_asio.reference.ip__network_v6.network_v6.overload2 network_v6]``(
      const address_v6 & addr,
      unsigned short prefix_len);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v6.network_v6.overload2 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.ip__network_v6.network_v6.overload3 network_v6]``(
      const network_v6 & other);
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v6.network_v6.overload3 more...]]``


[section:overload1 ip::network_v6::network_v6 (1 of 3 overloads)]


Default constructor. 


  network_v6();



[endsect]



[section:overload2 ip::network_v6::network_v6 (2 of 3 overloads)]


Construct a network based on the specified address and prefix length. 


  network_v6(
      const address_v6 & addr,
      unsigned short prefix_len);



[endsect]



[section:overload3 ip::network_v6::network_v6 (3 of 3 overloads)]


Copy constructor. 


  network_v6(
      const network_v6 & other);



[endsect]


[endsect]


[section:operator_not__eq_ ip::network_v6::operator!=]

[indexterm2 boost_asio.indexterm.ip__network_v6.operator_not__eq_..operator!=..ip::network_v6] 
Compare two networks for inequality. 


  friend bool operator!=(
      const network_v6 & a,
      const network_v6 & b);


[heading Requirements]

['Header: ][^boost/asio/ip/network_v6.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ ip::network_v6::operator=]

[indexterm2 boost_asio.indexterm.ip__network_v6.operator_eq_..operator=..ip::network_v6] 
Assign from another network. 


  network_v6 & operator=(
      const network_v6 & other);



[endsect]



[section:operator_eq__eq_ ip::network_v6::operator==]

[indexterm2 boost_asio.indexterm.ip__network_v6.operator_eq__eq_..operator==..ip::network_v6] 
Compare two networks for equality. 


  friend bool operator==(
      const network_v6 & a,
      const network_v6 & b);


[heading Requirements]

['Header: ][^boost/asio/ip/network_v6.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:prefix_length ip::network_v6::prefix_length]

[indexterm2 boost_asio.indexterm.ip__network_v6.prefix_length..prefix_length..ip::network_v6] 
Obtain the prefix length that was specified when the network object was created. 


  unsigned short prefix_length() const;



[endsect]


[section:to_string ip::network_v6::to_string]

[indexterm2 boost_asio.indexterm.ip__network_v6.to_string..to_string..ip::network_v6] 
Get the network as an address in dotted decimal format. 


  std::string ``[link boost_asio.reference.ip__network_v6.to_string.overload1 to_string]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v6.to_string.overload1 more...]]``

  std::string ``[link boost_asio.reference.ip__network_v6.to_string.overload2 to_string]``(
      boost::system::error_code & ec) const;
  ``  [''''&raquo;''' [link boost_asio.reference.ip__network_v6.to_string.overload2 more...]]``


[section:overload1 ip::network_v6::to_string (1 of 2 overloads)]


Get the network as an address in dotted decimal format. 


  std::string to_string() const;



[endsect]



[section:overload2 ip::network_v6::to_string (2 of 2 overloads)]


Get the network as an address in dotted decimal format. 


  std::string to_string(
      boost::system::error_code & ec) const;



[endsect]


[endsect]


[endsect]


[section:ip__port_type ip::port_type]

[indexterm1 boost_asio.indexterm.ip__port_type..ip::port_type] 
Type used for storing port numbers. 


  typedef uint_least16_t port_type;



[heading Requirements]

['Header: ][^boost/asio/ip/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:ip__resolver_base ip::resolver_base]

[indexterm1 boost_asio.indexterm.ip__resolver_base..ip::resolver_base]


The [link boost_asio.reference.ip__resolver_base `ip::resolver_base`] class is used as a base for the [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] class templates to provide a common place to define the flag constants. 


  class resolver_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__resolver_base.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__resolver_base._resolver_base [*~resolver_base]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__resolver_base.address_configured [*address_configured]] [static]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link boost_asio.reference.ip__resolver_base.all_matching [*all_matching]] [static]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link boost_asio.reference.ip__resolver_base.canonical_name [*canonical_name]] [static]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link boost_asio.reference.ip__resolver_base.numeric_host [*numeric_host]] [static]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__resolver_base.numeric_service [*numeric_service]] [static]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__resolver_base.passive [*passive]] [static]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link boost_asio.reference.ip__resolver_base.v4_mapped [*v4_mapped]] [static]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/ip/resolver_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:address_configured ip::resolver_base::address_configured]

[indexterm2 boost_asio.indexterm.ip__resolver_base.address_configured..address_configured..ip::resolver_base] 
Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. 


  static const flags address_configured = implementation_defined;



[endsect]



[section:all_matching ip::resolver_base::all_matching]

[indexterm2 boost_asio.indexterm.ip__resolver_base.all_matching..all_matching..ip::resolver_base] 
If used with v4\_mapped, return all matching IPv6 and IPv4 addresses. 


  static const flags all_matching = implementation_defined;



[endsect]



[section:canonical_name ip::resolver_base::canonical_name]

[indexterm2 boost_asio.indexterm.ip__resolver_base.canonical_name..canonical_name..ip::resolver_base] 
Determine the canonical name of the host specified in the query. 


  static const flags canonical_name = implementation_defined;



[endsect]



[section:flags ip::resolver_base::flags]

[indexterm2 boost_asio.indexterm.ip__resolver_base.flags..flags..ip::resolver_base] 
A bitmask type (C++ Std [lib.bitmask.types]). 


  typedef unspecified flags;



[heading Requirements]

['Header: ][^boost/asio/ip/resolver_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:numeric_host ip::resolver_base::numeric_host]

[indexterm2 boost_asio.indexterm.ip__resolver_base.numeric_host..numeric_host..ip::resolver_base] 
Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. 


  static const flags numeric_host = implementation_defined;



[endsect]



[section:numeric_service ip::resolver_base::numeric_service]

[indexterm2 boost_asio.indexterm.ip__resolver_base.numeric_service..numeric_service..ip::resolver_base] 
Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. 


  static const flags numeric_service = implementation_defined;



[endsect]



[section:passive ip::resolver_base::passive]

[indexterm2 boost_asio.indexterm.ip__resolver_base.passive..passive..ip::resolver_base] 
Indicate that returned endpoint is intended for use as a locally bound socket endpoint. 


  static const flags passive = implementation_defined;



[endsect]



[section:v4_mapped ip::resolver_base::v4_mapped]

[indexterm2 boost_asio.indexterm.ip__resolver_base.v4_mapped..v4_mapped..ip::resolver_base] 
If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. 


  static const flags v4_mapped = implementation_defined;



[endsect]



[section:_resolver_base ip::resolver_base::~resolver_base]

[indexterm2 boost_asio.indexterm.ip__resolver_base._resolver_base..~resolver_base..ip::resolver_base] 
Protected destructor to prevent deletion through this type. 


  ~resolver_base();



[endsect]



[endsect]

[section:ip__resolver_query_base ip::resolver_query_base]

[indexterm1 boost_asio.indexterm.ip__resolver_query_base..ip::resolver_query_base]


The [link boost_asio.reference.ip__resolver_query_base `ip::resolver_query_base`] class is used as a base for the [link boost_asio.reference.ip__basic_resolver_query `ip::basic_resolver_query`] class templates to provide a common place to define the flag constants. 


  class resolver_query_base :
    public ip::resolver_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__resolver_query_base.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__resolver_query_base._resolver_query_base [*~resolver_query_base]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__resolver_query_base.address_configured [*address_configured]] [static]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link boost_asio.reference.ip__resolver_query_base.all_matching [*all_matching]] [static]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link boost_asio.reference.ip__resolver_query_base.canonical_name [*canonical_name]] [static]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link boost_asio.reference.ip__resolver_query_base.numeric_host [*numeric_host]] [static]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__resolver_query_base.numeric_service [*numeric_service]] [static]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__resolver_query_base.passive [*passive]] [static]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link boost_asio.reference.ip__resolver_query_base.v4_mapped [*v4_mapped]] [static]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/ip/resolver_query_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:address_configured ip::resolver_query_base::address_configured]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__resolver_query_base.address_configured..address_configured..ip::resolver_query_base] 
Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. 


  static const flags address_configured = implementation_defined;



[endsect]



[section:all_matching ip::resolver_query_base::all_matching]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__resolver_query_base.all_matching..all_matching..ip::resolver_query_base] 
If used with v4\_mapped, return all matching IPv6 and IPv4 addresses. 


  static const flags all_matching = implementation_defined;



[endsect]



[section:canonical_name ip::resolver_query_base::canonical_name]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__resolver_query_base.canonical_name..canonical_name..ip::resolver_query_base] 
Determine the canonical name of the host specified in the query. 


  static const flags canonical_name = implementation_defined;



[endsect]



[section:flags ip::resolver_query_base::flags]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__resolver_query_base.flags..flags..ip::resolver_query_base] 
A bitmask type (C++ Std [lib.bitmask.types]). 


  typedef unspecified flags;



[heading Requirements]

['Header: ][^boost/asio/ip/resolver_query_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:numeric_host ip::resolver_query_base::numeric_host]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__resolver_query_base.numeric_host..numeric_host..ip::resolver_query_base] 
Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. 


  static const flags numeric_host = implementation_defined;



[endsect]



[section:numeric_service ip::resolver_query_base::numeric_service]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__resolver_query_base.numeric_service..numeric_service..ip::resolver_query_base] 
Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. 


  static const flags numeric_service = implementation_defined;



[endsect]



[section:passive ip::resolver_query_base::passive]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__resolver_query_base.passive..passive..ip::resolver_query_base] 
Indicate that returned endpoint is intended for use as a locally bound socket endpoint. 


  static const flags passive = implementation_defined;



[endsect]



[section:v4_mapped ip::resolver_query_base::v4_mapped]


['Inherited from ip::resolver_base.]

[indexterm2 boost_asio.indexterm.ip__resolver_query_base.v4_mapped..v4_mapped..ip::resolver_query_base] 
If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. 


  static const flags v4_mapped = implementation_defined;



[endsect]



[section:_resolver_query_base ip::resolver_query_base::~resolver_query_base]

[indexterm2 boost_asio.indexterm.ip__resolver_query_base._resolver_query_base..~resolver_query_base..ip::resolver_query_base] 
Protected destructor to prevent deletion through this type. 


  ~resolver_query_base();



[endsect]



[endsect]


[section:ip__scope_id_type ip::scope_id_type]

[indexterm1 boost_asio.indexterm.ip__scope_id_type..ip::scope_id_type] 
Type used for storing IPv6 scope IDs. 


  typedef uint_least32_t scope_id_type;



[heading Requirements]

['Header: ][^boost/asio/ip/address_v6.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:ip__tcp ip::tcp]

[indexterm1 boost_asio.indexterm.ip__tcp..ip::tcp]


Encapsulates the flags needed for TCP. 


  class tcp


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__tcp.acceptor [*acceptor]]]
    [The TCP acceptor type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__tcp.endpoint [*endpoint]]]
    [The type of a TCP endpoint. ]
  
  ]

  [

    [[link boost_asio.reference.ip__tcp.iostream [*iostream]]]
    [The TCP iostream type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__tcp.no_delay [*no_delay]]]
    [Socket option for disabling the Nagle algorithm. ]
  
  ]

  [

    [[link boost_asio.reference.ip__tcp.resolver [*resolver]]]
    [The TCP resolver type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__tcp.socket [*socket]]]
    [The TCP socket type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__tcp.family [*family]]]
    [Obtain an identifier for the protocol family. ]
  ]
  
  [
    [[link boost_asio.reference.ip__tcp.protocol [*protocol]]]
    [Obtain an identifier for the protocol. ]
  ]
  
  [
    [[link boost_asio.reference.ip__tcp.type [*type]]]
    [Obtain an identifier for the type of the protocol. ]
  ]
  
  [
    [[link boost_asio.reference.ip__tcp.v4 [*v4]] [static]]
    [Construct to represent the IPv4 TCP protocol. ]
  ]
  
  [
    [[link boost_asio.reference.ip__tcp.v6 [*v6]] [static]]
    [Construct to represent the IPv6 TCP protocol. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__tcp.operator_not__eq_ [*operator!=]]]
    [Compare two protocols for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__tcp.operator_eq__eq_ [*operator==]]]
    [Compare two protocols for equality. ]
  ]
  
]

The [link boost_asio.reference.ip__tcp `ip::tcp`] class contains flags necessary for TCP sockets.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Safe.




[heading Requirements]

['Header: ][^boost/asio/ip/tcp.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:acceptor ip::tcp::acceptor]

[indexterm2 boost_asio.indexterm.ip__tcp.acceptor..acceptor..ip::tcp] 
The TCP acceptor type. 


  typedef basic_socket_acceptor< tcp > acceptor;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket_acceptor__rebind_executor [*rebind_executor]]]
    [Rebinds the acceptor type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.native_handle_type [*native_handle_type]]]
    [The native representation of an acceptor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_acceptor.accept [*accept]]]
    [Accept a new connection. 
     [hr]
     Accept a new connection and obtain the endpoint of the peer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.assign [*assign]]]
    [Assigns an existing native acceptor to the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.async_accept [*async_accept]]]
    [Start an asynchronous accept. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.async_wait [*async_wait]]]
    [Asynchronously wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor [*basic_socket_acceptor]] [constructor]]
    [Construct an acceptor without opening it. 
     [hr]
     Construct an open acceptor. 
     [hr]
     Construct an acceptor opened on the given endpoint. 
     [hr]
     Construct a basic_socket_acceptor on an existing native acceptor. 
     [hr]
     Move-construct a basic_socket_acceptor from another. 
     [hr]
     Move-construct a basic_socket_acceptor from an acceptor of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.bind [*bind]]]
    [Bind the acceptor to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.close [*close]]]
    [Close the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.get_option [*get_option]]]
    [Get an option from the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.io_control [*io_control]]]
    [Perform an IO control command on the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.is_open [*is_open]]]
    [Determine whether the acceptor is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.listen [*listen]]]
    [Place the acceptor into the state where it will listen for new connections. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.native_handle [*native_handle]]]
    [Get the native acceptor representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native acceptor implementation. 
     [hr]
     Sets the non-blocking mode of the native acceptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the acceptor. 
     [hr]
     Sets the non-blocking mode of the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.open [*open]]]
    [Open the acceptor using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_acceptor from another. 
     [hr]
     Move-assign a basic_socket_acceptor from an acceptor of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.release [*release]]]
    [Release ownership of the underlying native acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.set_option [*set_option]]]
    [Set an option on the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.wait [*wait]]]
    [Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor._basic_socket_acceptor [*~basic_socket_acceptor]] [destructor]]
    [Destroys the acceptor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_acceptor.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] class template is used for accepting new socket connections.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `accept` operations are thread safe, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to synchronous `accept` operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe.


[heading Example]
  
Opening a socket acceptor with the SO\_REUSEADDR option enabled: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port);
   acceptor.open(endpoint.protocol());
   acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
   acceptor.bind(endpoint);
   acceptor.listen();







[heading Requirements]

['Header: ][^boost/asio/ip/tcp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:endpoint ip::tcp::endpoint]

[indexterm2 boost_asio.indexterm.ip__tcp.endpoint..endpoint..ip::tcp] 
The type of a TCP endpoint. 


  typedef basic_endpoint< tcp > endpoint;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_endpoint.address [*address]]]
    [Get the IP address associated with the endpoint. 
     [hr]
     Set the IP address associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.basic_endpoint [*basic_endpoint]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an endpoint using a port number, specified in the host's byte order. The IP address will be the any address (i.e. INADDR_ANY or in6addr_any). This constructor would typically be used for accepting new connections. 
     [hr]
     Construct an endpoint using a port number and an IP address. This constructor may be used for accepting connections on a specific interface or for making a connection to a remote endpoint. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. 
     [hr]
     Move-assign from another endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.port [*port]]]
    [Get the port associated with the endpoint. The port number is always in the host's byte order. 
     [hr]
     Set the port associated with the endpoint. The port number is always in the host's byte order. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_lt__lt_ [*operator<<]]]
    [Output an endpoint as a string. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_endpoint `ip::basic_endpoint`] class template describes an endpoint that may be associated with a particular socket.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.





[heading Requirements]

['Header: ][^boost/asio/ip/tcp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:family ip::tcp::family]

[indexterm2 boost_asio.indexterm.ip__tcp.family..family..ip::tcp] 
Obtain an identifier for the protocol family. 


  int family() const;



[endsect]



[section:iostream ip::tcp::iostream]

[indexterm2 boost_asio.indexterm.ip__tcp.iostream..iostream..ip::tcp] 
The TCP iostream type. 


  typedef basic_socket_iostream< tcp > iostream;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket_iostream.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.duration [*duration]]]
    [The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.duration_type [*duration_type]]]
    [(Deprecated: Use duration.) The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.time_point [*time_point]]]
    [The time type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.time_type [*time_type]]]
    [(Deprecated: Use time_point.) The time type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_iostream.basic_socket_iostream [*basic_socket_iostream]] [constructor]]
    [Construct a basic_socket_iostream without establishing a connection. 
     [hr]
     Construct a basic_socket_iostream from the supplied socket. 
     [hr]
     Move-construct a basic_socket_iostream from another. 
     [hr]
     Establish a connection to an endpoint corresponding to a resolver query. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.close [*close]]]
    [Close the connection. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.connect [*connect]]]
    [Establish a connection to an endpoint corresponding to a resolver query. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.error [*error]]]
    [Get the last error associated with the stream. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expires_after [*expires_after]]]
    [Set the stream's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expires_at [*expires_at]]]
    [(Deprecated: Use expiry().) Get the stream's expiry time as an absolute time. 
     [hr]
     Set the stream's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expires_from_now [*expires_from_now]]]
    [(Deprecated: Use expiry().) Get the stream's expiry time relative to now. 
     [hr]
     (Deprecated: Use expires_after().) Set the stream's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expiry [*expiry]]]
    [Get the stream's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_iostream from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.rdbuf [*rdbuf]]]
    [Return a pointer to the underlying streambuf. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.socket [*socket]]]
    [Get a reference to the underlying socket. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/ip/tcp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:no_delay ip::tcp::no_delay]

[indexterm2 boost_asio.indexterm.ip__tcp.no_delay..no_delay..ip::tcp] 
Socket option for disabling the Nagle algorithm. 


  typedef implementation_defined no_delay;



Implements the IPPROTO\_TCP/TCP\_NODELAY socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::no_delay option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::tcp::no_delay option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/ip/tcp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_not__eq_ ip::tcp::operator!=]

[indexterm2 boost_asio.indexterm.ip__tcp.operator_not__eq_..operator!=..ip::tcp] 
Compare two protocols for inequality. 


  friend bool operator!=(
      const tcp & p1,
      const tcp & p2);


[heading Requirements]

['Header: ][^boost/asio/ip/tcp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq__eq_ ip::tcp::operator==]

[indexterm2 boost_asio.indexterm.ip__tcp.operator_eq__eq_..operator==..ip::tcp] 
Compare two protocols for equality. 


  friend bool operator==(
      const tcp & p1,
      const tcp & p2);


[heading Requirements]

['Header: ][^boost/asio/ip/tcp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol ip::tcp::protocol]

[indexterm2 boost_asio.indexterm.ip__tcp.protocol..protocol..ip::tcp] 
Obtain an identifier for the protocol. 


  int protocol() const;



[endsect]



[section:resolver ip::tcp::resolver]

[indexterm2 boost_asio.indexterm.ip__tcp.resolver..resolver..ip::tcp] 
The TCP resolver type. 


  typedef basic_resolver< tcp > resolver;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver__rebind_executor [*rebind_executor]]]
    [Rebinds the resolver type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.iterator [*iterator]]]
    [(Deprecated.) The iterator type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.query [*query]]]
    [(Deprecated.) The query type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.results_type [*results_type]]]
    [The results type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver.async_resolve [*async_resolve]]]
    [(Deprecated: Use overload with separate host and service parameters.) Asynchronously perform forward resolution of a query to a list of entries. 
     [hr]
     Asynchronously perform forward resolution of a query to a list of entries. 
     [hr]
     Asynchronously perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.basic_resolver [*basic_resolver]] [constructor]]
    [Construct with executor. 
     [hr]
     Construct with execution context. 
     [hr]
     Move-construct a basic_resolver from another. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the resolver. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.operator_eq_ [*operator=]]]
    [Move-assign a basic_resolver from another. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.resolve [*resolve]]]
    [(Deprecated: Use overload with separate host and service parameters.) Perform forward resolution of a query to a list of entries. 
     [hr]
     Perform forward resolution of a query to a list of entries. 
     [hr]
     Perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver._basic_resolver [*~basic_resolver]] [destructor]]
    [Destroys the resolver. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver.address_configured [*address_configured]] [static]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.all_matching [*all_matching]] [static]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.canonical_name [*canonical_name]] [static]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.numeric_host [*numeric_host]] [static]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.numeric_service [*numeric_service]] [static]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.passive [*passive]] [static]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.v4_mapped [*v4_mapped]] [static]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]

The [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] class template provides the ability to resolve a query to a list of endpoints.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/tcp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:socket ip::tcp::socket]

[indexterm2 boost_asio.indexterm.ip__tcp.socket..socket..ip::tcp] 
The TCP socket type. 


  typedef basic_stream_socket< tcp > socket;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_stream_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_send [*async_send]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.basic_stream_socket [*basic_stream_socket]] [constructor]]
    [Construct a basic_stream_socket without opening it. 
     [hr]
     Construct and open a basic_stream_socket. 
     [hr]
     Construct a basic_stream_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_stream_socket on an existing native socket. 
     [hr]
     Move-construct a basic_stream_socket from another. 
     [hr]
     Move-construct a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_stream_socket from another. 
     [hr]
     Move-assign a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.read_some [*read_some]]]
    [Read some data from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.receive [*receive]]]
    [Receive some data on the socket. 
     [hr]
     Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.send [*send]]]
    [Send some data on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.write_some [*write_some]]]
    [Write some data to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket._basic_stream_socket [*~basic_stream_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] class template provides asynchronous and blocking stream-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `receive`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe.





[heading Requirements]

['Header: ][^boost/asio/ip/tcp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:type ip::tcp::type]

[indexterm2 boost_asio.indexterm.ip__tcp.type..type..ip::tcp] 
Obtain an identifier for the type of the protocol. 


  int type() const;



[endsect]



[section:v4 ip::tcp::v4]

[indexterm2 boost_asio.indexterm.ip__tcp.v4..v4..ip::tcp] 
Construct to represent the IPv4 TCP protocol. 


  static tcp v4();



[endsect]



[section:v6 ip::tcp::v6]

[indexterm2 boost_asio.indexterm.ip__tcp.v6..v6..ip::tcp] 
Construct to represent the IPv6 TCP protocol. 


  static tcp v6();



[endsect]



[endsect]

[section:ip__udp ip::udp]

[indexterm1 boost_asio.indexterm.ip__udp..ip::udp]


Encapsulates the flags needed for UDP. 


  class udp


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__udp.endpoint [*endpoint]]]
    [The type of a UDP endpoint. ]
  
  ]

  [

    [[link boost_asio.reference.ip__udp.resolver [*resolver]]]
    [The UDP resolver type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__udp.socket [*socket]]]
    [The UDP socket type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__udp.family [*family]]]
    [Obtain an identifier for the protocol family. ]
  ]
  
  [
    [[link boost_asio.reference.ip__udp.protocol [*protocol]]]
    [Obtain an identifier for the protocol. ]
  ]
  
  [
    [[link boost_asio.reference.ip__udp.type [*type]]]
    [Obtain an identifier for the type of the protocol. ]
  ]
  
  [
    [[link boost_asio.reference.ip__udp.v4 [*v4]] [static]]
    [Construct to represent the IPv4 UDP protocol. ]
  ]
  
  [
    [[link boost_asio.reference.ip__udp.v6 [*v6]] [static]]
    [Construct to represent the IPv6 UDP protocol. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__udp.operator_not__eq_ [*operator!=]]]
    [Compare two protocols for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__udp.operator_eq__eq_ [*operator==]]]
    [Compare two protocols for equality. ]
  ]
  
]

The [link boost_asio.reference.ip__udp `ip::udp`] class contains flags necessary for UDP sockets.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Safe.




[heading Requirements]

['Header: ][^boost/asio/ip/udp.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:endpoint ip::udp::endpoint]

[indexterm2 boost_asio.indexterm.ip__udp.endpoint..endpoint..ip::udp] 
The type of a UDP endpoint. 


  typedef basic_endpoint< udp > endpoint;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_endpoint.address [*address]]]
    [Get the IP address associated with the endpoint. 
     [hr]
     Set the IP address associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.basic_endpoint [*basic_endpoint]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an endpoint using a port number, specified in the host's byte order. The IP address will be the any address (i.e. INADDR_ANY or in6addr_any). This constructor would typically be used for accepting new connections. 
     [hr]
     Construct an endpoint using a port number and an IP address. This constructor may be used for accepting connections on a specific interface or for making a connection to a remote endpoint. 
     [hr]
     Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. 
     [hr]
     Move-assign from another endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.port [*port]]]
    [Get the port associated with the endpoint. The port number is always in the host's byte order. 
     [hr]
     Set the port associated with the endpoint. The port number is always in the host's byte order. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_endpoint.operator_lt__lt_ [*operator<<]]]
    [Output an endpoint as a string. ]
  ]
  
]

The [link boost_asio.reference.ip__basic_endpoint `ip::basic_endpoint`] class template describes an endpoint that may be associated with a particular socket.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.





[heading Requirements]

['Header: ][^boost/asio/ip/udp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:family ip::udp::family]

[indexterm2 boost_asio.indexterm.ip__udp.family..family..ip::udp] 
Obtain an identifier for the protocol family. 


  int family() const;



[endsect]



[section:operator_not__eq_ ip::udp::operator!=]

[indexterm2 boost_asio.indexterm.ip__udp.operator_not__eq_..operator!=..ip::udp] 
Compare two protocols for inequality. 


  friend bool operator!=(
      const udp & p1,
      const udp & p2);


[heading Requirements]

['Header: ][^boost/asio/ip/udp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq__eq_ ip::udp::operator==]

[indexterm2 boost_asio.indexterm.ip__udp.operator_eq__eq_..operator==..ip::udp] 
Compare two protocols for equality. 


  friend bool operator==(
      const udp & p1,
      const udp & p2);


[heading Requirements]

['Header: ][^boost/asio/ip/udp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol ip::udp::protocol]

[indexterm2 boost_asio.indexterm.ip__udp.protocol..protocol..ip::udp] 
Obtain an identifier for the protocol. 


  int protocol() const;



[endsect]



[section:resolver ip::udp::resolver]

[indexterm2 boost_asio.indexterm.ip__udp.resolver..resolver..ip::udp] 
The UDP resolver type. 


  typedef basic_resolver< udp > resolver;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ip__basic_resolver__rebind_executor [*rebind_executor]]]
    [Rebinds the resolver type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.iterator [*iterator]]]
    [(Deprecated.) The iterator type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.query [*query]]]
    [(Deprecated.) The query type. ]
  
  ]

  [

    [[link boost_asio.reference.ip__basic_resolver.results_type [*results_type]]]
    [The results type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver.async_resolve [*async_resolve]]]
    [(Deprecated: Use overload with separate host and service parameters.) Asynchronously perform forward resolution of a query to a list of entries. 
     [hr]
     Asynchronously perform forward resolution of a query to a list of entries. 
     [hr]
     Asynchronously perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.basic_resolver [*basic_resolver]] [constructor]]
    [Construct with executor. 
     [hr]
     Construct with execution context. 
     [hr]
     Move-construct a basic_resolver from another. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the resolver. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.operator_eq_ [*operator=]]]
    [Move-assign a basic_resolver from another. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver.resolve [*resolve]]]
    [(Deprecated: Use overload with separate host and service parameters.) Perform forward resolution of a query to a list of entries. 
     [hr]
     Perform forward resolution of a query to a list of entries. 
     [hr]
     Perform reverse resolution of an endpoint to a list of entries. ]
  ]
  
  [
    [[link boost_asio.reference.ip__basic_resolver._basic_resolver [*~basic_resolver]] [destructor]]
    [Destroys the resolver. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ip__basic_resolver.address_configured [*address_configured]] [static]]
    [Only return IPv4 addresses if a non-loopback IPv4 address is configured for the system. Only return IPv6 addresses if a non-loopback IPv6 address is configured for the system. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.all_matching [*all_matching]] [static]]
    [If used with v4_mapped, return all matching IPv6 and IPv4 addresses. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.canonical_name [*canonical_name]] [static]]
    [Determine the canonical name of the host specified in the query. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.numeric_host [*numeric_host]] [static]]
    [Host name should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.numeric_service [*numeric_service]] [static]]
    [Service name should be treated as a numeric string defining a port number and no name resolution should be attempted. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.passive [*passive]] [static]]
    [Indicate that returned endpoint is intended for use as a locally bound socket endpoint. ]
  ]

  [
    [[link boost_asio.reference.ip__basic_resolver.v4_mapped [*v4_mapped]] [static]]
    [If the query protocol family is specified as IPv6, return IPv4-mapped IPv6 addresses on finding no IPv6 addresses. ]
  ]

]

The [link boost_asio.reference.ip__basic_resolver `ip::basic_resolver`] class template provides the ability to resolve a query to a list of endpoints.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/ip/udp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:socket ip::udp::socket]

[indexterm2 boost_asio.indexterm.ip__udp.socket..socket..ip::udp] 
The UDP socket type. 


  typedef basic_datagram_socket< udp > socket;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_datagram_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_datagram_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_receive_from [*async_receive_from]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_send [*async_send]]]
    [Start an asynchronous send on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_send_to [*async_send_to]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket [*basic_datagram_socket]] [constructor]]
    [Construct a basic_datagram_socket without opening it. 
     [hr]
     Construct and open a basic_datagram_socket. 
     [hr]
     Construct a basic_datagram_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_datagram_socket on an existing native socket. 
     [hr]
     Move-construct a basic_datagram_socket from another. 
     [hr]
     Move-construct a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_datagram_socket from another. 
     [hr]
     Move-assign a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.receive [*receive]]]
    [Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.receive_from [*receive_from]]]
    [Receive a datagram with the endpoint of the sender. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.send [*send]]]
    [Send some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.send_to [*send_to]]]
    [Send a datagram to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket._basic_datagram_socket [*~basic_datagram_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_datagram_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] class template provides asynchronous and blocking datagram-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `send_to`, `receive`, `receive_from`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe. 


[heading Requirements]

['Header: ][^boost/asio/ip/udp.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:type ip::udp::type]

[indexterm2 boost_asio.indexterm.ip__udp.type..type..ip::udp] 
Obtain an identifier for the type of the protocol. 


  int type() const;



[endsect]



[section:v4 ip::udp::v4]

[indexterm2 boost_asio.indexterm.ip__udp.v4..v4..ip::udp] 
Construct to represent the IPv4 UDP protocol. 


  static udp v4();



[endsect]



[section:v6 ip::udp::v6]

[indexterm2 boost_asio.indexterm.ip__udp.v6..v6..ip::udp] 
Construct to represent the IPv6 UDP protocol. 


  static udp v6();



[endsect]



[endsect]


[section:ip__unicast__hops ip::unicast::hops]

[indexterm1 boost_asio.indexterm.ip__unicast__hops..ip::unicast::hops] 
Socket option for time-to-live associated with outgoing unicast packets. 


  typedef implementation_defined hops;



Implements the IPPROTO\_IP/IP\_UNICAST\_TTL socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::ip::unicast::hops option(4);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::ip::unicast::hops option;
   socket.get_option(option);
   int ttl = option.value();







[heading Requirements]

['Header: ][^boost/asio/ip/unicast.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:ip__v4_mapped_t ip::v4_mapped_t]

[indexterm1 boost_asio.indexterm.ip__v4_mapped_t..ip::v4_mapped_t] 
Tag type used for distinguishing overloads that deal in IPv4-mapped IPv6 addresses. 

  enum v4_mapped_t

[indexterm2 boost_asio.indexterm.ip__v4_mapped_t.v4_mapped..v4_mapped..ip::v4_mapped_t]

[heading Values]
[variablelist

  [
    [v4_mapped]
    []
  ]

]


[heading Requirements]

['Header: ][^boost/asio/ip/address_v6.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:ip__v6_only ip::v6_only]

[indexterm1 boost_asio.indexterm.ip__v6_only..ip::v6_only] 
Socket option for determining whether an IPv6 socket supports IPv6 communication only. 


  typedef implementation_defined v6_only;



Implements the IPPROTO\_IPV6/IP\_V6ONLY socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::v6_only option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::ip::v6_only option;
   socket.get_option(option);
   bool v6_only = option.value();







[heading Requirements]

['Header: ][^boost/asio/ip/v6_only.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:is_applicable_property is_applicable_property]

[indexterm1 boost_asio.indexterm.is_applicable_property..is_applicable_property]



  template<
      typename T,
      typename Property,
      typename  = void>
  struct is_applicable_property


[heading Requirements]

['Header: ][^boost/asio/is_applicable_property.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:is_const_buffer_sequence is_const_buffer_sequence]

[indexterm1 boost_asio.indexterm.is_const_buffer_sequence..is_const_buffer_sequence]


Trait to determine whether a type satisfies the ConstBufferSequence requirements. 


  template<
      typename T>
  struct is_const_buffer_sequence


[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:is_dynamic_buffer is_dynamic_buffer]

[indexterm1 boost_asio.indexterm.is_dynamic_buffer..is_dynamic_buffer]


Trait to determine whether a type satisfies the DynamicBuffer requirements. 


  template<
      typename T>
  struct is_dynamic_buffer


If `BOOST_ASIO_NO_DYNAMIC_BUFFER_V1` is not defined, determines whether the type satisfies the DynamicBuffer\_v1 requirements. Otherwise, if `BOOST_ASIO_NO_DYNAMIC_BUFFER_V1` is defined, determines whether the type satisfies the DynamicBuffer\_v2 requirements. 

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:is_dynamic_buffer_v1 is_dynamic_buffer_v1]

[indexterm1 boost_asio.indexterm.is_dynamic_buffer_v1..is_dynamic_buffer_v1]


Trait to determine whether a type satisfies the DynamicBuffer\_v1 requirements. 


  template<
      typename T>
  struct is_dynamic_buffer_v1


[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:is_dynamic_buffer_v2 is_dynamic_buffer_v2]

[indexterm1 boost_asio.indexterm.is_dynamic_buffer_v2..is_dynamic_buffer_v2]


Trait to determine whether a type satisfies the DynamicBuffer\_v2 requirements. 


  template<
      typename T>
  struct is_dynamic_buffer_v2


[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:is_endpoint_sequence is_endpoint_sequence]

[indexterm1 boost_asio.indexterm.is_endpoint_sequence..is_endpoint_sequence]


Type trait used to determine whether a type is an endpoint sequence that can be used with with `connect` and `async_connect`. 


  template<
      typename T>
  struct is_endpoint_sequence


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.is_endpoint_sequence.value [*value]] [static]]
    [The value member is true if the type may be used as an endpoint sequence. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/connect.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:value is_endpoint_sequence::value]

[indexterm2 boost_asio.indexterm.is_endpoint_sequence.value..value..is_endpoint_sequence] 
The value member is true if the type may be used as an endpoint sequence. 


  static const bool value;



[endsect]



[endsect]

[section:is_executor is_executor]

[indexterm1 boost_asio.indexterm.is_executor..is_executor]


The [link boost_asio.reference.is_executor `is_executor`] trait detects whether a type T meets the Executor type requirements. 


  template<
      typename T>
  struct is_executor


Class template `is_executor` is a UnaryTypeTrait that is derived from `true_type` if the type `T` meets the syntactic requirements for Executor, otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/is_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:is_match_condition is_match_condition]

[indexterm1 boost_asio.indexterm.is_match_condition..is_match_condition]


Type trait used to determine whether a type can be used as a match condition function with read\_until and async\_read\_until. 


  template<
      typename T>
  struct is_match_condition


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.is_match_condition.value [*value]] [static]]
    [The value member is true if the type may be used as a match condition. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/read_until.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:value is_match_condition::value]

[indexterm2 boost_asio.indexterm.is_match_condition.value..value..is_match_condition] 
The value member is true if the type may be used as a match condition. 


  static const bool value;



[endsect]



[endsect]

[section:is_mutable_buffer_sequence is_mutable_buffer_sequence]

[indexterm1 boost_asio.indexterm.is_mutable_buffer_sequence..is_mutable_buffer_sequence]


Trait to determine whether a type satisfies the MutableBufferSequence requirements. 


  template<
      typename T>
  struct is_mutable_buffer_sequence


[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:is_nothrow_prefer is_nothrow_prefer]

[indexterm1 boost_asio.indexterm.is_nothrow_prefer..is_nothrow_prefer]


A type trait that determines whether a `prefer` expression will not throw. 


  template<
      typename T,
      typename... Properties>
  struct is_nothrow_prefer


Class template `is_nothrow_prefer` is a trait that is derived from `true_type` if the expression `boost::asio::prefer(std::declval<T>(), std::declval<Properties>()...)` is `noexcept`; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/prefer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:is_nothrow_query is_nothrow_query]

[indexterm1 boost_asio.indexterm.is_nothrow_query..is_nothrow_query]


A type trait that determines whether a `query` expression will not throw. 


  template<
      typename T,
      typename Property>
  struct is_nothrow_query


Class template `is_nothrow_query` is a trait that is derived from `true_type` if the expression `boost::asio::query(std::declval<T>(), std::declval<Property>())` is `noexcept`; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/query.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:is_nothrow_require is_nothrow_require]

[indexterm1 boost_asio.indexterm.is_nothrow_require..is_nothrow_require]


A type trait that determines whether a `require` expression will not throw. 


  template<
      typename T,
      typename... Properties>
  struct is_nothrow_require


Class template `is_nothrow_require` is a trait that is derived from `true_type` if the expression `boost::asio::require(std::declval<T>(), std::declval<Properties>()...)` is `noexcept`; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/require.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:is_nothrow_require_concept is_nothrow_require_concept]

[indexterm1 boost_asio.indexterm.is_nothrow_require_concept..is_nothrow_require_concept]


A type trait that determines whether a `require_concept` expression will not throw. 


  template<
      typename T,
      typename Property>
  struct is_nothrow_require_concept


Class template `is_nothrow_require_concept` is a trait that is derived from `true_type` if the expression `boost::asio::require_concept(std::declval<T>(), std::declval<Property>())` is `noexcept`; otherwise `false_type`. 

[heading Requirements]

['Header: ][^boost/asio/require_concept.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:is_read_buffered is_read_buffered]

[indexterm1 boost_asio.indexterm.is_read_buffered..is_read_buffered]


The [link boost_asio.reference.is_read_buffered `is_read_buffered`] class is a traits class that may be used to determine whether a stream type supports buffering of read data. 


  template<
      typename Stream>
  class is_read_buffered


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.is_read_buffered.value [*value]] [static]]
    [The value member is true only if the Stream type supports buffering of read data. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/is_read_buffered.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:value is_read_buffered::value]

[indexterm2 boost_asio.indexterm.is_read_buffered.value..value..is_read_buffered] 
The value member is true only if the Stream type supports buffering of read data. 


  static const bool value;



[endsect]



[endsect]

[section:is_write_buffered is_write_buffered]

[indexterm1 boost_asio.indexterm.is_write_buffered..is_write_buffered]


The [link boost_asio.reference.is_write_buffered `is_write_buffered`] class is a traits class that may be used to determine whether a stream type supports buffering of written data. 


  template<
      typename Stream>
  class is_write_buffered


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.is_write_buffered.value [*value]] [static]]
    [The value member is true only if the Stream type supports buffering of written data. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/is_write_buffered.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:value is_write_buffered::value]

[indexterm2 boost_asio.indexterm.is_write_buffered.value..value..is_write_buffered] 
The value member is true only if the Stream type supports buffering of written data. 


  static const bool value;



[endsect]



[endsect]

[section:local__basic_endpoint local::basic_endpoint]

[indexterm1 boost_asio.indexterm.local__basic_endpoint..local::basic_endpoint]


Describes an endpoint for a UNIX socket. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``>
  class basic_endpoint


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.local__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link boost_asio.reference.local__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.local__basic_endpoint.basic_endpoint [*basic_endpoint]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an endpoint using the specified path name. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.path [*path]]]
    [Get the path associated with the endpoint. 
     [hr]
     Set the path associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.local__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.local__basic_endpoint.operator_lt__lt_ [*operator<<]]]
    [Output an endpoint as a string. ]
  ]
  
]

The [link boost_asio.reference.local__basic_endpoint `local::basic_endpoint`] class template describes an endpoint that may be associated with a particular UNIX socket.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.




[heading Requirements]

['Header: ][^boost/asio/local/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_endpoint local::basic_endpoint::basic_endpoint]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.basic_endpoint..basic_endpoint..local::basic_endpoint] 
Default constructor. 


  ``[link boost_asio.reference.local__basic_endpoint.basic_endpoint.overload1 basic_endpoint]``();
  ``  [''''&raquo;''' [link boost_asio.reference.local__basic_endpoint.basic_endpoint.overload1 more...]]``


Construct an endpoint using the specified path name. 


  ``[link boost_asio.reference.local__basic_endpoint.basic_endpoint.overload2 basic_endpoint]``(
      const char * path_name);
  ``  [''''&raquo;''' [link boost_asio.reference.local__basic_endpoint.basic_endpoint.overload2 more...]]``

  ``[link boost_asio.reference.local__basic_endpoint.basic_endpoint.overload3 basic_endpoint]``(
      const std::string & path_name);
  ``  [''''&raquo;''' [link boost_asio.reference.local__basic_endpoint.basic_endpoint.overload3 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.local__basic_endpoint.basic_endpoint.overload4 basic_endpoint]``(
      const basic_endpoint & other);
  ``  [''''&raquo;''' [link boost_asio.reference.local__basic_endpoint.basic_endpoint.overload4 more...]]``


[section:overload1 local::basic_endpoint::basic_endpoint (1 of 4 overloads)]


Default constructor. 


  basic_endpoint();



[endsect]



[section:overload2 local::basic_endpoint::basic_endpoint (2 of 4 overloads)]


Construct an endpoint using the specified path name. 


  basic_endpoint(
      const char * path_name);



[endsect]



[section:overload3 local::basic_endpoint::basic_endpoint (3 of 4 overloads)]


Construct an endpoint using the specified path name. 


  basic_endpoint(
      const std::string & path_name);



[endsect]



[section:overload4 local::basic_endpoint::basic_endpoint (4 of 4 overloads)]


Copy constructor. 


  basic_endpoint(
      const basic_endpoint & other);



[endsect]


[endsect]


[section:capacity local::basic_endpoint::capacity]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.capacity..capacity..local::basic_endpoint] 
Get the capacity of the endpoint in the native type. 


  std::size_t capacity() const;



[endsect]


[section:data local::basic_endpoint::data]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.data..data..local::basic_endpoint] 
Get the underlying endpoint in the native type. 


  data_type * ``[link boost_asio.reference.local__basic_endpoint.data.overload1 data]``();
  ``  [''''&raquo;''' [link boost_asio.reference.local__basic_endpoint.data.overload1 more...]]``

  const data_type * ``[link boost_asio.reference.local__basic_endpoint.data.overload2 data]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.local__basic_endpoint.data.overload2 more...]]``


[section:overload1 local::basic_endpoint::data (1 of 2 overloads)]


Get the underlying endpoint in the native type. 


  data_type * data();



[endsect]



[section:overload2 local::basic_endpoint::data (2 of 2 overloads)]


Get the underlying endpoint in the native type. 


  const data_type * data() const;



[endsect]


[endsect]


[section:data_type local::basic_endpoint::data_type]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.data_type..data_type..local::basic_endpoint] 
The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. 


  typedef implementation_defined data_type;



[heading Requirements]

['Header: ][^boost/asio/local/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_not__eq_ local::basic_endpoint::operator!=]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.operator_not__eq_..operator!=..local::basic_endpoint] 
Compare two endpoints for inequality. 


  friend bool operator!=(
      const basic_endpoint< Protocol > & e1,
      const basic_endpoint< Protocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/local/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_lt_ local::basic_endpoint::operator<]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.operator_lt_..operator<..local::basic_endpoint] 
Compare endpoints for ordering. 


  friend bool operator<(
      const basic_endpoint< Protocol > & e1,
      const basic_endpoint< Protocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/local/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_lt__lt_ local::basic_endpoint::operator<<]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.operator_lt__lt_..operator<<..local::basic_endpoint] 
Output an endpoint as a string. 


  std::basic_ostream< Elem, Traits > & operator<<(
      std::basic_ostream< Elem, Traits > & os,
      const basic_endpoint< Protocol > & endpoint);


Used to output a human-readable string for a specified endpoint.


[heading Parameters]
    

[variablelist
  
[[os][The output stream to which the string will be written.]]

[[endpoint][The endpoint to be written.]]

]


[heading Return Value]
      
The output stream. 




[endsect]



[section:operator_lt__eq_ local::basic_endpoint::operator<=]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.operator_lt__eq_..operator<=..local::basic_endpoint] 
Compare endpoints for ordering. 


  friend bool operator<=(
      const basic_endpoint< Protocol > & e1,
      const basic_endpoint< Protocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/local/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ local::basic_endpoint::operator=]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.operator_eq_..operator=..local::basic_endpoint] 
Assign from another endpoint. 


  basic_endpoint & operator=(
      const basic_endpoint & other);



[endsect]



[section:operator_eq__eq_ local::basic_endpoint::operator==]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.operator_eq__eq_..operator==..local::basic_endpoint] 
Compare two endpoints for equality. 


  friend bool operator==(
      const basic_endpoint< Protocol > & e1,
      const basic_endpoint< Protocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/local/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt_ local::basic_endpoint::operator>]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.operator_gt_..operator>..local::basic_endpoint] 
Compare endpoints for ordering. 


  friend bool operator>(
      const basic_endpoint< Protocol > & e1,
      const basic_endpoint< Protocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/local/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_gt__eq_ local::basic_endpoint::operator>=]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.operator_gt__eq_..operator>=..local::basic_endpoint] 
Compare endpoints for ordering. 


  friend bool operator>=(
      const basic_endpoint< Protocol > & e1,
      const basic_endpoint< Protocol > & e2);


[heading Requirements]

['Header: ][^boost/asio/local/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:path local::basic_endpoint::path]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.path..path..local::basic_endpoint] 
Get the path associated with the endpoint. 


  std::string ``[link boost_asio.reference.local__basic_endpoint.path.overload1 path]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.local__basic_endpoint.path.overload1 more...]]``


Set the path associated with the endpoint. 


  void ``[link boost_asio.reference.local__basic_endpoint.path.overload2 path]``(
      const char * p);
  ``  [''''&raquo;''' [link boost_asio.reference.local__basic_endpoint.path.overload2 more...]]``

  void ``[link boost_asio.reference.local__basic_endpoint.path.overload3 path]``(
      const std::string & p);
  ``  [''''&raquo;''' [link boost_asio.reference.local__basic_endpoint.path.overload3 more...]]``


[section:overload1 local::basic_endpoint::path (1 of 3 overloads)]


Get the path associated with the endpoint. 


  std::string path() const;



[endsect]



[section:overload2 local::basic_endpoint::path (2 of 3 overloads)]


Set the path associated with the endpoint. 


  void path(
      const char * p);



[endsect]



[section:overload3 local::basic_endpoint::path (3 of 3 overloads)]


Set the path associated with the endpoint. 


  void path(
      const std::string & p);



[endsect]


[endsect]


[section:protocol local::basic_endpoint::protocol]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.protocol..protocol..local::basic_endpoint] 
The protocol associated with the endpoint. 


  protocol_type protocol() const;



[endsect]



[section:protocol_type local::basic_endpoint::protocol_type]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.protocol_type..protocol_type..local::basic_endpoint] 
The protocol type associated with the endpoint. 


  typedef Protocol protocol_type;



[heading Requirements]

['Header: ][^boost/asio/local/basic_endpoint.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:resize local::basic_endpoint::resize]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.resize..resize..local::basic_endpoint] 
Set the underlying size of the endpoint in the native type. 


  void resize(
      std::size_t new_size);



[endsect]



[section:size local::basic_endpoint::size]

[indexterm2 boost_asio.indexterm.local__basic_endpoint.size..size..local::basic_endpoint] 
Get the underlying size of the endpoint in the native type. 


  std::size_t size() const;



[endsect]



[endsect]

[section:local__connect_pair local::connect_pair]

[indexterm1 boost_asio.indexterm.local__connect_pair..local::connect_pair] 
Create a pair of connected sockets. 

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.Executor1 Executor2]``>
  void ``[link boost_asio.reference.local__connect_pair.overload1 connect_pair]``(
      basic_socket< Protocol, Executor1 > & socket1,
      basic_socket< Protocol, Executor2 > & socket2);
  ``  [''''&raquo;''' [link boost_asio.reference.local__connect_pair.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.Executor1 Executor2]``>
  void ``[link boost_asio.reference.local__connect_pair.overload2 connect_pair]``(
      basic_socket< Protocol, Executor1 > & socket1,
      basic_socket< Protocol, Executor2 > & socket2,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.local__connect_pair.overload2 more...]]``

[heading Requirements]

['Header: ][^boost/asio/local/connect_pair.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 local::connect_pair (1 of 2 overloads)]


Create a pair of connected sockets. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.Executor1 Executor2]``>
  void connect_pair(
      basic_socket< Protocol, Executor1 > & socket1,
      basic_socket< Protocol, Executor2 > & socket2);



[endsect]



[section:overload2 local::connect_pair (2 of 2 overloads)]


Create a pair of connected sockets. 


  template<
      typename ``[link boost_asio.reference.Protocol Protocol]``,
      typename ``[link boost_asio.reference.Executor1 Executor1]``,
      typename ``[link boost_asio.reference.Executor1 Executor2]``>
  void connect_pair(
      basic_socket< Protocol, Executor1 > & socket1,
      basic_socket< Protocol, Executor2 > & socket2,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:local__datagram_protocol local::datagram_protocol]

[indexterm1 boost_asio.indexterm.local__datagram_protocol..local::datagram_protocol]


Encapsulates the flags needed for datagram-oriented UNIX sockets. 


  class datagram_protocol


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.local__datagram_protocol.endpoint [*endpoint]]]
    [The type of a UNIX domain endpoint. ]
  
  ]

  [

    [[link boost_asio.reference.local__datagram_protocol.socket [*socket]]]
    [The UNIX domain socket type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.local__datagram_protocol.family [*family]]]
    [Obtain an identifier for the protocol family. ]
  ]
  
  [
    [[link boost_asio.reference.local__datagram_protocol.protocol [*protocol]]]
    [Obtain an identifier for the protocol. ]
  ]
  
  [
    [[link boost_asio.reference.local__datagram_protocol.type [*type]]]
    [Obtain an identifier for the type of the protocol. ]
  ]
  
]

The [link boost_asio.reference.local__datagram_protocol `local::datagram_protocol`] class contains flags necessary for datagram-oriented UNIX domain sockets.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Safe.




[heading Requirements]

['Header: ][^boost/asio/local/datagram_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:endpoint local::datagram_protocol::endpoint]

[indexterm2 boost_asio.indexterm.local__datagram_protocol.endpoint..endpoint..local::datagram_protocol] 
The type of a UNIX domain endpoint. 


  typedef basic_endpoint< datagram_protocol > endpoint;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.local__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link boost_asio.reference.local__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.local__basic_endpoint.basic_endpoint [*basic_endpoint]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an endpoint using the specified path name. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.path [*path]]]
    [Get the path associated with the endpoint. 
     [hr]
     Set the path associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.local__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.local__basic_endpoint.operator_lt__lt_ [*operator<<]]]
    [Output an endpoint as a string. ]
  ]
  
]

The [link boost_asio.reference.local__basic_endpoint `local::basic_endpoint`] class template describes an endpoint that may be associated with a particular UNIX socket.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.





[heading Requirements]

['Header: ][^boost/asio/local/datagram_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:family local::datagram_protocol::family]

[indexterm2 boost_asio.indexterm.local__datagram_protocol.family..family..local::datagram_protocol] 
Obtain an identifier for the protocol family. 


  int family() const;



[endsect]



[section:protocol local::datagram_protocol::protocol]

[indexterm2 boost_asio.indexterm.local__datagram_protocol.protocol..protocol..local::datagram_protocol] 
Obtain an identifier for the protocol. 


  int protocol() const;



[endsect]



[section:socket local::datagram_protocol::socket]

[indexterm2 boost_asio.indexterm.local__datagram_protocol.socket..socket..local::datagram_protocol] 
The UNIX domain socket type. 


  typedef basic_datagram_socket< datagram_protocol > socket;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_datagram_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_datagram_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_datagram_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_receive_from [*async_receive_from]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_send [*async_send]]]
    [Start an asynchronous send on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_send_to [*async_send_to]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.basic_datagram_socket [*basic_datagram_socket]] [constructor]]
    [Construct a basic_datagram_socket without opening it. 
     [hr]
     Construct and open a basic_datagram_socket. 
     [hr]
     Construct a basic_datagram_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_datagram_socket on an existing native socket. 
     [hr]
     Move-construct a basic_datagram_socket from another. 
     [hr]
     Move-construct a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_datagram_socket from another. 
     [hr]
     Move-assign a basic_datagram_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.receive [*receive]]]
    [Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.receive_from [*receive_from]]]
    [Receive a datagram with the endpoint of the sender. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.send [*send]]]
    [Send some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.send_to [*send_to]]]
    [Send a datagram to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_datagram_socket._basic_datagram_socket [*~basic_datagram_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_datagram_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_datagram_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] class template provides asynchronous and blocking datagram-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `send_to`, `receive`, `receive_from`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe. 


[heading Requirements]

['Header: ][^boost/asio/local/datagram_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:type local::datagram_protocol::type]

[indexterm2 boost_asio.indexterm.local__datagram_protocol.type..type..local::datagram_protocol] 
Obtain an identifier for the type of the protocol. 


  int type() const;



[endsect]



[endsect]

[section:local__stream_protocol local::stream_protocol]

[indexterm1 boost_asio.indexterm.local__stream_protocol..local::stream_protocol]


Encapsulates the flags needed for stream-oriented UNIX sockets. 


  class stream_protocol


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.local__stream_protocol.acceptor [*acceptor]]]
    [The UNIX domain acceptor type. ]
  
  ]

  [

    [[link boost_asio.reference.local__stream_protocol.endpoint [*endpoint]]]
    [The type of a UNIX domain endpoint. ]
  
  ]

  [

    [[link boost_asio.reference.local__stream_protocol.iostream [*iostream]]]
    [The UNIX domain iostream type. ]
  
  ]

  [

    [[link boost_asio.reference.local__stream_protocol.socket [*socket]]]
    [The UNIX domain socket type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.local__stream_protocol.family [*family]]]
    [Obtain an identifier for the protocol family. ]
  ]
  
  [
    [[link boost_asio.reference.local__stream_protocol.protocol [*protocol]]]
    [Obtain an identifier for the protocol. ]
  ]
  
  [
    [[link boost_asio.reference.local__stream_protocol.type [*type]]]
    [Obtain an identifier for the type of the protocol. ]
  ]
  
]

The [link boost_asio.reference.local__stream_protocol `local::stream_protocol`] class contains flags necessary for stream-oriented UNIX domain sockets.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Safe.




[heading Requirements]

['Header: ][^boost/asio/local/stream_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:acceptor local::stream_protocol::acceptor]

[indexterm2 boost_asio.indexterm.local__stream_protocol.acceptor..acceptor..local::stream_protocol] 
The UNIX domain acceptor type. 


  typedef basic_socket_acceptor< stream_protocol > acceptor;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket_acceptor__rebind_executor [*rebind_executor]]]
    [Rebinds the acceptor type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.native_handle_type [*native_handle_type]]]
    [The native representation of an acceptor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_acceptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_acceptor.accept [*accept]]]
    [Accept a new connection. 
     [hr]
     Accept a new connection and obtain the endpoint of the peer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.assign [*assign]]]
    [Assigns an existing native acceptor to the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.async_accept [*async_accept]]]
    [Start an asynchronous accept. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.async_wait [*async_wait]]]
    [Asynchronously wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.basic_socket_acceptor [*basic_socket_acceptor]] [constructor]]
    [Construct an acceptor without opening it. 
     [hr]
     Construct an open acceptor. 
     [hr]
     Construct an acceptor opened on the given endpoint. 
     [hr]
     Construct a basic_socket_acceptor on an existing native acceptor. 
     [hr]
     Move-construct a basic_socket_acceptor from another. 
     [hr]
     Move-construct a basic_socket_acceptor from an acceptor of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.bind [*bind]]]
    [Bind the acceptor to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.close [*close]]]
    [Close the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.get_option [*get_option]]]
    [Get an option from the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.io_control [*io_control]]]
    [Perform an IO control command on the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.is_open [*is_open]]]
    [Determine whether the acceptor is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.listen [*listen]]]
    [Place the acceptor into the state where it will listen for new connections. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.native_handle [*native_handle]]]
    [Get the native acceptor representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native acceptor implementation. 
     [hr]
     Sets the non-blocking mode of the native acceptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the acceptor. 
     [hr]
     Sets the non-blocking mode of the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.open [*open]]]
    [Open the acceptor using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_acceptor from another. 
     [hr]
     Move-assign a basic_socket_acceptor from an acceptor of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.release [*release]]]
    [Release ownership of the underlying native acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.set_option [*set_option]]]
    [Set an option on the acceptor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor.wait [*wait]]]
    [Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_acceptor._basic_socket_acceptor [*~basic_socket_acceptor]] [destructor]]
    [Destroys the acceptor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_acceptor.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_socket_acceptor.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_socket_acceptor `basic_socket_acceptor`] class template is used for accepting new socket connections.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `accept` operations are thread safe, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to synchronous `accept` operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe.


[heading Example]
  
Opening a socket acceptor with the SO\_REUSEADDR option enabled: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   boost::asio::ip::tcp::endpoint endpoint(boost::asio::ip::tcp::v4(), port);
   acceptor.open(endpoint.protocol());
   acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));
   acceptor.bind(endpoint);
   acceptor.listen();







[heading Requirements]

['Header: ][^boost/asio/local/stream_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:endpoint local::stream_protocol::endpoint]

[indexterm2 boost_asio.indexterm.local__stream_protocol.endpoint..endpoint..local::stream_protocol] 
The type of a UNIX domain endpoint. 


  typedef basic_endpoint< stream_protocol > endpoint;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.local__basic_endpoint.data_type [*data_type]]]
    [The type of the endpoint structure. This type is dependent on the underlying implementation of the socket layer. ]
  
  ]

  [

    [[link boost_asio.reference.local__basic_endpoint.protocol_type [*protocol_type]]]
    [The protocol type associated with the endpoint. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.local__basic_endpoint.basic_endpoint [*basic_endpoint]] [constructor]]
    [Default constructor. 
     [hr]
     Construct an endpoint using the specified path name. 
     [hr]
     Copy constructor. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.capacity [*capacity]]]
    [Get the capacity of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.data [*data]]]
    [Get the underlying endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_eq_ [*operator=]]]
    [Assign from another endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.path [*path]]]
    [Get the path associated with the endpoint. 
     [hr]
     Set the path associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.protocol [*protocol]]]
    [The protocol associated with the endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.resize [*resize]]]
    [Set the underlying size of the endpoint in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.size [*size]]]
    [Get the underlying size of the endpoint in the native type. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.local__basic_endpoint.operator_not__eq_ [*operator!=]]]
    [Compare two endpoints for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_lt_ [*operator<]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_lt__eq_ [*operator<=]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_eq__eq_ [*operator==]]]
    [Compare two endpoints for equality. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_gt_ [*operator>]]]
    [Compare endpoints for ordering. ]
  ]
  
  [
    [[link boost_asio.reference.local__basic_endpoint.operator_gt__eq_ [*operator>=]]]
    [Compare endpoints for ordering. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.local__basic_endpoint.operator_lt__lt_ [*operator<<]]]
    [Output an endpoint as a string. ]
  ]
  
]

The [link boost_asio.reference.local__basic_endpoint `local::basic_endpoint`] class template describes an endpoint that may be associated with a particular UNIX socket.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.





[heading Requirements]

['Header: ][^boost/asio/local/stream_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:family local::stream_protocol::family]

[indexterm2 boost_asio.indexterm.local__stream_protocol.family..family..local::stream_protocol] 
Obtain an identifier for the protocol family. 


  int family() const;



[endsect]



[section:iostream local::stream_protocol::iostream]

[indexterm2 boost_asio.indexterm.local__stream_protocol.iostream..iostream..local::stream_protocol] 
The UNIX domain iostream type. 


  typedef basic_socket_iostream< stream_protocol > iostream;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_socket_iostream.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.duration [*duration]]]
    [The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.duration_type [*duration_type]]]
    [(Deprecated: Use duration.) The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.time_point [*time_point]]]
    [The time type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_socket_iostream.time_type [*time_type]]]
    [(Deprecated: Use time_point.) The time type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_socket_iostream.basic_socket_iostream [*basic_socket_iostream]] [constructor]]
    [Construct a basic_socket_iostream without establishing a connection. 
     [hr]
     Construct a basic_socket_iostream from the supplied socket. 
     [hr]
     Move-construct a basic_socket_iostream from another. 
     [hr]
     Establish a connection to an endpoint corresponding to a resolver query. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.close [*close]]]
    [Close the connection. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.connect [*connect]]]
    [Establish a connection to an endpoint corresponding to a resolver query. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.error [*error]]]
    [Get the last error associated with the stream. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expires_after [*expires_after]]]
    [Set the stream's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expires_at [*expires_at]]]
    [(Deprecated: Use expiry().) Get the stream's expiry time as an absolute time. 
     [hr]
     Set the stream's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expires_from_now [*expires_from_now]]]
    [(Deprecated: Use expiry().) Get the stream's expiry time relative to now. 
     [hr]
     (Deprecated: Use expires_after().) Set the stream's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.expiry [*expiry]]]
    [Get the stream's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.operator_eq_ [*operator=]]]
    [Move-assign a basic_socket_iostream from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.rdbuf [*rdbuf]]]
    [Return a pointer to the underlying streambuf. ]
  ]
  
  [
    [[link boost_asio.reference.basic_socket_iostream.socket [*socket]]]
    [Get a reference to the underlying socket. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/local/stream_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:protocol local::stream_protocol::protocol]

[indexterm2 boost_asio.indexterm.local__stream_protocol.protocol..protocol..local::stream_protocol] 
Obtain an identifier for the protocol. 


  int protocol() const;



[endsect]



[section:socket local::stream_protocol::socket]

[indexterm2 boost_asio.indexterm.local__stream_protocol.socket..socket..local::stream_protocol] 
The UNIX domain socket type. 


  typedef basic_stream_socket< stream_protocol > socket;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_stream_socket__rebind_executor [*rebind_executor]]]
    [Rebinds the socket type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.endpoint_type [*endpoint_type]]]
    [The endpoint type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.lowest_layer_type [*lowest_layer_type]]]
    [A basic_socket is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.native_handle_type [*native_handle_type]]]
    [The native representation of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.protocol_type [*protocol_type]]]
    [The protocol type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_socket.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_socket.assign [*assign]]]
    [Assign an existing native socket to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_connect [*async_connect]]]
    [Start an asynchronous connect. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_receive [*async_receive]]]
    [Start an asynchronous receive. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_send [*async_send]]]
    [Start an asynchronous send. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_wait [*async_wait]]]
    [Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.at_mark [*at_mark]]]
    [Determine whether the socket is at the out-of-band data mark. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.available [*available]]]
    [Determine the number of bytes available for reading. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.basic_stream_socket [*basic_stream_socket]] [constructor]]
    [Construct a basic_stream_socket without opening it. 
     [hr]
     Construct and open a basic_stream_socket. 
     [hr]
     Construct a basic_stream_socket, opening it and binding it to the given local endpoint. 
     [hr]
     Construct a basic_stream_socket on an existing native socket. 
     [hr]
     Move-construct a basic_stream_socket from another. 
     [hr]
     Move-construct a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.bind [*bind]]]
    [Bind the socket to the given local endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.close [*close]]]
    [Close the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.connect [*connect]]]
    [Connect the socket to the specified endpoint. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.get_option [*get_option]]]
    [Get an option from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.io_control [*io_control]]]
    [Perform an IO control command on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.is_open [*is_open]]]
    [Determine whether the socket is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.local_endpoint [*local_endpoint]]]
    [Get the local endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.native_handle [*native_handle]]]
    [Get the native socket representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native socket implementation. 
     [hr]
     Sets the non-blocking mode of the native socket implementation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the socket. 
     [hr]
     Sets the non-blocking mode of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.open [*open]]]
    [Open the socket using the specified protocol. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.operator_eq_ [*operator=]]]
    [Move-assign a basic_stream_socket from another. 
     [hr]
     Move-assign a basic_stream_socket from a socket of another protocol type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.read_some [*read_some]]]
    [Read some data from the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.receive [*receive]]]
    [Receive some data on the socket. 
     [hr]
     Receive some data on a connected socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.release [*release]]]
    [Release ownership of the underlying native socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.remote_endpoint [*remote_endpoint]]]
    [Get the remote endpoint of the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.send [*send]]]
    [Send some data on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.set_option [*set_option]]]
    [Set an option on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.shutdown [*shutdown]]]
    [Disable sends or receives on the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.wait [*wait]]]
    [Wait for the socket to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket.write_some [*write_some]]]
    [Write some data to the socket. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_socket._basic_stream_socket [*~basic_stream_socket]] [destructor]]
    [Destroys the socket. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_socket.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_socket.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

The [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] class template provides asynchronous and blocking stream-oriented socket functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `send`, `receive`, and `connect` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single socket object. Other synchronous operations, such as `open` or `close`, are not thread safe.





[heading Requirements]

['Header: ][^boost/asio/local/stream_protocol.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:type local::stream_protocol::type]

[indexterm2 boost_asio.indexterm.local__stream_protocol.type..type..local::stream_protocol] 
Obtain an identifier for the type of the protocol. 


  int type() const;



[endsect]



[endsect]

[section:make_strand make_strand]

[indexterm1 boost_asio.indexterm.make_strand..make_strand] 
The `boost::asio::make_strand` function creates a [link boost_asio.reference.strand `strand`]  object for an executor or execution context. 


Create a [link boost_asio.reference.strand `strand`]  object for an executor. 

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  strand< Executor > ``[link boost_asio.reference.make_strand.overload1 make_strand]``(
      const Executor & ex,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.make_strand.overload1 more...]]``

Create a [link boost_asio.reference.strand `strand`]  object for an execution context. 

  template<
      typename ExecutionContext>
  strand< typename ExecutionContext::executor_type > ``[link boost_asio.reference.make_strand.overload2 make_strand]``(
      ExecutionContext & ctx,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.make_strand.overload2 more...]]``

[heading Requirements]

['Header: ][^boost/asio/strand.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 make_strand (1 of 2 overloads)]


Create a [link boost_asio.reference.strand `strand`]  object for an executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  strand< Executor > make_strand(
      const Executor & ex,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);



[endsect]



[section:overload2 make_strand (2 of 2 overloads)]


Create a [link boost_asio.reference.strand `strand`]  object for an execution context. 


  template<
      typename ExecutionContext>
  strand< typename ExecutionContext::executor_type > make_strand(
      ExecutionContext & ctx,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[endsect]


[endsect]

[section:make_work_guard make_work_guard]

[indexterm1 boost_asio.indexterm.make_work_guard..make_work_guard] 
Create an [link boost_asio.reference.executor_work_guard `executor_work_guard`]  object. 

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  executor_work_guard< Executor > ``[link boost_asio.reference.make_work_guard.overload1 make_work_guard]``(
      const Executor & ex,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.make_work_guard.overload1 more...]]``

  template<
      typename ExecutionContext>
  executor_work_guard< typename ExecutionContext::executor_type > ``[link boost_asio.reference.make_work_guard.overload2 make_work_guard]``(
      ExecutionContext & ctx,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.make_work_guard.overload2 more...]]``

  template<
      typename T>
  executor_work_guard< typename associated_executor< T >::type > ``[link boost_asio.reference.make_work_guard.overload3 make_work_guard]``(
      const T & t,
      typename constraint< !is_executor< T >::value >::type  = 0,
      typename constraint< !execution::is_executor< T >::value >::type  = 0,
      typename constraint< !is_convertible< T &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.make_work_guard.overload3 more...]]``

  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  executor_work_guard< typename associated_executor< T, Executor >::type > ``[link boost_asio.reference.make_work_guard.overload4 make_work_guard]``(
      const T & t,
      const Executor & ex,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.make_work_guard.overload4 more...]]``

  template<
      typename T,
      typename ExecutionContext>
  executor_work_guard< typename associated_executor< T, typename ExecutionContext::executor_type >::type > ``[link boost_asio.reference.make_work_guard.overload5 make_work_guard]``(
      const T & t,
      ExecutionContext & ctx,
      typename constraint< !is_executor< T >::value >::type  = 0,
      typename constraint< !execution::is_executor< T >::value >::type  = 0,
      typename constraint< !is_convertible< T &, execution_context & >::value >::type  = 0,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.make_work_guard.overload5 more...]]``

[heading Requirements]

['Header: ][^boost/asio/executor_work_guard.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 make_work_guard (1 of 5 overloads)]


Create an [link boost_asio.reference.executor_work_guard `executor_work_guard`]  object. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  executor_work_guard< Executor > make_work_guard(
      const Executor & ex,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);



[endsect]



[section:overload2 make_work_guard (2 of 5 overloads)]


Create an [link boost_asio.reference.executor_work_guard `executor_work_guard`]  object. 


  template<
      typename ExecutionContext>
  executor_work_guard< typename ExecutionContext::executor_type > make_work_guard(
      ExecutionContext & ctx,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[endsect]



[section:overload3 make_work_guard (3 of 5 overloads)]


Create an [link boost_asio.reference.executor_work_guard `executor_work_guard`]  object. 


  template<
      typename T>
  executor_work_guard< typename associated_executor< T >::type > make_work_guard(
      const T & t,
      typename constraint< !is_executor< T >::value >::type  = 0,
      typename constraint< !execution::is_executor< T >::value >::type  = 0,
      typename constraint< !is_convertible< T &, execution_context & >::value >::type  = 0);



[endsect]



[section:overload4 make_work_guard (4 of 5 overloads)]


Create an [link boost_asio.reference.executor_work_guard `executor_work_guard`]  object. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  executor_work_guard< typename associated_executor< T, Executor >::type > make_work_guard(
      const T & t,
      const Executor & ex,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);



[endsect]



[section:overload5 make_work_guard (5 of 5 overloads)]


Create an [link boost_asio.reference.executor_work_guard `executor_work_guard`]  object. 


  template<
      typename T,
      typename ExecutionContext>
  executor_work_guard< typename associated_executor< T, typename ExecutionContext::executor_type >::type > make_work_guard(
      const T & t,
      ExecutionContext & ctx,
      typename constraint< !is_executor< T >::value >::type  = 0,
      typename constraint< !execution::is_executor< T >::value >::type  = 0,
      typename constraint< !is_convertible< T &, execution_context & >::value >::type  = 0,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[endsect]


[endsect]

[section:multiple_exceptions multiple_exceptions]

[indexterm1 boost_asio.indexterm.multiple_exceptions..multiple_exceptions]


Exception thrown when there are multiple pending exceptions to rethrow. 


  class multiple_exceptions :
    public std::exception


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.multiple_exceptions.first_exception [*first_exception]]]
    [Obtain a pointer to the first exception. ]
  ]
  
  [
    [[link boost_asio.reference.multiple_exceptions.multiple_exceptions [*multiple_exceptions]] [constructor]]
    [Constructor. ]
  ]
  
  [
    [[link boost_asio.reference.multiple_exceptions.what [*what]]]
    [Obtain message associated with exception. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/multiple_exceptions.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:first_exception multiple_exceptions::first_exception]

[indexterm2 boost_asio.indexterm.multiple_exceptions.first_exception..first_exception..multiple_exceptions] 
Obtain a pointer to the first exception. 


  std::exception_ptr first_exception() const;



[endsect]



[section:multiple_exceptions multiple_exceptions::multiple_exceptions]

[indexterm2 boost_asio.indexterm.multiple_exceptions.multiple_exceptions..multiple_exceptions..multiple_exceptions] 
Constructor. 


  multiple_exceptions(
      std::exception_ptr first);



[endsect]



[section:what multiple_exceptions::what]

[indexterm2 boost_asio.indexterm.multiple_exceptions.what..what..multiple_exceptions] 
Obtain message associated with exception. 


  virtual const char * what() const;



[endsect]



[endsect]

[section:mutable_buffer mutable_buffer]

[indexterm1 boost_asio.indexterm.mutable_buffer..mutable_buffer]


Holds a buffer that can be modified. 


  class mutable_buffer


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.mutable_buffer [*mutable_buffer]] [constructor]]
    [Construct an empty buffer. 
     [hr]
     Construct a buffer to represent a given memory range. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_buffer.operator_plus_ [*operator+]]]
    [Create a new modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link boost_asio.reference.mutable_buffer `mutable_buffer`] class provides a safe representation of a buffer that can be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   boost::asio::mutable_buffer b1 = ...;
   std::size_t s1 = b1.size();
   unsigned char* p1 = static_cast<unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:data mutable_buffer::data]

[indexterm2 boost_asio.indexterm.mutable_buffer.data..data..mutable_buffer] 
Get a pointer to the beginning of the memory range. 


  void * data() const;



[endsect]


[section:mutable_buffer mutable_buffer::mutable_buffer]

[indexterm2 boost_asio.indexterm.mutable_buffer.mutable_buffer..mutable_buffer..mutable_buffer] 
Construct an empty buffer. 


  ``[link boost_asio.reference.mutable_buffer.mutable_buffer.overload1 mutable_buffer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.mutable_buffer.mutable_buffer.overload1 more...]]``


Construct a buffer to represent a given memory range. 


  ``[link boost_asio.reference.mutable_buffer.mutable_buffer.overload2 mutable_buffer]``(
      void * data,
      std::size_t size);
  ``  [''''&raquo;''' [link boost_asio.reference.mutable_buffer.mutable_buffer.overload2 more...]]``


[section:overload1 mutable_buffer::mutable_buffer (1 of 2 overloads)]


Construct an empty buffer. 


  mutable_buffer();



[endsect]



[section:overload2 mutable_buffer::mutable_buffer (2 of 2 overloads)]


Construct a buffer to represent a given memory range. 


  mutable_buffer(
      void * data,
      std::size_t size);



[endsect]


[endsect]

[section:operator_plus_ mutable_buffer::operator+]

[indexterm2 boost_asio.indexterm.mutable_buffer.operator_plus_..operator+..mutable_buffer] 
Create a new modifiable buffer that is offset from the start of another. 


  mutable_buffer ``[link boost_asio.reference.mutable_buffer.operator_plus_.overload1 operator+]``(
      const mutable_buffer & b,
      std::size_t n);
  ``  [''''&raquo;''' [link boost_asio.reference.mutable_buffer.operator_plus_.overload1 more...]]``

  mutable_buffer ``[link boost_asio.reference.mutable_buffer.operator_plus_.overload2 operator+]``(
      std::size_t n,
      const mutable_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.mutable_buffer.operator_plus_.overload2 more...]]``


[section:overload1 mutable_buffer::operator+ (1 of 2 overloads)]


Create a new modifiable buffer that is offset from the start of another. 


  mutable_buffer operator+(
      const mutable_buffer & b,
      std::size_t n);



[endsect]



[section:overload2 mutable_buffer::operator+ (2 of 2 overloads)]


Create a new modifiable buffer that is offset from the start of another. 


  mutable_buffer operator+(
      std::size_t n,
      const mutable_buffer & b);



[endsect]


[endsect]


[section:operator_plus__eq_ mutable_buffer::operator+=]

[indexterm2 boost_asio.indexterm.mutable_buffer.operator_plus__eq_..operator+=..mutable_buffer] 
Move the start of the buffer by the specified number of bytes. 


  mutable_buffer & operator+=(
      std::size_t n);



[endsect]



[section:size mutable_buffer::size]

[indexterm2 boost_asio.indexterm.mutable_buffer.size..size..mutable_buffer] 
Get the size of the memory range. 


  std::size_t size() const;



[endsect]



[endsect]

[section:mutable_buffers_1 mutable_buffers_1]

[indexterm1 boost_asio.indexterm.mutable_buffers_1..mutable_buffers_1]


(Deprecated: Use [link boost_asio.reference.mutable_buffer `mutable_buffer`].) Adapts a single modifiable buffer so that it meets the requirements of the MutableBufferSequence concept. 


  class mutable_buffers_1 :
    public mutable_buffer


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.mutable_buffers_1.const_iterator [*const_iterator]]]
    [A random-access iterator type that may be used to read elements. ]
  
  ]

  [

    [[link boost_asio.reference.mutable_buffers_1.value_type [*value_type]]]
    [The type for each element in the list of buffers. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_buffers_1.begin [*begin]]]
    [Get a random-access iterator to the first element. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffers_1.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffers_1.end [*end]]]
    [Get a random-access iterator for one past the last element. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffers_1.mutable_buffers_1 [*mutable_buffers_1]] [constructor]]
    [Construct to represent a given memory range. 
     [hr]
     Construct to represent a single modifiable buffer. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffers_1.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffers_1.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_buffers_1.operator_plus_ [*operator+]]]
    [Create a new modifiable buffer that is offset from the start of another. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:begin mutable_buffers_1::begin]

[indexterm2 boost_asio.indexterm.mutable_buffers_1.begin..begin..mutable_buffers_1] 
Get a random-access iterator to the first element. 


  const_iterator begin() const;



[endsect]



[section:const_iterator mutable_buffers_1::const_iterator]

[indexterm2 boost_asio.indexterm.mutable_buffers_1.const_iterator..const_iterator..mutable_buffers_1] 
A random-access iterator type that may be used to read elements. 


  typedef const mutable_buffer * const_iterator;



[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:data mutable_buffers_1::data]


['Inherited from mutable_buffer.]

[indexterm2 boost_asio.indexterm.mutable_buffers_1.data..data..mutable_buffers_1] 
Get a pointer to the beginning of the memory range. 


  void * data() const;



[endsect]



[section:end mutable_buffers_1::end]

[indexterm2 boost_asio.indexterm.mutable_buffers_1.end..end..mutable_buffers_1] 
Get a random-access iterator for one past the last element. 


  const_iterator end() const;



[endsect]


[section:mutable_buffers_1 mutable_buffers_1::mutable_buffers_1]

[indexterm2 boost_asio.indexterm.mutable_buffers_1.mutable_buffers_1..mutable_buffers_1..mutable_buffers_1] 
Construct to represent a given memory range. 


  ``[link boost_asio.reference.mutable_buffers_1.mutable_buffers_1.overload1 mutable_buffers_1]``(
      void * data,
      std::size_t size);
  ``  [''''&raquo;''' [link boost_asio.reference.mutable_buffers_1.mutable_buffers_1.overload1 more...]]``


Construct to represent a single modifiable buffer. 


  explicit ``[link boost_asio.reference.mutable_buffers_1.mutable_buffers_1.overload2 mutable_buffers_1]``(
      const mutable_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.mutable_buffers_1.mutable_buffers_1.overload2 more...]]``


[section:overload1 mutable_buffers_1::mutable_buffers_1 (1 of 2 overloads)]


Construct to represent a given memory range. 


  mutable_buffers_1(
      void * data,
      std::size_t size);



[endsect]



[section:overload2 mutable_buffers_1::mutable_buffers_1 (2 of 2 overloads)]


Construct to represent a single modifiable buffer. 


  mutable_buffers_1(
      const mutable_buffer & b);



[endsect]


[endsect]

[section:operator_plus_ mutable_buffers_1::operator+]

[indexterm2 boost_asio.indexterm.mutable_buffers_1.operator_plus_..operator+..mutable_buffers_1] 
Create a new modifiable buffer that is offset from the start of another. 


  mutable_buffer ``[link boost_asio.reference.mutable_buffers_1.operator_plus_.overload1 operator+]``(
      const mutable_buffer & b,
      std::size_t n);
  ``  [''''&raquo;''' [link boost_asio.reference.mutable_buffers_1.operator_plus_.overload1 more...]]``

  mutable_buffer ``[link boost_asio.reference.mutable_buffers_1.operator_plus_.overload2 operator+]``(
      std::size_t n,
      const mutable_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.mutable_buffers_1.operator_plus_.overload2 more...]]``


[section:overload1 mutable_buffers_1::operator+ (1 of 2 overloads)]


['Inherited from mutable_buffer.]


Create a new modifiable buffer that is offset from the start of another. 


  mutable_buffer operator+(
      const mutable_buffer & b,
      std::size_t n);



[endsect]



[section:overload2 mutable_buffers_1::operator+ (2 of 2 overloads)]


['Inherited from mutable_buffer.]


Create a new modifiable buffer that is offset from the start of another. 


  mutable_buffer operator+(
      std::size_t n,
      const mutable_buffer & b);



[endsect]


[endsect]


[section:operator_plus__eq_ mutable_buffers_1::operator+=]


['Inherited from mutable_buffer.]

[indexterm2 boost_asio.indexterm.mutable_buffers_1.operator_plus__eq_..operator+=..mutable_buffers_1] 
Move the start of the buffer by the specified number of bytes. 


  mutable_buffer & operator+=(
      std::size_t n);



[endsect]



[section:size mutable_buffers_1::size]


['Inherited from mutable_buffer.]

[indexterm2 boost_asio.indexterm.mutable_buffers_1.size..size..mutable_buffers_1] 
Get the size of the memory range. 


  std::size_t size() const;



[endsect]



[section:value_type mutable_buffers_1::value_type]

[indexterm2 boost_asio.indexterm.mutable_buffers_1.value_type..value_type..mutable_buffers_1] 
The type for each element in the list of buffers. 


  typedef mutable_buffer value_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.mutable_buffer [*mutable_buffer]] [constructor]]
    [Construct an empty buffer. 
     [hr]
     Construct a buffer to represent a given memory range. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_buffer.operator_plus_ [*operator+]]]
    [Create a new modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link boost_asio.reference.mutable_buffer `mutable_buffer`] class provides a safe representation of a buffer that can be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   boost::asio::mutable_buffer b1 = ...;
   std::size_t s1 = b1.size();
   unsigned char* p1 = static_cast<unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 


[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:mutable_registered_buffer mutable_registered_buffer]

[indexterm1 boost_asio.indexterm.mutable_registered_buffer..mutable_registered_buffer]


Holds a registered buffer over modifiable data. 


  class mutable_registered_buffer


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_registered_buffer.buffer [*buffer]]]
    [Get the underlying mutable buffer. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_registered_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_registered_buffer.id [*id]]]
    [Get the registered buffer identifier. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_registered_buffer.mutable_registered_buffer [*mutable_registered_buffer]] [constructor]]
    [Default constructor creates an invalid registered buffer. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_registered_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_registered_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_registered_buffer.operator_plus_ [*operator+]]]
    [Create a new modifiable registered buffer that is offset from the start of another. 

     Create a new modifiable buffer that is offset from the start of another. ]
  ]
  
]

Satisfies the `MutableBufferSequence` type requirements. 

[heading Requirements]

['Header: ][^boost/asio/registered_buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:buffer mutable_registered_buffer::buffer]

[indexterm2 boost_asio.indexterm.mutable_registered_buffer.buffer..buffer..mutable_registered_buffer] 
Get the underlying mutable buffer. 


  const mutable_buffer & buffer() const;



[endsect]



[section:data mutable_registered_buffer::data]

[indexterm2 boost_asio.indexterm.mutable_registered_buffer.data..data..mutable_registered_buffer] 
Get a pointer to the beginning of the memory range. 


  void * data() const;



[heading Return Value]
      
`buffer().data()`. 




[endsect]



[section:id mutable_registered_buffer::id]

[indexterm2 boost_asio.indexterm.mutable_registered_buffer.id..id..mutable_registered_buffer] 
Get the registered buffer identifier. 


  const registered_buffer_id & id() const;



[endsect]



[section:mutable_registered_buffer mutable_registered_buffer::mutable_registered_buffer]

[indexterm2 boost_asio.indexterm.mutable_registered_buffer.mutable_registered_buffer..mutable_registered_buffer..mutable_registered_buffer] 
Default constructor creates an invalid registered buffer. 


  mutable_registered_buffer();



[endsect]


[section:operator_plus_ mutable_registered_buffer::operator+]

[indexterm2 boost_asio.indexterm.mutable_registered_buffer.operator_plus_..operator+..mutable_registered_buffer] 
Create a new modifiable registered buffer that is offset from the start of another. 


  mutable_registered_buffer ``[link boost_asio.reference.mutable_registered_buffer.operator_plus_.overload1 operator+]``(
      const mutable_registered_buffer & b,
      std::size_t n);
  ``  [''''&raquo;''' [link boost_asio.reference.mutable_registered_buffer.operator_plus_.overload1 more...]]``


Create a new modifiable buffer that is offset from the start of another. 


  mutable_registered_buffer ``[link boost_asio.reference.mutable_registered_buffer.operator_plus_.overload2 operator+]``(
      std::size_t n,
      const mutable_registered_buffer & b);
  ``  [''''&raquo;''' [link boost_asio.reference.mutable_registered_buffer.operator_plus_.overload2 more...]]``


[section:overload1 mutable_registered_buffer::operator+ (1 of 2 overloads)]


Create a new modifiable registered buffer that is offset from the start of another. 


  mutable_registered_buffer operator+(
      const mutable_registered_buffer & b,
      std::size_t n);



[endsect]



[section:overload2 mutable_registered_buffer::operator+ (2 of 2 overloads)]


Create a new modifiable buffer that is offset from the start of another. 


  mutable_registered_buffer operator+(
      std::size_t n,
      const mutable_registered_buffer & b);



[endsect]


[endsect]


[section:operator_plus__eq_ mutable_registered_buffer::operator+=]

[indexterm2 boost_asio.indexterm.mutable_registered_buffer.operator_plus__eq_..operator+=..mutable_registered_buffer] 
Move the start of the buffer by the specified number of bytes. 


  mutable_registered_buffer & operator+=(
      std::size_t n);



[endsect]



[section:size mutable_registered_buffer::size]

[indexterm2 boost_asio.indexterm.mutable_registered_buffer.size..size..mutable_registered_buffer] 
Get the size of the memory range. 


  std::size_t size() const;



[heading Return Value]
      
`buffer().size()`. 




[endsect]



[endsect]

[section:null_buffers null_buffers]

[indexterm1 boost_asio.indexterm.null_buffers..null_buffers]


(Deprecated: Use the socket/descriptor wait() and async\_wait() member functions.) An implementation of both the ConstBufferSequence and MutableBufferSequence concepts to represent a null buffer sequence. 


  class null_buffers


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.null_buffers.const_iterator [*const_iterator]]]
    [A random-access iterator type that may be used to read elements. ]
  
  ]

  [

    [[link boost_asio.reference.null_buffers.value_type [*value_type]]]
    [The type for each element in the list of buffers. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.null_buffers.begin [*begin]]]
    [Get a random-access iterator to the first element. ]
  ]
  
  [
    [[link boost_asio.reference.null_buffers.end [*end]]]
    [Get a random-access iterator for one past the last element. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:begin null_buffers::begin]

[indexterm2 boost_asio.indexterm.null_buffers.begin..begin..null_buffers] 
Get a random-access iterator to the first element. 


  const_iterator begin() const;



[endsect]



[section:const_iterator null_buffers::const_iterator]

[indexterm2 boost_asio.indexterm.null_buffers.const_iterator..const_iterator..null_buffers] 
A random-access iterator type that may be used to read elements. 


  typedef const mutable_buffer * const_iterator;



[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:end null_buffers::end]

[indexterm2 boost_asio.indexterm.null_buffers.end..end..null_buffers] 
Get a random-access iterator for one past the last element. 


  const_iterator end() const;



[endsect]



[section:value_type null_buffers::value_type]

[indexterm2 boost_asio.indexterm.null_buffers.value_type..value_type..null_buffers] 
The type for each element in the list of buffers. 


  typedef mutable_buffer value_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_buffer.data [*data]]]
    [Get a pointer to the beginning of the memory range. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.mutable_buffer [*mutable_buffer]] [constructor]]
    [Construct an empty buffer. 
     [hr]
     Construct a buffer to represent a given memory range. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.operator_plus__eq_ [*operator+=]]]
    [Move the start of the buffer by the specified number of bytes. ]
  ]
  
  [
    [[link boost_asio.reference.mutable_buffer.size [*size]]]
    [Get the size of the memory range. ]
  ]
  
]

[heading Related Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.mutable_buffer.operator_plus_ [*operator+]]]
    [Create a new modifiable buffer that is offset from the start of another. ]
  ]
  
]

The [link boost_asio.reference.mutable_buffer `mutable_buffer`] class provides a safe representation of a buffer that can be modified. It does not own the underlying data, and so is cheap to copy or assign.


[heading Accessing Buffer Contents]
  


The contents of a buffer may be accessed using the `data()` and `size()` member functions:



   boost::asio::mutable_buffer b1 = ...;
   std::size_t s1 = b1.size();
   unsigned char* p1 = static_cast<unsigned char*>(b1.data());




The `data()` member function permits violations of type safety, so uses of it in application code should be carefully considered. 


[heading Requirements]

['Header: ][^boost/asio/buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]


[section:placeholders__bytes_transferred placeholders::bytes_transferred]

[indexterm1 boost_asio.indexterm.placeholders__bytes_transferred..placeholders::bytes_transferred] 
An argument placeholder, for use with boost::bind(), that corresponds to the bytes\_transferred argument of a handler for asynchronous functions such as `boost::asio::basic_stream_socket::async_write_some` or `boost::asio::async_write`. 


  unspecified bytes_transferred;


[heading Requirements]

['Header: ][^boost/asio/placeholders.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:placeholders__endpoint placeholders::endpoint]

[indexterm1 boost_asio.indexterm.placeholders__endpoint..placeholders::endpoint] 
An argument placeholder, for use with boost::bind(), that corresponds to the results argument of a handler for asynchronous functions such as `boost::asio::async_connect`. 


  unspecified endpoint;


[heading Requirements]

['Header: ][^boost/asio/placeholders.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:placeholders__error placeholders::error]

[indexterm1 boost_asio.indexterm.placeholders__error..placeholders::error] 
An argument placeholder, for use with boost::bind(), that corresponds to the error argument of a handler for any of the asynchronous functions. 


  unspecified error;


[heading Requirements]

['Header: ][^boost/asio/placeholders.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:placeholders__iterator placeholders::iterator]

[indexterm1 boost_asio.indexterm.placeholders__iterator..placeholders::iterator] 
An argument placeholder, for use with boost::bind(), that corresponds to the iterator argument of a handler for asynchronous functions such as `boost::asio::async_connect`. 


  unspecified iterator;


[heading Requirements]

['Header: ][^boost/asio/placeholders.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:placeholders__results placeholders::results]

[indexterm1 boost_asio.indexterm.placeholders__results..placeholders::results] 
An argument placeholder, for use with boost::bind(), that corresponds to the results argument of a handler for asynchronous functions such as boost::asio::basic\_resolver::async\_resolve. 


  unspecified results;


[heading Requirements]

['Header: ][^boost/asio/placeholders.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:placeholders__signal_number placeholders::signal_number]

[indexterm1 boost_asio.indexterm.placeholders__signal_number..placeholders::signal_number] 
An argument placeholder, for use with boost::bind(), that corresponds to the signal\_number argument of a handler for asynchronous functions such as `boost::asio::signal_set::async_wait`. 


  unspecified signal_number;


[heading Requirements]

['Header: ][^boost/asio/placeholders.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:posix__basic_descriptor posix::basic_descriptor]

[indexterm1 boost_asio.indexterm.posix__basic_descriptor..posix::basic_descriptor]


Provides POSIX descriptor functionality. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  class basic_descriptor :
    public posix::descriptor_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.posix__basic_descriptor__rebind_executor [*rebind_executor]]]
    [Rebinds the descriptor type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.lowest_layer_type [*lowest_layer_type]]]
    [A descriptor is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.native_handle_type [*native_handle_type]]]
    [The native representation of a descriptor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_descriptor.assign [*assign]]]
    [Assign an existing native descriptor to the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.async_wait [*async_wait]]]
    [Asynchronously wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.basic_descriptor [*basic_descriptor]] [constructor]]
    [Construct a descriptor without opening it. 
     [hr]
     Construct a descriptor on an existing native descriptor. 
     [hr]
     Move-construct a descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.close [*close]]]
    [Close the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.io_control [*io_control]]]
    [Perform an IO control command on the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.is_open [*is_open]]]
    [Determine whether the descriptor is open. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.native_handle [*native_handle]]]
    [Get the native descriptor representation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native descriptor implementation. 
     [hr]
     Sets the non-blocking mode of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the descriptor. 
     [hr]
     Sets the non-blocking mode of the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.operator_eq_ [*operator=]]]
    [Move-assign a descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.release [*release]]]
    [Release ownership of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.wait [*wait]]]
    [Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_descriptor._basic_descriptor [*~basic_descriptor]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

The [link boost_asio.reference.posix__basic_descriptor `posix::basic_descriptor`] class template provides the ability to wrap a POSIX descriptor.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/posix/basic_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign posix::basic_descriptor::assign]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.assign..assign..posix::basic_descriptor] 
Assign an existing native descriptor to the descriptor. 


  void ``[link boost_asio.reference.posix__basic_descriptor.assign.overload1 assign]``(
      const native_handle_type & native_descriptor);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.assign.overload1 more...]]``

  void ``[link boost_asio.reference.posix__basic_descriptor.assign.overload2 assign]``(
      const native_handle_type & native_descriptor,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.assign.overload2 more...]]``


[section:overload1 posix::basic_descriptor::assign (1 of 2 overloads)]


Assign an existing native descriptor to the descriptor. 


  void assign(
      const native_handle_type & native_descriptor);



[endsect]



[section:overload2 posix::basic_descriptor::assign (2 of 2 overloads)]


Assign an existing native descriptor to the descriptor. 


  void assign(
      const native_handle_type & native_descriptor,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_wait posix::basic_descriptor::async_wait]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.async_wait..async_wait..posix::basic_descriptor] 
Asynchronously wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. 


  template<
      typename ``[link boost_asio.reference.WaitHandler WaitHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_wait(
      wait_type w,
      WaitHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to perform an asynchronous wait for a descriptor to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired descriptor state.]]

[[handler][The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void wait_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Wait succeeded.
     }
   }

   ...

   boost::asio::posix::stream_descriptor descriptor(my_context);
   ...
   descriptor.async_wait(
       boost::asio::posix::stream_descriptor::wait_read,
       wait_handler);





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:basic_descriptor posix::basic_descriptor::basic_descriptor]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.basic_descriptor..basic_descriptor..posix::basic_descriptor] 
Construct a descriptor without opening it. 


  explicit ``[link boost_asio.reference.posix__basic_descriptor.basic_descriptor.overload1 basic_descriptor]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.basic_descriptor.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.posix__basic_descriptor.basic_descriptor.overload2 basic_descriptor]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.basic_descriptor.overload2 more...]]``


Construct a descriptor on an existing native descriptor. 


  ``[link boost_asio.reference.posix__basic_descriptor.basic_descriptor.overload3 basic_descriptor]``(
      const executor_type & ex,
      const native_handle_type & native_descriptor);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.basic_descriptor.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.posix__basic_descriptor.basic_descriptor.overload4 basic_descriptor]``(
      ExecutionContext & context,
      const native_handle_type & native_descriptor,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.basic_descriptor.overload4 more...]]``


Move-construct a descriptor from another. 


  ``[link boost_asio.reference.posix__basic_descriptor.basic_descriptor.overload5 basic_descriptor]``(
      basic_descriptor && other);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.basic_descriptor.overload5 more...]]``


[section:overload1 posix::basic_descriptor::basic_descriptor (1 of 5 overloads)]


Construct a descriptor without opening it. 


  basic_descriptor(
      const executor_type & ex);


This constructor creates a descriptor without opening it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the descriptor will use, by default, to dispatch handlers for any asynchronous operations performed on the descriptor. ]]

]




[endsect]



[section:overload2 posix::basic_descriptor::basic_descriptor (2 of 5 overloads)]


Construct a descriptor without opening it. 


  template<
      typename ExecutionContext>
  basic_descriptor(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates a descriptor without opening it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the descriptor will use, by default, to dispatch handlers for any asynchronous operations performed on the descriptor. ]]

]




[endsect]



[section:overload3 posix::basic_descriptor::basic_descriptor (3 of 5 overloads)]


Construct a descriptor on an existing native descriptor. 


  basic_descriptor(
      const executor_type & ex,
      const native_handle_type & native_descriptor);


This constructor creates a descriptor object to hold an existing native descriptor.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the descriptor will use, by default, to dispatch handlers for any asynchronous operations performed on the descriptor.]]

[[native_descriptor][A native descriptor.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 posix::basic_descriptor::basic_descriptor (4 of 5 overloads)]


Construct a descriptor on an existing native descriptor. 


  template<
      typename ExecutionContext>
  basic_descriptor(
      ExecutionContext & context,
      const native_handle_type & native_descriptor,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a descriptor object to hold an existing native descriptor.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the descriptor will use, by default, to dispatch handlers for any asynchronous operations performed on the descriptor.]]

[[native_descriptor][A native descriptor.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 posix::basic_descriptor::basic_descriptor (5 of 5 overloads)]


Move-construct a descriptor from another. 


  basic_descriptor(
      basic_descriptor && other);


This constructor moves a descriptor from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other descriptor object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_descriptor(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:bytes_readable posix::basic_descriptor::bytes_readable]


['Inherited from posix::descriptor_base.]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.bytes_readable..bytes_readable..posix::basic_descriptor] 
IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   boost::asio::posix::stream_descriptor descriptor(my_context);
   ...
   boost::asio::descriptor_base::bytes_readable command(true);
   descriptor.io_control(command);
   std::size_t bytes_readable = command.get();







[heading Requirements]

['Header: ][^boost/asio/posix/basic_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:cancel posix::basic_descriptor::cancel]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.cancel..cancel..posix::basic_descriptor] 
Cancel all asynchronous operations associated with the descriptor. 


  void ``[link boost_asio.reference.posix__basic_descriptor.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.posix__basic_descriptor.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.cancel.overload2 more...]]``


[section:overload1 posix::basic_descriptor::cancel (1 of 2 overloads)]


Cancel all asynchronous operations associated with the descriptor. 


  void cancel();


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 posix::basic_descriptor::cancel (2 of 2 overloads)]


Cancel all asynchronous operations associated with the descriptor. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:close posix::basic_descriptor::close]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.close..close..posix::basic_descriptor] 
Close the descriptor. 


  void ``[link boost_asio.reference.posix__basic_descriptor.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.close.overload1 more...]]``

  void ``[link boost_asio.reference.posix__basic_descriptor.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.close.overload2 more...]]``


[section:overload1 posix::basic_descriptor::close (1 of 2 overloads)]


Close the descriptor. 


  void close();


This function is used to close the descriptor. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed. ]]

]




[endsect]



[section:overload2 posix::basic_descriptor::close (2 of 2 overloads)]


Close the descriptor. 


  void close(
      boost::system::error_code & ec);


This function is used to close the descriptor. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed. ]]

]




[endsect]


[endsect]


[section:executor_type posix::basic_descriptor::executor_type]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.executor_type..executor_type..posix::basic_descriptor] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/posix/basic_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor posix::basic_descriptor::get_executor]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.get_executor..get_executor..posix::basic_descriptor] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:io_control posix::basic_descriptor::io_control]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.io_control..io_control..posix::basic_descriptor] 
Perform an IO control command on the descriptor. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.posix__basic_descriptor.io_control.overload1 io_control]``(
      IoControlCommand & command);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.io_control.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.posix__basic_descriptor.io_control.overload2 io_control]``(
      IoControlCommand & command,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.io_control.overload2 more...]]``


[section:overload1 posix::basic_descriptor::io_control (1 of 2 overloads)]


Perform an IO control command on the descriptor. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command);


This function is used to execute an IO control command on the descriptor.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the descriptor.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::posix::stream_descriptor descriptor(my_context);
   ...
   boost::asio::posix::stream_descriptor::bytes_readable command;
   descriptor.io_control(command);
   std::size_t bytes_readable = command.get();







[endsect]



[section:overload2 posix::basic_descriptor::io_control (2 of 2 overloads)]


Perform an IO control command on the descriptor. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command,
      boost::system::error_code & ec);


This function is used to execute an IO control command on the descriptor.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the descriptor.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::posix::stream_descriptor descriptor(my_context);
   ...
   boost::asio::posix::stream_descriptor::bytes_readable command;
   boost::system::error_code ec;
   descriptor.io_control(command, ec);
   if (ec)
   {
     // An error occurred.
   }
   std::size_t bytes_readable = command.get();







[endsect]


[endsect]


[section:is_open posix::basic_descriptor::is_open]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.is_open..is_open..posix::basic_descriptor] 
Determine whether the descriptor is open. 


  bool is_open() const;



[endsect]


[section:lowest_layer posix::basic_descriptor::lowest_layer]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.lowest_layer..lowest_layer..posix::basic_descriptor] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.posix__basic_descriptor.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.posix__basic_descriptor.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.lowest_layer.overload2 more...]]``


[section:overload1 posix::basic_descriptor::lowest_layer (1 of 2 overloads)]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since a descriptor cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 posix::basic_descriptor::lowest_layer (2 of 2 overloads)]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since a descriptor cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type posix::basic_descriptor::lowest_layer_type]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.lowest_layer_type..lowest_layer_type..posix::basic_descriptor] 
A descriptor is always the lowest layer. 


  typedef basic_descriptor lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.posix__basic_descriptor__rebind_executor [*rebind_executor]]]
    [Rebinds the descriptor type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.lowest_layer_type [*lowest_layer_type]]]
    [A descriptor is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.native_handle_type [*native_handle_type]]]
    [The native representation of a descriptor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_descriptor.assign [*assign]]]
    [Assign an existing native descriptor to the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.async_wait [*async_wait]]]
    [Asynchronously wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.basic_descriptor [*basic_descriptor]] [constructor]]
    [Construct a descriptor without opening it. 
     [hr]
     Construct a descriptor on an existing native descriptor. 
     [hr]
     Move-construct a descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.close [*close]]]
    [Close the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.io_control [*io_control]]]
    [Perform an IO control command on the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.is_open [*is_open]]]
    [Determine whether the descriptor is open. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.native_handle [*native_handle]]]
    [Get the native descriptor representation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native descriptor implementation. 
     [hr]
     Sets the non-blocking mode of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the descriptor. 
     [hr]
     Sets the non-blocking mode of the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.operator_eq_ [*operator=]]]
    [Move-assign a descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.release [*release]]]
    [Release ownership of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.wait [*wait]]]
    [Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_descriptor._basic_descriptor [*~basic_descriptor]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

The [link boost_asio.reference.posix__basic_descriptor `posix::basic_descriptor`] class template provides the ability to wrap a POSIX descriptor.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/posix/basic_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:native_handle posix::basic_descriptor::native_handle]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.native_handle..native_handle..posix::basic_descriptor] 
Get the native descriptor representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the descriptor. This is intended to allow access to native descriptor functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type posix::basic_descriptor::native_handle_type]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.native_handle_type..native_handle_type..posix::basic_descriptor] 
The native representation of a descriptor. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/posix/basic_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:native_non_blocking posix::basic_descriptor::native_non_blocking]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.native_non_blocking..native_non_blocking..posix::basic_descriptor] 
Gets the non-blocking mode of the native descriptor implementation. 


  bool ``[link boost_asio.reference.posix__basic_descriptor.native_non_blocking.overload1 native_non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.native_non_blocking.overload1 more...]]``


Sets the non-blocking mode of the native descriptor implementation. 


  void ``[link boost_asio.reference.posix__basic_descriptor.native_non_blocking.overload2 native_non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.native_non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.posix__basic_descriptor.native_non_blocking.overload3 native_non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.native_non_blocking.overload3 more...]]``


[section:overload1 posix::basic_descriptor::native_non_blocking (1 of 3 overloads)]


Gets the non-blocking mode of the native descriptor implementation. 


  bool native_non_blocking() const;


This function is used to retrieve the non-blocking mode of the underlying native descriptor. This mode has no effect on the behaviour of the descriptor object's synchronous operations.


[heading Return Value]
      
`true` if the underlying descriptor is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).


[heading Remarks]
      
The current non-blocking mode is cached by the descriptor object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native descriptor. 




[endsect]



[section:overload2 posix::basic_descriptor::native_non_blocking (2 of 3 overloads)]


Sets the non-blocking mode of the native descriptor implementation. 


  void native_non_blocking(
      bool mode);


This function is used to modify the non-blocking mode of the underlying native descriptor. It has no effect on the behaviour of the descriptor object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying descriptor is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense. ]]

]




[endsect]



[section:overload3 posix::basic_descriptor::native_non_blocking (3 of 3 overloads)]


Sets the non-blocking mode of the native descriptor implementation. 


  void native_non_blocking(
      bool mode,
      boost::system::error_code & ec);


This function is used to modify the non-blocking mode of the underlying native descriptor. It has no effect on the behaviour of the descriptor object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying descriptor is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense. ]]

]




[endsect]


[endsect]

[section:non_blocking posix::basic_descriptor::non_blocking]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.non_blocking..non_blocking..posix::basic_descriptor] 
Gets the non-blocking mode of the descriptor. 


  bool ``[link boost_asio.reference.posix__basic_descriptor.non_blocking.overload1 non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.non_blocking.overload1 more...]]``


Sets the non-blocking mode of the descriptor. 


  void ``[link boost_asio.reference.posix__basic_descriptor.non_blocking.overload2 non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.posix__basic_descriptor.non_blocking.overload3 non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.non_blocking.overload3 more...]]``


[section:overload1 posix::basic_descriptor::non_blocking (1 of 3 overloads)]


Gets the non-blocking mode of the descriptor. 


  bool non_blocking() const;



[heading Return Value]
      
`true` if the descriptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload2 posix::basic_descriptor::non_blocking (2 of 3 overloads)]


Sets the non-blocking mode of the descriptor. 


  void non_blocking(
      bool mode);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the descriptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload3 posix::basic_descriptor::non_blocking (3 of 3 overloads)]


Sets the non-blocking mode of the descriptor. 


  void non_blocking(
      bool mode,
      boost::system::error_code & ec);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the descriptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]


[endsect]


[section:operator_eq_ posix::basic_descriptor::operator=]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.operator_eq_..operator=..posix::basic_descriptor] 
Move-assign a descriptor from another. 


  basic_descriptor & operator=(
      basic_descriptor && other);


This assignment operator moves a descriptor from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other descriptor object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_descriptor(const executor_type&)` constructor. 




[endsect]



[section:release posix::basic_descriptor::release]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.release..release..posix::basic_descriptor] 
Release ownership of the native descriptor implementation. 


  native_handle_type release();


This function may be used to obtain the underlying representation of the descriptor. After calling this function, `is_open()` returns false. The caller is responsible for closing the descriptor.

All outstanding asynchronous read or write operations will finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. 


[endsect]


[section:wait posix::basic_descriptor::wait]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.wait..wait..posix::basic_descriptor] 
Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. 


  void ``[link boost_asio.reference.posix__basic_descriptor.wait.overload1 wait]``(
      wait_type w);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.wait.overload1 more...]]``

  void ``[link boost_asio.reference.posix__basic_descriptor.wait.overload2 wait]``(
      wait_type w,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_descriptor.wait.overload2 more...]]``


[section:overload1 posix::basic_descriptor::wait (1 of 2 overloads)]


Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w);


This function is used to perform a blocking wait for a descriptor to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired descriptor state.]]

]


[heading Example]
  
Waiting for a descriptor to become readable. 

   boost::asio::posix::stream_descriptor descriptor(my_context);
   ...
   descriptor.wait(boost::asio::posix::stream_descriptor::wait_read);







[endsect]



[section:overload2 posix::basic_descriptor::wait (2 of 2 overloads)]


Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w,
      boost::system::error_code & ec);


This function is used to perform a blocking wait for a descriptor to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired descriptor state.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Waiting for a descriptor to become readable. 

   boost::asio::posix::stream_descriptor descriptor(my_context);
   ...
   boost::system::error_code ec;
   descriptor.wait(boost::asio::posix::stream_descriptor::wait_read, ec);







[endsect]


[endsect]


[section:wait_type posix::basic_descriptor::wait_type]


['Inherited from posix::descriptor_base.]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.wait_type..wait_type..posix::basic_descriptor] 
Wait types. 

  enum wait_type

[indexterm2 boost_asio.indexterm.posix__basic_descriptor.wait_type.wait_read..wait_read..posix::basic_descriptor]
[indexterm2 boost_asio.indexterm.posix__basic_descriptor.wait_type.wait_write..wait_write..posix::basic_descriptor]
[indexterm2 boost_asio.indexterm.posix__basic_descriptor.wait_type.wait_error..wait_error..posix::basic_descriptor]

[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a descriptor to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a descriptor to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a descriptor to have error conditions pending. ]
  ]

]


For use with `descriptor::wait()` and `descriptor::async_wait()`. 


[endsect]



[section:_basic_descriptor posix::basic_descriptor::~basic_descriptor]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor._basic_descriptor..~basic_descriptor..posix::basic_descriptor] 
Protected destructor to prevent deletion through this type. 


  ~basic_descriptor();


This function destroys the descriptor, cancelling any outstanding asynchronous wait operations associated with the descriptor as if by calling `cancel`. 


[endsect]



[endsect]

[section:posix__basic_descriptor__rebind_executor posix::basic_descriptor::rebind_executor]

[indexterm1 boost_asio.indexterm.posix__basic_descriptor__rebind_executor..posix::basic_descriptor::rebind_executor]


Rebinds the descriptor type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.posix__basic_descriptor__rebind_executor.other [*other]]]
    [The descriptor type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/posix/basic_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other posix::basic_descriptor::rebind_executor::other]

[indexterm2 boost_asio.indexterm.posix__basic_descriptor__rebind_executor.other..other..posix::basic_descriptor::rebind_executor] 
The descriptor type when rebound to the specified executor. 


  typedef basic_descriptor< Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.posix__basic_descriptor__rebind_executor [*rebind_executor]]]
    [Rebinds the descriptor type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.lowest_layer_type [*lowest_layer_type]]]
    [A descriptor is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.native_handle_type [*native_handle_type]]]
    [The native representation of a descriptor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_descriptor.assign [*assign]]]
    [Assign an existing native descriptor to the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.async_wait [*async_wait]]]
    [Asynchronously wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.basic_descriptor [*basic_descriptor]] [constructor]]
    [Construct a descriptor without opening it. 
     [hr]
     Construct a descriptor on an existing native descriptor. 
     [hr]
     Move-construct a descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.close [*close]]]
    [Close the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.io_control [*io_control]]]
    [Perform an IO control command on the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.is_open [*is_open]]]
    [Determine whether the descriptor is open. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.native_handle [*native_handle]]]
    [Get the native descriptor representation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native descriptor implementation. 
     [hr]
     Sets the non-blocking mode of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the descriptor. 
     [hr]
     Sets the non-blocking mode of the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.operator_eq_ [*operator=]]]
    [Move-assign a descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.release [*release]]]
    [Release ownership of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.wait [*wait]]]
    [Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_descriptor._basic_descriptor [*~basic_descriptor]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

The [link boost_asio.reference.posix__basic_descriptor `posix::basic_descriptor`] class template provides the ability to wrap a POSIX descriptor.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/posix/basic_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:posix__basic_stream_descriptor posix::basic_stream_descriptor]

[indexterm1 boost_asio.indexterm.posix__basic_stream_descriptor..posix::basic_stream_descriptor]


Provides stream-oriented descriptor functionality. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  class basic_stream_descriptor :
    public posix::basic_descriptor< Executor >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor__rebind_executor [*rebind_executor]]]
    [Rebinds the descriptor type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.lowest_layer_type [*lowest_layer_type]]]
    [A descriptor is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.native_handle_type [*native_handle_type]]]
    [The native representation of a descriptor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.assign [*assign]]]
    [Assign an existing native descriptor to the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.async_wait [*async_wait]]]
    [Asynchronously wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.basic_stream_descriptor [*basic_stream_descriptor]] [constructor]]
    [Construct a stream descriptor without opening it. 
     [hr]
     Construct a stream descriptor on an existing native descriptor. 
     [hr]
     Move-construct a stream descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.close [*close]]]
    [Close the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.io_control [*io_control]]]
    [Perform an IO control command on the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.is_open [*is_open]]]
    [Determine whether the descriptor is open. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.native_handle [*native_handle]]]
    [Get the native descriptor representation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native descriptor implementation. 
     [hr]
     Sets the non-blocking mode of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the descriptor. 
     [hr]
     Sets the non-blocking mode of the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.operator_eq_ [*operator=]]]
    [Move-assign a stream descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.read_some [*read_some]]]
    [Read some data from the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.release [*release]]]
    [Release ownership of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.wait [*wait]]]
    [Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.write_some [*write_some]]]
    [Write some data to the descriptor. ]
  ]
  
]

The [link boost_asio.reference.posix__basic_stream_descriptor `posix::basic_stream_descriptor`] class template provides asynchronous and blocking stream-oriented descriptor functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `read_some` and `write_some` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single descriptor object. Other synchronous operations, such as `close`, are not thread safe.




[heading Requirements]

['Header: ][^boost/asio/posix/basic_stream_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign posix::basic_stream_descriptor::assign]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.assign..assign..posix::basic_stream_descriptor] 
Assign an existing native descriptor to the descriptor. 


  void ``[link boost_asio.reference.posix__basic_stream_descriptor.assign.overload1 assign]``(
      const native_handle_type & native_descriptor);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.assign.overload1 more...]]``

  void ``[link boost_asio.reference.posix__basic_stream_descriptor.assign.overload2 assign]``(
      const native_handle_type & native_descriptor,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.assign.overload2 more...]]``


[section:overload1 posix::basic_stream_descriptor::assign (1 of 2 overloads)]


['Inherited from posix::basic_descriptor.]


Assign an existing native descriptor to the descriptor. 


  void assign(
      const native_handle_type & native_descriptor);



[endsect]



[section:overload2 posix::basic_stream_descriptor::assign (2 of 2 overloads)]


['Inherited from posix::basic_descriptor.]


Assign an existing native descriptor to the descriptor. 


  void assign(
      const native_handle_type & native_descriptor,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_read_some posix::basic_stream_descriptor::async_read_some]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.async_read_some..async_read_some..posix::basic_stream_descriptor] 
Start an asynchronous read. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_some(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data from the stream descriptor. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes read.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The read operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.async_read `async_read`]  function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   descriptor.async_read_some(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:async_wait posix::basic_stream_descriptor::async_wait]


['Inherited from posix::basic_descriptor.]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.async_wait..async_wait..posix::basic_stream_descriptor] 
Asynchronously wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. 


  template<
      typename ``[link boost_asio.reference.WaitHandler WaitHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_wait(
      wait_type w,
      WaitHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to perform an asynchronous wait for a descriptor to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired descriptor state.]]

[[handler][The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Example]
  


   void wait_handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Wait succeeded.
     }
   }

   ...

   boost::asio::posix::stream_descriptor descriptor(my_context);
   ...
   descriptor.async_wait(
       boost::asio::posix::stream_descriptor::wait_read,
       wait_handler);





[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:async_write_some posix::basic_stream_descriptor::async_write_some]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.async_write_some..async_write_some..posix::basic_stream_descriptor] 
Start an asynchronous write. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_some(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write data to the stream descriptor. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the descriptor. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes written.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The write operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.async_write `async_write`]  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   descriptor.async_write_some(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:basic_stream_descriptor posix::basic_stream_descriptor::basic_stream_descriptor]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.basic_stream_descriptor..basic_stream_descriptor..posix::basic_stream_descriptor] 
Construct a stream descriptor without opening it. 


  explicit ``[link boost_asio.reference.posix__basic_stream_descriptor.basic_stream_descriptor.overload1 basic_stream_descriptor]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.basic_stream_descriptor.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.posix__basic_stream_descriptor.basic_stream_descriptor.overload2 basic_stream_descriptor]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.basic_stream_descriptor.overload2 more...]]``


Construct a stream descriptor on an existing native descriptor. 


  ``[link boost_asio.reference.posix__basic_stream_descriptor.basic_stream_descriptor.overload3 basic_stream_descriptor]``(
      const executor_type & ex,
      const native_handle_type & native_descriptor);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.basic_stream_descriptor.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.posix__basic_stream_descriptor.basic_stream_descriptor.overload4 basic_stream_descriptor]``(
      ExecutionContext & context,
      const native_handle_type & native_descriptor,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.basic_stream_descriptor.overload4 more...]]``


Move-construct a stream descriptor from another. 


  ``[link boost_asio.reference.posix__basic_stream_descriptor.basic_stream_descriptor.overload5 basic_stream_descriptor]``(
      basic_stream_descriptor && other);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.basic_stream_descriptor.overload5 more...]]``


[section:overload1 posix::basic_stream_descriptor::basic_stream_descriptor (1 of 5 overloads)]


Construct a stream descriptor without opening it. 


  basic_stream_descriptor(
      const executor_type & ex);


This constructor creates a stream descriptor without opening it. The descriptor needs to be opened and then connected or accepted before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the descriptor will use, by default, to dispatch handlers for any asynchronous operations performed on the descriptor. ]]

]




[endsect]



[section:overload2 posix::basic_stream_descriptor::basic_stream_descriptor (2 of 5 overloads)]


Construct a stream descriptor without opening it. 


  template<
      typename ExecutionContext>
  basic_stream_descriptor(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates a stream descriptor without opening it. The descriptor needs to be opened and then connected or accepted before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the descriptor will use, by default, to dispatch handlers for any asynchronous operations performed on the descriptor. ]]

]




[endsect]



[section:overload3 posix::basic_stream_descriptor::basic_stream_descriptor (3 of 5 overloads)]


Construct a stream descriptor on an existing native descriptor. 


  basic_stream_descriptor(
      const executor_type & ex,
      const native_handle_type & native_descriptor);


This constructor creates a stream descriptor object to hold an existing native descriptor.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the descriptor will use, by default, to dispatch handlers for any asynchronous operations performed on the descriptor.]]

[[native_descriptor][The new underlying descriptor implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 posix::basic_stream_descriptor::basic_stream_descriptor (4 of 5 overloads)]


Construct a stream descriptor on an existing native descriptor. 


  template<
      typename ExecutionContext>
  basic_stream_descriptor(
      ExecutionContext & context,
      const native_handle_type & native_descriptor,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a stream descriptor object to hold an existing native descriptor.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the descriptor will use, by default, to dispatch handlers for any asynchronous operations performed on the descriptor.]]

[[native_descriptor][The new underlying descriptor implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 posix::basic_stream_descriptor::basic_stream_descriptor (5 of 5 overloads)]


Move-construct a stream descriptor from another. 


  basic_stream_descriptor(
      basic_stream_descriptor && other);


This constructor moves a stream descriptor from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other stream descriptor object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_descriptor(const executor_type&)` constructor. 




[endsect]


[endsect]


[section:bytes_readable posix::basic_stream_descriptor::bytes_readable]


['Inherited from posix::descriptor_base.]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.bytes_readable..bytes_readable..posix::basic_stream_descriptor] 
IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   boost::asio::posix::stream_descriptor descriptor(my_context);
   ...
   boost::asio::descriptor_base::bytes_readable command(true);
   descriptor.io_control(command);
   std::size_t bytes_readable = command.get();







[heading Requirements]

['Header: ][^boost/asio/posix/basic_stream_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:cancel posix::basic_stream_descriptor::cancel]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.cancel..cancel..posix::basic_stream_descriptor] 
Cancel all asynchronous operations associated with the descriptor. 


  void ``[link boost_asio.reference.posix__basic_stream_descriptor.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.posix__basic_stream_descriptor.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.cancel.overload2 more...]]``


[section:overload1 posix::basic_stream_descriptor::cancel (1 of 2 overloads)]


['Inherited from posix::basic_descriptor.]


Cancel all asynchronous operations associated with the descriptor. 


  void cancel();


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 posix::basic_stream_descriptor::cancel (2 of 2 overloads)]


['Inherited from posix::basic_descriptor.]


Cancel all asynchronous operations associated with the descriptor. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:close posix::basic_stream_descriptor::close]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.close..close..posix::basic_stream_descriptor] 
Close the descriptor. 


  void ``[link boost_asio.reference.posix__basic_stream_descriptor.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.close.overload1 more...]]``

  void ``[link boost_asio.reference.posix__basic_stream_descriptor.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.close.overload2 more...]]``


[section:overload1 posix::basic_stream_descriptor::close (1 of 2 overloads)]


['Inherited from posix::basic_descriptor.]


Close the descriptor. 


  void close();


This function is used to close the descriptor. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed. ]]

]




[endsect]



[section:overload2 posix::basic_stream_descriptor::close (2 of 2 overloads)]


['Inherited from posix::basic_descriptor.]


Close the descriptor. 


  void close(
      boost::system::error_code & ec);


This function is used to close the descriptor. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed. ]]

]




[endsect]


[endsect]


[section:executor_type posix::basic_stream_descriptor::executor_type]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.executor_type..executor_type..posix::basic_stream_descriptor] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/posix/basic_stream_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor posix::basic_stream_descriptor::get_executor]


['Inherited from posix::basic_descriptor.]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.get_executor..get_executor..posix::basic_stream_descriptor] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]


[section:io_control posix::basic_stream_descriptor::io_control]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.io_control..io_control..posix::basic_stream_descriptor] 
Perform an IO control command on the descriptor. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.posix__basic_stream_descriptor.io_control.overload1 io_control]``(
      IoControlCommand & command);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.io_control.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void ``[link boost_asio.reference.posix__basic_stream_descriptor.io_control.overload2 io_control]``(
      IoControlCommand & command,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.io_control.overload2 more...]]``


[section:overload1 posix::basic_stream_descriptor::io_control (1 of 2 overloads)]


['Inherited from posix::basic_descriptor.]


Perform an IO control command on the descriptor. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command);


This function is used to execute an IO control command on the descriptor.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the descriptor.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::posix::stream_descriptor descriptor(my_context);
   ...
   boost::asio::posix::stream_descriptor::bytes_readable command;
   descriptor.io_control(command);
   std::size_t bytes_readable = command.get();







[endsect]



[section:overload2 posix::basic_stream_descriptor::io_control (2 of 2 overloads)]


['Inherited from posix::basic_descriptor.]


Perform an IO control command on the descriptor. 


  template<
      typename ``[link boost_asio.reference.IoControlCommand IoControlCommand]``>
  void io_control(
      IoControlCommand & command,
      boost::system::error_code & ec);


This function is used to execute an IO control command on the descriptor.


[heading Parameters]
    

[variablelist
  
[[command][The IO control command to be performed on the descriptor.]]

[[ec][Set to indicate what error occurred, if any.]]

]



[heading Example]
  
Getting the number of bytes ready to read: 

   boost::asio::posix::stream_descriptor descriptor(my_context);
   ...
   boost::asio::posix::stream_descriptor::bytes_readable command;
   boost::system::error_code ec;
   descriptor.io_control(command, ec);
   if (ec)
   {
     // An error occurred.
   }
   std::size_t bytes_readable = command.get();







[endsect]


[endsect]


[section:is_open posix::basic_stream_descriptor::is_open]


['Inherited from posix::basic_descriptor.]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.is_open..is_open..posix::basic_stream_descriptor] 
Determine whether the descriptor is open. 


  bool is_open() const;



[endsect]


[section:lowest_layer posix::basic_stream_descriptor::lowest_layer]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.lowest_layer..lowest_layer..posix::basic_stream_descriptor] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.posix__basic_stream_descriptor.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.posix__basic_stream_descriptor.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.lowest_layer.overload2 more...]]``


[section:overload1 posix::basic_stream_descriptor::lowest_layer (1 of 2 overloads)]


['Inherited from posix::basic_descriptor.]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since a descriptor cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 posix::basic_stream_descriptor::lowest_layer (2 of 2 overloads)]


['Inherited from posix::basic_descriptor.]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since a descriptor cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type posix::basic_stream_descriptor::lowest_layer_type]


['Inherited from posix::basic_descriptor.]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.lowest_layer_type..lowest_layer_type..posix::basic_stream_descriptor] 
A descriptor is always the lowest layer. 


  typedef basic_descriptor lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.posix__basic_descriptor__rebind_executor [*rebind_executor]]]
    [Rebinds the descriptor type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.lowest_layer_type [*lowest_layer_type]]]
    [A descriptor is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.native_handle_type [*native_handle_type]]]
    [The native representation of a descriptor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_descriptor.assign [*assign]]]
    [Assign an existing native descriptor to the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.async_wait [*async_wait]]]
    [Asynchronously wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.basic_descriptor [*basic_descriptor]] [constructor]]
    [Construct a descriptor without opening it. 
     [hr]
     Construct a descriptor on an existing native descriptor. 
     [hr]
     Move-construct a descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.close [*close]]]
    [Close the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.io_control [*io_control]]]
    [Perform an IO control command on the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.is_open [*is_open]]]
    [Determine whether the descriptor is open. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.native_handle [*native_handle]]]
    [Get the native descriptor representation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native descriptor implementation. 
     [hr]
     Sets the non-blocking mode of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the descriptor. 
     [hr]
     Sets the non-blocking mode of the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.operator_eq_ [*operator=]]]
    [Move-assign a descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.release [*release]]]
    [Release ownership of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.wait [*wait]]]
    [Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_descriptor._basic_descriptor [*~basic_descriptor]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

The [link boost_asio.reference.posix__basic_descriptor `posix::basic_descriptor`] class template provides the ability to wrap a POSIX descriptor.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/posix/basic_stream_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:native_handle posix::basic_stream_descriptor::native_handle]


['Inherited from posix::basic_descriptor.]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.native_handle..native_handle..posix::basic_stream_descriptor] 
Get the native descriptor representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the descriptor. This is intended to allow access to native descriptor functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type posix::basic_stream_descriptor::native_handle_type]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.native_handle_type..native_handle_type..posix::basic_stream_descriptor] 
The native representation of a descriptor. 


  typedef basic_descriptor< Executor >::native_handle_type native_handle_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.posix__basic_descriptor__rebind_executor [*rebind_executor]]]
    [Rebinds the descriptor type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.lowest_layer_type [*lowest_layer_type]]]
    [A descriptor is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.native_handle_type [*native_handle_type]]]
    [The native representation of a descriptor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_descriptor.assign [*assign]]]
    [Assign an existing native descriptor to the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.async_wait [*async_wait]]]
    [Asynchronously wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.basic_descriptor [*basic_descriptor]] [constructor]]
    [Construct a descriptor without opening it. 
     [hr]
     Construct a descriptor on an existing native descriptor. 
     [hr]
     Move-construct a descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.close [*close]]]
    [Close the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.io_control [*io_control]]]
    [Perform an IO control command on the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.is_open [*is_open]]]
    [Determine whether the descriptor is open. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.native_handle [*native_handle]]]
    [Get the native descriptor representation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native descriptor implementation. 
     [hr]
     Sets the non-blocking mode of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the descriptor. 
     [hr]
     Sets the non-blocking mode of the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.operator_eq_ [*operator=]]]
    [Move-assign a descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.release [*release]]]
    [Release ownership of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.wait [*wait]]]
    [Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_descriptor._basic_descriptor [*~basic_descriptor]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

The [link boost_asio.reference.posix__basic_descriptor `posix::basic_descriptor`] class template provides the ability to wrap a POSIX descriptor.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/posix/basic_stream_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:native_non_blocking posix::basic_stream_descriptor::native_non_blocking]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.native_non_blocking..native_non_blocking..posix::basic_stream_descriptor] 
Gets the non-blocking mode of the native descriptor implementation. 


  bool ``[link boost_asio.reference.posix__basic_stream_descriptor.native_non_blocking.overload1 native_non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.native_non_blocking.overload1 more...]]``


Sets the non-blocking mode of the native descriptor implementation. 


  void ``[link boost_asio.reference.posix__basic_stream_descriptor.native_non_blocking.overload2 native_non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.native_non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.posix__basic_stream_descriptor.native_non_blocking.overload3 native_non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.native_non_blocking.overload3 more...]]``


[section:overload1 posix::basic_stream_descriptor::native_non_blocking (1 of 3 overloads)]


['Inherited from posix::basic_descriptor.]


Gets the non-blocking mode of the native descriptor implementation. 


  bool native_non_blocking() const;


This function is used to retrieve the non-blocking mode of the underlying native descriptor. This mode has no effect on the behaviour of the descriptor object's synchronous operations.


[heading Return Value]
      
`true` if the underlying descriptor is in non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).


[heading Remarks]
      
The current non-blocking mode is cached by the descriptor object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native descriptor. 




[endsect]



[section:overload2 posix::basic_stream_descriptor::native_non_blocking (2 of 3 overloads)]


['Inherited from posix::basic_descriptor.]


Sets the non-blocking mode of the native descriptor implementation. 


  void native_non_blocking(
      bool mode);


This function is used to modify the non-blocking mode of the underlying native descriptor. It has no effect on the behaviour of the descriptor object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying descriptor is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense. ]]

]




[endsect]



[section:overload3 posix::basic_stream_descriptor::native_non_blocking (3 of 3 overloads)]


['Inherited from posix::basic_descriptor.]


Sets the non-blocking mode of the native descriptor implementation. 


  void native_non_blocking(
      bool mode,
      boost::system::error_code & ec);


This function is used to modify the non-blocking mode of the underlying native descriptor. It has no effect on the behaviour of the descriptor object's synchronous operations.


[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the underlying descriptor is put into non-blocking mode and direct system calls may fail with `boost::asio::error::would_block` (or the equivalent system error).]]

[[ec][Set to indicate what error occurred, if any. If the `mode` is `false`, but the current value of `non_blocking()` is `true`, this function fails with `boost::asio::error::invalid_argument`, as the combination does not make sense. ]]

]




[endsect]


[endsect]

[section:non_blocking posix::basic_stream_descriptor::non_blocking]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.non_blocking..non_blocking..posix::basic_stream_descriptor] 
Gets the non-blocking mode of the descriptor. 


  bool ``[link boost_asio.reference.posix__basic_stream_descriptor.non_blocking.overload1 non_blocking]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.non_blocking.overload1 more...]]``


Sets the non-blocking mode of the descriptor. 


  void ``[link boost_asio.reference.posix__basic_stream_descriptor.non_blocking.overload2 non_blocking]``(
      bool mode);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.non_blocking.overload2 more...]]``

  void ``[link boost_asio.reference.posix__basic_stream_descriptor.non_blocking.overload3 non_blocking]``(
      bool mode,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.non_blocking.overload3 more...]]``


[section:overload1 posix::basic_stream_descriptor::non_blocking (1 of 3 overloads)]


['Inherited from posix::basic_descriptor.]


Gets the non-blocking mode of the descriptor. 


  bool non_blocking() const;



[heading Return Value]
      
`true` if the descriptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload2 posix::basic_stream_descriptor::non_blocking (2 of 3 overloads)]


['Inherited from posix::basic_descriptor.]


Sets the non-blocking mode of the descriptor. 


  void non_blocking(
      bool mode);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the descriptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]



[section:overload3 posix::basic_stream_descriptor::non_blocking (3 of 3 overloads)]


['Inherited from posix::basic_descriptor.]


Sets the non-blocking mode of the descriptor. 


  void non_blocking(
      bool mode,
      boost::system::error_code & ec);



[heading Parameters]
    

[variablelist
  
[[mode][If `true`, the descriptor's synchronous operations will fail with `boost::asio::error::would_block` if they are unable to perform the requested operation immediately. If `false`, synchronous operations will block until complete.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error `boost::asio::error::would_block`. 




[endsect]


[endsect]


[section:operator_eq_ posix::basic_stream_descriptor::operator=]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.operator_eq_..operator=..posix::basic_stream_descriptor] 
Move-assign a stream descriptor from another. 


  basic_stream_descriptor & operator=(
      basic_stream_descriptor && other);


This assignment operator moves a stream descriptor from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other stream descriptor object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_descriptor(const executor_type&)` constructor. 




[endsect]


[section:read_some posix::basic_stream_descriptor::read_some]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.read_some..read_some..posix::basic_stream_descriptor] 
Read some data from the descriptor. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.posix__basic_stream_descriptor.read_some.overload1 read_some]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.read_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.posix__basic_stream_descriptor.read_some.overload2 read_some]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.read_some.overload2 more...]]``


[section:overload1 posix::basic_stream_descriptor::read_some (1 of 2 overloads)]


Read some data from the descriptor. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers);


This function is used to read data from the stream descriptor. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes read.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   descriptor.read_some(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 posix::basic_stream_descriptor::read_some (2 of 2 overloads)]


Read some data from the descriptor. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to read data from the stream descriptor. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. Returns 0 if an error occurred.


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]


[endsect]


[section:release posix::basic_stream_descriptor::release]


['Inherited from posix::basic_descriptor.]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.release..release..posix::basic_stream_descriptor] 
Release ownership of the native descriptor implementation. 


  native_handle_type release();


This function may be used to obtain the underlying representation of the descriptor. After calling this function, `is_open()` returns false. The caller is responsible for closing the descriptor.

All outstanding asynchronous read or write operations will finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error. 


[endsect]


[section:wait posix::basic_stream_descriptor::wait]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.wait..wait..posix::basic_stream_descriptor] 
Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. 


  void ``[link boost_asio.reference.posix__basic_stream_descriptor.wait.overload1 wait]``(
      wait_type w);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.wait.overload1 more...]]``

  void ``[link boost_asio.reference.posix__basic_stream_descriptor.wait.overload2 wait]``(
      wait_type w,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.wait.overload2 more...]]``


[section:overload1 posix::basic_stream_descriptor::wait (1 of 2 overloads)]


['Inherited from posix::basic_descriptor.]


Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w);


This function is used to perform a blocking wait for a descriptor to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired descriptor state.]]

]


[heading Example]
  
Waiting for a descriptor to become readable. 

   boost::asio::posix::stream_descriptor descriptor(my_context);
   ...
   descriptor.wait(boost::asio::posix::stream_descriptor::wait_read);







[endsect]



[section:overload2 posix::basic_stream_descriptor::wait (2 of 2 overloads)]


['Inherited from posix::basic_descriptor.]


Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. 


  void wait(
      wait_type w,
      boost::system::error_code & ec);


This function is used to perform a blocking wait for a descriptor to enter a ready to read, write or error condition state.


[heading Parameters]
    

[variablelist
  
[[w][Specifies the desired descriptor state.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Example]
  
Waiting for a descriptor to become readable. 

   boost::asio::posix::stream_descriptor descriptor(my_context);
   ...
   boost::system::error_code ec;
   descriptor.wait(boost::asio::posix::stream_descriptor::wait_read, ec);







[endsect]


[endsect]


[section:wait_type posix::basic_stream_descriptor::wait_type]


['Inherited from posix::descriptor_base.]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.wait_type..wait_type..posix::basic_stream_descriptor] 
Wait types. 

  enum wait_type

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.wait_type.wait_read..wait_read..posix::basic_stream_descriptor]
[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.wait_type.wait_write..wait_write..posix::basic_stream_descriptor]
[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.wait_type.wait_error..wait_error..posix::basic_stream_descriptor]

[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a descriptor to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a descriptor to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a descriptor to have error conditions pending. ]
  ]

]


For use with `descriptor::wait()` and `descriptor::async_wait()`. 


[endsect]


[section:write_some posix::basic_stream_descriptor::write_some]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor.write_some..write_some..posix::basic_stream_descriptor] 
Write some data to the descriptor. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.posix__basic_stream_descriptor.write_some.overload1 write_some]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.write_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.posix__basic_stream_descriptor.write_some.overload2 write_some]``(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.posix__basic_stream_descriptor.write_some.overload2 more...]]``


[section:overload1 posix::basic_stream_descriptor::write_some (1 of 2 overloads)]


Write some data to the descriptor. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers);


This function is used to write data to the stream descriptor. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the descriptor.]]

]


[heading Return Value]
      
The number of bytes written.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   descriptor.write_some(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 posix::basic_stream_descriptor::write_some (2 of 2 overloads)]


Write some data to the descriptor. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to write data to the stream descriptor. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the descriptor.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. Returns 0 if an error occurred.


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]


[endsect]


[endsect]

[section:posix__basic_stream_descriptor__rebind_executor posix::basic_stream_descriptor::rebind_executor]

[indexterm1 boost_asio.indexterm.posix__basic_stream_descriptor__rebind_executor..posix::basic_stream_descriptor::rebind_executor]


Rebinds the descriptor type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor__rebind_executor.other [*other]]]
    [The descriptor type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/posix/basic_stream_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other posix::basic_stream_descriptor::rebind_executor::other]

[indexterm2 boost_asio.indexterm.posix__basic_stream_descriptor__rebind_executor.other..other..posix::basic_stream_descriptor::rebind_executor] 
The descriptor type when rebound to the specified executor. 


  typedef basic_stream_descriptor< Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor__rebind_executor [*rebind_executor]]]
    [Rebinds the descriptor type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.lowest_layer_type [*lowest_layer_type]]]
    [A descriptor is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.native_handle_type [*native_handle_type]]]
    [The native representation of a descriptor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.assign [*assign]]]
    [Assign an existing native descriptor to the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.async_wait [*async_wait]]]
    [Asynchronously wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.basic_stream_descriptor [*basic_stream_descriptor]] [constructor]]
    [Construct a stream descriptor without opening it. 
     [hr]
     Construct a stream descriptor on an existing native descriptor. 
     [hr]
     Move-construct a stream descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.close [*close]]]
    [Close the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.io_control [*io_control]]]
    [Perform an IO control command on the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.is_open [*is_open]]]
    [Determine whether the descriptor is open. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.native_handle [*native_handle]]]
    [Get the native descriptor representation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native descriptor implementation. 
     [hr]
     Sets the non-blocking mode of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the descriptor. 
     [hr]
     Sets the non-blocking mode of the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.operator_eq_ [*operator=]]]
    [Move-assign a stream descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.read_some [*read_some]]]
    [Read some data from the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.release [*release]]]
    [Release ownership of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.wait [*wait]]]
    [Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.write_some [*write_some]]]
    [Write some data to the descriptor. ]
  ]
  
]

The [link boost_asio.reference.posix__basic_stream_descriptor `posix::basic_stream_descriptor`] class template provides asynchronous and blocking stream-oriented descriptor functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `read_some` and `write_some` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single descriptor object. Other synchronous operations, such as `close`, are not thread safe.





[heading Requirements]

['Header: ][^boost/asio/posix/basic_stream_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]


[section:posix__descriptor posix::descriptor]

[indexterm1 boost_asio.indexterm.posix__descriptor..posix::descriptor] 
Typedef for the typical usage of [link boost_asio.reference.posix__basic_descriptor `posix::basic_descriptor`]. 


  typedef basic_descriptor descriptor;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.posix__basic_descriptor__rebind_executor [*rebind_executor]]]
    [Rebinds the descriptor type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.lowest_layer_type [*lowest_layer_type]]]
    [A descriptor is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.native_handle_type [*native_handle_type]]]
    [The native representation of a descriptor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_descriptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_descriptor.assign [*assign]]]
    [Assign an existing native descriptor to the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.async_wait [*async_wait]]]
    [Asynchronously wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.basic_descriptor [*basic_descriptor]] [constructor]]
    [Construct a descriptor without opening it. 
     [hr]
     Construct a descriptor on an existing native descriptor. 
     [hr]
     Move-construct a descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.close [*close]]]
    [Close the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.io_control [*io_control]]]
    [Perform an IO control command on the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.is_open [*is_open]]]
    [Determine whether the descriptor is open. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.native_handle [*native_handle]]]
    [Get the native descriptor representation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native descriptor implementation. 
     [hr]
     Sets the non-blocking mode of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the descriptor. 
     [hr]
     Sets the non-blocking mode of the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.operator_eq_ [*operator=]]]
    [Move-assign a descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.release [*release]]]
    [Release ownership of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_descriptor.wait [*wait]]]
    [Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_descriptor._basic_descriptor [*~basic_descriptor]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

The [link boost_asio.reference.posix__basic_descriptor `posix::basic_descriptor`] class template provides the ability to wrap a POSIX descriptor.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/posix/descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:posix__descriptor_base posix::descriptor_base]

[indexterm1 boost_asio.indexterm.posix__descriptor_base..posix::descriptor_base]


The [link boost_asio.reference.posix__descriptor_base `posix::descriptor_base`] class is used as a base for the descriptor class as a place to define the associated IO control commands. 


  class descriptor_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.posix__descriptor_base.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.posix__descriptor_base.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__descriptor_base._descriptor_base [*~descriptor_base]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/posix/descriptor_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:bytes_readable posix::descriptor_base::bytes_readable]

[indexterm2 boost_asio.indexterm.posix__descriptor_base.bytes_readable..bytes_readable..posix::descriptor_base] 
IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   boost::asio::posix::stream_descriptor descriptor(my_context);
   ...
   boost::asio::descriptor_base::bytes_readable command(true);
   descriptor.io_control(command);
   std::size_t bytes_readable = command.get();







[heading Requirements]

['Header: ][^boost/asio/posix/descriptor_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:wait_type posix::descriptor_base::wait_type]

[indexterm2 boost_asio.indexterm.posix__descriptor_base.wait_type..wait_type..posix::descriptor_base] 
Wait types. 

  enum wait_type

[indexterm2 boost_asio.indexterm.posix__descriptor_base.wait_type.wait_read..wait_read..posix::descriptor_base]
[indexterm2 boost_asio.indexterm.posix__descriptor_base.wait_type.wait_write..wait_write..posix::descriptor_base]
[indexterm2 boost_asio.indexterm.posix__descriptor_base.wait_type.wait_error..wait_error..posix::descriptor_base]

[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a descriptor to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a descriptor to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a descriptor to have error conditions pending. ]
  ]

]


For use with `descriptor::wait()` and `descriptor::async_wait()`. 


[endsect]



[section:_descriptor_base posix::descriptor_base::~descriptor_base]

[indexterm2 boost_asio.indexterm.posix__descriptor_base._descriptor_base..~descriptor_base..posix::descriptor_base] 
Protected destructor to prevent deletion through this type. 


  ~descriptor_base();



[endsect]



[endsect]


[section:posix__stream_descriptor posix::stream_descriptor]

[indexterm1 boost_asio.indexterm.posix__stream_descriptor..posix::stream_descriptor] 
Typedef for the typical usage of a stream-oriented descriptor. 


  typedef basic_stream_descriptor stream_descriptor;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor__rebind_executor [*rebind_executor]]]
    [Rebinds the descriptor type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.lowest_layer_type [*lowest_layer_type]]]
    [A descriptor is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.native_handle_type [*native_handle_type]]]
    [The native representation of a descriptor. ]
  
  ]

  [

    [[link boost_asio.reference.posix__basic_stream_descriptor.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.assign [*assign]]]
    [Assign an existing native descriptor to the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.async_wait [*async_wait]]]
    [Asynchronously wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.basic_stream_descriptor [*basic_stream_descriptor]] [constructor]]
    [Construct a stream descriptor without opening it. 
     [hr]
     Construct a stream descriptor on an existing native descriptor. 
     [hr]
     Move-construct a stream descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.close [*close]]]
    [Close the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.io_control [*io_control]]]
    [Perform an IO control command on the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.is_open [*is_open]]]
    [Determine whether the descriptor is open. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.native_handle [*native_handle]]]
    [Get the native descriptor representation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.native_non_blocking [*native_non_blocking]]]
    [Gets the non-blocking mode of the native descriptor implementation. 
     [hr]
     Sets the non-blocking mode of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.non_blocking [*non_blocking]]]
    [Gets the non-blocking mode of the descriptor. 
     [hr]
     Sets the non-blocking mode of the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.operator_eq_ [*operator=]]]
    [Move-assign a stream descriptor from another. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.read_some [*read_some]]]
    [Read some data from the descriptor. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.release [*release]]]
    [Release ownership of the native descriptor implementation. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.wait [*wait]]]
    [Wait for the descriptor to become ready to read, ready to write, or to have pending error conditions. ]
  ]
  
  [
    [[link boost_asio.reference.posix__basic_stream_descriptor.write_some [*write_some]]]
    [Write some data to the descriptor. ]
  ]
  
]

The [link boost_asio.reference.posix__basic_stream_descriptor `posix::basic_stream_descriptor`] class template provides asynchronous and blocking stream-oriented descriptor functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `read_some` and `write_some` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single descriptor object. Other synchronous operations, such as `close`, are not thread safe.





[heading Requirements]

['Header: ][^boost/asio/posix/stream_descriptor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:post post]

[indexterm1 boost_asio.indexterm.post..post] 
Submits a completion token or function object for execution. 

  template<
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.post.overload1 post]``(
      CompletionToken && token);
  ``  [''''&raquo;''' [link boost_asio.reference.post.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.post.overload2 post]``(
      const Executor & ex,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< execution::is_executor< Executor >::value||is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.post.overload2 more...]]``

  template<
      typename ExecutionContext,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.post.overload3 post]``(
      ExecutionContext & ctx,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.post.overload3 more...]]``

[heading Requirements]

['Header: ][^boost/asio/post.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 post (1 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename CompletionToken>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` post(
      CompletionToken && token);


This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from `post()`.

The use of `post()`, rather than [link boost_asio.reference.defer `defer`] , indicates the caller's preference that the function object be eagerly queued for execution.

This function has the following effects:


* Constructs a function object handler of type `Handler`, initialized with `handler(forward<CompletionToken>(token))`.


* Constructs an object `result` of type `async_result<Handler>`, initializing the object as `result(handler)`.


* Obtains the handler's associated executor object `ex` by performing `get_associated_executor(handler)`.


* Obtains the handler's associated allocator object `alloc` by performing `get_associated_allocator(handler)`.


* Performs `ex.post(std::move(handler), alloc)`.


* Returns `result.get()`. 




[endsect]



[section:overload2 post (2 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` post(
      const Executor & ex,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< execution::is_executor< Executor >::value||is_executor< Executor >::value >::type  = 0);


This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from `post()`.

The use of `post()`, rather than [link boost_asio.reference.defer `defer`] , indicates the caller's preference that the function object be eagerly queued for execution.

This function has the following effects:


* Constructs a function object handler of type `Handler`, initialized with `handler(forward<CompletionToken>(token))`.


* Constructs an object `result` of type `async_result<Handler>`, initializing the object as `result(handler)`.


* Obtains the handler's associated executor object `ex1` by performing `get_associated_executor(handler)`.


* Creates a work object `w` by performing `make_work(ex1)`.


* Obtains the handler's associated allocator object `alloc` by performing `get_associated_allocator(handler)`.


* Constructs a function object `f` with a function call operator that performs `ex1.dispatch(std::move(handler), alloc)` followed by `w.reset()`.


* Performs `Executor(ex).post(std::move(f), alloc)`.


* Returns `result.get()`. 




[endsect]



[section:overload3 post (3 of 3 overloads)]


Submits a completion token or function object for execution. 


  template<
      typename ExecutionContext,
      typename CompletionToken = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` post(
      ExecutionContext & ctx,
      CompletionToken && token = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[heading Return Value]
      
`post(ctx.get_executor(), forward<CompletionToken>(token))`. 




[endsect]


[endsect]


[section:prefer prefer]

[indexterm1 boost_asio.indexterm.prefer..prefer] 
A customisation point that attempts to apply a property to an object. 


  constexpr unspecified prefer = unspecified;


The name `prefer` denotes a customisation point object. The expression `boost::asio::prefer(E, P0, Pn...)` for some subexpressions `E` and `P0`, and where `Pn...` represents `N` subexpressions (where `N` is 0 or more, and with types `T = decay_t<decltype(E)>` and `Prop0 = decay_t<decltype(P0)>`) is expression-equivalent to:


* If `is_applicable_property_v<T, Prop0> && Prop0::is_preferable` is not a well-formed constant expression with value `true`, `boost::asio::prefer(E, P0, Pn...)` is ill-formed.


* Otherwise, `E` if `N == 0` and the expression `Prop0::template static_query_v<T> == Prop0::value()` is a well-formed constant expression with value `true`.


* Otherwise, `(E).require(P0)` if `N == 0` and the expression `(E).require(P0)` is a valid expression.


* Otherwise, `require(E, P0)` if `N == 0` and the expression `require(E, P0)` is a valid expression with overload resolution performed in a context that does not include the declaration of the `require` customization point object.


* Otherwise, `(E).prefer(P0)` if `N == 0` and the expression `(E).prefer(P0)` is a valid expression.


* Otherwise, `prefer(E, P0)` if `N == 0` and the expression `prefer(E, P0)` is a valid expression with overload resolution performed in a context that does not include the declaration of the `prefer` customization point object.


* Otherwise, `E` if `N == 0`.


* Otherwise, `boost::asio::prefer(boost::asio::prefer(E, P0), Pn...)` if `N > 0` and the expression `boost::asio::prefer(boost::asio::prefer(E, P0), Pn...)` is a valid expression.


* Otherwise, `boost::asio::prefer(E, P0, Pn...)` is ill-formed. 



[heading Requirements]

['Header: ][^boost/asio/prefer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:prefer_result prefer_result]

[indexterm1 boost_asio.indexterm.prefer_result..prefer_result]


A type trait that determines the result type of a `prefer` expression. 


  template<
      typename T,
      typename... Properties>
  struct prefer_result


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.prefer_result.type [*type]]]
    [The result of the prefer expression. ]
  
  ]

]

Class template `prefer_result` is a trait that determines the result type of the expression `boost::asio::prefer(std::declval<T>(), std::declval<Properties>()...)`. 

[heading Requirements]

['Header: ][^boost/asio/prefer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:type prefer_result::type]

[indexterm2 boost_asio.indexterm.prefer_result.type..type..prefer_result] 
The result of the `prefer` expression. 


  typedef automatically_determined type;



[heading Requirements]

['Header: ][^boost/asio/prefer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]


[section:query query]

[indexterm1 boost_asio.indexterm.query..query] 
A customisation point that queries the value of a property. 


  constexpr unspecified query = unspecified;


The name `query` denotes a customization point object. The expression `boost::asio::query(E, P)` for some subexpressions `E` and `P` (with types `T = decay_t<decltype(E)>` and `Prop = decay_t<decltype(P)>`) is expression-equivalent to:


* If `is_applicable_property_v<T, Prop>` is not a well-formed constant expression with value `true`, `boost::asio::query(E, P)` is ill-formed.


* Otherwise, `Prop::template static_query_v<T>` if the expression `Prop::template static_query_v<T>` is a well-formed constant expression.


* Otherwise, `(E).query(P)` if the expression `(E).query(P)` is well-formed.


* Otherwise, `query(E, P)` if the expression `query(E, P)` is a valid expression with overload resolution performed in a context that does not include the declaration of the `query` customization point object.


* Otherwise, `boost::asio::query(E, P)` is ill-formed. 



[heading Requirements]

['Header: ][^boost/asio/query.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:query_result query_result]

[indexterm1 boost_asio.indexterm.query_result..query_result]


A type trait that determines the result type of a `query` expression. 


  template<
      typename T,
      typename Property>
  struct query_result


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.query_result.type [*type]]]
    [The result of the query expression. ]
  
  ]

]

Class template `query_result` is a trait that determines the result type of the expression `boost::asio::query(std::declval<T>(), std::declval<Property>())`. 

[heading Requirements]

['Header: ][^boost/asio/query.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:type query_result::type]

[indexterm2 boost_asio.indexterm.query_result.type..type..query_result] 
The result of the `query` expression. 


  typedef automatically_determined type;



[heading Requirements]

['Header: ][^boost/asio/query.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]


[section:random_access_file random_access_file]

[indexterm1 boost_asio.indexterm.random_access_file..random_access_file] 
Typedef for the typical usage of a random-access file. 


  typedef basic_random_access_file random_access_file;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_random_access_file__rebind_executor [*rebind_executor]]]
    [Rebinds the file type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_random_access_file.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_random_access_file.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.basic_random_access_file.native_handle_type [*native_handle_type]]]
    [The native representation of a file. ]
  
  ]

  [

    [[link boost_asio.reference.basic_random_access_file.seek_basis [*seek_basis]]]
    [Basis for seeking in a file. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_random_access_file.assign [*assign]]]
    [Assign an existing native file to the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.async_read_some_at [*async_read_some_at]]]
    [Start an asynchronous read at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.async_write_some_at [*async_write_some_at]]]
    [Start an asynchronous write at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.basic_random_access_file [*basic_random_access_file]] [constructor]]
    [Construct a basic_random_access_file without opening it. 
     [hr]
     Construct and open a basic_random_access_file. 
     [hr]
     Construct a basic_random_access_file on an existing native file. 
     [hr]
     Move-construct a basic_random_access_file from another. 
     [hr]
     Move-construct a basic_random_access_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.close [*close]]]
    [Close the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.is_open [*is_open]]]
    [Determine whether the file is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.native_handle [*native_handle]]]
    [Get the native file representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.open [*open]]]
    [Open the file using the specified path. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.operator_eq_ [*operator=]]]
    [Move-assign a basic_random_access_file from another. 
     [hr]
     Move-assign a basic_random_access_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.read_some_at [*read_some_at]]]
    [Read some data from the handle at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.release [*release]]]
    [Release ownership of the underlying native file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.resize [*resize]]]
    [Alter the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.size [*size]]]
    [Get the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.sync_all [*sync_all]]]
    [Synchronise the file to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.sync_data [*sync_data]]]
    [Synchronise the file data to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file.write_some_at [*write_some_at]]]
    [Write some data to the handle at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.basic_random_access_file._basic_random_access_file [*~basic_random_access_file]] [destructor]]
    [Destroys the file. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_random_access_file.append [*append]] [static]]
    [Open the file in append mode. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.create [*create]] [static]]
    [Create the file if it does not exist. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.exclusive [*exclusive]] [static]]
    [Ensure a new file is created. Must be combined with create. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.read_only [*read_only]] [static]]
    [Open the file for reading. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.read_write [*read_write]] [static]]
    [Open the file for reading and writing. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.truncate [*truncate]] [static]]
    [Open the file with any existing contents truncated. ]
  ]

  [
    [[link boost_asio.reference.basic_random_access_file.write_only [*write_only]] [static]]
    [Open the file for writing. ]
  ]

]

The [link boost_asio.reference.basic_random_access_file `basic_random_access_file`] class template provides asynchronous and blocking random-access file functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.

Synchronous `read_some_at` and `write_some_at` operations are thread safe with respect to each other, if the underlying operating system calls are also thread safe. This means that it is permitted to perform concurrent calls to these synchronous operations on a single file object. Other synchronous operations, such as `open` or `close`, are not thread safe. 


[heading Requirements]

['Header: ][^boost/asio/random_access_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:read read]

[indexterm1 boost_asio.indexterm.read..read] 
The `read` function is a composed operation that reads a certain amount of data from a stream before returning. 


Attempt to read a certain amount of data from a stream before returning. 

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.read.overload1 read]``(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.read.overload2 read]``(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.read.overload3 read]``(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.read.overload4 read]``(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload4 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t ``[link boost_asio.reference.read.overload5 read]``(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload5 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t ``[link boost_asio.reference.read.overload6 read]``(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload6 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.read.overload7 read]``(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload7 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.read.overload8 read]``(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload8 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.read.overload9 read]``(
      SyncReadStream & s,
      basic_streambuf< Allocator > & b);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload9 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.read.overload10 read]``(
      SyncReadStream & s,
      basic_streambuf< Allocator > & b,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload10 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.read.overload11 read]``(
      SyncReadStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload11 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.read.overload12 read]``(
      SyncReadStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload12 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t ``[link boost_asio.reference.read.overload13 read]``(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload13 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t ``[link boost_asio.reference.read.overload14 read]``(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload14 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.read.overload15 read]``(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload15 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.read.overload16 read]``(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read.overload16 more...]]``

[heading Requirements]

['Header: ][^boost/asio/read.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 read (1 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::read(s, boost::asio::buffer(data, size)); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::read(
       s, buffers,
       boost::asio::transfer_all()); 







[endsect]



[section:overload2 read (2 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::read(s, boost::asio::buffer(data, size), ec); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::read(
       s, buffers,
       boost::asio::transfer_all(), ec); 







[endsect]



[section:overload3 read (3 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t read(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read\_some function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::read(s, boost::asio::buffer(data, size),
       boost::asio::transfer_at_least(32)); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload4 read (4 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t read(
      SyncReadStream & s,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec,
      typename constraint< is_mutable_buffer_sequence< MutableBufferSequence >::value >::type  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read\_some function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]



[section:overload5 read (5 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t read(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::read(
       s, buffers,
       boost::asio::transfer_all()); 







[endsect]



[section:overload6 read (6 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t read(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffer is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::read(
       s, buffers,
       boost::asio::transfer_all(), ec); 







[endsect]



[section:overload7 read (7 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t read(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read\_some function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 read (8 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t read(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read\_some function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]



[section:overload9 read (9 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t read(
      SyncReadStream & s,
      basic_streambuf< Allocator > & b);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffer is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::read(
       s, b,
       boost::asio::transfer_all()); 







[endsect]



[section:overload10 read (10 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t read(
      SyncReadStream & s,
      basic_streambuf< Allocator > & b,
      boost::system::error_code & ec);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffer is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::read(
       s, b,
       boost::asio::transfer_all(), ec); 







[endsect]



[section:overload11 read (11 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t read(
      SyncReadStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffer is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read\_some function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload12 read (12 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t read(
      SyncReadStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      boost::system::error_code & ec);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffer is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read\_some function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]



[section:overload13 read (13 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t read(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::read(
       s, buffers,
       boost::asio::transfer_all()); 







[endsect]



[section:overload14 read (14 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t read(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The supplied buffer is full (that is, it has reached maximum size).


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::read(
       s, buffers,
       boost::asio::transfer_all(), ec); 







[endsect]



[section:overload15 read (15 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t read(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read\_some function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload16 read (16 of 16 overloads)]


Attempt to read a certain amount of data from a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t read(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:


* The specified dynamic buffer sequence is full (that is, it has reached maximum size).


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's read\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's read\_some function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]


[endsect]

[section:read_at read_at]

[indexterm1 boost_asio.indexterm.read_at..read_at] 
The `read_at` function is a composed operation that reads a certain amount of data at the specified offset before returning. 


Attempt to read a certain amount of data at the specified offset before returning. 

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.read_at.overload1 read_at]``(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.read_at.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.read_at.overload2 read_at]``(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.read_at.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.read_at.overload3 read_at]``(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition);
  ``  [''''&raquo;''' [link boost_asio.reference.read_at.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.read_at.overload4 read_at]``(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.read_at.overload4 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.read_at.overload5 read_at]``(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b);
  ``  [''''&raquo;''' [link boost_asio.reference.read_at.overload5 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.read_at.overload6 read_at]``(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.read_at.overload6 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.read_at.overload7 read_at]``(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition);
  ``  [''''&raquo;''' [link boost_asio.reference.read_at.overload7 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.read_at.overload8 read_at]``(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.read_at.overload8 more...]]``

[heading Requirements]

['Header: ][^boost/asio/read_at.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 read_at (1 of 8 overloads)]


Attempt to read a certain amount of data at the specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_at(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers);


This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::read_at(d, 42, boost::asio::buffer(data, size)); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::read_at(
       d, 42, buffers,
       boost::asio::transfer_all()); 







[endsect]



[section:overload2 read_at (2 of 8 overloads)]


Attempt to read a certain amount of data at the specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_at(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::read_at(d, 42,
       boost::asio::buffer(data, size), ec); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::read_at(
       d, 42, buffers,
       boost::asio::transfer_all(), ec); 







[endsect]



[section:overload3 read_at (3 of 8 overloads)]


Attempt to read a certain amount of data at the specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t read_at(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition);


This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read\_some\_at function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::read_at(d, 42, boost::asio::buffer(data, size),
       boost::asio::transfer_at_least(32)); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload4 read_at (4 of 8 overloads)]


Attempt to read a certain amount of data at the specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t read_at(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      const MutableBufferSequence & buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec);


This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:


* The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the device.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read\_some\_at function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]



[section:overload5 read_at (5 of 8 overloads)]


Attempt to read a certain amount of data at the specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename Allocator>
  std::size_t read_at(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b);


This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::read_at(
       d, 42, b,
       boost::asio::transfer_all()); 







[endsect]



[section:overload6 read_at (6 of 8 overloads)]


Attempt to read a certain amount of data at the specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename Allocator>
  std::size_t read_at(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      boost::system::error_code & ec);


This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::read_at(
       d, 42, b,
       boost::asio::transfer_all(), ec); 







[endsect]



[section:overload7 read_at (7 of 8 overloads)]


Attempt to read a certain amount of data at the specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t read_at(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition);


This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read\_some\_at function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 read_at (8 of 8 overloads)]


Attempt to read a certain amount of data at the specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessReadDevice SyncRandomAccessReadDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t read_at(
      SyncRandomAccessReadDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      boost::system::error_code & ec);


This function is used to read a certain number of bytes of data from a random access device at the specified offset. The call will block until one of the following conditions is true:


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's read\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device from which the data is to be read. The type must support the SyncRandomAccessReadDevice concept.]]

[[offset][The offset at which the data will be read.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object into which the data will be read.]]

[[completion_condition][The function object to be called to determine whether the read operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest read_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the device's read\_some\_at function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]


[endsect]

[section:read_until read_until]

[indexterm1 boost_asio.indexterm.read_until..read_until] 
The `read_until` function is a composed operation that reads data into a dynamic buffer sequence, or into a streambuf, until it contains a delimiter, matches a regular expression, or a function object indicates a match. 


Read data into a dynamic buffer sequence until it contains a specified delimiter. 

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t ``[link boost_asio.reference.read_until.overload1 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      char delim,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t ``[link boost_asio.reference.read_until.overload2 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      char delim,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t ``[link boost_asio.reference.read_until.overload3 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      string_view delim,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t ``[link boost_asio.reference.read_until.overload4 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      string_view delim,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload4 more...]]``

Read data into a dynamic buffer sequence until some part of the data it contains matches a regular expression. 

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t ``[link boost_asio.reference.read_until.overload5 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      const boost::regex & expr,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload5 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t ``[link boost_asio.reference.read_until.overload6 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      const boost::regex & expr,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload6 more...]]``

Read data into a dynamic buffer sequence until a function object indicates a match. 

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename MatchCondition>
  std::size_t ``[link boost_asio.reference.read_until.overload7 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      MatchCondition match_condition,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload7 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename MatchCondition>
  std::size_t ``[link boost_asio.reference.read_until.overload8 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      MatchCondition match_condition,
      boost::system::error_code & ec,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload8 more...]]``

Read data into a streambuf until it contains a specified delimiter. 

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.read_until.overload9 read_until]``(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      char delim);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload9 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.read_until.overload10 read_until]``(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      char delim,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload10 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.read_until.overload11 read_until]``(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      string_view delim);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload11 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.read_until.overload12 read_until]``(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      string_view delim,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload12 more...]]``

Read data into a streambuf until some part of the data it contains matches a regular expression. 

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.read_until.overload13 read_until]``(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      const boost::regex & expr);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload13 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.read_until.overload14 read_until]``(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      const boost::regex & expr,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload14 more...]]``

Read data into a streambuf until a function object indicates a match. 

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator,
      typename MatchCondition>
  std::size_t ``[link boost_asio.reference.read_until.overload15 read_until]``(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      MatchCondition match_condition,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload15 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator,
      typename MatchCondition>
  std::size_t ``[link boost_asio.reference.read_until.overload16 read_until]``(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      MatchCondition match_condition,
      boost::system::error_code & ec,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload16 more...]]``

Read data into a dynamic buffer sequence until it contains a specified delimiter. 

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t ``[link boost_asio.reference.read_until.overload17 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      char delim,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload17 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t ``[link boost_asio.reference.read_until.overload18 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      char delim,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload18 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t ``[link boost_asio.reference.read_until.overload19 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      string_view delim,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload19 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t ``[link boost_asio.reference.read_until.overload20 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      string_view delim,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload20 more...]]``

Read data into a dynamic buffer sequence until some part of the data it contains matches a regular expression. 

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t ``[link boost_asio.reference.read_until.overload21 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      const boost::regex & expr,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload21 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t ``[link boost_asio.reference.read_until.overload22 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      const boost::regex & expr,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload22 more...]]``

Read data into a dynamic buffer sequence until a function object indicates a match. 

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename MatchCondition>
  std::size_t ``[link boost_asio.reference.read_until.overload23 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      MatchCondition match_condition,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload23 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename MatchCondition>
  std::size_t ``[link boost_asio.reference.read_until.overload24 read_until]``(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      MatchCondition match_condition,
      boost::system::error_code & ec,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.read_until.overload24 more...]]``

[heading Requirements]

['Header: ][^boost/asio/read_until.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 read_until (1 of 24 overloads)]


Read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      char delim,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[delim][The delimiter character.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine.


[heading Example]
  
To read data into a `std::string` until a newline is encountered: 

   std::string data;
   std::size_t n = boost::asio::read_until(s,
       boost::asio::dynamic_buffer(data), '\n');
   std::string line = data.substr(0, n);
   data.erase(0, n); 


After the `read_until` operation completes successfully, the string `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\n' } 


After the call to `erase`, the remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `read_until` operation. 




[endsect]



[section:overload2 read_until (2 of 24 overloads)]


Read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      char delim,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[delim][The delimiter character.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine. 




[endsect]



[section:overload3 read_until (3 of 24 overloads)]


Read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      string_view delim,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[delim][The delimiter string.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine.


[heading Example]
  
To read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   std::size_t n = boost::asio::read_until(s,
       boost::asio::dynamic_buffer(data), "\r\n");
   std::string line = data.substr(0, n);
   data.erase(0, n); 


After the `read_until` operation completes successfully, the string `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `read_until` operation. 




[endsect]



[section:overload4 read_until (4 of 24 overloads)]


Read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      string_view delim,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[delim][The delimiter string.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine. 




[endsect]



[section:overload5 read_until (5 of 24 overloads)]


Read data into a dynamic buffer sequence until some part of the data it contains matches a regular expression. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      const boost::regex & expr,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:


* A substring of the dynamic buffer sequence's get area matches the regular expression.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains data that matches the regular expression, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][A dynamic buffer sequence into which the data will be read.]]

[[expr][The regular expression.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the substring that matches the regular expression.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine.


[heading Example]
  
To read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   std::size_t n = boost::asio::read_until(s,
       boost::asio::dynamic_buffer(data), boost::regex("\r\n"));
   std::string line = data.substr(0, n);
   data.erase(0, n); 


After the `read_until` operation completes successfully, the string `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `read_until` operation. 




[endsect]



[section:overload6 read_until (6 of 24 overloads)]


Read data into a dynamic buffer sequence until some part of the data it contains matches a regular expression. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      const boost::regex & expr,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:


* A substring of the dynamic buffer sequence's get area matches the regular expression.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains data that matches the regular expression, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][A dynamic buffer sequence into which the data will be read.]]

[[expr][The regular expression.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the substring that matches the regular expression. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine. 




[endsect]



[section:overload7 read_until (7 of 24 overloads)]


Read data into a dynamic buffer sequence until a function object indicates a match. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename MatchCondition>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      MatchCondition match_condition,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:


* The match condition function object returns a std::pair where the second element evaluates to true.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the match condition function object already indicates a match, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][A dynamic buffer sequence into which the data will be read.]]

[[match_condition][The function object to be called to determine whether a match exists. The signature of the function object must be: 
``
   pair<iterator, bool> match_condition(iterator begin, iterator end);
``
where `iterator` represents the type: 
``
   buffers_iterator<typename DynamicBuffer_v1::const_buffers_type>
``
The iterator parameters `begin` and `end` define the range of bytes to be scanned to determine whether there is a match. The `first` member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the `begin` parameter for any subsequent invocation of the match condition. The `second` member of the return value is true if a match has been found, false otherwise.]]

]


[heading Return Value]
      
The number of bytes in the dynamic\_buffer's get area that have been fully consumed by the match function.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine.

The default implementation of the `is_match_condition` type trait evaluates to true for function pointers and function objects with a `result_type` typedef. It must be specialised for other user-defined function objects.


[heading Examples]
  
To read data into a dynamic buffer sequence until whitespace is encountered: 

   typedef boost::asio::buffers_iterator<
       boost::asio::const_buffers_1> iterator;

   std::pair<iterator, bool>
   match_whitespace(iterator begin, iterator end)
   {
     iterator i = begin;
     while (i != end)
       if (std::isspace(*i++))
         return std::make_pair(i, true);
     return std::make_pair(i, false);
   }
   ...
   std::string data;
   boost::asio::read_until(s, data, match_whitespace);




To read data into a `std::string` until a matching character is found: 

   class match_char
   {
   public:
     explicit match_char(char c) : c_(c) {}

     template <typename Iterator>
     std::pair<Iterator, bool> operator()(
         Iterator begin, Iterator end) const
     {
       Iterator i = begin;
       while (i != end)
         if (c_ == *i++)
           return std::make_pair(i, true);
       return std::make_pair(i, false);
     }

   private:
     char c_;
   };

   namespace asio {
     template <> struct is_match_condition<match_char>
       : public boost::true_type {};
   } // namespace asio
   ...
   std::string data;
   boost::asio::read_until(s, data, match_char('a'));





[endsect]



[section:overload8 read_until (8 of 24 overloads)]


Read data into a dynamic buffer sequence until a function object indicates a match. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename MatchCondition>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v1 && buffers,
      MatchCondition match_condition,
      boost::system::error_code & ec,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:


* The match condition function object returns a std::pair where the second element evaluates to true.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the match condition function object already indicates a match, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][A dynamic buffer sequence into which the data will be read.]]

[[match_condition][The function object to be called to determine whether a match exists. The signature of the function object must be: 
``
   pair<iterator, bool> match_condition(iterator begin, iterator end);
``
where `iterator` represents the type: 
``
   buffers_iterator<DynamicBuffer_v1::const_buffers_type>
``
The iterator parameters `begin` and `end` define the range of bytes to be scanned to determine whether there is a match. The `first` member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the `begin` parameter for any subsequent invocation of the match condition. The `second` member of the return value is true if a match has been found, false otherwise.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area that have been fully consumed by the match function. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine.

The default implementation of the `is_match_condition` type trait evaluates to true for function pointers and function objects with a `result_type` typedef. It must be specialised for other user-defined function objects. 




[endsect]



[section:overload9 read_until (9 of 24 overloads)]


Read data into a streambuf until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t read_until(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      char delim);


This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the streambuf contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[b][A streambuf object into which the data will be read.]]

[[delim][The delimiter character.]]

]


[heading Return Value]
      
The number of bytes in the streambuf's get area up to and including the delimiter.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
After a successful read\_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read\_until operation to examine.


[heading Example]
  
To read data into a streambuf until a newline is encountered: 

   boost::asio::streambuf b;
   boost::asio::read_until(s, b, '\n');
   std::istream is(&b);
   std::string line;
   std::getline(is, line); 


After the `read_until` operation completes successfully, the buffer `b` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\n', 'd', 'e', ... } 


The call to `std::getline` then extracts the data up to and including the newline (which is discarded), so that the string `line` contains: 

   { 'a', 'b', ..., 'c' } 


The remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `read_until` operation. 




[endsect]



[section:overload10 read_until (10 of 24 overloads)]


Read data into a streambuf until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t read_until(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      char delim,
      boost::system::error_code & ec);


This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the streambuf contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[b][A streambuf object into which the data will be read.]]

[[delim][The delimiter character.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read\_until operation to examine. 




[endsect]



[section:overload11 read_until (11 of 24 overloads)]


Read data into a streambuf until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t read_until(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      string_view delim);


This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the streambuf contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[b][A streambuf object into which the data will be read.]]

[[delim][The delimiter string.]]

]


[heading Return Value]
      
The number of bytes in the streambuf's get area up to and including the delimiter.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
After a successful read\_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read\_until operation to examine.


[heading Example]
  
To read data into a streambuf until a newline is encountered: 

   boost::asio::streambuf b;
   boost::asio::read_until(s, b, "\r\n");
   std::istream is(&b);
   std::string line;
   std::getline(is, line); 


After the `read_until` operation completes successfully, the buffer `b` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `std::getline` then extracts the data up to and including the newline (which is discarded), so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r' } 


The remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `read_until` operation. 




[endsect]



[section:overload12 read_until (12 of 24 overloads)]


Read data into a streambuf until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t read_until(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      string_view delim,
      boost::system::error_code & ec);


This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the streambuf contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[b][A streambuf object into which the data will be read.]]

[[delim][The delimiter string.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read\_until operation to examine. 




[endsect]



[section:overload13 read_until (13 of 24 overloads)]


Read data into a streambuf until some part of the data it contains matches a regular expression. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t read_until(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      const boost::regex & expr);


This function is used to read data into the specified streambuf until the streambuf's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:


* A substring of the streambuf's get area matches the regular expression.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the streambuf's get area already contains data that matches the regular expression, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[b][A streambuf object into which the data will be read.]]

[[expr][The regular expression.]]

]


[heading Return Value]
      
The number of bytes in the streambuf's get area up to and including the substring that matches the regular expression.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
After a successful read\_until operation, the streambuf may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the streambuf for a subsequent read\_until operation to examine.


[heading Example]
  
To read data into a streambuf until a CR-LF sequence is encountered: 

   boost::asio::streambuf b;
   boost::asio::read_until(s, b, boost::regex("\r\n"));
   std::istream is(&b);
   std::string line;
   std::getline(is, line); 


After the `read_until` operation completes successfully, the buffer `b` contains the data which matched the regular expression: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `std::getline` then extracts the data up to and including the newline (which is discarded), so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r' } 


The remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `read_until` operation. 




[endsect]



[section:overload14 read_until (14 of 24 overloads)]


Read data into a streambuf until some part of the data it contains matches a regular expression. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator>
  std::size_t read_until(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      const boost::regex & expr,
      boost::system::error_code & ec);


This function is used to read data into the specified streambuf until the streambuf's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:


* A substring of the streambuf's get area matches the regular expression.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the streambuf's get area already contains data that matches the regular expression, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[b][A streambuf object into which the data will be read.]]

[[expr][The regular expression.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the streambuf's get area up to and including the substring that matches the regular expression. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the streambuf may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the streambuf for a subsequent read\_until operation to examine. 




[endsect]



[section:overload15 read_until (15 of 24 overloads)]


Read data into a streambuf until a function object indicates a match. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator,
      typename MatchCondition>
  std::size_t read_until(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      MatchCondition match_condition,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0);


This function is used to read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The call will block until one of the following conditions is true:


* The match condition function object returns a std::pair where the second element evaluates to true.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the match condition function object already indicates a match, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[b][A streambuf object into which the data will be read.]]

[[match_condition][The function object to be called to determine whether a match exists. The signature of the function object must be: 
``
   pair<iterator, bool> match_condition(iterator begin, iterator end);
``
where `iterator` represents the type: 
``
   buffers_iterator<basic_streambuf<Allocator>::const_buffers_type>
``
The iterator parameters `begin` and `end` define the range of bytes to be scanned to determine whether there is a match. The `first` member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the `begin` parameter for any subsequent invocation of the match condition. The `second` member of the return value is true if a match has been found, false otherwise.]]

]


[heading Return Value]
      
The number of bytes in the streambuf's get area that have been fully consumed by the match function.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
After a successful read\_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent read\_until operation to examine.

The default implementation of the `is_match_condition` type trait evaluates to true for function pointers and function objects with a `result_type` typedef. It must be specialised for other user-defined function objects.


[heading Examples]
  
To read data into a streambuf until whitespace is encountered: 

   typedef boost::asio::buffers_iterator<
       boost::asio::streambuf::const_buffers_type> iterator;

   std::pair<iterator, bool>
   match_whitespace(iterator begin, iterator end)
   {
     iterator i = begin;
     while (i != end)
       if (std::isspace(*i++))
         return std::make_pair(i, true);
     return std::make_pair(i, false);
   }
   ...
   boost::asio::streambuf b;
   boost::asio::read_until(s, b, match_whitespace);




To read data into a streambuf until a matching character is found: 

   class match_char
   {
   public:
     explicit match_char(char c) : c_(c) {}

     template <typename Iterator>
     std::pair<Iterator, bool> operator()(
         Iterator begin, Iterator end) const
     {
       Iterator i = begin;
       while (i != end)
         if (c_ == *i++)
           return std::make_pair(i, true);
       return std::make_pair(i, false);
     }

   private:
     char c_;
   };

   namespace asio {
     template <> struct is_match_condition<match_char>
       : public boost::true_type {};
   } // namespace asio
   ...
   boost::asio::streambuf b;
   boost::asio::read_until(s, b, match_char('a'));





[endsect]



[section:overload16 read_until (16 of 24 overloads)]


Read data into a streambuf until a function object indicates a match. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename Allocator,
      typename MatchCondition>
  std::size_t read_until(
      SyncReadStream & s,
      boost::asio::basic_streambuf< Allocator > & b,
      MatchCondition match_condition,
      boost::system::error_code & ec,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0);


This function is used to read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The call will block until one of the following conditions is true:


* The match condition function object returns a std::pair where the second element evaluates to true.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the match condition function object already indicates a match, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[b][A streambuf object into which the data will be read.]]

[[match_condition][The function object to be called to determine whether a match exists. The signature of the function object must be: 
``
   pair<iterator, bool> match_condition(iterator begin, iterator end);
``
where `iterator` represents the type: 
``
   buffers_iterator<basic_streambuf<Allocator>::const_buffers_type>
``
The iterator parameters `begin` and `end` define the range of bytes to be scanned to determine whether there is a match. The `first` member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the `begin` parameter for any subsequent invocation of the match condition. The `second` member of the return value is true if a match has been found, false otherwise.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the streambuf's get area that have been fully consumed by the match function. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent read\_until operation to examine.

The default implementation of the `is_match_condition` type trait evaluates to true for function pointers and function objects with a `result_type` typedef. It must be specialised for other user-defined function objects. 




[endsect]



[section:overload17 read_until (17 of 24 overloads)]


Read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      char delim,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[delim][The delimiter character.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine.


[heading Example]
  
To read data into a `std::string` until a newline is encountered: 

   std::string data;
   std::size_t n = boost::asio::read_until(s,
       boost::asio::dynamic_buffer(data), '\n');
   std::string line = data.substr(0, n);
   data.erase(0, n); 


After the `read_until` operation completes successfully, the string `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\n' } 


After the call to `erase`, the remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `read_until` operation. 




[endsect]



[section:overload18 read_until (18 of 24 overloads)]


Read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      char delim,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[delim][The delimiter character.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine. 




[endsect]



[section:overload19 read_until (19 of 24 overloads)]


Read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      string_view delim,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[delim][The delimiter string.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine.


[heading Example]
  
To read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   std::size_t n = boost::asio::read_until(s,
       boost::asio::dynamic_buffer(data), "\r\n");
   std::string line = data.substr(0, n);
   data.erase(0, n); 


After the `read_until` operation completes successfully, the string `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `read_until` operation. 




[endsect]



[section:overload20 read_until (20 of 24 overloads)]


Read data into a dynamic buffer sequence until it contains a specified delimiter. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      string_view delim,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:


* The get area of the dynamic buffer sequence contains the specified delimiter.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][The dynamic buffer sequence into which the data will be read.]]

[[delim][The delimiter string.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine. 




[endsect]



[section:overload21 read_until (21 of 24 overloads)]


Read data into a dynamic buffer sequence until some part of the data it contains matches a regular expression. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      const boost::regex & expr,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:


* A substring of the dynamic buffer sequence's get area matches the regular expression.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains data that matches the regular expression, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][A dynamic buffer sequence into which the data will be read.]]

[[expr][The regular expression.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the substring that matches the regular expression.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine.


[heading Example]
  
To read data into a `std::string` until a CR-LF sequence is encountered: 

   std::string data;
   std::size_t n = boost::asio::read_until(s,
       boost::asio::dynamic_buffer(data), boost::regex("\r\n"));
   std::string line = data.substr(0, n);
   data.erase(0, n); 


After the `read_until` operation completes successfully, the string `data` contains the delimiter: 

   { 'a', 'b', ..., 'c', '\r', '\n', 'd', 'e', ... } 


The call to `substr` then extracts the data up to and including the delimiter, so that the string `line` contains: 

   { 'a', 'b', ..., 'c', '\r', '\n' } 


After the call to `erase`, the remaining data is left in the buffer `b` as follows: 

   { 'd', 'e', ... } 


This data may be the start of a new line, to be extracted by a subsequent `read_until` operation. 




[endsect]



[section:overload22 read_until (22 of 24 overloads)]


Read data into a dynamic buffer sequence until some part of the data it contains matches a regular expression. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      const boost::regex & expr,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:


* A substring of the dynamic buffer sequence's get area matches the regular expression.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the dynamic buffer sequence's get area already contains data that matches the regular expression, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][A dynamic buffer sequence into which the data will be read.]]

[[expr][The regular expression.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area up to and including the substring that matches the regular expression. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine. 




[endsect]



[section:overload23 read_until (23 of 24 overloads)]


Read data into a dynamic buffer sequence until a function object indicates a match. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename MatchCondition>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      MatchCondition match_condition,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:


* The match condition function object returns a std::pair where the second element evaluates to true.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the match condition function object already indicates a match, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][A dynamic buffer sequence into which the data will be read.]]

[[match_condition][The function object to be called to determine whether a match exists. The signature of the function object must be: 
``
   pair<iterator, bool> match_condition(iterator begin, iterator end);
``
where `iterator` represents the type: 
``
   buffers_iterator<typename DynamicBuffer_v2::const_buffers_type>
``
The iterator parameters `begin` and `end` define the range of bytes to be scanned to determine whether there is a match. The `first` member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the `begin` parameter for any subsequent invocation of the match condition. The `second` member of the return value is true if a match has been found, false otherwise.]]

]


[heading Return Value]
      
The number of bytes in the dynamic\_buffer's get area that have been fully consumed by the match function.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine.

The default implementation of the `is_match_condition` type trait evaluates to true for function pointers and function objects with a `result_type` typedef. It must be specialised for other user-defined function objects.


[heading Examples]
  
To read data into a dynamic buffer sequence until whitespace is encountered: 

   typedef boost::asio::buffers_iterator<
       boost::asio::const_buffers_1> iterator;

   std::pair<iterator, bool>
   match_whitespace(iterator begin, iterator end)
   {
     iterator i = begin;
     while (i != end)
       if (std::isspace(*i++))
         return std::make_pair(i, true);
     return std::make_pair(i, false);
   }
   ...
   std::string data;
   boost::asio::read_until(s, data, match_whitespace);




To read data into a `std::string` until a matching character is found: 

   class match_char
   {
   public:
     explicit match_char(char c) : c_(c) {}

     template <typename Iterator>
     std::pair<Iterator, bool> operator()(
         Iterator begin, Iterator end) const
     {
       Iterator i = begin;
       while (i != end)
         if (c_ == *i++)
           return std::make_pair(i, true);
       return std::make_pair(i, false);
     }

   private:
     char c_;
   };

   namespace asio {
     template <> struct is_match_condition<match_char>
       : public boost::true_type {};
   } // namespace asio
   ...
   std::string data;
   boost::asio::read_until(s, data, match_char('a'));





[endsect]



[section:overload24 read_until (24 of 24 overloads)]


Read data into a dynamic buffer sequence until a function object indicates a match. 


  template<
      typename ``[link boost_asio.reference.SyncReadStream SyncReadStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename MatchCondition>
  std::size_t read_until(
      SyncReadStream & s,
      DynamicBuffer_v2 buffers,
      MatchCondition match_condition,
      boost::system::error_code & ec,
      typename constraint< is_match_condition< MatchCondition >::value >::type  = 0,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:


* The match condition function object returns a std::pair where the second element evaluates to true.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's read\_some function. If the match condition function object already indicates a match, the function returns immediately.


[heading Parameters]
    

[variablelist
  
[[s][The stream from which the data is to be read. The type must support the SyncReadStream concept.]]

[[buffers][A dynamic buffer sequence into which the data will be read.]]

[[match_condition][The function object to be called to determine whether a match exists. The signature of the function object must be: 
``
   pair<iterator, bool> match_condition(iterator begin, iterator end);
``
where `iterator` represents the type: 
``
   buffers_iterator<DynamicBuffer_v2::const_buffers_type>
``
The iterator parameters `begin` and `end` define the range of bytes to be scanned to determine whether there is a match. The `first` member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the `begin` parameter for any subsequent invocation of the match condition. The `second` member of the return value is true if a match has been found, false otherwise.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes in the dynamic buffer sequence's get area that have been fully consumed by the match function. Returns 0 if an error occurred.


[heading Remarks]
      
After a successful read\_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read\_until operation to examine.

The default implementation of the `is_match_condition` type trait evaluates to true for function pointers and function objects with a `result_type` typedef. It must be specialised for other user-defined function objects. 




[endsect]


[endsect]


[section:readable_pipe readable_pipe]

[indexterm1 boost_asio.indexterm.readable_pipe..readable_pipe] 
Typedef for the typical usage of a readable pipe. 


  typedef basic_readable_pipe readable_pipe;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_readable_pipe__rebind_executor [*rebind_executor]]]
    [Rebinds the pipe type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_readable_pipe.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_readable_pipe.lowest_layer_type [*lowest_layer_type]]]
    [A basic_readable_pipe is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_readable_pipe.native_handle_type [*native_handle_type]]]
    [The native representation of a pipe. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_readable_pipe.assign [*assign]]]
    [Assign an existing native pipe to the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.basic_readable_pipe [*basic_readable_pipe]] [constructor]]
    [Construct a basic_readable_pipe without opening it. 
     [hr]
     Construct a basic_readable_pipe on an existing native pipe. 
     [hr]
     Move-construct a basic_readable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.close [*close]]]
    [Close the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.is_open [*is_open]]]
    [Determine whether the pipe is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.native_handle [*native_handle]]]
    [Get the native pipe representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.operator_eq_ [*operator=]]]
    [Move-assign a basic_readable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe.read_some [*read_some]]]
    [Read some data from the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_readable_pipe._basic_readable_pipe [*~basic_readable_pipe]] [destructor]]
    [Destroys the pipe. ]
  ]
  
]

The [link boost_asio.reference.basic_readable_pipe `basic_readable_pipe`] class provides a wrapper over pipe functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/readable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:redirect_error redirect_error]

[indexterm1 boost_asio.indexterm.redirect_error..redirect_error] 
Create a completion token to capture error\_code values to a variable. 


  template<
      typename CompletionToken>
  redirect_error_t< typename decay< CompletionToken >::type > redirect_error(
      CompletionToken && completion_token,
      boost::system::error_code & ec);


[heading Requirements]

['Header: ][^boost/asio/redirect_error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:redirect_error_t redirect_error_t]

[indexterm1 boost_asio.indexterm.redirect_error_t..redirect_error_t]


Completion token type used to specify that an error produced by an asynchronous operation is captured to an error\_code variable. 


  template<
      typename CompletionToken>
  class redirect_error_t


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.redirect_error_t.redirect_error_t [*redirect_error_t]] [constructor]]
    [Constructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.redirect_error_t.ec_ [*ec_]]]
    []
  ]

  [
    [[link boost_asio.reference.redirect_error_t.token_ [*token_]]]
    []
  ]

]

The [link boost_asio.reference.redirect_error_t `redirect_error_t`] class is used to indicate that any error\_code produced by an asynchronous operation is captured to a specified variable. 

[heading Requirements]

['Header: ][^boost/asio/redirect_error.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:ec_ redirect_error_t::ec_]

[indexterm2 boost_asio.indexterm.redirect_error_t.ec_..ec_..redirect_error_t] 

  boost::system::error_code & ec_;



[endsect]



[section:redirect_error_t redirect_error_t::redirect_error_t]

[indexterm2 boost_asio.indexterm.redirect_error_t.redirect_error_t..redirect_error_t..redirect_error_t] 
Constructor. 


  template<
      typename T>
  redirect_error_t(
      T && completion_token,
      boost::system::error_code & ec);



[endsect]



[section:token_ redirect_error_t::token_]

[indexterm2 boost_asio.indexterm.redirect_error_t.token_..token_..redirect_error_t] 

  CompletionToken token_;



[endsect]



[endsect]

[section:register_buffers register_buffers]

[indexterm1 boost_asio.indexterm.register_buffers..register_buffers] 
Register buffers with an execution context. 

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  buffer_registration< MutableBufferSequence > ``[link boost_asio.reference.register_buffers.overload1 register_buffers]``(
      const Executor & ex,
      const MutableBufferSequence & buffer_sequence,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.register_buffers.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename Allocator>
  buffer_registration< MutableBufferSequence, Allocator > ``[link boost_asio.reference.register_buffers.overload2 register_buffers]``(
      const Executor & ex,
      const MutableBufferSequence & buffer_sequence,
      const Allocator & alloc,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.register_buffers.overload2 more...]]``

  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  buffer_registration< MutableBufferSequence > ``[link boost_asio.reference.register_buffers.overload3 register_buffers]``(
      ExecutionContext & ctx,
      const MutableBufferSequence & buffer_sequence,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.register_buffers.overload3 more...]]``

  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename Allocator>
  buffer_registration< MutableBufferSequence, Allocator > ``[link boost_asio.reference.register_buffers.overload4 register_buffers]``(
      ExecutionContext & ctx,
      const MutableBufferSequence & buffer_sequence,
      const Allocator & alloc,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.register_buffers.overload4 more...]]``

[heading Requirements]

['Header: ][^boost/asio/buffer_registration.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 register_buffers (1 of 4 overloads)]


Register buffers with an execution context. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  buffer_registration< MutableBufferSequence > register_buffers(
      const Executor & ex,
      const MutableBufferSequence & buffer_sequence,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);



[endsect]



[section:overload2 register_buffers (2 of 4 overloads)]


Register buffers with an execution context. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename Allocator>
  buffer_registration< MutableBufferSequence, Allocator > register_buffers(
      const Executor & ex,
      const MutableBufferSequence & buffer_sequence,
      const Allocator & alloc,
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);



[endsect]



[section:overload3 register_buffers (3 of 4 overloads)]


Register buffers with an execution context. 


  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  buffer_registration< MutableBufferSequence > register_buffers(
      ExecutionContext & ctx,
      const MutableBufferSequence & buffer_sequence,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[endsect]



[section:overload4 register_buffers (4 of 4 overloads)]


Register buffers with an execution context. 


  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename Allocator>
  buffer_registration< MutableBufferSequence, Allocator > register_buffers(
      ExecutionContext & ctx,
      const MutableBufferSequence & buffer_sequence,
      const Allocator & alloc,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[endsect]


[endsect]

[section:registered_buffer_id registered_buffer_id]

[indexterm1 boost_asio.indexterm.registered_buffer_id..registered_buffer_id]


Type used to identify a registered buffer. 


  class registered_buffer_id


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.registered_buffer_id.native_handle_type [*native_handle_type]]]
    [The native buffer identifier type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.registered_buffer_id.native_handle [*native_handle]]]
    [Get the native buffer identifier type. ]
  ]
  
  [
    [[link boost_asio.reference.registered_buffer_id.registered_buffer_id [*registered_buffer_id]] [constructor]]
    [Default constructor creates an invalid registered buffer identifier. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.registered_buffer_id.operator_not__eq_ [*operator!=]]]
    [Compare two IDs for equality. ]
  ]
  
  [
    [[link boost_asio.reference.registered_buffer_id.operator_eq__eq_ [*operator==]]]
    [Compare two IDs for equality. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/registered_buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:native_handle registered_buffer_id::native_handle]

[indexterm2 boost_asio.indexterm.registered_buffer_id.native_handle..native_handle..registered_buffer_id] 
Get the native buffer identifier type. 


  native_handle_type native_handle() const;



[endsect]



[section:native_handle_type registered_buffer_id::native_handle_type]

[indexterm2 boost_asio.indexterm.registered_buffer_id.native_handle_type..native_handle_type..registered_buffer_id] 
The native buffer identifier type. 


  typedef int native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/registered_buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_not__eq_ registered_buffer_id::operator!=]

[indexterm2 boost_asio.indexterm.registered_buffer_id.operator_not__eq_..operator!=..registered_buffer_id] 
Compare two IDs for equality. 


  friend bool operator!=(
      const registered_buffer_id & lhs,
      const registered_buffer_id & rhs);


[heading Requirements]

['Header: ][^boost/asio/registered_buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq__eq_ registered_buffer_id::operator==]

[indexterm2 boost_asio.indexterm.registered_buffer_id.operator_eq__eq_..operator==..registered_buffer_id] 
Compare two IDs for equality. 


  friend bool operator==(
      const registered_buffer_id & lhs,
      const registered_buffer_id & rhs);


[heading Requirements]

['Header: ][^boost/asio/registered_buffer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:registered_buffer_id registered_buffer_id::registered_buffer_id]

[indexterm2 boost_asio.indexterm.registered_buffer_id.registered_buffer_id..registered_buffer_id..registered_buffer_id] 
Default constructor creates an invalid registered buffer identifier. 


  registered_buffer_id();



[endsect]



[endsect]


[section:require require]

[indexterm1 boost_asio.indexterm.require..require] 
A customisation point that applies a concept-preserving property to an object. 


  constexpr unspecified require = unspecified;


The name `require` denotes a customisation point object. The expression `boost::asio::require(E, P0, Pn...)` for some subexpressions `E` and `P0`, and where `Pn...` represents `N` subexpressions (where `N` is 0 or more, and with types `T = decay_t<decltype(E)>` and `Prop0 = decay_t<decltype(P0)>`) is expression-equivalent to:


* If `is_applicable_property_v<T, Prop0> && Prop0::is_requirable` is not a well-formed constant expression with value `true`, `boost::asio::require(E, P0, Pn...)` is ill-formed.


* Otherwise, `E` if `N == 0` and the expression `Prop0::template static_query_v<T> == Prop0::value()` is a well-formed constant expression with value `true`.


* Otherwise, `(E).require(P0)` if `N == 0` and the expression `(E).require(P0)` is a valid expression.


* Otherwise, `require(E, P0)` if `N == 0` and the expression `require(E, P0)` is a valid expression with overload resolution performed in a context that does not include the declaration of the `require` customization point object.


* Otherwise, `boost::asio::require(boost::asio::require(E, P0), Pn...)` if `N > 0` and the expression `boost::asio::require(boost::asio::require(E, P0), Pn...)` is a valid expression.


* Otherwise, `boost::asio::require(E, P0, Pn...)` is ill-formed. 



[heading Requirements]

['Header: ][^boost/asio/require.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:require_concept require_concept]

[indexterm1 boost_asio.indexterm.require_concept..require_concept] 
A customisation point that applies a concept-enforcing property to an object. 


  constexpr unspecified require_concept = unspecified;


The name `require_concept` denotes a customization point object. The expression `boost::asio::require_concept(E, P)` for some subexpressions `E` and `P` (with types `T = decay_t<decltype(E)>` and `Prop = decay_t<decltype(P)>`) is expression-equivalent to:


* If `is_applicable_property_v<T, Prop> && Prop::is_requirable_concept` is not a well-formed constant expression with value `true`, `boost::asio::require_concept(E, P)` is ill-formed.


* Otherwise, `E` if the expression `Prop::template static_query_v<T> == Prop::value()` is a well-formed constant expression with value `true`.


* Otherwise, `(E).require_concept(P)` if the expression `(E).require_concept(P)` is well-formed.


* Otherwise, `require_concept(E, P)` if the expression `require_concept(E, P)` is a valid expression with overload resolution performed in a context that does not include the declaration of the `require_concept` customization point object.


* Otherwise, `boost::asio::require_concept(E, P)` is ill-formed. 



[heading Requirements]

['Header: ][^boost/asio/require_concept.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:require_concept_result require_concept_result]

[indexterm1 boost_asio.indexterm.require_concept_result..require_concept_result]


A type trait that determines the result type of a `require_concept` expression. 


  template<
      typename T,
      typename Property>
  struct require_concept_result


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.require_concept_result.type [*type]]]
    [The result of the require_concept expression. ]
  
  ]

]

Class template `require_concept_result` is a trait that determines the result type of the expression `boost::asio::require_concept(std::declval<T>(), std::declval<Property>())`. 

[heading Requirements]

['Header: ][^boost/asio/require_concept.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:type require_concept_result::type]

[indexterm2 boost_asio.indexterm.require_concept_result.type..type..require_concept_result] 
The result of the `require_concept` expression. 


  typedef automatically_determined type;



[heading Requirements]

['Header: ][^boost/asio/require_concept.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:require_result require_result]

[indexterm1 boost_asio.indexterm.require_result..require_result]


A type trait that determines the result type of a `require` expression. 


  template<
      typename T,
      typename... Properties>
  struct require_result


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.require_result.type [*type]]]
    [The result of the require expression. ]
  
  ]

]

Class template `require_result` is a trait that determines the result type of the expression `boost::asio::require(std::declval<T>(), std::declval<Properties>()...)`. 

[heading Requirements]

['Header: ][^boost/asio/require.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:type require_result::type]

[indexterm2 boost_asio.indexterm.require_result.type..type..require_result] 
The result of the `require` expression. 


  typedef automatically_determined type;



[heading Requirements]

['Header: ][^boost/asio/require.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]


[section:resolver_errc__try_again resolver_errc::try_again]

[indexterm1 boost_asio.indexterm.resolver_errc__try_again..resolver_errc::try_again] 

  const error::netdb_errors try_again = error::host_not_found_try_again;


[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:serial_port serial_port]

[indexterm1 boost_asio.indexterm.serial_port..serial_port] 
Typedef for the typical usage of a serial port. 


  typedef basic_serial_port serial_port;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_serial_port__rebind_executor [*rebind_executor]]]
    [Rebinds the serial port type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_serial_port.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_serial_port.lowest_layer_type [*lowest_layer_type]]]
    [A basic_basic_serial_port is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_serial_port.native_handle_type [*native_handle_type]]]
    [The native representation of a serial port. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_serial_port.assign [*assign]]]
    [Assign an existing native serial port to the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.basic_serial_port [*basic_serial_port]] [constructor]]
    [Construct a basic_serial_port without opening it. 
     [hr]
     Construct and open a basic_serial_port. 
     [hr]
     Construct a basic_serial_port on an existing native serial port. 
     [hr]
     Move-construct a basic_serial_port from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.close [*close]]]
    [Close the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.get_option [*get_option]]]
    [Get an option from the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.is_open [*is_open]]]
    [Determine whether the serial port is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.native_handle [*native_handle]]]
    [Get the native serial port representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.open [*open]]]
    [Open the serial port using the specified device name. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.operator_eq_ [*operator=]]]
    [Move-assign a basic_serial_port from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.read_some [*read_some]]]
    [Read some data from the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.send_break [*send_break]]]
    [Send a break sequence to the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.set_option [*set_option]]]
    [Set an option on the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port.write_some [*write_some]]]
    [Write some data to the serial port. ]
  ]
  
  [
    [[link boost_asio.reference.basic_serial_port._basic_serial_port [*~basic_serial_port]] [destructor]]
    [Destroys the serial port. ]
  ]
  
]

The [link boost_asio.reference.basic_serial_port `basic_serial_port`] class provides a wrapper over serial port functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/serial_port.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:serial_port_base serial_port_base]

[indexterm1 boost_asio.indexterm.serial_port_base..serial_port_base]


The [link boost_asio.reference.serial_port_base `serial_port_base`] class is used as a base for the [link boost_asio.reference.basic_serial_port `basic_serial_port`] class template so that we have a common place to define the serial port options. 


  class serial_port_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.serial_port_base__baud_rate [*baud_rate]]]
    [Serial port option to permit changing the baud rate. ]
  
  ]

  [

    [[link boost_asio.reference.serial_port_base__character_size [*character_size]]]
    [Serial port option to permit changing the character size. ]
  
  ]

  [

    [[link boost_asio.reference.serial_port_base__flow_control [*flow_control]]]
    [Serial port option to permit changing the flow control. ]
  
  ]

  [

    [[link boost_asio.reference.serial_port_base__parity [*parity]]]
    [Serial port option to permit changing the parity. ]
  
  ]

  [

    [[link boost_asio.reference.serial_port_base__stop_bits [*stop_bits]]]
    [Serial port option to permit changing the number of stop bits. ]
  
  ]

]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.serial_port_base._serial_port_base [*~serial_port_base]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/serial_port_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:_serial_port_base serial_port_base::~serial_port_base]

[indexterm2 boost_asio.indexterm.serial_port_base._serial_port_base..~serial_port_base..serial_port_base] 
Protected destructor to prevent deletion through this type. 


  ~serial_port_base();



[endsect]



[endsect]

[section:serial_port_base__baud_rate serial_port_base::baud_rate]

[indexterm1 boost_asio.indexterm.serial_port_base__baud_rate..serial_port_base::baud_rate]


Serial port option to permit changing the baud rate. 


  class baud_rate


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.serial_port_base__baud_rate.baud_rate [*baud_rate]] [constructor]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__baud_rate.load [*load]]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__baud_rate.store [*store]]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__baud_rate.value [*value]]]
    []
  ]
  
]

Implements changing the baud rate for a given serial port. 

[heading Requirements]

['Header: ][^boost/asio/serial_port_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:baud_rate serial_port_base::baud_rate::baud_rate]

[indexterm2 boost_asio.indexterm.serial_port_base__baud_rate.baud_rate..baud_rate..serial_port_base::baud_rate] 

  baud_rate(
      unsigned int rate = 0);



[endsect]



[section:load serial_port_base::baud_rate::load]

[indexterm2 boost_asio.indexterm.serial_port_base__baud_rate.load..load..serial_port_base::baud_rate] 

  void load(
      const BOOST_ASIO_OPTION_STORAGE & storage,
      boost::system::error_code & ec);



[endsect]



[section:store serial_port_base::baud_rate::store]

[indexterm2 boost_asio.indexterm.serial_port_base__baud_rate.store..store..serial_port_base::baud_rate] 

  void store(
      BOOST_ASIO_OPTION_STORAGE & storage,
      boost::system::error_code & ec) const;



[endsect]



[section:value serial_port_base::baud_rate::value]

[indexterm2 boost_asio.indexterm.serial_port_base__baud_rate.value..value..serial_port_base::baud_rate] 

  unsigned int value() const;



[endsect]



[endsect]

[section:serial_port_base__character_size serial_port_base::character_size]

[indexterm1 boost_asio.indexterm.serial_port_base__character_size..serial_port_base::character_size]


Serial port option to permit changing the character size. 


  class character_size


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.serial_port_base__character_size.character_size [*character_size]] [constructor]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__character_size.load [*load]]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__character_size.store [*store]]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__character_size.value [*value]]]
    []
  ]
  
]

Implements changing the character size for a given serial port. 

[heading Requirements]

['Header: ][^boost/asio/serial_port_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:character_size serial_port_base::character_size::character_size]

[indexterm2 boost_asio.indexterm.serial_port_base__character_size.character_size..character_size..serial_port_base::character_size] 

  character_size(
      unsigned int t = 8);



[endsect]



[section:load serial_port_base::character_size::load]

[indexterm2 boost_asio.indexterm.serial_port_base__character_size.load..load..serial_port_base::character_size] 

  void load(
      const BOOST_ASIO_OPTION_STORAGE & storage,
      boost::system::error_code & ec);



[endsect]



[section:store serial_port_base::character_size::store]

[indexterm2 boost_asio.indexterm.serial_port_base__character_size.store..store..serial_port_base::character_size] 

  void store(
      BOOST_ASIO_OPTION_STORAGE & storage,
      boost::system::error_code & ec) const;



[endsect]



[section:value serial_port_base::character_size::value]

[indexterm2 boost_asio.indexterm.serial_port_base__character_size.value..value..serial_port_base::character_size] 

  unsigned int value() const;



[endsect]



[endsect]

[section:serial_port_base__flow_control serial_port_base::flow_control]

[indexterm1 boost_asio.indexterm.serial_port_base__flow_control..serial_port_base::flow_control]


Serial port option to permit changing the flow control. 


  class flow_control


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.serial_port_base__flow_control.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.serial_port_base__flow_control.flow_control [*flow_control]] [constructor]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__flow_control.load [*load]]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__flow_control.store [*store]]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__flow_control.value [*value]]]
    []
  ]
  
]

Implements changing the flow control for a given serial port. 

[heading Requirements]

['Header: ][^boost/asio/serial_port_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:flow_control serial_port_base::flow_control::flow_control]

[indexterm2 boost_asio.indexterm.serial_port_base__flow_control.flow_control..flow_control..serial_port_base::flow_control] 

  flow_control(
      type t = none);



[endsect]



[section:load serial_port_base::flow_control::load]

[indexterm2 boost_asio.indexterm.serial_port_base__flow_control.load..load..serial_port_base::flow_control] 

  void load(
      const BOOST_ASIO_OPTION_STORAGE & storage,
      boost::system::error_code & ec);



[endsect]



[section:store serial_port_base::flow_control::store]

[indexterm2 boost_asio.indexterm.serial_port_base__flow_control.store..store..serial_port_base::flow_control] 

  void store(
      BOOST_ASIO_OPTION_STORAGE & storage,
      boost::system::error_code & ec) const;



[endsect]



[section:type serial_port_base::flow_control::type]

[indexterm2 boost_asio.indexterm.serial_port_base__flow_control.type..type..serial_port_base::flow_control] 
  enum type

[indexterm2 boost_asio.indexterm.serial_port_base__flow_control.type.none..none..serial_port_base::flow_control]
[indexterm2 boost_asio.indexterm.serial_port_base__flow_control.type.software..software..serial_port_base::flow_control]
[indexterm2 boost_asio.indexterm.serial_port_base__flow_control.type.hardware..hardware..serial_port_base::flow_control]

[heading Values]
[variablelist

  [
    [none]
    []
  ]

  [
    [software]
    []
  ]

  [
    [hardware]
    []
  ]

]



[endsect]



[section:value serial_port_base::flow_control::value]

[indexterm2 boost_asio.indexterm.serial_port_base__flow_control.value..value..serial_port_base::flow_control] 

  type value() const;



[endsect]



[endsect]

[section:serial_port_base__parity serial_port_base::parity]

[indexterm1 boost_asio.indexterm.serial_port_base__parity..serial_port_base::parity]


Serial port option to permit changing the parity. 


  class parity


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.serial_port_base__parity.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.serial_port_base__parity.load [*load]]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__parity.parity [*parity]] [constructor]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__parity.store [*store]]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__parity.value [*value]]]
    []
  ]
  
]

Implements changing the parity for a given serial port. 

[heading Requirements]

['Header: ][^boost/asio/serial_port_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:load serial_port_base::parity::load]

[indexterm2 boost_asio.indexterm.serial_port_base__parity.load..load..serial_port_base::parity] 

  void load(
      const BOOST_ASIO_OPTION_STORAGE & storage,
      boost::system::error_code & ec);



[endsect]



[section:parity serial_port_base::parity::parity]

[indexterm2 boost_asio.indexterm.serial_port_base__parity.parity..parity..serial_port_base::parity] 

  parity(
      type t = none);



[endsect]



[section:store serial_port_base::parity::store]

[indexterm2 boost_asio.indexterm.serial_port_base__parity.store..store..serial_port_base::parity] 

  void store(
      BOOST_ASIO_OPTION_STORAGE & storage,
      boost::system::error_code & ec) const;



[endsect]



[section:type serial_port_base::parity::type]

[indexterm2 boost_asio.indexterm.serial_port_base__parity.type..type..serial_port_base::parity] 
  enum type

[indexterm2 boost_asio.indexterm.serial_port_base__parity.type.none..none..serial_port_base::parity]
[indexterm2 boost_asio.indexterm.serial_port_base__parity.type.odd..odd..serial_port_base::parity]
[indexterm2 boost_asio.indexterm.serial_port_base__parity.type.even..even..serial_port_base::parity]

[heading Values]
[variablelist

  [
    [none]
    []
  ]

  [
    [odd]
    []
  ]

  [
    [even]
    []
  ]

]



[endsect]



[section:value serial_port_base::parity::value]

[indexterm2 boost_asio.indexterm.serial_port_base__parity.value..value..serial_port_base::parity] 

  type value() const;



[endsect]



[endsect]

[section:serial_port_base__stop_bits serial_port_base::stop_bits]

[indexterm1 boost_asio.indexterm.serial_port_base__stop_bits..serial_port_base::stop_bits]


Serial port option to permit changing the number of stop bits. 


  class stop_bits


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.serial_port_base__stop_bits.type [*type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.serial_port_base__stop_bits.load [*load]]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__stop_bits.stop_bits [*stop_bits]] [constructor]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__stop_bits.store [*store]]]
    []
  ]
  
  [
    [[link boost_asio.reference.serial_port_base__stop_bits.value [*value]]]
    []
  ]
  
]

Implements changing the number of stop bits for a given serial port. 

[heading Requirements]

['Header: ][^boost/asio/serial_port_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:load serial_port_base::stop_bits::load]

[indexterm2 boost_asio.indexterm.serial_port_base__stop_bits.load..load..serial_port_base::stop_bits] 

  void load(
      const BOOST_ASIO_OPTION_STORAGE & storage,
      boost::system::error_code & ec);



[endsect]



[section:stop_bits serial_port_base::stop_bits::stop_bits]

[indexterm2 boost_asio.indexterm.serial_port_base__stop_bits.stop_bits..stop_bits..serial_port_base::stop_bits] 

  stop_bits(
      type t = one);



[endsect]



[section:store serial_port_base::stop_bits::store]

[indexterm2 boost_asio.indexterm.serial_port_base__stop_bits.store..store..serial_port_base::stop_bits] 

  void store(
      BOOST_ASIO_OPTION_STORAGE & storage,
      boost::system::error_code & ec) const;



[endsect]



[section:type serial_port_base::stop_bits::type]

[indexterm2 boost_asio.indexterm.serial_port_base__stop_bits.type..type..serial_port_base::stop_bits] 
  enum type

[indexterm2 boost_asio.indexterm.serial_port_base__stop_bits.type.one..one..serial_port_base::stop_bits]
[indexterm2 boost_asio.indexterm.serial_port_base__stop_bits.type.onepointfive..onepointfive..serial_port_base::stop_bits]
[indexterm2 boost_asio.indexterm.serial_port_base__stop_bits.type.two..two..serial_port_base::stop_bits]

[heading Values]
[variablelist

  [
    [one]
    []
  ]

  [
    [onepointfive]
    []
  ]

  [
    [two]
    []
  ]

]



[endsect]



[section:value serial_port_base::stop_bits::value]

[indexterm2 boost_asio.indexterm.serial_port_base__stop_bits.value..value..serial_port_base::stop_bits] 

  type value() const;



[endsect]



[endsect]

[section:service_already_exists service_already_exists]

[indexterm1 boost_asio.indexterm.service_already_exists..service_already_exists]


Exception thrown when trying to add a duplicate service to an [link boost_asio.reference.execution_context `execution_context`]. 


  class service_already_exists


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.service_already_exists.service_already_exists [*service_already_exists]] [constructor]]
    []
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/execution_context.hpp]

['Convenience header: ][^boost/asio/execution.hpp]


[section:service_already_exists service_already_exists::service_already_exists]

[indexterm2 boost_asio.indexterm.service_already_exists.service_already_exists..service_already_exists..service_already_exists] 

  service_already_exists();



[endsect]



[endsect]


[section:signal_set signal_set]

[indexterm1 boost_asio.indexterm.signal_set..signal_set] 
Typedef for the typical usage of a signal set. 


  typedef basic_signal_set signal_set;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_signal_set__rebind_executor [*rebind_executor]]]
    [Rebinds the signal set type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_signal_set.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_signal_set.add [*add]]]
    [Add a signal to a signal_set. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.async_wait [*async_wait]]]
    [Start an asynchronous operation to wait for a signal to be delivered. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.basic_signal_set [*basic_signal_set]] [constructor]]
    [Construct a signal set without adding any signals. 
     [hr]
     Construct a signal set and add one signal. 
     [hr]
     Construct a signal set and add two signals. 
     [hr]
     Construct a signal set and add three signals. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.cancel [*cancel]]]
    [Cancel all operations associated with the signal set. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.clear [*clear]]]
    [Remove all signals from a signal_set. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set.remove [*remove]]]
    [Remove a signal from a signal_set. ]
  ]
  
  [
    [[link boost_asio.reference.basic_signal_set._basic_signal_set [*~basic_signal_set]] [destructor]]
    [Destroys the signal set. ]
  ]
  
]

The [link boost_asio.reference.basic_signal_set `basic_signal_set`] class provides the ability to perform an asynchronous wait for one or more signals to occur.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.


[heading Example]
  
Performing an asynchronous wait: 

   void handler(
       const boost::system::error_code& error,
       int signal_number)
   {
     if (!error)
     {
       // A signal occurred.
     }
   }

   ...

   // Construct a signal set registered for process termination.
   boost::asio::signal_set signals(my_context, SIGINT, SIGTERM);

   // Start an asynchronous wait for one of the signals to occur.
   signals.async_wait(handler);





[heading Queueing of signal notifications]
  


If a signal is registered with a signal\_set, and the signal occurs when there are no waiting handlers, then the signal notification is queued. The next async\_wait operation on that signal\_set will dequeue the notification. If multiple notifications are queued, subsequent async\_wait operations dequeue them one at a time. Signal notifications are dequeued in order of ascending signal number.

If a signal number is removed from a signal\_set (using the `remove` or `erase` member functions) then any queued notifications for that signal are discarded.


[heading Multiple registration of signals]
  


The same signal number may be registered with different signal\_set objects. When the signal occurs, one handler is called for each signal\_set object.

Note that multiple registration only works for signals that are registered using Asio. The application must not also register a signal handler using functions such as `signal()` or `sigaction()`.


[heading Signal masking on POSIX platforms]
  


POSIX allows signals to be blocked using functions such as `sigprocmask()` and `pthread_sigmask()`. For signals to be delivered, programs must ensure that any signals registered using signal\_set objects are unblocked in at least one thread. 


[heading Requirements]

['Header: ][^boost/asio/signal_set.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:socket_base socket_base]

[indexterm1 boost_asio.indexterm.socket_base..socket_base]


The [link boost_asio.reference.socket_base `socket_base`] class is used as a base for the [link boost_asio.reference.basic_stream_socket `basic_stream_socket`] and [link boost_asio.reference.basic_datagram_socket `basic_datagram_socket`] class templates so that we have a common place to define the shutdown\_type and enum. 


  class socket_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.socket_base.broadcast [*broadcast]]]
    [Socket option to permit sending of broadcast messages. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.bytes_readable [*bytes_readable]]]
    [IO control command to get the amount of data that can be read without blocking. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.debug [*debug]]]
    [Socket option to enable socket-level debugging. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.do_not_route [*do_not_route]]]
    [Socket option to prevent routing, use local interfaces only. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.enable_connection_aborted [*enable_connection_aborted]]]
    [Socket option to report aborted connections on accept. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.keep_alive [*keep_alive]]]
    [Socket option to send keep-alives. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.linger [*linger]]]
    [Socket option to specify whether the socket lingers on close if unsent data is present. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.message_flags [*message_flags]]]
    [Bitmask type for flags that can be passed to send and receive operations. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.out_of_band_inline [*out_of_band_inline]]]
    [Socket option for putting received out-of-band data inline. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.receive_buffer_size [*receive_buffer_size]]]
    [Socket option for the receive buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.receive_low_watermark [*receive_low_watermark]]]
    [Socket option for the receive low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.reuse_address [*reuse_address]]]
    [Socket option to allow the socket to be bound to an address that is already in use. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.send_buffer_size [*send_buffer_size]]]
    [Socket option for the send buffer size of a socket. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.send_low_watermark [*send_low_watermark]]]
    [Socket option for the send low watermark. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.shutdown_type [*shutdown_type]]]
    [Different ways a socket may be shutdown. ]
  
  ]

  [

    [[link boost_asio.reference.socket_base.wait_type [*wait_type]]]
    [Wait types. ]
  
  ]

]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.socket_base._socket_base [*~socket_base]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.socket_base.max_connections [*max_connections]] [static]]
    [(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.socket_base.max_listen_connections [*max_listen_connections]] [static]]
    [The maximum length of the queue of pending incoming connections. ]
  ]

  [
    [[link boost_asio.reference.socket_base.message_do_not_route [*message_do_not_route]] [static]]
    [Specify that the data should not be subject to routing. ]
  ]

  [
    [[link boost_asio.reference.socket_base.message_end_of_record [*message_end_of_record]] [static]]
    [Specifies that the data marks the end of a record. ]
  ]

  [
    [[link boost_asio.reference.socket_base.message_out_of_band [*message_out_of_band]] [static]]
    [Process out-of-band data. ]
  ]

  [
    [[link boost_asio.reference.socket_base.message_peek [*message_peek]] [static]]
    [Peek at incoming data without removing it from the input queue. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:broadcast socket_base::broadcast]

[indexterm2 boost_asio.indexterm.socket_base.broadcast..broadcast..socket_base] 
Socket option to permit sending of broadcast messages. 


  typedef implementation_defined broadcast;



Implements the SOL\_SOCKET/SO\_BROADCAST socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::broadcast option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:bytes_readable socket_base::bytes_readable]

[indexterm2 boost_asio.indexterm.socket_base.bytes_readable..bytes_readable..socket_base] 
IO control command to get the amount of data that can be read without blocking. 


  typedef implementation_defined bytes_readable;



Implements the FIONREAD IO control command.


[heading Example]
  


   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::bytes_readable command(true);
   socket.io_control(command);
   std::size_t bytes_readable = command.get();







[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:debug socket_base::debug]

[indexterm2 boost_asio.indexterm.socket_base.debug..debug..socket_base] 
Socket option to enable socket-level debugging. 


  typedef implementation_defined debug;



Implements the SOL\_SOCKET/SO\_DEBUG socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::debug option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:do_not_route socket_base::do_not_route]

[indexterm2 boost_asio.indexterm.socket_base.do_not_route..do_not_route..socket_base] 
Socket option to prevent routing, use local interfaces only. 


  typedef implementation_defined do_not_route;



Implements the SOL\_SOCKET/SO\_DONTROUTE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::udp::socket socket(my_context);
   ...
   boost::asio::socket_base::do_not_route option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:enable_connection_aborted socket_base::enable_connection_aborted]

[indexterm2 boost_asio.indexterm.socket_base.enable_connection_aborted..enable_connection_aborted..socket_base] 
Socket option to report aborted connections on accept. 


  typedef implementation_defined enable_connection_aborted;



Implements a custom socket option that determines whether or not an accept operation is permitted to fail with `boost::asio::error::connection_aborted`. By default the option is false.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::enable_connection_aborted option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:keep_alive socket_base::keep_alive]

[indexterm2 boost_asio.indexterm.socket_base.keep_alive..keep_alive..socket_base] 
Socket option to send keep-alives. 


  typedef implementation_defined keep_alive;



Implements the SOL\_SOCKET/SO\_KEEPALIVE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::keep_alive option;
   socket.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:linger socket_base::linger]

[indexterm2 boost_asio.indexterm.socket_base.linger..linger..socket_base] 
Socket option to specify whether the socket lingers on close if unsent data is present. 


  typedef implementation_defined linger;



Implements the SOL\_SOCKET/SO\_LINGER socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option(true, 30);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::linger option;
   socket.get_option(option);
   bool is_set = option.enabled();
   unsigned short timeout = option.timeout();







[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:max_connections socket_base::max_connections]

[indexterm2 boost_asio.indexterm.socket_base.max_connections..max_connections..socket_base] 
(Deprecated: Use max\_listen\_connections.) The maximum length of the queue of pending incoming connections. 


  static const int max_connections = implementation_defined;



[endsect]



[section:max_listen_connections socket_base::max_listen_connections]

[indexterm2 boost_asio.indexterm.socket_base.max_listen_connections..max_listen_connections..socket_base] 
The maximum length of the queue of pending incoming connections. 


  static const int max_listen_connections = implementation_defined;



[endsect]



[section:message_do_not_route socket_base::message_do_not_route]

[indexterm2 boost_asio.indexterm.socket_base.message_do_not_route..message_do_not_route..socket_base] 
Specify that the data should not be subject to routing. 


  static const int message_do_not_route = implementation_defined;



[endsect]



[section:message_end_of_record socket_base::message_end_of_record]

[indexterm2 boost_asio.indexterm.socket_base.message_end_of_record..message_end_of_record..socket_base] 
Specifies that the data marks the end of a record. 


  static const int message_end_of_record = implementation_defined;



[endsect]



[section:message_flags socket_base::message_flags]

[indexterm2 boost_asio.indexterm.socket_base.message_flags..message_flags..socket_base] 
Bitmask type for flags that can be passed to send and receive operations. 


  typedef int message_flags;



[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:message_out_of_band socket_base::message_out_of_band]

[indexterm2 boost_asio.indexterm.socket_base.message_out_of_band..message_out_of_band..socket_base] 
Process out-of-band data. 


  static const int message_out_of_band = implementation_defined;



[endsect]



[section:message_peek socket_base::message_peek]

[indexterm2 boost_asio.indexterm.socket_base.message_peek..message_peek..socket_base] 
Peek at incoming data without removing it from the input queue. 


  static const int message_peek = implementation_defined;



[endsect]



[section:out_of_band_inline socket_base::out_of_band_inline]

[indexterm2 boost_asio.indexterm.socket_base.out_of_band_inline..out_of_band_inline..socket_base] 
Socket option for putting received out-of-band data inline. 


  typedef implementation_defined out_of_band_inline;



Implements the SOL\_SOCKET/SO\_OOBINLINE socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option(true);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::out_of_band_inline option;
   socket.get_option(option);
   bool value = option.value();







[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:receive_buffer_size socket_base::receive_buffer_size]

[indexterm2 boost_asio.indexterm.socket_base.receive_buffer_size..receive_buffer_size..socket_base] 
Socket option for the receive buffer size of a socket. 


  typedef implementation_defined receive_buffer_size;



Implements the SOL\_SOCKET/SO\_RCVBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:receive_low_watermark socket_base::receive_low_watermark]

[indexterm2 boost_asio.indexterm.socket_base.receive_low_watermark..receive_low_watermark..socket_base] 
Socket option for the receive low watermark. 


  typedef implementation_defined receive_low_watermark;



Implements the SOL\_SOCKET/SO\_RCVLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::receive_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:reuse_address socket_base::reuse_address]

[indexterm2 boost_asio.indexterm.socket_base.reuse_address..reuse_address..socket_base] 
Socket option to allow the socket to be bound to an address that is already in use. 


  typedef implementation_defined reuse_address;



Implements the SOL\_SOCKET/SO\_REUSEADDR socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option(true);
   acceptor.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::acceptor acceptor(my_context);
   ...
   boost::asio::socket_base::reuse_address option;
   acceptor.get_option(option);
   bool is_set = option.value();







[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:send_buffer_size socket_base::send_buffer_size]

[indexterm2 boost_asio.indexterm.socket_base.send_buffer_size..send_buffer_size..socket_base] 
Socket option for the send buffer size of a socket. 


  typedef implementation_defined send_buffer_size;



Implements the SOL\_SOCKET/SO\_SNDBUF socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option(8192);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_buffer_size option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:send_low_watermark socket_base::send_low_watermark]

[indexterm2 boost_asio.indexterm.socket_base.send_low_watermark..send_low_watermark..socket_base] 
Socket option for the send low watermark. 


  typedef implementation_defined send_low_watermark;



Implements the SOL\_SOCKET/SO\_SNDLOWAT socket option.


[heading Examples]
  
Setting the option: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option(1024);
   socket.set_option(option);





Getting the current option value: 

   boost::asio::ip::tcp::socket socket(my_context);
   ...
   boost::asio::socket_base::send_low_watermark option;
   socket.get_option(option);
   int size = option.value();







[heading Requirements]

['Header: ][^boost/asio/socket_base.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:shutdown_type socket_base::shutdown_type]

[indexterm2 boost_asio.indexterm.socket_base.shutdown_type..shutdown_type..socket_base] 
Different ways a socket may be shutdown. 

  enum shutdown_type

[indexterm2 boost_asio.indexterm.socket_base.shutdown_type.shutdown_receive..shutdown_receive..socket_base]
[indexterm2 boost_asio.indexterm.socket_base.shutdown_type.shutdown_send..shutdown_send..socket_base]
[indexterm2 boost_asio.indexterm.socket_base.shutdown_type.shutdown_both..shutdown_both..socket_base]

[heading Values]
[variablelist

  [
    [shutdown_receive]
    [Shutdown the receive side of the socket. ]
  ]

  [
    [shutdown_send]
    [Shutdown the send side of the socket. ]
  ]

  [
    [shutdown_both]
    [Shutdown both send and receive on the socket. ]
  ]

]



[endsect]



[section:wait_type socket_base::wait_type]

[indexterm2 boost_asio.indexterm.socket_base.wait_type..wait_type..socket_base] 
Wait types. 

  enum wait_type

[indexterm2 boost_asio.indexterm.socket_base.wait_type.wait_read..wait_read..socket_base]
[indexterm2 boost_asio.indexterm.socket_base.wait_type.wait_write..wait_write..socket_base]
[indexterm2 boost_asio.indexterm.socket_base.wait_type.wait_error..wait_error..socket_base]

[heading Values]
[variablelist

  [
    [wait_read]
    [Wait for a socket to become ready to read. ]
  ]

  [
    [wait_write]
    [Wait for a socket to become ready to write. ]
  ]

  [
    [wait_error]
    [Wait for a socket to have error conditions pending. ]
  ]

]


For use with `basic_socket::wait()` and `basic_socket::async_wait()`. 


[endsect]



[section:_socket_base socket_base::~socket_base]

[indexterm2 boost_asio.indexterm.socket_base._socket_base..~socket_base..socket_base] 
Protected destructor to prevent deletion through this type. 


  ~socket_base();



[endsect]



[endsect]

[section:spawn spawn]

[indexterm1 boost_asio.indexterm.spawn..spawn] 
Start a new stackful coroutine. 


Start a new stackful coroutine, calling the specified handler when it completes. 

  template<
      typename Function>
  void ``[link boost_asio.reference.spawn.overload1 spawn]``(
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes());
  ``  [''''&raquo;''' [link boost_asio.reference.spawn.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Handler Handler]``,
      typename Function>
  void ``[link boost_asio.reference.spawn.overload2 spawn]``(
      Handler && handler,
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes(),
      typename constraint< !is_executor< typename decay< Handler >::type >::value &&!execution::is_executor< typename decay< Handler >::type >::value &&!is_convertible< Handler &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.spawn.overload2 more...]]``

Start a new stackful coroutine, inheriting the execution context of another. 

  template<
      typename ``[link boost_asio.reference.Handler Handler]``,
      typename Function>
  void ``[link boost_asio.reference.spawn.overload3 spawn]``(
      basic_yield_context< Handler > ctx,
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes());
  ``  [''''&raquo;''' [link boost_asio.reference.spawn.overload3 more...]]``

Start a new stackful coroutine that executes on a given executor. 

  template<
      typename Function,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  void ``[link boost_asio.reference.spawn.overload4 spawn]``(
      const Executor & ex,
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes(),
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.spawn.overload4 more...]]``

Start a new stackful coroutine that executes on a given strand. 

  template<
      typename Function,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  void ``[link boost_asio.reference.spawn.overload5 spawn]``(
      const strand< Executor > & ex,
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes());
  ``  [''''&raquo;''' [link boost_asio.reference.spawn.overload5 more...]]``

Start a new stackful coroutine that executes in the context of a strand. 

  template<
      typename Function>
  void ``[link boost_asio.reference.spawn.overload6 spawn]``(
      const boost::asio::io_context::strand & s,
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes());
  ``  [''''&raquo;''' [link boost_asio.reference.spawn.overload6 more...]]``

Start a new stackful coroutine that executes on a given execution context. 

  template<
      typename Function,
      typename ExecutionContext>
  void ``[link boost_asio.reference.spawn.overload7 spawn]``(
      ExecutionContext & ctx,
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes(),
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.spawn.overload7 more...]]``

The `spawn()` function is a high-level wrapper over the Boost.Coroutine library. This function enables programs to implement asynchronous logic in a synchronous manner, as illustrated by the following example:



   boost::asio::spawn(my_strand, do_echo);

   // ...

   void do_echo(boost::asio::yield_context yield)
   {
     try
     {
       char data[128];
       for (;;)
       {
         std::size_t length =
           my_socket.async_read_some(
             boost::asio::buffer(data), yield);

         boost::asio::async_write(my_socket,
             boost::asio::buffer(data, length), yield);
       }
     }
     catch (std::exception& e)
     {
       // ...
     }
   } 




[heading Requirements]

['Header: ][^boost/asio/spawn.hpp]

['Convenience header: ]None


[section:overload1 spawn (1 of 7 overloads)]


Start a new stackful coroutine, calling the specified handler when it completes. 


  template<
      typename Function>
  void spawn(
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes());


This function is used to launch a new coroutine.


[heading Parameters]
    

[variablelist
  
[[function][The coroutine function. The function must have the signature: 
``
   void function(basic_yield_context<Handler> yield); 
``
]]

[[attributes][Boost.Coroutine attributes used to customise the coroutine. ]]

]




[endsect]



[section:overload2 spawn (2 of 7 overloads)]


Start a new stackful coroutine, calling the specified handler when it completes. 


  template<
      typename ``[link boost_asio.reference.Handler Handler]``,
      typename Function>
  void spawn(
      Handler && handler,
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes(),
      typename constraint< !is_executor< typename decay< Handler >::type >::value &&!execution::is_executor< typename decay< Handler >::type >::value &&!is_convertible< Handler &, execution_context & >::value >::type  = 0);


This function is used to launch a new coroutine.


[heading Parameters]
    

[variablelist
  
[[handler][A handler to be called when the coroutine exits. More importantly, the handler provides an execution context (via the the handler invocation hook) for the coroutine. The handler must have the signature: 
``
   void handler(); 
``
]]

[[function][The coroutine function. The function must have the signature: 
``
   void function(basic_yield_context<Handler> yield); 
``
]]

[[attributes][Boost.Coroutine attributes used to customise the coroutine. ]]

]




[endsect]



[section:overload3 spawn (3 of 7 overloads)]


Start a new stackful coroutine, inheriting the execution context of another. 


  template<
      typename ``[link boost_asio.reference.Handler Handler]``,
      typename Function>
  void spawn(
      basic_yield_context< Handler > ctx,
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes());


This function is used to launch a new coroutine.


[heading Parameters]
    

[variablelist
  
[[ctx][Identifies the current coroutine as a parent of the new coroutine. This specifies that the new coroutine should inherit the execution context of the parent. For example, if the parent coroutine is executing in a particular strand, then the new coroutine will execute in the same strand.]]

[[function][The coroutine function. The function must have the signature: 
``
   void function(basic_yield_context<Handler> yield); 
``
]]

[[attributes][Boost.Coroutine attributes used to customise the coroutine. ]]

]




[endsect]



[section:overload4 spawn (4 of 7 overloads)]


Start a new stackful coroutine that executes on a given executor. 


  template<
      typename Function,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  void spawn(
      const Executor & ex,
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes(),
      typename constraint< is_executor< Executor >::value||execution::is_executor< Executor >::value >::type  = 0);


This function is used to launch a new coroutine.


[heading Parameters]
    

[variablelist
  
[[ex][Identifies the executor that will run the coroutine. The new coroutine is implicitly given its own strand within this executor.]]

[[function][The coroutine function. The function must have the signature: 
``
   void function(yield_context yield); 
``
]]

[[attributes][Boost.Coroutine attributes used to customise the coroutine. ]]

]




[endsect]



[section:overload5 spawn (5 of 7 overloads)]


Start a new stackful coroutine that executes on a given strand. 


  template<
      typename Function,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  void spawn(
      const strand< Executor > & ex,
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes());


This function is used to launch a new coroutine.


[heading Parameters]
    

[variablelist
  
[[ex][Identifies the strand that will run the coroutine.]]

[[function][The coroutine function. The function must have the signature: 
``
   void function(yield_context yield); 
``
]]

[[attributes][Boost.Coroutine attributes used to customise the coroutine. ]]

]




[endsect]



[section:overload6 spawn (6 of 7 overloads)]


Start a new stackful coroutine that executes in the context of a strand. 


  template<
      typename Function>
  void spawn(
      const boost::asio::io_context::strand & s,
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes());


This function is used to launch a new coroutine.


[heading Parameters]
    

[variablelist
  
[[s][Identifies a strand. By starting multiple coroutines on the same strand, the implementation ensures that none of those coroutines can execute simultaneously.]]

[[function][The coroutine function. The function must have the signature: 
``
   void function(yield_context yield); 
``
]]

[[attributes][Boost.Coroutine attributes used to customise the coroutine. ]]

]




[endsect]



[section:overload7 spawn (7 of 7 overloads)]


Start a new stackful coroutine that executes on a given execution context. 


  template<
      typename Function,
      typename ExecutionContext>
  void spawn(
      ExecutionContext & ctx,
      Function && function,
      const boost::coroutines::attributes & attributes = boost::coroutines::attributes(),
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This function is used to launch a new coroutine.


[heading Parameters]
    

[variablelist
  
[[ctx][Identifies the execution context that will run the coroutine. The new coroutine is implicitly given its own strand within this execution context.]]

[[function][The coroutine function. The function must have the signature: 
``
   void function(yield_context yield); 
``
]]

[[attributes][Boost.Coroutine attributes used to customise the coroutine. ]]

]




[endsect]


[endsect]

[section:ssl__context ssl::context]

[indexterm1 boost_asio.indexterm.ssl__context..ssl::context]



  class context :
    public ssl::context_base,
    noncopyable


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ssl__context.file_format [*file_format]]]
    [File format types. ]
  
  ]

  [

    [[link boost_asio.reference.ssl__context.method [*method]]]
    [Different methods supported by a context. ]
  
  ]

  [

    [[link boost_asio.reference.ssl__context.native_handle_type [*native_handle_type]]]
    [The native handle type of the SSL context. ]
  
  ]

  [

    [[link boost_asio.reference.ssl__context.options [*options]]]
    [Bitmask type for SSL options. ]
  
  ]

  [

    [[link boost_asio.reference.ssl__context.password_purpose [*password_purpose]]]
    [Purpose of PEM password. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ssl__context.add_certificate_authority [*add_certificate_authority]]]
    [Add certification authority for performing verification. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.add_verify_path [*add_verify_path]]]
    [Add a directory containing certificate authority files to be used for performing verification. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.clear_options [*clear_options]]]
    [Clear options on the context. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.context [*context]] [constructor]]
    [Constructor. 
     [hr]
     Construct to take ownership of a native handle. 
     [hr]
     Move-construct a context from another. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.load_verify_file [*load_verify_file]]]
    [Load a certification authority file for performing verification. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.native_handle [*native_handle]]]
    [Get the underlying implementation in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.operator_eq_ [*operator=]]]
    [Move-assign a context from another. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.set_default_verify_paths [*set_default_verify_paths]]]
    [Configures the context to use the default directories for finding certification authority certificates. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.set_options [*set_options]]]
    [Set options on the context. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.set_password_callback [*set_password_callback]]]
    [Set the password callback. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.set_verify_callback [*set_verify_callback]]]
    [Set the callback used to verify peer certificates. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.set_verify_depth [*set_verify_depth]]]
    [Set the peer verification depth. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.set_verify_mode [*set_verify_mode]]]
    [Set the peer verification mode. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.use_certificate [*use_certificate]]]
    [Use a certificate from a memory buffer. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.use_certificate_chain [*use_certificate_chain]]]
    [Use a certificate chain from a memory buffer. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.use_certificate_chain_file [*use_certificate_chain_file]]]
    [Use a certificate chain from a file. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.use_certificate_file [*use_certificate_file]]]
    [Use a certificate from a file. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.use_private_key [*use_private_key]]]
    [Use a private key from a memory buffer. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.use_private_key_file [*use_private_key_file]]]
    [Use a private key from a file. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.use_rsa_private_key [*use_rsa_private_key]]]
    [Use an RSA private key from a memory buffer. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.use_rsa_private_key_file [*use_rsa_private_key_file]]]
    [Use an RSA private key from a file. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.use_tmp_dh [*use_tmp_dh]]]
    [Use the specified memory buffer to obtain the temporary Diffie-Hellman parameters. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context.use_tmp_dh_file [*use_tmp_dh_file]]]
    [Use the specified file to obtain the temporary Diffie-Hellman parameters. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__context._context [*~context]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ssl__context.default_workarounds [*default_workarounds]] [static]]
    [Implement various bug workarounds. ]
  ]

  [
    [[link boost_asio.reference.ssl__context.no_compression [*no_compression]] [static]]
    [Disable compression. Compression is disabled by default. ]
  ]

  [
    [[link boost_asio.reference.ssl__context.no_sslv2 [*no_sslv2]] [static]]
    [Disable SSL v2. ]
  ]

  [
    [[link boost_asio.reference.ssl__context.no_sslv3 [*no_sslv3]] [static]]
    [Disable SSL v3. ]
  ]

  [
    [[link boost_asio.reference.ssl__context.no_tlsv1 [*no_tlsv1]] [static]]
    [Disable TLS v1. ]
  ]

  [
    [[link boost_asio.reference.ssl__context.no_tlsv1_1 [*no_tlsv1_1]] [static]]
    [Disable TLS v1.1. ]
  ]

  [
    [[link boost_asio.reference.ssl__context.no_tlsv1_2 [*no_tlsv1_2]] [static]]
    [Disable TLS v1.2. ]
  ]

  [
    [[link boost_asio.reference.ssl__context.no_tlsv1_3 [*no_tlsv1_3]] [static]]
    [Disable TLS v1.3. ]
  ]

  [
    [[link boost_asio.reference.ssl__context.single_dh_use [*single_dh_use]] [static]]
    [Always create a new key when using tmp_dh parameters. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/ssl/context.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]

[section:add_certificate_authority ssl::context::add_certificate_authority]

[indexterm2 boost_asio.indexterm.ssl__context.add_certificate_authority..add_certificate_authority..ssl::context] 
Add certification authority for performing verification. 


  void ``[link boost_asio.reference.ssl__context.add_certificate_authority.overload1 add_certificate_authority]``(
      const const_buffer & ca);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.add_certificate_authority.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.add_certificate_authority.overload2 add_certificate_authority]``(
      const const_buffer & ca,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.add_certificate_authority.overload2 more...]]``


[section:overload1 ssl::context::add_certificate_authority (1 of 2 overloads)]


Add certification authority for performing verification. 


  void add_certificate_authority(
      const const_buffer & ca);


This function is used to add one trusted certification authority from a memory buffer.


[heading Parameters]
    

[variablelist
  
[[ca][The buffer containing the certification authority certificate. The certificate must use the PEM format.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_get_cert_store` and `X509_STORE_add_cert`. 




[endsect]



[section:overload2 ssl::context::add_certificate_authority (2 of 2 overloads)]


Add certification authority for performing verification. 


  void add_certificate_authority(
      const const_buffer & ca,
      boost::system::error_code & ec);


This function is used to add one trusted certification authority from a memory buffer.


[heading Parameters]
    

[variablelist
  
[[ca][The buffer containing the certification authority certificate. The certificate must use the PEM format.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_get_cert_store` and `X509_STORE_add_cert`. 




[endsect]


[endsect]

[section:add_verify_path ssl::context::add_verify_path]

[indexterm2 boost_asio.indexterm.ssl__context.add_verify_path..add_verify_path..ssl::context] 
Add a directory containing certificate authority files to be used for performing verification. 


  void ``[link boost_asio.reference.ssl__context.add_verify_path.overload1 add_verify_path]``(
      const std::string & path);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.add_verify_path.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.add_verify_path.overload2 add_verify_path]``(
      const std::string & path,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.add_verify_path.overload2 more...]]``


[section:overload1 ssl::context::add_verify_path (1 of 2 overloads)]


Add a directory containing certificate authority files to be used for performing verification. 


  void add_verify_path(
      const std::string & path);


This function is used to specify the name of a directory containing certification authority certificates. Each file in the directory must contain a single certificate. The files must be named using the subject name's hash and an extension of ".0".


[heading Parameters]
    

[variablelist
  
[[path][The name of a directory containing the certificates.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_load_verify_locations`. 




[endsect]



[section:overload2 ssl::context::add_verify_path (2 of 2 overloads)]


Add a directory containing certificate authority files to be used for performing verification. 


  void add_verify_path(
      const std::string & path,
      boost::system::error_code & ec);


This function is used to specify the name of a directory containing certification authority certificates. Each file in the directory must contain a single certificate. The files must be named using the subject name's hash and an extension of ".0".


[heading Parameters]
    

[variablelist
  
[[path][The name of a directory containing the certificates.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_load_verify_locations`. 




[endsect]


[endsect]

[section:clear_options ssl::context::clear_options]

[indexterm2 boost_asio.indexterm.ssl__context.clear_options..clear_options..ssl::context] 
Clear options on the context. 


  void ``[link boost_asio.reference.ssl__context.clear_options.overload1 clear_options]``(
      options o);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.clear_options.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.clear_options.overload2 clear_options]``(
      options o,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.clear_options.overload2 more...]]``


[section:overload1 ssl::context::clear_options (1 of 2 overloads)]


Clear options on the context. 


  void clear_options(
      options o);


This function may be used to configure the SSL options used by the context.


[heading Parameters]
    

[variablelist
  
[[o][A bitmask of options. The available option values are defined in the [link boost_asio.reference.ssl__context_base `ssl::context_base`] class. The specified options, if currently enabled on the context, are cleared.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_clear_options`. 




[endsect]



[section:overload2 ssl::context::clear_options (2 of 2 overloads)]


Clear options on the context. 


  void clear_options(
      options o,
      boost::system::error_code & ec);


This function may be used to configure the SSL options used by the context.


[heading Parameters]
    

[variablelist
  
[[o][A bitmask of options. The available option values are defined in the [link boost_asio.reference.ssl__context_base `ssl::context_base`] class. The specified options, if currently enabled on the context, are cleared.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_clear_options`. 




[endsect]


[endsect]

[section:context ssl::context::context]

[indexterm2 boost_asio.indexterm.ssl__context.context..context..ssl::context] 
Constructor. 


  explicit ``[link boost_asio.reference.ssl__context.context.overload1 context]``(
      method m);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.context.overload1 more...]]``


Construct to take ownership of a native handle. 


  explicit ``[link boost_asio.reference.ssl__context.context.overload2 context]``(
      native_handle_type native_handle);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.context.overload2 more...]]``


Move-construct a context from another. 


  ``[link boost_asio.reference.ssl__context.context.overload3 context]``(
      context && other);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.context.overload3 more...]]``


[section:overload1 ssl::context::context (1 of 3 overloads)]


Constructor. 


  context(
      method m);



[endsect]



[section:overload2 ssl::context::context (2 of 3 overloads)]


Construct to take ownership of a native handle. 


  context(
      native_handle_type native_handle);



[endsect]



[section:overload3 ssl::context::context (3 of 3 overloads)]


Move-construct a context from another. 


  context(
      context && other);


This constructor moves an SSL context from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other context object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the following operations only are valid for the moved-from object: 
* Destruction. 

* As a target for move-assignment. 






[endsect]


[endsect]


[section:default_workarounds ssl::context::default_workarounds]

[indexterm2 boost_asio.indexterm.ssl__context.default_workarounds..default_workarounds..ssl::context] 
Implement various bug workarounds. 


  static const long default_workarounds = implementation_defined;



[endsect]



[section:file_format ssl::context::file_format]

[indexterm2 boost_asio.indexterm.ssl__context.file_format..file_format..ssl::context] 
File format types. 

  enum file_format

[indexterm2 boost_asio.indexterm.ssl__context.file_format.asn1..asn1..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.file_format.pem..pem..ssl::context]

[heading Values]
[variablelist

  [
    [asn1]
    [ASN.1 file. ]
  ]

  [
    [pem]
    [PEM file. ]
  ]

]



[endsect]


[section:load_verify_file ssl::context::load_verify_file]

[indexterm2 boost_asio.indexterm.ssl__context.load_verify_file..load_verify_file..ssl::context] 
Load a certification authority file for performing verification. 


  void ``[link boost_asio.reference.ssl__context.load_verify_file.overload1 load_verify_file]``(
      const std::string & filename);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.load_verify_file.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.load_verify_file.overload2 load_verify_file]``(
      const std::string & filename,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.load_verify_file.overload2 more...]]``


[section:overload1 ssl::context::load_verify_file (1 of 2 overloads)]


Load a certification authority file for performing verification. 


  void load_verify_file(
      const std::string & filename);


This function is used to load one or more trusted certification authorities from a file.


[heading Parameters]
    

[variablelist
  
[[filename][The name of a file containing certification authority certificates in PEM format.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_load_verify_locations`. 




[endsect]



[section:overload2 ssl::context::load_verify_file (2 of 2 overloads)]


Load a certification authority file for performing verification. 


  void load_verify_file(
      const std::string & filename,
      boost::system::error_code & ec);


This function is used to load the certificates for one or more trusted certification authorities from a file.


[heading Parameters]
    

[variablelist
  
[[filename][The name of a file containing certification authority certificates in PEM format.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_load_verify_locations`. 




[endsect]


[endsect]


[section:method ssl::context::method]

[indexterm2 boost_asio.indexterm.ssl__context.method..method..ssl::context] 
Different methods supported by a context. 

  enum method

[indexterm2 boost_asio.indexterm.ssl__context.method.sslv2..sslv2..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.sslv2_client..sslv2_client..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.sslv2_server..sslv2_server..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.sslv3..sslv3..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.sslv3_client..sslv3_client..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.sslv3_server..sslv3_server..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tlsv1..tlsv1..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tlsv1_client..tlsv1_client..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tlsv1_server..tlsv1_server..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.sslv23..sslv23..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.sslv23_client..sslv23_client..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.sslv23_server..sslv23_server..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tlsv11..tlsv11..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tlsv11_client..tlsv11_client..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tlsv11_server..tlsv11_server..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tlsv12..tlsv12..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tlsv12_client..tlsv12_client..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tlsv12_server..tlsv12_server..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tlsv13..tlsv13..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tlsv13_client..tlsv13_client..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tlsv13_server..tlsv13_server..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tls..tls..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tls_client..tls_client..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.method.tls_server..tls_server..ssl::context]

[heading Values]
[variablelist

  [
    [sslv2]
    [Generic SSL version 2. ]
  ]

  [
    [sslv2_client]
    [SSL version 2 client. ]
  ]

  [
    [sslv2_server]
    [SSL version 2 server. ]
  ]

  [
    [sslv3]
    [Generic SSL version 3. ]
  ]

  [
    [sslv3_client]
    [SSL version 3 client. ]
  ]

  [
    [sslv3_server]
    [SSL version 3 server. ]
  ]

  [
    [tlsv1]
    [Generic TLS version 1. ]
  ]

  [
    [tlsv1_client]
    [TLS version 1 client. ]
  ]

  [
    [tlsv1_server]
    [TLS version 1 server. ]
  ]

  [
    [sslv23]
    [Generic SSL/TLS. ]
  ]

  [
    [sslv23_client]
    [SSL/TLS client. ]
  ]

  [
    [sslv23_server]
    [SSL/TLS server. ]
  ]

  [
    [tlsv11]
    [Generic TLS version 1.1. ]
  ]

  [
    [tlsv11_client]
    [TLS version 1.1 client. ]
  ]

  [
    [tlsv11_server]
    [TLS version 1.1 server. ]
  ]

  [
    [tlsv12]
    [Generic TLS version 1.2. ]
  ]

  [
    [tlsv12_client]
    [TLS version 1.2 client. ]
  ]

  [
    [tlsv12_server]
    [TLS version 1.2 server. ]
  ]

  [
    [tlsv13]
    [Generic TLS version 1.3. ]
  ]

  [
    [tlsv13_client]
    [TLS version 1.3 client. ]
  ]

  [
    [tlsv13_server]
    [TLS version 1.3 server. ]
  ]

  [
    [tls]
    [Generic TLS. ]
  ]

  [
    [tls_client]
    [TLS client. ]
  ]

  [
    [tls_server]
    [TLS server. ]
  ]

]



[endsect]



[section:native_handle ssl::context::native_handle]

[indexterm2 boost_asio.indexterm.ssl__context.native_handle..native_handle..ssl::context] 
Get the underlying implementation in the native type. 


  native_handle_type native_handle();


This function may be used to obtain the underlying implementation of the context. This is intended to allow access to context functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type ssl::context::native_handle_type]

[indexterm2 boost_asio.indexterm.ssl__context.native_handle_type..native_handle_type..ssl::context] 
The native handle type of the SSL context. 


  typedef SSL_CTX * native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/ssl/context.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:no_compression ssl::context::no_compression]

[indexterm2 boost_asio.indexterm.ssl__context.no_compression..no_compression..ssl::context] 
Disable compression. Compression is disabled by default. 


  static const long no_compression = implementation_defined;



[endsect]



[section:no_sslv2 ssl::context::no_sslv2]

[indexterm2 boost_asio.indexterm.ssl__context.no_sslv2..no_sslv2..ssl::context] 
Disable SSL v2. 


  static const long no_sslv2 = implementation_defined;



[endsect]



[section:no_sslv3 ssl::context::no_sslv3]

[indexterm2 boost_asio.indexterm.ssl__context.no_sslv3..no_sslv3..ssl::context] 
Disable SSL v3. 


  static const long no_sslv3 = implementation_defined;



[endsect]



[section:no_tlsv1 ssl::context::no_tlsv1]

[indexterm2 boost_asio.indexterm.ssl__context.no_tlsv1..no_tlsv1..ssl::context] 
Disable TLS v1. 


  static const long no_tlsv1 = implementation_defined;



[endsect]



[section:no_tlsv1_1 ssl::context::no_tlsv1_1]

[indexterm2 boost_asio.indexterm.ssl__context.no_tlsv1_1..no_tlsv1_1..ssl::context] 
Disable TLS v1.1. 


  static const long no_tlsv1_1 = implementation_defined;



[endsect]



[section:no_tlsv1_2 ssl::context::no_tlsv1_2]

[indexterm2 boost_asio.indexterm.ssl__context.no_tlsv1_2..no_tlsv1_2..ssl::context] 
Disable TLS v1.2. 


  static const long no_tlsv1_2 = implementation_defined;



[endsect]



[section:no_tlsv1_3 ssl::context::no_tlsv1_3]

[indexterm2 boost_asio.indexterm.ssl__context.no_tlsv1_3..no_tlsv1_3..ssl::context] 
Disable TLS v1.3. 


  static const long no_tlsv1_3 = implementation_defined;



[endsect]



[section:operator_eq_ ssl::context::operator=]

[indexterm2 boost_asio.indexterm.ssl__context.operator_eq_..operator=..ssl::context] 
Move-assign a context from another. 


  context & operator=(
      context && other);


This assignment operator moves an SSL context from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other context object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the following operations only are valid for the moved-from object: 
* Destruction. 

* As a target for move-assignment. 






[endsect]



[section:options ssl::context::options]

[indexterm2 boost_asio.indexterm.ssl__context.options..options..ssl::context] 
Bitmask type for SSL options. 


  typedef long options;



[heading Requirements]

['Header: ][^boost/asio/ssl/context.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:password_purpose ssl::context::password_purpose]

[indexterm2 boost_asio.indexterm.ssl__context.password_purpose..password_purpose..ssl::context] 
Purpose of PEM password. 

  enum password_purpose

[indexterm2 boost_asio.indexterm.ssl__context.password_purpose.for_reading..for_reading..ssl::context]
[indexterm2 boost_asio.indexterm.ssl__context.password_purpose.for_writing..for_writing..ssl::context]

[heading Values]
[variablelist

  [
    [for_reading]
    [The password is needed for reading/decryption. ]
  ]

  [
    [for_writing]
    [The password is needed for writing/encryption. ]
  ]

]



[endsect]


[section:set_default_verify_paths ssl::context::set_default_verify_paths]

[indexterm2 boost_asio.indexterm.ssl__context.set_default_verify_paths..set_default_verify_paths..ssl::context] 
Configures the context to use the default directories for finding certification authority certificates. 


  void ``[link boost_asio.reference.ssl__context.set_default_verify_paths.overload1 set_default_verify_paths]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.set_default_verify_paths.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.set_default_verify_paths.overload2 set_default_verify_paths]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.set_default_verify_paths.overload2 more...]]``


[section:overload1 ssl::context::set_default_verify_paths (1 of 2 overloads)]


Configures the context to use the default directories for finding certification authority certificates. 


  void set_default_verify_paths();


This function specifies that the context should use the default, system-dependent directories for locating certification authority certificates.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_default_verify_paths`. 




[endsect]



[section:overload2 ssl::context::set_default_verify_paths (2 of 2 overloads)]


Configures the context to use the default directories for finding certification authority certificates. 


  void set_default_verify_paths(
      boost::system::error_code & ec);


This function specifies that the context should use the default, system-dependent directories for locating certification authority certificates.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_default_verify_paths`. 




[endsect]


[endsect]

[section:set_options ssl::context::set_options]

[indexterm2 boost_asio.indexterm.ssl__context.set_options..set_options..ssl::context] 
Set options on the context. 


  void ``[link boost_asio.reference.ssl__context.set_options.overload1 set_options]``(
      options o);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.set_options.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.set_options.overload2 set_options]``(
      options o,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.set_options.overload2 more...]]``


[section:overload1 ssl::context::set_options (1 of 2 overloads)]


Set options on the context. 


  void set_options(
      options o);


This function may be used to configure the SSL options used by the context.


[heading Parameters]
    

[variablelist
  
[[o][A bitmask of options. The available option values are defined in the [link boost_asio.reference.ssl__context_base `ssl::context_base`] class. The options are bitwise-ored with any existing value for the options.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_options`. 




[endsect]



[section:overload2 ssl::context::set_options (2 of 2 overloads)]


Set options on the context. 


  void set_options(
      options o,
      boost::system::error_code & ec);


This function may be used to configure the SSL options used by the context.


[heading Parameters]
    

[variablelist
  
[[o][A bitmask of options. The available option values are defined in the [link boost_asio.reference.ssl__context_base `ssl::context_base`] class. The options are bitwise-ored with any existing value for the options.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_options`. 




[endsect]


[endsect]

[section:set_password_callback ssl::context::set_password_callback]

[indexterm2 boost_asio.indexterm.ssl__context.set_password_callback..set_password_callback..ssl::context] 
Set the password callback. 


  template<
      typename PasswordCallback>
  void ``[link boost_asio.reference.ssl__context.set_password_callback.overload1 set_password_callback]``(
      PasswordCallback callback);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.set_password_callback.overload1 more...]]``

  template<
      typename PasswordCallback>
  void ``[link boost_asio.reference.ssl__context.set_password_callback.overload2 set_password_callback]``(
      PasswordCallback callback,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.set_password_callback.overload2 more...]]``


[section:overload1 ssl::context::set_password_callback (1 of 2 overloads)]


Set the password callback. 


  template<
      typename PasswordCallback>
  void set_password_callback(
      PasswordCallback callback);


This function is used to specify a callback function to obtain password information about an encrypted key in PEM format.


[heading Parameters]
    

[variablelist
  
[[callback][The function object to be used for obtaining the password. The function signature of the handler must be: 
``
   std::string password_callback(
     std::size_t max_length,  // The maximum size for a password.
     password_purpose purpose // Whether password is for reading or writing.
   ); 
``
The return value of the callback is a string containing the password.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_default_passwd_cb`. 




[endsect]



[section:overload2 ssl::context::set_password_callback (2 of 2 overloads)]


Set the password callback. 


  template<
      typename PasswordCallback>
  void set_password_callback(
      PasswordCallback callback,
      boost::system::error_code & ec);


This function is used to specify a callback function to obtain password information about an encrypted key in PEM format.


[heading Parameters]
    

[variablelist
  
[[callback][The function object to be used for obtaining the password. The function signature of the handler must be: 
``
   std::string password_callback(
     std::size_t max_length,  // The maximum size for a password.
     password_purpose purpose // Whether password is for reading or writing.
   ); 
``
The return value of the callback is a string containing the password.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_default_passwd_cb`. 




[endsect]


[endsect]

[section:set_verify_callback ssl::context::set_verify_callback]

[indexterm2 boost_asio.indexterm.ssl__context.set_verify_callback..set_verify_callback..ssl::context] 
Set the callback used to verify peer certificates. 


  template<
      typename VerifyCallback>
  void ``[link boost_asio.reference.ssl__context.set_verify_callback.overload1 set_verify_callback]``(
      VerifyCallback callback);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.set_verify_callback.overload1 more...]]``

  template<
      typename VerifyCallback>
  void ``[link boost_asio.reference.ssl__context.set_verify_callback.overload2 set_verify_callback]``(
      VerifyCallback callback,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.set_verify_callback.overload2 more...]]``


[section:overload1 ssl::context::set_verify_callback (1 of 2 overloads)]


Set the callback used to verify peer certificates. 


  template<
      typename VerifyCallback>
  void set_verify_callback(
      VerifyCallback callback);


This function is used to specify a callback function that will be called by the implementation when it needs to verify a peer certificate.


[heading Parameters]
    

[variablelist
  
[[callback][The function object to be used for verifying a certificate. The function signature of the handler must be: 
``
   bool verify_callback(
     bool preverified, // True if the certificate passed pre-verification.
     verify_context& ctx // The peer certificate and other context.
   ); 
``
The return value of the callback is true if the certificate has passed verification, false otherwise.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_verify`. 




[endsect]



[section:overload2 ssl::context::set_verify_callback (2 of 2 overloads)]


Set the callback used to verify peer certificates. 


  template<
      typename VerifyCallback>
  void set_verify_callback(
      VerifyCallback callback,
      boost::system::error_code & ec);


This function is used to specify a callback function that will be called by the implementation when it needs to verify a peer certificate.


[heading Parameters]
    

[variablelist
  
[[callback][The function object to be used for verifying a certificate. The function signature of the handler must be: 
``
   bool verify_callback(
     bool preverified, // True if the certificate passed pre-verification.
     verify_context& ctx // The peer certificate and other context.
   ); 
``
The return value of the callback is true if the certificate has passed verification, false otherwise.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_verify`. 




[endsect]


[endsect]

[section:set_verify_depth ssl::context::set_verify_depth]

[indexterm2 boost_asio.indexterm.ssl__context.set_verify_depth..set_verify_depth..ssl::context] 
Set the peer verification depth. 


  void ``[link boost_asio.reference.ssl__context.set_verify_depth.overload1 set_verify_depth]``(
      int depth);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.set_verify_depth.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.set_verify_depth.overload2 set_verify_depth]``(
      int depth,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.set_verify_depth.overload2 more...]]``


[section:overload1 ssl::context::set_verify_depth (1 of 2 overloads)]


Set the peer verification depth. 


  void set_verify_depth(
      int depth);


This function may be used to configure the maximum verification depth allowed by the context.


[heading Parameters]
    

[variablelist
  
[[depth][Maximum depth for the certificate chain verification that shall be allowed.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_verify_depth`. 




[endsect]



[section:overload2 ssl::context::set_verify_depth (2 of 2 overloads)]


Set the peer verification depth. 


  void set_verify_depth(
      int depth,
      boost::system::error_code & ec);


This function may be used to configure the maximum verification depth allowed by the context.


[heading Parameters]
    

[variablelist
  
[[depth][Maximum depth for the certificate chain verification that shall be allowed.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_verify_depth`. 




[endsect]


[endsect]

[section:set_verify_mode ssl::context::set_verify_mode]

[indexterm2 boost_asio.indexterm.ssl__context.set_verify_mode..set_verify_mode..ssl::context] 
Set the peer verification mode. 


  void ``[link boost_asio.reference.ssl__context.set_verify_mode.overload1 set_verify_mode]``(
      verify_mode v);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.set_verify_mode.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.set_verify_mode.overload2 set_verify_mode]``(
      verify_mode v,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.set_verify_mode.overload2 more...]]``


[section:overload1 ssl::context::set_verify_mode (1 of 2 overloads)]


Set the peer verification mode. 


  void set_verify_mode(
      verify_mode v);


This function may be used to configure the peer verification mode used by the context.


[heading Parameters]
    

[variablelist
  
[[v][A bitmask of peer verification modes. See [link boost_asio.reference.ssl__verify_mode `ssl::verify_mode`]  for available values.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_verify`. 




[endsect]



[section:overload2 ssl::context::set_verify_mode (2 of 2 overloads)]


Set the peer verification mode. 


  void set_verify_mode(
      verify_mode v,
      boost::system::error_code & ec);


This function may be used to configure the peer verification mode used by the context.


[heading Parameters]
    

[variablelist
  
[[v][A bitmask of peer verification modes. See [link boost_asio.reference.ssl__verify_mode `ssl::verify_mode`]  for available values.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_verify`. 




[endsect]


[endsect]


[section:single_dh_use ssl::context::single_dh_use]

[indexterm2 boost_asio.indexterm.ssl__context.single_dh_use..single_dh_use..ssl::context] 
Always create a new key when using tmp\_dh parameters. 


  static const long single_dh_use = implementation_defined;



[endsect]


[section:use_certificate ssl::context::use_certificate]

[indexterm2 boost_asio.indexterm.ssl__context.use_certificate..use_certificate..ssl::context] 
Use a certificate from a memory buffer. 


  void ``[link boost_asio.reference.ssl__context.use_certificate.overload1 use_certificate]``(
      const const_buffer & certificate,
      file_format format);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_certificate.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.use_certificate.overload2 use_certificate]``(
      const const_buffer & certificate,
      file_format format,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_certificate.overload2 more...]]``


[section:overload1 ssl::context::use_certificate (1 of 2 overloads)]


Use a certificate from a memory buffer. 


  void use_certificate(
      const const_buffer & certificate,
      file_format format);


This function is used to load a certificate into the context from a buffer.


[heading Parameters]
    

[variablelist
  
[[certificate][The buffer containing the certificate.]]

[[format][The certificate format (ASN.1 or PEM).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_certificate` or SSL\_CTX\_use\_certificate\_ASN1. 




[endsect]



[section:overload2 ssl::context::use_certificate (2 of 2 overloads)]


Use a certificate from a memory buffer. 


  void use_certificate(
      const const_buffer & certificate,
      file_format format,
      boost::system::error_code & ec);


This function is used to load a certificate into the context from a buffer.


[heading Parameters]
    

[variablelist
  
[[certificate][The buffer containing the certificate.]]

[[format][The certificate format (ASN.1 or PEM).]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_certificate` or SSL\_CTX\_use\_certificate\_ASN1. 




[endsect]


[endsect]

[section:use_certificate_chain ssl::context::use_certificate_chain]

[indexterm2 boost_asio.indexterm.ssl__context.use_certificate_chain..use_certificate_chain..ssl::context] 
Use a certificate chain from a memory buffer. 


  void ``[link boost_asio.reference.ssl__context.use_certificate_chain.overload1 use_certificate_chain]``(
      const const_buffer & chain);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_certificate_chain.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.use_certificate_chain.overload2 use_certificate_chain]``(
      const const_buffer & chain,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_certificate_chain.overload2 more...]]``


[section:overload1 ssl::context::use_certificate_chain (1 of 2 overloads)]


Use a certificate chain from a memory buffer. 


  void use_certificate_chain(
      const const_buffer & chain);


This function is used to load a certificate chain into the context from a buffer.


[heading Parameters]
    

[variablelist
  
[[chain][The buffer containing the certificate chain. The certificate chain must use the PEM format.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_certificate` and SSL\_CTX\_add\_extra\_chain\_cert. 




[endsect]



[section:overload2 ssl::context::use_certificate_chain (2 of 2 overloads)]


Use a certificate chain from a memory buffer. 


  void use_certificate_chain(
      const const_buffer & chain,
      boost::system::error_code & ec);


This function is used to load a certificate chain into the context from a buffer.


[heading Parameters]
    

[variablelist
  
[[chain][The buffer containing the certificate chain. The certificate chain must use the PEM format.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_certificate` and SSL\_CTX\_add\_extra\_chain\_cert. 




[endsect]


[endsect]

[section:use_certificate_chain_file ssl::context::use_certificate_chain_file]

[indexterm2 boost_asio.indexterm.ssl__context.use_certificate_chain_file..use_certificate_chain_file..ssl::context] 
Use a certificate chain from a file. 


  void ``[link boost_asio.reference.ssl__context.use_certificate_chain_file.overload1 use_certificate_chain_file]``(
      const std::string & filename);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_certificate_chain_file.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.use_certificate_chain_file.overload2 use_certificate_chain_file]``(
      const std::string & filename,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_certificate_chain_file.overload2 more...]]``


[section:overload1 ssl::context::use_certificate_chain_file (1 of 2 overloads)]


Use a certificate chain from a file. 


  void use_certificate_chain_file(
      const std::string & filename);


This function is used to load a certificate chain into the context from a file.


[heading Parameters]
    

[variablelist
  
[[filename][The name of the file containing the certificate. The file must use the PEM format.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_certificate_chain_file`. 




[endsect]



[section:overload2 ssl::context::use_certificate_chain_file (2 of 2 overloads)]


Use a certificate chain from a file. 


  void use_certificate_chain_file(
      const std::string & filename,
      boost::system::error_code & ec);


This function is used to load a certificate chain into the context from a file.


[heading Parameters]
    

[variablelist
  
[[filename][The name of the file containing the certificate. The file must use the PEM format.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_certificate_chain_file`. 




[endsect]


[endsect]

[section:use_certificate_file ssl::context::use_certificate_file]

[indexterm2 boost_asio.indexterm.ssl__context.use_certificate_file..use_certificate_file..ssl::context] 
Use a certificate from a file. 


  void ``[link boost_asio.reference.ssl__context.use_certificate_file.overload1 use_certificate_file]``(
      const std::string & filename,
      file_format format);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_certificate_file.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.use_certificate_file.overload2 use_certificate_file]``(
      const std::string & filename,
      file_format format,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_certificate_file.overload2 more...]]``


[section:overload1 ssl::context::use_certificate_file (1 of 2 overloads)]


Use a certificate from a file. 


  void use_certificate_file(
      const std::string & filename,
      file_format format);


This function is used to load a certificate into the context from a file.


[heading Parameters]
    

[variablelist
  
[[filename][The name of the file containing the certificate.]]

[[format][The file format (ASN.1 or PEM).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_certificate_file`. 




[endsect]



[section:overload2 ssl::context::use_certificate_file (2 of 2 overloads)]


Use a certificate from a file. 


  void use_certificate_file(
      const std::string & filename,
      file_format format,
      boost::system::error_code & ec);


This function is used to load a certificate into the context from a file.


[heading Parameters]
    

[variablelist
  
[[filename][The name of the file containing the certificate.]]

[[format][The file format (ASN.1 or PEM).]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_certificate_file`. 




[endsect]


[endsect]

[section:use_private_key ssl::context::use_private_key]

[indexterm2 boost_asio.indexterm.ssl__context.use_private_key..use_private_key..ssl::context] 
Use a private key from a memory buffer. 


  void ``[link boost_asio.reference.ssl__context.use_private_key.overload1 use_private_key]``(
      const const_buffer & private_key,
      file_format format);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_private_key.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.use_private_key.overload2 use_private_key]``(
      const const_buffer & private_key,
      file_format format,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_private_key.overload2 more...]]``


[section:overload1 ssl::context::use_private_key (1 of 2 overloads)]


Use a private key from a memory buffer. 


  void use_private_key(
      const const_buffer & private_key,
      file_format format);


This function is used to load a private key into the context from a buffer.


[heading Parameters]
    

[variablelist
  
[[private_key][The buffer containing the private key.]]

[[format][The private key format (ASN.1 or PEM).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_PrivateKey` or SSL\_CTX\_use\_PrivateKey\_ASN1. 




[endsect]



[section:overload2 ssl::context::use_private_key (2 of 2 overloads)]


Use a private key from a memory buffer. 


  void use_private_key(
      const const_buffer & private_key,
      file_format format,
      boost::system::error_code & ec);


This function is used to load a private key into the context from a buffer.


[heading Parameters]
    

[variablelist
  
[[private_key][The buffer containing the private key.]]

[[format][The private key format (ASN.1 or PEM).]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_PrivateKey` or SSL\_CTX\_use\_PrivateKey\_ASN1. 




[endsect]


[endsect]

[section:use_private_key_file ssl::context::use_private_key_file]

[indexterm2 boost_asio.indexterm.ssl__context.use_private_key_file..use_private_key_file..ssl::context] 
Use a private key from a file. 


  void ``[link boost_asio.reference.ssl__context.use_private_key_file.overload1 use_private_key_file]``(
      const std::string & filename,
      file_format format);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_private_key_file.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.use_private_key_file.overload2 use_private_key_file]``(
      const std::string & filename,
      file_format format,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_private_key_file.overload2 more...]]``


[section:overload1 ssl::context::use_private_key_file (1 of 2 overloads)]


Use a private key from a file. 


  void use_private_key_file(
      const std::string & filename,
      file_format format);


This function is used to load a private key into the context from a file.


[heading Parameters]
    

[variablelist
  
[[filename][The name of the file containing the private key.]]

[[format][The file format (ASN.1 or PEM).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_PrivateKey_file`. 




[endsect]



[section:overload2 ssl::context::use_private_key_file (2 of 2 overloads)]


Use a private key from a file. 


  void use_private_key_file(
      const std::string & filename,
      file_format format,
      boost::system::error_code & ec);


This function is used to load a private key into the context from a file.


[heading Parameters]
    

[variablelist
  
[[filename][The name of the file containing the private key.]]

[[format][The file format (ASN.1 or PEM).]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_PrivateKey_file`. 




[endsect]


[endsect]

[section:use_rsa_private_key ssl::context::use_rsa_private_key]

[indexterm2 boost_asio.indexterm.ssl__context.use_rsa_private_key..use_rsa_private_key..ssl::context] 
Use an RSA private key from a memory buffer. 


  void ``[link boost_asio.reference.ssl__context.use_rsa_private_key.overload1 use_rsa_private_key]``(
      const const_buffer & private_key,
      file_format format);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_rsa_private_key.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.use_rsa_private_key.overload2 use_rsa_private_key]``(
      const const_buffer & private_key,
      file_format format,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_rsa_private_key.overload2 more...]]``


[section:overload1 ssl::context::use_rsa_private_key (1 of 2 overloads)]


Use an RSA private key from a memory buffer. 


  void use_rsa_private_key(
      const const_buffer & private_key,
      file_format format);


This function is used to load an RSA private key into the context from a buffer.


[heading Parameters]
    

[variablelist
  
[[private_key][The buffer containing the RSA private key.]]

[[format][The private key format (ASN.1 or PEM).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_RSAPrivateKey` or SSL\_CTX\_use\_RSAPrivateKey\_ASN1. 




[endsect]



[section:overload2 ssl::context::use_rsa_private_key (2 of 2 overloads)]


Use an RSA private key from a memory buffer. 


  void use_rsa_private_key(
      const const_buffer & private_key,
      file_format format,
      boost::system::error_code & ec);


This function is used to load an RSA private key into the context from a buffer.


[heading Parameters]
    

[variablelist
  
[[private_key][The buffer containing the RSA private key.]]

[[format][The private key format (ASN.1 or PEM).]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_RSAPrivateKey` or SSL\_CTX\_use\_RSAPrivateKey\_ASN1. 




[endsect]


[endsect]

[section:use_rsa_private_key_file ssl::context::use_rsa_private_key_file]

[indexterm2 boost_asio.indexterm.ssl__context.use_rsa_private_key_file..use_rsa_private_key_file..ssl::context] 
Use an RSA private key from a file. 


  void ``[link boost_asio.reference.ssl__context.use_rsa_private_key_file.overload1 use_rsa_private_key_file]``(
      const std::string & filename,
      file_format format);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_rsa_private_key_file.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.use_rsa_private_key_file.overload2 use_rsa_private_key_file]``(
      const std::string & filename,
      file_format format,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_rsa_private_key_file.overload2 more...]]``


[section:overload1 ssl::context::use_rsa_private_key_file (1 of 2 overloads)]


Use an RSA private key from a file. 


  void use_rsa_private_key_file(
      const std::string & filename,
      file_format format);


This function is used to load an RSA private key into the context from a file.


[heading Parameters]
    

[variablelist
  
[[filename][The name of the file containing the RSA private key.]]

[[format][The file format (ASN.1 or PEM).]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_RSAPrivateKey_file`. 




[endsect]



[section:overload2 ssl::context::use_rsa_private_key_file (2 of 2 overloads)]


Use an RSA private key from a file. 


  void use_rsa_private_key_file(
      const std::string & filename,
      file_format format,
      boost::system::error_code & ec);


This function is used to load an RSA private key into the context from a file.


[heading Parameters]
    

[variablelist
  
[[filename][The name of the file containing the RSA private key.]]

[[format][The file format (ASN.1 or PEM).]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_use_RSAPrivateKey_file`. 




[endsect]


[endsect]

[section:use_tmp_dh ssl::context::use_tmp_dh]

[indexterm2 boost_asio.indexterm.ssl__context.use_tmp_dh..use_tmp_dh..ssl::context] 
Use the specified memory buffer to obtain the temporary Diffie-Hellman parameters. 


  void ``[link boost_asio.reference.ssl__context.use_tmp_dh.overload1 use_tmp_dh]``(
      const const_buffer & dh);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_tmp_dh.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.use_tmp_dh.overload2 use_tmp_dh]``(
      const const_buffer & dh,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_tmp_dh.overload2 more...]]``


[section:overload1 ssl::context::use_tmp_dh (1 of 2 overloads)]


Use the specified memory buffer to obtain the temporary Diffie-Hellman parameters. 


  void use_tmp_dh(
      const const_buffer & dh);


This function is used to load Diffie-Hellman parameters into the context from a buffer.


[heading Parameters]
    

[variablelist
  
[[dh][The memory buffer containing the Diffie-Hellman parameters. The buffer must use the PEM format.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_tmp_dh`. 




[endsect]



[section:overload2 ssl::context::use_tmp_dh (2 of 2 overloads)]


Use the specified memory buffer to obtain the temporary Diffie-Hellman parameters. 


  void use_tmp_dh(
      const const_buffer & dh,
      boost::system::error_code & ec);


This function is used to load Diffie-Hellman parameters into the context from a buffer.


[heading Parameters]
    

[variablelist
  
[[dh][The memory buffer containing the Diffie-Hellman parameters. The buffer must use the PEM format.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_tmp_dh`. 




[endsect]


[endsect]

[section:use_tmp_dh_file ssl::context::use_tmp_dh_file]

[indexterm2 boost_asio.indexterm.ssl__context.use_tmp_dh_file..use_tmp_dh_file..ssl::context] 
Use the specified file to obtain the temporary Diffie-Hellman parameters. 


  void ``[link boost_asio.reference.ssl__context.use_tmp_dh_file.overload1 use_tmp_dh_file]``(
      const std::string & filename);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_tmp_dh_file.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__context.use_tmp_dh_file.overload2 use_tmp_dh_file]``(
      const std::string & filename,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__context.use_tmp_dh_file.overload2 more...]]``


[section:overload1 ssl::context::use_tmp_dh_file (1 of 2 overloads)]


Use the specified file to obtain the temporary Diffie-Hellman parameters. 


  void use_tmp_dh_file(
      const std::string & filename);


This function is used to load Diffie-Hellman parameters into the context from a file.


[heading Parameters]
    

[variablelist
  
[[filename][The name of the file containing the Diffie-Hellman parameters. The file must use the PEM format.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_tmp_dh`. 




[endsect]



[section:overload2 ssl::context::use_tmp_dh_file (2 of 2 overloads)]


Use the specified file to obtain the temporary Diffie-Hellman parameters. 


  void use_tmp_dh_file(
      const std::string & filename,
      boost::system::error_code & ec);


This function is used to load Diffie-Hellman parameters into the context from a file.


[heading Parameters]
    

[variablelist
  
[[filename][The name of the file containing the Diffie-Hellman parameters. The file must use the PEM format.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_CTX_set_tmp_dh`. 




[endsect]


[endsect]


[section:_context ssl::context::~context]

[indexterm2 boost_asio.indexterm.ssl__context._context..~context..ssl::context] 
Destructor. 


  ~context();



[endsect]



[endsect]

[section:ssl__context_base ssl::context_base]

[indexterm1 boost_asio.indexterm.ssl__context_base..ssl::context_base]


The [link boost_asio.reference.ssl__context_base `ssl::context_base`] class is used as a base for the basic\_context class template so that we have a common place to define various enums. 


  class context_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ssl__context_base.file_format [*file_format]]]
    [File format types. ]
  
  ]

  [

    [[link boost_asio.reference.ssl__context_base.method [*method]]]
    [Different methods supported by a context. ]
  
  ]

  [

    [[link boost_asio.reference.ssl__context_base.options [*options]]]
    [Bitmask type for SSL options. ]
  
  ]

  [

    [[link boost_asio.reference.ssl__context_base.password_purpose [*password_purpose]]]
    [Purpose of PEM password. ]
  
  ]

]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ssl__context_base._context_base [*~context_base]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ssl__context_base.default_workarounds [*default_workarounds]] [static]]
    [Implement various bug workarounds. ]
  ]

  [
    [[link boost_asio.reference.ssl__context_base.no_compression [*no_compression]] [static]]
    [Disable compression. Compression is disabled by default. ]
  ]

  [
    [[link boost_asio.reference.ssl__context_base.no_sslv2 [*no_sslv2]] [static]]
    [Disable SSL v2. ]
  ]

  [
    [[link boost_asio.reference.ssl__context_base.no_sslv3 [*no_sslv3]] [static]]
    [Disable SSL v3. ]
  ]

  [
    [[link boost_asio.reference.ssl__context_base.no_tlsv1 [*no_tlsv1]] [static]]
    [Disable TLS v1. ]
  ]

  [
    [[link boost_asio.reference.ssl__context_base.no_tlsv1_1 [*no_tlsv1_1]] [static]]
    [Disable TLS v1.1. ]
  ]

  [
    [[link boost_asio.reference.ssl__context_base.no_tlsv1_2 [*no_tlsv1_2]] [static]]
    [Disable TLS v1.2. ]
  ]

  [
    [[link boost_asio.reference.ssl__context_base.no_tlsv1_3 [*no_tlsv1_3]] [static]]
    [Disable TLS v1.3. ]
  ]

  [
    [[link boost_asio.reference.ssl__context_base.single_dh_use [*single_dh_use]] [static]]
    [Always create a new key when using tmp_dh parameters. ]
  ]

]

[heading Requirements]

['Header: ][^boost/asio/ssl/context_base.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[section:default_workarounds ssl::context_base::default_workarounds]

[indexterm2 boost_asio.indexterm.ssl__context_base.default_workarounds..default_workarounds..ssl::context_base] 
Implement various bug workarounds. 


  static const long default_workarounds = implementation_defined;



[endsect]



[section:file_format ssl::context_base::file_format]

[indexterm2 boost_asio.indexterm.ssl__context_base.file_format..file_format..ssl::context_base] 
File format types. 

  enum file_format

[indexterm2 boost_asio.indexterm.ssl__context_base.file_format.asn1..asn1..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.file_format.pem..pem..ssl::context_base]

[heading Values]
[variablelist

  [
    [asn1]
    [ASN.1 file. ]
  ]

  [
    [pem]
    [PEM file. ]
  ]

]



[endsect]



[section:method ssl::context_base::method]

[indexterm2 boost_asio.indexterm.ssl__context_base.method..method..ssl::context_base] 
Different methods supported by a context. 

  enum method

[indexterm2 boost_asio.indexterm.ssl__context_base.method.sslv2..sslv2..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.sslv2_client..sslv2_client..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.sslv2_server..sslv2_server..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.sslv3..sslv3..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.sslv3_client..sslv3_client..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.sslv3_server..sslv3_server..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tlsv1..tlsv1..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tlsv1_client..tlsv1_client..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tlsv1_server..tlsv1_server..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.sslv23..sslv23..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.sslv23_client..sslv23_client..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.sslv23_server..sslv23_server..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tlsv11..tlsv11..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tlsv11_client..tlsv11_client..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tlsv11_server..tlsv11_server..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tlsv12..tlsv12..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tlsv12_client..tlsv12_client..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tlsv12_server..tlsv12_server..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tlsv13..tlsv13..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tlsv13_client..tlsv13_client..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tlsv13_server..tlsv13_server..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tls..tls..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tls_client..tls_client..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.method.tls_server..tls_server..ssl::context_base]

[heading Values]
[variablelist

  [
    [sslv2]
    [Generic SSL version 2. ]
  ]

  [
    [sslv2_client]
    [SSL version 2 client. ]
  ]

  [
    [sslv2_server]
    [SSL version 2 server. ]
  ]

  [
    [sslv3]
    [Generic SSL version 3. ]
  ]

  [
    [sslv3_client]
    [SSL version 3 client. ]
  ]

  [
    [sslv3_server]
    [SSL version 3 server. ]
  ]

  [
    [tlsv1]
    [Generic TLS version 1. ]
  ]

  [
    [tlsv1_client]
    [TLS version 1 client. ]
  ]

  [
    [tlsv1_server]
    [TLS version 1 server. ]
  ]

  [
    [sslv23]
    [Generic SSL/TLS. ]
  ]

  [
    [sslv23_client]
    [SSL/TLS client. ]
  ]

  [
    [sslv23_server]
    [SSL/TLS server. ]
  ]

  [
    [tlsv11]
    [Generic TLS version 1.1. ]
  ]

  [
    [tlsv11_client]
    [TLS version 1.1 client. ]
  ]

  [
    [tlsv11_server]
    [TLS version 1.1 server. ]
  ]

  [
    [tlsv12]
    [Generic TLS version 1.2. ]
  ]

  [
    [tlsv12_client]
    [TLS version 1.2 client. ]
  ]

  [
    [tlsv12_server]
    [TLS version 1.2 server. ]
  ]

  [
    [tlsv13]
    [Generic TLS version 1.3. ]
  ]

  [
    [tlsv13_client]
    [TLS version 1.3 client. ]
  ]

  [
    [tlsv13_server]
    [TLS version 1.3 server. ]
  ]

  [
    [tls]
    [Generic TLS. ]
  ]

  [
    [tls_client]
    [TLS client. ]
  ]

  [
    [tls_server]
    [TLS server. ]
  ]

]



[endsect]



[section:no_compression ssl::context_base::no_compression]

[indexterm2 boost_asio.indexterm.ssl__context_base.no_compression..no_compression..ssl::context_base] 
Disable compression. Compression is disabled by default. 


  static const long no_compression = implementation_defined;



[endsect]



[section:no_sslv2 ssl::context_base::no_sslv2]

[indexterm2 boost_asio.indexterm.ssl__context_base.no_sslv2..no_sslv2..ssl::context_base] 
Disable SSL v2. 


  static const long no_sslv2 = implementation_defined;



[endsect]



[section:no_sslv3 ssl::context_base::no_sslv3]

[indexterm2 boost_asio.indexterm.ssl__context_base.no_sslv3..no_sslv3..ssl::context_base] 
Disable SSL v3. 


  static const long no_sslv3 = implementation_defined;



[endsect]



[section:no_tlsv1 ssl::context_base::no_tlsv1]

[indexterm2 boost_asio.indexterm.ssl__context_base.no_tlsv1..no_tlsv1..ssl::context_base] 
Disable TLS v1. 


  static const long no_tlsv1 = implementation_defined;



[endsect]



[section:no_tlsv1_1 ssl::context_base::no_tlsv1_1]

[indexterm2 boost_asio.indexterm.ssl__context_base.no_tlsv1_1..no_tlsv1_1..ssl::context_base] 
Disable TLS v1.1. 


  static const long no_tlsv1_1 = implementation_defined;



[endsect]



[section:no_tlsv1_2 ssl::context_base::no_tlsv1_2]

[indexterm2 boost_asio.indexterm.ssl__context_base.no_tlsv1_2..no_tlsv1_2..ssl::context_base] 
Disable TLS v1.2. 


  static const long no_tlsv1_2 = implementation_defined;



[endsect]



[section:no_tlsv1_3 ssl::context_base::no_tlsv1_3]

[indexterm2 boost_asio.indexterm.ssl__context_base.no_tlsv1_3..no_tlsv1_3..ssl::context_base] 
Disable TLS v1.3. 


  static const long no_tlsv1_3 = implementation_defined;



[endsect]



[section:options ssl::context_base::options]

[indexterm2 boost_asio.indexterm.ssl__context_base.options..options..ssl::context_base] 
Bitmask type for SSL options. 


  typedef long options;



[heading Requirements]

['Header: ][^boost/asio/ssl/context_base.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:password_purpose ssl::context_base::password_purpose]

[indexterm2 boost_asio.indexterm.ssl__context_base.password_purpose..password_purpose..ssl::context_base] 
Purpose of PEM password. 

  enum password_purpose

[indexterm2 boost_asio.indexterm.ssl__context_base.password_purpose.for_reading..for_reading..ssl::context_base]
[indexterm2 boost_asio.indexterm.ssl__context_base.password_purpose.for_writing..for_writing..ssl::context_base]

[heading Values]
[variablelist

  [
    [for_reading]
    [The password is needed for reading/decryption. ]
  ]

  [
    [for_writing]
    [The password is needed for writing/encryption. ]
  ]

]



[endsect]



[section:single_dh_use ssl::context_base::single_dh_use]

[indexterm2 boost_asio.indexterm.ssl__context_base.single_dh_use..single_dh_use..ssl::context_base] 
Always create a new key when using tmp\_dh parameters. 


  static const long single_dh_use = implementation_defined;



[endsect]



[section:_context_base ssl::context_base::~context_base]

[indexterm2 boost_asio.indexterm.ssl__context_base._context_base..~context_base..ssl::context_base] 
Protected destructor to prevent deletion through this type. 


  ~context_base();



[endsect]



[endsect]


[section:ssl__error__get_stream_category ssl::error::get_stream_category]

[indexterm1 boost_asio.indexterm.ssl__error__get_stream_category..ssl::error::get_stream_category] 

  const boost::system::error_category & get_stream_category();


[heading Requirements]

['Header: ][^boost/asio/ssl/error.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:ssl__error__make_error_code ssl::error::make_error_code]

[indexterm1 boost_asio.indexterm.ssl__error__make_error_code..ssl::error::make_error_code] 

  boost::system::error_code make_error_code(
      stream_errors e);


[heading Requirements]

['Header: ][^boost/asio/ssl/error.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:ssl__error__stream_category ssl::error::stream_category]

[indexterm1 boost_asio.indexterm.ssl__error__stream_category..ssl::error::stream_category] 

  static const boost::system::error_category & stream_category = boost::asio::ssl::error::get_stream_category();


[heading Requirements]

['Header: ][^boost/asio/ssl/error.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:ssl__error__stream_errors ssl::error::stream_errors]

[indexterm1 boost_asio.indexterm.ssl__error__stream_errors..ssl::error::stream_errors] 
  enum stream_errors

[indexterm2 boost_asio.indexterm.ssl__error__stream_errors.stream_truncated..stream_truncated..ssl::error::stream_errors]
[indexterm2 boost_asio.indexterm.ssl__error__stream_errors.unspecified_system_error..unspecified_system_error..ssl::error::stream_errors]
[indexterm2 boost_asio.indexterm.ssl__error__stream_errors.unexpected_result..unexpected_result..ssl::error::stream_errors]

[heading Values]
[variablelist

  [
    [stream_truncated]
    [The underlying stream closed before the ssl stream gracefully shut down. ]
  ]

  [
    [unspecified_system_error]
    [The underlying SSL library returned a system error without providing further information. ]
  ]

  [
    [unexpected_result]
    [The underlying SSL library generated an unexpected result from a function call. ]
  ]

]


[heading Requirements]

['Header: ][^boost/asio/ssl/error.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]


[section:ssl__host_name_verification ssl::host_name_verification]

[indexterm1 boost_asio.indexterm.ssl__host_name_verification..ssl::host_name_verification]


Verifies a certificate against a host\_name according to the rules described in RFC 6125. 


  class host_name_verification


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ssl__host_name_verification.result_type [*result_type]]]
    [The type of the function object's result. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ssl__host_name_verification.host_name_verification [*host_name_verification]] [constructor]]
    [Constructor. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__host_name_verification.operator_lp__rp_ [*operator()]]]
    [Perform certificate verification. ]
  ]
  
]


[heading Example]
  
The following example shows how to synchronously open a secure connection to a given host name: 

   using boost::asio::ip::tcp;
   namespace ssl = boost::asio::ssl;
   typedef ssl::stream<tcp::socket> ssl_socket;

   // Create a context that uses the default paths for finding CA certificates.
   ssl::context ctx(ssl::context::sslv23);
   ctx.set_default_verify_paths();

   // Open a socket and connect it to the remote host.
   boost::asio::io_context io_context;
   ssl_socket sock(io_context, ctx);
   tcp::resolver resolver(io_context);
   tcp::resolver::query query("host.name", "https");
   boost::asio::connect(sock.lowest_layer(), resolver.resolve(query));
   sock.lowest_layer().set_option(tcp::no_delay(true));

   // Perform SSL handshake and verify the remote host's certificate.
   sock.set_verify_mode(ssl::verify_peer);
   sock.set_verify_callback(ssl::host_name_verification("host.name"));
   sock.handshake(ssl_socket::client);

   // ... read and write as normal ...






[heading Requirements]

['Header: ][^boost/asio/ssl/host_name_verification.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[section:host_name_verification ssl::host_name_verification::host_name_verification]

[indexterm2 boost_asio.indexterm.ssl__host_name_verification.host_name_verification..host_name_verification..ssl::host_name_verification] 
Constructor. 


  host_name_verification(
      const std::string & host);



[endsect]



[section:operator_lp__rp_ ssl::host_name_verification::operator()]

[indexterm2 boost_asio.indexterm.ssl__host_name_verification.operator_lp__rp_..operator()..ssl::host_name_verification] 
Perform certificate verification. 


  bool operator()(
      bool preverified,
      verify_context & ctx) const;



[endsect]



[section:result_type ssl::host_name_verification::result_type]

[indexterm2 boost_asio.indexterm.ssl__host_name_verification.result_type..result_type..ssl::host_name_verification] 
The type of the function object's result. 


  typedef bool result_type;



[heading Requirements]

['Header: ][^boost/asio/ssl/host_name_verification.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[endsect]

[section:ssl__rfc2818_verification ssl::rfc2818_verification]

[indexterm1 boost_asio.indexterm.ssl__rfc2818_verification..ssl::rfc2818_verification]


(Deprecated. Use [link boost_asio.reference.ssl__host_name_verification `ssl::host_name_verification`].) Verifies a certificate against a hostname according to the rules described in RFC 2818. 


  class rfc2818_verification


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ssl__rfc2818_verification.result_type [*result_type]]]
    [The type of the function object's result. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ssl__rfc2818_verification.operator_lp__rp_ [*operator()]]]
    [Perform certificate verification. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__rfc2818_verification.rfc2818_verification [*rfc2818_verification]] [constructor]]
    [Constructor. ]
  ]
  
]


[heading Example]
  
The following example shows how to synchronously open a secure connection to a given host name: 

   using boost::asio::ip::tcp;
   namespace ssl = boost::asio::ssl;
   typedef ssl::stream<tcp::socket> ssl_socket;

   // Create a context that uses the default paths for finding CA certificates.
   ssl::context ctx(ssl::context::sslv23);
   ctx.set_default_verify_paths();

   // Open a socket and connect it to the remote host.
   boost::asio::io_context io_context;
   ssl_socket sock(io_context, ctx);
   tcp::resolver resolver(io_context);
   tcp::resolver::query query("host.name", "https");
   boost::asio::connect(sock.lowest_layer(), resolver.resolve(query));
   sock.lowest_layer().set_option(tcp::no_delay(true));

   // Perform SSL handshake and verify the remote host's certificate.
   sock.set_verify_mode(ssl::verify_peer);
   sock.set_verify_callback(ssl::rfc2818_verification("host.name"));
   sock.handshake(ssl_socket::client);

   // ... read and write as normal ...






[heading Requirements]

['Header: ][^boost/asio/ssl/rfc2818_verification.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[section:operator_lp__rp_ ssl::rfc2818_verification::operator()]

[indexterm2 boost_asio.indexterm.ssl__rfc2818_verification.operator_lp__rp_..operator()..ssl::rfc2818_verification] 
Perform certificate verification. 


  bool operator()(
      bool preverified,
      verify_context & ctx) const;



[endsect]



[section:result_type ssl::rfc2818_verification::result_type]

[indexterm2 boost_asio.indexterm.ssl__rfc2818_verification.result_type..result_type..ssl::rfc2818_verification] 
The type of the function object's result. 


  typedef bool result_type;



[heading Requirements]

['Header: ][^boost/asio/ssl/rfc2818_verification.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:rfc2818_verification ssl::rfc2818_verification::rfc2818_verification]

[indexterm2 boost_asio.indexterm.ssl__rfc2818_verification.rfc2818_verification..rfc2818_verification..ssl::rfc2818_verification] 
Constructor. 


  rfc2818_verification(
      const std::string & host);



[endsect]



[endsect]

[section:ssl__stream ssl::stream]

[indexterm1 boost_asio.indexterm.ssl__stream..ssl::stream]


Provides stream-oriented functionality using SSL. 


  template<
      typename Stream>
  class stream :
    public ssl::stream_base,
    noncopyable


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ssl__stream__impl_struct [*impl_struct]]]
    [Structure for use with deprecated impl_type. ]
  
  ]

  [

    [[link boost_asio.reference.ssl__stream.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.ssl__stream.handshake_type [*handshake_type]]]
    [Different handshake types. ]
  
  ]

  [

    [[link boost_asio.reference.ssl__stream.lowest_layer_type [*lowest_layer_type]]]
    [The type of the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.ssl__stream.native_handle_type [*native_handle_type]]]
    [The native handle type of the SSL stream. ]
  
  ]

  [

    [[link boost_asio.reference.ssl__stream.next_layer_type [*next_layer_type]]]
    [The type of the next layer. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ssl__stream.async_handshake [*async_handshake]]]
    [Start an asynchronous SSL handshake. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.async_shutdown [*async_shutdown]]]
    [Asynchronously shut down SSL on the stream. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.handshake [*handshake]]]
    [Perform SSL handshaking. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.native_handle [*native_handle]]]
    [Get the underlying implementation in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.next_layer [*next_layer]]]
    [Get a reference to the next layer. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.operator_eq_ [*operator=]]]
    [Move-assign a stream from another. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.read_some [*read_some]]]
    [Read some data from the stream. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.set_verify_callback [*set_verify_callback]]]
    [Set the callback used to verify peer certificates. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.set_verify_depth [*set_verify_depth]]]
    [Set the peer verification depth. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.set_verify_mode [*set_verify_mode]]]
    [Set the peer verification mode. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.shutdown [*shutdown]]]
    [Shut down SSL on the stream. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.stream [*stream]] [constructor]]
    [Construct a stream. 
     [hr]
     Move-construct a stream from another. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream.write_some [*write_some]]]
    [Write some data to the stream. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__stream._stream [*~stream]] [destructor]]
    [Destructor. ]
  ]
  
]

The stream class template provides asynchronous and blocking stream-oriented functionality using SSL.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. The application must also ensure that all asynchronous operations are performed within the same implicit or explicit strand.


[heading Example]
  
To use the SSL stream template with an `ip::tcp::socket`, you would write: 

   boost::asio::io_context my_context;
   boost::asio::ssl::context ctx(boost::asio::ssl::context::sslv23);
   boost::asio::ssl::stream<asio:ip::tcp::socket> sock(my_context, ctx);







[heading Requirements]

['Header: ][^boost/asio/ssl/stream.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]

[section:async_handshake ssl::stream::async_handshake]

[indexterm2 boost_asio.indexterm.ssl__stream.async_handshake..async_handshake..ssl::stream] 
Start an asynchronous SSL handshake. 


  template<
      typename ``[link boost_asio.reference.HandshakeHandler HandshakeHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.ssl__stream.async_handshake.overload1 async_handshake]``(
      handshake_type type,
      HandshakeHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.async_handshake.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.BufferedHandshakeHandler BufferedHandshakeHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` ``[link boost_asio.reference.ssl__stream.async_handshake.overload2 async_handshake]``(
      handshake_type type,
      const ConstBufferSequence & buffers,
      BufferedHandshakeHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.async_handshake.overload2 more...]]``


[section:overload1 ssl::stream::async_handshake (1 of 2 overloads)]


Start an asynchronous SSL handshake. 


  template<
      typename ``[link boost_asio.reference.HandshakeHandler HandshakeHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_handshake(
      handshake_type type,
      HandshakeHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously perform an SSL handshake on the stream. This function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[type][The type of handshaking to be performed, i.e. as a client or as a server.]]

[[handler][The handler to be called when the handshake operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation.
   ); 
``
]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `Stream` type's `async_read_some` and `async_write_some` operations. 


[endsect]



[section:overload2 ssl::stream::async_handshake (2 of 2 overloads)]


Start an asynchronous SSL handshake. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.BufferedHandshakeHandler BufferedHandshakeHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_handshake(
      handshake_type type,
      const ConstBufferSequence & buffers,
      BufferedHandshakeHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously perform an SSL handshake on the stream. This function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[type][The type of handshaking to be performed, i.e. as a client or as a server.]]

[[buffers][The buffered data to be reused for the handshake. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the handshake operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred // Amount of buffers used in handshake.
   ); 
``
]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `Stream` type's `async_read_some` and `async_write_some` operations. 


[endsect]


[endsect]


[section:async_read_some ssl::stream::async_read_some]

[indexterm2 boost_asio.indexterm.ssl__stream.async_read_some..async_read_some..ssl::stream] 
Start an asynchronous read. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_some(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read one or more bytes of data from the stream. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][The buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes read.
   ); 
``
]]

]


[heading Remarks]
      
The async\_read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.async_read `async_read`]  function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `Stream` type's `async_read_some` and `async_write_some` operations. 


[endsect]



[section:async_shutdown ssl::stream::async_shutdown]

[indexterm2 boost_asio.indexterm.ssl__stream.async_shutdown..async_shutdown..ssl::stream] 
Asynchronously shut down SSL on the stream. 


  template<
      typename ``[link boost_asio.reference.ShutdownHandler ShutdownHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_shutdown(
      ShutdownHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously shut down SSL on the stream. This function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be called when the handshake operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation.
   ); 
``
]]

]


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `Stream` type's `async_read_some` and `async_write_some` operations. 


[endsect]



[section:async_write_some ssl::stream::async_write_some]

[indexterm2 boost_asio.indexterm.ssl__stream.async_write_some..async_write_some..ssl::stream] 
Start an asynchronous write. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_some(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write one or more bytes of data to the stream. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][The data to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes written.
   ); 
``
]]

]


[heading Remarks]
      
The async\_write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.async_write `async_write`]  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 

if they are also supported by the `Stream` type's `async_read_some` and `async_write_some` operations. 


[endsect]



[section:executor_type ssl::stream::executor_type]

[indexterm2 boost_asio.indexterm.ssl__stream.executor_type..executor_type..ssl::stream] 
The type of the executor associated with the object. 


  typedef lowest_layer_type::executor_type executor_type;



[heading Requirements]

['Header: ][^boost/asio/ssl/stream.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:get_executor ssl::stream::get_executor]

[indexterm2 boost_asio.indexterm.ssl__stream.get_executor..get_executor..ssl::stream] 
Get the executor associated with the object. 


  executor_type get_executor();


This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.


[heading Return Value]
      
A copy of the executor that stream will use to dispatch handlers. 




[endsect]


[section:handshake ssl::stream::handshake]

[indexterm2 boost_asio.indexterm.ssl__stream.handshake..handshake..ssl::stream] 
Perform SSL handshaking. 


  void ``[link boost_asio.reference.ssl__stream.handshake.overload1 handshake]``(
      handshake_type type);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.handshake.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__stream.handshake.overload2 handshake]``(
      handshake_type type,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.handshake.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  void ``[link boost_asio.reference.ssl__stream.handshake.overload3 handshake]``(
      handshake_type type,
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.handshake.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  void ``[link boost_asio.reference.ssl__stream.handshake.overload4 handshake]``(
      handshake_type type,
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.handshake.overload4 more...]]``


[section:overload1 ssl::stream::handshake (1 of 4 overloads)]


Perform SSL handshaking. 


  void handshake(
      handshake_type type);


This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.


[heading Parameters]
    

[variablelist
  
[[type][The type of handshaking to be performed, i.e. as a client or as a server.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 ssl::stream::handshake (2 of 4 overloads)]


Perform SSL handshaking. 


  void handshake(
      handshake_type type,
      boost::system::error_code & ec);


This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.


[heading Parameters]
    

[variablelist
  
[[type][The type of handshaking to be performed, i.e. as a client or as a server.]]

[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]



[section:overload3 ssl::stream::handshake (3 of 4 overloads)]


Perform SSL handshaking. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  void handshake(
      handshake_type type,
      const ConstBufferSequence & buffers);


This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.


[heading Parameters]
    

[variablelist
  
[[type][The type of handshaking to be performed, i.e. as a client or as a server.]]

[[buffers][The buffered data to be reused for the handshake.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 ssl::stream::handshake (4 of 4 overloads)]


Perform SSL handshaking. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  void handshake(
      handshake_type type,
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.


[heading Parameters]
    

[variablelist
  
[[type][The type of handshaking to be performed, i.e. as a client or as a server.]]

[[buffers][The buffered data to be reused for the handshake.]]

[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:handshake_type ssl::stream::handshake_type]

[indexterm2 boost_asio.indexterm.ssl__stream.handshake_type..handshake_type..ssl::stream] 
Different handshake types. 

  enum handshake_type

[indexterm2 boost_asio.indexterm.ssl__stream.handshake_type.client..client..ssl::stream]
[indexterm2 boost_asio.indexterm.ssl__stream.handshake_type.server..server..ssl::stream]

[heading Values]
[variablelist

  [
    [client]
    [Perform handshaking as a client. ]
  ]

  [
    [server]
    [Perform handshaking as a server. ]
  ]

]



[endsect]


[section:lowest_layer ssl::stream::lowest_layer]

[indexterm2 boost_asio.indexterm.ssl__stream.lowest_layer..lowest_layer..ssl::stream] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.ssl__stream.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.lowest_layer.overload1 more...]]``

  const lowest_layer_type & ``[link boost_asio.reference.ssl__stream.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.lowest_layer.overload2 more...]]``


[section:overload1 ssl::stream::lowest_layer (1 of 2 overloads)]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of stream layers.


[heading Return Value]
      
A reference to the lowest layer in the stack of stream layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 ssl::stream::lowest_layer (2 of 2 overloads)]


Get a reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a reference to the lowest layer in a stack of stream layers.


[heading Return Value]
      
A reference to the lowest layer in the stack of stream layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type ssl::stream::lowest_layer_type]

[indexterm2 boost_asio.indexterm.ssl__stream.lowest_layer_type..lowest_layer_type..ssl::stream] 
The type of the lowest layer. 


  typedef next_layer_type::lowest_layer_type lowest_layer_type;



[heading Requirements]

['Header: ][^boost/asio/ssl/stream.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:native_handle ssl::stream::native_handle]

[indexterm2 boost_asio.indexterm.ssl__stream.native_handle..native_handle..ssl::stream] 
Get the underlying implementation in the native type. 


  native_handle_type native_handle();


This function may be used to obtain the underlying implementation of the context. This is intended to allow access to context functionality that is not otherwise provided.


[heading Example]
  
The `native_handle()` function returns a pointer of type `SSL*` that is suitable for passing to functions such as `SSL_get_verify_result` and `SSL_get_peer_certificate:` 

   boost::asio::ssl::stream<asio:ip::tcp::socket> sock(my_context, ctx);

   // ... establish connection and perform handshake ...

   if (X509* cert = SSL_get_peer_certificate(sock.native_handle()))
   {
     if (SSL_get_verify_result(sock.native_handle()) == X509_V_OK)
     {
       // ...
     }
   }







[endsect]



[section:native_handle_type ssl::stream::native_handle_type]

[indexterm2 boost_asio.indexterm.ssl__stream.native_handle_type..native_handle_type..ssl::stream] 
The native handle type of the SSL stream. 


  typedef SSL * native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/ssl/stream.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]


[section:next_layer ssl::stream::next_layer]

[indexterm2 boost_asio.indexterm.ssl__stream.next_layer..next_layer..ssl::stream] 
Get a reference to the next layer. 


  const next_layer_type & ``[link boost_asio.reference.ssl__stream.next_layer.overload1 next_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.next_layer.overload1 more...]]``

  next_layer_type & ``[link boost_asio.reference.ssl__stream.next_layer.overload2 next_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.next_layer.overload2 more...]]``


[section:overload1 ssl::stream::next_layer (1 of 2 overloads)]


Get a reference to the next layer. 


  const next_layer_type & next_layer() const;


This function returns a reference to the next layer in a stack of stream layers.


[heading Return Value]
      
A reference to the next layer in the stack of stream layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 ssl::stream::next_layer (2 of 2 overloads)]


Get a reference to the next layer. 


  next_layer_type & next_layer();


This function returns a reference to the next layer in a stack of stream layers.


[heading Return Value]
      
A reference to the next layer in the stack of stream layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:next_layer_type ssl::stream::next_layer_type]

[indexterm2 boost_asio.indexterm.ssl__stream.next_layer_type..next_layer_type..ssl::stream] 
The type of the next layer. 


  typedef remove_reference< Stream >::type next_layer_type;



[heading Requirements]

['Header: ][^boost/asio/ssl/stream.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:operator_eq_ ssl::stream::operator=]

[indexterm2 boost_asio.indexterm.ssl__stream.operator_eq_..operator=..ssl::stream] 
Move-assign a stream from another. 


  stream & operator=(
      stream && other);



[heading Parameters]
    

[variablelist
  
[[other][The other stream object from which the move will occur. Must have no outstanding asynchronous operations associated with it. Following the move, `other` has a valid but unspecified state where the only safe operation is destruction, or use as the target of a move assignment. ]]

]




[endsect]


[section:read_some ssl::stream::read_some]

[indexterm2 boost_asio.indexterm.ssl__stream.read_some..read_some..ssl::stream] 
Read some data from the stream. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.ssl__stream.read_some.overload1 read_some]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.read_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.ssl__stream.read_some.overload2 read_some]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.read_some.overload2 more...]]``


[section:overload1 ssl::stream::read_some (1 of 2 overloads)]


Read some data from the stream. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers);


This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][The buffers into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes read.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]



[section:overload2 ssl::stream::read_some (2 of 2 overloads)]


Read some data from the stream. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][The buffers into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. Returns 0 if an error occurred.


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]


[endsect]

[section:set_verify_callback ssl::stream::set_verify_callback]

[indexterm2 boost_asio.indexterm.ssl__stream.set_verify_callback..set_verify_callback..ssl::stream] 
Set the callback used to verify peer certificates. 


  template<
      typename VerifyCallback>
  void ``[link boost_asio.reference.ssl__stream.set_verify_callback.overload1 set_verify_callback]``(
      VerifyCallback callback);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.set_verify_callback.overload1 more...]]``

  template<
      typename VerifyCallback>
  void ``[link boost_asio.reference.ssl__stream.set_verify_callback.overload2 set_verify_callback]``(
      VerifyCallback callback,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.set_verify_callback.overload2 more...]]``


[section:overload1 ssl::stream::set_verify_callback (1 of 2 overloads)]


Set the callback used to verify peer certificates. 


  template<
      typename VerifyCallback>
  void set_verify_callback(
      VerifyCallback callback);


This function is used to specify a callback function that will be called by the implementation when it needs to verify a peer certificate.


[heading Parameters]
    

[variablelist
  
[[callback][The function object to be used for verifying a certificate. The function signature of the handler must be: 
``
   bool verify_callback(
     bool preverified, // True if the certificate passed pre-verification.
     verify_context& ctx // The peer certificate and other context.
   ); 
``
The return value of the callback is true if the certificate has passed verification, false otherwise.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_set_verify`. 




[endsect]



[section:overload2 ssl::stream::set_verify_callback (2 of 2 overloads)]


Set the callback used to verify peer certificates. 


  template<
      typename VerifyCallback>
  void set_verify_callback(
      VerifyCallback callback,
      boost::system::error_code & ec);


This function is used to specify a callback function that will be called by the implementation when it needs to verify a peer certificate.


[heading Parameters]
    

[variablelist
  
[[callback][The function object to be used for verifying a certificate. The function signature of the handler must be: 
``
   bool verify_callback(
     bool preverified, // True if the certificate passed pre-verification.
     verify_context& ctx // The peer certificate and other context.
   ); 
``
The return value of the callback is true if the certificate has passed verification, false otherwise.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_set_verify`. 




[endsect]


[endsect]

[section:set_verify_depth ssl::stream::set_verify_depth]

[indexterm2 boost_asio.indexterm.ssl__stream.set_verify_depth..set_verify_depth..ssl::stream] 
Set the peer verification depth. 


  void ``[link boost_asio.reference.ssl__stream.set_verify_depth.overload1 set_verify_depth]``(
      int depth);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.set_verify_depth.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__stream.set_verify_depth.overload2 set_verify_depth]``(
      int depth,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.set_verify_depth.overload2 more...]]``


[section:overload1 ssl::stream::set_verify_depth (1 of 2 overloads)]


Set the peer verification depth. 


  void set_verify_depth(
      int depth);


This function may be used to configure the maximum verification depth allowed by the stream.


[heading Parameters]
    

[variablelist
  
[[depth][Maximum depth for the certificate chain verification that shall be allowed.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_set_verify_depth`. 




[endsect]



[section:overload2 ssl::stream::set_verify_depth (2 of 2 overloads)]


Set the peer verification depth. 


  void set_verify_depth(
      int depth,
      boost::system::error_code & ec);


This function may be used to configure the maximum verification depth allowed by the stream.


[heading Parameters]
    

[variablelist
  
[[depth][Maximum depth for the certificate chain verification that shall be allowed.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_set_verify_depth`. 




[endsect]


[endsect]

[section:set_verify_mode ssl::stream::set_verify_mode]

[indexterm2 boost_asio.indexterm.ssl__stream.set_verify_mode..set_verify_mode..ssl::stream] 
Set the peer verification mode. 


  void ``[link boost_asio.reference.ssl__stream.set_verify_mode.overload1 set_verify_mode]``(
      verify_mode v);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.set_verify_mode.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__stream.set_verify_mode.overload2 set_verify_mode]``(
      verify_mode v,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.set_verify_mode.overload2 more...]]``


[section:overload1 ssl::stream::set_verify_mode (1 of 2 overloads)]


Set the peer verification mode. 


  void set_verify_mode(
      verify_mode v);


This function may be used to configure the peer verification mode used by the stream. The new mode will override the mode inherited from the context.


[heading Parameters]
    

[variablelist
  
[[v][A bitmask of peer verification modes. See [link boost_asio.reference.ssl__verify_mode `ssl::verify_mode`]  for available values.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
Calls `SSL_set_verify`. 




[endsect]



[section:overload2 ssl::stream::set_verify_mode (2 of 2 overloads)]


Set the peer verification mode. 


  void set_verify_mode(
      verify_mode v,
      boost::system::error_code & ec);


This function may be used to configure the peer verification mode used by the stream. The new mode will override the mode inherited from the context.


[heading Parameters]
    

[variablelist
  
[[v][A bitmask of peer verification modes. See [link boost_asio.reference.ssl__verify_mode `ssl::verify_mode`]  for available values.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Remarks]
      
Calls `SSL_set_verify`. 




[endsect]


[endsect]

[section:shutdown ssl::stream::shutdown]

[indexterm2 boost_asio.indexterm.ssl__stream.shutdown..shutdown..ssl::stream] 
Shut down SSL on the stream. 


  void ``[link boost_asio.reference.ssl__stream.shutdown.overload1 shutdown]``();
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.shutdown.overload1 more...]]``

  void ``[link boost_asio.reference.ssl__stream.shutdown.overload2 shutdown]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.shutdown.overload2 more...]]``


[section:overload1 ssl::stream::shutdown (1 of 2 overloads)]


Shut down SSL on the stream. 


  void shutdown();


This function is used to shut down SSL on the stream. The function call will block until SSL has been shut down or an error occurs.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 ssl::stream::shutdown (2 of 2 overloads)]


Shut down SSL on the stream. 


  void shutdown(
      boost::system::error_code & ec);


This function is used to shut down SSL on the stream. The function call will block until SSL has been shut down or an error occurs.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:stream ssl::stream::stream]

[indexterm2 boost_asio.indexterm.ssl__stream.stream..stream..ssl::stream] 
Construct a stream. 


  template<
      typename Arg>
  ``[link boost_asio.reference.ssl__stream.stream.overload1 stream]``(
      Arg && arg,
      context & ctx);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.stream.overload1 more...]]``


Move-construct a stream from another. 


  ``[link boost_asio.reference.ssl__stream.stream.overload2 stream]``(
      stream && other);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.stream.overload2 more...]]``


[section:overload1 ssl::stream::stream (1 of 2 overloads)]


Construct a stream. 


  template<
      typename Arg>
  stream(
      Arg && arg,
      context & ctx);


This constructor creates a stream and initialises the underlying stream object.


[heading Parameters]
    

[variablelist
  
[[arg][The argument to be passed to initialise the underlying stream.]]

[[ctx][The SSL context to be used for the stream. ]]

]




[endsect]



[section:overload2 ssl::stream::stream (2 of 2 overloads)]


Move-construct a stream from another. 


  stream(
      stream && other);



[heading Parameters]
    

[variablelist
  
[[other][The other stream object from which the move will occur. Must have no outstanding asynchronous operations associated with it. Following the move, `other` has a valid but unspecified state where the only safe operation is destruction, or use as the target of a move assignment. ]]

]




[endsect]


[endsect]

[section:write_some ssl::stream::write_some]

[indexterm2 boost_asio.indexterm.ssl__stream.write_some..write_some..ssl::stream] 
Write some data to the stream. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.ssl__stream.write_some.overload1 write_some]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.write_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.ssl__stream.write_some.overload2 write_some]``(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.ssl__stream.write_some.overload2 more...]]``


[section:overload1 ssl::stream::write_some (1 of 2 overloads)]


Write some data to the stream. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers);


This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][The data to be written.]]

]


[heading Return Value]
      
The number of bytes written.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]



[section:overload2 ssl::stream::write_some (2 of 2 overloads)]


Write some data to the stream. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][The data to be written to the stream.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. Returns 0 if an error occurred.


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]


[endsect]


[section:_stream ssl::stream::~stream]

[indexterm2 boost_asio.indexterm.ssl__stream._stream..~stream..ssl::stream] 
Destructor. 


  ~stream();



[heading Remarks]
      
A `stream` object must not be destroyed while there are pending asynchronous operations associated with it. 




[endsect]



[endsect]

[section:ssl__stream__impl_struct ssl::stream::impl_struct]

[indexterm1 boost_asio.indexterm.ssl__stream__impl_struct..ssl::stream::impl_struct]


Structure for use with deprecated impl\_type. 


  struct impl_struct


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ssl__stream__impl_struct.ssl [*ssl]]]
    []
  ]

]

[heading Requirements]

['Header: ][^boost/asio/ssl/stream.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[section:ssl ssl::stream::impl_struct::ssl]

[indexterm2 boost_asio.indexterm.ssl__stream__impl_struct.ssl..ssl..ssl::stream::impl_struct] 

  SSL * ssl;



[endsect]



[endsect]

[section:ssl__stream_base ssl::stream_base]

[indexterm1 boost_asio.indexterm.ssl__stream_base..ssl::stream_base]


The [link boost_asio.reference.ssl__stream_base `ssl::stream_base`] class is used as a base for the [link boost_asio.reference.ssl__stream `ssl::stream`] class template so that we have a common place to define various enums. 


  class stream_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ssl__stream_base.handshake_type [*handshake_type]]]
    [Different handshake types. ]
  
  ]

]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ssl__stream_base._stream_base [*~stream_base]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/ssl/stream_base.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[section:handshake_type ssl::stream_base::handshake_type]

[indexterm2 boost_asio.indexterm.ssl__stream_base.handshake_type..handshake_type..ssl::stream_base] 
Different handshake types. 

  enum handshake_type

[indexterm2 boost_asio.indexterm.ssl__stream_base.handshake_type.client..client..ssl::stream_base]
[indexterm2 boost_asio.indexterm.ssl__stream_base.handshake_type.server..server..ssl::stream_base]

[heading Values]
[variablelist

  [
    [client]
    [Perform handshaking as a client. ]
  ]

  [
    [server]
    [Perform handshaking as a server. ]
  ]

]



[endsect]



[section:_stream_base ssl::stream_base::~stream_base]

[indexterm2 boost_asio.indexterm.ssl__stream_base._stream_base..~stream_base..ssl::stream_base] 
Protected destructor to prevent deletion through this type. 


  ~stream_base();



[endsect]



[endsect]


[section:ssl__verify_client_once ssl::verify_client_once]

[indexterm1 boost_asio.indexterm.ssl__verify_client_once..ssl::verify_client_once] 
Do not request client certificate on renegotiation. Ignored unless [link boost_asio.reference.ssl__verify_peer `ssl::verify_peer`]  is set. 


  const int verify_client_once = implementation_defined;


[heading Requirements]

['Header: ][^boost/asio/ssl/verify_mode.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]


[section:ssl__verify_context ssl::verify_context]

[indexterm1 boost_asio.indexterm.ssl__verify_context..ssl::verify_context]


A simple wrapper around the X509\_STORE\_CTX type, used during verification of a peer certificate. 


  class verify_context :
    noncopyable


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.ssl__verify_context.native_handle_type [*native_handle_type]]]
    [The native handle type of the verification context. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.ssl__verify_context.native_handle [*native_handle]]]
    [Get the underlying implementation in the native type. ]
  ]
  
  [
    [[link boost_asio.reference.ssl__verify_context.verify_context [*verify_context]] [constructor]]
    [Constructor. ]
  ]
  
]


[heading Remarks]
      
The [link boost_asio.reference.ssl__verify_context `ssl::verify_context`] does not own the underlying X509\_STORE\_CTX object. 



[heading Requirements]

['Header: ][^boost/asio/ssl/verify_context.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[section:native_handle ssl::verify_context::native_handle]

[indexterm2 boost_asio.indexterm.ssl__verify_context.native_handle..native_handle..ssl::verify_context] 
Get the underlying implementation in the native type. 


  native_handle_type native_handle();


This function may be used to obtain the underlying implementation of the context. This is intended to allow access to context functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type ssl::verify_context::native_handle_type]

[indexterm2 boost_asio.indexterm.ssl__verify_context.native_handle_type..native_handle_type..ssl::verify_context] 
The native handle type of the verification context. 


  typedef X509_STORE_CTX * native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/ssl/verify_context.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:verify_context ssl::verify_context::verify_context]

[indexterm2 boost_asio.indexterm.ssl__verify_context.verify_context..verify_context..ssl::verify_context] 
Constructor. 


  verify_context(
      native_handle_type handle);



[endsect]



[endsect]


[section:ssl__verify_fail_if_no_peer_cert ssl::verify_fail_if_no_peer_cert]

[indexterm1 boost_asio.indexterm.ssl__verify_fail_if_no_peer_cert..ssl::verify_fail_if_no_peer_cert] 
Fail verification if the peer has no certificate. Ignored unless [link boost_asio.reference.ssl__verify_peer `ssl::verify_peer`]  is set. 


  const int verify_fail_if_no_peer_cert = implementation_defined;


[heading Requirements]

['Header: ][^boost/asio/ssl/verify_mode.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:ssl__verify_mode ssl::verify_mode]

[indexterm1 boost_asio.indexterm.ssl__verify_mode..ssl::verify_mode] 
Bitmask type for peer verification. 


  typedef int verify_mode;



Possible values are:


* [link boost_asio.reference.ssl__verify_none `ssl::verify_none`]  

* [link boost_asio.reference.ssl__verify_peer `ssl::verify_peer`]  

* [link boost_asio.reference.ssl__verify_fail_if_no_peer_cert `ssl::verify_fail_if_no_peer_cert`]  

* [link boost_asio.reference.ssl__verify_client_once `ssl::verify_client_once`]  



[heading Requirements]

['Header: ][^boost/asio/ssl/verify_mode.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:ssl__verify_none ssl::verify_none]

[indexterm1 boost_asio.indexterm.ssl__verify_none..ssl::verify_none] 
No verification. 


  const int verify_none = implementation_defined;


[heading Requirements]

['Header: ][^boost/asio/ssl/verify_mode.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:ssl__verify_peer ssl::verify_peer]

[indexterm1 boost_asio.indexterm.ssl__verify_peer..ssl::verify_peer] 
Verify the peer. 


  const int verify_peer = implementation_defined;


[heading Requirements]

['Header: ][^boost/asio/ssl/verify_mode.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[endsect]



[section:static_thread_pool static_thread_pool]

[indexterm1 boost_asio.indexterm.static_thread_pool..static_thread_pool] 

  typedef thread_pool static_thread_pool;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type [*basic_executor_type]]]
    [Executor implementation type used to submit functions to a thread pool. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool.executor_type [*executor_type]]]
    [Executor used to submit functions to a thread pool. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool.fork_event [*fork_event]]]
    [Fork-related event notifications. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool.scheduler_type [*scheduler_type]]]
    [Scheduler used to schedule receivers on a thread pool. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool.attach [*attach]]]
    [Attaches the current thread to the pool. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.executor [*executor]]]
    [Obtains the executor associated with the pool. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.get_executor [*get_executor]]]
    [Obtains the executor associated with the pool. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.join [*join]]]
    [Joins the threads. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.notify_fork [*notify_fork]]]
    [Notify the execution_context of a fork-related event. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.scheduler [*scheduler]]]
    [Obtains the scheduler associated with the pool. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.stop [*stop]]]
    [Stops the threads. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.thread_pool [*thread_pool]] [constructor]]
    [Constructs a pool with an automatically determined number of threads. 
     [hr]
     Constructs a pool with a specified number of threads. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.wait [*wait]]]
    [Waits for threads to complete. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool._thread_pool [*~thread_pool]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool.destroy [*destroy]]]
    [Destroys all services in the context. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.shutdown [*shutdown]]]
    [Shuts down all services in the context. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool.add_service [*add_service]]]
    [(Deprecated: Use make_service().) Add a service object to the execution_context. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.has_service [*has_service]]]
    [Determine if an execution_context contains a specified service type. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.make_service [*make_service]]]
    [Creates a service object and adds it to the execution_context. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.use_service [*use_service]]]
    [Obtain the service object corresponding to the given type. ]
  ]
  
]

The thread pool class is an execution context where functions are permitted to run on one of a fixed number of threads.


[heading Submitting tasks to the pool]
  


To submit functions to the thread pool, use the [link boost_asio.reference.dispatch `dispatch`] , [link boost_asio.reference.post `post`]  or [link boost_asio.reference.defer `defer`]  free functions.

For example:



   void my_task()
   {
     ...
   }

   ...

   // Launch the pool with four threads.
   boost::asio::thread_pool pool(4);

   // Submit a function to the pool.
   boost::asio::post(pool, my_task);

   // Submit a lambda object to the pool.
   boost::asio::post(pool,
       []()
       {
         ...
       });

   // Wait for all tasks in the pool to complete.
   pool.join(); 





[heading Requirements]

['Header: ][^boost/asio/static_thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:steady_timer steady_timer]

[indexterm1 boost_asio.indexterm.steady_timer..steady_timer] 
Typedef for a timer based on the steady clock. 


  typedef basic_waitable_timer< chrono::steady_clock > steady_timer;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_waitable_timer__rebind_executor [*rebind_executor]]]
    [Rebinds the timer type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.duration [*duration]]]
    [The duration type of the clock. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.time_point [*time_point]]]
    [The time point type of the clock. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.traits_type [*traits_type]]]
    [The wait traits type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_waitable_timer.async_wait [*async_wait]]]
    [Start an asynchronous wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.basic_waitable_timer [*basic_waitable_timer]] [constructor]]
    [Constructor. 
     [hr]
     Constructor to set a particular expiry time as an absolute time. 
     [hr]
     Constructor to set a particular expiry time relative to now. 
     [hr]
     Move-construct a basic_waitable_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the timer. 
     [hr]
     (Deprecated: Use non-error_code overload.) Cancel any asynchronous operations that are waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.cancel_one [*cancel_one]]]
    [Cancels one asynchronous operation that is waiting on the timer. 
     [hr]
     (Deprecated: Use non-error_code overload.) Cancels one asynchronous operation that is waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_after [*expires_after]]]
    [Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_at [*expires_at]]]
    [(Deprecated: Use expiry().) Get the timer's expiry time as an absolute time. 
     [hr]
     Set the timer's expiry time as an absolute time. 
     [hr]
     (Deprecated: Use non-error_code overload.) Set the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_from_now [*expires_from_now]]]
    [(Deprecated: Use expiry().) Get the timer's expiry time relative to now. 
     [hr]
     (Deprecated: Use expires_after().) Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expiry [*expiry]]]
    [Get the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.operator_eq_ [*operator=]]]
    [Move-assign a basic_waitable_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.wait [*wait]]]
    [Perform a blocking wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer._basic_waitable_timer [*~basic_waitable_timer]] [destructor]]
    [Destroys the timer. ]
  ]
  
]

The [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] class template provides the ability to perform a blocking or asynchronous wait for a timer to expire.

A waitable timer is always in one of two states: "expired" or "not expired". If the `wait()` or `async_wait()` function is called on an expired timer, the wait operation will complete immediately.

Most applications will use one of the [link boost_asio.reference.steady_timer `steady_timer`], [link boost_asio.reference.system_timer `system_timer`] or [link boost_asio.reference.high_resolution_timer `high_resolution_timer`] typedefs.


[heading Remarks]
      
This waitable timer functionality is for use with the C++11 standard library's `<chrono>` facility, or with the Boost.Chrono library.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.


[heading Examples]
  
Performing a blocking wait (C++11): 

   // Construct a timer without setting an expiry time.
   boost::asio::steady_timer timer(my_context);

   // Set an expiry time relative to now.
   timer.expires_after(std::chrono::seconds(5));

   // Wait for the timer to expire.
   timer.wait();





Performing an asynchronous wait (C++11): 

   void handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Timer expired.
     }
   }

   ...

   // Construct a timer with an absolute expiry time.
   boost::asio::steady_timer timer(my_context,
       std::chrono::steady_clock::now() + std::chrono::seconds(60));

   // Start an asynchronous wait.
   timer.async_wait(handler);





[heading Changing an active waitable timer's expiry time]
  


Changing the expiry time of a timer while there are pending asynchronous waits causes those wait operations to be cancelled. To ensure that the action associated with the timer is performed only once, use something like this: used:



   void on_some_event()
   {
     if (my_timer.expires_after(seconds(5)) > 0)
     {
       // We managed to cancel the timer. Start new asynchronous wait.
       my_timer.async_wait(on_timeout);
     }
     else
     {
       // Too late, timer has already expired!
     }
   }

   void on_timeout(const boost::system::error_code& e)
   {
     if (e != boost::asio::error::operation_aborted)
     {
       // Timer was not cancelled, take necessary action.
     }
   }





* The `boost::asio::basic_waitable_timer::expires_after()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.


* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 




This typedef uses the C++11 `<chrono>` standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] template directly: 

   typedef basic_waitable_timer<boost::chrono::steady_clock> timer;




[heading Requirements]

['Header: ][^boost/asio/steady_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:strand strand]

[indexterm1 boost_asio.indexterm.strand..strand]


Provides serialised function invocation for any executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  class strand


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.strand.inner_executor_type [*inner_executor_type]]]
    [The type of the underlying executor. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.strand.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.strand.defer [*defer]]]
    [Request the strand to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.strand.dispatch [*dispatch]]]
    [Request the strand to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.strand.execute [*execute]]]
    [Request the strand to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.strand.get_inner_executor [*get_inner_executor]]]
    [Obtain the underlying executor. ]
  ]
  
  [
    [[link boost_asio.reference.strand.on_work_finished [*on_work_finished]]]
    [Inform the strand that some work is no longer outstanding. ]
  ]
  
  [
    [[link boost_asio.reference.strand.on_work_started [*on_work_started]]]
    [Inform the strand that it has some outstanding work to do. ]
  ]
  
  [
    [[link boost_asio.reference.strand.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Converting assignment operator. 
     [hr]
     Move assignment operator. 
     [hr]
     Converting move assignment operator. ]
  ]
  
  [
    [[link boost_asio.reference.strand.post [*post]]]
    [Request the strand to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.strand.prefer [*prefer]]]
    [Forward a preference to the underlying executor. ]
  ]
  
  [
    [[link boost_asio.reference.strand.query [*query]]]
    [Forward a query to the underlying executor. ]
  ]
  
  [
    [[link boost_asio.reference.strand.require [*require]]]
    [Forward a requirement to the underlying executor. ]
  ]
  
  [
    [[link boost_asio.reference.strand.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the strand is running in the current thread. ]
  ]
  
  [
    [[link boost_asio.reference.strand.strand [*strand]] [constructor]]
    [Default constructor. 
     [hr]
     Construct a strand for the specified executor. 
     [hr]
     Copy constructor. 
     [hr]
     Converting constructor. 
     [hr]
     Move constructor. 
     [hr]
     Converting move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.strand._strand [*~strand]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.strand.operator_not__eq_ [*operator!=]]]
    [Compare two strands for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.strand.operator_eq__eq_ [*operator==]]]
    [Compare two strands for equality. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/strand.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:context strand::context]

[indexterm2 boost_asio.indexterm.strand.context..context..strand] 
Obtain the underlying execution context. 


  execution_context & context() const;



[endsect]



[section:defer strand::defer]

[indexterm2 boost_asio.indexterm.strand.defer..defer..strand] 
Request the strand to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void defer(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object will never be executed inside this function. Instead, it will be scheduled by the underlying executor's defer function.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:dispatch strand::dispatch]

[indexterm2 boost_asio.indexterm.strand.dispatch..dispatch..strand] 
Request the strand to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void dispatch(
      Function && f,
      const Allocator & a) const;


This function is used to ask the strand to execute the given function object on its underlying executor. The function object will be executed inside this function if the strand is not otherwise busy and if the underlying executor's `dispatch()` function is also able to execute the function before returning.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:execute strand::execute]

[indexterm2 boost_asio.indexterm.strand.execute..execute..strand] 
Request the strand to invoke the given function object. 


  template<
      typename Function>
  constraint< execution::can_execute< const Executor &, Function >::value, void >::type execute(
      Function && f) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.execution__execute `execution::execute`] customisation point.

For example: 

   boost::asio::strand<my_executor_type> ex = ...;
   execution::execute(ex, my_function_object); 




This function is used to ask the strand to execute the given function object on its underlying executor. The function object will be executed according to the properties of the underlying executor.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

]




[endsect]



[section:get_inner_executor strand::get_inner_executor]

[indexterm2 boost_asio.indexterm.strand.get_inner_executor..get_inner_executor..strand] 
Obtain the underlying executor. 


  inner_executor_type get_inner_executor() const;



[endsect]



[section:inner_executor_type strand::inner_executor_type]

[indexterm2 boost_asio.indexterm.strand.inner_executor_type..inner_executor_type..strand] 
The type of the underlying executor. 


  typedef Executor inner_executor_type;



[heading Requirements]

['Header: ][^boost/asio/strand.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:on_work_finished strand::on_work_finished]

[indexterm2 boost_asio.indexterm.strand.on_work_finished..on_work_finished..strand] 
Inform the strand that some work is no longer outstanding. 


  void on_work_finished() const;


The strand delegates this call to its underlying executor. 


[endsect]



[section:on_work_started strand::on_work_started]

[indexterm2 boost_asio.indexterm.strand.on_work_started..on_work_started..strand] 
Inform the strand that it has some outstanding work to do. 


  void on_work_started() const;


The strand delegates this call to its underlying executor. 


[endsect]



[section:operator_not__eq_ strand::operator!=]

[indexterm2 boost_asio.indexterm.strand.operator_not__eq_..operator!=..strand] 
Compare two strands for inequality. 


  friend bool operator!=(
      const strand & a,
      const strand & b);


Two strands are equal if they refer to the same ordered, non-concurrent state. 

[heading Requirements]

['Header: ][^boost/asio/strand.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:operator_eq_ strand::operator=]

[indexterm2 boost_asio.indexterm.strand.operator_eq_..operator=..strand] 
Assignment operator. 


  strand & ``[link boost_asio.reference.strand.operator_eq_.overload1 operator=]``(
      const strand & other);
  ``  [''''&raquo;''' [link boost_asio.reference.strand.operator_eq_.overload1 more...]]``


Converting assignment operator. 


  template<
      class ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  strand & ``[link boost_asio.reference.strand.operator_eq_.overload2 operator=]``(
      const strand< OtherExecutor > & other);
  ``  [''''&raquo;''' [link boost_asio.reference.strand.operator_eq_.overload2 more...]]``


Move assignment operator. 


  strand & ``[link boost_asio.reference.strand.operator_eq_.overload3 operator=]``(
      strand && other);
  ``  [''''&raquo;''' [link boost_asio.reference.strand.operator_eq_.overload3 more...]]``


Converting move assignment operator. 


  template<
      class ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  strand & ``[link boost_asio.reference.strand.operator_eq_.overload4 operator=]``(
      strand< OtherExecutor > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.strand.operator_eq_.overload4 more...]]``


[section:overload1 strand::operator= (1 of 4 overloads)]


Assignment operator. 


  strand & operator=(
      const strand & other);



[endsect]



[section:overload2 strand::operator= (2 of 4 overloads)]


Converting assignment operator. 


  template<
      class ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  strand & operator=(
      const strand< OtherExecutor > & other);


This assignment operator is only valid if the `OtherExecutor` type is convertible to `Executor`. 


[endsect]



[section:overload3 strand::operator= (3 of 4 overloads)]


Move assignment operator. 


  strand & operator=(
      strand && other);



[endsect]



[section:overload4 strand::operator= (4 of 4 overloads)]


Converting move assignment operator. 


  template<
      class ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  strand & operator=(
      strand< OtherExecutor > && other);


This assignment operator is only valid if the `OtherExecutor` type is convertible to `Executor`. 


[endsect]


[endsect]


[section:operator_eq__eq_ strand::operator==]

[indexterm2 boost_asio.indexterm.strand.operator_eq__eq_..operator==..strand] 
Compare two strands for equality. 


  friend bool operator==(
      const strand & a,
      const strand & b);


Two strands are equal if they refer to the same ordered, non-concurrent state. 

[heading Requirements]

['Header: ][^boost/asio/strand.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:post strand::post]

[indexterm2 boost_asio.indexterm.strand.post..post..strand] 
Request the strand to invoke the given function object. 


  template<
      typename Function,
      typename Allocator>
  void post(
      Function && f,
      const Allocator & a) const;


This function is used to ask the executor to execute the given function object. The function object will never be executed inside this function. Instead, it will be scheduled by the underlying executor's defer function.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:prefer strand::prefer]

[indexterm2 boost_asio.indexterm.strand.prefer..prefer..strand] 
Forward a preference to the underlying executor. 


  template<
      typename Property>
  constraint< can_prefer< const Executor &, Property >::value &&!is_convertible< Property, execution::blocking_t::always_t >::value, strand< typename decay< typename prefer_result< const Executor &, Property >::type >::type > >::type prefer(
      const Property & p) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.prefer `prefer`] customisation point.

For example: 

   boost::asio::strand<my_executor_type> ex1 = ...;
   auto ex2 = boost::asio::prefer(ex1,
       boost::asio::execution::blocking.never); 





[endsect]



[section:query strand::query]

[indexterm2 boost_asio.indexterm.strand.query..query..strand] 
Forward a query to the underlying executor. 


  template<
      typename Property>
  constraint< can_query< const Executor &, Property >::value, typename conditional< is_convertible< Property, execution::blocking_t >::value, execution::blocking_t, typename query_result< const Executor &, Property >::type >::type >::type query(
      const Property & p) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   boost::asio::strand<my_executor_type> ex = ...;
   if (boost::asio::query(ex, boost::asio::execution::blocking)
         == boost::asio::execution::blocking.never)
     ... 





[endsect]



[section:require strand::require]

[indexterm2 boost_asio.indexterm.strand.require..require..strand] 
Forward a requirement to the underlying executor. 


  template<
      typename Property>
  constraint< can_require< const Executor &, Property >::value &&!is_convertible< Property, execution::blocking_t::always_t >::value, strand< typename decay< typename require_result< const Executor &, Property >::type >::type > >::type require(
      const Property & p) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   boost::asio::strand<my_executor_type> ex1 = ...;
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::blocking.never); 





[endsect]



[section:running_in_this_thread strand::running_in_this_thread]

[indexterm2 boost_asio.indexterm.strand.running_in_this_thread..running_in_this_thread..strand] 
Determine whether the strand is running in the current thread. 


  bool running_in_this_thread() const;



[heading Return Value]
      
`true` if the current thread is executing a function that was submitted to the strand using `post()`, `dispatch()` or `defer()`. Otherwise returns `false`. 




[endsect]


[section:strand strand::strand]

[indexterm2 boost_asio.indexterm.strand.strand..strand..strand] 
Default constructor. 


  ``[link boost_asio.reference.strand.strand.overload1 strand]``();
  ``  [''''&raquo;''' [link boost_asio.reference.strand.strand.overload1 more...]]``


Construct a strand for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  explicit ``[link boost_asio.reference.strand.strand.overload2 strand]``(
      const Executor1 & e,
      typename constraint< conditional< !is_same< Executor1, strand >::value, is_convertible< Executor1, Executor >, false_type >::type::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.strand.strand.overload2 more...]]``


Copy constructor. 


  ``[link boost_asio.reference.strand.strand.overload3 strand]``(
      const strand & other);
  ``  [''''&raquo;''' [link boost_asio.reference.strand.strand.overload3 more...]]``


Converting constructor. 


  template<
      class ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  ``[link boost_asio.reference.strand.strand.overload4 strand]``(
      const strand< OtherExecutor > & other);
  ``  [''''&raquo;''' [link boost_asio.reference.strand.strand.overload4 more...]]``


Move constructor. 


  ``[link boost_asio.reference.strand.strand.overload5 strand]``(
      strand && other);
  ``  [''''&raquo;''' [link boost_asio.reference.strand.strand.overload5 more...]]``


Converting move constructor. 


  template<
      class ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  ``[link boost_asio.reference.strand.strand.overload6 strand]``(
      strand< OtherExecutor > && other);
  ``  [''''&raquo;''' [link boost_asio.reference.strand.strand.overload6 more...]]``


[section:overload1 strand::strand (1 of 6 overloads)]


Default constructor. 


  strand();


This constructor is only valid if the underlying executor type is default constructible. 


[endsect]



[section:overload2 strand::strand (2 of 6 overloads)]


Construct a strand for the specified executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  strand(
      const Executor1 & e,
      typename constraint< conditional< !is_same< Executor1, strand >::value, is_convertible< Executor1, Executor >, false_type >::type::value >::type  = 0);



[endsect]



[section:overload3 strand::strand (3 of 6 overloads)]


Copy constructor. 


  strand(
      const strand & other);



[endsect]



[section:overload4 strand::strand (4 of 6 overloads)]


Converting constructor. 


  template<
      class ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  strand(
      const strand< OtherExecutor > & other);


This constructor is only valid if the `OtherExecutor` type is convertible to `Executor`. 


[endsect]



[section:overload5 strand::strand (5 of 6 overloads)]


Move constructor. 


  strand(
      strand && other);



[endsect]



[section:overload6 strand::strand (6 of 6 overloads)]


Converting move constructor. 


  template<
      class ``[link boost_asio.reference.Executor1 OtherExecutor]``>
  strand(
      strand< OtherExecutor > && other);


This constructor is only valid if the `OtherExecutor` type is convertible to `Executor`. 


[endsect]


[endsect]


[section:_strand strand::~strand]

[indexterm2 boost_asio.indexterm.strand._strand..~strand..strand] 
Destructor. 


  ~strand();



[endsect]



[endsect]


[section:stream_file stream_file]

[indexterm1 boost_asio.indexterm.stream_file..stream_file] 
Typedef for the typical usage of a stream-oriented file. 


  typedef basic_stream_file stream_file;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_stream_file__rebind_executor [*rebind_executor]]]
    [Rebinds the file type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_file.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_file.flags [*flags]]]
    [A bitmask type (C++ Std \[lib.bitmask.types\]). ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_file.native_handle_type [*native_handle_type]]]
    [The native representation of a file. ]
  
  ]

  [

    [[link boost_asio.reference.basic_stream_file.seek_basis [*seek_basis]]]
    [Basis for seeking in a file. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_file.assign [*assign]]]
    [Assign an existing native file to the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.basic_stream_file [*basic_stream_file]] [constructor]]
    [Construct a basic_stream_file without opening it. 
     [hr]
     Construct and open a basic_stream_file. 
     [hr]
     Construct a basic_stream_file on an existing native file. 
     [hr]
     Move-construct a basic_stream_file from another. 
     [hr]
     Move-construct a basic_stream_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.close [*close]]]
    [Close the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.is_open [*is_open]]]
    [Determine whether the file is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.native_handle [*native_handle]]]
    [Get the native file representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.open [*open]]]
    [Open the file using the specified path. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.operator_eq_ [*operator=]]]
    [Move-assign a basic_stream_file from another. 
     [hr]
     Move-assign a basic_stream_file from a file of another executor type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.read_some [*read_some]]]
    [Read some data from the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.release [*release]]]
    [Release ownership of the underlying native file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.resize [*resize]]]
    [Alter the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.seek [*seek]]]
    [Seek to a position in the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.size [*size]]]
    [Get the size of the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.sync_all [*sync_all]]]
    [Synchronise the file to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.sync_data [*sync_data]]]
    [Synchronise the file data to disk. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file.write_some [*write_some]]]
    [Write some data to the file. ]
  ]
  
  [
    [[link boost_asio.reference.basic_stream_file._basic_stream_file [*~basic_stream_file]] [destructor]]
    [Destroys the file. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_stream_file.append [*append]] [static]]
    [Open the file in append mode. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.create [*create]] [static]]
    [Create the file if it does not exist. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.exclusive [*exclusive]] [static]]
    [Ensure a new file is created. Must be combined with create. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.read_only [*read_only]] [static]]
    [Open the file for reading. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.read_write [*read_write]] [static]]
    [Open the file for reading and writing. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.truncate [*truncate]] [static]]
    [Open the file with any existing contents truncated. ]
  ]

  [
    [[link boost_asio.reference.basic_stream_file.write_only [*write_only]] [static]]
    [Open the file for writing. ]
  ]

]

The [link boost_asio.reference.basic_stream_file `basic_stream_file`] class template provides asynchronous and blocking stream-oriented file functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.





[heading Requirements]

['Header: ][^boost/asio/stream_file.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:streambuf streambuf]

[indexterm1 boost_asio.indexterm.streambuf..streambuf] 
Typedef for the typical usage of [link boost_asio.reference.basic_streambuf `basic_streambuf`]. 


  typedef basic_streambuf streambuf;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_streambuf.const_buffers_type [*const_buffers_type]]]
    [The type used to represent the input sequence as a list of buffers. ]
  
  ]

  [

    [[link boost_asio.reference.basic_streambuf.mutable_buffers_type [*mutable_buffers_type]]]
    [The type used to represent the output sequence as a list of buffers. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_streambuf.basic_streambuf [*basic_streambuf]] [constructor]]
    [Construct a basic_streambuf object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.capacity [*capacity]]]
    [Get the current capacity of the basic_streambuf. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.commit [*commit]]]
    [Move characters from the output sequence to the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.consume [*consume]]]
    [Remove characters from the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.data [*data]]]
    [Get a list of buffers that represents the input sequence. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.max_size [*max_size]]]
    [Get the maximum size of the basic_streambuf. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.prepare [*prepare]]]
    [Get a list of buffers that represents the output sequence, with the given size. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.size [*size]]]
    [Get the size of the input sequence. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_streambuf.overflow [*overflow]]]
    [Override std::streambuf behaviour. ]
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.reserve [*reserve]]]
    []
  ]
  
  [
    [[link boost_asio.reference.basic_streambuf.underflow [*underflow]]]
    [Override std::streambuf behaviour. ]
  ]
  
]

The `basic_streambuf` class is derived from `std::streambuf` to associate the streambuf's input and output sequences with one or more character arrays. These character arrays are internal to the `basic_streambuf` object, but direct access to the array elements is provided to permit them to be used efficiently with I/O operations. Characters written to the output sequence of a `basic_streambuf` object are appended to the input sequence of the same object.

The `basic_streambuf` class's public interface is intended to permit the following implementation strategies:


* A single contiguous character array, which is reallocated as necessary to accommodate changes in the size of the character sequence. This is the implementation approach currently used in Asio.


* A sequence of one or more character arrays, where each array is of the same size. Additional character array objects are appended to the sequence to accommodate changes in the size of the character sequence.


* A sequence of one or more character arrays of varying sizes. Additional character array objects are appended to the sequence to accommodate changes in the size of the character sequence.

The constructor for [link boost_asio.reference.basic_streambuf `basic_streambuf`] accepts a `size_t` argument specifying the maximum of the sum of the sizes of the input sequence and output sequence. During the lifetime of the `basic_streambuf` object, the following invariant holds: 

   size() <= max_size()


Any member function that would, if successful, cause the invariant to be violated shall throw an exception of class `std::length_error`.

The constructor for `basic_streambuf` takes an Allocator argument. A copy of this argument is used for any memory allocation performed, by the constructor and by all member functions, during the lifetime of each `basic_streambuf` object.


[heading Examples]
  
Writing directly from an streambuf to a socket: 

   boost::asio::streambuf b;
   std::ostream os(&b);
   os << "Hello, World!\n";

   // try sending some data in input sequence
   size_t n = sock.send(b.data());

   b.consume(n); // sent data is removed from input sequence




Reading from a socket directly into a streambuf: 

   boost::asio::streambuf b;

   // reserve 512 bytes in output sequence
   boost::asio::streambuf::mutable_buffers_type bufs = b.prepare(512);

   size_t n = sock.receive(bufs);

   // received data is "committed" from output sequence to input sequence
   b.commit(n);

   std::istream is(&b);
   std::string s;
   is >> s;





[heading Requirements]

['Header: ][^boost/asio/streambuf.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:system_context system_context]

[indexterm1 boost_asio.indexterm.system_context..system_context]


The executor context for the system executor. 


  class system_context :
    public execution_context


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.system_context.executor_type [*executor_type]]]
    [The executor type associated with the context. ]
  
  ]

  [

    [[link boost_asio.reference.system_context.fork_event [*fork_event]]]
    [Fork-related event notifications. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.system_context.get_executor [*get_executor]]]
    [Obtain an executor for the context. ]
  ]
  
  [
    [[link boost_asio.reference.system_context.join [*join]]]
    [Join all threads in the system thread pool. ]
  ]
  
  [
    [[link boost_asio.reference.system_context.notify_fork [*notify_fork]]]
    [Notify the execution_context of a fork-related event. ]
  ]
  
  [
    [[link boost_asio.reference.system_context.stop [*stop]]]
    [Signal all threads in the system thread pool to stop. ]
  ]
  
  [
    [[link boost_asio.reference.system_context.stopped [*stopped]]]
    [Determine whether the system thread pool has been stopped. ]
  ]
  
  [
    [[link boost_asio.reference.system_context._system_context [*~system_context]] [destructor]]
    [Destructor shuts down all threads in the system thread pool. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.system_context.destroy [*destroy]]]
    [Destroys all services in the context. ]
  ]
  
  [
    [[link boost_asio.reference.system_context.shutdown [*shutdown]]]
    [Shuts down all services in the context. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.system_context.add_service [*add_service]]]
    [(Deprecated: Use make_service().) Add a service object to the execution_context. ]
  ]
  
  [
    [[link boost_asio.reference.system_context.has_service [*has_service]]]
    [Determine if an execution_context contains a specified service type. ]
  ]
  
  [
    [[link boost_asio.reference.system_context.make_service [*make_service]]]
    [Creates a service object and adds it to the execution_context. ]
  ]
  
  [
    [[link boost_asio.reference.system_context.use_service [*use_service]]]
    [Obtain the service object corresponding to the given type. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/system_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:add_service system_context::add_service]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.system_context.add_service..add_service..system_context] 
(Deprecated: Use `make_service()`.) Add a service object to the [link boost_asio.reference.execution_context `execution_context`]. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend void add_service(
      execution_context & e,
      Service * svc);


This function is used to add a service to the [link boost_asio.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

[[svc][The service object. On success, ownership of the service object is transferred to the [link boost_asio.reference.execution_context `execution_context`]. When the [link boost_asio.reference.execution_context `execution_context`] object is destroyed, it will destroy the service object by performing:
``
   delete static_cast<execution_context::service*>(svc) 
``
]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`].]]

[[boost::asio::invalid_service_owner][Thrown if the service's owning [link boost_asio.reference.execution_context `execution_context`] is not the [link boost_asio.reference.execution_context `execution_context`] object specified by the `e` parameter. ]]

]



[heading Requirements]

['Header: ][^boost/asio/system_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:destroy system_context::destroy]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.system_context.destroy..destroy..system_context] 
Destroys all services in the context. 


  void destroy();


This function is implemented as follows:


* For each service object `svc` in the [link boost_asio.reference.execution_context `execution_context`] set, in reverse order * of the beginning of service object lifetime, performs `delete static_cast<execution_context::service*>(svc)`. 




[endsect]



[section:executor_type system_context::executor_type]

[indexterm2 boost_asio.indexterm.system_context.executor_type..executor_type..system_context] 
The executor type associated with the context. 


  typedef basic_system_executor< execution::blocking_t::possibly_t, execution::relationship_t::fork_t, std::allocator< void > > executor_type;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_system_executor.basic_system_executor [*basic_system_executor]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.defer [*defer]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.dispatch [*dispatch]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.execute [*execute]]]
    [Execution function. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.on_work_finished [*on_work_finished]]]
    [Inform the executor that some work is no longer outstanding. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.on_work_started [*on_work_started]]]
    [Inform the executor that it has some outstanding work to do. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.post [*post]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.query [*query]]]
    [Query the current value of the allocator property. 
     [hr]
     Query the occupancy (recommended number of work items) for the system context. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.query__static [*query]] [static]]
    [Query the current value of the mapping property. 
     [hr]
     Query the current value of the context property. 
     [hr]
     Query the current value of the blocking property. 
     [hr]
     Query the current value of the relationship property. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.require [*require]]]
    [Obtain an executor with the blocking.possibly property. 
     [hr]
     Obtain an executor with the blocking.always property. 
     [hr]
     Obtain an executor with the blocking.never property. 
     [hr]
     Obtain an executor with the relationship.continuation property. 
     [hr]
     Obtain an executor with the relationship.fork property. 
     [hr]
     Obtain an executor with the specified allocator property. 
     [hr]
     Obtain an executor with the default allocator property. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_system_executor.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]

The system executor represents an execution context where functions are permitted to run on arbitrary threads. When the blocking.never property is established, the system executor will schedule the function to run on an unspecified system thread pool. When either blocking.possibly or blocking.always is established, the executor invokes the function immediately. 


[heading Requirements]

['Header: ][^boost/asio/system_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:fork_event system_context::fork_event]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.system_context.fork_event..fork_event..system_context] 
Fork-related event notifications. 

  enum fork_event

[indexterm2 boost_asio.indexterm.system_context.fork_event.fork_prepare..fork_prepare..system_context]
[indexterm2 boost_asio.indexterm.system_context.fork_event.fork_parent..fork_parent..system_context]
[indexterm2 boost_asio.indexterm.system_context.fork_event.fork_child..fork_child..system_context]

[heading Values]
[variablelist

  [
    [fork_prepare]
    [Notify the context that the process is about to fork. ]
  ]

  [
    [fork_parent]
    [Notify the context that the process has forked and is the parent. ]
  ]

  [
    [fork_child]
    [Notify the context that the process has forked and is the child. ]
  ]

]



[endsect]



[section:get_executor system_context::get_executor]

[indexterm2 boost_asio.indexterm.system_context.get_executor..get_executor..system_context] 
Obtain an executor for the context. 


  executor_type get_executor();



[endsect]



[section:has_service system_context::has_service]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.system_context.has_service..has_service..system_context] 
Determine if an [link boost_asio.reference.execution_context `execution_context`] contains a specified service type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend bool has_service(
      execution_context & e);


This function is used to determine whether the [link boost_asio.reference.execution_context `execution_context`] contains a service object corresponding to the given service type.


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
A boolean indicating whether the [link boost_asio.reference.execution_context `execution_context`] contains the service. 



[heading Requirements]

['Header: ][^boost/asio/system_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:join system_context::join]

[indexterm2 boost_asio.indexterm.system_context.join..join..system_context] 
Join all threads in the system thread pool. 


  void join();



[endsect]



[section:make_service system_context::make_service]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.system_context.make_service..make_service..system_context] 
Creates a service object and adds it to the [link boost_asio.reference.execution_context `execution_context`]. 


  template<
      typename ``[link boost_asio.reference.Service Service]``,
      typename... Args>
  friend Service & make_service(
      execution_context & e,
      Args &&... args);


This function is used to add a service to the [link boost_asio.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

[[args][Zero or more arguments to be passed to the service constructor.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`]. ]]

]



[heading Requirements]

['Header: ][^boost/asio/system_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:notify_fork system_context::notify_fork]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.system_context.notify_fork..notify_fork..system_context] 
Notify the [link boost_asio.reference.execution_context `execution_context`] of a fork-related event. 


  void notify_fork(
      fork_event event);


This function is used to inform the [link boost_asio.reference.execution_context `execution_context`] that the process is about to fork, or has just forked. This allows the [link boost_asio.reference.execution_context `execution_context`], and the services it contains, to perform any necessary housekeeping to ensure correct operation following a fork.

This function must not be called while any other [link boost_asio.reference.execution_context `execution_context`] function, or any function associated with the execution\_context's derived class, is being called in another thread. It is, however, safe to call this function from within a completion handler, provided no other thread is accessing the [link boost_asio.reference.execution_context `execution_context`] or its derived class.


[heading Parameters]
    

[variablelist
  
[[event][A fork-related event.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the notification fails the [link boost_asio.reference.execution_context `execution_context`] object should no longer be used and should be destroyed.]]

]


[heading Example]
  
The following code illustrates how to incorporate the `notify_fork()` function: 

   my_execution_context.notify_fork(execution_context::fork_prepare);
   if (fork() == 0)
   {
     // This is the child process.
     my_execution_context.notify_fork(execution_context::fork_child);
   }
   else
   {
     // This is the parent process.
     my_execution_context.notify_fork(execution_context::fork_parent);
   } 





[heading Remarks]
      
For each service object `svc` in the [link boost_asio.reference.execution_context `execution_context`] set, performs `svc->notify_fork();`. When processing the fork\_prepare event, services are visited in reverse order of the beginning of service object lifetime. Otherwise, services are visited in order of the beginning of service object lifetime. 




[endsect]



[section:shutdown system_context::shutdown]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.system_context.shutdown..shutdown..system_context] 
Shuts down all services in the context. 


  void shutdown();


This function is implemented as follows:


* For each service object `svc` in the [link boost_asio.reference.execution_context `execution_context`] set, in reverse order of the beginning of service object lifetime, performs `svc->shutdown()`. 




[endsect]



[section:stop system_context::stop]

[indexterm2 boost_asio.indexterm.system_context.stop..stop..system_context] 
Signal all threads in the system thread pool to stop. 


  void stop();



[endsect]



[section:stopped system_context::stopped]

[indexterm2 boost_asio.indexterm.system_context.stopped..stopped..system_context] 
Determine whether the system thread pool has been stopped. 


  bool stopped() const;



[endsect]


[section:use_service system_context::use_service]

[indexterm2 boost_asio.indexterm.system_context.use_service..use_service..system_context] 
Obtain the service object corresponding to the given type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & ``[link boost_asio.reference.system_context.use_service.overload1 use_service]``(
      execution_context & e);
  ``  [''''&raquo;''' [link boost_asio.reference.system_context.use_service.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & ``[link boost_asio.reference.system_context.use_service.overload2 use_service]``(
      io_context & ioc);
  ``  [''''&raquo;''' [link boost_asio.reference.system_context.use_service.overload2 more...]]``


[section:overload1 system_context::use_service (1 of 2 overloads)]


['Inherited from execution_context.]


Obtain the service object corresponding to the given type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & use_service(
      execution_context & e);


This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the [link boost_asio.reference.execution_context `execution_context`] will create a new instance of the service.


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller. 



[heading Requirements]

['Header: ][^boost/asio/system_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:overload2 system_context::use_service (2 of 2 overloads)]


['Inherited from execution_context.]


Obtain the service object corresponding to the given type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & use_service(
      io_context & ioc);


This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the [link boost_asio.reference.io_context `io_context`] will create a new instance of the service.


[heading Parameters]
    

[variablelist
  
[[ioc][The [link boost_asio.reference.io_context `io_context`] object that owns the service.]]

]


[heading Return Value]
      
The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller.


[heading Remarks]
      
This overload is preserved for backwards compatibility with services that inherit from [link boost_asio.reference.io_context__service `io_context::service`]. 



[heading Requirements]

['Header: ][^boost/asio/system_context.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[endsect]


[section:_system_context system_context::~system_context]

[indexterm2 boost_asio.indexterm.system_context._system_context..~system_context..system_context] 
Destructor shuts down all threads in the system thread pool. 


  ~system_context();



[endsect]



[endsect]


[section:system_executor system_executor]

[indexterm1 boost_asio.indexterm.system_executor..system_executor] 
An executor that uses arbitrary threads. 


  typedef basic_system_executor< execution::blocking_t::possibly_t, execution::relationship_t::fork_t, std::allocator< void > > system_executor;


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_system_executor.basic_system_executor [*basic_system_executor]] [constructor]]
    [Default constructor. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.defer [*defer]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.dispatch [*dispatch]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.execute [*execute]]]
    [Execution function. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.on_work_finished [*on_work_finished]]]
    [Inform the executor that some work is no longer outstanding. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.on_work_started [*on_work_started]]]
    [Inform the executor that it has some outstanding work to do. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.post [*post]]]
    [Request the system executor to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.query [*query]]]
    [Query the current value of the allocator property. 
     [hr]
     Query the occupancy (recommended number of work items) for the system context. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.query__static [*query]] [static]]
    [Query the current value of the mapping property. 
     [hr]
     Query the current value of the context property. 
     [hr]
     Query the current value of the blocking property. 
     [hr]
     Query the current value of the relationship property. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.require [*require]]]
    [Obtain an executor with the blocking.possibly property. 
     [hr]
     Obtain an executor with the blocking.always property. 
     [hr]
     Obtain an executor with the blocking.never property. 
     [hr]
     Obtain an executor with the relationship.continuation property. 
     [hr]
     Obtain an executor with the relationship.fork property. 
     [hr]
     Obtain an executor with the specified allocator property. 
     [hr]
     Obtain an executor with the default allocator property. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_system_executor.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.basic_system_executor.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]

The system executor represents an execution context where functions are permitted to run on arbitrary threads. When the blocking.never property is established, the system executor will schedule the function to run on an unspecified system thread pool. When either blocking.possibly or blocking.always is established, the executor invokes the function immediately. 


The system executor represents an execution context where functions are permitted to run on arbitrary threads. When the blocking.never property is established, the system executor will schedule the function to run on an unspecified system thread pool. When either blocking.possibly or blocking.always is established, the executor invokes the function immediately. 

[heading Requirements]

['Header: ][^boost/asio/system_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:system_timer system_timer]

[indexterm1 boost_asio.indexterm.system_timer..system_timer] 
Typedef for a timer based on the system clock. 


  typedef basic_waitable_timer< chrono::system_clock > system_timer;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_waitable_timer__rebind_executor [*rebind_executor]]]
    [Rebinds the timer type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.clock_type [*clock_type]]]
    [The clock type. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.duration [*duration]]]
    [The duration type of the clock. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.time_point [*time_point]]]
    [The time point type of the clock. ]
  
  ]

  [

    [[link boost_asio.reference.basic_waitable_timer.traits_type [*traits_type]]]
    [The wait traits type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_waitable_timer.async_wait [*async_wait]]]
    [Start an asynchronous wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.basic_waitable_timer [*basic_waitable_timer]] [constructor]]
    [Constructor. 
     [hr]
     Constructor to set a particular expiry time as an absolute time. 
     [hr]
     Constructor to set a particular expiry time relative to now. 
     [hr]
     Move-construct a basic_waitable_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.cancel [*cancel]]]
    [Cancel any asynchronous operations that are waiting on the timer. 
     [hr]
     (Deprecated: Use non-error_code overload.) Cancel any asynchronous operations that are waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.cancel_one [*cancel_one]]]
    [Cancels one asynchronous operation that is waiting on the timer. 
     [hr]
     (Deprecated: Use non-error_code overload.) Cancels one asynchronous operation that is waiting on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_after [*expires_after]]]
    [Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_at [*expires_at]]]
    [(Deprecated: Use expiry().) Get the timer's expiry time as an absolute time. 
     [hr]
     Set the timer's expiry time as an absolute time. 
     [hr]
     (Deprecated: Use non-error_code overload.) Set the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expires_from_now [*expires_from_now]]]
    [(Deprecated: Use expiry().) Get the timer's expiry time relative to now. 
     [hr]
     (Deprecated: Use expires_after().) Set the timer's expiry time relative to now. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.expiry [*expiry]]]
    [Get the timer's expiry time as an absolute time. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.operator_eq_ [*operator=]]]
    [Move-assign a basic_waitable_timer from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer.wait [*wait]]]
    [Perform a blocking wait on the timer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_waitable_timer._basic_waitable_timer [*~basic_waitable_timer]] [destructor]]
    [Destroys the timer. ]
  ]
  
]

The [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] class template provides the ability to perform a blocking or asynchronous wait for a timer to expire.

A waitable timer is always in one of two states: "expired" or "not expired". If the `wait()` or `async_wait()` function is called on an expired timer, the wait operation will complete immediately.

Most applications will use one of the [link boost_asio.reference.steady_timer `steady_timer`], [link boost_asio.reference.system_timer `system_timer`] or [link boost_asio.reference.high_resolution_timer `high_resolution_timer`] typedefs.


[heading Remarks]
      
This waitable timer functionality is for use with the C++11 standard library's `<chrono>` facility, or with the Boost.Chrono library.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.


[heading Examples]
  
Performing a blocking wait (C++11): 

   // Construct a timer without setting an expiry time.
   boost::asio::steady_timer timer(my_context);

   // Set an expiry time relative to now.
   timer.expires_after(std::chrono::seconds(5));

   // Wait for the timer to expire.
   timer.wait();





Performing an asynchronous wait (C++11): 

   void handler(const boost::system::error_code& error)
   {
     if (!error)
     {
       // Timer expired.
     }
   }

   ...

   // Construct a timer with an absolute expiry time.
   boost::asio::steady_timer timer(my_context,
       std::chrono::steady_clock::now() + std::chrono::seconds(60));

   // Start an asynchronous wait.
   timer.async_wait(handler);





[heading Changing an active waitable timer's expiry time]
  


Changing the expiry time of a timer while there are pending asynchronous waits causes those wait operations to be cancelled. To ensure that the action associated with the timer is performed only once, use something like this: used:



   void on_some_event()
   {
     if (my_timer.expires_after(seconds(5)) > 0)
     {
       // We managed to cancel the timer. Start new asynchronous wait.
       my_timer.async_wait(on_timeout);
     }
     else
     {
       // Too late, timer has already expired!
     }
   }

   void on_timeout(const boost::system::error_code& e)
   {
     if (e != boost::asio::error::operation_aborted)
     {
       // Timer was not cancelled, take necessary action.
     }
   }





* The `boost::asio::basic_waitable_timer::expires_after()` function cancels any pending asynchronous waits, and returns the number of asynchronous waits that were cancelled. If it returns 0 then you were too late and the wait handler has already been executed, or will soon be executed. If it returns 1 then the wait handler was successfully cancelled.


* If a wait handler is cancelled, the boost::system::error\_code passed to it contains the value `boost::asio::error::operation_aborted`. 




This typedef uses the C++11 `<chrono>` standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] template directly: 

   typedef basic_waitable_timer<boost::chrono::system_clock> timer;




[heading Requirements]

['Header: ][^boost/asio/system_timer.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:this_coro__cancellation_state this_coro::cancellation_state]

[indexterm1 boost_asio.indexterm.this_coro__cancellation_state..this_coro::cancellation_state] 
Awaitable object that returns the cancellation state of the current coroutine. 


  constexpr cancellation_state_t cancellation_state;



[heading Example]
  


   boost::asio::awaitable<void> my_coroutine()
   {
     boost::asio::cancellation_state cs
       = co_await boost::asio::this_coro::cancellation_state;

     // ...

     if (cs.cancelled() != boost::asio::cancellation_type::none)
       // ...
   } 






[heading Requirements]

['Header: ][^boost/asio/this_coro.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:this_coro__cancellation_state_t this_coro::cancellation_state_t]

[indexterm1 boost_asio.indexterm.this_coro__cancellation_state_t..this_coro::cancellation_state_t]


Awaitable type that returns the cancellation state of the current coroutine. 


  struct cancellation_state_t


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.this_coro__cancellation_state_t.cancellation_state_t [*cancellation_state_t]] [constructor]]
    []
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/this_coro.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:cancellation_state_t this_coro::cancellation_state_t::cancellation_state_t]

[indexterm2 boost_asio.indexterm.this_coro__cancellation_state_t.cancellation_state_t..cancellation_state_t..this_coro::cancellation_state_t] 

  constexpr cancellation_state_t();



[endsect]



[endsect]


[section:this_coro__executor this_coro::executor]

[indexterm1 boost_asio.indexterm.this_coro__executor..this_coro::executor] 
Awaitable object that returns the executor of the current coroutine. 


  constexpr executor_t executor;


[heading Requirements]

['Header: ][^boost/asio/this_coro.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:this_coro__executor_t this_coro::executor_t]

[indexterm1 boost_asio.indexterm.this_coro__executor_t..this_coro::executor_t]


Awaitable type that returns the executor of the current coroutine. 


  struct executor_t


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.this_coro__executor_t.executor_t [*executor_t]] [constructor]]
    []
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/this_coro.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:executor_t this_coro::executor_t::executor_t]

[indexterm2 boost_asio.indexterm.this_coro__executor_t.executor_t..executor_t..this_coro::executor_t] 

  constexpr executor_t();



[endsect]



[endsect]

[section:this_coro__reset_cancellation_state this_coro::reset_cancellation_state]

[indexterm1 boost_asio.indexterm.this_coro__reset_cancellation_state..this_coro::reset_cancellation_state] 
Returns an awaitable object that may be used to reset the cancellation state of the current coroutine. 

  constexpr unspecified ``[link boost_asio.reference.this_coro__reset_cancellation_state.overload1 reset_cancellation_state]``();
  ``  [''''&raquo;''' [link boost_asio.reference.this_coro__reset_cancellation_state.overload1 more...]]``

  template<
      typename Filter>
  constexpr unspecified ``[link boost_asio.reference.this_coro__reset_cancellation_state.overload2 reset_cancellation_state]``(
      Filter && filter);
  ``  [''''&raquo;''' [link boost_asio.reference.this_coro__reset_cancellation_state.overload2 more...]]``

  template<
      typename InFilter,
      typename OutFilter>
  constexpr unspecified ``[link boost_asio.reference.this_coro__reset_cancellation_state.overload3 reset_cancellation_state]``(
      InFilter && in_filter,
      OutFilter && out_filter);
  ``  [''''&raquo;''' [link boost_asio.reference.this_coro__reset_cancellation_state.overload3 more...]]``

[heading Requirements]

['Header: ][^boost/asio/this_coro.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 this_coro::reset_cancellation_state (1 of 3 overloads)]


Returns an awaitable object that may be used to reset the cancellation state of the current coroutine. 


  constexpr unspecified reset_cancellation_state();


Let `P` be the cancellation slot associated with the current coroutine's `co\_spawn` completion handler. Assigns a new [link boost_asio.reference.cancellation_state `cancellation_state`] object `S`, constructed as `S(P)`, into the current coroutine's cancellation state object.


[heading Example]
  


   boost::asio::awaitable<void> my_coroutine()
   {
     co_await boost::asio::this_coro::reset_cancellation_state();

     // ...
   } 





[heading Remarks]
      
The cancellation state is shared by all coroutines in the same "thread of execution" that was created using [link boost_asio.reference.co_spawn `co_spawn`]. 




[endsect]



[section:overload2 this_coro::reset_cancellation_state (2 of 3 overloads)]


Returns an awaitable object that may be used to reset the cancellation state of the current coroutine. 


  template<
      typename Filter>
  constexpr unspecified reset_cancellation_state(
      Filter && filter);


Let `P` be the cancellation slot associated with the current coroutine's `co\_spawn` completion handler. Assigns a new [link boost_asio.reference.cancellation_state `cancellation_state`] object `S`, constructed as `S(P, std::forward<Filter>(filter))`, into the current coroutine's cancellation state object.


[heading Example]
  


   boost::asio::awaitable<void> my_coroutine()
   {
     co_await boost::asio::this_coro::reset_cancellation_state(
         boost::asio::enable_partial_cancellation());

     // ...
   } 





[heading Remarks]
      
The cancellation state is shared by all coroutines in the same "thread of execution" that was created using [link boost_asio.reference.co_spawn `co_spawn`]. 




[endsect]



[section:overload3 this_coro::reset_cancellation_state (3 of 3 overloads)]


Returns an awaitable object that may be used to reset the cancellation state of the current coroutine. 


  template<
      typename InFilter,
      typename OutFilter>
  constexpr unspecified reset_cancellation_state(
      InFilter && in_filter,
      OutFilter && out_filter);


Let `P` be the cancellation slot associated with the current coroutine's `co\_spawn` completion handler. Assigns a new [link boost_asio.reference.cancellation_state `cancellation_state`] object `S`, constructed as `S(P, std::forward<InFilter>(in_filter), std::forward<OutFilter>(out_filter))`, into the current coroutine's cancellation state object.


[heading Example]
  


   boost::asio::awaitable<void> my_coroutine()
   {
     co_await boost::asio::this_coro::reset_cancellation_state(
         boost::asio::enable_partial_cancellation(),
         boost::asio::disable_cancellation());

     // ...
   } 





[heading Remarks]
      
The cancellation state is shared by all coroutines in the same "thread of execution" that was created using [link boost_asio.reference.co_spawn `co_spawn`]. 




[endsect]


[endsect]

[section:this_coro__throw_if_cancelled this_coro::throw_if_cancelled]

[indexterm1 boost_asio.indexterm.this_coro__throw_if_cancelled..this_coro::throw_if_cancelled] 
Returns an awaitable object that may be used to determine whether the coroutine throws if trying to suspend when it has been cancelled. 

  constexpr unspecified ``[link boost_asio.reference.this_coro__throw_if_cancelled.overload1 throw_if_cancelled]``();
  ``  [''''&raquo;''' [link boost_asio.reference.this_coro__throw_if_cancelled.overload1 more...]]``

Returns an awaitable object that may be used to specify whether the coroutine throws if trying to suspend when it has been cancelled. 

  constexpr unspecified ``[link boost_asio.reference.this_coro__throw_if_cancelled.overload2 throw_if_cancelled]``(
      bool value);
  ``  [''''&raquo;''' [link boost_asio.reference.this_coro__throw_if_cancelled.overload2 more...]]``

[heading Requirements]

['Header: ][^boost/asio/this_coro.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 this_coro::throw_if_cancelled (1 of 2 overloads)]


Returns an awaitable object that may be used to determine whether the coroutine throws if trying to suspend when it has been cancelled. 


  constexpr unspecified throw_if_cancelled();



[heading Example]
  


   boost::asio::awaitable<void> my_coroutine()
   {
     if (co_await boost::asio::this_coro::throw_if_cancelled)
       // ...

     // ...
   } 







[endsect]



[section:overload2 this_coro::throw_if_cancelled (2 of 2 overloads)]


Returns an awaitable object that may be used to specify whether the coroutine throws if trying to suspend when it has been cancelled. 


  constexpr unspecified throw_if_cancelled(
      bool value);



[heading Example]
  


   boost::asio::awaitable<void> my_coroutine()
   {
     co_await boost::asio::this_coro::throw_if_cancelled(false);

     // ...
   } 







[endsect]


[endsect]

[section:thread_pool thread_pool]

[indexterm1 boost_asio.indexterm.thread_pool..thread_pool]


A simple fixed-size thread pool. 


  class thread_pool :
    public execution_context


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type [*basic_executor_type]]]
    [Executor implementation type used to submit functions to a thread pool. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool.executor_type [*executor_type]]]
    [Executor used to submit functions to a thread pool. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool.fork_event [*fork_event]]]
    [Fork-related event notifications. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool.scheduler_type [*scheduler_type]]]
    [Scheduler used to schedule receivers on a thread pool. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool.attach [*attach]]]
    [Attaches the current thread to the pool. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.executor [*executor]]]
    [Obtains the executor associated with the pool. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.get_executor [*get_executor]]]
    [Obtains the executor associated with the pool. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.join [*join]]]
    [Joins the threads. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.notify_fork [*notify_fork]]]
    [Notify the execution_context of a fork-related event. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.scheduler [*scheduler]]]
    [Obtains the scheduler associated with the pool. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.stop [*stop]]]
    [Stops the threads. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.thread_pool [*thread_pool]] [constructor]]
    [Constructs a pool with an automatically determined number of threads. 
     [hr]
     Constructs a pool with a specified number of threads. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.wait [*wait]]]
    [Waits for threads to complete. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool._thread_pool [*~thread_pool]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool.destroy [*destroy]]]
    [Destroys all services in the context. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.shutdown [*shutdown]]]
    [Shuts down all services in the context. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool.add_service [*add_service]]]
    [(Deprecated: Use make_service().) Add a service object to the execution_context. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.has_service [*has_service]]]
    [Determine if an execution_context contains a specified service type. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.make_service [*make_service]]]
    [Creates a service object and adds it to the execution_context. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool.use_service [*use_service]]]
    [Obtain the service object corresponding to the given type. ]
  ]
  
]

The thread pool class is an execution context where functions are permitted to run on one of a fixed number of threads.


[heading Submitting tasks to the pool]
  


To submit functions to the thread pool, use the [link boost_asio.reference.dispatch `dispatch`] , [link boost_asio.reference.post `post`]  or [link boost_asio.reference.defer `defer`]  free functions.

For example:



   void my_task()
   {
     ...
   }

   ...

   // Launch the pool with four threads.
   boost::asio::thread_pool pool(4);

   // Submit a function to the pool.
   boost::asio::post(pool, my_task);

   // Submit a lambda object to the pool.
   boost::asio::post(pool,
       []()
       {
         ...
       });

   // Wait for all tasks in the pool to complete.
   pool.join(); 




[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:add_service thread_pool::add_service]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.thread_pool.add_service..add_service..thread_pool] 
(Deprecated: Use `make_service()`.) Add a service object to the [link boost_asio.reference.execution_context `execution_context`]. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend void add_service(
      execution_context & e,
      Service * svc);


This function is used to add a service to the [link boost_asio.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

[[svc][The service object. On success, ownership of the service object is transferred to the [link boost_asio.reference.execution_context `execution_context`]. When the [link boost_asio.reference.execution_context `execution_context`] object is destroyed, it will destroy the service object by performing:
``
   delete static_cast<execution_context::service*>(svc) 
``
]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`].]]

[[boost::asio::invalid_service_owner][Thrown if the service's owning [link boost_asio.reference.execution_context `execution_context`] is not the [link boost_asio.reference.execution_context `execution_context`] object specified by the `e` parameter. ]]

]



[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:attach thread_pool::attach]

[indexterm2 boost_asio.indexterm.thread_pool.attach..attach..thread_pool] 
Attaches the current thread to the pool. 


  void attach();


This function attaches the current thread to the pool so that it may be used for executing submitted function objects. Blocks the calling thread until the pool is stopped or joined and has no outstanding work. 


[endsect]



[section:destroy thread_pool::destroy]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.thread_pool.destroy..destroy..thread_pool] 
Destroys all services in the context. 


  void destroy();


This function is implemented as follows:


* For each service object `svc` in the [link boost_asio.reference.execution_context `execution_context`] set, in reverse order * of the beginning of service object lifetime, performs `delete static_cast<execution_context::service*>(svc)`. 




[endsect]



[section:executor thread_pool::executor]

[indexterm2 boost_asio.indexterm.thread_pool.executor..executor..thread_pool] 
Obtains the executor associated with the pool. 


  executor_type executor();



[endsect]



[section:executor_type thread_pool::executor_type]

[indexterm2 boost_asio.indexterm.thread_pool.executor_type..executor_type..thread_pool] 
Executor used to submit functions to a thread pool. 


  typedef basic_executor_type< std::allocator< void >, 0 > executor_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type.index_type [*index_type]]]
    [The bulk execution index type. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type.sender_type [*sender_type]]]
    [The sender type, when this type is used as a scheduler. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type.shape_type [*shape_type]]]
    [The bulk execution shape type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.basic_executor_type [*basic_executor_type]] [constructor]]
    [Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.bulk_execute [*bulk_execute]]]
    [Bulk execution function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.connect [*connect]]]
    [Connect function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.defer [*defer]]]
    [Request the thread pool to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.dispatch [*dispatch]]]
    [Request the thread pool to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.execute [*execute]]]
    [Execution function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.on_work_finished [*on_work_finished]]]
    [Inform the thread pool that some work is no longer outstanding. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.on_work_started [*on_work_started]]]
    [Inform the thread pool that it has some outstanding work to do. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move assignment operator. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.post [*post]]]
    [Request the thread pool to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.query [*query]]]
    [Query the current value of the context property. 
     [hr]
     Query the current value of the blocking property. 
     [hr]
     Query the current value of the relationship property. 
     [hr]
     Query the current value of the allocator property. 
     [hr]
     Query the occupancy (recommended number of work items) for the pool. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.query__static [*query]] [static]]
    [Query the current value of the bulk_guarantee property. 
     [hr]
     Query the current value of the mapping property. 
     [hr]
     Query the current value of the outstanding_work property. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.require [*require]]]
    [Obtain an executor with the blocking.possibly property. 
     [hr]
     Obtain an executor with the blocking.always property. 
     [hr]
     Obtain an executor with the blocking.never property. 
     [hr]
     Obtain an executor with the relationship.fork property. 
     [hr]
     Obtain an executor with the relationship.continuation property. 
     [hr]
     Obtain an executor with the outstanding_work.tracked property. 
     [hr]
     Obtain an executor with the outstanding_work.untracked property. 
     [hr]
     Obtain an executor with the specified allocator property. 
     [hr]
     Obtain an executor with the default allocator property. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the thread pool is running in the current thread. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.schedule [*schedule]]]
    [Schedule function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type._basic_executor_type [*~basic_executor_type]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:fork_event thread_pool::fork_event]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.thread_pool.fork_event..fork_event..thread_pool] 
Fork-related event notifications. 

  enum fork_event

[indexterm2 boost_asio.indexterm.thread_pool.fork_event.fork_prepare..fork_prepare..thread_pool]
[indexterm2 boost_asio.indexterm.thread_pool.fork_event.fork_parent..fork_parent..thread_pool]
[indexterm2 boost_asio.indexterm.thread_pool.fork_event.fork_child..fork_child..thread_pool]

[heading Values]
[variablelist

  [
    [fork_prepare]
    [Notify the context that the process is about to fork. ]
  ]

  [
    [fork_parent]
    [Notify the context that the process has forked and is the parent. ]
  ]

  [
    [fork_child]
    [Notify the context that the process has forked and is the child. ]
  ]

]



[endsect]



[section:get_executor thread_pool::get_executor]

[indexterm2 boost_asio.indexterm.thread_pool.get_executor..get_executor..thread_pool] 
Obtains the executor associated with the pool. 


  executor_type get_executor();



[endsect]



[section:has_service thread_pool::has_service]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.thread_pool.has_service..has_service..thread_pool] 
Determine if an [link boost_asio.reference.execution_context `execution_context`] contains a specified service type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend bool has_service(
      execution_context & e);


This function is used to determine whether the [link boost_asio.reference.execution_context `execution_context`] contains a service object corresponding to the given service type.


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
A boolean indicating whether the [link boost_asio.reference.execution_context `execution_context`] contains the service. 



[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:join thread_pool::join]

[indexterm2 boost_asio.indexterm.thread_pool.join..join..thread_pool] 
Joins the threads. 


  void join();


This function blocks until the threads in the pool have completed. If `stop()` is not called prior to `join()`, the `join()` call will wait until the pool has no more outstanding work. 


[endsect]



[section:make_service thread_pool::make_service]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.thread_pool.make_service..make_service..thread_pool] 
Creates a service object and adds it to the [link boost_asio.reference.execution_context `execution_context`]. 


  template<
      typename ``[link boost_asio.reference.Service Service]``,
      typename... Args>
  friend Service & make_service(
      execution_context & e,
      Args &&... args);


This function is used to add a service to the [link boost_asio.reference.execution_context `execution_context`].


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

[[args][Zero or more arguments to be passed to the service constructor.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::asio::service_already_exists][Thrown if a service of the given type is already present in the [link boost_asio.reference.execution_context `execution_context`]. ]]

]



[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:notify_fork thread_pool::notify_fork]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.thread_pool.notify_fork..notify_fork..thread_pool] 
Notify the [link boost_asio.reference.execution_context `execution_context`] of a fork-related event. 


  void notify_fork(
      fork_event event);


This function is used to inform the [link boost_asio.reference.execution_context `execution_context`] that the process is about to fork, or has just forked. This allows the [link boost_asio.reference.execution_context `execution_context`], and the services it contains, to perform any necessary housekeeping to ensure correct operation following a fork.

This function must not be called while any other [link boost_asio.reference.execution_context `execution_context`] function, or any function associated with the execution\_context's derived class, is being called in another thread. It is, however, safe to call this function from within a completion handler, provided no other thread is accessing the [link boost_asio.reference.execution_context `execution_context`] or its derived class.


[heading Parameters]
    

[variablelist
  
[[event][A fork-related event.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. If the notification fails the [link boost_asio.reference.execution_context `execution_context`] object should no longer be used and should be destroyed.]]

]


[heading Example]
  
The following code illustrates how to incorporate the `notify_fork()` function: 

   my_execution_context.notify_fork(execution_context::fork_prepare);
   if (fork() == 0)
   {
     // This is the child process.
     my_execution_context.notify_fork(execution_context::fork_child);
   }
   else
   {
     // This is the parent process.
     my_execution_context.notify_fork(execution_context::fork_parent);
   } 





[heading Remarks]
      
For each service object `svc` in the [link boost_asio.reference.execution_context `execution_context`] set, performs `svc->notify_fork();`. When processing the fork\_prepare event, services are visited in reverse order of the beginning of service object lifetime. Otherwise, services are visited in order of the beginning of service object lifetime. 




[endsect]



[section:scheduler thread_pool::scheduler]

[indexterm2 boost_asio.indexterm.thread_pool.scheduler..scheduler..thread_pool] 
Obtains the scheduler associated with the pool. 


  scheduler_type scheduler();



[endsect]



[section:scheduler_type thread_pool::scheduler_type]

[indexterm2 boost_asio.indexterm.thread_pool.scheduler_type..scheduler_type..thread_pool] 
Scheduler used to schedule receivers on a thread pool. 


  typedef basic_executor_type< std::allocator< void >, 0 > scheduler_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type.index_type [*index_type]]]
    [The bulk execution index type. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type.sender_type [*sender_type]]]
    [The sender type, when this type is used as a scheduler. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type.shape_type [*shape_type]]]
    [The bulk execution shape type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.basic_executor_type [*basic_executor_type]] [constructor]]
    [Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.bulk_execute [*bulk_execute]]]
    [Bulk execution function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.connect [*connect]]]
    [Connect function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.defer [*defer]]]
    [Request the thread pool to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.dispatch [*dispatch]]]
    [Request the thread pool to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.execute [*execute]]]
    [Execution function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.on_work_finished [*on_work_finished]]]
    [Inform the thread pool that some work is no longer outstanding. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.on_work_started [*on_work_started]]]
    [Inform the thread pool that it has some outstanding work to do. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move assignment operator. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.post [*post]]]
    [Request the thread pool to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.query [*query]]]
    [Query the current value of the context property. 
     [hr]
     Query the current value of the blocking property. 
     [hr]
     Query the current value of the relationship property. 
     [hr]
     Query the current value of the allocator property. 
     [hr]
     Query the occupancy (recommended number of work items) for the pool. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.query__static [*query]] [static]]
    [Query the current value of the bulk_guarantee property. 
     [hr]
     Query the current value of the mapping property. 
     [hr]
     Query the current value of the outstanding_work property. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.require [*require]]]
    [Obtain an executor with the blocking.possibly property. 
     [hr]
     Obtain an executor with the blocking.always property. 
     [hr]
     Obtain an executor with the blocking.never property. 
     [hr]
     Obtain an executor with the relationship.fork property. 
     [hr]
     Obtain an executor with the relationship.continuation property. 
     [hr]
     Obtain an executor with the outstanding_work.tracked property. 
     [hr]
     Obtain an executor with the outstanding_work.untracked property. 
     [hr]
     Obtain an executor with the specified allocator property. 
     [hr]
     Obtain an executor with the default allocator property. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the thread pool is running in the current thread. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.schedule [*schedule]]]
    [Schedule function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type._basic_executor_type [*~basic_executor_type]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:shutdown thread_pool::shutdown]


['Inherited from execution_context.]

[indexterm2 boost_asio.indexterm.thread_pool.shutdown..shutdown..thread_pool] 
Shuts down all services in the context. 


  void shutdown();


This function is implemented as follows:


* For each service object `svc` in the [link boost_asio.reference.execution_context `execution_context`] set, in reverse order of the beginning of service object lifetime, performs `svc->shutdown()`. 




[endsect]



[section:stop thread_pool::stop]

[indexterm2 boost_asio.indexterm.thread_pool.stop..stop..thread_pool] 
Stops the threads. 


  void stop();


This function stops the threads as soon as possible. As a result of calling `stop()`, pending function objects may be never be invoked. 


[endsect]


[section:thread_pool thread_pool::thread_pool]

[indexterm2 boost_asio.indexterm.thread_pool.thread_pool..thread_pool..thread_pool] 
Constructs a pool with an automatically determined number of threads. 


  ``[link boost_asio.reference.thread_pool.thread_pool.overload1 thread_pool]``();
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool.thread_pool.overload1 more...]]``


Constructs a pool with a specified number of threads. 


  ``[link boost_asio.reference.thread_pool.thread_pool.overload2 thread_pool]``(
      std::size_t num_threads);
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool.thread_pool.overload2 more...]]``


[section:overload1 thread_pool::thread_pool (1 of 2 overloads)]


Constructs a pool with an automatically determined number of threads. 


  thread_pool();



[endsect]



[section:overload2 thread_pool::thread_pool (2 of 2 overloads)]


Constructs a pool with a specified number of threads. 


  thread_pool(
      std::size_t num_threads);



[endsect]


[endsect]

[section:use_service thread_pool::use_service]

[indexterm2 boost_asio.indexterm.thread_pool.use_service..use_service..thread_pool] 
Obtain the service object corresponding to the given type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & ``[link boost_asio.reference.thread_pool.use_service.overload1 use_service]``(
      execution_context & e);
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool.use_service.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & ``[link boost_asio.reference.thread_pool.use_service.overload2 use_service]``(
      io_context & ioc);
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool.use_service.overload2 more...]]``


[section:overload1 thread_pool::use_service (1 of 2 overloads)]


['Inherited from execution_context.]


Obtain the service object corresponding to the given type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & use_service(
      execution_context & e);


This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the [link boost_asio.reference.execution_context `execution_context`] will create a new instance of the service.


[heading Parameters]
    

[variablelist
  
[[e][The [link boost_asio.reference.execution_context `execution_context`] object that owns the service.]]

]


[heading Return Value]
      
The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller. 



[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:overload2 thread_pool::use_service (2 of 2 overloads)]


['Inherited from execution_context.]


Obtain the service object corresponding to the given type. 


  template<
      typename ``[link boost_asio.reference.Service Service]``>
  friend Service & use_service(
      io_context & ioc);


This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the [link boost_asio.reference.io_context `io_context`] will create a new instance of the service.


[heading Parameters]
    

[variablelist
  
[[ioc][The [link boost_asio.reference.io_context `io_context`] object that owns the service.]]

]


[heading Return Value]
      
The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller.


[heading Remarks]
      
This overload is preserved for backwards compatibility with services that inherit from [link boost_asio.reference.io_context__service `io_context::service`]. 



[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[endsect]


[section:wait thread_pool::wait]

[indexterm2 boost_asio.indexterm.thread_pool.wait..wait..thread_pool] 
Waits for threads to complete. 


  void wait();


This function blocks until the threads in the pool have completed. If `stop()` is not called prior to `wait()`, the `wait()` call will wait until the pool has no more outstanding work. 


[endsect]



[section:_thread_pool thread_pool::~thread_pool]

[indexterm2 boost_asio.indexterm.thread_pool._thread_pool..~thread_pool..thread_pool] 
Destructor. 


  ~thread_pool();


Automatically stops and joins the pool, if not explicitly done beforehand. 


[endsect]



[endsect]

[section:thread_pool__basic_executor_type thread_pool::basic_executor_type]

[indexterm1 boost_asio.indexterm.thread_pool__basic_executor_type..thread_pool::basic_executor_type]


Executor implementation type used to submit functions to a thread pool. 


  template<
      typename Allocator,
      unsigned int Bits>
  class basic_executor_type


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type.index_type [*index_type]]]
    [The bulk execution index type. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type.sender_type [*sender_type]]]
    [The sender type, when this type is used as a scheduler. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type.shape_type [*shape_type]]]
    [The bulk execution shape type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.basic_executor_type [*basic_executor_type]] [constructor]]
    [Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.bulk_execute [*bulk_execute]]]
    [Bulk execution function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.connect [*connect]]]
    [Connect function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.defer [*defer]]]
    [Request the thread pool to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.dispatch [*dispatch]]]
    [Request the thread pool to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.execute [*execute]]]
    [Execution function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.on_work_finished [*on_work_finished]]]
    [Inform the thread pool that some work is no longer outstanding. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.on_work_started [*on_work_started]]]
    [Inform the thread pool that it has some outstanding work to do. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move assignment operator. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.post [*post]]]
    [Request the thread pool to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.query [*query]]]
    [Query the current value of the context property. 
     [hr]
     Query the current value of the blocking property. 
     [hr]
     Query the current value of the relationship property. 
     [hr]
     Query the current value of the allocator property. 
     [hr]
     Query the occupancy (recommended number of work items) for the pool. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.query__static [*query]] [static]]
    [Query the current value of the bulk_guarantee property. 
     [hr]
     Query the current value of the mapping property. 
     [hr]
     Query the current value of the outstanding_work property. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.require [*require]]]
    [Obtain an executor with the blocking.possibly property. 
     [hr]
     Obtain an executor with the blocking.always property. 
     [hr]
     Obtain an executor with the blocking.never property. 
     [hr]
     Obtain an executor with the relationship.fork property. 
     [hr]
     Obtain an executor with the relationship.continuation property. 
     [hr]
     Obtain an executor with the outstanding_work.tracked property. 
     [hr]
     Obtain an executor with the outstanding_work.untracked property. 
     [hr]
     Obtain an executor with the specified allocator property. 
     [hr]
     Obtain an executor with the default allocator property. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the thread pool is running in the current thread. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.schedule [*schedule]]]
    [Schedule function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type._basic_executor_type [*~basic_executor_type]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:basic_executor_type thread_pool::basic_executor_type::basic_executor_type]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.basic_executor_type..basic_executor_type..thread_pool::basic_executor_type] 
Copy constructor. 


  ``[link boost_asio.reference.thread_pool__basic_executor_type.basic_executor_type.overload1 basic_executor_type]``(
      const basic_executor_type & other);
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.basic_executor_type.overload1 more...]]``


Move constructor. 


  ``[link boost_asio.reference.thread_pool__basic_executor_type.basic_executor_type.overload2 basic_executor_type]``(
      basic_executor_type && other);
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.basic_executor_type.overload2 more...]]``


[section:overload1 thread_pool::basic_executor_type::basic_executor_type (1 of 2 overloads)]


Copy constructor. 


  basic_executor_type(
      const basic_executor_type & other);



[endsect]



[section:overload2 thread_pool::basic_executor_type::basic_executor_type (2 of 2 overloads)]


Move constructor. 


  basic_executor_type(
      basic_executor_type && other);



[endsect]


[endsect]


[section:bulk_execute thread_pool::basic_executor_type::bulk_execute]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.bulk_execute..bulk_execute..thread_pool::basic_executor_type] 
Bulk execution function. 


  template<
      typename Function>
  void bulk_execute(
      Function && f,
      std::size_t n) const;



[endsect]



[section:connect thread_pool::basic_executor_type::connect]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.connect..connect..thread_pool::basic_executor_type] 
Connect function. 


  template<
      typename ``[link boost_asio.reference.Receiver Receiver]``>
  unspecified connect(
      Receiver && r) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.execution__connect `execution::connect`] customisation point.


[heading Return Value]
      
An object of an unspecified type that satisfies the `operation_state` concept. 




[endsect]



[section:context thread_pool::basic_executor_type::context]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.context..context..thread_pool::basic_executor_type] 
Obtain the underlying execution context. 


  thread_pool & context() const;



[endsect]



[section:defer thread_pool::basic_executor_type::defer]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.defer..defer..thread_pool::basic_executor_type] 
Request the thread pool to invoke the given function object. 


  template<
      typename Function,
      typename OtherAllocator>
  void defer(
      Function && f,
      const OtherAllocator & a) const;


This function is used to ask the thread pool to execute the given function object. The function object will never be executed inside `defer()`. Instead, it will be scheduled to run on the thread pool.

If the current thread belongs to the thread pool, `defer()` will delay scheduling the function object until the current thread returns control to the pool.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:dispatch thread_pool::basic_executor_type::dispatch]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.dispatch..dispatch..thread_pool::basic_executor_type] 
Request the thread pool to invoke the given function object. 


  template<
      typename Function,
      typename OtherAllocator>
  void dispatch(
      Function && f,
      const OtherAllocator & a) const;


This function is used to ask the thread pool to execute the given function object. If the current thread belongs to the pool, `dispatch()` executes the function before returning. Otherwise, the function will be scheduled to run on the thread pool.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]



[section:execute thread_pool::basic_executor_type::execute]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.execute..execute..thread_pool::basic_executor_type] 
Execution function. 


  template<
      typename Function>
  void execute(
      Function && f) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.execution__execute `execution::execute`] customisation point.

For example: 

   auto ex = my_thread_pool.executor();
   execution::execute(ex, my_function_object); 





[endsect]



[section:index_type thread_pool::basic_executor_type::index_type]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.index_type..index_type..thread_pool::basic_executor_type] 
The bulk execution index type. 


  typedef std::size_t index_type;



[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:on_work_finished thread_pool::basic_executor_type::on_work_finished]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.on_work_finished..on_work_finished..thread_pool::basic_executor_type] 
Inform the thread pool that some work is no longer outstanding. 


  void on_work_finished() const;


This function is used to inform the thread pool that some work has finished. Once the count of unfinished work reaches zero, the thread pool's `join()` function is permitted to exit. 


[endsect]



[section:on_work_started thread_pool::basic_executor_type::on_work_started]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.on_work_started..on_work_started..thread_pool::basic_executor_type] 
Inform the thread pool that it has some outstanding work to do. 


  void on_work_started() const;


This function is used to inform the thread pool that some work has begun. This ensures that the thread pool's `join()` function will not return while the work is underway. 


[endsect]



[section:operator_not__eq_ thread_pool::basic_executor_type::operator!=]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.operator_not__eq_..operator!=..thread_pool::basic_executor_type] 
Compare two executors for inequality. 


  friend bool operator!=(
      const basic_executor_type & a,
      const basic_executor_type & b);


Two executors are equal if they refer to the same underlying thread pool. 

[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:operator_eq_ thread_pool::basic_executor_type::operator=]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.operator_eq_..operator=..thread_pool::basic_executor_type] 
Assignment operator. 


  basic_executor_type & ``[link boost_asio.reference.thread_pool__basic_executor_type.operator_eq_.overload1 operator=]``(
      const basic_executor_type & other);
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.operator_eq_.overload1 more...]]``


Move assignment operator. 


  basic_executor_type & ``[link boost_asio.reference.thread_pool__basic_executor_type.operator_eq_.overload2 operator=]``(
      basic_executor_type && other);
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.operator_eq_.overload2 more...]]``


[section:overload1 thread_pool::basic_executor_type::operator= (1 of 2 overloads)]


Assignment operator. 


  basic_executor_type & operator=(
      const basic_executor_type & other);



[endsect]



[section:overload2 thread_pool::basic_executor_type::operator= (2 of 2 overloads)]


Move assignment operator. 


  basic_executor_type & operator=(
      basic_executor_type && other);



[endsect]


[endsect]


[section:operator_eq__eq_ thread_pool::basic_executor_type::operator==]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.operator_eq__eq_..operator==..thread_pool::basic_executor_type] 
Compare two executors for equality. 


  friend bool operator==(
      const basic_executor_type & a,
      const basic_executor_type & b);


Two executors are equal if they refer to the same underlying thread pool. 

[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:post thread_pool::basic_executor_type::post]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.post..post..thread_pool::basic_executor_type] 
Request the thread pool to invoke the given function object. 


  template<
      typename Function,
      typename OtherAllocator>
  void post(
      Function && f,
      const OtherAllocator & a) const;


This function is used to ask the thread pool to execute the given function object. The function object will never be executed inside `post()`. Instead, it will be scheduled to run on the thread pool.


[heading Parameters]
    

[variablelist
  
[[f][The function object to be called. The executor will make a copy of the handler object as required. The function signature of the function object must be:
``
   void function(); 
``
]]

[[a][An allocator that may be used by the executor to allocate the internal storage needed for function invocation. ]]

]




[endsect]


[section:query thread_pool::basic_executor_type::query]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.query..query..thread_pool::basic_executor_type] 
Query the current value of the `context` property. 


  thread_pool & ``[link boost_asio.reference.thread_pool__basic_executor_type.query.overload1 query]``(
      execution::context_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.query.overload1 more...]]``


Query the current value of the `blocking` property. 


  constexpr execution::blocking_t ``[link boost_asio.reference.thread_pool__basic_executor_type.query.overload2 query]``(
      execution::blocking_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.query.overload2 more...]]``


Query the current value of the `relationship` property. 


  constexpr execution::relationship_t ``[link boost_asio.reference.thread_pool__basic_executor_type.query.overload3 query]``(
      execution::relationship_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.query.overload3 more...]]``


Query the current value of the `allocator` property. 


  template<
      typename OtherAllocator>
  constexpr Allocator ``[link boost_asio.reference.thread_pool__basic_executor_type.query.overload4 query]``(
      execution::allocator_t< OtherAllocator > ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.query.overload4 more...]]``

  constexpr Allocator ``[link boost_asio.reference.thread_pool__basic_executor_type.query.overload5 query]``(
      execution::allocator_t< void > ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.query.overload5 more...]]``


Query the occupancy (recommended number of work items) for the pool. 


  std::size_t ``[link boost_asio.reference.thread_pool__basic_executor_type.query.overload6 query]``(
      execution::occupancy_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.query.overload6 more...]]``


[section:overload1 thread_pool::basic_executor_type::query (1 of 6 overloads)]


Query the current value of the `context` property. 


  thread_pool & query(
      execution::context_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_thread_pool.executor();
   boost::asio::thread_pool& pool = boost::asio::query(
       ex, boost::asio::execution::context); 





[endsect]



[section:overload2 thread_pool::basic_executor_type::query (2 of 6 overloads)]


Query the current value of the `blocking` property. 


  constexpr execution::blocking_t query(
      execution::blocking_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_thread_pool.executor();
   if (boost::asio::query(ex, boost::asio::execution::blocking)
         == boost::asio::execution::blocking.always)
     ... 





[endsect]



[section:overload3 thread_pool::basic_executor_type::query (3 of 6 overloads)]


Query the current value of the `relationship` property. 


  constexpr execution::relationship_t query(
      execution::relationship_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_thread_pool.executor();
   if (boost::asio::query(ex, boost::asio::execution::relationship)
         == boost::asio::execution::relationship.continuation)
     ... 





[endsect]



[section:overload4 thread_pool::basic_executor_type::query (4 of 6 overloads)]


Query the current value of the `allocator` property. 


  template<
      typename OtherAllocator>
  constexpr Allocator query(
      execution::allocator_t< OtherAllocator > ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_thread_pool.executor();
   auto alloc = boost::asio::query(ex,
       boost::asio::execution::allocator); 





[endsect]



[section:overload5 thread_pool::basic_executor_type::query (5 of 6 overloads)]


Query the current value of the `allocator` property. 


  constexpr Allocator query(
      execution::allocator_t< void > ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_thread_pool.executor();
   auto alloc = boost::asio::query(ex,
       boost::asio::execution::allocator); 





[endsect]



[section:overload6 thread_pool::basic_executor_type::query (6 of 6 overloads)]


Query the occupancy (recommended number of work items) for the pool. 


  std::size_t query(
      execution::occupancy_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_thread_pool.executor();
   std::size_t occupancy = boost::asio::query(
       ex, boost::asio::execution::occupancy); 





[endsect]


[endsect]

[section:query__static thread_pool::basic_executor_type::query]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.query__static..query..thread_pool::basic_executor_type] 
Query the current value of the `bulk_guarantee` property. 


  static constexpr execution::bulk_guarantee_t ``[link boost_asio.reference.thread_pool__basic_executor_type.query__static.overload1 query]``(
      execution::bulk_guarantee_t );
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.query__static.overload1 more...]]``


Query the current value of the `mapping` property. 


  static constexpr execution::mapping_t ``[link boost_asio.reference.thread_pool__basic_executor_type.query__static.overload2 query]``(
      execution::mapping_t );
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.query__static.overload2 more...]]``


Query the current value of the `outstanding_work` property. 


  static constexpr execution::outstanding_work_t ``[link boost_asio.reference.thread_pool__basic_executor_type.query__static.overload3 query]``(
      execution::outstanding_work_t );
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.query__static.overload3 more...]]``


[section:overload1 thread_pool::basic_executor_type::query (1 of 3 overloads)]


Query the current value of the `bulk_guarantee` property. 


  static constexpr execution::bulk_guarantee_t query(
      execution::bulk_guarantee_t );


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_thread_pool.executor();
   if (boost::asio::query(ex, boost::asio::execution::bulk_guarantee)
         == boost::asio::execution::bulk_guarantee.parallel)
     ... 





[endsect]



[section:overload2 thread_pool::basic_executor_type::query (2 of 3 overloads)]


Query the current value of the `mapping` property. 


  static constexpr execution::mapping_t query(
      execution::mapping_t );


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_thread_pool.executor();
   if (boost::asio::query(ex, boost::asio::execution::mapping)
         == boost::asio::execution::mapping.thread)
     ... 





[endsect]



[section:overload3 thread_pool::basic_executor_type::query (3 of 3 overloads)]


Query the current value of the `outstanding_work` property. 


  static constexpr execution::outstanding_work_t query(
      execution::outstanding_work_t );


Do not call this function directly. It is intended for use with the [link boost_asio.reference.query `query`] customisation point.

For example: 

   auto ex = my_thread_pool.executor();
   if (boost::asio::query(ex, boost::asio::execution::outstanding_work)
         == boost::asio::execution::outstanding_work.tracked)
     ... 





[endsect]


[endsect]

[section:require thread_pool::basic_executor_type::require]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.require..require..thread_pool::basic_executor_type] 
Obtain an executor with the `blocking.possibly` property. 


  constexpr basic_executor_type< Allocator, unspecified > ``[link boost_asio.reference.thread_pool__basic_executor_type.require.overload1 require]``(
      execution::blocking_t::possibly_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.require.overload1 more...]]``


Obtain an executor with the `blocking.always` property. 


  constexpr basic_executor_type< Allocator, unspecified > ``[link boost_asio.reference.thread_pool__basic_executor_type.require.overload2 require]``(
      execution::blocking_t::always_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.require.overload2 more...]]``


Obtain an executor with the `blocking.never` property. 


  constexpr basic_executor_type< Allocator, unspecified > ``[link boost_asio.reference.thread_pool__basic_executor_type.require.overload3 require]``(
      execution::blocking_t::never_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.require.overload3 more...]]``


Obtain an executor with the `relationship.fork` property. 


  constexpr basic_executor_type ``[link boost_asio.reference.thread_pool__basic_executor_type.require.overload4 require]``(
      execution::relationship_t::fork_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.require.overload4 more...]]``


Obtain an executor with the `relationship.continuation` property. 


  constexpr basic_executor_type ``[link boost_asio.reference.thread_pool__basic_executor_type.require.overload5 require]``(
      execution::relationship_t::continuation_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.require.overload5 more...]]``


Obtain an executor with the `outstanding_work.tracked` property. 


  constexpr basic_executor_type< Allocator, unspecified > ``[link boost_asio.reference.thread_pool__basic_executor_type.require.overload6 require]``(
      execution::outstanding_work_t::tracked_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.require.overload6 more...]]``


Obtain an executor with the `outstanding_work.untracked` property. 


  constexpr basic_executor_type< Allocator, unspecified > ``[link boost_asio.reference.thread_pool__basic_executor_type.require.overload7 require]``(
      execution::outstanding_work_t::untracked_t ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.require.overload7 more...]]``


Obtain an executor with the specified `allocator` property. 


  template<
      typename OtherAllocator>
  constexpr basic_executor_type< OtherAllocator, Bits > ``[link boost_asio.reference.thread_pool__basic_executor_type.require.overload8 require]``(
      execution::allocator_t< OtherAllocator > a) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.require.overload8 more...]]``


Obtain an executor with the default `allocator` property. 


  constexpr basic_executor_type< std::allocator< void >, Bits > ``[link boost_asio.reference.thread_pool__basic_executor_type.require.overload9 require]``(
      execution::allocator_t< void > ) const;
  ``  [''''&raquo;''' [link boost_asio.reference.thread_pool__basic_executor_type.require.overload9 more...]]``


[section:overload1 thread_pool::basic_executor_type::require (1 of 9 overloads)]


Obtain an executor with the `blocking.possibly` property. 


  constexpr basic_executor_type< Allocator, unspecified > require(
      execution::blocking_t::possibly_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_thread_pool.executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::blocking.possibly); 





[endsect]



[section:overload2 thread_pool::basic_executor_type::require (2 of 9 overloads)]


Obtain an executor with the `blocking.always` property. 


  constexpr basic_executor_type< Allocator, unspecified > require(
      execution::blocking_t::always_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_thread_pool.executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::blocking.always); 





[endsect]



[section:overload3 thread_pool::basic_executor_type::require (3 of 9 overloads)]


Obtain an executor with the `blocking.never` property. 


  constexpr basic_executor_type< Allocator, unspecified > require(
      execution::blocking_t::never_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_thread_pool.executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::blocking.never); 





[endsect]



[section:overload4 thread_pool::basic_executor_type::require (4 of 9 overloads)]


Obtain an executor with the `relationship.fork` property. 


  constexpr basic_executor_type require(
      execution::relationship_t::fork_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_thread_pool.executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::relationship.fork); 





[endsect]



[section:overload5 thread_pool::basic_executor_type::require (5 of 9 overloads)]


Obtain an executor with the `relationship.continuation` property. 


  constexpr basic_executor_type require(
      execution::relationship_t::continuation_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_thread_pool.executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::relationship.continuation); 





[endsect]



[section:overload6 thread_pool::basic_executor_type::require (6 of 9 overloads)]


Obtain an executor with the `outstanding_work.tracked` property. 


  constexpr basic_executor_type< Allocator, unspecified > require(
      execution::outstanding_work_t::tracked_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_thread_pool.executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::outstanding_work.tracked); 





[endsect]



[section:overload7 thread_pool::basic_executor_type::require (7 of 9 overloads)]


Obtain an executor with the `outstanding_work.untracked` property. 


  constexpr basic_executor_type< Allocator, unspecified > require(
      execution::outstanding_work_t::untracked_t ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_thread_pool.executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::outstanding_work.untracked); 





[endsect]



[section:overload8 thread_pool::basic_executor_type::require (8 of 9 overloads)]


Obtain an executor with the specified `allocator` property. 


  template<
      typename OtherAllocator>
  constexpr basic_executor_type< OtherAllocator, Bits > require(
      execution::allocator_t< OtherAllocator > a) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_thread_pool.executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::allocator(my_allocator)); 





[endsect]



[section:overload9 thread_pool::basic_executor_type::require (9 of 9 overloads)]


Obtain an executor with the default `allocator` property. 


  constexpr basic_executor_type< std::allocator< void >, Bits > require(
      execution::allocator_t< void > ) const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.require `require`] customisation point.

For example: 

   auto ex1 = my_thread_pool.executor();
   auto ex2 = boost::asio::require(ex1,
       boost::asio::execution::allocator); 





[endsect]


[endsect]


[section:running_in_this_thread thread_pool::basic_executor_type::running_in_this_thread]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.running_in_this_thread..running_in_this_thread..thread_pool::basic_executor_type] 
Determine whether the thread pool is running in the current thread. 


  bool running_in_this_thread() const;



[heading Return Value]
      
`true` if the current thread is running the thread pool. Otherwise returns `false`. 




[endsect]



[section:schedule thread_pool::basic_executor_type::schedule]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.schedule..schedule..thread_pool::basic_executor_type] 
Schedule function. 


  sender_type schedule() const;


Do not call this function directly. It is intended for use with the [link boost_asio.reference.execution__schedule `execution::schedule`] customisation point.


[heading Return Value]
      
An object that satisfies the sender concept. 




[endsect]



[section:sender_type thread_pool::basic_executor_type::sender_type]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.sender_type..sender_type..thread_pool::basic_executor_type] 
The sender type, when this type is used as a scheduler. 


  typedef basic_executor_type sender_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type.index_type [*index_type]]]
    [The bulk execution index type. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type.sender_type [*sender_type]]]
    [The sender type, when this type is used as a scheduler. ]
  
  ]

  [

    [[link boost_asio.reference.thread_pool__basic_executor_type.shape_type [*shape_type]]]
    [The bulk execution shape type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.basic_executor_type [*basic_executor_type]] [constructor]]
    [Copy constructor. 
     [hr]
     Move constructor. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.bulk_execute [*bulk_execute]]]
    [Bulk execution function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.connect [*connect]]]
    [Connect function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.context [*context]]]
    [Obtain the underlying execution context. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.defer [*defer]]]
    [Request the thread pool to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.dispatch [*dispatch]]]
    [Request the thread pool to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.execute [*execute]]]
    [Execution function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.on_work_finished [*on_work_finished]]]
    [Inform the thread pool that some work is no longer outstanding. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.on_work_started [*on_work_started]]]
    [Inform the thread pool that it has some outstanding work to do. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.operator_eq_ [*operator=]]]
    [Assignment operator. 
     [hr]
     Move assignment operator. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.post [*post]]]
    [Request the thread pool to invoke the given function object. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.query [*query]]]
    [Query the current value of the context property. 
     [hr]
     Query the current value of the blocking property. 
     [hr]
     Query the current value of the relationship property. 
     [hr]
     Query the current value of the allocator property. 
     [hr]
     Query the occupancy (recommended number of work items) for the pool. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.query__static [*query]] [static]]
    [Query the current value of the bulk_guarantee property. 
     [hr]
     Query the current value of the mapping property. 
     [hr]
     Query the current value of the outstanding_work property. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.require [*require]]]
    [Obtain an executor with the blocking.possibly property. 
     [hr]
     Obtain an executor with the blocking.always property. 
     [hr]
     Obtain an executor with the blocking.never property. 
     [hr]
     Obtain an executor with the relationship.fork property. 
     [hr]
     Obtain an executor with the relationship.continuation property. 
     [hr]
     Obtain an executor with the outstanding_work.tracked property. 
     [hr]
     Obtain an executor with the outstanding_work.untracked property. 
     [hr]
     Obtain an executor with the specified allocator property. 
     [hr]
     Obtain an executor with the default allocator property. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.running_in_this_thread [*running_in_this_thread]]]
    [Determine whether the thread pool is running in the current thread. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.schedule [*schedule]]]
    [Schedule function. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type._basic_executor_type [*~basic_executor_type]] [destructor]]
    [Destructor. ]
  ]
  
]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.operator_not__eq_ [*operator!=]]]
    [Compare two executors for inequality. ]
  ]
  
  [
    [[link boost_asio.reference.thread_pool__basic_executor_type.operator_eq__eq_ [*operator==]]]
    [Compare two executors for equality. ]
  ]
  
]


[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:shape_type thread_pool::basic_executor_type::shape_type]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type.shape_type..shape_type..thread_pool::basic_executor_type] 
The bulk execution shape type. 


  typedef std::size_t shape_type;



[heading Requirements]

['Header: ][^boost/asio/thread_pool.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:_basic_executor_type thread_pool::basic_executor_type::~basic_executor_type]

[indexterm2 boost_asio.indexterm.thread_pool__basic_executor_type._basic_executor_type..~basic_executor_type..thread_pool::basic_executor_type] 
Destructor. 


  ~basic_executor_type();



[endsect]



[endsect]

[section:time_traits_lt__ptime__gt_ time_traits< boost::posix_time::ptime >]

[indexterm1 boost_asio.indexterm.time_traits_lt__ptime__gt_..time_traits< boost::posix_time::ptime >]


Time traits specialised for posix\_time. 


  template<>
  struct time_traits< boost::posix_time::ptime >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.time_traits_lt__ptime__gt_.duration_type [*duration_type]]]
    [The duration type. ]
  
  ]

  [

    [[link boost_asio.reference.time_traits_lt__ptime__gt_.time_type [*time_type]]]
    [The time type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.time_traits_lt__ptime__gt_.add [*add]] [static]]
    [Add a duration to a time. ]
  ]
  
  [
    [[link boost_asio.reference.time_traits_lt__ptime__gt_.less_than [*less_than]] [static]]
    [Test whether one time is less than another. ]
  ]
  
  [
    [[link boost_asio.reference.time_traits_lt__ptime__gt_.now [*now]] [static]]
    [Get the current time. ]
  ]
  
  [
    [[link boost_asio.reference.time_traits_lt__ptime__gt_.subtract [*subtract]] [static]]
    [Subtract one time from another. ]
  ]
  
  [
    [[link boost_asio.reference.time_traits_lt__ptime__gt_.to_posix_duration [*to_posix_duration]] [static]]
    [Convert to POSIX duration type. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/time_traits.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:add time_traits< boost::posix_time::ptime >::add]

[indexterm2 boost_asio.indexterm.time_traits_lt__ptime__gt_.add..add..time_traits< boost::posix_time::ptime >] 
Add a duration to a time. 


  static time_type add(
      const time_type & t,
      const duration_type & d);



[endsect]



[section:duration_type time_traits< boost::posix_time::ptime >::duration_type]

[indexterm2 boost_asio.indexterm.time_traits_lt__ptime__gt_.duration_type..duration_type..time_traits< boost::posix_time::ptime >] 
The duration type. 


  typedef boost::posix_time::time_duration duration_type;



[heading Requirements]

['Header: ][^boost/asio/time_traits.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:less_than time_traits< boost::posix_time::ptime >::less_than]

[indexterm2 boost_asio.indexterm.time_traits_lt__ptime__gt_.less_than..less_than..time_traits< boost::posix_time::ptime >] 
Test whether one time is less than another. 


  static bool less_than(
      const time_type & t1,
      const time_type & t2);



[endsect]



[section:now time_traits< boost::posix_time::ptime >::now]

[indexterm2 boost_asio.indexterm.time_traits_lt__ptime__gt_.now..now..time_traits< boost::posix_time::ptime >] 
Get the current time. 


  static time_type now();



[endsect]



[section:subtract time_traits< boost::posix_time::ptime >::subtract]

[indexterm2 boost_asio.indexterm.time_traits_lt__ptime__gt_.subtract..subtract..time_traits< boost::posix_time::ptime >] 
Subtract one time from another. 


  static duration_type subtract(
      const time_type & t1,
      const time_type & t2);



[endsect]



[section:time_type time_traits< boost::posix_time::ptime >::time_type]

[indexterm2 boost_asio.indexterm.time_traits_lt__ptime__gt_.time_type..time_type..time_traits< boost::posix_time::ptime >] 
The time type. 


  typedef boost::posix_time::ptime time_type;



[heading Requirements]

['Header: ][^boost/asio/time_traits.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:to_posix_duration time_traits< boost::posix_time::ptime >::to_posix_duration]

[indexterm2 boost_asio.indexterm.time_traits_lt__ptime__gt_.to_posix_duration..to_posix_duration..time_traits< boost::posix_time::ptime >] 
Convert to POSIX duration type. 


  static boost::posix_time::time_duration to_posix_duration(
      const duration_type & d);



[endsect]



[endsect]


[section:transfer_all transfer_all]

[indexterm1 boost_asio.indexterm.transfer_all..transfer_all] 
Return a completion condition function object that indicates that a read or write operation should continue until all of the data has been transferred, or until an error occurs. 


  unspecified transfer_all();


This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.


[heading Example]
  
Reading until a buffer is full: 

   boost::array<char, 128> buf;
   boost::system::error_code ec;
   std::size_t n = boost::asio::read(
       sock, boost::asio::buffer(buf),
       boost::asio::transfer_all(), ec);
   if (ec)
   {
     // An error occurred.
   }
   else
   {
     // n == 128
   }






[heading Requirements]

['Header: ][^boost/asio/completion_condition.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:transfer_at_least transfer_at_least]

[indexterm1 boost_asio.indexterm.transfer_at_least..transfer_at_least] 
Return a completion condition function object that indicates that a read or write operation should continue until a minimum number of bytes has been transferred, or until an error occurs. 


  unspecified transfer_at_least(
      std::size_t minimum);


This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.


[heading Example]
  
Reading until a buffer is full or contains at least 64 bytes: 

   boost::array<char, 128> buf;
   boost::system::error_code ec;
   std::size_t n = boost::asio::read(
       sock, boost::asio::buffer(buf),
       boost::asio::transfer_at_least(64), ec);
   if (ec)
   {
     // An error occurred.
   }
   else
   {
     // n >= 64 && n <= 128
   }






[heading Requirements]

['Header: ][^boost/asio/completion_condition.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:transfer_exactly transfer_exactly]

[indexterm1 boost_asio.indexterm.transfer_exactly..transfer_exactly] 
Return a completion condition function object that indicates that a read or write operation should continue until an exact number of bytes has been transferred, or until an error occurs. 


  unspecified transfer_exactly(
      std::size_t size);


This function is used to create an object, of unspecified type, that meets CompletionCondition requirements.


[heading Example]
  
Reading until a buffer is full or contains exactly 64 bytes: 

   boost::array<char, 128> buf;
   boost::system::error_code ec;
   std::size_t n = boost::asio::read(
       sock, boost::asio::buffer(buf),
       boost::asio::transfer_exactly(64), ec);
   if (ec)
   {
     // An error occurred.
   }
   else
   {
     // n == 64
   }






[heading Requirements]

['Header: ][^boost/asio/completion_condition.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:use_awaitable use_awaitable]

[indexterm1 boost_asio.indexterm.use_awaitable..use_awaitable] 
A completion token object that represents the currently executing coroutine. 


  constexpr use_awaitable_t use_awaitable;


See the documentation for [link boost_asio.reference.use_awaitable_t `use_awaitable_t`] for a usage example. 

[heading Requirements]

['Header: ][^boost/asio/use_awaitable.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:use_awaitable_t use_awaitable_t]

[indexterm1 boost_asio.indexterm.use_awaitable_t..use_awaitable_t]


A completion token that represents the currently executing coroutine. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  struct use_awaitable_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.use_awaitable_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the use_awaitable_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.use_awaitable_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use use_awaitable_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.use_awaitable_t.use_awaitable_t [*use_awaitable_t]] [constructor]]
    [Default constructor. 
     [hr]
     Constructor used to specify file name, line, and function name. ]
  ]
  
]

The `use_awaitable_t` class, with its value `use_awaitable`, is used to represent the currently executing coroutine. This completion token may be passed as a handler to an asynchronous operation. For example:



   awaitable<void> my_coroutine()
   {
     std::size_t n = co_await my_socket.async_read_some(buffer, use_awaitable);
     ...
   } 




When used with co\_await, the initiating function (`async_read_some` in the above example) suspends the current coroutine. The coroutine is resumed when the asynchronous operation completes, and the result of the operation is returned. 

[heading Requirements]

['Header: ][^boost/asio/use_awaitable.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:as_default_on use_awaitable_t::as_default_on]

[indexterm2 boost_asio.indexterm.use_awaitable_t.as_default_on..as_default_on..use_awaitable_t] 
Function helper to adapt an I/O object to use `use_awaitable_t` as its default completion token type. 


  template<
      typename T>
  static decay< T >::type::template rebind_executor< executor_with_default< typename decay< T >::type::executor_type > >::other as_default_on(
      T && object);



[endsect]


[section:use_awaitable_t use_awaitable_t::use_awaitable_t]

[indexterm2 boost_asio.indexterm.use_awaitable_t.use_awaitable_t..use_awaitable_t..use_awaitable_t] 
Default constructor. 


  constexpr ``[link boost_asio.reference.use_awaitable_t.use_awaitable_t.overload1 use_awaitable_t]``();
  ``  [''''&raquo;''' [link boost_asio.reference.use_awaitable_t.use_awaitable_t.overload1 more...]]``


Constructor used to specify file name, line, and function name. 


  constexpr ``[link boost_asio.reference.use_awaitable_t.use_awaitable_t.overload2 use_awaitable_t]``(
      const char * file_name,
      int line,
      const char * function_name);
  ``  [''''&raquo;''' [link boost_asio.reference.use_awaitable_t.use_awaitable_t.overload2 more...]]``


[section:overload1 use_awaitable_t::use_awaitable_t (1 of 2 overloads)]


Default constructor. 


  constexpr use_awaitable_t();



[endsect]



[section:overload2 use_awaitable_t::use_awaitable_t (2 of 2 overloads)]


Constructor used to specify file name, line, and function name. 


  constexpr use_awaitable_t(
      const char * file_name,
      int line,
      const char * function_name);



[endsect]


[endsect]


[endsect]

[section:use_awaitable_t__executor_with_default use_awaitable_t::executor_with_default]

[indexterm1 boost_asio.indexterm.use_awaitable_t__executor_with_default..use_awaitable_t::executor_with_default]


Adapts an executor to add the `use_awaitable_t` completion token as the default. 


  template<
      typename ``[link boost_asio.reference.Executor1 InnerExecutor]``>
  struct executor_with_default


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.use_awaitable_t__executor_with_default.default_completion_token_type [*default_completion_token_type]]]
    [Specify use_awaitable_t as the default completion token type. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.use_awaitable_t__executor_with_default.executor_with_default [*executor_with_default]] [constructor]]
    [Construct the adapted executor from the inner executor type. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/use_awaitable.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:default_completion_token_type use_awaitable_t::executor_with_default::default_completion_token_type]

[indexterm2 boost_asio.indexterm.use_awaitable_t__executor_with_default.default_completion_token_type..default_completion_token_type..use_awaitable_t::executor_with_default] 
Specify `use_awaitable_t` as the default completion token type. 


  typedef use_awaitable_t default_completion_token_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.use_awaitable_t__executor_with_default [*executor_with_default]]]
    [Adapts an executor to add the use_awaitable_t completion token as the default. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.use_awaitable_t.as_default_on [*as_default_on]] [static]]
    [Function helper to adapt an I/O object to use use_awaitable_t as its default completion token type. ]
  ]
  
  [
    [[link boost_asio.reference.use_awaitable_t.use_awaitable_t [*use_awaitable_t]] [constructor]]
    [Default constructor. 
     [hr]
     Constructor used to specify file name, line, and function name. ]
  ]
  
]

The `use_awaitable_t` class, with its value `use_awaitable`, is used to represent the currently executing coroutine. This completion token may be passed as a handler to an asynchronous operation. For example:



   awaitable<void> my_coroutine()
   {
     std::size_t n = co_await my_socket.async_read_some(buffer, use_awaitable);
     ...
   } 




When used with co\_await, the initiating function (`async_read_some` in the above example) suspends the current coroutine. The coroutine is resumed when the asynchronous operation completes, and the result of the operation is returned. 


[heading Requirements]

['Header: ][^boost/asio/use_awaitable.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:executor_with_default use_awaitable_t::executor_with_default::executor_with_default]

[indexterm2 boost_asio.indexterm.use_awaitable_t__executor_with_default.executor_with_default..executor_with_default..use_awaitable_t::executor_with_default] 
Construct the adapted executor from the inner executor type. 


  template<
      typename ``[link boost_asio.reference.Executor1 InnerExecutor1]``>
  executor_with_default(
      const InnerExecutor1 & ex,
      typename constraint< conditional< !is_same< InnerExecutor1, executor_with_default >::value, is_convertible< InnerExecutor1, InnerExecutor >, false_type >::type::value >::type  = 0);



[endsect]



[endsect]


[section:use_future use_future]

[indexterm1 boost_asio.indexterm.use_future..use_future] 
A special value, similar to std::nothrow. 


  constexpr use_future_t use_future;


See the documentation for [link boost_asio.reference.use_future_t `use_future_t`] for a usage example. 

[heading Requirements]

['Header: ][^boost/asio/use_future.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:use_future_t use_future_t]

[indexterm1 boost_asio.indexterm.use_future_t..use_future_t]


Class used to specify that an asynchronous operation should return a future. 


  template<
      typename Allocator = std::allocator<void>>
  class use_future_t


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.use_future_t.allocator_type [*allocator_type]]]
    [The allocator type. The allocator is used when constructing the std::promise object for a given asynchronous operation. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.use_future_t.get_allocator [*get_allocator]]]
    [Obtain allocator. ]
  ]
  
  [
    [[link boost_asio.reference.use_future_t.operator_lp__rp_ [*operator()]]]
    [Wrap a function object in a packaged task. ]
  ]
  
  [
    [[link boost_asio.reference.use_future_t.operator_lb__rb_ [*operator\[\]]]]
    [(Deprecated: Use rebind().) Specify an alternate allocator. ]
  ]
  
  [
    [[link boost_asio.reference.use_future_t.rebind [*rebind]]]
    [Specify an alternate allocator. ]
  ]
  
  [
    [[link boost_asio.reference.use_future_t.use_future_t [*use_future_t]] [constructor]]
    [Construct using default-constructed allocator. 
     [hr]
     Construct using specified allocator. ]
  ]
  
]

The [link boost_asio.reference.use_future_t `use_future_t`] class is used to indicate that an asynchronous operation should return a std::future object. A [link boost_asio.reference.use_future_t `use_future_t`] object may be passed as a handler to an asynchronous operation, typically using the special value `boost::asio::use_future`. For example:



   std::future<std::size_t> my_future
     = my_socket.async_read_some(my_buffer, boost::asio::use_future); 




The initiating function (async\_read\_some in the above example) returns a future that will receive the result of the operation. If the operation completes with an error\_code indicating failure, it is converted into a system\_error and passed back to the caller via the future. 

[heading Requirements]

['Header: ][^boost/asio/use_future.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:allocator_type use_future_t::allocator_type]

[indexterm2 boost_asio.indexterm.use_future_t.allocator_type..allocator_type..use_future_t] 
The allocator type. The allocator is used when constructing the `std::promise` object for a given asynchronous operation. 


  typedef Allocator allocator_type;



[heading Requirements]

['Header: ][^boost/asio/use_future.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_allocator use_future_t::get_allocator]

[indexterm2 boost_asio.indexterm.use_future_t.get_allocator..get_allocator..use_future_t] 
Obtain allocator. 


  allocator_type get_allocator() const;



[endsect]



[section:operator_lp__rp_ use_future_t::operator()]

[indexterm2 boost_asio.indexterm.use_future_t.operator_lp__rp_..operator()..use_future_t] 
Wrap a function object in a packaged task. 


  template<
      typename Function>
  unspecified operator()(
      Function && f) const;


The `package` function is used to adapt a function object as a packaged task. When this adapter is passed as a completion token to an asynchronous operation, the result of the function object is retuned via a std::future.


[heading Example]
  




   std::future<std::size_t> fut =
     my_socket.async_read_some(buffer,
       use_future([](boost::system::error_code ec, std::size_t n)
         {
           return ec ? 0 : n;
         }));
   ...
   std::size_t n = fut.get(); 





[endsect]



[section:operator_lb__rb_ use_future_t::operator\[\]]

[indexterm2 boost_asio.indexterm.use_future_t.operator_lb__rb_..operator\[\]..use_future_t] 
(Deprecated: Use `rebind()`.) Specify an alternate allocator. 


  template<
      typename OtherAllocator>
  use_future_t< OtherAllocator > operator[](
      const OtherAllocator & allocator) const;



[endsect]



[section:rebind use_future_t::rebind]

[indexterm2 boost_asio.indexterm.use_future_t.rebind..rebind..use_future_t] 
Specify an alternate allocator. 


  template<
      typename OtherAllocator>
  use_future_t< OtherAllocator > rebind(
      const OtherAllocator & allocator) const;



[endsect]


[section:use_future_t use_future_t::use_future_t]

[indexterm2 boost_asio.indexterm.use_future_t.use_future_t..use_future_t..use_future_t] 
Construct using default-constructed allocator. 


  constexpr ``[link boost_asio.reference.use_future_t.use_future_t.overload1 use_future_t]``();
  ``  [''''&raquo;''' [link boost_asio.reference.use_future_t.use_future_t.overload1 more...]]``


Construct using specified allocator. 


  explicit ``[link boost_asio.reference.use_future_t.use_future_t.overload2 use_future_t]``(
      const Allocator & allocator);
  ``  [''''&raquo;''' [link boost_asio.reference.use_future_t.use_future_t.overload2 more...]]``


[section:overload1 use_future_t::use_future_t (1 of 2 overloads)]


Construct using default-constructed allocator. 


  constexpr use_future_t();



[endsect]



[section:overload2 use_future_t::use_future_t (2 of 2 overloads)]


Construct using specified allocator. 


  use_future_t(
      const Allocator & allocator);



[endsect]


[endsect]


[endsect]

[section:uses_executor uses_executor]

[indexterm1 boost_asio.indexterm.uses_executor..uses_executor]


The [link boost_asio.reference.uses_executor `uses_executor`] trait detects whether a type T has an associated executor that is convertible from type Executor. 


  template<
      typename T,
      typename ``[link boost_asio.reference.Executor1 Executor]``>
  struct uses_executor :
    public false_type


Meets the BinaryTypeTrait requirements. The Asio library provides a definition that is derived from `false_type`. A program may specialize this template to derive from true\_type for a user-defined type T that can be constructed with an executor, where the first argument of a constructor has type [link boost_asio.reference.executor_arg_t `executor_arg_t`] and the second argument is convertible from type Executor. 

[heading Requirements]

['Header: ][^boost/asio/uses_executor.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]

[section:wait_traits wait_traits]

[indexterm1 boost_asio.indexterm.wait_traits..wait_traits]


Wait traits suitable for use with the [link boost_asio.reference.basic_waitable_timer `basic_waitable_timer`] class template. 


  template<
      typename Clock>
  struct wait_traits


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.wait_traits.to_wait_duration [*to_wait_duration]] [static]]
    [Convert a clock duration into a duration used for waiting. ]
  ]
  
]

[heading Requirements]

['Header: ][^boost/asio/wait_traits.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:to_wait_duration wait_traits::to_wait_duration]

[indexterm2 boost_asio.indexterm.wait_traits.to_wait_duration..to_wait_duration..wait_traits] 
Convert a clock duration into a duration used for waiting. 


  static Clock::duration ``[link boost_asio.reference.wait_traits.to_wait_duration.overload1 to_wait_duration]``(
      const typename Clock::duration & d);
  ``  [''''&raquo;''' [link boost_asio.reference.wait_traits.to_wait_duration.overload1 more...]]``

  static Clock::duration ``[link boost_asio.reference.wait_traits.to_wait_duration.overload2 to_wait_duration]``(
      const typename Clock::time_point & t);
  ``  [''''&raquo;''' [link boost_asio.reference.wait_traits.to_wait_duration.overload2 more...]]``


[section:overload1 wait_traits::to_wait_duration (1 of 2 overloads)]


Convert a clock duration into a duration used for waiting. 


  static Clock::duration to_wait_duration(
      const typename Clock::duration & d);



[heading Return Value]
      
`d`. 




[endsect]



[section:overload2 wait_traits::to_wait_duration (2 of 2 overloads)]


Convert a clock duration into a duration used for waiting. 


  static Clock::duration to_wait_duration(
      const typename Clock::time_point & t);



[heading Return Value]
      
`d`. 




[endsect]


[endsect]


[endsect]

[section:windows__basic_object_handle windows::basic_object_handle]

[indexterm1 boost_asio.indexterm.windows__basic_object_handle..windows::basic_object_handle]


Provides object-oriented handle functionality. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  class basic_object_handle


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_object_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_object_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_object_handle.lowest_layer_type [*lowest_layer_type]]]
    [An object handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_object_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_object_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.async_wait [*async_wait]]]
    [Start an asynchronous wait on the object handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.basic_object_handle [*basic_object_handle]] [constructor]]
    [Construct an object handle without opening it. 
     [hr]
     Construct an object handle on an existing native handle. 
     [hr]
     Move-construct an object handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.operator_eq_ [*operator=]]]
    [Move-assign an object handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.wait [*wait]]]
    [Perform a blocking wait on the object handle. ]
  ]
  
]

The [link boost_asio.reference.windows__basic_object_handle `windows::basic_object_handle`] class provides asynchronous and blocking object-oriented handle functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/windows/basic_object_handle.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign windows::basic_object_handle::assign]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.assign..assign..windows::basic_object_handle] 
Assign an existing native handle to the handle. 


  void ``[link boost_asio.reference.windows__basic_object_handle.assign.overload1 assign]``(
      const native_handle_type & handle);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.assign.overload1 more...]]``

  void ``[link boost_asio.reference.windows__basic_object_handle.assign.overload2 assign]``(
      const native_handle_type & handle,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.assign.overload2 more...]]``


[section:overload1 windows::basic_object_handle::assign (1 of 2 overloads)]


Assign an existing native handle to the handle. 


  void assign(
      const native_handle_type & handle);



[endsect]



[section:overload2 windows::basic_object_handle::assign (2 of 2 overloads)]


Assign an existing native handle to the handle. 


  void assign(
      const native_handle_type & handle,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_wait windows::basic_object_handle::async_wait]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.async_wait..async_wait..windows::basic_object_handle] 
Start an asynchronous wait on the object handle. 


  template<
      typename ``[link boost_asio.reference.WaitHandler WaitHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_wait(
      WaitHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is be used to initiate an asynchronous wait against the object handle. It always returns immediately.


[heading Parameters]
    

[variablelist
  
[[handler][The handler to be called when the object handle is set to the signalled state. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error // Result of operation.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`]. ]]

]




[endsect]


[section:basic_object_handle windows::basic_object_handle::basic_object_handle]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.basic_object_handle..basic_object_handle..windows::basic_object_handle] 
Construct an object handle without opening it. 


  explicit ``[link boost_asio.reference.windows__basic_object_handle.basic_object_handle.overload1 basic_object_handle]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.basic_object_handle.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.windows__basic_object_handle.basic_object_handle.overload2 basic_object_handle]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.basic_object_handle.overload2 more...]]``


Construct an object handle on an existing native handle. 


  ``[link boost_asio.reference.windows__basic_object_handle.basic_object_handle.overload3 basic_object_handle]``(
      const executor_type & ex,
      const native_handle_type & native_handle);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.basic_object_handle.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.windows__basic_object_handle.basic_object_handle.overload4 basic_object_handle]``(
      ExecutionContext & context,
      const native_handle_type & native_handle,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.basic_object_handle.overload4 more...]]``


Move-construct an object handle from another. 


  ``[link boost_asio.reference.windows__basic_object_handle.basic_object_handle.overload5 basic_object_handle]``(
      basic_object_handle && other);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.basic_object_handle.overload5 more...]]``


[section:overload1 windows::basic_object_handle::basic_object_handle (1 of 5 overloads)]


Construct an object handle without opening it. 


  basic_object_handle(
      const executor_type & ex);


This constructor creates an object handle without opening it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the object handle will use, by default, to dispatch handlers for any asynchronous operations performed on the object handle. ]]

]




[endsect]



[section:overload2 windows::basic_object_handle::basic_object_handle (2 of 5 overloads)]


Construct an object handle without opening it. 


  template<
      typename ExecutionContext>
  basic_object_handle(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates an object handle without opening it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the object handle will use, by default, to dispatch handlers for any asynchronous operations performed on the object handle. ]]

]




[endsect]



[section:overload3 windows::basic_object_handle::basic_object_handle (3 of 5 overloads)]


Construct an object handle on an existing native handle. 


  basic_object_handle(
      const executor_type & ex,
      const native_handle_type & native_handle);


This constructor creates an object handle object to hold an existing native handle.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the object handle will use, by default, to dispatch handlers for any asynchronous operations performed on the object handle.]]

[[native_handle][The new underlying handle implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 windows::basic_object_handle::basic_object_handle (4 of 5 overloads)]


Construct an object handle on an existing native handle. 


  template<
      typename ExecutionContext>
  basic_object_handle(
      ExecutionContext & context,
      const native_handle_type & native_handle,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates an object handle object to hold an existing native handle.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the object handle will use, by default, to dispatch handlers for any asynchronous operations performed on the object handle.]]

[[native_handle][The new underlying handle implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 windows::basic_object_handle::basic_object_handle (5 of 5 overloads)]


Move-construct an object handle from another. 


  basic_object_handle(
      basic_object_handle && other);


This constructor moves an object handle from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other object handle object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_object_handle(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:cancel windows::basic_object_handle::cancel]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.cancel..cancel..windows::basic_object_handle] 
Cancel all asynchronous operations associated with the handle. 


  void ``[link boost_asio.reference.windows__basic_object_handle.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.windows__basic_object_handle.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.cancel.overload2 more...]]``


[section:overload1 windows::basic_object_handle::cancel (1 of 2 overloads)]


Cancel all asynchronous operations associated with the handle. 


  void cancel();


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 windows::basic_object_handle::cancel (2 of 2 overloads)]


Cancel all asynchronous operations associated with the handle. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:close windows::basic_object_handle::close]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.close..close..windows::basic_object_handle] 
Close the handle. 


  void ``[link boost_asio.reference.windows__basic_object_handle.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.close.overload1 more...]]``

  void ``[link boost_asio.reference.windows__basic_object_handle.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.close.overload2 more...]]``


[section:overload1 windows::basic_object_handle::close (1 of 2 overloads)]


Close the handle. 


  void close();


This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 windows::basic_object_handle::close (2 of 2 overloads)]


Close the handle. 


  void close(
      boost::system::error_code & ec);


This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:executor_type windows::basic_object_handle::executor_type]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.executor_type..executor_type..windows::basic_object_handle] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/windows/basic_object_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor windows::basic_object_handle::get_executor]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.get_executor..get_executor..windows::basic_object_handle] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:is_open windows::basic_object_handle::is_open]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.is_open..is_open..windows::basic_object_handle] 
Determine whether the handle is open. 


  bool is_open() const;



[endsect]


[section:lowest_layer windows::basic_object_handle::lowest_layer]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.lowest_layer..lowest_layer..windows::basic_object_handle] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.windows__basic_object_handle.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.windows__basic_object_handle.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.lowest_layer.overload2 more...]]``


[section:overload1 windows::basic_object_handle::lowest_layer (1 of 2 overloads)]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since an object handle cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 windows::basic_object_handle::lowest_layer (2 of 2 overloads)]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since an object handle cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type windows::basic_object_handle::lowest_layer_type]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.lowest_layer_type..lowest_layer_type..windows::basic_object_handle] 
An object handle is always the lowest layer. 


  typedef basic_object_handle lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_object_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_object_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_object_handle.lowest_layer_type [*lowest_layer_type]]]
    [An object handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_object_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_object_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.async_wait [*async_wait]]]
    [Start an asynchronous wait on the object handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.basic_object_handle [*basic_object_handle]] [constructor]]
    [Construct an object handle without opening it. 
     [hr]
     Construct an object handle on an existing native handle. 
     [hr]
     Move-construct an object handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.operator_eq_ [*operator=]]]
    [Move-assign an object handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.wait [*wait]]]
    [Perform a blocking wait on the object handle. ]
  ]
  
]

The [link boost_asio.reference.windows__basic_object_handle `windows::basic_object_handle`] class provides asynchronous and blocking object-oriented handle functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/windows/basic_object_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:native_handle windows::basic_object_handle::native_handle]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.native_handle..native_handle..windows::basic_object_handle] 
Get the native handle representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the handle. This is intended to allow access to native handle functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type windows::basic_object_handle::native_handle_type]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.native_handle_type..native_handle_type..windows::basic_object_handle] 
The native representation of a handle. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/windows/basic_object_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ windows::basic_object_handle::operator=]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.operator_eq_..operator=..windows::basic_object_handle] 
Move-assign an object handle from another. 


  basic_object_handle & operator=(
      basic_object_handle && other);


This assignment operator moves an object handle from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other object handle object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_object_handle(const executor_type&)` constructor. 




[endsect]


[section:wait windows::basic_object_handle::wait]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle.wait..wait..windows::basic_object_handle] 
Perform a blocking wait on the object handle. 


  void ``[link boost_asio.reference.windows__basic_object_handle.wait.overload1 wait]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.wait.overload1 more...]]``

  void ``[link boost_asio.reference.windows__basic_object_handle.wait.overload2 wait]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_object_handle.wait.overload2 more...]]``


[section:overload1 windows::basic_object_handle::wait (1 of 2 overloads)]


Perform a blocking wait on the object handle. 


  void wait();


This function is used to wait for the object handle to be set to the signalled state. This function blocks and does not return until the object handle has been set to the signalled state.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 windows::basic_object_handle::wait (2 of 2 overloads)]


Perform a blocking wait on the object handle. 


  void wait(
      boost::system::error_code & ec);


This function is used to wait for the object handle to be set to the signalled state. This function blocks and does not return until the object handle has been set to the signalled state.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[endsect]

[section:windows__basic_object_handle__rebind_executor windows::basic_object_handle::rebind_executor]

[indexterm1 boost_asio.indexterm.windows__basic_object_handle__rebind_executor..windows::basic_object_handle::rebind_executor]


Rebinds the handle type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_object_handle__rebind_executor.other [*other]]]
    [The handle type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/windows/basic_object_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other windows::basic_object_handle::rebind_executor::other]

[indexterm2 boost_asio.indexterm.windows__basic_object_handle__rebind_executor.other..other..windows::basic_object_handle::rebind_executor] 
The handle type when rebound to the specified executor. 


  typedef basic_object_handle< Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_object_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_object_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_object_handle.lowest_layer_type [*lowest_layer_type]]]
    [An object handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_object_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_object_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.async_wait [*async_wait]]]
    [Start an asynchronous wait on the object handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.basic_object_handle [*basic_object_handle]] [constructor]]
    [Construct an object handle without opening it. 
     [hr]
     Construct an object handle on an existing native handle. 
     [hr]
     Move-construct an object handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.operator_eq_ [*operator=]]]
    [Move-assign an object handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.wait [*wait]]]
    [Perform a blocking wait on the object handle. ]
  ]
  
]

The [link boost_asio.reference.windows__basic_object_handle `windows::basic_object_handle`] class provides asynchronous and blocking object-oriented handle functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/windows/basic_object_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:windows__basic_overlapped_handle windows::basic_overlapped_handle]

[indexterm1 boost_asio.indexterm.windows__basic_overlapped_handle..windows::basic_overlapped_handle]


Provides Windows handle functionality for objects that support overlapped I/O. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  class basic_overlapped_handle


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer_type [*lowest_layer_type]]]
    [An overlapped_handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle [*basic_overlapped_handle]] [constructor]]
    [Construct an overlapped handle without opening it. 
     [hr]
     Construct an overlapped handle on an existing native handle. 
     [hr]
     Move-construct an overlapped handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.operator_eq_ [*operator=]]]
    [Move-assign an overlapped handle from another. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_overlapped_handle._basic_overlapped_handle [*~basic_overlapped_handle]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

The [link boost_asio.reference.windows__overlapped_handle `windows::overlapped_handle`] class provides the ability to wrap a Windows handle. The underlying object referred to by the handle must support overlapped I/O.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/windows/basic_overlapped_handle.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign windows::basic_overlapped_handle::assign]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle.assign..assign..windows::basic_overlapped_handle] 
Assign an existing native handle to the handle. 


  void ``[link boost_asio.reference.windows__basic_overlapped_handle.assign.overload1 assign]``(
      const native_handle_type & handle);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_overlapped_handle.assign.overload1 more...]]``

  void ``[link boost_asio.reference.windows__basic_overlapped_handle.assign.overload2 assign]``(
      const native_handle_type & handle,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_overlapped_handle.assign.overload2 more...]]``


[section:overload1 windows::basic_overlapped_handle::assign (1 of 2 overloads)]


Assign an existing native handle to the handle. 


  void assign(
      const native_handle_type & handle);



[endsect]



[section:overload2 windows::basic_overlapped_handle::assign (2 of 2 overloads)]


Assign an existing native handle to the handle. 


  void assign(
      const native_handle_type & handle,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:basic_overlapped_handle windows::basic_overlapped_handle::basic_overlapped_handle]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle.basic_overlapped_handle..basic_overlapped_handle..windows::basic_overlapped_handle] 
Construct an overlapped handle without opening it. 


  explicit ``[link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle.overload1 basic_overlapped_handle]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle.overload2 basic_overlapped_handle]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle.overload2 more...]]``


Construct an overlapped handle on an existing native handle. 


  ``[link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle.overload3 basic_overlapped_handle]``(
      const executor_type & ex,
      const native_handle_type & native_handle);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle.overload4 basic_overlapped_handle]``(
      ExecutionContext & context,
      const native_handle_type & native_handle,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle.overload4 more...]]``


Move-construct an overlapped handle from another. 


  ``[link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle.overload5 basic_overlapped_handle]``(
      basic_overlapped_handle && other);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle.overload5 more...]]``


[section:overload1 windows::basic_overlapped_handle::basic_overlapped_handle (1 of 5 overloads)]


Construct an overlapped handle without opening it. 


  basic_overlapped_handle(
      const executor_type & ex);


This constructor creates an overlapped handle without opening it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the overlapped handle will use, by default, to dispatch handlers for any asynchronous operations performed on the overlapped handle. ]]

]




[endsect]



[section:overload2 windows::basic_overlapped_handle::basic_overlapped_handle (2 of 5 overloads)]


Construct an overlapped handle without opening it. 


  template<
      typename ExecutionContext>
  basic_overlapped_handle(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates an overlapped handle without opening it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the overlapped handle will use, by default, to dispatch handlers for any asynchronous operations performed on the overlapped handle. ]]

]




[endsect]



[section:overload3 windows::basic_overlapped_handle::basic_overlapped_handle (3 of 5 overloads)]


Construct an overlapped handle on an existing native handle. 


  basic_overlapped_handle(
      const executor_type & ex,
      const native_handle_type & native_handle);


This constructor creates an overlapped handle object to hold an existing native handle.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the overlapped handle will use, by default, to dispatch handlers for any asynchronous operations performed on the overlapped handle.]]

[[native_handle][The new underlying handle implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 windows::basic_overlapped_handle::basic_overlapped_handle (4 of 5 overloads)]


Construct an overlapped handle on an existing native handle. 


  template<
      typename ExecutionContext>
  basic_overlapped_handle(
      ExecutionContext & context,
      const native_handle_type & native_handle,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates an overlapped handle object to hold an existing native handle.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the overlapped handle will use, by default, to dispatch handlers for any asynchronous operations performed on the overlapped handle.]]

[[native_handle][The new underlying handle implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 windows::basic_overlapped_handle::basic_overlapped_handle (5 of 5 overloads)]


Move-construct an overlapped handle from another. 


  basic_overlapped_handle(
      basic_overlapped_handle && other);


This constructor moves a handle from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other overlapped handle object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `overlapped_handle(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:cancel windows::basic_overlapped_handle::cancel]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle.cancel..cancel..windows::basic_overlapped_handle] 
Cancel all asynchronous operations associated with the handle. 


  void ``[link boost_asio.reference.windows__basic_overlapped_handle.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_overlapped_handle.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.windows__basic_overlapped_handle.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_overlapped_handle.cancel.overload2 more...]]``


[section:overload1 windows::basic_overlapped_handle::cancel (1 of 2 overloads)]


Cancel all asynchronous operations associated with the handle. 


  void cancel();


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 windows::basic_overlapped_handle::cancel (2 of 2 overloads)]


Cancel all asynchronous operations associated with the handle. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:close windows::basic_overlapped_handle::close]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle.close..close..windows::basic_overlapped_handle] 
Close the handle. 


  void ``[link boost_asio.reference.windows__basic_overlapped_handle.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_overlapped_handle.close.overload1 more...]]``

  void ``[link boost_asio.reference.windows__basic_overlapped_handle.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_overlapped_handle.close.overload2 more...]]``


[section:overload1 windows::basic_overlapped_handle::close (1 of 2 overloads)]


Close the handle. 


  void close();


This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 windows::basic_overlapped_handle::close (2 of 2 overloads)]


Close the handle. 


  void close(
      boost::system::error_code & ec);


This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:executor_type windows::basic_overlapped_handle::executor_type]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle.executor_type..executor_type..windows::basic_overlapped_handle] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/windows/basic_overlapped_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor windows::basic_overlapped_handle::get_executor]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle.get_executor..get_executor..windows::basic_overlapped_handle] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:is_open windows::basic_overlapped_handle::is_open]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle.is_open..is_open..windows::basic_overlapped_handle] 
Determine whether the handle is open. 


  bool is_open() const;



[endsect]


[section:lowest_layer windows::basic_overlapped_handle::lowest_layer]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle.lowest_layer..lowest_layer..windows::basic_overlapped_handle] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer.overload2 more...]]``


[section:overload1 windows::basic_overlapped_handle::lowest_layer (1 of 2 overloads)]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since an overlapped\_handle cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 windows::basic_overlapped_handle::lowest_layer (2 of 2 overloads)]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since an overlapped\_handle cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type windows::basic_overlapped_handle::lowest_layer_type]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle.lowest_layer_type..lowest_layer_type..windows::basic_overlapped_handle] 
An overlapped\_handle is always the lowest layer. 


  typedef basic_overlapped_handle lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer_type [*lowest_layer_type]]]
    [An overlapped_handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle [*basic_overlapped_handle]] [constructor]]
    [Construct an overlapped handle without opening it. 
     [hr]
     Construct an overlapped handle on an existing native handle. 
     [hr]
     Move-construct an overlapped handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.operator_eq_ [*operator=]]]
    [Move-assign an overlapped handle from another. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_overlapped_handle._basic_overlapped_handle [*~basic_overlapped_handle]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

The [link boost_asio.reference.windows__overlapped_handle `windows::overlapped_handle`] class provides the ability to wrap a Windows handle. The underlying object referred to by the handle must support overlapped I/O.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/windows/basic_overlapped_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:native_handle windows::basic_overlapped_handle::native_handle]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle.native_handle..native_handle..windows::basic_overlapped_handle] 
Get the native handle representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the handle. This is intended to allow access to native handle functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type windows::basic_overlapped_handle::native_handle_type]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle.native_handle_type..native_handle_type..windows::basic_overlapped_handle] 
The native representation of a handle. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/windows/basic_overlapped_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ windows::basic_overlapped_handle::operator=]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle.operator_eq_..operator=..windows::basic_overlapped_handle] 
Move-assign an overlapped handle from another. 


  basic_overlapped_handle & operator=(
      basic_overlapped_handle && other);


This assignment operator moves a handle from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other overlapped handle object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `overlapped_handle(const executor_type&)` constructor. 




[endsect]



[section:_basic_overlapped_handle windows::basic_overlapped_handle::~basic_overlapped_handle]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle._basic_overlapped_handle..~basic_overlapped_handle..windows::basic_overlapped_handle] 
Protected destructor to prevent deletion through this type. 


  ~basic_overlapped_handle();


This function destroys the handle, cancelling any outstanding asynchronous wait operations associated with the handle as if by calling `cancel`. 


[endsect]



[endsect]

[section:windows__basic_overlapped_handle__rebind_executor windows::basic_overlapped_handle::rebind_executor]

[indexterm1 boost_asio.indexterm.windows__basic_overlapped_handle__rebind_executor..windows::basic_overlapped_handle::rebind_executor]


Rebinds the handle type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle__rebind_executor.other [*other]]]
    [The handle type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/windows/basic_overlapped_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other windows::basic_overlapped_handle::rebind_executor::other]

[indexterm2 boost_asio.indexterm.windows__basic_overlapped_handle__rebind_executor.other..other..windows::basic_overlapped_handle::rebind_executor] 
The handle type when rebound to the specified executor. 


  typedef basic_overlapped_handle< Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer_type [*lowest_layer_type]]]
    [An overlapped_handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle [*basic_overlapped_handle]] [constructor]]
    [Construct an overlapped handle without opening it. 
     [hr]
     Construct an overlapped handle on an existing native handle. 
     [hr]
     Move-construct an overlapped handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.operator_eq_ [*operator=]]]
    [Move-assign an overlapped handle from another. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_overlapped_handle._basic_overlapped_handle [*~basic_overlapped_handle]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

The [link boost_asio.reference.windows__overlapped_handle `windows::overlapped_handle`] class provides the ability to wrap a Windows handle. The underlying object referred to by the handle must support overlapped I/O.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/windows/basic_overlapped_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:windows__basic_random_access_handle windows::basic_random_access_handle]

[indexterm1 boost_asio.indexterm.windows__basic_random_access_handle..windows::basic_random_access_handle]


Provides random-access handle functionality. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  class basic_random_access_handle :
    public windows::basic_overlapped_handle< Executor >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_random_access_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_random_access_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_random_access_handle.lowest_layer_type [*lowest_layer_type]]]
    [An overlapped_handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_random_access_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_random_access_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.async_read_some_at [*async_read_some_at]]]
    [Start an asynchronous read at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.async_write_some_at [*async_write_some_at]]]
    [Start an asynchronous write at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.basic_random_access_handle [*basic_random_access_handle]] [constructor]]
    [Construct a random-access handle without opening it. 
     [hr]
     Construct a random-access handle on an existing native handle. 
     [hr]
     Move-construct a random-access handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.operator_eq_ [*operator=]]]
    [Move-assign a random-access handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.read_some_at [*read_some_at]]]
    [Read some data from the handle at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.write_some_at [*write_some_at]]]
    [Write some data to the handle at the specified offset. ]
  ]
  
]

The [link boost_asio.reference.windows__basic_random_access_handle `windows::basic_random_access_handle`] class provides asynchronous and blocking random-access handle functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/windows/basic_random_access_handle.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign windows::basic_random_access_handle::assign]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.assign..assign..windows::basic_random_access_handle] 
Assign an existing native handle to the handle. 


  void ``[link boost_asio.reference.windows__basic_random_access_handle.assign.overload1 assign]``(
      const native_handle_type & handle);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.assign.overload1 more...]]``

  void ``[link boost_asio.reference.windows__basic_random_access_handle.assign.overload2 assign]``(
      const native_handle_type & handle,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.assign.overload2 more...]]``


[section:overload1 windows::basic_random_access_handle::assign (1 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Assign an existing native handle to the handle. 


  void assign(
      const native_handle_type & handle);



[endsect]



[section:overload2 windows::basic_random_access_handle::assign (2 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Assign an existing native handle to the handle. 


  void assign(
      const native_handle_type & handle,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_read_some_at windows::basic_random_access_handle::async_read_some_at]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.async_read_some_at..async_read_some_at..windows::basic_random_access_handle] 
Start an asynchronous read at the specified offset. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_some_at(
      uint64_t offset,
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data from the random-access handle. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes read.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The read operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.async_read_at `async_read_at`]  function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   handle.async_read_some_at(42, boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:async_write_some_at windows::basic_random_access_handle::async_write_some_at]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.async_write_some_at..async_write_some_at..windows::basic_random_access_handle] 
Start an asynchronous write at the specified offset. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_some_at(
      uint64_t offset,
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write data to the random-access handle. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[offset][The offset at which the data will be written.]]

[[buffers][One or more data buffers to be written to the handle. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes written.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The write operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.async_write_at `async_write_at`]  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   handle.async_write_some_at(42, boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:basic_random_access_handle windows::basic_random_access_handle::basic_random_access_handle]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.basic_random_access_handle..basic_random_access_handle..windows::basic_random_access_handle] 
Construct a random-access handle without opening it. 


  explicit ``[link boost_asio.reference.windows__basic_random_access_handle.basic_random_access_handle.overload1 basic_random_access_handle]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.basic_random_access_handle.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.windows__basic_random_access_handle.basic_random_access_handle.overload2 basic_random_access_handle]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.basic_random_access_handle.overload2 more...]]``


Construct a random-access handle on an existing native handle. 


  ``[link boost_asio.reference.windows__basic_random_access_handle.basic_random_access_handle.overload3 basic_random_access_handle]``(
      const executor_type & ex,
      const native_handle_type & handle);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.basic_random_access_handle.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.windows__basic_random_access_handle.basic_random_access_handle.overload4 basic_random_access_handle]``(
      ExecutionContext & context,
      const native_handle_type & handle,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.basic_random_access_handle.overload4 more...]]``


Move-construct a random-access handle from another. 


  ``[link boost_asio.reference.windows__basic_random_access_handle.basic_random_access_handle.overload5 basic_random_access_handle]``(
      basic_random_access_handle && other);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.basic_random_access_handle.overload5 more...]]``


[section:overload1 windows::basic_random_access_handle::basic_random_access_handle (1 of 5 overloads)]


Construct a random-access handle without opening it. 


  basic_random_access_handle(
      const executor_type & ex);


This constructor creates a random-access handle without opening it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the random-access handle will use, by default, to dispatch handlers for any asynchronous operations performed on the random-access handle. ]]

]




[endsect]



[section:overload2 windows::basic_random_access_handle::basic_random_access_handle (2 of 5 overloads)]


Construct a random-access handle without opening it. 


  template<
      typename ExecutionContext>
  basic_random_access_handle(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates a random-access handle without opening it. The handle needs to be opened or assigned before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the random-access handle will use, by default, to dispatch handlers for any asynchronous operations performed on the random-access handle. ]]

]




[endsect]



[section:overload3 windows::basic_random_access_handle::basic_random_access_handle (3 of 5 overloads)]


Construct a random-access handle on an existing native handle. 


  basic_random_access_handle(
      const executor_type & ex,
      const native_handle_type & handle);


This constructor creates a random-access handle object to hold an existing native handle.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the random-access handle will use, by default, to dispatch handlers for any asynchronous operations performed on the random-access handle.]]

[[handle][The new underlying handle implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 windows::basic_random_access_handle::basic_random_access_handle (4 of 5 overloads)]


Construct a random-access handle on an existing native handle. 


  template<
      typename ExecutionContext>
  basic_random_access_handle(
      ExecutionContext & context,
      const native_handle_type & handle,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a random-access handle object to hold an existing native handle.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the random-access handle will use, by default, to dispatch handlers for any asynchronous operations performed on the random-access handle.]]

[[handle][The new underlying handle implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 windows::basic_random_access_handle::basic_random_access_handle (5 of 5 overloads)]


Move-construct a random-access handle from another. 


  basic_random_access_handle(
      basic_random_access_handle && other);


This constructor moves a random-access handle from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other random-access handle object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_random_access_handle(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:cancel windows::basic_random_access_handle::cancel]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.cancel..cancel..windows::basic_random_access_handle] 
Cancel all asynchronous operations associated with the handle. 


  void ``[link boost_asio.reference.windows__basic_random_access_handle.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.windows__basic_random_access_handle.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.cancel.overload2 more...]]``


[section:overload1 windows::basic_random_access_handle::cancel (1 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Cancel all asynchronous operations associated with the handle. 


  void cancel();


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 windows::basic_random_access_handle::cancel (2 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Cancel all asynchronous operations associated with the handle. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:close windows::basic_random_access_handle::close]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.close..close..windows::basic_random_access_handle] 
Close the handle. 


  void ``[link boost_asio.reference.windows__basic_random_access_handle.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.close.overload1 more...]]``

  void ``[link boost_asio.reference.windows__basic_random_access_handle.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.close.overload2 more...]]``


[section:overload1 windows::basic_random_access_handle::close (1 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Close the handle. 


  void close();


This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 windows::basic_random_access_handle::close (2 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Close the handle. 


  void close(
      boost::system::error_code & ec);


This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:executor_type windows::basic_random_access_handle::executor_type]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.executor_type..executor_type..windows::basic_random_access_handle] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/windows/basic_random_access_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor windows::basic_random_access_handle::get_executor]


['Inherited from windows::basic_overlapped_handle.]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.get_executor..get_executor..windows::basic_random_access_handle] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:is_open windows::basic_random_access_handle::is_open]


['Inherited from windows::basic_overlapped_handle.]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.is_open..is_open..windows::basic_random_access_handle] 
Determine whether the handle is open. 


  bool is_open() const;



[endsect]


[section:lowest_layer windows::basic_random_access_handle::lowest_layer]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.lowest_layer..lowest_layer..windows::basic_random_access_handle] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.windows__basic_random_access_handle.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.windows__basic_random_access_handle.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.lowest_layer.overload2 more...]]``


[section:overload1 windows::basic_random_access_handle::lowest_layer (1 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since an overlapped\_handle cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 windows::basic_random_access_handle::lowest_layer (2 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since an overlapped\_handle cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type windows::basic_random_access_handle::lowest_layer_type]


['Inherited from windows::basic_overlapped_handle.]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.lowest_layer_type..lowest_layer_type..windows::basic_random_access_handle] 
An overlapped\_handle is always the lowest layer. 


  typedef basic_overlapped_handle lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer_type [*lowest_layer_type]]]
    [An overlapped_handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle [*basic_overlapped_handle]] [constructor]]
    [Construct an overlapped handle without opening it. 
     [hr]
     Construct an overlapped handle on an existing native handle. 
     [hr]
     Move-construct an overlapped handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.operator_eq_ [*operator=]]]
    [Move-assign an overlapped handle from another. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_overlapped_handle._basic_overlapped_handle [*~basic_overlapped_handle]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

The [link boost_asio.reference.windows__overlapped_handle `windows::overlapped_handle`] class provides the ability to wrap a Windows handle. The underlying object referred to by the handle must support overlapped I/O.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/windows/basic_random_access_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:native_handle windows::basic_random_access_handle::native_handle]


['Inherited from windows::basic_overlapped_handle.]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.native_handle..native_handle..windows::basic_random_access_handle] 
Get the native handle representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the handle. This is intended to allow access to native handle functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type windows::basic_random_access_handle::native_handle_type]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.native_handle_type..native_handle_type..windows::basic_random_access_handle] 
The native representation of a handle. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/windows/basic_random_access_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ windows::basic_random_access_handle::operator=]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.operator_eq_..operator=..windows::basic_random_access_handle] 
Move-assign a random-access handle from another. 


  basic_random_access_handle & operator=(
      basic_random_access_handle && other);


This assignment operator moves a random-access handle from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other random-access handle object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_random_access_handle(const executor_type&)` constructor. 




[endsect]


[section:read_some_at windows::basic_random_access_handle::read_some_at]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.read_some_at..read_some_at..windows::basic_random_access_handle] 
Read some data from the handle at the specified offset. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.windows__basic_random_access_handle.read_some_at.overload1 read_some_at]``(
      uint64_t offset,
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.read_some_at.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.windows__basic_random_access_handle.read_some_at.overload2 read_some_at]``(
      uint64_t offset,
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.read_some_at.overload2 more...]]``


[section:overload1 windows::basic_random_access_handle::read_some_at (1 of 2 overloads)]


Read some data from the handle at the specified offset. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some_at(
      uint64_t offset,
      const MutableBufferSequence & buffers);


This function is used to read data from the random-access handle. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes read.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read_at `read_at`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   handle.read_some_at(42, boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 windows::basic_random_access_handle::read_some_at (2 of 2 overloads)]


Read some data from the handle at the specified offset. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some_at(
      uint64_t offset,
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to read data from the random-access handle. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[offset][The offset at which the data will be read.]]

[[buffers][One or more buffers into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. Returns 0 if an error occurred.


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read_at `read_at`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]


[endsect]

[section:write_some_at windows::basic_random_access_handle::write_some_at]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle.write_some_at..write_some_at..windows::basic_random_access_handle] 
Write some data to the handle at the specified offset. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.windows__basic_random_access_handle.write_some_at.overload1 write_some_at]``(
      uint64_t offset,
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.write_some_at.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.windows__basic_random_access_handle.write_some_at.overload2 write_some_at]``(
      uint64_t offset,
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_random_access_handle.write_some_at.overload2 more...]]``


[section:overload1 windows::basic_random_access_handle::write_some_at (1 of 2 overloads)]


Write some data to the handle at the specified offset. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some_at(
      uint64_t offset,
      const ConstBufferSequence & buffers);


This function is used to write data to the random-access handle. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[offset][The offset at which the data will be written.]]

[[buffers][One or more data buffers to be written to the handle.]]

]


[heading Return Value]
      
The number of bytes written.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The write\_some\_at operation may not write all of the data. Consider using the [link boost_asio.reference.write_at `write_at`]  function if you need to ensure that all data is written before the blocking operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   handle.write_some_at(42, boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 windows::basic_random_access_handle::write_some_at (2 of 2 overloads)]


Write some data to the handle at the specified offset. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some_at(
      uint64_t offset,
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to write data to the random-access handle. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[offset][The offset at which the data will be written.]]

[[buffers][One or more data buffers to be written to the handle.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. Returns 0 if an error occurred.


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write_at `write_at`]  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]


[endsect]


[endsect]

[section:windows__basic_random_access_handle__rebind_executor windows::basic_random_access_handle::rebind_executor]

[indexterm1 boost_asio.indexterm.windows__basic_random_access_handle__rebind_executor..windows::basic_random_access_handle::rebind_executor]


Rebinds the handle type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_random_access_handle__rebind_executor.other [*other]]]
    [The handle type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/windows/basic_random_access_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other windows::basic_random_access_handle::rebind_executor::other]

[indexterm2 boost_asio.indexterm.windows__basic_random_access_handle__rebind_executor.other..other..windows::basic_random_access_handle::rebind_executor] 
The handle type when rebound to the specified executor. 


  typedef basic_random_access_handle< Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_random_access_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_random_access_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_random_access_handle.lowest_layer_type [*lowest_layer_type]]]
    [An overlapped_handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_random_access_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_random_access_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.async_read_some_at [*async_read_some_at]]]
    [Start an asynchronous read at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.async_write_some_at [*async_write_some_at]]]
    [Start an asynchronous write at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.basic_random_access_handle [*basic_random_access_handle]] [constructor]]
    [Construct a random-access handle without opening it. 
     [hr]
     Construct a random-access handle on an existing native handle. 
     [hr]
     Move-construct a random-access handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.operator_eq_ [*operator=]]]
    [Move-assign a random-access handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.read_some_at [*read_some_at]]]
    [Read some data from the handle at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.write_some_at [*write_some_at]]]
    [Write some data to the handle at the specified offset. ]
  ]
  
]

The [link boost_asio.reference.windows__basic_random_access_handle `windows::basic_random_access_handle`] class provides asynchronous and blocking random-access handle functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/windows/basic_random_access_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]

[section:windows__basic_stream_handle windows::basic_stream_handle]

[indexterm1 boost_asio.indexterm.windows__basic_stream_handle..windows::basic_stream_handle]


Provides stream-oriented handle functionality. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]`` = any_io_executor>
  class basic_stream_handle :
    public windows::basic_overlapped_handle< Executor >


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_stream_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_stream_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_stream_handle.lowest_layer_type [*lowest_layer_type]]]
    [An overlapped_handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_stream_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_stream_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.basic_stream_handle [*basic_stream_handle]] [constructor]]
    [Construct a stream handle without opening it. 
     [hr]
     Construct a stream handle on an existing native handle. 
     [hr]
     Move-construct a stream handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.operator_eq_ [*operator=]]]
    [Move-assign a stream handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.read_some [*read_some]]]
    [Read some data from the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.write_some [*write_some]]]
    [Write some data to the handle. ]
  ]
  
]

The [link boost_asio.reference.windows__basic_stream_handle `windows::basic_stream_handle`] class provides asynchronous and blocking stream-oriented handle functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.




[heading Requirements]

['Header: ][^boost/asio/windows/basic_stream_handle.hpp]

['Convenience header: ][^boost/asio.hpp]

[section:assign windows::basic_stream_handle::assign]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.assign..assign..windows::basic_stream_handle] 
Assign an existing native handle to the handle. 


  void ``[link boost_asio.reference.windows__basic_stream_handle.assign.overload1 assign]``(
      const native_handle_type & handle);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.assign.overload1 more...]]``

  void ``[link boost_asio.reference.windows__basic_stream_handle.assign.overload2 assign]``(
      const native_handle_type & handle,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.assign.overload2 more...]]``


[section:overload1 windows::basic_stream_handle::assign (1 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Assign an existing native handle to the handle. 


  void assign(
      const native_handle_type & handle);



[endsect]



[section:overload2 windows::basic_stream_handle::assign (2 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Assign an existing native handle to the handle. 


  void assign(
      const native_handle_type & handle,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:async_read_some windows::basic_stream_handle::async_read_some]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.async_read_some..async_read_some..windows::basic_stream_handle] 
Start an asynchronous read. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``,
      typename ``[link boost_asio.reference.ReadHandler ReadHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_read_some(
      const MutableBufferSequence & buffers,
      ReadHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously read data from the stream handle. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes read.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The read operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.async_read `async_read`]  function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   handle.async_read_some(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]



[section:async_write_some windows::basic_stream_handle::async_write_some]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.async_write_some..async_write_some..windows::basic_stream_handle] 
Start an asynchronous write. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.WriteHandler WriteHandler]`` = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``>
  ``[link boost_asio.reference.asynchronous_operations.automatic_deduction_of_initiating_function_return_type ['DEDUCED]]`` async_write_some(
      const ConstBufferSequence & buffers,
      WriteHandler && handler = ``[link boost_asio.reference.asynchronous_operations.default_completion_tokens ['DEFAULT]]``);


This function is used to asynchronously write data to the stream handle. The function call always returns immediately.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the handle. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.]]

[[handler][The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
   void handler(
     const boost::system::error_code& error, // Result of operation.
     std::size_t bytes_transferred           // Number of bytes written.
   ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using [link boost_asio.reference.post `post`].]]

]


[heading Remarks]
      
The write operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.async_write `async_write`]  function if you need to ensure that all data is written before the asynchronous operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   handle.async_write_some(boost::asio::buffer(data, size), handler);


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Per-Operation Cancellation]
  
This asynchronous operation supports cancellation for the following [link boost_asio.reference.cancellation_type `cancellation_type`] values:


* `cancellation_type::terminal` 


* `cancellation_type::partial` 


* `cancellation_type::total` 




[endsect]


[section:basic_stream_handle windows::basic_stream_handle::basic_stream_handle]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.basic_stream_handle..basic_stream_handle..windows::basic_stream_handle] 
Construct a stream handle without opening it. 


  explicit ``[link boost_asio.reference.windows__basic_stream_handle.basic_stream_handle.overload1 basic_stream_handle]``(
      const executor_type & ex);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.basic_stream_handle.overload1 more...]]``

  template<
      typename ExecutionContext>
  explicit ``[link boost_asio.reference.windows__basic_stream_handle.basic_stream_handle.overload2 basic_stream_handle]``(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.basic_stream_handle.overload2 more...]]``


Construct a stream handle on an existing native handle. 


  ``[link boost_asio.reference.windows__basic_stream_handle.basic_stream_handle.overload3 basic_stream_handle]``(
      const executor_type & ex,
      const native_handle_type & handle);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.basic_stream_handle.overload3 more...]]``

  template<
      typename ExecutionContext>
  ``[link boost_asio.reference.windows__basic_stream_handle.basic_stream_handle.overload4 basic_stream_handle]``(
      ExecutionContext & context,
      const native_handle_type & handle,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.basic_stream_handle.overload4 more...]]``


Move-construct a stream handle from another. 


  ``[link boost_asio.reference.windows__basic_stream_handle.basic_stream_handle.overload5 basic_stream_handle]``(
      basic_stream_handle && other);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.basic_stream_handle.overload5 more...]]``


[section:overload1 windows::basic_stream_handle::basic_stream_handle (1 of 5 overloads)]


Construct a stream handle without opening it. 


  basic_stream_handle(
      const executor_type & ex);


This constructor creates a stream handle without opening it.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the stream handle will use, by default, to dispatch handlers for any asynchronous operations performed on the stream handle. ]]

]




[endsect]



[section:overload2 windows::basic_stream_handle::basic_stream_handle (2 of 5 overloads)]


Construct a stream handle without opening it. 


  template<
      typename ExecutionContext>
  basic_stream_handle(
      ExecutionContext & context,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value, defaulted_constraint >::type  = defaulted_constraint());


This constructor creates a stream handle without opening it. The handle needs to be opened or assigned before data can be sent or received on it.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the stream handle will use, by default, to dispatch handlers for any asynchronous operations performed on the stream handle. ]]

]




[endsect]



[section:overload3 windows::basic_stream_handle::basic_stream_handle (3 of 5 overloads)]


Construct a stream handle on an existing native handle. 


  basic_stream_handle(
      const executor_type & ex,
      const native_handle_type & handle);


This constructor creates a stream handle object to hold an existing native handle.


[heading Parameters]
    

[variablelist
  
[[ex][The I/O executor that the stream handle will use, by default, to dispatch handlers for any asynchronous operations performed on the stream handle.]]

[[handle][The new underlying handle implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload4 windows::basic_stream_handle::basic_stream_handle (4 of 5 overloads)]


Construct a stream handle on an existing native handle. 


  template<
      typename ExecutionContext>
  basic_stream_handle(
      ExecutionContext & context,
      const native_handle_type & handle,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);


This constructor creates a stream handle object to hold an existing native handle.


[heading Parameters]
    

[variablelist
  
[[context][An execution context which provides the I/O executor that the stream handle will use, by default, to dispatch handlers for any asynchronous operations performed on the stream handle.]]

[[handle][The new underlying handle implementation.]]

]


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload5 windows::basic_stream_handle::basic_stream_handle (5 of 5 overloads)]


Move-construct a stream handle from another. 


  basic_stream_handle(
      basic_stream_handle && other);


This constructor moves a stream handle from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other stream handle object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_handle(const executor_type&)` constructor. 




[endsect]


[endsect]

[section:cancel windows::basic_stream_handle::cancel]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.cancel..cancel..windows::basic_stream_handle] 
Cancel all asynchronous operations associated with the handle. 


  void ``[link boost_asio.reference.windows__basic_stream_handle.cancel.overload1 cancel]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.cancel.overload1 more...]]``

  void ``[link boost_asio.reference.windows__basic_stream_handle.cancel.overload2 cancel]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.cancel.overload2 more...]]``


[section:overload1 windows::basic_stream_handle::cancel (1 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Cancel all asynchronous operations associated with the handle. 


  void cancel();


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 windows::basic_stream_handle::cancel (2 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Cancel all asynchronous operations associated with the handle. 


  void cancel(
      boost::system::error_code & ec);


This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]

[section:close windows::basic_stream_handle::close]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.close..close..windows::basic_stream_handle] 
Close the handle. 


  void ``[link boost_asio.reference.windows__basic_stream_handle.close.overload1 close]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.close.overload1 more...]]``

  void ``[link boost_asio.reference.windows__basic_stream_handle.close.overload2 close]``(
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.close.overload2 more...]]``


[section:overload1 windows::basic_stream_handle::close (1 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Close the handle. 


  void close();


This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload2 windows::basic_stream_handle::close (2 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Close the handle. 


  void close(
      boost::system::error_code & ec);


This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the `boost::asio::error::operation_aborted` error.


[heading Parameters]
    

[variablelist
  
[[ec][Set to indicate what error occurred, if any. ]]

]




[endsect]


[endsect]


[section:executor_type windows::basic_stream_handle::executor_type]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.executor_type..executor_type..windows::basic_stream_handle] 
The type of the executor associated with the object. 


  typedef Executor executor_type;



[heading Requirements]

['Header: ][^boost/asio/windows/basic_stream_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:get_executor windows::basic_stream_handle::get_executor]


['Inherited from windows::basic_overlapped_handle.]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.get_executor..get_executor..windows::basic_stream_handle] 
Get the executor associated with the object. 


  executor_type get_executor();



[endsect]



[section:is_open windows::basic_stream_handle::is_open]


['Inherited from windows::basic_overlapped_handle.]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.is_open..is_open..windows::basic_stream_handle] 
Determine whether the handle is open. 


  bool is_open() const;



[endsect]


[section:lowest_layer windows::basic_stream_handle::lowest_layer]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.lowest_layer..lowest_layer..windows::basic_stream_handle] 
Get a reference to the lowest layer. 


  lowest_layer_type & ``[link boost_asio.reference.windows__basic_stream_handle.lowest_layer.overload1 lowest_layer]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.lowest_layer.overload1 more...]]``


Get a const reference to the lowest layer. 


  const lowest_layer_type & ``[link boost_asio.reference.windows__basic_stream_handle.lowest_layer.overload2 lowest_layer]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.lowest_layer.overload2 more...]]``


[section:overload1 windows::basic_stream_handle::lowest_layer (1 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Get a reference to the lowest layer. 


  lowest_layer_type & lowest_layer();


This function returns a reference to the lowest layer in a stack of layers. Since an overlapped\_handle cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]



[section:overload2 windows::basic_stream_handle::lowest_layer (2 of 2 overloads)]


['Inherited from windows::basic_overlapped_handle.]


Get a const reference to the lowest layer. 


  const lowest_layer_type & lowest_layer() const;


This function returns a const reference to the lowest layer in a stack of layers. Since an overlapped\_handle cannot contain any further layers, it simply returns a reference to itself.


[heading Return Value]
      
A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. 




[endsect]


[endsect]


[section:lowest_layer_type windows::basic_stream_handle::lowest_layer_type]


['Inherited from windows::basic_overlapped_handle.]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.lowest_layer_type..lowest_layer_type..windows::basic_stream_handle] 
An overlapped\_handle is always the lowest layer. 


  typedef basic_overlapped_handle lowest_layer_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer_type [*lowest_layer_type]]]
    [An overlapped_handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle [*basic_overlapped_handle]] [constructor]]
    [Construct an overlapped handle without opening it. 
     [hr]
     Construct an overlapped handle on an existing native handle. 
     [hr]
     Move-construct an overlapped handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.operator_eq_ [*operator=]]]
    [Move-assign an overlapped handle from another. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_overlapped_handle._basic_overlapped_handle [*~basic_overlapped_handle]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

The [link boost_asio.reference.windows__overlapped_handle `windows::overlapped_handle`] class provides the ability to wrap a Windows handle. The underlying object referred to by the handle must support overlapped I/O.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/windows/basic_stream_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:native_handle windows::basic_stream_handle::native_handle]


['Inherited from windows::basic_overlapped_handle.]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.native_handle..native_handle..windows::basic_stream_handle] 
Get the native handle representation. 


  native_handle_type native_handle();


This function may be used to obtain the underlying representation of the handle. This is intended to allow access to native handle functionality that is not otherwise provided. 


[endsect]



[section:native_handle_type windows::basic_stream_handle::native_handle_type]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.native_handle_type..native_handle_type..windows::basic_stream_handle] 
The native representation of a handle. 


  typedef implementation_defined native_handle_type;



[heading Requirements]

['Header: ][^boost/asio/windows/basic_stream_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:operator_eq_ windows::basic_stream_handle::operator=]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.operator_eq_..operator=..windows::basic_stream_handle] 
Move-assign a stream handle from another. 


  basic_stream_handle & operator=(
      basic_stream_handle && other);


This assignment operator moves a stream handle from one object to another.


[heading Parameters]
    

[variablelist
  
[[other][The other stream handle object from which the move will occur.]]

]


[heading Remarks]
      
Following the move, the moved-from object is in the same state as if constructed using the `basic_stream_handle(const executor_type&)` constructor. 




[endsect]


[section:read_some windows::basic_stream_handle::read_some]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.read_some..read_some..windows::basic_stream_handle] 
Read some data from the handle. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.windows__basic_stream_handle.read_some.overload1 read_some]``(
      const MutableBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.read_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t ``[link boost_asio.reference.windows__basic_stream_handle.read_some.overload2 read_some]``(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.read_some.overload2 more...]]``


[section:overload1 windows::basic_stream_handle::read_some (1 of 2 overloads)]


Read some data from the handle. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers);


This function is used to read data from the stream handle. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

]


[heading Return Value]
      
The number of bytes read.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes.


[heading Example]
  
To read into a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   handle.read_some(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 windows::basic_stream_handle::read_some (2 of 2 overloads)]


Read some data from the handle. 


  template<
      typename ``[link boost_asio.reference.MutableBufferSequence MutableBufferSequence]``>
  std::size_t read_some(
      const MutableBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to read data from the stream handle. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more buffers into which the data will be read.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes read. Returns 0 if an error occurred.


[heading Remarks]
      
The read\_some operation may not read all of the requested number of bytes. Consider using the [link boost_asio.reference.read `read`]  function if you need to ensure that the requested amount of data is read before the blocking operation completes. 




[endsect]


[endsect]

[section:write_some windows::basic_stream_handle::write_some]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle.write_some..write_some..windows::basic_stream_handle] 
Write some data to the handle. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.windows__basic_stream_handle.write_some.overload1 write_some]``(
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.write_some.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.windows__basic_stream_handle.write_some.overload2 write_some]``(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__basic_stream_handle.write_some.overload2 more...]]``


[section:overload1 windows::basic_stream_handle::write_some (1 of 2 overloads)]


Write some data to the handle. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers);


This function is used to write data to the stream handle. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the handle.]]

]


[heading Return Value]
      
The number of bytes written.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. An error code of `boost::asio::error::eof` indicates that the connection was closed by the peer.]]

]


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   handle.write_some(boost::asio::buffer(data, size));


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload2 windows::basic_stream_handle::write_some (2 of 2 overloads)]


Write some data to the handle. 


  template<
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_some(
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to write data to the stream handle. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.


[heading Parameters]
    

[variablelist
  
[[buffers][One or more data buffers to be written to the handle.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. Returns 0 if an error occurred.


[heading Remarks]
      
The write\_some operation may not transmit all of the data to the peer. Consider using the [link boost_asio.reference.write `write`]  function if you need to ensure that all data is written before the blocking operation completes. 




[endsect]


[endsect]


[endsect]

[section:windows__basic_stream_handle__rebind_executor windows::basic_stream_handle::rebind_executor]

[indexterm1 boost_asio.indexterm.windows__basic_stream_handle__rebind_executor..windows::basic_stream_handle::rebind_executor]


Rebinds the handle type to another executor. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor1]``>
  struct rebind_executor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_stream_handle__rebind_executor.other [*other]]]
    [The handle type when rebound to the specified executor. ]
  
  ]

]

[heading Requirements]

['Header: ][^boost/asio/windows/basic_stream_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:other windows::basic_stream_handle::rebind_executor::other]

[indexterm2 boost_asio.indexterm.windows__basic_stream_handle__rebind_executor.other..other..windows::basic_stream_handle::rebind_executor] 
The handle type when rebound to the specified executor. 


  typedef basic_stream_handle< Executor1 > other;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_stream_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_stream_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_stream_handle.lowest_layer_type [*lowest_layer_type]]]
    [An overlapped_handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_stream_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_stream_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.basic_stream_handle [*basic_stream_handle]] [constructor]]
    [Construct a stream handle without opening it. 
     [hr]
     Construct a stream handle on an existing native handle. 
     [hr]
     Move-construct a stream handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.operator_eq_ [*operator=]]]
    [Move-assign a stream handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.read_some [*read_some]]]
    [Read some data from the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.write_some [*write_some]]]
    [Write some data to the handle. ]
  ]
  
]

The [link boost_asio.reference.windows__basic_stream_handle `windows::basic_stream_handle`] class provides asynchronous and blocking stream-oriented handle functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.





[heading Requirements]

['Header: ][^boost/asio/windows/basic_stream_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[endsect]


[section:windows__object_handle windows::object_handle]

[indexterm1 boost_asio.indexterm.windows__object_handle..windows::object_handle] 
Typedef for the typical usage of an object handle. 


  typedef basic_object_handle object_handle;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_object_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_object_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_object_handle.lowest_layer_type [*lowest_layer_type]]]
    [An object handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_object_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_object_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.async_wait [*async_wait]]]
    [Start an asynchronous wait on the object handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.basic_object_handle [*basic_object_handle]] [constructor]]
    [Construct an object handle without opening it. 
     [hr]
     Construct an object handle on an existing native handle. 
     [hr]
     Move-construct an object handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.operator_eq_ [*operator=]]]
    [Move-assign an object handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_object_handle.wait [*wait]]]
    [Perform a blocking wait on the object handle. ]
  ]
  
]

The [link boost_asio.reference.windows__basic_object_handle `windows::basic_object_handle`] class provides asynchronous and blocking object-oriented handle functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/windows/object_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:windows__overlapped_handle windows::overlapped_handle]

[indexterm1 boost_asio.indexterm.windows__overlapped_handle..windows::overlapped_handle] 
Typedef for the typical usage of an overlapped handle. 


  typedef basic_overlapped_handle overlapped_handle;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer_type [*lowest_layer_type]]]
    [An overlapped_handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_overlapped_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.basic_overlapped_handle [*basic_overlapped_handle]] [constructor]]
    [Construct an overlapped handle without opening it. 
     [hr]
     Construct an overlapped handle on an existing native handle. 
     [hr]
     Move-construct an overlapped handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_overlapped_handle.operator_eq_ [*operator=]]]
    [Move-assign an overlapped handle from another. ]
  ]
  
]

[heading Protected Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_overlapped_handle._basic_overlapped_handle [*~basic_overlapped_handle]] [destructor]]
    [Protected destructor to prevent deletion through this type. ]
  ]
  
]

The [link boost_asio.reference.windows__overlapped_handle `windows::overlapped_handle`] class provides the ability to wrap a Windows handle. The underlying object referred to by the handle must support overlapped I/O.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/windows/overlapped_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:windows__overlapped_ptr windows::overlapped_ptr]

[indexterm1 boost_asio.indexterm.windows__overlapped_ptr..windows::overlapped_ptr]


Wraps a handler to create an OVERLAPPED object for use with overlapped I/O. 


  class overlapped_ptr :
    noncopyable


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__overlapped_ptr.complete [*complete]]]
    [Post completion notification for overlapped operation. Releases ownership. ]
  ]
  
  [
    [[link boost_asio.reference.windows__overlapped_ptr.get [*get]]]
    [Get the contained OVERLAPPED object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__overlapped_ptr.overlapped_ptr [*overlapped_ptr]] [constructor]]
    [Construct an empty overlapped_ptr. 
     [hr]
     Construct an overlapped_ptr to contain the specified handler. ]
  ]
  
  [
    [[link boost_asio.reference.windows__overlapped_ptr.release [*release]]]
    [Release ownership of the OVERLAPPED object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__overlapped_ptr.reset [*reset]]]
    [Reset to empty. 
     [hr]
     Reset to contain the specified handler, freeing any current OVERLAPPED object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__overlapped_ptr._overlapped_ptr [*~overlapped_ptr]] [destructor]]
    [Destructor automatically frees the OVERLAPPED object unless released. ]
  ]
  
]

A special-purpose smart pointer used to wrap an application handler so that it can be passed as the LPOVERLAPPED argument to overlapped I/O functions.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 



[heading Requirements]

['Header: ][^boost/asio/windows/overlapped_ptr.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:complete windows::overlapped_ptr::complete]

[indexterm2 boost_asio.indexterm.windows__overlapped_ptr.complete..complete..windows::overlapped_ptr] 
Post completion notification for overlapped operation. Releases ownership. 


  void complete(
      const boost::system::error_code & ec,
      std::size_t bytes_transferred);



[endsect]


[section:get windows::overlapped_ptr::get]

[indexterm2 boost_asio.indexterm.windows__overlapped_ptr.get..get..windows::overlapped_ptr] 
Get the contained OVERLAPPED object. 


  OVERLAPPED * ``[link boost_asio.reference.windows__overlapped_ptr.get.overload1 get]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__overlapped_ptr.get.overload1 more...]]``

  const OVERLAPPED * ``[link boost_asio.reference.windows__overlapped_ptr.get.overload2 get]``() const;
  ``  [''''&raquo;''' [link boost_asio.reference.windows__overlapped_ptr.get.overload2 more...]]``


[section:overload1 windows::overlapped_ptr::get (1 of 2 overloads)]


Get the contained OVERLAPPED object. 


  OVERLAPPED * get();



[endsect]



[section:overload2 windows::overlapped_ptr::get (2 of 2 overloads)]


Get the contained OVERLAPPED object. 


  const OVERLAPPED * get() const;



[endsect]


[endsect]

[section:overlapped_ptr windows::overlapped_ptr::overlapped_ptr]

[indexterm2 boost_asio.indexterm.windows__overlapped_ptr.overlapped_ptr..overlapped_ptr..windows::overlapped_ptr] 
Construct an empty [link boost_asio.reference.windows__overlapped_ptr `windows::overlapped_ptr`]. 


  ``[link boost_asio.reference.windows__overlapped_ptr.overlapped_ptr.overload1 overlapped_ptr]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__overlapped_ptr.overlapped_ptr.overload1 more...]]``


Construct an [link boost_asio.reference.windows__overlapped_ptr `windows::overlapped_ptr`] to contain the specified handler. 


  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.Handler Handler]``>
  explicit ``[link boost_asio.reference.windows__overlapped_ptr.overlapped_ptr.overload2 overlapped_ptr]``(
      ExecutionContext & context,
      Handler && handler,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__overlapped_ptr.overlapped_ptr.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.Handler Handler]``>
  explicit ``[link boost_asio.reference.windows__overlapped_ptr.overlapped_ptr.overload3 overlapped_ptr]``(
      const Executor & ex,
      Handler && handler,
      typename constraint< execution::is_executor< Executor >::value||is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__overlapped_ptr.overlapped_ptr.overload3 more...]]``


[section:overload1 windows::overlapped_ptr::overlapped_ptr (1 of 3 overloads)]


Construct an empty [link boost_asio.reference.windows__overlapped_ptr `windows::overlapped_ptr`]. 


  overlapped_ptr();



[endsect]



[section:overload2 windows::overlapped_ptr::overlapped_ptr (2 of 3 overloads)]


Construct an [link boost_asio.reference.windows__overlapped_ptr `windows::overlapped_ptr`] to contain the specified handler. 


  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.Handler Handler]``>
  overlapped_ptr(
      ExecutionContext & context,
      Handler && handler,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[endsect]



[section:overload3 windows::overlapped_ptr::overlapped_ptr (3 of 3 overloads)]


Construct an [link boost_asio.reference.windows__overlapped_ptr `windows::overlapped_ptr`] to contain the specified handler. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.Handler Handler]``>
  overlapped_ptr(
      const Executor & ex,
      Handler && handler,
      typename constraint< execution::is_executor< Executor >::value||is_executor< Executor >::value >::type  = 0);



[endsect]


[endsect]


[section:release windows::overlapped_ptr::release]

[indexterm2 boost_asio.indexterm.windows__overlapped_ptr.release..release..windows::overlapped_ptr] 
Release ownership of the OVERLAPPED object. 


  OVERLAPPED * release();



[endsect]


[section:reset windows::overlapped_ptr::reset]

[indexterm2 boost_asio.indexterm.windows__overlapped_ptr.reset..reset..windows::overlapped_ptr] 
Reset to empty. 


  void ``[link boost_asio.reference.windows__overlapped_ptr.reset.overload1 reset]``();
  ``  [''''&raquo;''' [link boost_asio.reference.windows__overlapped_ptr.reset.overload1 more...]]``


Reset to contain the specified handler, freeing any current OVERLAPPED object. 


  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.Handler Handler]``>
  void ``[link boost_asio.reference.windows__overlapped_ptr.reset.overload2 reset]``(
      ExecutionContext & context,
      Handler && handler,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__overlapped_ptr.reset.overload2 more...]]``

  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.Handler Handler]``>
  void ``[link boost_asio.reference.windows__overlapped_ptr.reset.overload3 reset]``(
      const Executor & ex,
      Handler && handler,
      typename constraint< execution::is_executor< Executor >::value||is_executor< Executor >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.windows__overlapped_ptr.reset.overload3 more...]]``


[section:overload1 windows::overlapped_ptr::reset (1 of 3 overloads)]


Reset to empty. 


  void reset();



[endsect]



[section:overload2 windows::overlapped_ptr::reset (2 of 3 overloads)]


Reset to contain the specified handler, freeing any current OVERLAPPED object. 


  template<
      typename ExecutionContext,
      typename ``[link boost_asio.reference.Handler Handler]``>
  void reset(
      ExecutionContext & context,
      Handler && handler,
      typename constraint< is_convertible< ExecutionContext &, execution_context & >::value >::type  = 0);



[endsect]



[section:overload3 windows::overlapped_ptr::reset (3 of 3 overloads)]


Reset to contain the specified handler, freeing any current OVERLAPPED object. 


  template<
      typename ``[link boost_asio.reference.Executor1 Executor]``,
      typename ``[link boost_asio.reference.Handler Handler]``>
  void reset(
      const Executor & ex,
      Handler && handler,
      typename constraint< execution::is_executor< Executor >::value||is_executor< Executor >::value >::type  = 0);



[endsect]


[endsect]


[section:_overlapped_ptr windows::overlapped_ptr::~overlapped_ptr]

[indexterm2 boost_asio.indexterm.windows__overlapped_ptr._overlapped_ptr..~overlapped_ptr..windows::overlapped_ptr] 
Destructor automatically frees the OVERLAPPED object unless released. 


  ~overlapped_ptr();



[endsect]



[endsect]


[section:windows__random_access_handle windows::random_access_handle]

[indexterm1 boost_asio.indexterm.windows__random_access_handle..windows::random_access_handle] 
Typedef for the typical usage of a random-access handle. 


  typedef basic_random_access_handle random_access_handle;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_random_access_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_random_access_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_random_access_handle.lowest_layer_type [*lowest_layer_type]]]
    [An overlapped_handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_random_access_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_random_access_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.async_read_some_at [*async_read_some_at]]]
    [Start an asynchronous read at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.async_write_some_at [*async_write_some_at]]]
    [Start an asynchronous write at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.basic_random_access_handle [*basic_random_access_handle]] [constructor]]
    [Construct a random-access handle without opening it. 
     [hr]
     Construct a random-access handle on an existing native handle. 
     [hr]
     Move-construct a random-access handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.operator_eq_ [*operator=]]]
    [Move-assign a random-access handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.read_some_at [*read_some_at]]]
    [Read some data from the handle at the specified offset. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_random_access_handle.write_some_at [*write_some_at]]]
    [Write some data to the handle at the specified offset. ]
  ]
  
]

The [link boost_asio.reference.windows__basic_random_access_handle `windows::basic_random_access_handle`] class provides asynchronous and blocking random-access handle functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/windows/random_access_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:windows__stream_handle windows::stream_handle]

[indexterm1 boost_asio.indexterm.windows__stream_handle..windows::stream_handle] 
Typedef for the typical usage of a stream-oriented handle. 


  typedef basic_stream_handle stream_handle;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.windows__basic_stream_handle__rebind_executor [*rebind_executor]]]
    [Rebinds the handle type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_stream_handle.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_stream_handle.lowest_layer_type [*lowest_layer_type]]]
    [An overlapped_handle is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.windows__basic_stream_handle.native_handle_type [*native_handle_type]]]
    [The native representation of a handle. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.windows__basic_stream_handle.assign [*assign]]]
    [Assign an existing native handle to the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.async_read_some [*async_read_some]]]
    [Start an asynchronous read. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.basic_stream_handle [*basic_stream_handle]] [constructor]]
    [Construct a stream handle without opening it. 
     [hr]
     Construct a stream handle on an existing native handle. 
     [hr]
     Move-construct a stream handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.close [*close]]]
    [Close the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.is_open [*is_open]]]
    [Determine whether the handle is open. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.native_handle [*native_handle]]]
    [Get the native handle representation. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.operator_eq_ [*operator=]]]
    [Move-assign a stream handle from another. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.read_some [*read_some]]]
    [Read some data from the handle. ]
  ]
  
  [
    [[link boost_asio.reference.windows__basic_stream_handle.write_some [*write_some]]]
    [Write some data to the handle. ]
  ]
  
]

The [link boost_asio.reference.windows__basic_stream_handle `windows::basic_stream_handle`] class provides asynchronous and blocking stream-oriented handle functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe.





[heading Requirements]

['Header: ][^boost/asio/windows/stream_handle.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]



[section:writable_pipe writable_pipe]

[indexterm1 boost_asio.indexterm.writable_pipe..writable_pipe] 
Typedef for the typical usage of a writable pipe. 


  typedef basic_writable_pipe writable_pipe;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_writable_pipe__rebind_executor [*rebind_executor]]]
    [Rebinds the pipe type to another executor. ]
  
  ]

  [

    [[link boost_asio.reference.basic_writable_pipe.executor_type [*executor_type]]]
    [The type of the executor associated with the object. ]
  
  ]

  [

    [[link boost_asio.reference.basic_writable_pipe.lowest_layer_type [*lowest_layer_type]]]
    [A basic_writable_pipe is always the lowest layer. ]
  
  ]

  [

    [[link boost_asio.reference.basic_writable_pipe.native_handle_type [*native_handle_type]]]
    [The native representation of a pipe. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_writable_pipe.assign [*assign]]]
    [Assign an existing native pipe to the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.async_write_some [*async_write_some]]]
    [Start an asynchronous write. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.basic_writable_pipe [*basic_writable_pipe]] [constructor]]
    [Construct a basic_writable_pipe without opening it. 
     [hr]
     Construct a basic_writable_pipe on an existing native pipe. 
     [hr]
     Move-construct a basic_writable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.close [*close]]]
    [Close the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.get_executor [*get_executor]]]
    [Get the executor associated with the object. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.is_open [*is_open]]]
    [Determine whether the pipe is open. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.lowest_layer [*lowest_layer]]]
    [Get a reference to the lowest layer. 
     [hr]
     Get a const reference to the lowest layer. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.native_handle [*native_handle]]]
    [Get the native pipe representation. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.operator_eq_ [*operator=]]]
    [Move-assign a basic_writable_pipe from another. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe.write_some [*write_some]]]
    [Write some data to the pipe. ]
  ]
  
  [
    [[link boost_asio.reference.basic_writable_pipe._basic_writable_pipe [*~basic_writable_pipe]] [destructor]]
    [Destroys the pipe. ]
  ]
  
]

The [link boost_asio.reference.basic_writable_pipe `basic_writable_pipe`] class provides a wrapper over pipe functionality.


[heading Thread Safety]
  
['Distinct] ['objects:] Safe.

['Shared] ['objects:] Unsafe. 




[heading Requirements]

['Header: ][^boost/asio/writable_pipe.hpp]

['Convenience header: ][^boost/asio.hpp]


[endsect]


[section:write write]

[indexterm1 boost_asio.indexterm.write..write] 
The `write` function is a composed operation that writes a certain amount of data to a stream before returning. 


Write all of the supplied data to a stream before returning. 

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.write.overload1 write]``(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.write.overload2 write]``(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload2 more...]]``

Write a certain amount of data to a stream before returning. 

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.write.overload3 write]``(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.write.overload4 write]``(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload4 more...]]``

Write all of the supplied data to a stream before returning. 

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t ``[link boost_asio.reference.write.overload5 write]``(
      SyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload5 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t ``[link boost_asio.reference.write.overload6 write]``(
      SyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload6 more...]]``

Write a certain amount of data to a stream before returning. 

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.write.overload7 write]``(
      SyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload7 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.write.overload8 write]``(
      SyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload8 more...]]``

Write all of the supplied data to a stream before returning. 

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.write.overload9 write]``(
      SyncWriteStream & s,
      basic_streambuf< Allocator > & b);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload9 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.write.overload10 write]``(
      SyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload10 more...]]``

Write a certain amount of data to a stream before returning. 

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.write.overload11 write]``(
      SyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload11 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.write.overload12 write]``(
      SyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload12 more...]]``

Write all of the supplied data to a stream before returning. 

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t ``[link boost_asio.reference.write.overload13 write]``(
      SyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload13 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t ``[link boost_asio.reference.write.overload14 write]``(
      SyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload14 more...]]``

Write a certain amount of data to a stream before returning. 

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.write.overload15 write]``(
      SyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload15 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.write.overload16 write]``(
      SyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);
  ``  [''''&raquo;''' [link boost_asio.reference.write.overload16 more...]]``

[heading Requirements]

['Header: ][^boost/asio/write.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 write (1 of 16 overloads)]


Write all of the supplied data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::write(s, boost::asio::buffer(data, size)); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::write(
       s, buffers,
       boost::asio::transfer_all()); 







[endsect]



[section:overload2 write (2 of 16 overloads)]


Write all of the supplied data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::write(s, boost::asio::buffer(data, size), ec); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::write(
       s, buffers,
       boost::asio::transfer_all(), ec); 







[endsect]



[section:overload3 write (3 of 16 overloads)]


Write a certain amount of data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t write(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write\_some function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::write(s, boost::asio::buffer(data, size),
       boost::asio::transfer_at_least(32)); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload4 write (4 of 16 overloads)]


Write a certain amount of data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t write(
      SyncWriteStream & s,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec,
      typename constraint< is_const_buffer_sequence< ConstBufferSequence >::value >::type  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the stream.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write\_some function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]



[section:overload5 write (5 of 16 overloads)]


Write all of the supplied data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t write(
      SyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::write(
       s, buffers,
       boost::asio::transfer_all()); 







[endsect]



[section:overload6 write (6 of 16 overloads)]


Write all of the supplied data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``>
  std::size_t write(
      SyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::write(
       s, buffers,
       boost::asio::transfer_all(), ec); 







[endsect]



[section:overload7 write (7 of 16 overloads)]


Write a certain amount of data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t write(
      SyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write\_some function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 write (8 of 16 overloads)]


Write a certain amount of data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v1 DynamicBuffer_v1]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t write(
      SyncWriteStream & s,
      DynamicBuffer_v1 && buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v1< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0,
      typename constraint< !is_dynamic_buffer_v2< typename decay< DynamicBuffer_v1 >::type >::value >::type  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write\_some function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]



[section:overload9 write (9 of 16 overloads)]


Write all of the supplied data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename Allocator>
  std::size_t write(
      SyncWriteStream & s,
      basic_streambuf< Allocator > & b);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::write(
       s, b,
       boost::asio::transfer_all()); 







[endsect]



[section:overload10 write (10 of 16 overloads)]


Write all of the supplied data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename Allocator>
  std::size_t write(
      SyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      boost::system::error_code & ec);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::write(
       s, b,
       boost::asio::transfer_all(), ec); 







[endsect]



[section:overload11 write (11 of 16 overloads)]


Write a certain amount of data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t write(
      SyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write\_some function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload12 write (12 of 16 overloads)]


Write a certain amount of data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t write(
      SyncWriteStream & s,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      boost::system::error_code & ec);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write\_some function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]



[section:overload13 write (13 of 16 overloads)]


Write all of the supplied data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t write(
      SyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::write(
       s, buffers,
       boost::asio::transfer_all()); 







[endsect]



[section:overload14 write (14 of 16 overloads)]


Write all of the supplied data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``>
  std::size_t write(
      SyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::write(
       s, buffers,
       boost::asio::transfer_all(), ec); 







[endsect]



[section:overload15 write (15 of 16 overloads)]


Write a certain amount of data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t write(
      SyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write\_some function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload16 write (16 of 16 overloads)]


Write a certain amount of data to a stream before returning. 


  template<
      typename ``[link boost_asio.reference.SyncWriteStream SyncWriteStream]``,
      typename ``[link boost_asio.reference.DynamicBuffer_v2 DynamicBuffer_v2]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t write(
      SyncWriteStream & s,
      DynamicBuffer_v2 buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec,
      typename constraint< is_dynamic_buffer_v2< DynamicBuffer_v2 >::value >::type  = 0);


This function is used to write a certain number of bytes of data to a stream. The call will block until one of the following conditions is true:


* All of the data in the supplied dynamic buffer sequence has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the stream's write\_some function.


[heading Parameters]
    

[variablelist
  
[[s][The stream to which the data is to be written. The type must support the SyncWriteStream concept.]]

[[buffers][The dynamic buffer sequence from which data will be written. Successfully written data is automatically consumed from the buffers.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the stream's write\_some function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]


[endsect]

[section:write_at write_at]

[indexterm1 boost_asio.indexterm.write_at..write_at] 
The `write_at` function is a composed operation that writes a certain amount of data at a specified offset before returning. 


Write all of the supplied data at the specified offset before returning. 

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.write_at.overload1 write_at]``(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers);
  ``  [''''&raquo;''' [link boost_asio.reference.write_at.overload1 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t ``[link boost_asio.reference.write_at.overload2 write_at]``(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.write_at.overload2 more...]]``

Write a certain amount of data at a specified offset before returning. 

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.write_at.overload3 write_at]``(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition);
  ``  [''''&raquo;''' [link boost_asio.reference.write_at.overload3 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.write_at.overload4 write_at]``(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.write_at.overload4 more...]]``

Write all of the supplied data at the specified offset before returning. 

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.write_at.overload5 write_at]``(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b);
  ``  [''''&raquo;''' [link boost_asio.reference.write_at.overload5 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename Allocator>
  std::size_t ``[link boost_asio.reference.write_at.overload6 write_at]``(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.write_at.overload6 more...]]``

Write a certain amount of data at a specified offset before returning. 

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.write_at.overload7 write_at]``(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition);
  ``  [''''&raquo;''' [link boost_asio.reference.write_at.overload7 more...]]``

  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t ``[link boost_asio.reference.write_at.overload8 write_at]``(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      boost::system::error_code & ec);
  ``  [''''&raquo;''' [link boost_asio.reference.write_at.overload8 more...]]``

[heading Requirements]

['Header: ][^boost/asio/write_at.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:overload1 write_at (1 of 8 overloads)]


Write all of the supplied data at the specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_at(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers);


This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's write\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[buffers][One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::write_at(d, 42, boost::asio::buffer(data, size)); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::write_at(
       d, offset, buffers,
       boost::asio::transfer_all()); 







[endsect]



[section:overload2 write_at (2 of 8 overloads)]


Write all of the supplied data at the specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``>
  std::size_t write_at(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      boost::system::error_code & ec);


This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's write\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[buffers][One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::write_at(d, 42,
       boost::asio::buffer(data, size), ec); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::write_at(
       d, offset, buffers,
       boost::asio::transfer_all(), ec); 







[endsect]



[section:overload3 write_at (3 of 8 overloads)]


Write a certain amount of data at a specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t write_at(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition);


This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's write\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[buffers][One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write\_some\_at function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Example]
  
To write a single data buffer use the [link boost_asio.reference.buffer `buffer`]  function as follows: 

   boost::asio::write_at(d, 42, boost::asio::buffer(data, size),
       boost::asio::transfer_at_least(32)); 


See the [link boost_asio.reference.buffer `buffer`]  documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. 




[endsect]



[section:overload4 write_at (4 of 8 overloads)]


Write a certain amount of data at a specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename ``[link boost_asio.reference.ConstBufferSequence ConstBufferSequence]``,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t write_at(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      const ConstBufferSequence & buffers,
      CompletionCondition completion_condition,
      boost::system::error_code & ec);


This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:


* All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's write\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[buffers][One or more buffers containing the data to be written. The sum of the buffer sizes indicates the maximum number of bytes to write to the device.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write\_some\_at function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]



[section:overload5 write_at (5 of 8 overloads)]


Write all of the supplied data at the specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename Allocator>
  std::size_t write_at(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b);


This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's write\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure.]]

]


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::write_at(
       d, 42, b,
       boost::asio::transfer_all()); 







[endsect]



[section:overload6 write_at (6 of 8 overloads)]


Write all of the supplied data at the specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename Allocator>
  std::size_t write_at(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      boost::system::error_code & ec);


This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* An error occurred.

This operation is implemented in terms of zero or more calls to the device's write\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Remarks]
      
This overload is equivalent to calling: 

   boost::asio::write_at(
       d, 42, b,
       boost::asio::transfer_all(), ec); 







[endsect]



[section:overload7 write_at (7 of 8 overloads)]


Write a certain amount of data at a specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t write_at(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition);


This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's write\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write\_some\_at function.]]

]


[heading Return Value]
      
The number of bytes transferred.


[heading Exceptions]
    

[variablelist
  
[[boost::system::system_error][Thrown on failure. ]]

]




[endsect]



[section:overload8 write_at (8 of 8 overloads)]


Write a certain amount of data at a specified offset before returning. 


  template<
      typename ``[link boost_asio.reference.SyncRandomAccessWriteDevice SyncRandomAccessWriteDevice]``,
      typename Allocator,
      typename ``[link boost_asio.reference.CompletionCondition CompletionCondition]``>
  std::size_t write_at(
      SyncRandomAccessWriteDevice & d,
      uint64_t offset,
      basic_streambuf< Allocator > & b,
      CompletionCondition completion_condition,
      boost::system::error_code & ec);


This function is used to write a certain number of bytes of data to a random access device at a specified offset. The call will block until one of the following conditions is true:


* All of the data in the supplied [link boost_asio.reference.basic_streambuf `basic_streambuf`] has been written.


* The completion\_condition function object returns 0.

This operation is implemented in terms of zero or more calls to the device's write\_some\_at function.


[heading Parameters]
    

[variablelist
  
[[d][The device to which the data is to be written. The type must support the SyncRandomAccessWriteDevice concept.]]

[[offset][The offset at which the data will be written.]]

[[b][The [link boost_asio.reference.basic_streambuf `basic_streambuf`] object from which data will be written.]]

[[completion_condition][The function object to be called to determine whether the write operation is complete. The signature of the function object must be: 
``
   std::size_t completion_condition(
     // Result of latest write_some_at operation.
     const boost::system::error_code& error,

     // Number of bytes transferred so far.
     std::size_t bytes_transferred
   ); 
``
A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's write\_some\_at function.]]

[[ec][Set to indicate what error occurred, if any.]]

]


[heading Return Value]
      
The number of bytes written. If an error occurs, returns the total number of bytes successfully transferred prior to the error. 




[endsect]


[endsect]


[section:yield_context yield_context]

[indexterm1 boost_asio.indexterm.yield_context..yield_context] 
Context object that represents the currently executing coroutine. 


  typedef basic_yield_context< unspecified > yield_context;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link boost_asio.reference.basic_yield_context.callee_type [*callee_type]]]
    [The coroutine callee type, used by the implementation. ]
  
  ]

  [

    [[link boost_asio.reference.basic_yield_context.caller_type [*caller_type]]]
    [The coroutine caller type, used by the implementation. ]
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.basic_yield_context.basic_yield_context [*basic_yield_context]] [constructor]]
    [Construct a yield context to represent the specified coroutine. 
     [hr]
     Construct a yield context from another yield context type. ]
  ]
  
  [
    [[link boost_asio.reference.basic_yield_context.operator_lb__rb_ [*operator\[\]]]]
    [Return a yield context that sets the specified error_code. ]
  ]
  
]

The [link boost_asio.reference.basic_yield_context `basic_yield_context`] class is used to represent the currently executing stackful coroutine. A [link boost_asio.reference.basic_yield_context `basic_yield_context`] may be passed as a handler to an asynchronous operation. For example:



   template <typename Handler>
   void my_coroutine(basic_yield_context<Handler> yield)
   {
     ...
     std::size_t n = my_socket.async_read_some(buffer, yield);
     ...
   } 




The initiating function (async\_read\_some in the above example) suspends the current coroutine. The coroutine is resumed when the asynchronous operation completes, and the result of the operation is returned. 


[heading Requirements]

['Header: ][^boost/asio/spawn.hpp]

['Convenience header: ]None


[endsect]


[section:is_error_code_enum_lt__addrinfo_errors__gt_ boost::system::is_error_code_enum< boost::asio::error::addrinfo_errors >]

[indexterm1 boost_asio.indexterm.is_error_code_enum_lt__addrinfo_errors__gt_..boost::system::is_error_code_enum< boost::asio::error::addrinfo_errors >]



  template<>
  struct boost::system::is_error_code_enum< boost::asio::error::addrinfo_errors >


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.is_error_code_enum_lt__addrinfo_errors__gt_.value [*value]] [static]]
    []
  ]

]

[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:value boost::system::is_error_code_enum< boost::asio::error::addrinfo_errors >::value]

[indexterm2 boost_asio.indexterm.is_error_code_enum_lt__addrinfo_errors__gt_.value..value..boost::system::is_error_code_enum< boost::asio::error::addrinfo_errors >] 

  static const bool value = true;



[endsect]



[endsect]

[section:is_error_code_enum_lt__basic_errors__gt_ boost::system::is_error_code_enum< boost::asio::error::basic_errors >]

[indexterm1 boost_asio.indexterm.is_error_code_enum_lt__basic_errors__gt_..boost::system::is_error_code_enum< boost::asio::error::basic_errors >]



  template<>
  struct boost::system::is_error_code_enum< boost::asio::error::basic_errors >


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.is_error_code_enum_lt__basic_errors__gt_.value [*value]] [static]]
    []
  ]

]

[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:value boost::system::is_error_code_enum< boost::asio::error::basic_errors >::value]

[indexterm2 boost_asio.indexterm.is_error_code_enum_lt__basic_errors__gt_.value..value..boost::system::is_error_code_enum< boost::asio::error::basic_errors >] 

  static const bool value = true;



[endsect]



[endsect]

[section:is_error_code_enum_lt__misc_errors__gt_ boost::system::is_error_code_enum< boost::asio::error::misc_errors >]

[indexterm1 boost_asio.indexterm.is_error_code_enum_lt__misc_errors__gt_..boost::system::is_error_code_enum< boost::asio::error::misc_errors >]



  template<>
  struct boost::system::is_error_code_enum< boost::asio::error::misc_errors >


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.is_error_code_enum_lt__misc_errors__gt_.value [*value]] [static]]
    []
  ]

]

[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:value boost::system::is_error_code_enum< boost::asio::error::misc_errors >::value]

[indexterm2 boost_asio.indexterm.is_error_code_enum_lt__misc_errors__gt_.value..value..boost::system::is_error_code_enum< boost::asio::error::misc_errors >] 

  static const bool value = true;



[endsect]



[endsect]

[section:is_error_code_enum_lt__netdb_errors__gt_ boost::system::is_error_code_enum< boost::asio::error::netdb_errors >]

[indexterm1 boost_asio.indexterm.is_error_code_enum_lt__netdb_errors__gt_..boost::system::is_error_code_enum< boost::asio::error::netdb_errors >]



  template<>
  struct boost::system::is_error_code_enum< boost::asio::error::netdb_errors >


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.is_error_code_enum_lt__netdb_errors__gt_.value [*value]] [static]]
    []
  ]

]

[heading Requirements]

['Header: ][^boost/asio/error.hpp]

['Convenience header: ][^boost/asio.hpp]


[section:value boost::system::is_error_code_enum< boost::asio::error::netdb_errors >::value]

[indexterm2 boost_asio.indexterm.is_error_code_enum_lt__netdb_errors__gt_.value..value..boost::system::is_error_code_enum< boost::asio::error::netdb_errors >] 

  static const bool value = true;



[endsect]



[endsect]

[section:is_error_code_enum_lt__ssl_errors__gt_ boost::system::is_error_code_enum< boost::asio::error::ssl_errors >]

[indexterm1 boost_asio.indexterm.is_error_code_enum_lt__ssl_errors__gt_..boost::system::is_error_code_enum< boost::asio::error::ssl_errors >]



  template<>
  struct boost::system::is_error_code_enum< boost::asio::error::ssl_errors >


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.is_error_code_enum_lt__ssl_errors__gt_.value [*value]] [static]]
    []
  ]

]

[heading Requirements]

['Header: ][^boost/asio/ssl/error.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[section:value boost::system::is_error_code_enum< boost::asio::error::ssl_errors >::value]

[indexterm2 boost_asio.indexterm.is_error_code_enum_lt__ssl_errors__gt_.value..value..boost::system::is_error_code_enum< boost::asio::error::ssl_errors >] 

  static const bool value = true;



[endsect]



[endsect]

[section:is_error_code_enum_lt__boost__asio__experimental__error__channel_errors__gt_ boost::system::is_error_code_enum< boost::asio::experimental::error::channel_errors >]

[indexterm1 boost_asio.indexterm.is_error_code_enum_lt__boost__asio__experimental__error__channel_errors__gt_..boost::system::is_error_code_enum< boost::asio::experimental::error::channel_errors >]



  template<>
  struct boost::system::is_error_code_enum< boost::asio::experimental::error::channel_errors >


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.is_error_code_enum_lt__boost__asio__experimental__error__channel_errors__gt_.value [*value]] [static]]
    []
  ]

]

[heading Requirements]

['Header: ][^boost/asio/experimental/channel_error.hpp]

['Convenience header: ]None


[section:value boost::system::is_error_code_enum< boost::asio::experimental::error::channel_errors >::value]

[indexterm2 boost_asio.indexterm.is_error_code_enum_lt__boost__asio__experimental__error__channel_errors__gt_.value..value..boost::system::is_error_code_enum< boost::asio::experimental::error::channel_errors >] 

  static const bool value = true;



[endsect]



[endsect]

[section:is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_ boost::system::is_error_code_enum< boost::asio::ssl::error::stream_errors >]

[indexterm1 boost_asio.indexterm.is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_..boost::system::is_error_code_enum< boost::asio::ssl::error::stream_errors >]



  template<>
  struct boost::system::is_error_code_enum< boost::asio::ssl::error::stream_errors >


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link boost_asio.reference.is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.value [*value]] [static]]
    []
  ]

]

[heading Requirements]

['Header: ][^boost/asio/ssl/error.hpp]

['Convenience header: ][^boost/asio/ssl.hpp]


[section:value boost::system::is_error_code_enum< boost::asio::ssl::error::stream_errors >::value]

[indexterm2 boost_asio.indexterm.is_error_code_enum_lt__boost__asio__ssl__error__stream_errors__gt_.value..value..boost::system::is_error_code_enum< boost::asio::ssl::error::stream_errors >] 

  static const bool value = true;



[endsect]



[endsect]

[endsect]
