<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Result of</title>
<link rel="stylesheet" href="../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Utility">
<link rel="up" href="../utilities.html" title="Utilities">
<link rel="prev" href="operators.html" title="Operators">
<link rel="next" href="string_view.html" title="String View">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="operators.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../utilities.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="string_view.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="utility.utilities.result_of"></a><a class="link" href="result_of.html" title="Result of">Result of</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="result_of.html#utility.utilities.result_of.introduction">Introduction</a></span></dt>
<dt><span class="section"><a href="result_of.html#utility.utilities.result_of.usage_guidelines_for_boost_resul">Usage guidelines for <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a></span></dt>
<dt><span class="section"><a href="result_of.html#utility.utilities.result_of.usage_guidelines_for_the_tr1_res">Usage
        guidelines for the TR1 result_of protocol</a></span></dt>
<dt><span class="section"><a href="result_of.html#utility.utilities.result_of.known_differences_between_boost_">Known differences between <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code>
        and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tr1_result_of</span></code></a></span></dt>
<dt><span class="section"><a href="result_of.html#utility.utilities.result_of.known_differences_between_boost0">Known differences between
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code>
        and C++11 result_of</a></span></dt>
<dt><span class="section"><a href="result_of.html#result_of.reference">Reference</a></span></dt>
<dt><span class="section"><a href="result_of.html#utility.utilities.result_of.acknowledgments">Acknowledgments</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="utility.utilities.result_of.introduction"></a><a class="link" href="result_of.html#utility.utilities.result_of.introduction" title="Introduction">Introduction</a>
</h4></div></div></div>
<p>
          The class template <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a>
          helps determine the type of a call expression. For example, given an lvalue
          <code class="computeroutput"><span class="identifier">f</span></code> of type <code class="computeroutput"><span class="identifier">F</span></code> and lvalues <code class="computeroutput"><span class="identifier">t1</span></code>,<code class="computeroutput"><span class="identifier">t2</span></code>, ..., <code class="computeroutput"><span class="identifier">tN</span></code>
          of types <code class="computeroutput"><span class="identifier">T1</span></code>, <code class="computeroutput"><span class="identifier">T2</span></code>, ..., <code class="computeroutput"><span class="identifier">TN</span></code>,
          respectively, the type <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a><code class="computeroutput"><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">T1</span><span class="special">,</span>
          <span class="identifier">T2</span><span class="special">,</span>
          <span class="special">...,</span> <span class="identifier">TN</span><span class="special">)&gt;::</span><span class="identifier">type</span></code>
          defines the result type of the expression <code class="computeroutput"><span class="identifier">f</span><span class="special">(</span><span class="identifier">t1</span><span class="special">,</span>
          <span class="identifier">t2</span><span class="special">,</span>
          <span class="special">...,</span><span class="identifier">tN</span><span class="special">)</span></code>.
        </p>
<p>
          This implementation permits the type <code class="computeroutput"><span class="identifier">F</span></code>
          to be a function pointer, function reference, member function pointer,
          or class type. By default, N may be any value between 0 and 16. To change
          the upper limit, define the macro <code class="computeroutput"><span class="identifier">BOOST_RESULT_OF_NUM_ARGS</span></code>
          to the maximum value for N. Class template <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a> resides in the header
          <a href="../../../../../include/boost/utility/result_of.hpp" target="_top"><code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">utility</span><span class="special">/</span><span class="identifier">result_of</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code></a>.
        </p>
<p>
          If your compiler's support for <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a> is adequate, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a> automatically uses it
          to deduce the type of the call expression, in which case <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a><code class="computeroutput"><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span><span class="special">,</span> <span class="special">...,</span> <span class="identifier">TN</span><span class="special">)&gt;::</span><span class="identifier">type</span></code> names the type <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a><code class="computeroutput"><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">declval</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">&gt;()(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">declval</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">&gt;(),</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">declval</span><span class="special">&lt;</span><span class="identifier">T2</span><span class="special">&gt;(),</span> <span class="special">...,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">declval</span><span class="special">&lt;</span><span class="identifier">TN</span><span class="special">&gt;()))</span></code>, as in the following example.
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">functor</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="identifier">T</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span> <span class="identifier">x</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">x</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">typedef</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a><span class="special">&lt;</span><span class="identifier">functor</span><span class="special">(</span><span class="keyword">int</span><span class="special">)&gt;::</span><span class="identifier">type</span> <span class="identifier">type</span><span class="special">;</span> <span class="comment">// type is int</span>
</pre>
<p>
          You can test whether <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a>
          is using <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a> by checking if the macro
          <code class="computeroutput"><span class="identifier">BOOST_RESULT_OF_USE_DECLTYPE</span></code>
          is defined after including <code class="computeroutput"><span class="identifier">result_of</span><span class="special">.</span><span class="identifier">hpp</span></code>.
          You can also force <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a>
          to use <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a> by defining <code class="computeroutput"><span class="identifier">BOOST_RESULT_OF_USE_DECLTYPE</span></code> prior to
          including <code class="computeroutput"><span class="identifier">result_of</span><span class="special">.</span><span class="identifier">hpp</span></code>.
        </p>
<p>
          If <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a> is not used, then automatic
          result type deduction of function objects is not possible. Instead, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a>
          uses the following protocol to allow the programmer to specify a type.
          When <code class="computeroutput"><span class="identifier">F</span></code> is a class type
          with a member type <code class="computeroutput"><span class="identifier">result_type</span></code>,
          <code class="computeroutput"><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span><span class="special">,</span> <span class="special">...,</span> <span class="identifier">TN</span><span class="special">)&gt;::</span><span class="identifier">type</span></code> is <code class="computeroutput"><span class="identifier">F</span><span class="special">::</span><span class="identifier">result_type</span></code>.
          When <code class="computeroutput"><span class="identifier">F</span></code> does not contain
          <code class="computeroutput"><span class="identifier">result_type</span></code>, <code class="computeroutput"><span class="identifier">result_of</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span><span class="special">,</span> <span class="special">...,</span> <span class="identifier">TN</span><span class="special">)&gt;::</span><span class="identifier">type</span></code> is <code class="computeroutput"><span class="identifier">F</span><span class="special">::</span><span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">T1</span><span class="special">,</span>
          <span class="identifier">T2</span><span class="special">,</span>
          <span class="special">...,</span> <span class="identifier">TN</span><span class="special">)&gt;::</span><span class="identifier">type</span></code>
          when <code class="computeroutput"><span class="identifier">N</span> <span class="special">&gt;</span>
          <span class="number">0</span></code> or <code class="computeroutput"><span class="keyword">void</span></code>
          when <code class="computeroutput"><span class="identifier">N</span> <span class="special">=</span>
          <span class="number">0</span></code>.
        </p>
<p>
          Note that it is the responsibility of the programmer to ensure that function
          objects accurately advertise their result type via this protocol, as in
          the following example.
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">functor</span> <span class="special">{</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">T</span><span class="special">)&gt;</span> <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">T</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="identifier">T</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span> <span class="identifier">x</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">x</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">typedef</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a><span class="special">&lt;</span><span class="identifier">functor</span><span class="special">(</span><span class="keyword">int</span><span class="special">)&gt;::</span><span class="identifier">type</span> <span class="identifier">type</span><span class="special">;</span> <span class="comment">// type is int</span>
</pre>
<p>
          Since <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a> is a language feature standardized
          in C++11, if you are writing a function object to be used with <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a>, for maximum portability,
          you might consider following the above protocol even if your compiler has
          proper <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a> support.
        </p>
<p>
          If you wish to continue to use the protocol on compilers that support
          <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a>, there are two options:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              You can use <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tr1_result_of</span></code></a>,
              which is also defined in <a href="../../../../../boost/utility/result_of.hpp" target="_top"><code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">utility</span><span class="special">/</span><span class="identifier">result_of</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code></a>.
            </li>
<li class="listitem">
              Alternatively, you can define the macro <code class="computeroutput"><span class="identifier">BOOST_RESULT_OF_USE_TR1</span></code>,
              which causes <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a>
              to use the protocol described above instead of <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a>. If you choose to follow
              the protocol, take care to ensure that the <code class="computeroutput"><span class="identifier">result_type</span></code>
              and <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>
              members accurately represent the return type of <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> given a call expression.
            </li>
</ul></div>
<p>
          Additionally, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a>
          provides a third mode of operation, which some users may find convenient.
          When <code class="computeroutput"><span class="identifier">BOOST_RESULT_OF_USE_TR1_WITH_DECLTYPE_FALLBACK</span></code>
          is defined, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a>
          behaves as follows. If the function object has a member type <code class="computeroutput"><span class="identifier">result_type</span></code> or member template <code class="computeroutput"><span class="identifier">result</span><span class="special">&lt;&gt;</span></code>,
          then <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a>
          will use the TR1 protocol.
        </p>
<p>
          Otherwise, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a>
          will use <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a>. Using TR1 with a <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a> fallback may workaround
          certain problems at the cost of portability. For example:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              Deficient compiler: If your code requires <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> to work with incomplete
              return types but your compiler's <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a> implementation does
              not support incomplete return types, then you can use the TR1 protocol
              as a workaround. Support for incomplete return types was added late
              in the C++11 standardization process (see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3276.pdf" target="_top">N3276</a>)
              and is not implemented by some compilers.
            </li>
<li class="listitem">
              Deficient legacy code: If your existing TR1 function object advertises
              a different type than the actual result type deduced by <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a>, then using TR1 with
              a <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a> fallback will allow
              you to work with both your existing TR1 function objects and new C++11
              function object. This situation could occur if your legacy function
              objects misused the TR1 protocol. See the documentation on known <a class="link" href="result_of.html#sec:result_of_tr1_diff">differences</a> between <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> and TR1.
            </li>
<li class="listitem">
              <a name="BOOST_NO_RESULT_OF"></a>This implementation of <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a> requires class template
              partial specialization, the ability to parse function types properly,
              and support for SFINAE. If <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a> is not supported
              by your compiler, including the header <a href="../../../../../boost/utility/result_of.hpp" target="_top"><code class="computeroutput"><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">utility</span><span class="special">/</span><span class="identifier">result_of</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code></a> will define the macro
              <code class="computeroutput"><span class="identifier">BOOST_NO_RESULT_OF</span></code>.
            </li>
</ul></div>
<p>
          For additional information about <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a>, see the C++ Library
          Technical Report, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf" target="_top">N1836</a>,
          or, for motivation and design rationale, the <a class="link" href="../../"><code class="computeroutput"><span class="identifier">result_of</span></code></a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1454.html" target="_top">proposal</a>.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="utility.utilities.result_of.usage_guidelines_for_boost_resul"></a><a name="sec:result_of_guidelines"></a>Usage guidelines for <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a>
</h4></div></div></div>
<p>
          The following are general suggestions about when and how to use <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a>.
        </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
              If you are targeting C++11 and are not concerned about portability
              to non-compliant compilers or previous versions of the standard, then
              use <code class="computeroutput"><a href="https://en.cppreference.com/w/cpp/types/result_of" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span></code></a></code>. If <code class="computeroutput"><a href="https://en.cppreference.com/w/cpp/types/result_of" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span></code></a></code> meets your
              needs, then there's no reason to stop using it.
            </li>
<li class="listitem">
              If you are targeting C++11 but may port your code to legacy compilers
              at some time in the future, then use <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> with <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a>. When <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a> is used <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> and <code class="computeroutput"><a href="https://en.cppreference.com/w/cpp/types/result_of" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span></code></a></code> are usually
              interchangeable. See the documentation on known <a class="link" href="result_of.html#sec:result_of_cxx11_diff">differences</a>
              between <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a>
              and C++11 <a href="https://en.cppreference.com/w/cpp/types/result_of" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span></code></a>.
            </li>
<li class="listitem">
              If compiler portability is required, use <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> with the TR1 protocol
            </li>
</ol></div>
<p>
          Regardless of how you configure <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a>, it is important to
          bear in mind that the return type of a function may change depending on
          its arguments, and additionally, the return type of a member function may
          change depending on the cv-qualification of the object. <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> must be passed the appropriately
          cv-qualified types in order to deduce the corresponding return type.
        </p>
<p>
          For example:
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">functor</span> <span class="special">{</span>
    <span class="keyword">int</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">int</span><span class="special">);</span>
    <span class="keyword">int</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">int</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">float</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">float</span><span class="special">&amp;);</span>
    <span class="keyword">float</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">float</span> <span class="keyword">const</span><span class="special">&amp;);</span>
<span class="special">};</span>

<span class="keyword">typedef</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a><span class="special">&lt;</span>
    <span class="identifier">functor</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span>
<span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">type1</span><span class="special">;</span> <span class="comment">// type1 is int &amp;</span>

<span class="keyword">typedef</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a><span class="special">&lt;</span>
    <span class="keyword">const</span> <span class="identifier">functor</span><span class="special">(</span><span class="keyword">int</span><span class="special">)</span>
<span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">type2</span><span class="special">;</span> <span class="comment">// type2 is int const &amp;</span>

<span class="keyword">typedef</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a><span class="special">&lt;</span>
    <span class="identifier">functor</span><span class="special">(</span><span class="keyword">float</span><span class="special">&amp;)</span>
<span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">type3</span><span class="special">;</span> <span class="comment">// type3 is float &amp;</span>

<span class="keyword">typedef</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a><span class="special">&lt;</span>
    <span class="identifier">functor</span><span class="special">(</span><span class="keyword">float</span> <span class="keyword">const</span><span class="special">&amp;)</span>
<span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">type4</span><span class="special">;</span> <span class="comment">// type4 is float const &amp;</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="utility.utilities.result_of.usage_guidelines_for_the_tr1_res"></a><a name="sec:result_of_tr1_protocol_guidelines"></a><a class="link" href="result_of.html#utility.utilities.result_of.usage_guidelines_for_the_tr1_res" title="Usage guidelines for the TR1 result_of protocol">Usage
        guidelines for the TR1 result_of protocol</a>
</h4></div></div></div>
<p>
          On compliant C++11 compilers, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> can use <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a> to deduce the type of any
          call expression, including calls to function objects. However, on pre-C++11
          compilers or on compilers without adequate decltype support, additional
          scaffolding is needed from function objects as described above. The following
          are suggestions about how to use the TR1 protocol.
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              When the return type does not depend on the argument types or the cv-qualification
              of the function object, simply define <code class="computeroutput"><span class="identifier">result_type</span></code>.
              There is no need to use the <code class="computeroutput"><span class="identifier">result</span></code>
              template unless the return type varies.&lt;/li&gt;
            </li>
<li class="listitem">
              Use the protocol specified type when defining function prototypes.
              This can help ensure the actual return type does not get out of sync
              with the protocol specification. For example:
            </li>
</ul></div>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">functor</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="identifier">result_type</span><span class="special">;</span>
    <span class="identifier">result_type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">int</span><span class="special">);</span>
<span class="special">};</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              Always specify the <code class="computeroutput"><span class="identifier">result</span></code>
              specialization near the corresponding <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> overload. This can make it easier
              to keep the specializations in sync with the overloads. For example:
            </li></ul></div>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">functor</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="keyword">int</span><span class="special">)&gt;</span> <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">int</span><span class="special">&amp;</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>
    <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">functor</span><span class="special">(</span><span class="keyword">int</span><span class="special">)&gt;::</span><span class="identifier">type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">int</span><span class="special">);</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">F</span><span class="special">(</span><span class="keyword">int</span><span class="special">)&gt;</span> <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>
    <span class="identifier">result</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="identifier">functor</span><span class="special">(</span><span class="keyword">int</span><span class="special">)&gt;::</span><span class="identifier">type</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">int</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              Use type transformations to simplify the <code class="computeroutput"><span class="identifier">result</span></code>
              template specialization. For example, the following uses <a href="../../../type_traits/doc/html/index.html" target="_top">Boost.TypeTraits</a>
              to specialize the <code class="computeroutput"><span class="identifier">result</span></code>
              template for a single <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code> that can be called on both a const
              and non-const function object with either an lvalue or rvalue argument.
            </li></ul></div>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">functor</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">;</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="identifier">T</span><span class="special">)&gt;</span>
        <span class="special">:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">remove_cv</span><span class="special">&lt;</span>
              <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">remove_reference</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span>
          <span class="special">&gt;</span>
    <span class="special">{};</span>

    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
    <span class="identifier">T</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span><span class="identifier">amp</span><span class="special">;</span> <span class="identifier">x</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="utility.utilities.result_of.known_differences_between_boost_"></a><a name="sec:result_of_tr1_diff"></a>Known differences between <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a>
        and <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tr1_result_of</span></code></a>
</h4></div></div></div>
<p>
          When using <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a>, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> ignores the TR1 protocol
          and instead deduces the return type of function objects directly via <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a>. In most situations, users
          will not notice a difference, so long as they use the protocol correctly.
          The following are situations in which the type deduced by <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> is known to differ depending
          on whether <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a> or the TR1 protocol is
          used.
        </p>
<p>
          TR1 protocol misusage: When using the TR1 protocol, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> cannot detect whether
          the actual type of a call to a function object is the same as the type
          specified by the protocol, which allows for the possibility of inadvertent
          mismatches between the specified type and the actual type. When using
          <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a>, these subtle bugs may
          result in compilation errors. For example:
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">functor</span> <span class="special">{</span>
   <span class="keyword">typedef</span> <span class="keyword">short</span> <span class="identifier">result_type</span><span class="special">;</span>
   <span class="keyword">int</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">short</span><span class="special">);</span>
<span class="special">};</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_RESULT_OF_USE_DECLTYPE</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a><span class="special">&lt;</span><span class="identifier">functor</span><span class="special">(</span><span class="keyword">short</span><span class="special">)&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="preprocessor">#else</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a><span class="special">&lt;</span><span class="identifier">functor</span><span class="special">(</span><span class="keyword">short</span><span class="special">)&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="keyword">short</span><span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="preprocessor">#endif</span>
</pre>
<p>
          Note that the user can force <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> to use the TR1 protocol
          even on platforms that support <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a> by defining <code class="computeroutput"><span class="identifier">BOOST_RESULT_OF_USE_TR1</span></code>.
        </p>
<p>
          Nullary function objects: When using the TR1 protocol, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> cannot always deduce
          the type of calls to nullary function objects, in which case the type defaults
          to void. When using <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a>, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> always gives the actual
          type of the call expression. For example:
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">functor</span> <span class="special">{</span>
   <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">result</span> <span class="special">{</span>
       <span class="keyword">typedef</span> <span class="keyword">int</span> <span class="identifier">type</span><span class="special">;</span>
   <span class="special">};</span>
   <span class="keyword">int</span> <span class="keyword">operator</span><span class="special">()();</span>
<span class="special">};</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_RESULT_OF_USE_DECLTYPE</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a><span class="special">&lt;</span><span class="identifier">functor</span><span class="special">()&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="preprocessor">#else</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span><a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a><span class="special">&lt;</span><span class="identifier">functor</span><span class="special">()&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="keyword">void</span><span class="special">&gt;::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="preprocessor">#endif</span>
</pre>
<p>
          Note that there are some workarounds for the nullary function problem.
          So long as the return type does not vary, <code class="computeroutput"><span class="identifier">result_type</span></code>
          can always be used to specify the return type regardless of arity. If the
          return type does vary, then the user can specialize <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> itself for nullary calls.
        </p>
<p>
          Non-class prvalues and cv-qualification: When using the TR1 protocol,
          <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a>
          will report the cv-qualified type specified by <code class="computeroutput"><span class="identifier">result_type</span></code>
          or the <code class="computeroutput"><span class="identifier">result</span></code> template
          regardless of the actual cv-qualification of the call expression. When
          using <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a>, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> will report the actual
          type of the call expression, which is not cv-qualified when the expression
          is a non-class prvalue. For example:
        </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">functor</span> <span class="special">{</span>
   <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">;</span>
   <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">F</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">result</span><span class="special">&lt;</span><span class="identifier">F</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">)&gt;</span> <span class="special">{</span>
       <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="identifier">T</span> <span class="identifier">type</span><span class="special">;</span>
   <span class="special">};</span>

   <span class="keyword">const</span> <span class="keyword">short</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">const</span> <span class="keyword">short</span><span class="special">);</span>
   <span class="keyword">int</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">()(</span><span class="keyword">int</span> <span class="keyword">const</span> <span class="special">&amp;);</span>
<span class="special">};</span>

<span class="comment">// Non-prvalue call expressions work the same with or without decltype.</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span>
       <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a><span class="special">&lt;</span><span class="identifier">functor</span><span class="special">(</span><span class="keyword">int</span> <span class="keyword">const</span> <span class="special">&amp;)&gt;::</span><span class="identifier">type</span><span class="special">,</span>
       <span class="keyword">int</span> <span class="keyword">const</span> <span class="special">&amp;</span>
<span class="special">::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="comment">// Non-class prvalue call expressions are not actually cv-qualified,</span>
<span class="comment">// but only the decltype-based result_of reports this accurately.</span>

<span class="preprocessor">#ifdef</span> <span class="identifier">BOOST_RESULT_OF_USE_DECLTYPE</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span>
       <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a><span class="special">&lt;</span><span class="identifier">functor</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">short</span><span class="special">)&gt;::</span><span class="identifier">type</span><span class="special">,</span>
       <span class="keyword">short</span>
<span class="special">::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="preprocessor">#else</span>

<span class="identifier">BOOST_STATIC_ASSERT</span><span class="special">((</span>
   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_same</span><span class="special">&lt;</span>
       <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a><span class="special">&lt;</span><span class="identifier">functor</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">short</span><span class="special">)&gt;::</span><span class="identifier">type</span><span class="special">,</span>
       <span class="keyword">const</span> <span class="keyword">short</span>
<span class="special">::</span><span class="identifier">value</span>
<span class="special">));</span>

<span class="preprocessor">#endif</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="utility.utilities.result_of.known_differences_between_boost0"></a><a name="sec:result_of_cxx11_diff"></a>Known differences between
        <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a>
        and C++11 result_of</h4></div></div></div>
<p>
          When using <a href="https://en.cppreference.com/w/cpp/language/decltype" target="_top"><code class="computeroutput"><span class="keyword">decltype</span></code></a>, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a> implements most of the
          C++11 <a href="https://en.cppreference.com/w/cpp/types/result_of" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">result_of</span></code></a> specification. One
          known exception is that <a class="link" href="../../"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">result_of</span></code></a>
          does not implement the requirements regarding pointers to member data.
        </p>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title">
<a name="result_of.reference"></a>Reference</h4></div></div></div></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="utility.utilities.result_of.acknowledgments"></a><a class="link" href="result_of.html#utility.utilities.result_of.acknowledgments" title="Acknowledgments">Acknowledgments</a>
</h4></div></div></div>
<p>
          Created by Doug Gregor. Contributions from Daniel Walker, Eric Niebler,
          Michel Morin and others.
        </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2001 Beman Dawes<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="operators.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../utilities.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="string_view.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
