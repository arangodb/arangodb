<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Value Init</title>
<link rel="stylesheet" href="../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Utility">
<link rel="up" href="../utilities.html" title="Utilities">
<link rel="prev" href="string_view.html" title="String View">
<link rel="next" href="../utilities0.html" title="More Utilities">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="string_view.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../utilities.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../utilities0.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="utility.utilities.value_init"></a><a name="sec:value_init"></a><a class="link" href="value_init.html" title="Value Init">Value
      Init</a>
</h3></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="value_init.html#utility.utilities.value_init.introduction">Introduction</a></span></dt>
<dt><span class="section"><a href="value_init.html#utility.utilities.value_init.details">Details</a></span></dt>
<dt><span class="section"><a href="value_init.html#utility.utilities.value_init.types_and_objects">Types
        and objects</a></span></dt>
<dt><span class="section"><a href="value_init.html#utility.utilities.value_init.references">References</a></span></dt>
<dt><span class="section"><a href="value_init.html#value_init.reference">Reference</a></span></dt>
<dt><span class="section"><a href="value_init.html#utility.utilities.value_init.acknowledgements">Acknowledgements</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="utility.utilities.value_init.introduction"></a><a class="link" href="value_init.html#utility.utilities.value_init.introduction" title="Introduction">Introduction</a>
</h4></div></div></div>
<p>
          Constructing and initializing objects in a generic way is difficult in
          C++. The problem is that there are several different rules that apply for
          initialization. Depending on the type, the value of a newly constructed
          object can be zero-initialized (logically 0), default-constructed (using
          the default constructor), or indeterminate. When writing generic code,
          this problem must be addressed. The template <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a> provides a solution
          with consistent syntax for value initialization of scalar, union and class
          types. Moreover, <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a> offers a workaround
          to various compiler issues regarding value-initialization.
        </p>
<p>
          Furthermore, a <code class="computeroutput"><span class="keyword">const</span></code> object
          <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized_value</span></code></a>
          is provided, to avoid repeating the type name when retrieving the value
          from a <code class="computeroutput"><a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> object.
        </p>
<p>
          There are various ways to initialize a variable, in C++. The following
          declarations all <span class="emphasis"><em>may</em></span> have a local variable initialized
          to its default value:
        </p>
<pre class="programlisting"><span class="identifier">T1</span> <span class="identifier">var1</span><span class="special">;</span>
<span class="identifier">T2</span> <span class="identifier">var2</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="identifier">T3</span> <span class="identifier">var3</span> <span class="special">=</span> <span class="special">{};</span>
<span class="identifier">T4</span> <span class="identifier">var4</span> <span class="special">=</span> <span class="identifier">T4</span><span class="special">();</span>
</pre>
<p>
          Unfortunately, whether or not any of those declarations correctly initialize
          the variable very much depends on its type. The first declaration is valid
          for any <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_top"><span class="emphasis"><em>DefaultConstructible</em></span></a>
          type by definition.
        </p>
<p>
          However, it does not always do an initialization. It correctly initializes
          the variable when it's an instance of a class, and the author of the class
          has provided a proper default constructor. On the other hand, the value
          of <code class="computeroutput"><span class="identifier">var1</span></code> is <span class="emphasis"><em>indeterminate</em></span>
          when its type is an arithmetic type, like <code class="computeroutput"><span class="keyword">int</span></code>,
          <code class="computeroutput"><span class="keyword">float</span></code>, or <code class="computeroutput"><span class="keyword">char</span></code>.
        </p>
<p>
          An arithmetic variable is of course initialized properly by the second
          declaration, <code class="computeroutput"><span class="identifier">T2</span> <span class="identifier">var2</span>
          <span class="special">=</span> <span class="number">0</span></code>.
          But this initialization form will not usually work for a class type, unless
          the class was especially written to support being initialized that way.
        </p>
<p>
          The third form, <code class="computeroutput"><span class="identifier">T3</span> <span class="identifier">var3</span>
          <span class="special">=</span> <span class="special">{}</span></code>,
          initializes an aggregate, typically a "C-style" <code class="computeroutput"><span class="keyword">struct</span></code> or a "C-style" array. However,
          at the time this library was developed, the syntax did not allow for a
          class that has an explicitly declared constructor.
        </p>
<p>
          The fourth form is the most generic form of them, as it can be used to
          initialize arithmetic types, class types, aggregates, pointers, and other
          types. The declaration, <code class="computeroutput"><span class="identifier">T4</span> <span class="identifier">var4</span> <span class="special">=</span> <span class="identifier">T4</span><span class="special">()</span></code>,
          should be read as follows: First a temporary object is created, by <code class="computeroutput"><span class="identifier">T4</span><span class="special">()</span></code>.
          This object is <a class="link" href="value_init.html#sec:valueinit">value-initialized</a>.
          Next the temporary object is copied to the named variable, <code class="computeroutput"><span class="identifier">var4</span></code>. Afterwards, the temporary is destroyed.
          While the copying and the destruction are likely to be optimized away,
          C++ still requires the type <code class="computeroutput"><span class="identifier">T4</span></code>
          to be <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible" target="_top"><span class="emphasis"><em>CopyConstructible</em></span></a>.
          So <code class="computeroutput"><span class="identifier">T4</span></code> needs to be <span class="emphasis"><em>both</em></span>
          <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_top"><span class="emphasis"><em>DefaultConstructible</em></span></a>
          <span class="emphasis"><em>and</em></span> <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible" target="_top"><span class="emphasis"><em>CopyConstructible</em></span></a>.
        </p>
<p>
          A class may not be CopyConstructible, for example because it may have a
          private and undefined copy constructor, or because it may be derived from
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span></code>. Scott Meyers [<a class="link" href="value_init.html#sec:references">2</a>]
          explains why a class would be defined like that.
        </p>
<p>
          There is another, less obvious disadvantage to the fourth form, <code class="computeroutput"><span class="identifier">T4</span> <span class="identifier">var4</span>
          <span class="special">=</span> <span class="identifier">T4</span><span class="special">()</span></code>: It suffers from various <a class="link" href="value_init.html#sec:compiler_issues">compiler
          issues</a>, causing a variable to be left uninitialized in some compiler
          specific cases.
        </p>
<p>
          The template <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a>
          offers a generic way to initialize an object, like <code class="computeroutput"><span class="identifier">T4</span>
          <span class="identifier">var4</span> <span class="special">=</span>
          <span class="identifier">T4</span><span class="special">()</span></code>,
          but without requiring its type to be <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible" target="_top"><span class="emphasis"><em>CopyConstructible</em></span></a>.
          And it offers a workaround to those compiler issues regarding value-initialization
          as well. It allows getting an initialized variable of any type; it <span class="emphasis"><em>only</em></span>
          requires the type to be <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_top"><span class="emphasis"><em>DefaultConstructible</em></span></a>.
          A properly <span class="emphasis"><em>value-initialized</em></span> object of type <code class="computeroutput"><span class="identifier">T</span></code> is constructed by the following declaration:
        </p>
<pre class="programlisting"><span class="identifier">value_initialized</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">var</span><span class="special">;</span>
</pre>
<p>
          The template <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a>
          offers both value-initialization and direct-initialization. It is especially
          useful as a data member type, allowing the very same object to be either
          direct-initialized or value-initialized.
        </p>
<p>
          The <code class="computeroutput"><span class="keyword">const</span></code> object <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized_value</span></code></a> allows value-initializing
          a variable as follows:
        </p>
<pre class="programlisting"><span class="identifier">T</span> <span class="identifier">var</span> <span class="special">=</span> <span class="identifier">initialized_value</span><span class="special">;</span>
</pre>
<p>
          This form of initialization is semantically equivalent to <code class="computeroutput"><span class="identifier">T4</span> <span class="identifier">var4</span>
          <span class="special">=</span> <span class="identifier">T4</span><span class="special">()</span></code>, but robust against the aforementioned
          compiler issues.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="utility.utilities.value_init.details"></a><a name="sec:details"></a><a class="link" href="value_init.html#utility.utilities.value_init.details" title="Details">Details</a>
</h4></div></div></div>
<p>
          The C++ standard [<a class="link" href="value_init.html#sec:references">3</a>] contains the
          definitions of <code class="computeroutput"><span class="identifier">zero</span><span class="special">-</span><span class="identifier">initialization</span></code> and <code class="computeroutput"><span class="keyword">default</span><span class="special">-</span><span class="identifier">initialization</span></code>.
          Informally, zero-initialization means that the object is given the initial
          value <code class="computeroutput"><span class="number">0</span></code> converted to the type
          and default-initialization means that POD [<a class="link" href="value_init.html#sec:references">4</a>]
          types are zero-initialized, while non-POD class types are initialized with
          their corresponding default constructors.
        </p>
<p>
          A <span class="emphasis"><em>declaration</em></span> can contain an <span class="emphasis"><em>initializer</em></span>,
          which specifies the object's initial value. The initializer can be just
          '()', which states that the object shall be value-initialized (but see
          below). However, if a <span class="emphasis"><em>declaration</em></span> has no <span class="emphasis"><em>initializer</em></span>
          and it is of a non-<code class="computeroutput"><span class="keyword">const</span></code>,
          non-<code class="computeroutput"><span class="keyword">static</span></code> POD type, the initial
          value is indeterminate: (see &amp;sect;8.5, [dcl.init], for the accurate
          definitions).
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">x</span><span class="special">;</span> <span class="comment">// no initializer. x value is indeterminate.</span>
<a href="https://en.cppreference.com/w/cpp/string/basic_string" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code></a> <span class="identifier">s</span><span class="special">;</span> <span class="comment">// no initializer, s is default-constructed.</span>

<span class="keyword">int</span> <span class="identifier">y</span> <span class="special">=</span> <span class="keyword">int</span><span class="special">();</span>
<span class="comment">// y is initialized using copy-initialization</span>
<span class="comment">// but the temporary uses an empty set of parentheses as the initializer,</span>
<span class="comment">// so it is default-constructed.</span>
<span class="comment">// A default constructed POD type is zero-initialized,</span>
<span class="comment">// therefore, y == 0.</span>

<span class="keyword">void</span> <span class="identifier">foo</span> <span class="special">(</span> <a href="https://en.cppreference.com/w/cpp/string/basic_string" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code></a> <span class="special">)</span> <span class="special">;</span>
<span class="identifier">foo</span> <span class="special">(</span> <a href="https://en.cppreference.com/w/cpp/string/basic_string" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code></a><span class="special">()</span> <span class="special">)</span> <span class="special">;</span>
<span class="comment">// the temporary string is default constructed</span>
<span class="comment">// as indicated by the initializer ()</span>
</pre>
<a name="sec:valueinit"></a><h6>
<a name="utility.utilities.value_init.details.h0"></a>
          <span class="phrase"><a name="utility.utilities.value_init.details.value_initialization"></a></span><a class="link" href="value_init.html#utility.utilities.value_init.details.value_initialization">value-initialization</a>
        </h6>
<p>
          The first <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html" target="_top">Technical
          Corrigendum for the C++ Standard</a> (TC1), whose draft was released
          to the public in November 2001, introduced <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#178" target="_top">Core
          Issue 178</a>, among many other issues.
        </p>
<p>
          That issue introduced the new concept of <code class="computeroutput"><span class="identifier">value</span><span class="special">-</span><span class="identifier">initialization</span></code>,
          and also fixed the wording for zero-initialization. Informally, value-initialization
          is similar to default-initialization with the exception that in some cases
          non-static data members and base class sub-objects are also value-initialized.
        </p>
<p>
          The difference is that an object that is value-initialized will not have,
          or at least is less likely to have, indeterminate values for data members
          and base class sub-objects; unlike the case of an object default constructed
          (see Core Issue 178 for a normative description).
        </p>
<p>
          In order to specify value-initialization of an object we need to use the
          empty-set initializer: <code class="computeroutput"><span class="special">()</span></code>.
        </p>
<p>
          As before, a declaration with no initializer specifies default-initialization,
          and a declaration with a non-empty initializer specifies copy (<code class="computeroutput"><span class="special">=</span><span class="identifier">xxx</span></code>)
          or direct (<code class="computeroutput"><span class="identifier">xxx</span></code>) initialization.
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">eat</span><span class="special">(</span><span class="identifier">T</span><span class="special">);</span>

<span class="keyword">int</span> <span class="identifier">x</span> <span class="special">;</span> <span class="comment">// indeterminate initial value.</span>

<a href="https://en.cppreference.com/w/cpp/string/basic_string" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code></a> <span class="identifier">s</span><span class="special">;</span> <span class="comment">// default-initialized.</span>

<span class="identifier">eat</span> <span class="special">(</span> <span class="keyword">int</span><span class="special">()</span> <span class="special">)</span> <span class="special">;</span> <span class="comment">// value-initialized</span>

<span class="identifier">eat</span> <span class="special">(</span> <a href="https://en.cppreference.com/w/cpp/string/basic_string" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code></a><span class="special">()</span> <span class="special">)</span> <span class="special">;</span> <span class="comment">// value-initialized</span>
</pre>
<a name="sec:valueinitsyn"></a><h6>
<a name="utility.utilities.value_init.details.h1"></a>
          <span class="phrase"><a name="utility.utilities.value_init.details.value_initialization_syntax"></a></span><a class="link" href="value_init.html#utility.utilities.value_init.details.value_initialization_syntax">value-initialization
          syntax</a>
        </h6>
<p>
          Value initialization is specified using <code class="computeroutput"><span class="special">()</span></code>.
          However, the empty set of parentheses is not permitted by the syntax of
          initializers because it is parsed as the declaration of a function taking
          no arguments:
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">x</span><span class="special">()</span> <span class="special">;</span> <span class="comment">// declares function int(*)()</span>
</pre>
<p>
          Thus, the empty <code class="computeroutput"><span class="special">()</span></code> must be
          put in some other initialization context.
        </p>
<p>
          One alternative is to use copy-initialization syntax:
        </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">x</span> <span class="special">=</span> <span class="keyword">int</span><span class="special">();</span>
</pre>
<p>
          This works perfectly fine for POD types. But for non-POD class types, copy-initialization
          searches for a suitable constructor, which could be, for instance, the
          copy-constructor. It also searches for a suitable conversion sequence but
          this does not apply in this context.
        </p>
<p>
          For an arbitrary unknown type, using this syntax may not have the value-initialization
          effect intended because we don't know if a copy from a default constructed
          object is exactly the same as a default constructed object, and the compiler
          is allowed, in some cases, but never required to, optimize the copy away.
        </p>
<p>
          One possible generic solution is to use value-initialization of a non static
          data member:
        </p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">W</span>
<span class="special">{</span>
    <span class="comment">// value-initialization of 'data' here.</span>
    <span class="identifier">W</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">data</span><span class="special">()</span> <span class="special">{}</span>

    <span class="identifier">T</span> <span class="identifier">data</span><span class="special">;</span>
<span class="special">};</span>

<span class="identifier">W</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">w</span><span class="special">;</span>
<span class="comment">// w.data is value-initialized for any type.</span>
</pre>
<p>
          This is the solution as it was supplied by earlier versions of the <code class="computeroutput"><a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> template class. Unfortunately this
          approach suffered from various compiler issues.
        </p>
<a name="sec:compiler_issues"></a><h6>
<a name="utility.utilities.value_init.details.h2"></a>
          <span class="phrase"><a name="utility.utilities.value_init.details.compiler_issues"></a></span><a class="link" href="value_init.html#utility.utilities.value_init.details.compiler_issues">Compiler
          issues</a>
        </h6>
<p>
          Various compilers have not yet fully implemented value-initialization.
          So when an object should be <span class="emphasis"><em>value-initialized</em></span> according
          to the C++ Standard, it <span class="emphasis"><em>may</em></span> in practice still be left
          uninitialized, because of those compiler issues. It is hard to make a general
          statement on what those issues are like, because they depend on the compiler
          you are using, its version number, and the type of object you would like
          to have value-initialized.
        </p>
<p>
          All compilers we have tested so far support value-initialization for arithmetic
          types properly. However, various compilers may leave some types of <span class="emphasis"><em>aggregates</em></span>
          uninitialized, when they should be value-initialized. Value-initialization
          of objects of a pointer-to-member type may also go wrong on various compilers.
        </p>
<p>
          At the moment of writing, May 2010, the following reported issues regarding
          value-initialization are still there in current compiler releases:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <a href="https://connect.microsoft.com/VisualStudio/feedback/details/100744" target="_top">Microsoft
              Visual Studio Feedback ID 100744, Value-initialization in new-expression</a>:
              Reported by Pavel Kuznetsov (MetaCommunications Engineering), 2005.
            </li>
<li class="listitem">
              <a href="http://connect.microsoft.com/VisualStudio/feedback/details/484295" target="_top">Microsoft
              Visual Studio Feedback ID 484295, VC++ does not value-initialize members
              of derived classes without user-declared constructor</a> Reported
              by Sylvester Hesp, 2009.
            </li>
<li class="listitem">
              <a href="https://connect.microsoft.com/VisualStudio/feedback/details/499606" target="_top">Microsoft
              Visual Studio Feedback ID 499606, Presence of copy constructor breaks
              member class initialization</a> Reported by Alex Vakulenko, 2009
            </li>
<li class="listitem">
              <a href="http://qc.embarcadero.com/wc/qcmain.aspx?d=83751" target="_top">Embarcadero/C++Builder
              Report 83751, Value-initialization: arrays should have each element
              value-initialized</a> Reported by Niels Dekker (LKEB), 2010.
            </li>
<li class="listitem">
              <a href="http://qc.embarcadero.com/wc/qcmain.aspx?d=83851" target="_top">Embarcadero/C++Builder
              Report 83851, Value-initialized temporary triggers internal backend
              error C1798</a> Reported by Niels Dekker, 2010.
            </li>
<li class="listitem">
              <a href="http://qc.embarcadero.com/wc/qcmain.aspx?d=84279" target="_top">Embarcadero/C++Builder
              Report 84279, Internal compiler error (F1004), value-initializing member
              function pointer by "new T()"</a> Reported by Niels Dekker,
              2010
            </li>
<li class="listitem">
              Sun CR 6947016, Sun 5.10 may fail to value-initialize an object of
              a non-POD aggregate. Reported to Steve Clamage by Niels Dekker, 2010.
            </li>
<li class="listitem">
              IBM's XL V10.1 and V11.1 may fail to value-initialize a temporary of
              a non-POD aggregate. Reported to Michael Wong by Niels Dekker, 2010.
            </li>
<li class="listitem">
              Intel support issue 589832, Attempt to value-initialize pointer-to-member
              triggers internal error on Intel 11.1. Reported by John Maddock, 2010.
            </li>
</ul></div>
<p>
          Note that all known GCC issues regarding value-initialization are fixed
          with GCC version 4.4, including <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=30111" target="_top">GCC
          Bug 30111</a>. Clang also has completely implemented value-initialization,
          as far as we know, now that <a href="http://llvm.org/bugs/show_bug.cgi?id=7139" target="_top">Clang
          Bug 7139</a> is fixed.
        </p>
<p>
          New versions of <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a>
          (Boost release version 1.35 or higher) offer a workaround to these issues:
          <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a>
          may now clear its internal data, prior to constructing the object that
          it contains. It will do so for those compilers that need to have such a
          workaround, based on the <a href="../../../../../../doc/html/config/doc/html/boost_config/boost_macro_reference.html#boost_config.boost_macro_reference.macros_that_describe_defects" target="_top">compiler
          defect macro</a> <code class="computeroutput"><span class="identifier">BOOST_NO_COMPLETE_VALUE_INITIALIZATION</span></code>.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="utility.utilities.value_init.types_and_objects"></a><a name="sec:types"></a><a class="link" href="value_init.html#utility.utilities.value_init.types_and_objects" title="Types and objects">Types
        and objects</a>
</h4></div></div></div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="utility.utilities.value_init.types_and_objects.template_class_value_initialized"></a><a name="sec:val_init"></a><a class="link" href="value_init.html#utility.utilities.value_init.types_and_objects.template_class_value_initialized" title="template class value_initialized&lt;T&gt;"><code class="computeroutput"><span class="keyword">template</span> <span class="keyword">class</span>
          <span class="identifier">value_initialized</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a>
<span class="special">{</span>

  <span class="keyword">public</span> <span class="special">:</span>

    <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">()</span> <span class="special">:</span> <span class="identifier">x</span><span class="special">()</span> <span class="special">{}</span>

    <span class="keyword">operator</span> <span class="identifier">T</span> <span class="keyword">const</span> <span class="special">&amp;()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">x</span> <span class="special">;</span> <span class="special">}</span>

    <span class="keyword">operator</span> <span class="identifier">T</span><span class="special">&amp;()</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">x</span> <span class="special">;</span> <span class="special">}</span>

    <span class="identifier">T</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">data</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">x</span> <span class="special">;</span> <span class="special">}</span>

    <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">data</span><span class="special">()</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">x</span> <span class="special">;</span> <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&amp;</span> <span class="special">);</span>

  <span class="keyword">private</span> <span class="special">:</span>

    <span class="special">[</span><span class="identifier">unspecified</span><span class="special">]</span> <span class="identifier">x</span> <span class="special">;</span>

<span class="special">}</span> <span class="special">;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>

<span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">get</span> <span class="special">(</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">x</span> <span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">data</span><span class="special">();</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span> <span class="special">(</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span> <span class="special">)</span>
<span class="special">{</span>
  <span class="keyword">return</span> <span class="identifier">x</span><span class="special">.</span><span class="identifier">data</span><span class="special">();</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span> <span class="special">(</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&amp;</span> <span class="identifier">lhs</span><span class="special">,</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&amp;</span> <span class="identifier">rhs</span> <span class="special">)</span>
<span class="special">{</span>
  <span class="identifier">lhs</span><span class="special">.</span><span class="identifier">swap</span><span class="special">(</span><span class="identifier">rhs</span><span class="special">);</span>
<span class="special">}</span>

<span class="special">}</span> <span class="comment">// namespace boost</span>
</pre>
<p>
            An object of this template class is a <code class="computeroutput"><span class="identifier">T</span></code>-wrapper
            convertible to <code class="computeroutput"><span class="char">'T&amp;'</span></code> whose
            wrapped object (data member of type <code class="computeroutput"><span class="identifier">T</span></code>)
            is <a class="link" href="value_init.html#sec:valueinit">value-initialized</a> upon default-initialization
            of this wrapper class:
          </p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">zero</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">x</span><span class="special">;</span>
<span class="identifier">assert</span><span class="special">(</span> <span class="identifier">x</span> <span class="special">==</span> <span class="identifier">zero</span> <span class="special">)</span> <span class="special">;</span>

<a href="https://en.cppreference.com/w/cpp/string/basic_string" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code></a> <span class="identifier">def</span><span class="special">;</span>
<a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span> <a href="https://en.cppreference.com/w/cpp/string/basic_string" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code></a> <span class="special">&gt;</span> <span class="identifier">y</span><span class="special">;</span>
<span class="identifier">assert</span><span class="special">(</span> <span class="identifier">y</span> <span class="special">==</span> <span class="identifier">def</span> <span class="special">)</span> <span class="special">;</span>
</pre>
<p>
            The purpose of this wrapper is to provide a consistent syntax for value
            initialization of scalar, union and class types (POD and non-POD) since
            the correct syntax for value initialization varies (see <a class="link" href="value_init.html#sec:valueinitsyn">value-initialization
            syntax</a>).
          </p>
<p>
            The wrapped object can be accessed either through the conversion operator
            <code class="computeroutput"><span class="identifier">T</span><span class="special">&amp;</span></code>,
            the member function <code class="computeroutput"><span class="identifier">data</span><span class="special">()</span></code>, or the non-member function <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code>:
          </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">watch</span><span class="special">(</span><span class="keyword">int</span><span class="special">);</span>

<a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">x</span><span class="special">;</span>

<span class="identifier">watch</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span> <span class="special">;</span> <span class="comment">// operator T&amp; used.</span>
<span class="identifier">watch</span><span class="special">(</span><span class="identifier">x</span><span class="special">.</span><span class="identifier">data</span><span class="special">());</span>
<span class="identifier">watch</span><span class="special">(</span> <span class="identifier">get</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span> <span class="special">)</span> <span class="comment">// function get() used</span>
</pre>
<p>
            Both <code class="computeroutput"><span class="keyword">const</span></code> and non-<code class="computeroutput"><span class="keyword">const</span></code> objects can be wrapped. Mutable
            objects can be modified directly from within the wrapper but constant
            objects cannot:
          </p>
<p>
            When <code class="computeroutput"><span class="identifier">T</span></code> is a <a href="https://en.cppreference.com/w/cpp/named_req/Swappable" target="_top"><span class="emphasis"><em>Swappable</em></span></a>
            type, <code class="computeroutput"><a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> is swappable as well, by calling
            its <code class="computeroutput"><span class="identifier">swap</span></code> member function
            as well as by calling <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">swap</span></code>.
          </p>
<pre class="programlisting"><a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">x</span><span class="special">;</span>
<span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&amp;&gt;(</span><span class="identifier">x</span><span class="special">)</span> <span class="special">=</span> <span class="number">1</span> <span class="special">;</span> <span class="comment">// OK</span>
<span class="identifier">get</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span> <span class="special">=</span> <span class="number">1</span> <span class="special">;</span> <span class="comment">// OK</span>

<a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="keyword">int</span> <span class="keyword">const</span><span class="special">&gt;</span> <span class="identifier">y</span> <span class="special">;</span>
<span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&amp;&gt;(</span><span class="identifier">y</span><span class="special">)</span> <span class="special">=</span> <span class="number">1</span> <span class="special">;</span> <span class="comment">// ERROR: cannot cast to int&amp;</span>
<span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="keyword">const</span><span class="special">&amp;&gt;(</span><span class="identifier">y</span><span class="special">)</span> <span class="special">=</span> <span class="number">1</span> <span class="special">;</span> <span class="comment">// ERROR: cannot modify a const value</span>
<span class="identifier">get</span><span class="special">(</span><span class="identifier">y</span><span class="special">)</span> <span class="special">=</span> <span class="number">1</span> <span class="special">;</span> <span class="comment">// ERROR: cannot modify a const value</span>
</pre>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top">
<p>
              The <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a>
              implementation of Boost version 1.40.0 and older allowed <span class="emphasis"><em>non-const</em></span>
              access to the wrapped object, from a constant wrapper, both by its
              conversion operator and its <code class="computeroutput"><span class="identifier">data</span><span class="special">()</span></code> member function.
            </p>
<p>
              For example:
            </p>
<pre class="programlisting"><a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">x_c</span><span class="special">;</span>
<span class="keyword">int</span><span class="special">&amp;</span> <span class="identifier">xr</span> <span class="special">=</span> <span class="identifier">x_c</span> <span class="special">;</span> <span class="comment">// OK, conversion to int&amp; available even though x_c is itself const.</span>
<span class="identifier">xr</span> <span class="special">=</span> <span class="number">2</span> <span class="special">;</span>
</pre>
<p>
              The reason for this obscure behavior was that some compilers did not
              accept the following valid code:
            </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">X</span>
<span class="special">{</span>
  <span class="keyword">operator</span> <span class="keyword">int</span><span class="special">&amp;()</span> <span class="special">;</span>
    <span class="keyword">operator</span> <span class="keyword">int</span> <span class="keyword">const</span><span class="special">&amp;()</span> <span class="keyword">const</span> <span class="special">;</span>
  <span class="special">};</span>
  <span class="identifier">X</span> <span class="identifier">x</span> <span class="special">;</span>
  <span class="special">(</span><span class="identifier">x</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span> <span class="special">;</span> <span class="comment">// ERROR HERE!</span>
</pre>
<p>
              The current version of <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a> no longer
              has this obscure behavior. As compilers nowadays widely support overloading
              the conversion operator by having a <code class="computeroutput"><span class="keyword">const</span></code>
              and a <code class="computeroutput"><span class="identifier">non</span><span class="special">-</span><span class="keyword">const</span></code> version, we have decided to fix
              the issue accordingly. So the current version supports the idea of
              logical constness.
            </p>
</td></tr>
</table></div>
<h6>
<a name="utility.utilities.value_init.types_and_objects.template_class_value_initialized.h0"></a>
            <span class="phrase"><a name="utility.utilities.value_init.types_and_objects.template_class_value_initialized.recommended_practice_the_non_mem"></a></span><a class="link" href="value_init.html#utility.utilities.value_init.types_and_objects.template_class_value_initialized.recommended_practice_the_non_mem">Recommended
            practice: The non-member get() idiom</a>
          </h6>
<p>
            The obscure behavior of being able to modify a non-<code class="computeroutput"><span class="keyword">const</span></code>
            wrapped object from within a constant wrapper (as was supported by previous
            versions of <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a>)
            can be avoided if access to the wrapped object is always performed with
            the <code class="computeroutput"><span class="identifier">get</span><span class="special">()</span></code>
            idiom:
          </p>
<pre class="programlisting"><span class="identifier">value_initialized</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">x</span><span class="special">;</span>
<span class="identifier">get</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span> <span class="comment">// OK</span>
<span class="identifier">value_initialized</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="keyword">const</span><span class="special">&gt;</span> <span class="identifier">cx</span><span class="special">;</span>
<span class="identifier">get</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span> <span class="comment">// ERROR: Cannot modify a const object</span>

<span class="identifier">value_initialized</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">x_c</span><span class="special">;</span>
<span class="identifier">get</span><span class="special">(</span><span class="identifier">x_c</span><span class="special">)</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span> <span class="comment">// ERROR: Cannot modify a const object</span>

<span class="identifier">value_initialized</span><span class="special">&lt;</span><span class="keyword">int</span> <span class="keyword">const</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">cx_c</span><span class="special">;</span>
<span class="identifier">get</span><span class="special">(</span><span class="identifier">cx_c</span><span class="special">)</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span> <span class="comment">// ERROR: Cannot modify a const object</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="utility.utilities.value_init.types_and_objects.template_class_initialized_t"></a><a name="sec:initialized"></a><a class="link" href="value_init.html#utility.utilities.value_init.types_and_objects.template_class_initialized_t" title="template class initialized&lt;T&gt;"><code class="computeroutput"><span class="keyword">template</span> <span class="keyword">class</span>
          <span class="identifier">initialized</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a>
<span class="special">{</span>

  <span class="keyword">public</span> <span class="special">:</span>

    <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a><span class="special">()</span> <span class="special">:</span> <span class="identifier">x</span><span class="special">()</span> <span class="special">{}</span>

    <span class="keyword">explicit</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">arg</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">x</span><span class="special">(</span><span class="identifier">arg</span><span class="special">)</span> <span class="special">{}</span>

    <span class="keyword">operator</span> <span class="identifier">T</span> <span class="keyword">const</span> <span class="special">&amp;()</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">operator</span> <span class="identifier">T</span><span class="special">&amp;();</span>

    <span class="identifier">T</span> <span class="keyword">const</span> <span class="special">&amp;</span><span class="identifier">data</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">data</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">swap</span><span class="special">(</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a><span class="special">&amp;</span> <span class="special">);</span>

  <span class="keyword">private</span> <span class="special">:</span>

    <span class="special">[</span><span class="identifier">unspecified</span><span class="special">]</span> <span class="identifier">x</span> <span class="special">;</span>

<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">get</span> <span class="special">(</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">x</span> <span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">get</span> <span class="special">(</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&amp;</span> <span class="identifier">x</span> <span class="special">);</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">swap</span> <span class="special">(</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&amp;</span> <span class="identifier">lhs</span><span class="special">,</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&amp;</span> <span class="identifier">rhs</span> <span class="special">);</span>

<span class="special">}</span> <span class="comment">// namespace boost</span>
</pre>
<p>
            The template class <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
            supports both value-initialization and direct-initialization, so its
            interface is a superset of the interface of <code class="computeroutput"><a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>:
            Its default-constructor value-initializes the wrapped object just like
            the default-constructor of <code class="computeroutput"><a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>,
            but <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> also offers an extra <code class="computeroutput"><span class="keyword">explicit</span></code> constructor, which direct-initializes
            the wrapped object by the specified value.
          </p>
<p>
            <code class="computeroutput"><a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> is especially useful when the wrapped
            object must be either value-initialized or direct-initialized, depending
            on runtime conditions. For example, <code class="computeroutput"><a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
            could hold the value of a data member that may be value-initialized by
            some constructors, and direct-initialized by others.
          </p>
<p>
            On the other hand, if it is known beforehand that the object must <span class="emphasis"><em>always</em></span>
            be value-initialized, <code class="computeroutput"><a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
            may be preferable. And if the object must always be direct-initialized,
            none of the two wrappers really needs to be used.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="utility.utilities.value_init.types_and_objects.initialized_value"></a><a name="sec:initialized_value"></a><a class="link" href="value_init.html#utility.utilities.value_init.types_and_objects.initialized_value" title="initialized_value"><code class="computeroutput"><span class="identifier">initialized_value</span></code></a>
</h5></div></div></div>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
<span class="keyword">class</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized_value_t</span></code></a>
<span class="special">{</span>
  <span class="keyword">public</span> <span class="special">:</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">operator</span> <span class="identifier">T</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">;</span>
<span class="special">};</span>

<a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized_value_t</span></code></a> <span class="keyword">const</span> <span class="identifier">initialized_value</span> <span class="special">=</span> <span class="special">{}</span> <span class="special">;</span>

<span class="special">}</span> <span class="comment">// namespace boost</span>
</pre>
<p>
            <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized_value</span></code></a>
            provides a convenient way to get an initialized value: its conversion
            operator provides an appropriate <span class="emphasis"><em>value-initialized</em></span>
            object for any <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible" target="_top"><span class="emphasis"><em>CopyConstructible</em></span></a>
            type.
          </p>
<p>
            Suppose you need to have an initialized variable of type <code class="computeroutput"><span class="identifier">T</span></code>. You could do it as follows:
          </p>
<pre class="programlisting"><span class="identifier">T</span> <span class="identifier">var</span> <span class="special">=</span> <span class="identifier">T</span><span class="special">();</span>
</pre>
<p>
            But as mentioned before, this form suffers from various compiler issues.
            The template <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a>
            offers a workaround:
          </p>
<pre class="programlisting"><span class="identifier">T</span> <span class="identifier">var</span> <span class="special">=</span> <span class="identifier">get</span><span class="special">(</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;()</span> <span class="special">);</span>
</pre>
<p>
            Unfortunately both forms repeat the type name, which is rather short
            now (<code class="computeroutput"><span class="identifier">T</span></code>), but could of
            course be more like <code class="computeroutput"><span class="identifier">Namespace</span><span class="special">::</span><span class="identifier">Template</span><span class="special">&lt;</span><span class="identifier">Arg</span><span class="special">&gt;::</span><span class="identifier">Type</span></code>.
          </p>
<p>
            Instead, one could use <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized_value</span></code></a> as follows:
          </p>
<pre class="programlisting"><span class="identifier">T</span> <span class="identifier">var</span> <span class="special">=</span> <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized_value</span></code></a><span class="special">;</span>
</pre>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="utility.utilities.value_init.references"></a><a name="sec:references"></a><a class="link" href="value_init.html#utility.utilities.value_init.references" title="References">References</a>
</h4></div></div></div>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
              Bjarne Stroustrup, Gabriel Dos Reis, and J. Stephen Adamczyk wrote
              various papers, proposing to extend the support for brace-enclosed
              <span class="emphasis"><em>initializer lists</em></span> in C++. This <a href="https://en.cppreference.com/w/cpp/language/list_initialization" target="_top">feature</a>
              has now been available since C++11. This would allow a variable <code class="computeroutput"><span class="identifier">var</span></code> of any <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible" target="_top"><span class="emphasis"><em>DefaultConstructible</em></span></a>
              type <code class="computeroutput"><span class="identifier">T</span></code> to be <span class="emphasis"><em>value-initialized</em></span>
              by doing <code class="computeroutput"><span class="identifier">T</span> <span class="identifier">var</span>
              <span class="special">=</span> <span class="special">{}</span></code>.
              The papers are listed at Bjarne's web page, <a href="http://www.research.att.com/~bs/WG21.html" target="_top">My
              C++ Standards committee papers</a>.
            </li>
<li class="listitem">
              Scott Meyers, Effective C++, Third Edition, item 6, <span class="emphasis"><em>Explicitly
              disallow the use of compiler-generated functions you do not want</em></span>,
              <a href="http://www.aristeia.com/books.html" target="_top">Scott Meyers: Books
              and CDs</a>
            </li>
<li class="listitem">
              The C++ Standard, Second edition (2003), ISO/IEC 14882:2003
            </li>
<li class="listitem">
              POD stands for "Plain Old Data"
            </li>
</ol></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title">
<a name="value_init.reference"></a>Reference</h4></div></div></div></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="utility.utilities.value_init.acknowledgements"></a><a name="sec:acknowledgements"></a><a class="link" href="value_init.html#utility.utilities.value_init.acknowledgements" title="Acknowledgements">Acknowledgements</a>
</h4></div></div></div>
<p>
          <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a>
          was developed by Fernando Cacciola, with help and suggestions from David
          Abrahams and Darin Adler.
        </p>
<p>
          Special thanks to Bjorn Karlsson who carefully edited and completed this
          documentation.
        </p>
<p>
          <a class="link" href="../../"><code class="computeroutput"><span class="identifier">value_initialized</span></code></a>
          was reimplemented by Fernando Cacciola and Niels Dekker for Boost release
          version 1.35 (2008), offering a workaround to various compiler issues.
        </p>
<p>
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized</span></code></a></code>
          was very much inspired by feedback from Edward Diener and Jeffrey Hellrung.
        </p>
<p>
          <a class="link" href="../../"><code class="computeroutput"><span class="identifier">initialized_value</span></code></a>
          was written by Niels Dekker, and added to Boost release version 1.36 (2008).
        </p>
<p>
          Developed by <a href="mailto:fernando_cacciola%40hotmail.com" target="_top">Fernando
          Cacciola</a>. The latest version of this file can be found at <a href="http://www.boost.org" target="_top">www.boost.org</a>.
        </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2001 Beman Dawes<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="string_view.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../utilities.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../utilities0.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
