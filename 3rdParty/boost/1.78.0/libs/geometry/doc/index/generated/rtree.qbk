[/ Generated by doxygen_xml2qbk 1.1.1, don't change, will be overwritten automatically]
[/ Generated from xml/classboost_1_1geometry_1_1index_1_1rtree.xml]
[#classboost_1_1geometry_1_1index_1_1rtree]
[section boost::geometry::index::rtree]

'''<indexterm><primary>boost</primary></indexterm><indexterm><primary>geometry</primary></indexterm><indexterm><primary>index</primary></indexterm><indexterm><primary>rtree</primary></indexterm>'''
The R-tree spatial index. 

[heading Description]
This is self-balancing spatial index capable to store various types of Values and balancing algorithms.

[heading Parameters]
The user must pass a type defining the Parameters which will be used in rtree creation process. This type is used e.g. to specify balancing algorithm with specific parameters like min and max number of elements in node.




Predefined algorithms with compile-time parameters are: 

* [^[link structboost_1_1geometry_1_1index_1_1linear boost::geometry::index::linear]], 
* [^[link structboost_1_1geometry_1_1index_1_1quadratic boost::geometry::index::quadratic]], 
* [^[link structboost_1_1geometry_1_1index_1_1rstar boost::geometry::index::rstar]].






Predefined algorithms with run-time parameters are: 

* [^[link classboost_1_1geometry_1_1index_1_1dynamic__linear boost::geometry::index::dynamic_linear]], 
* [^[link classboost_1_1geometry_1_1index_1_1dynamic__quadratic boost::geometry::index::dynamic_quadratic]], 
* [^[link classboost_1_1geometry_1_1index_1_1dynamic__rstar boost::geometry::index::dynamic_rstar]].



[heading IndexableGetter]
The object of IndexableGetter type translates from Value to Indexable each time r-tree requires it. This means that this operation is done for each Value access. Therefore the IndexableGetter should return the Indexable by a reference type. The Indexable should not be calculated since it could harm the performance. The default IndexableGetter can translate all types adapted to Point, Box or Segment concepts (called Indexables). Furthermore, it can handle [^`std::pair<Indexable, T>`], [^`std::tuple<Indexable, ...>`] and [^`boost::tuple<Indexable, ...>`]. For example, for Value of type [^`std::pair<Box, int>`], the default IndexableGetter translates from [^`std::pair<Box, int> const&`] to [^`Box const&`].

[heading EqualTo]
The object of EqualTo type compares Values and returns [^`true`] if they are equal. It's similar to [^`std::equal_to<>`]. The default EqualTo returns the result of [^`boost::geometry::equals()`] for types adapted to some Geometry concept defined in Boost.Geometry and the result of [^`operator==`] for other types. Components of Pairs and Tuples are compared left-to-right.

[heading Header]
`#include <boost/geometry/index/rtree.hpp>`

[heading Synopsis]
[pre
`template<``typename Value``,`
         `typename Parameters``,`
         `typename IndexableGetter` = [^[link structboost_1_1geometry_1_1index_1_1indexable index::indexable]]`<Value>``,`
         `typename EqualTo` = [^[link structboost_1_1geometry_1_1index_1_1equal__to index::equal_to]]`<Value>``,`
         `typename Allocator` = `boost::container::new_allocator<Value>``>`
`class rtree`
`{`
`  // ...`
`};`
]

[heading Template parameter(s)]
[table
[[Parameter] [Description]]
[[`Value`][The type of objects stored in the container. ]]
[[`Parameters`][Compile-time parameters. ]]
[[`IndexableGetter`][The function object extracting Indexable from Value. ]]
[[`EqualTo`][The function object comparing objects of type Value. ]]
[[`Allocator`][The allocator used to allocate/deallocate memory, construct/destroy nodes and Values. ]]
]

[heading Typedef(s)]
[table
[[Type] [Description]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1a5761a41d87b93d4fd548ecb6600ae757] `value_type`][The type of Value stored in the container. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17] `parameters_type`][R-tree parameters type. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5] `indexable_getter`][The function object extracting Indexable from Value. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b] `value_equal`][The function object comparing objects of type Value. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e] `allocator_type`][The type of allocator used by the container. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1a28e88e55d260a454688fe1bd5e5af96b] `indexable_type`][The Indexable type to which Value is translated. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1a12e80f9da4c68e0e687f1c2012321147] `bounds_type`][The Box type used by the R-tree. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1a5301c3d7ee3589751579e0573a9e8165] `reference`][Type of reference to Value. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1a615e622930be97ab1f3b8ceee641feaf] `const_reference`][Type of reference to const Value. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1a762ced6b98d2cc6503e2b00549c6a89a] `pointer`][Type of pointer to Value. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1abad30462044d5d8fb607c24a05e8c9c2] `const_pointer`][Type of pointer to const Value. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1ac256168e9371a070515fc61f29c691ed] `difference_type`][Type of difference type. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1acc1f90d7b70afebc58107c523ece5cd5] `size_type`][Unsigned integral type used by the container. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1a701f65f0d6cf2e8b7be7f1c4b8fb7fde] `const_iterator`][Type of const iterator, category ForwardIterator. ]]
[[[#classboost_1_1geometry_1_1index_1_1rtree_1ad144a7704ad878caaa84cda79b140855] `const_query_iterator`][Type of const query iterator, category ForwardIterator. ]]
]

[heading Constructor(s) and destructor]
[table
[[Function][Description]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1a55d5fd5d205df08db5267253689ccf0c `rtree()`]][The constructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1a1a6b696d4855cbf1866196fe058c3a87 `rtree(parameters_type const &, indexable_getter const &, value_equal const &, allocator_type const &)`]][The constructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1a037f17d8a1dfa4a818ff471dec61c912 `rtree(Iterator, Iterator)`]][The constructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1a7b96b715c52ddc13d7a81db344825848 `rtree(Range const &)`]][The constructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1aad1b32e82dd734747810f01ee17e464e `rtree(Iterator, Iterator, parameters_type const &, indexable_getter const &, value_equal const &, allocator_type const &, PackAlloc const &)`]][The constructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1aa2615aff643804935c530a668663807f `rtree(Range const &, parameters_type const &, indexable_getter const &, value_equal const &, allocator_type const &, PackAlloc const &)`]][The constructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1a0d5b2e4876782e6950fbbdfa60f7406b `rtree(Iterator, Iterator, allocator_type const &)`]][The constructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1a90857cba52523d5ff0e7b2a87081ccf5 `rtree(Range const &, allocator_type const &)`]][The constructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1aed5c247a23b8236b2e80867acefe55ec `rtree(Iterator, Iterator, allocator_type const &, PackAlloc const &)`]][The constructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1aceb504e98a611ef81f96b2df357d03f3 `rtree(Range const &, allocator_type const &, PackAlloc const &)`]][The constructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1af8db72811d2be53c409240204e63fb5a `~rtree()`]][The destructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1a826fc3236e181ad718d5283e95d7866f `rtree(rtree const &)`]][The copy constructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1a72b6b75e083eea2ed26f54d4a2265375 `rtree(rtree const &, allocator_type const &)`]][The copy constructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1aa8b27db8cb783282ab5274e6769da26a `rtree(rtree &&)`]][The moving constructor. ]]
[[[link classboost_1_1geometry_1_1index_1_1rtree_1a8508c4236d17ff39a1caef058aac8486 `rtree(rtree &&, allocator_type const &)`]][The moving constructor. ]]
]

[heading Member(s)]
[table
[[Modifier][Function][Description]]
[[][[link classboost_1_1geometry_1_1index_1_1rtree_1ad0db5e9e41e1553f944b7e740dbbb883 `operator=(rtree const &)`]][The assignment operator. ]]
[[][[link classboost_1_1geometry_1_1index_1_1rtree_1af0bf9622ed3e901580b73ed39b746fb7 `operator=(rtree &&)`]][The moving assignment. ]]
[[][[link classboost_1_1geometry_1_1index_1_1rtree_1aedb719dfece91d298e9ee56878524c9b `swap(rtree &)`]][Swaps contents of two rtrees. ]]
[[][[link classboost_1_1geometry_1_1index_1_1rtree_1ad47980467e66b8644df18a480dbf9d86 `insert(value_type const &)`]][Insert a value to the index. ]]
[[][[link classboost_1_1geometry_1_1index_1_1rtree_1a60d4c8790fd8810ff8b57f049e6bed8d `insert(Iterator, Iterator)`]][Insert a range of values to the index. ]]
[[][[link classboost_1_1geometry_1_1index_1_1rtree_1a5db294b14ebf1319edcfc92e78c8167e `insert(ConvertibleOrRange const &)`]][Insert a value created using convertible object or a range of values to the index. ]]
[[][[link classboost_1_1geometry_1_1index_1_1rtree_1a1ce933b0b833faec5349bfc27bde15d4 `remove(value_type const &)`]][Remove a value from the container. ]]
[[][[link classboost_1_1geometry_1_1index_1_1rtree_1aa97084231d17564a94f0142d095cecaa `remove(Iterator, Iterator)`]][Remove a range of values from the container. ]]
[[][[link classboost_1_1geometry_1_1index_1_1rtree_1a320cd1861ba7b43364ed53e1f93a4411 `remove(ConvertibleOrRange const &)`]][Remove value corresponding to an object convertible to it or a range of values from the container. ]]
[[ `const`][[link classboost_1_1geometry_1_1index_1_1rtree_1ace0ba7f3280b1074cea31b4f1bc1d7ea `query(Predicates const &, OutIter)`]][Finds values meeting passed predicates e.g. nearest to some Point and/or intersecting some Box. ]]
[[ `const`][[link classboost_1_1geometry_1_1index_1_1rtree_1a874f43d4119f552a613f051c6177b9d8 `qbegin(Predicates const &)`]][Returns a query iterator pointing at the begin of the query range. ]]
[[ `const`][[link classboost_1_1geometry_1_1index_1_1rtree_1a4950060dcd8647acbddfbeb38d453253 `qend()`]][Returns a query iterator pointing at the end of the query range. ]]
[[ `const`][[link classboost_1_1geometry_1_1index_1_1rtree_1a4efdce77c31a940642d824f3cabe2d31 `begin()`]][Returns the iterator pointing at the begin of the rtree values range. ]]
[[ `const`][[link classboost_1_1geometry_1_1index_1_1rtree_1a5c8b735055ac44dd1d354359c5a0b910 `end()`]][Returns the iterator pointing at the end of the rtree values range. ]]
[[ `const`][[link classboost_1_1geometry_1_1index_1_1rtree_1a7a7bfa3ce751e0c357c36e1bb238c523 `size()`]][Returns the number of stored values. ]]
[[ `const`][[link classboost_1_1geometry_1_1index_1_1rtree_1a18bed92ff302df192215c3809fe5272e `empty()`]][Query if the container is empty. ]]
[[][[link classboost_1_1geometry_1_1index_1_1rtree_1a1bec40977c175983f585c4488cf8fe3c `clear()`]][Removes all values stored in the container. ]]
[[ `const`][[link classboost_1_1geometry_1_1index_1_1rtree_1a2f244b24b24711dc39019198151dc2db `bounds()`]][Returns the box able to contain all values stored in the container. ]]
[[ `const`][[link classboost_1_1geometry_1_1index_1_1rtree_1a69dfe7fea7dac9513b79b9918bbf8050 `count(ValueOrIndexable const &)`]][Count Values or Indexables stored in the container. ]]
[[ `const`][[link classboost_1_1geometry_1_1index_1_1rtree_1a4968c4543d315372b4c24fc4b571c3c5 `parameters()`]][Returns parameters. ]]
[[ `const`][[link classboost_1_1geometry_1_1index_1_1rtree_1abf1759583c5ae7284dbe53e904eec455 `indexable_get()`]][Returns function retrieving Indexable from Value. ]]
[[ `const`][[link classboost_1_1geometry_1_1index_1_1rtree_1ae7d1516455b9565fbddff04db202b223 `value_eq()`]][Returns function comparing Values. ]]
[[ `const`][[link classboost_1_1geometry_1_1index_1_1rtree_1a256cfca98dba150a63fd2023934dbd1a `get_allocator()`]][Returns allocator used by the rtree. ]]
]

[#classboost_1_1geometry_1_1index_1_1rtree_1a55d5fd5d205df08db5267253689ccf0c]
[section rtree()]
'''<indexterm><primary>rtree</primary></indexterm>'''
The constructor. 

[heading Synopsis]
[pre

`rtree``(`[^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]` const &` `parameters` = [^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]`()``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]` const &` `getter` = [^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]`()``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]` const &` `equal` = [^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]`()``)`
]

[heading Modifier(s)]
``explicit ``[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]` const &`][ `parameters` ][The parameters object. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]` const &`][ `getter` ][The function object extracting Indexable from Value. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]` const &`][ `equal` ][The function object comparing Values.]]
]
[heading Throws]
If allocator default constructor throws. 

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a1a6b696d4855cbf1866196fe058c3a87]
[section:rtree_par_cr_ind_cr_val_cr_all_cr rtree(parameters_type const &, indexable_getter const &, value_equal const &, allocator_type const &)]
'''<indexterm><primary>rtree</primary></indexterm>'''
The constructor. 

[heading Synopsis]
[pre

`rtree``(`[^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]` const &` `parameters``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]` const &` `getter``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]` const &` `equal``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &` `allocator``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]` const &`][ `parameters` ][The parameters object. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]` const &`][ `getter` ][The function object extracting Indexable from Value. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]` const &`][ `equal` ][The function object comparing Values. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &`][ `allocator` ][The allocator object.]]
]
[heading Throws]
If allocator copy constructor throws. 

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a037f17d8a1dfa4a818ff471dec61c912]
[section rtree(Iterator, Iterator)]
'''<indexterm><primary>rtree</primary></indexterm>'''
The constructor. 

[heading Description]
The tree is created using packing algorithm.[heading Synopsis]
[pre
`template<``typename Iterator``>`
`rtree``(``Iterator` `first``,`
      `Iterator` `last``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]` const &` `parameters` = [^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]`()``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]` const &` `getter` = [^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]`()``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]` const &` `equal` = [^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]`()``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &` `allocator` = [^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]`()``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`Iterator`][ `first` ][The beginning of the range of Values. ]]
[[`Iterator`][ `last` ][The end of the range of Values. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]` const &`][ `parameters` ][The parameters object. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]` const &`][ `getter` ][The function object extracting Indexable from Value. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]` const &`][ `equal` ][The function object comparing Values. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &`][ `allocator` ][The allocator object.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value. 



[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a7b96b715c52ddc13d7a81db344825848]
[section rtree(Range const &)]
'''<indexterm><primary>rtree</primary></indexterm>'''
The constructor. 

[heading Description]
The tree is created using packing algorithm.[heading Synopsis]
[pre
`template<``typename Range``>`
`rtree``(``Range const &` `rng``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]` const &` `parameters` = [^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]`()``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]` const &` `getter` = [^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]`()``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]` const &` `equal` = [^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]`()``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &` `allocator` = [^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]`()``)`
]

[heading Modifier(s)]
``explicit ``[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`Range const &`][ `rng` ][The range of Values. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]` const &`][ `parameters` ][The parameters object. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]` const &`][ `getter` ][The function object extracting Indexable from Value. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]` const &`][ `equal` ][The function object comparing Values. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &`][ `allocator` ][The allocator object.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value. 



[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1aad1b32e82dd734747810f01ee17e464e]
[section:rtree_ite_ite_par_cr_ind_cr_val_cr_all_cr_pac_cr rtree(Iterator, Iterator, parameters_type const &, indexable_getter const &, value_equal const &, allocator_type const &, PackAlloc const &)]
'''<indexterm><primary>rtree</primary></indexterm>'''
The constructor. 

[heading Description]
The tree is created using packing algorithm and a temporary packing allocator.[heading Synopsis]
[pre
`template<``typename Iterator``,` `typename PackAlloc``>`
`rtree``(``Iterator` `first``,`
      `Iterator` `last``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]` const &` `parameters``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]` const &` `getter``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]` const &` `equal``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &` `allocator``,`
      `PackAlloc const &` `temp_allocator``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`Iterator`][ `first` ][The beginning of the range of Values. ]]
[[`Iterator`][ `last` ][The end of the range of Values. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]` const &`][ `parameters` ][The parameters object. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]` const &`][ `getter` ][The function object extracting Indexable from Value. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]` const &`][ `equal` ][The function object comparing Values. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &`][ `allocator` ][The allocator object for persistent data in the tree. ]]
[[`PackAlloc const &`][ `temp_allocator` ][The temporary allocator object used when packing.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value. 



[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1aa2615aff643804935c530a668663807f]
[section:rtree_ran_cr_par_cr_ind_cr_val_cr_all_cr_pac_cr rtree(Range const &, parameters_type const &, indexable_getter const &, value_equal const &, allocator_type const &, PackAlloc const &)]
'''<indexterm><primary>rtree</primary></indexterm>'''
The constructor. 

[heading Description]
The tree is created using packing algorithm and a temporary packing allocator.[heading Synopsis]
[pre
`template<``typename Range``,` `typename PackAlloc``>`
`rtree``(``Range const &` `rng``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]` const &` `parameters``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]` const &` `getter``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]` const &` `equal``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &` `allocator``,`
      `PackAlloc const &` `temp_allocator``)`
]

[heading Modifier(s)]
``explicit ``[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`Range const &`][ `rng` ][The range of Values. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]]` const &`][ `parameters` ][The parameters object. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]]` const &`][ `getter` ][The function object extracting Indexable from Value. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]]` const &`][ `equal` ][The function object comparing Values. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &`][ `allocator` ][The allocator object for persistent data in the tree. ]]
[[`PackAlloc const &`][ `temp_allocator` ][The temporary allocator object used when packing.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value. 



[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a0d5b2e4876782e6950fbbdfa60f7406b]
[section rtree(Iterator, Iterator, allocator_type const &)]
'''<indexterm><primary>rtree</primary></indexterm>'''
The constructor. 

[heading Description]
The tree is created using packing algorithm and a temporary packing allocator.[heading Synopsis]
[pre
`template<``typename Iterator``>`
`rtree``(``Iterator` `first``,`
      `Iterator` `last``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &` `allocator``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`Iterator`][ `first` ][The beginning of the range of Values. ]]
[[`Iterator`][ `last` ][The end of the range of Values. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &`][ `allocator` ][The allocator object for persistent data in the tree.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value. 



[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a90857cba52523d5ff0e7b2a87081ccf5]
[section rtree(Range const &, allocator_type const &)]
'''<indexterm><primary>rtree</primary></indexterm>'''
The constructor. 

[heading Description]
The tree is created using packing algorithm and a temporary packing allocator.[heading Synopsis]
[pre
`template<``typename Range``>`
`rtree``(``Range const &` `rng``,` [^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &` `allocator``)`
]

[heading Modifier(s)]
``explicit ``[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`Range const &`][ `rng` ][The range of Values. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &`][ `allocator` ][The allocator object for persistent data in the tree.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value. 



[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1aed5c247a23b8236b2e80867acefe55ec]
[section:rtree_ite_ite_all_cr_pac_cr rtree(Iterator, Iterator, allocator_type const &, PackAlloc const &)]
'''<indexterm><primary>rtree</primary></indexterm>'''
The constructor. 

[heading Description]
The tree is created using packing algorithm and a temporary packing allocator.[heading Synopsis]
[pre
`template<``typename Iterator``,` `typename PackAlloc``>`
`rtree``(``Iterator` `first``,`
      `Iterator` `last``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &` `allocator``,`
      `PackAlloc const &` `temp_allocator``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`Iterator`][ `first` ][The beginning of the range of Values. ]]
[[`Iterator`][ `last` ][The end of the range of Values. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &`][ `allocator` ][The allocator object for persistent data in the tree. ]]
[[`PackAlloc const &`][ `temp_allocator` ][The temporary allocator object used when packing.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value. 



[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1aceb504e98a611ef81f96b2df357d03f3]
[section:rtree_ran_cr_all_cr_pac_cr rtree(Range const &, allocator_type const &, PackAlloc const &)]
'''<indexterm><primary>rtree</primary></indexterm>'''
The constructor. 

[heading Description]
The tree is created using packing algorithm and a temporary packing allocator.[heading Synopsis]
[pre
`template<``typename Range``,` `typename PackAlloc``>`
`rtree``(``Range const &` `rng``,`
      [^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &` `allocator``,`
      `PackAlloc const &` `temp_allocator``)`
]

[heading Modifier(s)]
``explicit ``[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`Range const &`][ `rng` ][The range of Values. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &`][ `allocator` ][The allocator object for persistent data in the tree. ]]
[[`PackAlloc const &`][ `temp_allocator` ][The temporary allocator object used when packing.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value. 



[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1af8db72811d2be53c409240204e63fb5a]
[section ~rtree()]
'''<indexterm><primary>~rtree</primary></indexterm>'''
The destructor. 

[heading Synopsis]
[pre

`~rtree``()`
]

[heading Throws]
Nothing. 

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a826fc3236e181ad718d5283e95d7866f]
[section rtree(rtree const &)]
'''<indexterm><primary>rtree</primary></indexterm>'''
The copy constructor. 

[heading Description]
It uses parameters, translator and allocator from the source tree.[heading Synopsis]
[pre

`rtree``(`[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` const &` `src``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` const &`][ `src` ][The rtree which content will be copied.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor throws. 
* If allocation throws or returns invalid value. 



[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a72b6b75e083eea2ed26f54d4a2265375]
[section rtree(rtree const &, allocator_type const &)]
'''<indexterm><primary>rtree</primary></indexterm>'''
The copy constructor. 

[heading Description]
It uses Parameters and translator from the source tree.[heading Synopsis]
[pre

`rtree``(`[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` const &` `src``,` [^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &` `allocator``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` const &`][ `src` ][The rtree which content will be copied. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &`][ `allocator` ][The allocator which will be used.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor throws. 
* If allocation throws or returns invalid value. 



[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1aa8b27db8cb783282ab5274e6769da26a]
[section rtree(rtree &&)]
'''<indexterm><primary>rtree</primary></indexterm>'''
The moving constructor. 

[heading Description]
It uses parameters, translator and allocator from the source tree.[heading Synopsis]
[pre

`rtree``(`[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` &&` `src``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` &&`][ `src` ][The rtree which content will be moved.]]
]
[heading Throws]
Nothing. 

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a8508c4236d17ff39a1caef058aac8486]
[section rtree(rtree &&, allocator_type const &)]
'''<indexterm><primary>rtree</primary></indexterm>'''
The moving constructor. 

[heading Description]
It uses parameters and translator from the source tree.[heading Synopsis]
[pre

`rtree``(`[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` &&` `src``,` [^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &` `allocator``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` &&`][ `src` ][The rtree which content will be moved. ]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]]` const &`][ `allocator` ][The allocator.]]
]
[heading Throws]


* If allocator copy constructor throws. 
* If Value copy constructor throws (only if allocators aren't equal). 
* If allocation throws or returns invalid value (only if allocators aren't equal). 



[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1ad0db5e9e41e1553f944b7e740dbbb883]
[section operator=(rtree const &)]
'''<indexterm><primary>operator=</primary></indexterm>'''
The assignment operator. 

[heading Description]
It uses parameters and translator from the source tree.[heading Synopsis]
[pre

[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` &` `operator=``(`[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` const &` `src``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` const &`][ `src` ][The rtree which content will be copied.]]
]
[heading Throws]


* If Value copy constructor throws. 
* If allocation throws. 
* If allocation throws or returns invalid value. 



[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1af0bf9622ed3e901580b73ed39b746fb7]
[section operator=(rtree &&)]
'''<indexterm><primary>operator=</primary></indexterm>'''
The moving assignment. 

[heading Description]
It uses parameters and translator from the source tree.[heading Synopsis]
[pre

[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` &` `operator=``(`[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` &&` `src``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` &&`][ `src` ][The rtree which content will be moved.]]
]
[heading Throws]
Only if allocators aren't equal. 

* If Value copy constructor throws. 
* If allocation throws or returns invalid value. 



[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1aedb719dfece91d298e9ee56878524c9b]
[section swap(rtree &)]
'''<indexterm><primary>swap</primary></indexterm>'''
Swaps contents of two rtrees. 

[heading Description]
Parameters, translator and allocators are swapped as well.[heading Synopsis]
[pre

`void` `swap``(`[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` &` `other``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree rtree]]` &`][ `other` ][The rtree which content will be swapped with this rtree content.]]
]
[heading Throws]
If allocators swap throws. 

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1ad47980467e66b8644df18a480dbf9d86]
[section insert(value_type const &)]
'''<indexterm><primary>insert</primary></indexterm>'''
Insert a value to the index. 

[heading Synopsis]
[pre

`void` `insert``(`[^[link classboost_1_1geometry_1_1index_1_1rtree_1a5761a41d87b93d4fd548ecb6600ae757 value_type]]` const &` `value``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a5761a41d87b93d4fd548ecb6600ae757 value_type]]` const &`][ `value` ][The value which will be stored in the container.]]
]
[heading Throws]


* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value.



[warning This operation only guarantees that there will be no memory leaks. After an exception is thrown the R-tree may be left in an inconsistent state, elements must not be inserted or removed. Other operations are allowed however some of them may return invalid data. ]

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a60d4c8790fd8810ff8b57f049e6bed8d]
[section insert(Iterator, Iterator)]
'''<indexterm><primary>insert</primary></indexterm>'''
Insert a range of values to the index. 

[heading Synopsis]
[pre
`template<``typename Iterator``>`
`void` `insert``(``Iterator` `first``,` `Iterator` `last``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`Iterator`][ `first` ][The beginning of the range of values. ]]
[[`Iterator`][ `last` ][The end of the range of values.]]
]
[heading Throws]


* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value.



[warning This operation only guarantees that there will be no memory leaks. After an exception is thrown the R-tree may be left in an inconsistent state, elements must not be inserted or removed. Other operations are allowed however some of them may return invalid data. ]

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a5db294b14ebf1319edcfc92e78c8167e]
[section insert(ConvertibleOrRange const &)]
'''<indexterm><primary>insert</primary></indexterm>'''
Insert a value created using convertible object or a range of values to the index. 

[heading Synopsis]
[pre
`template<``typename ConvertibleOrRange``>`
`void` `insert``(``ConvertibleOrRange const &` `conv_or_rng``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`ConvertibleOrRange const &`][ `conv_or_rng` ][An object of type convertible to value_type or a range of values.]]
]
[heading Throws]


* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value.



[warning This operation only guarantees that there will be no memory leaks. After an exception is thrown the R-tree may be left in an inconsistent state, elements must not be inserted or removed. Other operations are allowed however some of them may return invalid data. ]

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a1ce933b0b833faec5349bfc27bde15d4]
[section remove(value_type const &)]
'''<indexterm><primary>remove</primary></indexterm>'''
Remove a value from the container. 

[heading Description]
In contrast to the [^`std::set`] or [^`std::map erase()`] method this method removes only one value from the container.[heading Synopsis]
[pre

[^[link classboost_1_1geometry_1_1index_1_1rtree_1acc1f90d7b70afebc58107c523ece5cd5 size_type]] `remove``(`[^[link classboost_1_1geometry_1_1index_1_1rtree_1a5761a41d87b93d4fd548ecb6600ae757 value_type]]` const &` `value``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[[^[link classboost_1_1geometry_1_1index_1_1rtree_1a5761a41d87b93d4fd548ecb6600ae757 value_type]]` const &`][ `value` ][The value which will be removed from the container.]]
]
[heading Returns]
1 if the value was removed, 0 otherwise.
[heading Throws]


* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value.



[warning This operation only guarantees that there will be no memory leaks. After an exception is thrown the R-tree may be left in an inconsistent state, elements must not be inserted or removed. Other operations are allowed however some of them may return invalid data. ]

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1aa97084231d17564a94f0142d095cecaa]
[section remove(Iterator, Iterator)]
'''<indexterm><primary>remove</primary></indexterm>'''
Remove a range of values from the container. 

[heading Description]
In contrast to the [^`std::set`] or [^`std::map erase()`] method it doesn't take iterators pointing to values stored in this container. It removes values equal to these passed as a range. Furthermore this method removes only one value for each one passed in the range, not all equal values.[heading Synopsis]
[pre
`template<``typename Iterator``>`
[^[link classboost_1_1geometry_1_1index_1_1rtree_1acc1f90d7b70afebc58107c523ece5cd5 size_type]] `remove``(``Iterator` `first``,` `Iterator` `last``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`Iterator`][ `first` ][The beginning of the range of values. ]]
[[`Iterator`][ `last` ][The end of the range of values.]]
]
[heading Returns]
The number of removed values.
[heading Throws]


* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value.



[warning This operation only guarantees that there will be no memory leaks. After an exception is thrown the R-tree may be left in an inconsistent state, elements must not be inserted or removed. Other operations are allowed however some of them may return invalid data. ]

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a320cd1861ba7b43364ed53e1f93a4411]
[section remove(ConvertibleOrRange const &)]
'''<indexterm><primary>remove</primary></indexterm>'''
Remove value corresponding to an object convertible to it or a range of values from the container. 

[heading Description]
In contrast to the [^`std::set`] or [^`std::map erase()`] method it removes values equal to these passed as a range. Furthermore, this method removes only one value for each one passed in the range, not all equal values.[heading Synopsis]
[pre
`template<``typename ConvertibleOrRange``>`
[^[link classboost_1_1geometry_1_1index_1_1rtree_1acc1f90d7b70afebc58107c523ece5cd5 size_type]] `remove``(``ConvertibleOrRange const &` `conv_or_rng``)`
]

[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`ConvertibleOrRange const &`][ `conv_or_rng` ][The object of type convertible to value_type or a range of values.]]
]
[heading Returns]
The number of removed values.
[heading Throws]


* If Value copy constructor or copy assignment throws. 
* If allocation throws or returns invalid value.



[warning This operation only guarantees that there will be no memory leaks. After an exception is thrown the R-tree may be left in an inconsistent state, elements must not be inserted or removed. Other operations are allowed however some of them may return invalid data. ]

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1ace0ba7f3280b1074cea31b4f1bc1d7ea]
[section query(Predicates const &, OutIter)]
'''<indexterm><primary>query</primary></indexterm>'''
Finds values meeting passed predicates e.g. nearest to some Point and/or intersecting some Box. 

[heading Description]
This query function performs spatial and k-nearest neighbor searches. It allows to pass a set of predicates. Values will be returned only if all predicates are met.

[*Spatial predicates]

Spatial predicates may be generated by one of the functions listed below: 

* [^[link group__predicates_1gac52a6557110425d4ece53fbd6f9ff866 boost::geometry::index::contains()]], 
* [^[link group__predicates_1ga02dbb7cca47de0b921ef96af464d9590 boost::geometry::index::covered_by()]], 
* [^[link group__predicates_1ga0e92e4a20dd19185584fe85847439108 boost::geometry::index::covers()]], 
* [^[link group__predicates_1ga0aa114ab16f40c8caeb3338adba5d6da boost::geometry::index::disjoint()]], 
* [^[link group__predicates_1ga78cb2ef221b951867c591ffb51b7d8c5 boost::geometry::index::intersects()]], 
* [^[link group__predicates_1ga4a6d33e6f61ad5bff3bdee50a972d54b boost::geometry::index::overlaps()]], 
* [^[link group__predicates_1gaabce901b82af2aab10ebbd0dda12f4d5 boost::geometry::index::within()]],


It is possible to negate spatial predicates: 

* [^`! `[link group__predicates_1gac52a6557110425d4ece53fbd6f9ff866 boost::geometry::index::contains()]], 
* [^`! `[link group__predicates_1ga02dbb7cca47de0b921ef96af464d9590 boost::geometry::index::covered_by()]], 
* [^`! `[link group__predicates_1ga0e92e4a20dd19185584fe85847439108 boost::geometry::index::covers()]], 
* [^`! `[link group__predicates_1ga0aa114ab16f40c8caeb3338adba5d6da boost::geometry::index::disjoint()]], 
* [^`! `[link group__predicates_1ga78cb2ef221b951867c591ffb51b7d8c5 boost::geometry::index::intersects()]], 
* [^`! `[link group__predicates_1ga4a6d33e6f61ad5bff3bdee50a972d54b boost::geometry::index::overlaps()]], 
* [^`! `[link group__predicates_1gaabce901b82af2aab10ebbd0dda12f4d5 boost::geometry::index::within()]]

[*Satisfies predicate]

This is a special kind of predicate which allows to pass a user-defined function or function object which checks if Value should be returned by the query. It's generated by: 

* [^[link group__predicates_1ga3213772dd3e54ad03340c2ca66b4f58c boost::geometry::index::satisfies()]].

[*Nearest predicate]

If the nearest predicate is passed a k-nearest neighbor search will be performed. This query will result in returning k values to the output iterator. Only one nearest predicate may be passed to the query. It may be generated by: 

* [^[link group__predicates_1ga476c3b5d51e60d5c8e1e743340cb2b2b boost::geometry::index::nearest()]].

[*Connecting predicates]

Predicates may be passed together connected with [^`operator&&()`].[heading Synopsis]
[pre
`template<``typename Predicates``,` `typename OutIter``>`
[^[link classboost_1_1geometry_1_1index_1_1rtree_1acc1f90d7b70afebc58107c523ece5cd5 size_type]] `query``(``Predicates const &` `predicates``,` `OutIter` `out_it``)`
]

[heading Modifier(s)]
``const ``[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`Predicates const &`][ `predicates` ][Predicates. ]]
[[`OutIter`][ `out_it` ][The output iterator, e.g. generated by std::back_inserter().]]
]
[heading Returns]
The number of values found. 
[heading Example]

``
// return elements intersecting box
tree.query(bgi::intersects(box), std::back_inserter(result));
// return elements intersecting poly but not within box
tree.query(bgi::intersects(poly) && !bgi::within(box), std::back_inserter(result));
// return elements overlapping box and meeting my_fun unary predicate
tree.query(bgi::overlaps(box) && bgi::satisfies(my_fun), std::back_inserter(result));
// return 5 elements nearest to pt and elements are intersecting box
tree.query(bgi::nearest(pt, 5) && bgi::intersects(box), std::back_inserter(result));

// For each found value do_something (it is a type of function object)
tree.query(bgi::intersects(box),
           boost::make_function_output_iterator(do_something()));

// For each value stored in the rtree do_something
// always_true is a type of function object always returning true
tree.query(bgi::satisfies(always_true()),
           boost::make_function_output_iterator(do_something()));

// C++11 (lambda expression)
tree.query(bgi::intersects(box),
           boost::make_function_output_iterator([](value_type const& val){
               // do something
           }));

// C++14 (generic lambda expression)
tree.query(bgi::intersects(box),
           boost::make_function_output_iterator([](auto const& val){
               // do something
           }));
``


[heading Throws]
If Value copy constructor or copy assignment throws. If predicates copy throws.

[warning Only one [^[link group__predicates_1ga476c3b5d51e60d5c8e1e743340cb2b2b nearest()]] predicate may be passed to the query. Passing more of them results in compile-time error.]

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a874f43d4119f552a613f051c6177b9d8]
[section qbegin(Predicates const &)]
'''<indexterm><primary>qbegin</primary></indexterm>'''
Returns a query iterator pointing at the begin of the query range. 

[heading Description]
This method returns an iterator which may be used to perform iterative queries. For the information about predicates which may be passed to this method see [link classboost_1_1geometry_1_1index_1_1rtree_1ace0ba7f3280b1074cea31b4f1bc1d7ea query()].[heading Synopsis]
[pre
`template<``typename Predicates``>`
[^[link classboost_1_1geometry_1_1index_1_1rtree_1ad144a7704ad878caaa84cda79b140855 const_query_iterator]] `qbegin``(``Predicates const &` `predicates``)`
]

[heading Modifier(s)]
``const ``[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`Predicates const &`][ `predicates` ][Predicates.]]
]
[heading Returns]
The iterator pointing at the begin of the query range. 
[heading Example]

``
for ( Rtree::const_query_iterator it = tree.qbegin(bgi::nearest(pt, 10000)) ;
      it != tree.qend() ; ++it )
{
    // do something with value
    if ( has_enough_nearest_values() )
        break;
}

// C++11 (auto)
for ( auto it = tree.qbegin(bgi::nearest(pt, 3)) ; it != tree.qend() ; ++it )
{
    // do something with value
}

// C++14 (generic lambda expression)
std::for_each(tree.qbegin(bgi::nearest(pt, 3)), tree.qend(), [](auto const& val){
    // do something with value
});
``


[heading Iterator category]
ForwardIterator

[heading Throws]
If predicates copy throws. If allocation throws.

[warning The modification of the rtree may invalidate the iterators.]

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a4950060dcd8647acbddfbeb38d453253]
[section qend()]
'''<indexterm><primary>qend</primary></indexterm>'''
Returns a query iterator pointing at the end of the query range. 

[heading Description]
This method returns an iterator which may be used to check if the query has ended.[heading Synopsis]
[pre

[^[link classboost_1_1geometry_1_1index_1_1rtree_1ad144a7704ad878caaa84cda79b140855 const_query_iterator]] `qend``()`
]

[heading Modifier(s)]
``const ``[heading Returns]
The iterator pointing at the end of the query range. 
[heading Example]

``
for ( Rtree::const_query_iterator it = tree.qbegin(bgi::nearest(pt, 10000)) ;
      it != tree.qend() ; ++it )
{
    // do something with value
    if ( has_enough_nearest_values() )
        break;
}

// C++11 (auto)
for ( auto it = tree.qbegin(bgi::nearest(pt, 3)) ; it != tree.qend() ; ++it )
{
    // do something with value
}

// C++14 (generic lambda expression)
std::for_each(tree.qbegin(bgi::nearest(pt, 3)), tree.qend(), [](auto const& val){
    // do something with value
});
``


[heading Iterator category]
ForwardIterator

[heading Throws]
Nothing

[warning The modification of the rtree may invalidate the iterators.]

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a4efdce77c31a940642d824f3cabe2d31]
[section begin()]
'''<indexterm><primary>begin</primary></indexterm>'''
Returns the iterator pointing at the begin of the rtree values range. 

[heading Description]
This method returns the iterator which may be used to iterate over all values stored in the rtree.[heading Synopsis]
[pre

[^[link classboost_1_1geometry_1_1index_1_1rtree_1a701f65f0d6cf2e8b7be7f1c4b8fb7fde const_iterator]] `begin``()`
]

[heading Modifier(s)]
``const ``[heading Returns]
The iterator pointing at the begin of the range. 
[heading Example]

``
// Copy all values into the vector
std::copy(tree.begin(), tree.end(), std::back_inserter(vec));

for ( Rtree::const_iterator it = tree.begin() ; it != tree.end() ; ++it )
{
    // do something with value
}

// C++11 (auto)
for ( auto it = tree.begin() ; it != tree.end() ; ++it )
{
    // do something with value
}

// C++14 (generic lambda expression)
std::for_each(tree.begin(), tree.end(), [](auto const& val){
    // do something with value
})
``


[heading Iterator category]
ForwardIterator

[heading Throws]
If allocation throws.

[warning The modification of the rtree may invalidate the iterators.]

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a5c8b735055ac44dd1d354359c5a0b910]
[section end()]
'''<indexterm><primary>end</primary></indexterm>'''
Returns the iterator pointing at the end of the rtree values range. 

[heading Description]
This method returns the iterator which may be compared with the iterator returned by [link classboost_1_1geometry_1_1index_1_1rtree_1a4efdce77c31a940642d824f3cabe2d31 begin()] in order to check if the iteration has ended.[heading Synopsis]
[pre

[^[link classboost_1_1geometry_1_1index_1_1rtree_1a701f65f0d6cf2e8b7be7f1c4b8fb7fde const_iterator]] `end``()`
]

[heading Modifier(s)]
``const ``[heading Returns]
The iterator pointing at the end of the range. 
[heading Example]

``
for ( Rtree::const_iterator it = tree.begin() ; it != tree.end() ; ++it )
{
    // do something with value
}

// C++11 (lambda expression)
std::for_each(tree.begin(), tree.end(), [](value_type const& val){
    // do something with value
})
``


[heading Iterator category]
ForwardIterator

[heading Throws]
Nothing.

[warning The modification of the rtree may invalidate the iterators.]

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a7a7bfa3ce751e0c357c36e1bb238c523]
[section size()]
'''<indexterm><primary>size</primary></indexterm>'''
Returns the number of stored values. 

[heading Synopsis]
[pre

[^[link classboost_1_1geometry_1_1index_1_1rtree_1acc1f90d7b70afebc58107c523ece5cd5 size_type]] `size``()`
]

[heading Modifier(s)]
``const ``[heading Returns]
The number of stored values.
[heading Throws]
Nothing. 

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a18bed92ff302df192215c3809fe5272e]
[section empty()]
'''<indexterm><primary>empty</primary></indexterm>'''
Query if the container is empty. 

[heading Synopsis]
[pre

`bool` `empty``()`
]

[heading Modifier(s)]
``const ``[heading Returns]
true if the container is empty.
[heading Throws]
Nothing. 

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a1bec40977c175983f585c4488cf8fe3c]
[section clear()]
'''<indexterm><primary>clear</primary></indexterm>'''
Removes all values stored in the container. 

[heading Synopsis]
[pre

`void` `clear``()`
]

[heading Throws]
Nothing. 

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a2f244b24b24711dc39019198151dc2db]
[section bounds()]
'''<indexterm><primary>bounds</primary></indexterm>'''
Returns the box able to contain all values stored in the container. 

[heading Description]
Returns the box able to contain all values stored in the container. If the container is empty the result of [^`geometry::assign_inverse()`] is returned.[heading Synopsis]
[pre

[^[link classboost_1_1geometry_1_1index_1_1rtree_1a12e80f9da4c68e0e687f1c2012321147 bounds_type]] `bounds``()`
]

[heading Modifier(s)]
``const ``[heading Returns]
The box able to contain all values stored in the container or an invalid box if there are no values in the container.
[heading Throws]
Nothing. 

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a69dfe7fea7dac9513b79b9918bbf8050]
[section count(ValueOrIndexable const &)]
'''<indexterm><primary>count</primary></indexterm>'''
Count Values or Indexables stored in the container. 

[heading Description]
For indexable_type it returns the number of values which indexables equals the parameter. For value_type it returns the number of values which equals the parameter.[heading Synopsis]
[pre
`template<``typename ValueOrIndexable``>`
[^[link classboost_1_1geometry_1_1index_1_1rtree_1acc1f90d7b70afebc58107c523ece5cd5 size_type]] `count``(``ValueOrIndexable const &` `vori``)`
]

[heading Modifier(s)]
``const ``[heading Parameter(s)]
[table 
[[Type][Name][Description]]
[[`ValueOrIndexable const &`][ `vori` ][The value or indexable which will be counted.]]
]
[heading Returns]
The number of values found.
[heading Throws]
Nothing. 

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a4968c4543d315372b4c24fc4b571c3c5]
[section parameters()]
'''<indexterm><primary>parameters</primary></indexterm>'''
Returns parameters. 

[heading Synopsis]
[pre

[^[link classboost_1_1geometry_1_1index_1_1rtree_1a80db5532eb59f7a809bd44ded265eb17 parameters_type]] `parameters``()`
]

[heading Modifier(s)]
``const ``[heading Returns]
The parameters object.
[heading Throws]
Nothing. 

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1abf1759583c5ae7284dbe53e904eec455]
[section indexable_get()]
'''<indexterm><primary>indexable_get</primary></indexterm>'''
Returns function retrieving Indexable from Value. 

[heading Synopsis]
[pre

[^[link classboost_1_1geometry_1_1index_1_1rtree_1a43a7adb311cafc08e23010ccb4e97fb5 indexable_getter]] `indexable_get``()`
]

[heading Modifier(s)]
``const ``[heading Returns]
The indexable_getter object.
[heading Throws]
Nothing. 

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1ae7d1516455b9565fbddff04db202b223]
[section value_eq()]
'''<indexterm><primary>value_eq</primary></indexterm>'''
Returns function comparing Values. 

[heading Synopsis]
[pre

[^[link classboost_1_1geometry_1_1index_1_1rtree_1ad8fe544de514014a1bd87ea1b881ff9b value_equal]] `value_eq``()`
]

[heading Modifier(s)]
``const ``[heading Returns]
The value_equal function.
[heading Throws]
Nothing. 

[endsect]

[#classboost_1_1geometry_1_1index_1_1rtree_1a256cfca98dba150a63fd2023934dbd1a]
[section get_allocator()]
'''<indexterm><primary>get_allocator</primary></indexterm>'''
Returns allocator used by the rtree. 

[heading Synopsis]
[pre

[^[link classboost_1_1geometry_1_1index_1_1rtree_1ab6618b5c7e88ed70533233fbac0f5b2e allocator_type]] `get_allocator``()`
]

[heading Modifier(s)]
``const ``[heading Returns]
The allocator.
[heading Throws]
If allocator copy constructor throws. 

[endsect]

[endsect]

