<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/move/adl_move_swap.hpp">
<namespace name="boost">












<function name="adl_move_swap"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="x"><paramtype>T &amp;</paramtype></parameter><parameter name="y"><paramtype>T &amp;</paramtype></parameter><description><para>Exchanges the values of a and b, using Argument Dependent Lookup (ADL) to select a specialized swap function if available. If no specialized swap function is available, std::swap is used.</para><para><emphasis role="bold">Exception</emphasis>: If T uses Boost.Move's move emulation and the compiler has no rvalue references then:</para><para><itemizedlist>
<listitem><para>If T has a <computeroutput>T::swap(T&amp;)</computeroutput> member, that member is called.</para>
</listitem><listitem><para>Otherwise a move-based swap is called, equivalent to: <computeroutput>T t(::boost::move(x)); x = ::boost::move(y); y = ::boost::move(t);</computeroutput>. </para>
</listitem></itemizedlist>
</para></description></function>
<function name="adl_move_swap_ranges"><type>ForwardIt2</type><template>
          <template-type-parameter name="ForwardIt1"/>
          <template-type-parameter name="ForwardIt2"/>
        </template><parameter name="first1"><paramtype>ForwardIt1</paramtype></parameter><parameter name="last1"><paramtype>ForwardIt1</paramtype></parameter><parameter name="first2"><paramtype>ForwardIt2</paramtype></parameter><description><para>Exchanges elements between range [first1, last1) and another range starting at first2 using boost::adl_move_swap.</para><para>Parameters: first1, last1 - the first range of elements to swap first2 - beginning of the second range of elements to swap</para><para>Type requirements:<itemizedlist>
<listitem><para>ForwardIt1, ForwardIt2 must meet the requirements of ForwardIterator.</para>
</listitem><listitem><para>The types of dereferenced ForwardIt1 and ForwardIt2 must meet the requirements of Swappable</para>
</listitem></itemizedlist>
</para><para>Return value: Iterator to the element past the last element exchanged in the range beginning with first2. </para></description></function>
<function name="adl_move_swap_ranges_backward"><type>BidirIt2</type><template>
          <template-type-parameter name="BidirIt1"/>
          <template-type-parameter name="BidirIt2"/>
        </template><parameter name="first1"><paramtype>BidirIt1</paramtype></parameter><parameter name="last1"><paramtype>BidirIt1</paramtype></parameter><parameter name="last2"><paramtype>BidirIt2</paramtype></parameter></function>
<function name="adl_move_iter_swap"><type>void</type><template>
          <template-type-parameter name="ForwardIt1"/>
          <template-type-parameter name="ForwardIt2"/>
        </template><parameter name="a"><paramtype>ForwardIt1</paramtype></parameter><parameter name="b"><paramtype>ForwardIt2</paramtype></parameter></function>



</namespace>
</header>
<header name="boost/move/algo/adaptive_merge.hpp">
<namespace name="boost">
<namespace name="movelib">




































<function name="adaptive_merge"><type>void</type><template>
          <template-type-parameter name="RandIt"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="first"><paramtype>RandIt</paramtype></parameter><parameter name="middle"><paramtype>RandIt</paramtype></parameter><parameter name="last"><paramtype>RandIt</paramtype></parameter><parameter name="comp"><paramtype>Compare</paramtype></parameter><parameter name="uninitialized"><paramtype>typename iterator_traits&lt; RandIt &gt;::value_type *</paramtype><default>0</default></parameter><parameter name="uninitialized_len"><paramtype>typename iterator_traits&lt; RandIt &gt;::size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last) according to the given comparison function comp. The algorithm is stable (if there are equivalent elements in the original two ranges, the elements from the first range (preserving their original order) precede the elements from the second range (preserving their original order).</para><para><emphasis role="bold">Requires</emphasis>:<itemizedlist>
<listitem><para>RandIt must meet the requirements of ValueSwappable and RandomAccessIterator.</para>
</listitem><listitem><para>The type of dereferenced RandIt must meet the requirements of MoveAssignable and MoveConstructible.</para>
</listitem></itemizedlist>
</para><para><emphasis role="bold">Parameters</emphasis>:<itemizedlist>
<listitem><para>first: the beginning of the first sorted range.</para>
</listitem><listitem><para>middle: the end of the first sorted range and the beginning of the second</para>
</listitem><listitem><para>last: the end of the second sorted range</para>
</listitem><listitem><para>comp: comparison function object which returns true if the first argument is is ordered before the second.</para>
</listitem><listitem><para>uninitialized, uninitialized_len: raw storage starting on "uninitialized", able to hold "uninitialized_len" elements of type iterator_traits&lt;RandIt&gt;::value_type. Maximum performance is achieved when uninitialized_len is min(std::distance(first, middle), std::distance(middle, last)).</para>
</listitem></itemizedlist>
</para><para><emphasis role="bold">Throws</emphasis>: If comp throws or the move constructor, move assignment or swap of the type of dereferenced RandIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Always K x O(N) comparisons and move assignments/constructors/swaps. Constant factor for comparisons and data movement is minimized when uninitialized_len is min(std::distance(first, middle), std::distance(middle, last)). Pretty good enough performance is achieved when uninitialized_len is ceil(sqrt(std::distance(first, last)))*2.</para><para><emphasis role="bold">Caution</emphasis>: Experimental implementation, not production-ready. </para></description></function>
</namespace>



















</namespace>
</header>
<header name="boost/move/algo/adaptive_sort.hpp">
<namespace name="boost">
<namespace name="movelib">


































<function name="adaptive_sort"><type>void</type><template>
          <template-type-parameter name="RandIt"/>
          <template-type-parameter name="RandRawIt"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="first"><paramtype>RandIt</paramtype></parameter><parameter name="last"><paramtype>RandIt</paramtype></parameter><parameter name="comp"><paramtype>Compare</paramtype></parameter><parameter name="uninitialized"><paramtype>RandRawIt</paramtype></parameter><parameter name="uninitialized_len"><paramtype>typename iterator_traits&lt; RandIt &gt;::size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Sorts the elements in the range [first, last) in ascending order according to comparison functor "comp". The sort is stable (order of equal elements is guaranteed to be preserved). Performance is improved if additional raw storage is provided.</para><para><emphasis role="bold">Requires</emphasis>:<itemizedlist>
<listitem><para>RandIt must meet the requirements of ValueSwappable and RandomAccessIterator.</para>
</listitem><listitem><para>The type of dereferenced RandIt must meet the requirements of MoveAssignable and MoveConstructible.</para>
</listitem></itemizedlist>
</para><para><emphasis role="bold">Parameters</emphasis>:<itemizedlist>
<listitem><para>first, last: the range of elements to sort</para>
</listitem><listitem><para>comp: comparison function object which returns true if the first argument is is ordered before the second.</para>
</listitem><listitem><para>uninitialized, uninitialized_len: raw storage starting on "uninitialized", able to hold "uninitialized_len" elements of type iterator_traits&lt;RandIt&gt;::value_type. Maximum performance is achieved when uninitialized_len is ceil(std::distance(first, last)/2).</para>
</listitem></itemizedlist>
</para><para><emphasis role="bold">Throws</emphasis>: If comp throws or the move constructor, move assignment or swap of the type of dereferenced RandIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Always K x O(Nxlog(N)) comparisons and move assignments/constructors/swaps. Comparisons are close to minimum even with no additional memory. Constant factor for data movement is minimized when uninitialized_len is ceil(std::distance(first, last)/2). Pretty good enough performance is achieved when ceil(sqrt(std::distance(first, last)))*2.</para><para><emphasis role="bold">Caution</emphasis>: Experimental implementation, not production-ready. </para></description></function>
<function name="adaptive_sort"><type>void</type><template>
          <template-type-parameter name="RandIt"/>
          <template-type-parameter name="Compare"/>
        </template><parameter name="first"><paramtype>RandIt</paramtype></parameter><parameter name="last"><paramtype>RandIt</paramtype></parameter><parameter name="comp"><paramtype>Compare</paramtype></parameter></function>

</namespace>



















</namespace>
</header>
<header name="boost/move/algo/predicate.hpp">
<namespace name="boost">
<namespace name="movelib">
<struct name="antistable"><template>
      <template-type-parameter name="Comp"/>
    </template><method-group name="public member functions">
<method name="operator()"><type>bool</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="V"/>
        </template><parameter name="u"><paramtype>const U &amp;</paramtype></parameter><parameter name="v"><paramtype>const V &amp;</paramtype></parameter></method>
<method name="get" cv="const"><type>const Comp &amp;</type></method>
</method-group>
<constructor specifiers="explicit"><parameter name="comp"><paramtype>Comp &amp;</paramtype></parameter></constructor>
<constructor><parameter name="other"><paramtype>const antistable &amp;</paramtype></parameter></constructor>
<method-group name="private member functions">
</method-group>
<copy-assignment><type>antistable &amp;</type><parameter name=""><paramtype>const antistable &amp;</paramtype></parameter></copy-assignment>
</struct><class name="inverse"><template>
      <template-type-parameter name="Comp"/>
    </template><method-group name="public member functions">
<method name="operator()"><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="T2"/>
        </template><parameter name="l"><paramtype>const T1 &amp;</paramtype></parameter><parameter name="r"><paramtype>const T2 &amp;</paramtype></parameter></method>
</method-group>
<constructor/>
<constructor specifiers="explicit"><parameter name="comp"><paramtype>Comp</paramtype></parameter></constructor>
</class><class name="negate"><template>
      <template-type-parameter name="Comp"/>
    </template><method-group name="public member functions">
<method name="operator()"><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="T2"/>
        </template><parameter name="l"><paramtype>const T1 &amp;</paramtype></parameter><parameter name="r"><paramtype>const T2 &amp;</paramtype></parameter></method>
</method-group>
<constructor/>
<constructor specifiers="explicit"><parameter name="comp"><paramtype>Comp</paramtype></parameter></constructor>
</class>































<function name="unantistable"><type>Comp</type><template>
          <template-type-parameter name="Comp"/>
        </template><parameter name="comp"><paramtype>Comp</paramtype></parameter></function>
<function name="unantistable"><type>Comp</type><template>
          <template-type-parameter name="Comp"/>
        </template><parameter name="comp"><paramtype>antistable&lt; Comp &gt;</paramtype></parameter></function>



</namespace>



















</namespace>
</header>
<header name="boost/move/algo/unique.hpp">
<namespace name="boost">
<namespace name="movelib">































<function name="unique"><type>ForwardIterator</type><template>
          <template-type-parameter name="ForwardIterator"/>
          <template-type-parameter name="BinaryPredicate"/>
        </template><parameter name="first"><paramtype>ForwardIterator</paramtype></parameter><parameter name="last"><paramtype>ForwardIterator</paramtype></parameter><parameter name="pred"><paramtype>BinaryPredicate</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: The comparison function shall be an equivalence relation. The type of *first shall satisfy the MoveAssignable requirements</para><para><emphasis role="bold">Effects</emphasis>: For a nonempty range, eliminates all but the first element from every consecutive group of equivalent elements referred to by the iterator i in the range [first + 1, last) for which the following conditions hold: pred(*(i - 1), *i) != false.</para><para><emphasis role="bold">Returns</emphasis>: The end of the resulting range.</para><para><emphasis role="bold">Complexity</emphasis>: For nonempty ranges, exactly (last - first) - 1 applications of the corresponding predicate. </para></description></function>





</namespace>



















</namespace>
</header>
<header name="boost/move/algorithm.hpp">
<namespace name="boost">








<function name="uninitialized_copy_or_move"><type>F</type><template>
          <template-type-parameter name="I"/>
          <template-type-parameter name="F"/>
        </template><parameter name="f"><paramtype>I</paramtype></parameter><parameter name="l"><paramtype>I</paramtype></parameter><parameter name="r"><paramtype>F</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></function>
<function name="copy_or_move"><type>F</type><template>
          <template-type-parameter name="I"/>
          <template-type-parameter name="F"/>
        </template><parameter name="f"><paramtype>I</paramtype></parameter><parameter name="l"><paramtype>I</paramtype></parameter><parameter name="r"><paramtype>F</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></function>
<function name="uninitialized_copy_or_move"><type>F</type><template>
          <template-type-parameter name="I"/>
          <template-type-parameter name="F"/>
        </template><parameter name="f"><paramtype>I</paramtype></parameter><parameter name="l"><paramtype>I</paramtype></parameter><parameter name="r"><paramtype>F</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: <programlisting language="c++">for (; first != last; ++result, ++first)
   new (static_cast&lt;void*&gt;(&amp;*result))
      typename iterator_traits&lt;ForwardIterator&gt;::value_type(*first);
</programlisting></para><para><emphasis role="bold">Returns</emphasis>: result</para><para><emphasis role="bold">Note</emphasis>: This function is provided because <emphasis>std::uninitialized_copy</emphasis> from some STL implementations is not compatible with <emphasis><classname alt="boost::move_iterator">move_iterator</classname></emphasis> </para></description></function>
<function name="copy_or_move"><type>F</type><template>
          <template-type-parameter name="I"/>
          <template-type-parameter name="F"/>
        </template><parameter name="f"><paramtype>I</paramtype></parameter><parameter name="l"><paramtype>I</paramtype></parameter><parameter name="r"><paramtype>F</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: <programlisting language="c++">for (; first != last; ++result, ++first)
   *result = *first;
</programlisting></para><para><emphasis role="bold">Returns</emphasis>: result</para><para><emphasis role="bold">Note</emphasis>: This function is provided because <emphasis>std::uninitialized_copy</emphasis> from some STL implementations is not compatible with <emphasis><classname alt="boost::move_iterator">move_iterator</classname></emphasis> </para></description></function>







</namespace>
</header>
<header name="boost/move/core.hpp">
<para>This header implements macros to define movable classes and move-aware functions </para><namespace name="boost">
<struct name="has_move_emulation_disabled"><template>
      <template-type-parameter name="T"/>
    </template><data-member name="value" specifiers="static"><type>const bool</type></data-member>
</struct><struct name="has_move_emulation_enabled"><template>
      <template-type-parameter name="T"/>
    </template><description><para>This trait yields to a compile-time true boolean if T was marked as BOOST_MOVABLE_BUT_NOT_COPYABLE or BOOST_COPYABLE_AND_MOVABLE and rvalue references are not available on the platform. False otherwise. </para></description><data-member name="value" specifiers="static"><type>const bool</type></data-member>
</struct>


















</namespace>
<macro name="BOOST_MOVABLE_BUT_NOT_COPYABLE" kind="functionlike"><macro-parameter name="TYPE"/><description><para>This macro marks a type as movable but not copyable, disabling copy construction and assignment. The user will need to write a move constructor/assignment as explained in the documentation to fully write a movable but not copyable class. </para></description></macro>
<macro name="BOOST_COPYABLE_AND_MOVABLE" kind="functionlike"><macro-parameter name="TYPE"/><description><para>This macro marks a type as copyable and movable. The user will need to write a move constructor/assignment and a copy assignment as explained in the documentation to fully write a copyable and movable class. </para></description></macro>
<macro name="BOOST_RV_REF" kind="functionlike"><macro-parameter name="TYPE"/><description><para>This macro is used to achieve portable syntax in move constructors and assignments for classes marked as BOOST_COPYABLE_AND_MOVABLE or BOOST_MOVABLE_BUT_NOT_COPYABLE </para></description></macro>
<macro name="BOOST_RV_REF_BEG"><description><para>This macro is used to achieve portable syntax in move constructors and assignments for template classes marked as BOOST_COPYABLE_AND_MOVABLE or BOOST_MOVABLE_BUT_NOT_COPYABLE. As macros have problems with comma-separated template arguments, the template argument must be preceded with BOOST_RV_REF_BEG and ended with BOOST_RV_REF_END </para></description></macro>
<macro name="BOOST_RV_REF_END"><description><para>This macro is used to achieve portable syntax in move constructors and assignments for template classes marked as BOOST_COPYABLE_AND_MOVABLE or BOOST_MOVABLE_BUT_NOT_COPYABLE. As macros have problems with comma-separated template arguments, the template argument must be preceded with BOOST_RV_REF_BEG and ended with BOOST_RV_REF_END </para></description></macro>
<macro name="BOOST_RV_REF_BEG_IF_CXX11"><description><para>This macro expands to BOOST_RV_REF_BEG if BOOST_NO_CXX11_RVALUE_REFERENCES is not defined, empty otherwise </para></description></macro>
<macro name="BOOST_RV_REF_END_IF_CXX11"><description><para>This macro expands to BOOST_RV_REF_END if BOOST_NO_CXX11_RVALUE_REFERENCES is not defined, empty otherwise </para></description></macro>
<macro name="BOOST_COPY_ASSIGN_REF" kind="functionlike"><macro-parameter name="TYPE"/><description><para>This macro is used to achieve portable syntax in copy assignment for classes marked as BOOST_COPYABLE_AND_MOVABLE. </para></description></macro>
<macro name="BOOST_FWD_REF" kind="functionlike"><macro-parameter name="TYPE"/><description><para>This macro is used to implement portable perfect forwarding as explained in the documentation. </para></description></macro>
<macro name="BOOST_MOVE_RET" kind="functionlike"><macro-parameter name="RET_TYPE"/><macro-parameter name="REF"/><description><para>This macro is used to achieve portable move return semantics. The C++11 Standard allows implicit move returns when the object to be returned is designated by a lvalue and:<itemizedlist>
<listitem><para>The criteria for elision of a copy operation are met OR</para>
</listitem><listitem><para>The criteria would be met save for the fact that the source object is a function parameter</para>
</listitem></itemizedlist>
</para><para>For C++11 conforming compilers this macros only yields to REF: <computeroutput>return BOOST_MOVE_RET(RET_TYPE, REF);</computeroutput> -&gt; <computeroutput>return REF;</computeroutput></para><para>For compilers without rvalue references this macro does an explicit move if the move emulation is activated and the return type (RET_TYPE) is not a reference.</para><para>For non-conforming compilers with rvalue references like Visual 2010 &amp; 2012, an explicit move is performed if RET_TYPE is not a reference.</para><para><emphasis role="bold">Caution</emphasis>: When using this macro in non-conforming or C++03 compilers, a move will be performed even if the C++11 standard does not allow it (e.g. returning a static variable). The user is responsible for using this macro only to return local objects that met C++11 criteria. </para></description></macro>
<macro name="BOOST_MOVE_BASE" kind="functionlike"><macro-parameter name="BASE_TYPE"/><macro-parameter name="ARG"/><purpose>defined(BOOST_MOVE_MSVC_AUTO_MOVE_RETURN_BUG) || defined(BOOST_MOVE_DOXYGEN_INVOKED) </purpose><description><para>This macro is used to achieve portable optimal move constructors.</para><para>When implementing the move constructor, in C++03 compilers the moved-from argument must be cast to the base type before calling <computeroutput>boost::move()</computeroutput> due to rvalue reference limitations.</para><para>In C++11 compilers the cast from a rvalue reference of a derived type to a rvalue reference of a base type is implicit. </para></description></macro>
</header>
<header name="boost/move/default_delete.hpp">
<para>Describes the default deleter (destruction policy) of <computeroutput>unique_ptr</computeroutput>: <computeroutput>default_delete</computeroutput>. </para><namespace name="boost">
<namespace name="movelib">
<struct name="default_delete"><template>
      <template-type-parameter name="T"><purpose><para>The type to be deleted. It may be an incomplete type </para></purpose></template-type-parameter>
    </template><description><para>The class template <computeroutput><classname alt="boost::movelib::default_delete">default_delete</classname></computeroutput> serves as the default deleter (destruction policy) for the class template <computeroutput><classname alt="boost::movelib::unique_ptr">unique_ptr</classname></computeroutput>.</para><para>
</para></description><method-group name="public member functions">
<method name="operator()" cv="const noexcept"><type>void</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="ptr"><paramtype>U *</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: if T is not an array type, calls <computeroutput>delete</computeroutput> on static_cast&lt;T*&gt;(ptr), otherwise calls <computeroutput>delete[]</computeroutput> on static_cast&lt;remove_extent&lt;T&gt;::type*&gt;(ptr).</para><para><emphasis role="bold">Remarks</emphasis>: If U is an incomplete type, the program is ill-formed. This operator shall not participate in overload resolution unless:<itemizedlist>
<listitem><para>T is not an array type and U* is convertible to T*, OR</para>
</listitem><listitem><para>T is an array type, and remove_cv&lt;U&gt;::type is the same type as remove_cv&lt;remove_extent&lt;T&gt;::type&gt;::type and U* is convertible to remove_extent&lt;T&gt;::type*. </para>
</listitem></itemizedlist>
</para></description></method>
<method name="operator()" cv="const noexcept"><type>void</type><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as <computeroutput>(<emphasis>this)(static_cast&lt;element_type</emphasis>&gt;(nullptr))</computeroutput>. </para></description></method>
</method-group>
<constructor><description><para>Default constructor. </para></description></constructor>
<constructor><parameter name=""><paramtype>const <classname>default_delete</classname> &amp;</paramtype></parameter><description><para>Trivial copy constructor </para></description></constructor>
<copy-assignment><type><classname>default_delete</classname> &amp;</type><parameter name=""><paramtype>const <classname>default_delete</classname> &amp;</paramtype></parameter><description><para>Trivial assignment </para></description></copy-assignment>
<constructor cv="noexcept"><template>
          <template-type-parameter name="U"/>
        </template><parameter name=""><paramtype>const <classname>default_delete</classname>&lt; U &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::movelib::default_delete">default_delete</classname> object from another <computeroutput><classname alt="boost::movelib::default_delete">default_delete</classname><underline> object.</underline></computeroutput></para><para><computeroutput><underline><emphasis role="bold">Remarks</emphasis>: This constructor shall not participate in overload resolution unless:<itemizedlist>
<listitem><para>If T is not an array type and U* is implicitly convertible to T*.</para>
</listitem><listitem><para>If T is an array type and U* is a more CV qualified pointer to remove_extent&lt;T&gt;::type. </para>
</listitem></itemizedlist>
</underline></computeroutput></para></description></constructor>
<copy-assignment cv="noexcept"><type><classname>default_delete</classname> &amp;</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name=""><paramtype>const <classname>default_delete</classname>&lt; U &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::movelib::default_delete">default_delete</classname> object from another <computeroutput><classname alt="boost::movelib::default_delete">default_delete</classname><underline> object.</underline></computeroutput></para><para><computeroutput><underline><emphasis role="bold">Remarks</emphasis>: This constructor shall not participate in overload resolution unless:<itemizedlist>
<listitem><para>If T is not an array type and U* is implicitly convertible to T*.</para>
</listitem><listitem><para>If T is an array type and U* is a more CV qualified pointer to remove_extent&lt;T&gt;::type. </para>
</listitem></itemizedlist>
</underline></computeroutput></para></description></copy-assignment>
</struct>




































</namespace>



















</namespace>
</header>
<header name="boost/move/iterator.hpp">
<namespace name="boost">
<class name="back_move_insert_iterator"><template>
      <template-type-parameter name="C"/>
    </template><description><para>A move insert iterator that move constructs elements at the back of a container </para></description><typedef name="container_type"><type>C</type></typedef>
<typedef name="value_type"><type>C::value_type</type></typedef>
<typedef name="reference"><type>C::reference</type></typedef>
<typedef name="pointer"><type>C::pointer</type></typedef>
<typedef name="difference_type"><type>C::difference_type</type></typedef>
<typedef name="iterator_category"><type>std::output_iterator_tag</type></typedef>
<method-group name="public member functions">
<method name="operator *"><type><classname>back_move_insert_iterator</classname> &amp;</type></method>
<method name="operator++"><type><classname>back_move_insert_iterator</classname> &amp;</type></method>
<method name="operator++"><type><classname>back_move_insert_iterator</classname> &amp;</type><parameter name=""><paramtype>int</paramtype></parameter></method>
</method-group>
<constructor specifiers="explicit"><parameter name="x"><paramtype>C &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>back_move_insert_iterator</classname> &amp;</type><parameter name="x"><paramtype>reference</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>back_move_insert_iterator</classname> &amp;</type><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter></copy-assignment>
</class><class name="front_move_insert_iterator"><template>
      <template-type-parameter name="C"/>
    </template><description><para>A move insert iterator that move constructs elements int the front of a container </para></description><typedef name="container_type"><type>C</type></typedef>
<typedef name="value_type"><type>C::value_type</type></typedef>
<typedef name="reference"><type>C::reference</type></typedef>
<typedef name="pointer"><type>C::pointer</type></typedef>
<typedef name="difference_type"><type>C::difference_type</type></typedef>
<typedef name="iterator_category"><type>std::output_iterator_tag</type></typedef>
<method-group name="public member functions">
<method name="operator *"><type><classname>front_move_insert_iterator</classname> &amp;</type></method>
<method name="operator++"><type><classname>front_move_insert_iterator</classname> &amp;</type></method>
<method name="operator++"><type><classname>front_move_insert_iterator</classname> &amp;</type><parameter name=""><paramtype>int</paramtype></parameter></method>
</method-group>
<constructor specifiers="explicit"><parameter name="x"><paramtype>C &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>front_move_insert_iterator</classname> &amp;</type><parameter name="x"><paramtype>reference</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>front_move_insert_iterator</classname> &amp;</type><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter></copy-assignment>
</class><class name="move_insert_iterator"><template>
      <template-type-parameter name="C"/>
    </template><typedef name="container_type"><type>C</type></typedef>
<typedef name="value_type"><type>C::value_type</type></typedef>
<typedef name="reference"><type>C::reference</type></typedef>
<typedef name="pointer"><type>C::pointer</type></typedef>
<typedef name="difference_type"><type>C::difference_type</type></typedef>
<typedef name="iterator_category"><type>std::output_iterator_tag</type></typedef>
<method-group name="public member functions">
<method name="operator *"><type>move_insert_iterator &amp;</type></method>
<method name="operator++"><type>move_insert_iterator &amp;</type></method>
<method name="operator++"><type>move_insert_iterator &amp;</type><parameter name=""><paramtype>int</paramtype></parameter></method>
</method-group>
<constructor specifiers="explicit"><parameter name="x"><paramtype>C &amp;</paramtype></parameter><parameter name="pos"><paramtype>typename C::iterator</paramtype></parameter></constructor>
<copy-assignment><type>move_insert_iterator &amp;</type><parameter name="x"><paramtype>reference</paramtype></parameter></copy-assignment>
<copy-assignment><type>move_insert_iterator &amp;</type><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter></copy-assignment>
</class><class name="move_iterator"><template>
      <template-type-parameter name="It"/>
    </template><description><para>Class template <classname alt="boost::move_iterator">move_iterator</classname> is an iterator adaptor with the same behavior as the underlying iterator except that its dereference operator implicitly converts the value returned by the underlying iterator's dereference operator to an rvalue reference. Some generic algorithms can be called with move iterators to replace copying with moving. </para></description><typedef name="iterator_type"><type>It</type></typedef>
<typedef name="value_type"><type>boost::movelib::iterator_traits&lt; iterator_type &gt;::value_type</type></typedef>
<typedef name="reference"><type>value_type &amp;&amp;</type></typedef>
<typedef name="pointer"><type>It</type></typedef>
<typedef name="difference_type"><type>boost::movelib::iterator_traits&lt; iterator_type &gt;::difference_type</type></typedef>
<typedef name="iterator_category"><type>boost::movelib::iterator_traits&lt; iterator_type &gt;::iterator_category</type></typedef>
<method-group name="public member functions">
<method name="operator *" cv="const"><type>reference</type></method>
<method name="operator-&gt;" cv="const"><type>pointer</type></method>
<method name="operator++"><type><classname>move_iterator</classname> &amp;</type></method>
<method name="operator++"><type><classname>move_iterator</classname>&lt; iterator_type &gt;</type><parameter name=""><paramtype>int</paramtype></parameter></method>
<method name="operator--"><type><classname>move_iterator</classname> &amp;</type></method>
<method name="operator--"><type><classname>move_iterator</classname>&lt; iterator_type &gt;</type><parameter name=""><paramtype>int</paramtype></parameter></method>
<method name="operator+" cv="const"><type><classname>move_iterator</classname>&lt; iterator_type &gt;</type><parameter name="n"><paramtype>difference_type</paramtype></parameter></method>
<method name="operator+="><type><classname>move_iterator</classname> &amp;</type><parameter name="n"><paramtype>difference_type</paramtype></parameter></method>
<method name="operator-" cv="const"><type><classname>move_iterator</classname>&lt; iterator_type &gt;</type><parameter name="n"><paramtype>difference_type</paramtype></parameter></method>
<method name="operator-="><type><classname>move_iterator</classname> &amp;</type><parameter name="n"><paramtype>difference_type</paramtype></parameter></method>
<method name="operator[]" cv="const"><type>reference</type><parameter name="n"><paramtype>difference_type</paramtype></parameter></method>
</method-group>
<constructor/>
<constructor specifiers="explicit"><parameter name="i"><paramtype>const It &amp;</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>const <classname>move_iterator</classname>&lt; U &gt; &amp;</paramtype></parameter></constructor>
</class>



<function name="make_move_iterator"><type><classname>move_iterator</classname>&lt; It &gt;</type><template>
          <template-type-parameter name="It"/>
        </template><parameter name="it"><paramtype>const It &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: move_iterator&lt;It&gt;(i). </para></description></function>
<function name="back_move_inserter"><type><classname>back_move_insert_iterator</classname>&lt; C &gt;</type><template>
          <template-type-parameter name="C"/>
        </template><parameter name="x"><paramtype>C &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: back_move_insert_iterator&lt;C&gt;(x). </para></description></function>
<function name="front_move_inserter"><type><classname>front_move_insert_iterator</classname>&lt; C &gt;</type><template>
          <template-type-parameter name="C"/>
        </template><parameter name="x"><paramtype>C &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: front_move_insert_iterator&lt;C&gt;(x). </para></description></function>
<function name="move_inserter"><type>move_insert_iterator&lt; C &gt;</type><template>
          <template-type-parameter name="C"/>
        </template><parameter name="x"><paramtype>C &amp;</paramtype></parameter><parameter name="it"><paramtype>typename C::iterator</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: move_insert_iterator&lt;C&gt;(x, it). </para></description></function>











</namespace>
</header>
<header name="boost/move/make_unique.hpp">
<para>Defines "make_unique" functions, which are factories to create instances of unique_ptr depending on the passed arguments.</para><para>This header can be a bit heavyweight in C++03 compilers due to the use of the preprocessor library, that's why it's a a separate header from <computeroutput>unique_ptr.hpp</computeroutput> </para><namespace name="boost">
<namespace name="movelib">



















<function name="make_unique"><type><classname>unique_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Remarks</emphasis>: This function shall not participate in overload resolution unless T is not an array.</para><para><emphasis role="bold">Returns</emphasis>: <computeroutput>unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...))</computeroutput>. </para></description></function>
<function name="make_unique_nothrow"><type><classname>unique_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Remarks</emphasis>: This function shall not participate in overload resolution unless T is not an array.</para><para><emphasis role="bold">Returns</emphasis>: <computeroutput>unique_ptr&lt;T&gt;(new T(std::nothrow)(std::forward&lt;Args&gt;(args)...))</computeroutput>. </para></description></function>
<function name="make_unique_definit"><type><classname>unique_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><description><para><emphasis role="bold">Remarks</emphasis>: This function shall not participate in overload resolution unless T is not an array.</para><para><emphasis role="bold">Returns</emphasis>: <computeroutput>unique_ptr&lt;T&gt;(new T)</computeroutput> (default initialization) </para></description></function>
<function name="make_unique_nothrow_definit"><type><classname>unique_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><description><para><emphasis role="bold">Remarks</emphasis>: This function shall not participate in overload resolution unless T is not an array.</para><para><emphasis role="bold">Returns</emphasis>: <computeroutput>unique_ptr&lt;T&gt;(new T(std::nothrow)</computeroutput> (default initialization) </para></description></function>
<function name="make_unique"><type><classname>unique_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Remarks</emphasis>: This function shall not participate in overload resolution unless T is an array of unknown bound.</para><para><emphasis role="bold">Returns</emphasis>: <computeroutput>unique_ptr&lt;T&gt;(new remove_extent_t&lt;T&gt;[n]())</computeroutput> (value initialization) </para></description></function>
<function name="make_unique_nothrow"><type><classname>unique_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Remarks</emphasis>: This function shall not participate in overload resolution unless T is an array of unknown bound.</para><para><emphasis role="bold">Returns</emphasis>: <computeroutput>unique_ptr&lt;T&gt;(new (std::nothrow)remove_extent_t&lt;T&gt;[n]())</computeroutput> (value initialization) </para></description></function>
<function name="make_unique_definit"><type><classname>unique_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Remarks</emphasis>: This function shall not participate in overload resolution unless T is an array of unknown bound.</para><para><emphasis role="bold">Returns</emphasis>: <computeroutput>unique_ptr&lt;T&gt;(new remove_extent_t&lt;T&gt;[n])</computeroutput> (default initialization) </para></description></function>
<function name="make_unique_nothrow_definit"><type><classname>unique_ptr</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="n"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Remarks</emphasis>: This function shall not participate in overload resolution unless T is an array of unknown bound.</para><para><emphasis role="bold">Returns</emphasis>: <computeroutput>unique_ptr&lt;T&gt;(new (std::nothrow)remove_extent_t&lt;T&gt;[n])</computeroutput> (default initialization) </para></description></function>
<function name="make_unique"><type>unspecified</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="..."><paramtype>Args &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Remarks</emphasis>: This function shall not participate in overload resolution unless T is an array of known bound. </para></description></function>
<function name="make_unique_definit"><type>unspecified</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="..."><paramtype>Args &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Remarks</emphasis>: This function shall not participate in overload resolution unless T is an array of known bound. </para></description></function>
<function name="make_unique_nothrow"><type>unspecified</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="..."><paramtype>Args &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Remarks</emphasis>: This function shall not participate in overload resolution unless T is an array of known bound. </para></description></function>
<function name="make_unique_nothrow_definit"><type>unspecified</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="..."><paramtype>Args &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Remarks</emphasis>: This function shall not participate in overload resolution unless T is an array of known bound. </para></description></function>






</namespace>



















</namespace>
</header>
<header name="boost/move/move.hpp">
<para>A general library header that includes the rest of top-level headers. </para></header>
<header name="boost/move/algo/move.hpp">
<namespace name="boost">
















<function name="move"><type>O</type><template>
          <template-type-parameter name="I"/>
          <template-type-parameter name="O"/>
        </template><parameter name="f"><paramtype>I</paramtype></parameter><parameter name="l"><paramtype>I</paramtype></parameter><parameter name="result"><paramtype>O</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves elements in the range [first,last) into the range [result,result + (last - first)) starting from first and proceeding to last. For each non-negative integer n &lt; (last-first), performs *(result + n) = boost::move (*(first + n)).</para><para><emphasis role="bold">Effects</emphasis>: result + (last - first).</para><para><emphasis role="bold">Requires</emphasis>: result shall not be in the range [first,last).</para><para><emphasis role="bold">Complexity</emphasis>: Exactly last - first move assignments. </para></description></function>
<function name="move_backward"><type>O</type><template>
          <template-type-parameter name="I"/>
          <template-type-parameter name="O"/>
        </template><parameter name="f"><paramtype>I</paramtype></parameter><parameter name="l"><paramtype>I</paramtype></parameter><parameter name="result"><paramtype>O</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Moves elements in the range [first,last) into the range [result - (last-first),result) starting from last - 1 and proceeding to first. For each positive integer n &lt;= (last - first), performs *(result - n) = boost::move(*(last - n)).</para><para><emphasis role="bold">Requires</emphasis>: result shall not be in the range [first,last).</para><para><emphasis role="bold">Returns</emphasis>: result - (last - first).</para><para><emphasis role="bold">Complexity</emphasis>: Exactly last - first assignments. </para></description></function>
<function name="uninitialized_move"><type>F</type><template>
          <template-type-parameter name="I"/>
          <template-type-parameter name="F"/>
        </template><parameter name="f"><paramtype>I</paramtype></parameter><parameter name="l"><paramtype>I</paramtype></parameter><parameter name="r"><paramtype>F</paramtype></parameter><purpose>defined(BOOST_MOVE_USE_STANDARD_LIBRARY_MOVE) </purpose><description><para><emphasis role="bold">Effects</emphasis>: <programlisting language="c++">for (; first != last; ++result, ++first)
   new (static_cast&lt;void*&gt;(&amp;*result))
      typename iterator_traits&lt;ForwardIterator&gt;::value_type(boost::move(*first));
</programlisting></para><para><emphasis role="bold">Returns</emphasis>: result </para></description></function>
</namespace>
</header>
<header name="boost/move/traits.hpp">
<namespace name="boost">
<struct name="has_nothrow_move"><template>
      <template-type-parameter name="T"/>
    </template><description><programlisting>boost::is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; boost::is_nothrow_move_assignable&lt;T&gt;::value </programlisting></description><data-member name="value" specifiers="static"><type>const bool</type></data-member>
</struct><struct name="has_trivial_destructor_after_move"><template>
      <template-type-parameter name="T"/>
    </template><description><para>If this trait yields to true (<emphasis><classname alt="boost::has_trivial_destructor_after_move">has_trivial_destructor_after_move</classname> &lt;T&gt;::value == true</emphasis>) means that if T is used as argument of a move construction/assignment, there is no need to call T's destructor. This optimization tipically is used to improve containers' performance.</para><para>By default this trait is true if the type has trivial destructor, every class should specialize this trait if it wants to improve performance when inserted in containers. </para></description></struct>


















</namespace>
</header>
<header name="boost/move/unique_ptr.hpp">
<para>Describes the smart pointer unique_ptr, a drop-in replacement for std::unique_ptr, usable also from C++03 compilers.</para><para>Main differences from std::unique_ptr to avoid heavy dependencies, specially in C++03 compilers:<itemizedlist>
<listitem><para><computeroutput>operator &lt; </computeroutput> uses pointer <computeroutput>operator &lt; </computeroutput>instead of <computeroutput>std::less&lt;common_type&gt;</computeroutput>. This avoids dependencies on <computeroutput>std::common_type</computeroutput> and <computeroutput>std::less</computeroutput> (<computeroutput>&lt;type_traits&gt;/&lt;functional&gt;</computeroutput> headers). In C++03 this avoid pulling Boost.Typeof and other cascading dependencies. As in all Boost platforms <computeroutput>operator &lt;</computeroutput> on raw pointers and other smart pointers provides strict weak ordering in practice this should not be a problem for users.</para>
</listitem><listitem><para>assignable from literal 0 for compilers without nullptr</para>
</listitem><listitem><para><computeroutput>unique_ptr&lt;T[]&gt;</computeroutput> is constructible and assignable from <computeroutput>unique_ptr&lt;U[]&gt;</computeroutput> if cv-less T and cv-less U are the same type and T is more CV qualified than U. </para>
</listitem></itemizedlist>
</para><namespace name="boost">
<namespace name="movelib">
<class name="unique_ptr"><template>
      <template-type-parameter name="T"><purpose><para>Provides the type of the stored pointer. </para></purpose></template-type-parameter>
      <template-type-parameter name="D"><default><classname alt="boost::movelib::default_delete">default_delete</classname>&lt;T&gt;</default><purpose><para>The deleter type:<itemizedlist>
<listitem><para>The default type for the template parameter D is <classname alt="boost::movelib::default_delete">default_delete</classname>. A client-supplied template argument D shall be a function object type, lvalue-reference to function, or lvalue-reference to function object type for which, given a value d of type D and a value ptr of type unique_ptr&lt;T, D&gt;::pointer, the expression d(ptr) is valid and has the effect of disposing of the pointer as appropriate for that deleter.</para>
</listitem><listitem><para>If the deleter's type D is not a reference type, D shall satisfy the requirements of Destructible.</para>
</listitem><listitem><para>If the type <computeroutput>remove_reference&lt;D&gt;::type::pointer</computeroutput> exists, it shall satisfy the requirements of NullablePointer. </para>
</listitem></itemizedlist>
</para></purpose></template-type-parameter>
    </template><description><para>A unique pointer is an object that owns another object and manages that other object through a pointer.</para><para>More precisely, a unique pointer is an object u that stores a pointer to a second object p and will dispose of p when u is itself destroyed (e.g., when leaving block scope). In this context, u is said to own p.</para><para>The mechanism by which u disposes of p is known as p's associated deleter, a function object whose correct invocation results in p's appropriate disposition (typically its deletion).</para><para>Let the notation u.p denote the pointer stored by u, and let u.d denote the associated deleter. Upon request, u can reset (replace) u.p and u.d with another pointer and deleter, but must properly dispose of its owned object via the associated deleter before such replacement is considered completed.</para><para>Additionally, u can, upon request, transfer ownership to another unique pointer u2. Upon completion of such a transfer, the following postconditions hold:<itemizedlist>
<listitem><para>u2.p is equal to the pre-transfer u.p,</para>
</listitem><listitem><para>u.p is equal to nullptr, and</para>
</listitem><listitem><para>if the pre-transfer u.d maintained state, such state has been transferred to u2.d.</para>
</listitem></itemizedlist>
</para><para>As in the case of a reset, u2 must properly dispose of its pre-transfer owned object via the pre-transfer associated deleter before the ownership transfer is considered complete.</para><para>Each object of a type U instantiated from the <classname alt="boost::movelib::unique_ptr">unique_ptr</classname> template specified in this subclause has the strict ownership semantics, specified above, of a unique pointer. In partial satisfaction of these semantics, each such U is MoveConstructible and MoveAssignable, but is not CopyConstructible nor CopyAssignable. The template parameter T of <classname alt="boost::movelib::unique_ptr">unique_ptr</classname> may be an incomplete type.</para><para>The uses of <classname alt="boost::movelib::unique_ptr">unique_ptr</classname> include providing exception safety for dynamically allocated memory, passing ownership of dynamically allocated memory to a function, and returning dynamically allocated memory from a function.</para><para>If T is an array type (e.g. unique_ptr&lt;MyType[]&gt;) the interface is slightly altered:<itemizedlist>
<listitem><para>Pointers to types derived from T are rejected by the constructors, and by reset.</para>
</listitem><listitem><para>The observers <computeroutput>operator*</computeroutput> and <computeroutput>operator-&gt;</computeroutput> are not provided.</para>
</listitem><listitem><para>The indexing observer <computeroutput>operator[]</computeroutput> is provided.</para>
</listitem></itemizedlist>
</para><para>
</para></description><typedef name="pointer"><description><para>If the type <computeroutput>remove_reference&lt;D&gt;::type::pointer</computeroutput> exists, then it shall be a synonym for <computeroutput>remove_reference&lt;D&gt;::type::pointer</computeroutput>. Otherwise it shall be a synonym for T*. </para></description><type>see_documentation</type></typedef>
<typedef name="element_type"><description><para>If T is an array type, then element_type is equal to T. Otherwise, if T is a type in the form U[], element_type is equal to U. </para></description><type>see_documentation</type></typedef>
<typedef name="deleter_type"><type>D</type></typedef>
<method-group name="public member functions">
<method name="operator *" cv="const noexcept"><type>element_type &amp;</type><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>get() != nullptr</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: <computeroutput>*get()</computeroutput>.</para><para><emphasis role="bold">Remarks&lt;/b: If T is an array type, the program is ill-formed. </emphasis></para></description></method>
<method name="operator[]" cv="const noexcept"><type>element_type &amp;</type><parameter name="i"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: i &lt; the number of elements in the array to which the stored pointer points.</para><para><emphasis role="bold">Returns</emphasis>: <computeroutput>get()[i]</computeroutput>.</para><para><emphasis role="bold">Remarks&lt;/b: If T is not an array type, the program is ill-formed. </emphasis></para></description></method>
<method name="operator-&gt;" cv="const noexcept"><type>pointer</type><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>get() != nullptr</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: <computeroutput>get()</computeroutput>.</para><para><emphasis role="bold">Note</emphasis>: use typically requires that T be a complete type.</para><para><emphasis role="bold">Remarks&lt;/b: If T is an array type, the program is ill-formed. </emphasis></para></description></method>
<method name="get" cv="const noexcept"><type>pointer</type><description><para><emphasis role="bold">Returns</emphasis>: The stored pointer. </para></description></method>
<method name="get_deleter" cv="noexcept"><type>D &amp;</type><description><para><emphasis role="bold">Returns</emphasis>: A reference to the stored deleter. </para></description></method>
<method name="get_deleter" cv="const noexcept"><type>const D &amp;</type><description><para><emphasis role="bold">Returns</emphasis>: A reference to the stored deleter. </para></description></method>
<method name="conversion-operator" cv="const noexcept" specifiers="explicit"><type>bool</type><description><para><emphasis role="bold">Returns</emphasis>: Returns: get() != nullptr. </para></description></method>
<method name="release" cv="noexcept"><type>pointer</type><description><para><emphasis role="bold">Postcondition</emphasis>: <computeroutput>get() == nullptr</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: The value <computeroutput>get()</computeroutput> had at the start of the call to release. </para></description></method>
<method name="reset" cv="noexcept"><type>void</type><template>
          <template-type-parameter name="Pointer"/>
        </template><parameter name="p"><paramtype>Pointer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: The expression <computeroutput>get_deleter()(get())</computeroutput> shall be well formed, shall have well-defined behavior, and shall not throw exceptions.</para><para><emphasis role="bold">Effects</emphasis>: assigns p to the stored pointer, and then if the old value of the stored pointer, old_p, was not equal to nullptr, calls <computeroutput>get_deleter()(old_p)</computeroutput>. Note: The order of these operations is significant because the call to <computeroutput>get_deleter()</computeroutput> may destroy *this.</para><para><emphasis role="bold">Postconditions</emphasis>: <computeroutput>get() == p</computeroutput>. Note: The postcondition does not hold if the call to <computeroutput>get_deleter()</computeroutput> destroys *this since <computeroutput>this-&gt;get()</computeroutput> is no longer a valid expression.</para><para><emphasis role="bold">Remarks</emphasis>: This constructor shall not participate in overload resolution unless:<itemizedlist>
<listitem><para>If T is not an array type and Pointer is implicitly convertible to pointer.</para>
</listitem><listitem><para>If T is an array type and Pointer is a more CV qualified pointer to element_type. </para>
</listitem></itemizedlist>
</para></description></method>
<method name="reset" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Requires</emphasis>: The expression <computeroutput>get_deleter()(get())</computeroutput> shall be well formed, shall have well-defined behavior, and shall not throw exceptions.</para><para><emphasis role="bold">Effects</emphasis>: assigns nullptr to the stored pointer, and then if the old value of the stored pointer, old_p, was not equal to nullptr, calls <computeroutput>get_deleter()(old_p)</computeroutput>. Note: The order of these operations is significant because the call to <computeroutput>get_deleter()</computeroutput> may destroy *this.</para><para><emphasis role="bold">Postconditions</emphasis>: <computeroutput>get() == p</computeroutput>. Note: The postcondition does not hold if the call to <computeroutput>get_deleter()</computeroutput> destroys *this since <computeroutput>this-&gt;get()</computeroutput> is no longer a valid expression. </para></description></method>
<method name="reset" cv="noexcept"><type>void</type><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as <computeroutput>reset()</computeroutput> </para></description></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="u"><paramtype><classname>unique_ptr</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>get_deleter()</computeroutput> shall be swappable and shall not throw an exception under swap.</para><para><emphasis role="bold">Effects</emphasis>: Invokes swap on the stored pointers and on the stored deleters of *this and u. </para></description></method>
</method-group>
<constructor cv="= delete"><parameter name=""><paramtype>const <classname>unique_ptr</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= delete"><type><classname>unique_ptr</classname> &amp;</type><parameter name=""><paramtype>const <classname>unique_ptr</classname> &amp;</paramtype></parameter></copy-assignment>
<constructor cv="noexcept"><description><para><emphasis role="bold">Requires</emphasis>: D shall satisfy the requirements of DefaultConstructible, and that construction shall not throw an exception.</para><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::movelib::unique_ptr">unique_ptr</classname> object that owns nothing, value-initializing the stored pointer and the stored deleter.</para><para><emphasis role="bold">Postconditions</emphasis>: <computeroutput>get() == nullptr</computeroutput>. <computeroutput>get_deleter()</computeroutput> returns a reference to the stored deleter.</para><para><emphasis role="bold">Remarks</emphasis>: If this constructor is instantiated with a pointer type or reference type for the template argument D, the program is ill-formed. </para></description></constructor>
<constructor cv="noexcept"><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as <computeroutput>unique_ptr()</computeroutput> (default constructor). </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><template>
          <template-type-parameter name="Pointer"/>
        </template><parameter name="p"><paramtype>Pointer</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: D shall satisfy the requirements of DefaultConstructible, and that construction shall not throw an exception.</para><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::movelib::unique_ptr">unique_ptr</classname> which owns p, initializing the stored pointer with p and value initializing the stored deleter.</para><para><emphasis role="bold">Postconditions</emphasis>: <computeroutput>get() == p</computeroutput>. <computeroutput>get_deleter()</computeroutput> returns a reference to the stored deleter.</para><para><emphasis role="bold">Remarks</emphasis>: If this constructor is instantiated with a pointer type or reference type for the template argument D, the program is ill-formed. This constructor shall not participate in overload resolution unless:<itemizedlist>
<listitem><para>If T is not an array type and Pointer is implicitly convertible to pointer.</para>
</listitem><listitem><para>If T is an array type and Pointer is a more CV qualified pointer to element_type. </para>
</listitem></itemizedlist>
</para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="Pointer"/>
        </template><parameter name="p"><paramtype>Pointer</paramtype></parameter><parameter name="d1"><paramtype>see_documentation</paramtype></parameter><description><para>The signature of this constructor depends upon whether D is a reference type.<itemizedlist>
<listitem><para>If D is non-reference type A, then the signature is <computeroutput>unique_ptr(pointer p, const A&amp; d)</computeroutput>.</para>
</listitem><listitem><para>If D is an lvalue-reference type A&amp;, then the signature is <computeroutput>unique_ptr(pointer p, A&amp; d)</computeroutput>.</para>
</listitem><listitem><para>If D is an lvalue-reference type const A&amp;, then the signature is <computeroutput>unique_ptr(pointer p, const A&amp; d)</computeroutput>.</para>
</listitem></itemizedlist>
</para><para><emphasis role="bold">Requires</emphasis>: Either<itemizedlist>
<listitem><para>D is not an lvalue-reference type and d is an lvalue or const rvalue. D shall satisfy the requirements of CopyConstructible, and the copy constructor of D shall not throw an exception. This <classname alt="boost::movelib::unique_ptr">unique_ptr</classname> will hold a copy of d.</para>
</listitem><listitem><para>D is an lvalue-reference type and d is an lvalue. the type which D references need not be CopyConstructible nor MoveConstructible. This <classname alt="boost::movelib::unique_ptr">unique_ptr</classname> will hold a D which refers to the lvalue d.</para>
</listitem></itemizedlist>
</para><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::movelib::unique_ptr">unique_ptr</classname> object which owns p, initializing the stored pointer with p and initializing the deleter as described above.</para><para><emphasis role="bold">Postconditions</emphasis>: <computeroutput>get() == p</computeroutput>. <computeroutput>get_deleter()</computeroutput> returns a reference to the stored deleter. If D is a reference type then <computeroutput>get_deleter()</computeroutput> returns a reference to the lvalue d.</para><para><emphasis role="bold">Remarks</emphasis>: This constructor shall not participate in overload resolution unless:<itemizedlist>
<listitem><para>If T is not an array type and Pointer is implicitly convertible to pointer.</para>
</listitem><listitem><para>If T is an array type and Pointer is a more CV qualified pointer to element_type. </para>
</listitem></itemizedlist>
</para></description></constructor>
<constructor cv="noexcept"><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><parameter name="d1"><paramtype>see_documentation</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same effects as <computeroutput>template&lt;class Pointer&gt; unique_ptr(Pointer p, deleter_arg_type1 d1)</computeroutput> and additionally <computeroutput>get() == nullptr</computeroutput> </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="Pointer"/>
        </template><parameter name="p"><paramtype>Pointer</paramtype></parameter><parameter name="d2"><paramtype>see_documentation</paramtype></parameter><description><para>The signature of this constructor depends upon whether D is a reference type.<itemizedlist>
<listitem><para>If D is non-reference type A, then the signature is <computeroutput>unique_ptr(pointer p, A&amp;&amp; d)</computeroutput>.</para>
</listitem><listitem><para>If D is an lvalue-reference type A&amp;, then the signature is <computeroutput>unique_ptr(pointer p, A&amp;&amp; d)</computeroutput>.</para>
</listitem><listitem><para>If D is an lvalue-reference type const A&amp;, then the signature is <computeroutput>unique_ptr(pointer p, const A&amp;&amp; d)</computeroutput>.</para>
</listitem></itemizedlist>
</para><para><emphasis role="bold">Requires</emphasis>: Either<itemizedlist>
<listitem><para>D is not an lvalue-reference type and d is a non-const rvalue. D shall satisfy the requirements of MoveConstructible, and the move constructor of D shall not throw an exception. This <classname alt="boost::movelib::unique_ptr">unique_ptr</classname> will hold a value move constructed from d.</para>
</listitem><listitem><para>D is an lvalue-reference type and d is an rvalue, the program is ill-formed.</para>
</listitem></itemizedlist>
</para><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::movelib::unique_ptr">unique_ptr</classname> object which owns p, initializing the stored pointer with p and initializing the deleter as described above.</para><para><emphasis role="bold">Postconditions</emphasis>: <computeroutput>get() == p</computeroutput>. <computeroutput>get_deleter()</computeroutput> returns a reference to the stored deleter. If D is a reference type then <computeroutput>get_deleter()</computeroutput> returns a reference to the lvalue d.</para><para><emphasis role="bold">Remarks</emphasis>: This constructor shall not participate in overload resolution unless:<itemizedlist>
<listitem><para>If T is not an array type and Pointer is implicitly convertible to pointer.</para>
</listitem><listitem><para>If T is an array type and Pointer is a more CV qualified pointer to element_type. </para>
</listitem></itemizedlist>
</para></description></constructor>
<constructor cv="noexcept"><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><parameter name="d2"><paramtype>see_documentation</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same effects as <computeroutput>template&lt;class Pointer&gt; unique_ptr(Pointer p, deleter_arg_type2 d2)</computeroutput> and additionally <computeroutput>get() == nullptr</computeroutput> </para></description></constructor>
<constructor cv="noexcept"><parameter name="u"><paramtype><classname>unique_ptr</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: If D is not a reference type, D shall satisfy the requirements of MoveConstructible. Construction of the deleter from an rvalue of type D shall not throw an exception.</para><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::movelib::unique_ptr">unique_ptr</classname> by transferring ownership from u to *this. If D is a reference type, this deleter is copy constructed from u's deleter; otherwise, this deleter is move constructed from u's deleter.</para><para><emphasis role="bold">Postconditions</emphasis>: <computeroutput>get()</computeroutput> yields the value u.get() yielded before the construction. <computeroutput>get_deleter()</computeroutput> returns a reference to the stored deleter that was constructed from u.get_deleter(). If D is a reference type then <computeroutput>get_deleter()</computeroutput> and <computeroutput>u.get_deleter()</computeroutput> both reference the same lvalue deleter. </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="E"/>
        </template><parameter name="u"><paramtype>BOOST_RV_REF_BEG_IF_CXX11 <classname>unique_ptr</classname>&lt; U, E &gt; BOOST_RV_REF_END_IF_CXX11</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: If E is not a reference type, construction of the deleter from an rvalue of type E shall be well formed and shall not throw an exception. Otherwise, E is a reference type and construction of the deleter from an lvalue of type E shall be well formed and shall not throw an exception.</para><para><emphasis role="bold">Remarks</emphasis>: This constructor shall not participate in overload resolution unless:<itemizedlist>
<listitem><para><computeroutput>unique_ptr&lt;U, E&gt;::pointer</computeroutput> is implicitly convertible to pointer,</para>
</listitem><listitem><para>U is not an array type, and</para>
</listitem><listitem><para>either D is a reference type and E is the same type as D, or D is not a reference type and E is implicitly convertible to D.</para>
</listitem></itemizedlist>
</para><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::movelib::unique_ptr">unique_ptr</classname> by transferring ownership from u to *this. If E is a reference type, this deleter is copy constructed from u's deleter; otherwise, this deleter is move constructed from u's deleter.</para><para><emphasis role="bold">Postconditions</emphasis>: <computeroutput>get()</computeroutput> yields the value <computeroutput>u.get()</computeroutput> yielded before the construction. <computeroutput>get_deleter()</computeroutput> returns a reference to the stored deleter that was constructed from <computeroutput>u.get_deleter()</computeroutput>. </para></description></constructor>
<destructor><description><para><emphasis role="bold">Requires</emphasis>: The expression <computeroutput>get_deleter()(get())</computeroutput> shall be well formed, shall have well-defined behavior, and shall not throw exceptions.</para><para><emphasis role="bold">Effects</emphasis>: If <computeroutput>get() == nullpt1r</computeroutput> there are no effects. Otherwise <computeroutput>get_deleter()(get())</computeroutput>.</para><para><emphasis role="bold">Note</emphasis>: The use of <classname alt="boost::movelib::default_delete">default_delete</classname> requires T to be a complete type </para></description></destructor>
<copy-assignment cv="noexcept"><type><classname>unique_ptr</classname> &amp;</type><parameter name="u"><paramtype><classname>unique_ptr</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: If D is not a reference type, D shall satisfy the requirements of MoveAssignable and assignment of the deleter from an rvalue of type D shall not throw an exception. Otherwise, D is a reference type; <computeroutput>remove_reference&lt;D&gt;::type</computeroutput> shall satisfy the CopyAssignable requirements and assignment of the deleter from an lvalue of type D shall not throw an exception.</para><para><emphasis role="bold">Effects</emphasis>: Transfers ownership from u to *this as if by calling <computeroutput>reset(u.release())</computeroutput> followed by <computeroutput>get_deleter() = std::forward&lt;D&gt;(u.get_deleter())</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: *this. </para></description></copy-assignment>
<copy-assignment cv="noexcept"><type><classname>unique_ptr</classname> &amp;</type><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="E"/>
        </template><parameter name="u"><paramtype><classname>unique_ptr</classname>&lt; U, E &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: If E is not a reference type, assignment of the deleter from an rvalue of type E shall be well-formed and shall not throw an exception. Otherwise, E is a reference type and assignment of the deleter from an lvalue of type E shall be well-formed and shall not throw an exception.</para><para><emphasis role="bold">Remarks</emphasis>: This operator shall not participate in overload resolution unless:<itemizedlist>
<listitem><para><computeroutput>unique_ptr&lt;U, E&gt;::pointer</computeroutput> is implicitly convertible to pointer and</para>
</listitem><listitem><para>U is not an array type.</para>
</listitem></itemizedlist>
</para><para><emphasis role="bold">Effects</emphasis>: Transfers ownership from u to *this as if by calling <computeroutput>reset(u.release())</computeroutput> followed by <computeroutput>get_deleter() = std::forward&lt;E&gt;(u.get_deleter())</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: *this. </para></description></copy-assignment>
<copy-assignment cv="noexcept"><type><classname>unique_ptr</classname> &amp;</type><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: <computeroutput>reset()</computeroutput>.</para><para><emphasis role="bold">Postcondition</emphasis>: <computeroutput>get() == nullptr</computeroutput></para><para><emphasis role="bold">Returns</emphasis>: *this. </para></description></copy-assignment>
</class><function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="x"><paramtype><classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Calls <computeroutput>x.swap(y)</computeroutput>. </para></description></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="D1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T1, D1 &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>unique_ptr</classname>&lt; T2, D2 &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>x.get() == y.get()</computeroutput>. </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="D1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T1, D1 &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>unique_ptr</classname>&lt; T2, D2 &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>x.get() != y.get()</computeroutput>. </para></description></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="D1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T1, D1 &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>unique_ptr</classname>&lt; T2, D2 &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: x.get() &lt; y.get().</para><para><emphasis role="bold">Remarks</emphasis>: This comparison shall induce a strict weak ordering betwen pointers. </para></description></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="D1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T1, D1 &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>unique_ptr</classname>&lt; T2, D2 &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: !(y &lt; x). </para></description></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="D1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T1, D1 &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>unique_ptr</classname>&lt; T2, D2 &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: y &lt; x. </para></description></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="D1"/>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T1, D1 &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>unique_ptr</classname>&lt; T2, D2 &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>:!(x &lt; y). </para></description></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>:!x. </para></description></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>:!x. </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: (bool)x. </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: (bool)x. </para></description></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>operator </computeroutput> shall induce a strict weak ordering on unique_ptr&lt;T, D&gt;::pointer values.</para><para><emphasis role="bold">Returns</emphasis>: Returns <computeroutput>x.get() &lt; pointer()</computeroutput>. </para></description></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>operator </computeroutput> shall induce a strict weak ordering on unique_ptr&lt;T, D&gt;::pointer values.</para><para><emphasis role="bold">Returns</emphasis>: Returns <computeroutput>pointer() &lt; x.get()</computeroutput>. </para></description></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>nullptr &lt; x</computeroutput>. </para></description></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>x &lt; nullptr</computeroutput>. </para></description></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>!(nullptr &lt; x)</computeroutput>. </para></description></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>!(x &lt; nullptr)</computeroutput>. </para></description></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>!(x &lt; nullptr)</computeroutput>. </para></description></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name=""><paramtype>std::nullptr_t</paramtype></parameter><parameter name="x"><paramtype>const <classname>unique_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>!(nullptr &lt; x)</computeroutput>. </para></description></function>


















</namespace>



















</namespace>
</header>
<header name="boost/move/utility.hpp">
<para>This header includes core utilities from <computeroutput>&lt;boost/move/utility_core.hpp&gt;</computeroutput> and defines some more advanced utilities such as: </para><namespace name="boost">



<function name="move_if_noexcept"><type>rvalue_reference_or_const_lvalue_reference</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>input_reference</paramtype></parameter><description><para>This function provides a way to convert a reference into a rvalue reference in compilers with rvalue references. For other compilers converts T &amp; into <emphasis>::boost::rv&lt;T&gt; &amp;</emphasis> so that move emulation is activated. Reference would be converted to rvalue reference only if input type is nothrow move constructible or if it has no copy constructor. In all other cases const reference would be returned </para></description></function>















</namespace>
</header>
<header name="boost/move/utility_core.hpp">
<para>This header defines core utilities to ease the development of move-aware functions. This header minimizes dependencies from other libraries. </para><namespace name="boost">
<struct name="enable_move_utility_emulation"><template>
      <template-type-parameter name="T"/>
    </template><description><para>This trait's internal boolean <computeroutput>value</computeroutput> is false in compilers with rvalue references and true in compilers without rvalue references.</para><para>A user can specialize this trait for a type T to false to SFINAE out <computeroutput>move</computeroutput> and <computeroutput>forward</computeroutput> so that the user can define a different move emulation for that type in namespace boost (e.g. another Boost library for its types) and avoid any overload ambiguity. </para></description><data-member name="value" specifiers="static"><type>const bool</type></data-member>
</struct><function name="move"><type>rvalue_reference</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>input_reference</paramtype></parameter><description><para>This function provides a way to convert a reference into a rvalue reference in compilers with rvalue references. For other compilers if <computeroutput>T</computeroutput> is Boost.Move enabled type then it converts <computeroutput>T&amp;</computeroutput> into <computeroutput>::boost::rv&lt;T&gt; &amp;</computeroutput> so that move emulation is activated, else it returns <computeroutput>T &amp;</computeroutput>. </para></description></function>
<function name="forward"><type>output_reference</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>input_reference</paramtype></parameter><description><para>This function provides limited form of forwarding that is usually enough for in-place construction and avoids the exponential overloading for achieve the limited forwarding in C++03.</para><para>For compilers with rvalue references this function provides perfect forwarding.</para><para>Otherwise:<itemizedlist>
<listitem><para>If input_reference binds to const ::boost::rv&lt;T&gt; &amp; then it output_reference is ::boost::rv&lt;T&gt; &amp;</para>
</listitem><listitem><para>Else, output_reference is equal to input_reference. </para>
</listitem></itemizedlist>
</para></description></function>
<function name="move_if_not_lvalue_reference"><type>output_reference</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>input_reference</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Calls <computeroutput>boost::move</computeroutput> if <computeroutput>input_reference</computeroutput> is not a lvalue reference. Otherwise returns the reference </para></description></function>
















</namespace>
</header>
</library-reference>