<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Literal Types and constexpr Support</title>
<link rel="stylesheet" href="../../multiprecision.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.Multiprecision">
<link rel="up" href="../tut.html" title="Tutorial">
<link rel="prev" href="primetest.html" title="Primality Testing">
<link rel="next" href="import_export.html" title="Importing and Exporting Data to and from cpp_int and cpp_bin_float">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="primetest.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../tut.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="import_export.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_multiprecision.tut.lits"></a><a class="link" href="lits.html" title="Literal Types and constexpr Support">Literal Types and <code class="computeroutput"><span class="keyword">constexpr</span></code> Support</a>
</h3></div></div></div>
<p>
        There are two kinds of <code class="computeroutput"><span class="keyword">constexpr</span></code>
        support in this library:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            The more basic version requires only C++11 and allow the construction
            of some number types as literals.
          </li>
<li class="listitem">
            The more advanced support permits constexpr arithmetic and requires at
            least C++14 constexpr support, and for many operations C++2a support
          </li>
</ul></div>
<h5>
<a name="boost_multiprecision.tut.lits.h0"></a>
        <span class="phrase"><a name="boost_multiprecision.tut.lits.declaring_numeric_literals"></a></span><a class="link" href="lits.html#boost_multiprecision.tut.lits.declaring_numeric_literals">Declaring
        numeric literals</a>
      </h5>
<p>
        There are two backend types which are literals:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a class="link" href="floats/float128.html" title="float128">float128</a>
            (which requires GCC), and
          </li>
<li class="listitem">
            Instantiations of <code class="computeroutput"><span class="identifier">cpp_int_backend</span></code>
            where the Allocator parameter is type <code class="computeroutput"><span class="keyword">void</span></code>.
            In addition, prior to C++14 the Checked parameter must be <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">::</span><span class="identifier">unchecked</span></code>.
          </li>
</ul></div>
<p>
        For example:
      </p>
<pre class="programlisting"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">;</span>

<span class="keyword">constexpr</span> <span class="identifier">float128</span>            <span class="identifier">f</span> <span class="special">=</span> <span class="number">0.1</span><span class="identifier">Q</span>   <span class="comment">// OK, float128's are always literals in C++11</span>

<span class="keyword">constexpr</span> <span class="identifier">int128_t</span>            <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>     <span class="comment">// OK, fixed precision int128_t has no allocator.</span>
<span class="keyword">constexpr</span> <span class="identifier">uint1024_t</span>          <span class="identifier">j</span> <span class="special">=</span> <span class="number">0</span><span class="identifier">xFFFFFFFF00000000uLL</span><span class="special">;</span>  <span class="comment">// OK, fixed precision uint1024_t has no allocator.</span>

<span class="keyword">constexpr</span> <span class="identifier">checked_uint128_t</span>   <span class="identifier">k</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span> <span class="comment">// OK from C++14 and later, not supported for C++11.</span>
<span class="keyword">constexpr</span> <span class="identifier">checked_uint128_t</span>   <span class="identifier">k</span> <span class="special">=</span> <span class="special">-</span><span class="number">1</span><span class="special">;</span> <span class="comment">// Error, as this would normally lead to a runtime failure (exception).</span>
<span class="keyword">constexpr</span> <span class="identifier">cpp_int</span>             <span class="identifier">l</span> <span class="special">=</span> <span class="number">2</span><span class="special">;</span>  <span class="comment">// Error, type is not a literal as it performs memory management.</span>
</pre>
<p>
        There is also support for user defined-literals with <a class="link" href="ints/cpp_int.html" title="cpp_int">cpp_int</a>
        - these are limited to unchecked, fixed precision <code class="computeroutput"><span class="identifier">cpp_int</span></code>'s
        which are specified in hexadecimal notation. The suffixes supported are:
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Suffix
                </p>
              </th>
<th>
                <p>
                  Meaning
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  _cppi
                </p>
              </td>
<td>
                <p>
                  Specifies a value of type: <code class="computeroutput"><span class="identifier">number</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">signed_magnitude</span><span class="special">,</span><span class="identifier">unchecked</span><span class="special">,</span><span class="keyword">void</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>,
                  where N is chosen to contain just enough digits to hold the number
                  specified.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  _cppui
                </p>
              </td>
<td>
                <p>
                  Specifies a value of type: <code class="computeroutput"><span class="identifier">number</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">unsigned_magnitude</span><span class="special">,</span><span class="identifier">unchecked</span><span class="special">,</span><span class="keyword">void</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>,
                  where N is chosen to contain just enough digits to hold the number
                  specified.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  _cppi<span class="emphasis"><em>N</em></span>
                </p>
              </td>
<td>
                <p>
                  Specifies a value of type <code class="computeroutput"><span class="identifier">number</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">signed_magnitude</span><span class="special">,</span><span class="identifier">unchecked</span><span class="special">,</span><span class="keyword">void</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>.
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  _cppui<span class="emphasis"><em>N</em></span>
                </p>
              </td>
<td>
                <p>
                  Specifies a value of type <code class="computeroutput"><span class="identifier">number</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">N</span><span class="special">,</span><span class="identifier">signed_magnitude</span><span class="special">,</span><span class="identifier">unchecked</span><span class="special">,</span><span class="keyword">void</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>.
                </p>
              </td>
</tr>
</tbody>
</table></div>
<p>
        In each case, use of these suffixes with hexadecimal values produces a <code class="computeroutput"><span class="keyword">constexpr</span></code> result.
      </p>
<p>
        Examples:
      </p>
<pre class="programlisting"><span class="comment">// Any use of user defined literals requires that we import the literal-operators into current scope first:</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">::</span><span class="identifier">literals</span><span class="special">;</span>
<span class="comment">//</span>
<span class="comment">// To keep things simple in the example, we'll make our types used visible to this scope as well:</span>
<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">;</span>
<span class="comment">//</span>
<span class="comment">// The value zero as a number&lt;cpp_int_backend&lt;4,4,signed_magnitude,unchecked,void&gt; &gt;:</span>
<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="identifier">a</span> <span class="special">=</span> <span class="number">0x0</span><span class="identifier">_cppi</span><span class="special">;</span>
<span class="comment">// The type of each constant has 4 bits per hexadecimal digit,</span>
<span class="comment">// so this is of type uint256_t (ie number&lt;cpp_int_backend&lt;256,256,unsigned_magnitude,unchecked,void&gt; &gt;):</span>
<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="identifier">b</span> <span class="special">=</span> <span class="number">0</span><span class="identifier">xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF_cppui</span><span class="special">;</span>
<span class="comment">//</span>
<span class="comment">// Smaller values can be assigned to larger values:</span>
<span class="identifier">int256_t</span> <span class="identifier">c</span> <span class="special">=</span> <span class="number">0x1234</span><span class="identifier">_cppi</span><span class="special">;</span> <span class="comment">// OK</span>
<span class="comment">//</span>
<span class="comment">// However, this only works in constexpr contexts from C++14 onwards:</span>
<span class="keyword">constexpr</span> <span class="identifier">int256_t</span> <span class="identifier">d</span> <span class="special">=</span> <span class="number">0x1</span><span class="identifier">_cppi</span><span class="special">;</span> <span class="comment">// Compiler error in C++11, requires C++14</span>
<span class="comment">//</span>
<span class="comment">// Constants can be padded out with leading zeros to generate wider types:</span>
<span class="keyword">constexpr</span> <span class="identifier">uint256_t</span> <span class="identifier">e</span> <span class="special">=</span> <span class="number">0</span><span class="identifier">x0000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFF_cppui</span><span class="special">;</span> <span class="comment">// OK</span>
<span class="comment">//</span>
<span class="comment">// However, specific-width types are best produced with specific-width suffixes,</span>
<span class="comment">// ones supported by default are `_cpp[u]i128`, `_cpp[u]i256`, `_cpp[u]i512`, `_cpp[u]i1024`.</span>
<span class="comment">//</span>
<span class="keyword">constexpr</span> <span class="identifier">int128_t</span> <span class="identifier">f</span> <span class="special">=</span> <span class="number">0x1234</span><span class="identifier">_cppi128</span><span class="special">;</span> <span class="comment">// OK, always produces an int128_t as the result.</span>
<span class="keyword">constexpr</span> <span class="identifier">uint1024_t</span> <span class="identifier">g</span> <span class="special">=</span> <span class="number">0</span><span class="identifier">xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbccccccccccccccccccccc_cppui1024</span><span class="special">;</span> <span class="comment">// OK,</span>
<span class="comment">//  always produces an uint1024_t as the result.</span>
<span class="comment">//</span>
<span class="comment">// If other specific-width types are required, then there is a macro for generating the operators for these.</span>
<span class="comment">// The macro can be used at namespace scope only:</span>
<span class="comment">//</span>
<span class="identifier">BOOST_MP_DEFINE_SIZED_CPP_INT_LITERAL</span><span class="special">(</span><span class="number">2048</span><span class="special">);</span>
<span class="comment">//</span>
<span class="comment">// Now we can create 2048-bit literals as well:</span>
<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="identifier">h</span> <span class="special">=</span> <span class="number">0xff</span><span class="identifier">_cppi2048</span><span class="special">;</span> <span class="comment">// h is of type number&lt;cpp_int_backend&lt;2048,2048,signed_magnitude,unchecked,void&gt; &gt;</span>
<span class="comment">//</span>
<span class="comment">// Finally, negative values are handled via the unary minus operator:</span>
<span class="comment">//</span>
<span class="keyword">constexpr</span> <span class="identifier">int1024_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="special">-</span><span class="number">0</span><span class="identifier">xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF_cppui1024</span><span class="special">;</span>
<span class="comment">//</span>
<span class="comment">// Which means this also works:</span>
<span class="keyword">constexpr</span> <span class="identifier">int1024_t</span> <span class="identifier">j</span> <span class="special">=</span> <span class="special">-</span><span class="identifier">g</span><span class="special">;</span>   <span class="comment">// OK: unary minus operator is constexpr.</span>
</pre>
<h5>
<a name="boost_multiprecision.tut.lits.h1"></a>
        <span class="phrase"><a name="boost_multiprecision.tut.lits.constexpr_arithmetic"></a></span><a class="link" href="lits.html#boost_multiprecision.tut.lits.constexpr_arithmetic">constexpr
        arithmetic</a>
      </h5>
<p>
        The front end of the library is all <code class="computeroutput"><span class="keyword">constexpr</span></code>
        from C++14 and later. Currently there are only two backend types that are
        <code class="computeroutput"><span class="keyword">constexpr</span></code> aware: __float128
        and <a class="link" href="ints/cpp_int.html" title="cpp_int">cpp_int</a>.
        More backends will follow at a later date.
      </p>
<p>
        Provided the compiler is GCC, type <a class="link" href="floats/float128.html" title="float128">float128</a>
        support <code class="computeroutput"><span class="keyword">constexpr</span></code> operations
        on all arithmetic operations from C++14, comparisons, <code class="computeroutput"><span class="identifier">abs</span></code>,
        <code class="computeroutput"><span class="identifier">fabs</span></code>, <code class="computeroutput"><span class="identifier">fpclassify</span></code>,
        <code class="computeroutput"><span class="identifier">isnan</span></code>, <code class="computeroutput"><span class="identifier">isinf</span></code>,
        <code class="computeroutput"><span class="identifier">isfinite</span></code> and <code class="computeroutput"><span class="identifier">isnormal</span></code> are also fully supported, but
        the transcendental functions are not.
      </p>
<p>
        The <a class="link" href="ints/cpp_int.html" title="cpp_int">cpp_int</a>
        types support constexpr arithmetic, provided it is a fixed precision type
        with no allocator. It may also be a checked integer: in which case a compiler
        error will be generated on overflow or undefined behaviour. In addition the
        free functions <code class="computeroutput"><span class="identifier">abs</span></code>, <code class="computeroutput"><span class="identifier">swap</span></code>, <code class="computeroutput"><span class="identifier">multiply</span></code>,
        <code class="computeroutput"><span class="identifier">add</span></code>, <code class="computeroutput"><span class="identifier">subtract</span></code>,
        <code class="computeroutput"><span class="identifier">divide_qr</span></code>, <code class="computeroutput"><span class="identifier">integer_modulus</span></code>, <code class="computeroutput"><span class="identifier">powm</span></code>,
        <code class="computeroutput"><span class="identifier">lsb</span></code>, <code class="computeroutput"><span class="identifier">msb</span></code>,
        <code class="computeroutput"><span class="identifier">bit_test</span></code>, <code class="computeroutput"><span class="identifier">bit_set</span></code>,
        <code class="computeroutput"><span class="identifier">bit_unset</span></code>, <code class="computeroutput"><span class="identifier">bit_flip</span></code>, <code class="computeroutput"><span class="identifier">sqrt</span></code>,
        <code class="computeroutput"><span class="identifier">gcd</span></code>, <code class="computeroutput"><span class="identifier">lcm</span></code>
        are all supported. Use of <a class="link" href="ints/cpp_int.html" title="cpp_int">cpp_int</a>
        in this way requires either a C++2a compiler (one which supports <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_constant_evaluated</span><span class="special">()</span></code> - currently only gcc-9 or clang-9 or later),
        or GCC-6 or later in C++14 mode. Compilers other than GCC and without <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_constant_evaluated</span><span class="special">()</span></code> will support a very limited set of operations:
        expect to hit roadblocks rather easily.
      </p>
<p>
        See <a href="https://en.cppreference.com/w/cpp/compiler_support" target="_top">compiler
        support</a> for <a href="https://en.cppreference.com/w/cpp/types/is_constant_evaluated" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_constant_evaluated</span></code></a>;
      </p>
<p>
        For example given:
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">math</span><span class="special">/</span><span class="identifier">constants</span><span class="special">/</span><span class="identifier">constants</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span> <span class="comment">// For constant pi with full precision of type T.</span>
<span class="comment">// using  boost::math::constants::pi;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="identifier">T</span> <span class="identifier">circumference</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">radius</span><span class="special">)</span>
<span class="special">{</span>
   <span class="keyword">return</span> <span class="number">2</span> <span class="special">*</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">math</span><span class="special">::</span><span class="identifier">constants</span><span class="special">::</span><span class="identifier">pi</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;()</span> <span class="special">*</span> <span class="identifier">radius</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="identifier">T</span> <span class="identifier">area</span><span class="special">(</span><span class="identifier">T</span> <span class="identifier">radius</span><span class="special">)</span>
<span class="special">{</span>
   <span class="keyword">return</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">math</span><span class="special">::</span><span class="identifier">constants</span><span class="special">::</span><span class="identifier">pi</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;()</span> <span class="special">*</span> <span class="identifier">radius</span> <span class="special">*</span> <span class="identifier">radius</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        We can now calculate areas and circumferences, using all compile-time <code class="computeroutput"><span class="keyword">constexpr</span></code> arithmetic:
      </p>
<pre class="programlisting"><span class="keyword">using</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">::</span><span class="identifier">float128</span><span class="special">;</span>

<span class="keyword">constexpr</span> <span class="identifier">float128</span> <span class="identifier">radius</span> <span class="special">=</span> <span class="number">2.25</span><span class="special">;</span>
<span class="keyword">constexpr</span> <span class="identifier">float128</span> <span class="identifier">c</span>      <span class="special">=</span> <span class="identifier">circumference</span><span class="special">(</span><span class="identifier">radius</span><span class="special">);</span>
<span class="keyword">constexpr</span> <span class="identifier">float128</span> <span class="identifier">a</span>      <span class="special">=</span> <span class="identifier">area</span><span class="special">(</span><span class="identifier">radius</span><span class="special">);</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Circumference = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">c</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Area = "</span> <span class="special">&lt;&lt;</span> <span class="identifier">a</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
        Note that these make use of the numeric constants from the <a href="https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/constants.html" target="_top">Boost.Math
        constants</a> library, which also happen to be <code class="computeroutput"><span class="keyword">constexpr</span></code>.
        These usually have the full precision of the floating-point type, here 128-bit,
        about 36 decimal digits.
      </p>
<h6>
<a name="boost_multiprecision.tut.lits.h2"></a>
        <span class="phrase"><a name="boost_multiprecision.tut.lits.hermite_poly_coeffics"></a></span><a class="link" href="lits.html#boost_multiprecision.tut.lits.hermite_poly_coeffics">Calculating
        Hermite Polynomial coefficients at compile time</a>
      </h6>
<p>
        For a more interesting example, in <a href="http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/../../example/constexpr_float_arithmetic_examples.cpp" target="_top">constexpr_float_arithmetic_examples.cpp</a>
        we define a simple class for <code class="computeroutput"><span class="keyword">constexpr</span></code>
        polynomial arithmetic:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">Order</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">const_polynomial</span><span class="special">;</span>
</pre>
<p>
        Given this, we can use recurrence relations to calculate the coefficients
        for various orthogonal polynomials - in the example we use the Hermite polynomials.
        Only the constructor does any work - it uses the recurrence relations to
        calculate the coefficient array:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">Order</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">hermite_polynomial</span>
<span class="special">{</span>
   <span class="identifier">const_polynomial</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">Order</span><span class="special">&gt;</span> <span class="identifier">m_data</span><span class="special">;</span>

 <span class="keyword">public</span><span class="special">:</span>
   <span class="keyword">constexpr</span> <span class="identifier">hermite_polynomial</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">m_data</span><span class="special">(</span><span class="identifier">hermite_polynomial</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">Order</span> <span class="special">-</span> <span class="number">1</span><span class="special">&gt;().</span><span class="identifier">data</span><span class="special">()</span> <span class="special">*</span> <span class="identifier">const_polynomial</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="number">1</span><span class="special">&gt;{</span><span class="number">0</span><span class="special">,</span> <span class="number">2</span><span class="special">}</span> <span class="special">-</span> <span class="identifier">hermite_polynomial</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">Order</span> <span class="special">-</span> <span class="number">1</span><span class="special">&gt;().</span><span class="identifier">data</span><span class="special">().</span><span class="identifier">derivative</span><span class="special">())</span>
   <span class="special">{</span>
   <span class="special">}</span>
   <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="identifier">const_polynomial</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">Order</span><span class="special">&gt;&amp;</span> <span class="identifier">data</span><span class="special">()</span> <span class="keyword">const</span>
   <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">m_data</span><span class="special">;</span>
   <span class="special">}</span>
   <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">[](</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">N</span><span class="special">)</span><span class="keyword">const</span>
   <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">m_data</span><span class="special">[</span><span class="identifier">N</span><span class="special">];</span>
   <span class="special">}</span>
   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span>
   <span class="keyword">constexpr</span> <span class="identifier">T</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">U</span> <span class="identifier">val</span><span class="special">)</span><span class="keyword">const</span>
   <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">m_data</span><span class="special">(</span><span class="identifier">val</span><span class="special">);</span>
   <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        Now we just need to define <span class="emphasis"><em>H<sub>0</sub></em></span> and <span class="emphasis"><em>H<sub>1</sub></em></span>
        as termination conditions for the recurrence:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">hermite_polynomial</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="number">0</span><span class="special">&gt;</span>
<span class="special">{</span>
   <span class="identifier">const_polynomial</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="number">0</span><span class="special">&gt;</span> <span class="identifier">m_data</span><span class="special">;</span>

 <span class="keyword">public</span><span class="special">:</span>
   <span class="keyword">constexpr</span> <span class="identifier">hermite_polynomial</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">m_data</span><span class="special">{</span><span class="number">1</span><span class="special">}</span> <span class="special">{}</span>
   <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="identifier">const_polynomial</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="number">0</span><span class="special">&gt;&amp;</span> <span class="identifier">data</span><span class="special">()</span> <span class="keyword">const</span>
   <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">m_data</span><span class="special">;</span>
   <span class="special">}</span>
   <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">[](</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">N</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">m_data</span><span class="special">[</span><span class="identifier">N</span><span class="special">];</span>
   <span class="special">}</span>
   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span>
   <span class="keyword">constexpr</span> <span class="identifier">T</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">U</span> <span class="identifier">val</span><span class="special">)</span>
   <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">m_data</span><span class="special">(</span><span class="identifier">val</span><span class="special">);</span>
   <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">hermite_polynomial</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="number">1</span><span class="special">&gt;</span>
<span class="special">{</span>
   <span class="identifier">const_polynomial</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="number">1</span><span class="special">&gt;</span> <span class="identifier">m_data</span><span class="special">;</span>

 <span class="keyword">public</span><span class="special">:</span>
   <span class="keyword">constexpr</span> <span class="identifier">hermite_polynomial</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">m_data</span><span class="special">{</span><span class="number">0</span><span class="special">,</span> <span class="number">2</span><span class="special">}</span> <span class="special">{}</span>
   <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="identifier">const_polynomial</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="number">1</span><span class="special">&gt;&amp;</span> <span class="identifier">data</span><span class="special">()</span> <span class="keyword">const</span>
   <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">m_data</span><span class="special">;</span>
   <span class="special">}</span>
   <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">[](</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">N</span><span class="special">)</span> <span class="keyword">const</span>
   <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">m_data</span><span class="special">[</span><span class="identifier">N</span><span class="special">];</span>
   <span class="special">}</span>
   <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span>
   <span class="keyword">constexpr</span> <span class="identifier">T</span> <span class="keyword">operator</span><span class="special">()(</span><span class="identifier">U</span> <span class="identifier">val</span><span class="special">)</span>
   <span class="special">{</span>
      <span class="keyword">return</span> <span class="identifier">m_data</span><span class="special">(</span><span class="identifier">val</span><span class="special">);</span>
   <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        We can now declare <span class="emphasis"><em>H<sub>9</sub></em></span> as a <code class="computeroutput"><span class="keyword">constexpr</span></code>
        object, access the coefficients, and evaluate at an abscissa value, all at
        compile-time using <code class="computeroutput"><span class="keyword">constexpr</span></code>
        arithmetic:
      </p>
<pre class="programlisting"><span class="keyword">constexpr</span> <span class="identifier">hermite_polynomial</span><span class="special">&lt;</span><span class="identifier">float128</span><span class="special">,</span> <span class="number">9</span><span class="special">&gt;</span> <span class="identifier">h9</span><span class="special">;</span>
<span class="comment">//</span>
<span class="comment">// Verify that the polynomial's coefficients match the known values:</span>
<span class="comment">//</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">h9</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">==</span> <span class="number">0</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">h9</span><span class="special">[</span><span class="number">1</span><span class="special">]</span> <span class="special">==</span> <span class="number">30240</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">h9</span><span class="special">[</span><span class="number">2</span><span class="special">]</span> <span class="special">==</span> <span class="number">0</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">h9</span><span class="special">[</span><span class="number">3</span><span class="special">]</span> <span class="special">==</span> <span class="special">-</span><span class="number">80640</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">h9</span><span class="special">[</span><span class="number">4</span><span class="special">]</span> <span class="special">==</span> <span class="number">0</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">h9</span><span class="special">[</span><span class="number">5</span><span class="special">]</span> <span class="special">==</span> <span class="number">48384</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">h9</span><span class="special">[</span><span class="number">6</span><span class="special">]</span> <span class="special">==</span> <span class="number">0</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">h9</span><span class="special">[</span><span class="number">7</span><span class="special">]</span> <span class="special">==</span> <span class="special">-</span><span class="number">9216</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">h9</span><span class="special">[</span><span class="number">8</span><span class="special">]</span> <span class="special">==</span> <span class="number">0</span><span class="special">);</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">h9</span><span class="special">[</span><span class="number">9</span><span class="special">]</span> <span class="special">==</span> <span class="number">512</span><span class="special">);</span>
<span class="comment">//</span>
<span class="comment">// Define an abscissa value to evaluate at:</span>
<span class="keyword">constexpr</span> <span class="identifier">float128</span> <span class="identifier">abscissa</span><span class="special">(</span><span class="number">0.5</span><span class="special">);</span>
<span class="comment">//</span>
<span class="comment">// Evaluate H_9(0.5) using all constexpr arithmetic, and check that it has the expected result:</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">h9</span><span class="special">(</span><span class="identifier">abscissa</span><span class="special">)</span> <span class="special">==</span> <span class="number">6481</span><span class="special">);</span>
</pre>
<p>
        See <a href="http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/../../example/constexpr_float_arithmetic_examples.cpp" target="_top">constexpr_float_arithmetic_examples.cpp</a>
        for working code.
      </p>
<p>
        Also since the coefficients to the Hermite polynomials are integers, we can
        also generate the Hermite coefficients using (fixed precision) <code class="computeroutput"><span class="identifier">cpp_int</span></code>s: see <a href="http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/../../test/constexpr_test_cpp_int_6.cpp" target="_top">constexpr_test_cpp_int_6.cpp</a>.
      </p>
<h6>
<a name="boost_multiprecision.tut.lits.h3"></a>
        <span class="phrase"><a name="boost_multiprecision.tut.lits.factorial_constexpr"></a></span><a class="link" href="lits.html#boost_multiprecision.tut.lits.factorial_constexpr"><code class="computeroutput"><span class="keyword">constexpr</span></code> Factorials</a>
      </h6>
<p>
        We can also generate integer factorials in <a href="http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/../../test/constexpr_test_cpp_int_5.cpp" target="_top">constexpr_test_cpp_int_5.cpp</a>
        like so:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">constexpr</span> <span class="identifier">T</span> <span class="identifier">factorial</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">a</span><span class="special">)</span>
<span class="special">{</span>
   <span class="keyword">return</span> <span class="identifier">a</span> <span class="special">?</span> <span class="identifier">a</span> <span class="special">*</span> <span class="identifier">factorial</span><span class="special">(</span><span class="identifier">a</span> <span class="special">-</span> <span class="number">1</span><span class="special">)</span> <span class="special">:</span> <span class="number">1</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        and validate the result:
      </p>
<pre class="programlisting"><span class="keyword">constexpr</span> <span class="identifier">uint1024_t</span> <span class="identifier">f1</span> <span class="special">=</span> <span class="identifier">factorial</span><span class="special">(</span><span class="identifier">uint1024_t</span><span class="special">(</span><span class="number">31</span><span class="special">));</span> <span class="comment">// Factorial 31!</span>
<span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">f1</span> <span class="special">==</span> <span class="number">0</span><span class="identifier">x1956ad0aae33a4560c5cd2c000000_cppi</span><span class="special">);</span> <span class="comment">// Expected result as an Boost.Multiprecision integer literal. </span>
</pre>
<h6>
<a name="boost_multiprecision.tut.lits.h4"></a>
        <span class="phrase"><a name="boost_multiprecision.tut.lits.random_constexpr"></a></span><a class="link" href="lits.html#boost_multiprecision.tut.lits.random_constexpr">Random
        <code class="computeroutput"><span class="keyword">constexpr</span></code> values</a>
      </h6>
<p>
        Another example in <a href="http://www.boost.org/doc/libs/release/libs/multiprecision/doc/html/../../test/constexpr_test_cpp_int_7.cpp" target="_top">constexpr_test_cpp_int_7.cpp</a>
        generates a fresh multiprecision random number each time the file is compiled.
        It includes an C++ template implementation of the <a href="https://en.wikipedia.org/wiki/KISS_(algorithm)" target="_top">KISS
        random number algorithm by George Marsaglia</a> for <code class="computeroutput"><span class="identifier">cpp_int</span></code>
        integers.
      </p>
<pre class="programlisting"><span class="keyword">constexpr</span> <span class="identifier">uint1024_t</span> <span class="identifier">rand</span> <span class="special">=</span> <span class="identifier">nth_random_value</span><span class="special">&lt;</span><span class="identifier">uint1024_t</span><span class="special">&gt;(</span><span class="number">1000</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">hex</span> <span class="special">&lt;&lt;</span> <span class="identifier">rand</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
        See also the <a class="link" href="random.html" title="Generating Random Numbers">random number
        generation</a> section.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2002-2020 John
      Maddock and Christopher Kormanyos<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="primetest.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../tut.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="import_export.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
