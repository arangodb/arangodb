<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>Boost.Hana: Functional</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.7.1</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group-functional.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Functional</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>General purpose function objects. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga835970cb25a0c8dc200f1e5f8943538b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">boost::hana::always</a></td></tr>
<tr class="memdesc:ga835970cb25a0c8dc200f1e5f8943538b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a constant function returning <code>x</code> regardless of the argument(s) it is invoked with.  <a href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">More...</a><br /></td></tr>
<tr class="separator:ga835970cb25a0c8dc200f1e5f8943538b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30027c383676084be151ef3c6cf2829f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">boost::hana::apply</a></td></tr>
<tr class="memdesc:ga30027c383676084be151ef3c6cf2829f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a Callable with the given arguments.  <a href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">More...</a><br /></td></tr>
<tr class="separator:ga30027c383676084be151ef3c6cf2829f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6acc765a35c4dc85f0deab4785831a3d"><td class="memTemplParams" colspan="2">template&lt;std::size_t n&gt; </td></tr>
<tr class="memitem:ga6acc765a35c4dc85f0deab4785831a3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga6acc765a35c4dc85f0deab4785831a3d">boost::hana::arg</a></td></tr>
<tr class="memdesc:ga6acc765a35c4dc85f0deab4785831a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <code>n</code>th passed argument.  <a href="group__group-functional.html#ga6acc765a35c4dc85f0deab4785831a3d">More...</a><br /></td></tr>
<tr class="separator:ga6acc765a35c4dc85f0deab4785831a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ada6b336e9d5bcb101ff0c737acbd0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></td></tr>
<tr class="memdesc:ga41ada6b336e9d5bcb101ff0c737acbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function capturing the given variables.  <a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">More...</a><br /></td></tr>
<tr class="separator:ga41ada6b336e9d5bcb101ff0c737acbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b16146e53efcdf9ecbb9a7b21f8cd0b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">boost::hana::compose</a></td></tr>
<tr class="memdesc:ga3b16146e53efcdf9ecbb9a7b21f8cd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the composition of two functions or more.  <a href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">More...</a><br /></td></tr>
<tr class="separator:ga3b16146e53efcdf9ecbb9a7b21f8cd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49ea872ade5ac8f6c10052c495302e89"><td class="memTemplParams" colspan="2">template&lt;std::size_t n&gt; </td></tr>
<tr class="memitem:ga49ea872ade5ac8f6c10052c495302e89"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga49ea872ade5ac8f6c10052c495302e89">boost::hana::curry</a></td></tr>
<tr class="memdesc:ga49ea872ade5ac8f6c10052c495302e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Curry a function up to the given number of arguments.  <a href="group__group-functional.html#ga49ea872ade5ac8f6c10052c495302e89">More...</a><br /></td></tr>
<tr class="separator:ga49ea872ade5ac8f6c10052c495302e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c6f17b58ce527c7650eb878f01f2cd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga8c6f17b58ce527c7650eb878f01f2cd2">boost::hana::mathtt</a></td></tr>
<tr class="memdesc:ga8c6f17b58ce527c7650eb878f01f2cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function with the results of invoking other functions on its arguments.  <a href="group__group-functional.html#ga8c6f17b58ce527c7650eb878f01f2cd2">More...</a><br /></td></tr>
<tr class="separator:ga8c6f17b58ce527c7650eb878f01f2cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1393f40da2e8da6e0c12fce953e56a6c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">boost::hana::fix</a></td></tr>
<tr class="memdesc:ga1393f40da2e8da6e0c12fce953e56a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a function computing the fixed point of a function.  <a href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">More...</a><br /></td></tr>
<tr class="separator:ga1393f40da2e8da6e0c12fce953e56a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga004f884cdbb85c2efe3383c1db450094"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">boost::hana::flip</a></td></tr>
<tr class="memdesc:ga004f884cdbb85c2efe3383c1db450094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function with its two first arguments reversed.  <a href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">More...</a><br /></td></tr>
<tr class="separator:ga004f884cdbb85c2efe3383c1db450094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef38cf34324c8edbd3597ae71811d00d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">boost::hana::id</a></td></tr>
<tr class="memdesc:gaef38cf34324c8edbd3597ae71811d00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The identity function &ndash; returns its argument unchanged.  <a href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">More...</a><br /></td></tr>
<tr class="separator:gaef38cf34324c8edbd3597ae71811d00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bdafba6dc801f1d2d83731ad9714557"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">boost::hana::infix</a></td></tr>
<tr class="memdesc:ga7bdafba6dc801f1d2d83731ad9714557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an equivalent function that can also be applied in infix notation.  <a href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">More...</a><br /></td></tr>
<tr class="separator:ga7bdafba6dc801f1d2d83731ad9714557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca60c09e1f7a32a2b52baaf6515c279"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#gafca60c09e1f7a32a2b52baaf6515c279">boost::hana::lockstep</a></td></tr>
<tr class="memdesc:gafca60c09e1f7a32a2b52baaf6515c279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function with the result of invoking other functions on its arguments, in lockstep.  <a href="group__group-functional.html#gafca60c09e1f7a32a2b52baaf6515c279">More...</a><br /></td></tr>
<tr class="separator:gafca60c09e1f7a32a2b52baaf6515c279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35c4fc3c5677b9f558150b90e74d3ab1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">boost::hana::on</a></td></tr>
<tr class="memdesc:ga35c4fc3c5677b9f558150b90e74d3ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function with the result of invoking another function on each argument.  <a href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">More...</a><br /></td></tr>
<tr class="separator:ga35c4fc3c5677b9f558150b90e74d3ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e71bae315e299f9f5f9de77b012139"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga83e71bae315e299f9f5f9de77b012139">boost::hana::overload</a></td></tr>
<tr class="memdesc:ga83e71bae315e299f9f5f9de77b012139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick one of several functions to call based on overload resolution.  <a href="group__group-functional.html#ga83e71bae315e299f9f5f9de77b012139">More...</a><br /></td></tr>
<tr class="separator:ga83e71bae315e299f9f5f9de77b012139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa46de6f618d9f14edb1589b36b6e75ec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#gaa46de6f618d9f14edb1589b36b6e75ec">boost::hana::overload_linearly</a></td></tr>
<tr class="memdesc:gaa46de6f618d9f14edb1589b36b6e75ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the first function that produces a valid call expression.  <a href="group__group-functional.html#gaa46de6f618d9f14edb1589b36b6e75ec">More...</a><br /></td></tr>
<tr class="separator:gaa46de6f618d9f14edb1589b36b6e75ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778b2daa27882e71d28b6f2b38982ddf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga778b2daa27882e71d28b6f2b38982ddf">boost::hana::partial</a></td></tr>
<tr class="memdesc:ga778b2daa27882e71d28b6f2b38982ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partially apply a function to some arguments.  <a href="group__group-functional.html#ga778b2daa27882e71d28b6f2b38982ddf">More...</a><br /></td></tr>
<tr class="separator:ga778b2daa27882e71d28b6f2b38982ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefe9fd152cba94be71c2b5b9de689d23"><td class="memItemLeft" align="right" valign="top">constexpr unspecified&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">boost::hana::_</a> {}</td></tr>
<tr class="memdesc:gaefe9fd152cba94be71c2b5b9de689d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create simple functions representing C++ operators inline.  <a href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">More...</a><br /></td></tr>
<tr class="separator:gaefe9fd152cba94be71c2b5b9de689d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e648f0d3fc0209ec024e9d759a5e8f8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga6e648f0d3fc0209ec024e9d759a5e8f8">boost::hana::reverse_partial</a></td></tr>
<tr class="memdesc:ga6e648f0d3fc0209ec024e9d759a5e8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partially apply a function to some arguments.  <a href="group__group-functional.html#ga6e648f0d3fc0209ec024e9d759a5e8f8">More...</a><br /></td></tr>
<tr class="separator:ga6e648f0d3fc0209ec024e9d759a5e8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga835970cb25a0c8dc200f1e5f8943538b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga835970cb25a0c8dc200f1e5f8943538b">&#9670;&nbsp;</a></span>always</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::always</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="always_8hpp.html">boost/hana/functional/always.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; ...y) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> forwarded(x);</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="ttc" id="agroup__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables.</div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Return a constant function returning <code>x</code> regardless of the argument(s) it is invoked with. </p>
<p>Specifically, <code>always(x)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(x)(y...) == x</div>
<div class="ttc" id="agroup__group-functional_html_ga835970cb25a0c8dc200f1e5f8943538b"><div class="ttname"><a href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">boost::hana::always</a></div><div class="ttdeci">constexpr auto always</div><div class="ttdoc">Return a constant function returning x regardless of the argument(s) it is invoked with.</div><div class="ttdef"><b>Definition:</b> always.hpp:37</div></div>
</div><!-- fragment --><p> for any <code>y...</code>. A copy of <code>x</code> is made and it is owned by the <code>always(x)</code> function. When <code>always(x)</code> is called, it will return a reference to the <code>x</code> it owns. This reference is valid as long as <code>always(x)</code> is in scope.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="always_8hpp.html">boost/hana/functional/always.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">hana::always</a>(1)() == 1, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">hana::always</a>(<span class="charliteral">&#39;2&#39;</span>)(1, 2, 3) == <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="aalways_8hpp_html"><div class="ttname"><a href="always_8hpp.html">always.hpp</a></div><div class="ttdoc">Defines boost::hana::always.</div></div>
<div class="ttc" id="anamespaceboost_1_1hana_html"><div class="ttname"><a href="namespaceboost_1_1hana.html">boost::hana</a></div><div class="ttdoc">Namespace containing everything in the library.</div><div class="ttdef"><b>Definition:</b> accessors.hpp:20</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga30027c383676084be151ef3c6cf2829f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30027c383676084be151ef3c6cf2829f">&#9670;&nbsp;</a></span>apply</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::apply</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="apply_8hpp.html">boost/hana/functional/apply.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> forwarded(f)(forwarded(x)...);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Invokes a Callable with the given arguments. </p>
<p>This is equivalent to <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke">std::invoke</a> that will be added in C++17. However, <code>apply</code> is a function object instead of a function, which makes it possible to pass it to higher-order algorithms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A <a href="http://en.cppreference.com/w/cpp/named_req/Callable">Callable</a> to be invoked with the given arguments.</td></tr>
    <tr><td class="paramname">x...</td><td>The arguments to call <code>f</code> with. The number of <code>x...</code> must match the arity of <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md21"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="apply_8hpp.html">boost/hana/functional/apply.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plus_8hpp.html">boost/hana/plus.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">hana::apply</a>(<a class="code" href="group__group-_monoid.html#gaeb5d4a1e967e319712f9e4791948896c">hana::plus</a>, 1, 2) == 3, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="aapply_8hpp_html"><div class="ttname"><a href="apply_8hpp.html">apply.hpp</a></div><div class="ttdoc">Defines boost::hana::apply.</div></div>
<div class="ttc" id="agroup__group-_monoid_html_gaeb5d4a1e967e319712f9e4791948896c"><div class="ttname"><a href="group__group-_monoid.html#gaeb5d4a1e967e319712f9e4791948896c">boost::hana::plus</a></div><div class="ttdeci">constexpr auto plus</div><div class="ttdoc">Associative binary operation on a Monoid.</div><div class="ttdef"><b>Definition:</b> plus.hpp:47</div></div>
<div class="ttc" id="agroup__group-functional_html_ga30027c383676084be151ef3c6cf2829f"><div class="ttname"><a href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">boost::hana::apply</a></div><div class="ttdeci">constexpr auto apply</div><div class="ttdoc">Invokes a Callable with the given arguments.</div><div class="ttdef"><b>Definition:</b> apply.hpp:40</div></div>
<div class="ttc" id="aplus_8hpp_html"><div class="ttname"><a href="plus_8hpp.html">plus.hpp</a></div><div class="ttdoc">Defines boost::hana::plus.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga6acc765a35c4dc85f0deab4785831a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6acc765a35c4dc85f0deab4785831a3d">&#9670;&nbsp;</a></span>arg</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::arg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="arg_8hpp.html">boost/hana/functional/arg.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x1, ..., <span class="keyword">auto</span>&amp;&amp; xm) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> forwarded(xn);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the <code>n</code>th passed argument. </p>
<p>Specifically, <code>arg&lt;n&gt;(x1, ..., xn, ..., xm)</code> is equivalent to <code>xn</code>. Note that indexing starts at 1, so <code>arg&lt;1&gt;</code> returns the 1st argument, <code>arg&lt;2&gt;</code> the 2nd and so on. Using <code>arg&lt;0&gt;</code> is an error. Passing less than <code>n</code> arguments to <code>arg&lt;n&gt;</code> is also an error.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>An unsigned integer representing the argument to return. <code>n</code> must be positive (meaning nonzero).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1,...,xm</td><td>A variadic pack of arguments from which the <code>n</code>th one is returned.</td></tr>
  </table>
  </dd>
</dl>
<p>We could have chosen <code>arg</code> to be used like <code>arg(n)(x...)</code> instead of <code>arg&lt;n&gt;(x...)</code>. Provided all the arguments were of the same type, it would then be possible for <code>n</code> to only be known at runtime. However, we would then lose the ability to assert the in-boundedness of <code>n</code> statically.</p>
<h3><a class="anchor" id="autotoc_md23"></a>
Rationale for &lt;tt&gt;n&lt;/tt&gt; being a non-type template parameter</h3>
<p>I claim that the only interesting use case is with a compile-time <code>n</code>, which means that the usage would become <code>arg(int_&lt;n&gt;)(x...)</code>, which is more cumbersome to write than <code>arg&lt;n&gt;(x...)</code>. This is open for discussion. </p>
<h3><a class="anchor" id="autotoc_md24"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="arg_8hpp.html">boost/hana/functional/arg.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// hana::arg&lt;0&gt;(1, &#39;2&#39;, 3.3); // static assertion (regardless of the number of arguments)</span></div>
<div class="line">static_assert(hana::arg&lt;1&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3) == 1, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(hana::arg&lt;2&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3) == <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(hana::arg&lt;3&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3) == 3.3, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="comment">// hana::arg&lt;4&gt;(1, &#39;2&#39;, 3.3); // static assertion</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="aarg_8hpp_html"><div class="ttname"><a href="arg_8hpp.html">arg.hpp</a></div><div class="ttdoc">Defines boost::hana::arg.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga41ada6b336e9d5bcb101ff0c737acbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41ada6b336e9d5bcb101ff0c737acbd0">&#9670;&nbsp;</a></span>capture</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::capture</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="capture_8hpp.html">boost/hana/functional/capture.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; ...variables) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">            <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...args) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">                <span class="keywordflow">return</span> forwarded(f)(forwarded(variables)..., forwarded(args)...);</div>
<div class="line">            };</div>
<div class="line">        };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Create a function capturing the given variables. </p>
<p>Given 0 or more variables, <code>capture</code> creates a closure that can be used to partially apply a function. This is very similar to <code>partial</code>, except that <code>capture</code> allows the partially applied function to be specified later. Specifically, <code>capture(vars...)</code> is a function object taking a function <code>f</code> and returning <code>f</code> partially applied to <code>vars...</code>. In other words, </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>(vars...)(f)(args...) == f(vars..., args...)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The arity of <code>f</code> must match the total number of arguments passed to it, i.e. <code>sizeof...(vars) + sizeof...(args)</code>.</dd></dl>
<h2><a class="anchor" id="autotoc_md25"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="capture_8hpp.html">boost/hana/functional/capture.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> <a class="code" href="group__group-_foldable.html#ga650def4b2e98f4273d8b9b7aa5a2fc28">sum</a> = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {</div>
<div class="line">        <span class="keywordflow">return</span> x + y + z;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">hana::capture</a>(1, 2, 3)(<a class="code" href="group__group-_foldable.html#ga650def4b2e98f4273d8b9b7aa5a2fc28">sum</a>)() == 6);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">hana::capture</a>(1, 2)(<a class="code" href="group__group-_foldable.html#ga650def4b2e98f4273d8b9b7aa5a2fc28">sum</a>)(3) == 6);</div>
<div class="line">}</div>
<div class="ttc" id="aassert_8hpp_html"><div class="ttname"><a href="assert_8hpp.html">assert.hpp</a></div><div class="ttdoc">Defines macros to perform different kinds of assertions.</div></div>
<div class="ttc" id="acapture_8hpp_html"><div class="ttname"><a href="capture_8hpp.html">capture.hpp</a></div><div class="ttdoc">Defines boost::hana::capture.</div></div>
<div class="ttc" id="aconfig_8hpp_html"><div class="ttname"><a href="config_8hpp.html">config.hpp</a></div><div class="ttdoc">Defines configuration macros used throughout the library.</div></div>
<div class="ttc" id="agroup__group-_foldable_html_ga650def4b2e98f4273d8b9b7aa5a2fc28"><div class="ttname"><a href="group__group-_foldable.html#ga650def4b2e98f4273d8b9b7aa5a2fc28">boost::hana::sum</a></div><div class="ttdeci">constexpr auto sum</div><div class="ttdoc">Compute the sum of the numbers of a structure.</div><div class="ttdef"><b>Definition:</b> sum.hpp:66</div></div>
<div class="ttc" id="agroup__group-assertions_html_gac7aafc41e4dcc7d1f1929fb00f010d2a"><div class="ttname"><a href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a></div><div class="ttdeci">#define BOOST_HANA_CONSTEXPR_CHECK(...)</div><div class="ttdoc">Equivalent to BOOST_HANA_CONSTEXPR_ASSERT, but not influenced by the BOOST_HANA_CONFIG_DISABLE_ASSERT...</div><div class="ttdef"><b>Definition:</b> assert.hpp:300</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga3b16146e53efcdf9ecbb9a7b21f8cd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">&#9670;&nbsp;</a></span>compose</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::compose</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="compose_8hpp.html">boost/hana/functional/compose.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f1, <span class="keyword">auto</span>&amp;&amp; f2, ..., <span class="keyword">auto</span>&amp;&amp; fn) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; ...xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> forwarded(f1)(</div>
<div class="line">                    forwarded(f2)(</div>
<div class="line">                     ...</div>
<div class="line">                      forwarded(fn)(forwarded(x))</div>
<div class="line">                    ),</div>
<div class="line">                    forwarded(xs)...</div>
<div class="line">                );</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the composition of two functions or more. </p>
<p><code>compose</code> is defined inductively. When given more than two functions, <code>compose(f, g, h...)</code> is equivalent to <code>compose(f, compose(g, h...))</code>. When given two functions, <code>compose(f, g)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(f, g)(x, y...) == f(g(x), y...)</div>
<div class="ttc" id="agroup__group-functional_html_ga3b16146e53efcdf9ecbb9a7b21f8cd0b"><div class="ttname"><a href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">boost::hana::compose</a></div><div class="ttdeci">constexpr auto compose</div><div class="ttdoc">Return the composition of two functions or more.</div><div class="ttdef"><b>Definition:</b> compose.hpp:52</div></div>
</div><!-- fragment --><p>If you need composition of the form <code>f(g(x, y...))</code>, use <code>demux</code> instead.</p>
<dl class="section note"><dt>Note</dt><dd><code>compose</code> is an associative operation; <code>compose(f, compose(g, h))</code> is equivalent to <code>compose(compose(f, g), h)</code>.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(f, <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(g, h))(x, xs...) == f(<a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(g, h)(x), xs...)</div>
<div class="line">                                    == f(g(h(x)), xs...)</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(<a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(f, g), h)(x, xs...) == <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(f, g)(h(x), xs...)</div>
<div class="line">                                    == f(g(h(x)), xs...)</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md27"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="compose_8hpp.html">boost/hana/functional/compose.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> to_char = [](<span class="keywordtype">int</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(x + 48);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> increment = [](<span class="keyword">auto</span> x) {</div>
<div class="line">        <span class="keywordflow">return</span> x + 1;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">hana::compose</a>(to_char, increment)(3) == <span class="charliteral">&#39;4&#39;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="acompose_8hpp_html"><div class="ttname"><a href="compose_8hpp.html">compose.hpp</a></div><div class="ttdoc">Defines boost::hana::compose.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga49ea872ade5ac8f6c10052c495302e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49ea872ade5ac8f6c10052c495302e89">&#9670;&nbsp;</a></span>curry</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::curry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="curry_8hpp.html">boost/hana/functional/curry.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; x1) {</div>
<div class="line">            <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; x2) {</div>
<div class="line">                ...</div>
<div class="line">                    <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; xn) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">                        <span class="keywordflow">return</span> forwarded(f)(</div>
<div class="line">                            forwarded(x1), forwarded(x2), ..., forwarded(xn)</div>
<div class="line">                        );</div>
<div class="line">                    };</div>
<div class="line">            };</div>
<div class="line">        };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Curry a function up to the given number of arguments. </p>
<p><a href="http://en.wikipedia.org/wiki/Currying">Currying</a> is a technique in which we consider a function taking multiple arguments (or, equivalently, a tuple of arguments), and turn it into a function which takes a single argument and returns a function to handle the remaining arguments. To help visualize, let's denote the type of a function <code>f</code> which takes arguments of types <code>X1, ..., Xn</code> and returns a <code>R</code> as </p><div class="fragment"><div class="line">(X1, ..., Xn) -&gt; R</div>
</div><!-- fragment --><p>Then, currying is the process of taking <code>f</code> and turning it into an equivalent function (call it <code>g</code>) of type </p><div class="fragment"><div class="line">X1 -&gt; (X2 -&gt; (... -&gt; (Xn -&gt; R)))</div>
</div><!-- fragment --><p>This gives us the following equivalence, where <code>x1</code>, ..., <code>xn</code> are objects of type <code>X1</code>, ..., <code>Xn</code> respectively: </p><div class="fragment"><div class="line">f(x1, ..., xn) == g(x1)...(xn)</div>
</div><!-- fragment --><p>Currying can be useful in several situations, especially when working with higher-order functions.</p>
<p>This <code>curry</code> utility is an implementation of currying in C++. Specifically, <code>curry&lt;n&gt;(f)</code> is a function such that </p><div class="fragment"><div class="line">curry&lt;n&gt;(f)(x1)...(xn) == f(x1, ..., xn)</div>
</div><!-- fragment --><p>Note that the <code>n</code> has to be specified explicitly because the existence of functions with variadic arguments in C++ make it impossible to know when currying should stop.</p>
<p>Unlike usual currying, this implementation also allows a curried function to be called with several arguments at a time. Hence, the following always holds </p><div class="fragment"><div class="line">curry&lt;n&gt;(f)(x1, ..., xk) == curry&lt;n - k&gt;(f)(x1)...(xk)</div>
</div><!-- fragment --><p>Of course, this requires <code>k</code> to be less than or equal to <code>n</code>; failure to satisfy this will trigger a static assertion. This syntax is supported because it makes curried functions usable where normal functions are expected.</p>
<p>Another "extension" is that <code>curry&lt;0&gt;(f)</code> is supported: <code>curry&lt;0&gt;(f)</code> is a nullary function; whereas the classical definition for currying seems to leave this case undefined, as nullary functions don't make much sense in purely functional languages.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="curry_8hpp.html">boost/hana/functional/curry.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {</div>
<div class="line">        <span class="keywordflow">return</span> x + y + z;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(hana::curry&lt;3&gt;(add)(1)(2)(3) == 1 + 2 + 3);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(hana::curry&lt;3&gt;(add)(1)(2, 3) == hana::curry&lt;3&gt;(add)(1)(2)(3));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(hana::curry&lt;3&gt;(add)(1, 2, 3) == hana::curry&lt;3&gt;(add)(1)(2)(3));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// curry with a nullary function</span></div>
<div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> two = []() {</div>
<div class="line">        <span class="keywordflow">return</span> 2;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(hana::curry&lt;0&gt;(two)() == two());</div>
<div class="line">}</div>
<div class="ttc" id="acurry_8hpp_html"><div class="ttname"><a href="curry_8hpp.html">curry.hpp</a></div><div class="ttdoc">Defines boost::hana::curry.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga8c6f17b58ce527c7650eb878f01f2cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c6f17b58ce527c7650eb878f01f2cd2">&#9670;&nbsp;</a></span>mathtt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::hana::mathtt</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="demux_8hpp.html">boost/hana/functional/demux.hpp</a>&gt;</code></p>

<p>Invoke a function with the results of invoking other functions on its arguments. </p>
<p>Removes all consecutive duplicate elements from a Sequence.</p>
<p>Dual operation to <code>fold_right</code> for sequences.</p>
<p>Dual operation to <code>fold_left</code> for sequences.</p>
<p>Map a function over a <code>Functor</code>.</p>
<p>Returns a <code>Product</code> containing the longest prefix of a sequence satisfying a predicate, and the rest of the sequence.</p>
<p>Sort a sequence, optionally based on a custom <code>predicate</code>.</p>
<p>Equivalent to <code>reverse_fold</code> in Boost.Fusion and Boost.MPL.</p>
<p>Replace all the elements of a structure satisfying a <code>predicate</code> with a fixed value.</p>
<p>Replace all the elements of a structure that compare equal to some <code>value</code> with some new fixed value.</p>
<p>Partition a sequence based on a <code>predicate</code>.</p>
<p>Monadic right-fold of a structure with a binary operation and an optional initial reduction state.</p>
<p>Monadic left-fold of a structure with a binary operation and an optional initial reduction state.</p>
<p>Composition of monadic functions.</p>
<p>Return the least element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>.</p>
<p>Return the greatest element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>.</p>
<p>Short-circuiting lexicographical comparison of two <code>Iterable</code>s with an optional custom predicate, by default <code><a class="el" href="group__group-_orderable.html#gad510011602bdb14686f1c4ec145301c9" title="Returns a Logical representing whether x is less than y.">hana::less</a></code>.</p>
<p>Returns a <code><a class="el" href="structboost_1_1hana_1_1type.html" title="C++ type in value-level representation.">hana::type</a></code> representing the compile-time hash of an object.</p>
<p>Group adjacent elements of a sequence that all respect a binary predicate, by default equality.</p>
<p>Right-fold of a structure using a binary operation and an optional initial reduction state.</p>
<p>Left-fold of a structure using a binary operation and an optional initial reduction state.</p>
<p>Collapse two levels of monadic structure into a single level.</p>
<p>Replace all the elements of a structure with a fixed value.</p>
<p>Extract a value in a given comonadic context.</p>
<p>Comonadic application of a function to a comonadic value.</p>
<p>Add an extra layer of comonadic context to a comonadic value.</p>
<p>Feed a monadic value into a monadic computation.</p>
<p>Computes the cartesian product of a sequence of sequences.</p>
<p>Apply a function on all the elements of a structure satisfying a predicate.</p>
<p>Apply a function on all the elements of a structure that compare equal to some value.</p>
<p>Applies another function <code>n</code> times to its argument.</p>
<p>Specifically, <code>demux(f)(g...)</code> is a function such that </p><div class="fragment"><div class="line">demux(f)(g...)(x...) == f(g(x...)...)</div>
</div><!-- fragment --><p>Each <code>g</code> is called with all the arguments, and then <code>f</code> is called with the result of each <code>g</code>. Hence, the arity of <code>f</code> must match the number of <code>g</code>s.</p>
<p>This is called <code>demux</code> because of a vague similarity between this device and a demultiplexer in signal processing. <code>demux</code> takes what can be seen as a continuation (<code>f</code>), a bunch of functions to split a signal (<code>g...</code>) and zero or more arguments representing the signal (<code>x...</code>). Then, it calls the continuation with the result of splitting the signal with whatever functions where given.</p>
<dl class="section note"><dt>Note</dt><dd>When used with two functions only, <code>demux</code> is associative. In other words (and noting <code>demux(f, g) = demux(f)(g)</code> to ease the notation), it is true that <code>demux(demux(f, g), h) == demux(f, demux(g, h))</code>.</dd></dl>
<h2><a class="anchor" id="autotoc_md29"></a>
Signature</h2>
<p>The signature of <code>demux</code> is</p>
<p>Given a function <code>f</code> and an argument <code>x</code>, <code>iterate&lt;n&gt;(f, x)</code> returns the result of applying <code>f</code> <code>n</code> times to its argument. In other words, </p><div class="fragment"><div class="line">iterate&lt;n&gt;(f, x) == f(f( ... f(x)))</div>
<div class="line">                    ^^^^^^^^^^ n times total</div>
</div><!-- fragment --><p>If <code>n == 0</code>, <code>iterate&lt;n&gt;(f, x)</code> returns the <code>x</code> argument unchanged and <code>f</code> is never applied. It is important to note that the function passed to <code>iterate&lt;n&gt;</code> must be a unary function. Indeed, since <code>f</code> will be called with the result of the previous <code>f</code> application, it may only take a single argument.</p>
<p>In addition to what's documented above, <code>iterate</code> can also be partially applied to the function argument out-of-the-box. In other words, <code>iterate&lt;n&gt;(f)</code> is a function object applying <code>f</code> <code>n</code> times to the argument it is called with, which means that </p><div class="fragment"><div class="line">iterate&lt;n&gt;(f)(x) == iterate&lt;n&gt;(f, x)</div>
</div><!-- fragment --><p>This is provided for convenience, and it turns out to be especially useful in conjunction with higher-order algorithms.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
Signature</h2>
<p>Given a function \( f : T \to T \) and <code>x</code> and argument of data type <code>T</code>, the signature is</p>
<h2><a class="anchor" id="autotoc_md48"></a>
Signature</h2>
<p>Given <code>F</code> a Functor and <code>U</code> a type that can be compared with <code>T</code>'s, the signature is</p>
<p>Given a Functor, a predicate <code>pred</code> and a function <code>f</code>, <code>adjust_if</code> will <em>adjust</em> the elements of the Functor that satisfy the predicate with the function <code>f</code>. In other words, <code>adjust_if</code> will return a new Functor equal to the original one, except that the elements satisfying the predicate will be transformed with the given function. Elements for which the predicate is not satisfied are left untouched, and they are kept as-is in the resulting Functor.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Signature</h2>
<p>Given a <code>Functor</code> <code>F</code> and a <code>Logical</code> <code>Bool</code>, the signature is</p>
<p>Given a sequence of sequences, <code>cartesian_product</code> returns a new sequence of sequences containing the cartesian product of the original sequences. For this method to finish, a finite number of finite sequences must be provided.</p>
<dl class="section note"><dt>Note</dt><dd>All the sequences must have the same tag, and that tag must also match that of the top-level sequence.</dd></dl>
<h2><a class="anchor" id="autotoc_md66"></a>
Signature</h2>
<p>Given a <code>Sequence</code> <code>S(T)</code>, the signature is</p>
<p>Given a monadic value and a monadic function, <code>chain</code> feeds the monadic value into the function, thus performing some Monad-specific effects, and returns the result. An implementation of <code>chain</code> must satisfy </p><div class="fragment"><div class="line">chain(xs, f) == flatten(transform(xs, f))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md67"></a>
Signature</h2>
<p>For a monad <code>M</code>, given a monadic value of type <code>M(A)</code> and a monadic function \( f : A \to M(B) \), <code>chain</code> has the signature</p>
<p>Given a value already in a comonadic context, <code>duplicate</code> wraps this value with an additional layer of comonadic context. This can be seen as the dual operation to <code>flatten</code> from the Monad concept.</p>
<h2><a class="anchor" id="autotoc_md209"></a>
Signature</h2>
<p>Given a Comonad <code>W</code>, the signature is</p>
<p>Given a comonadic value and a function accepting a comonadic input, <code>extend</code> returns the result of applying the function to that input inside the comonadic context.</p>
<h2><a class="anchor" id="autotoc_md217"></a>
Signature</h2>
<p>Given a Comonad <code>W</code> and a function of type \( W(T) \to U \), the signature is</p>
<p>Given a value inside a comonadic context, extract it from that context, performing whatever effects are mandated by that context. This can be seen as the dual operation to the <code>lift</code> method of the Applicative concept.</p>
<h2><a class="anchor" id="autotoc_md218"></a>
Signature</h2>
<p>Given a Comonad <code>W</code>, the signature is</p>
<h2><a class="anchor" id="autotoc_md219"></a>
Signature</h2>
<p>Given <code>F</code> a Functor, the signature is</p>
<p>Given a monadic value wrapped into two levels of monad, <code>flatten</code> removes one such level. An implementation of <code>flatten</code> must satisfy </p><div class="fragment"><div class="line">flatten(xs) == chain(xs, <span class="keywordtype">id</span>)</div>
</div><!-- fragment --><p>For <code>Sequence</code>s, this simply takes a <code>Sequence</code> of <code>Sequence</code>s, and returns a (non-recursively) flattened <code>Sequence</code>.</p>
<h2><a class="anchor" id="autotoc_md225"></a>
Signature</h2>
<p>For a <code>Monad</code> <code>M</code>, the signature of <code>flatten</code> is</p>
<p><code>fold_left</code> is a left-associative fold using a binary operation. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and an optional initial state, <code>fold_left</code> applies <code>f</code> as follows </p><div class="fragment"><div class="line">f(... f(f(f(x1, x2), x3), x4) ..., xn) <span class="comment">// without state</span></div>
<div class="line">f(... f(f(f(f(state, x1), x2), x3), x4) ..., xn) <span class="comment">// with state</span></div>
</div><!-- fragment --><p>When the structure is empty, two things may arise. If an initial state was provided, it is returned as-is. Otherwise, if the no-state version of the function was used, an error is triggered. When the stucture contains a single element and the no-state version of the function was used, that single element is returned as is.</p>
<h2><a class="anchor" id="autotoc_md227"></a>
Signature</h2>
<p>Given a <code>Foldable</code> <code>F</code> and an optional initial state of tag <code>S</code>, the signatures for <code>fold_left</code> are</p>
<p><code>fold_right</code> is a right-associative fold using a binary operation. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and an optional initial state, <code>fold_right</code> applies <code>f</code> as follows </p><div class="fragment"><div class="line">f(x1, f(x2, f(x3, f(x4, ... f(xn-1, xn) ... )))) <span class="comment">// without state</span></div>
<div class="line">f(x1, f(x2, f(x3, f(x4, ... f(xn, state) ... )))) <span class="comment">// with state</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is worth noting that the order in which the binary function should expect its arguments is reversed from <code>fold_left</code>.</dd></dl>
<p>When the structure is empty, two things may arise. If an initial state was provided, it is returned as-is. Otherwise, if the no-state version of the function was used, an error is triggered. When the stucture contains a single element and the no-state version of the function was used, that single element is returned as is.</p>
<h2><a class="anchor" id="autotoc_md228"></a>
Signature</h2>
<p>Given a <code>Foldable</code> <code>F</code> and an optional initial state of tag <code>S</code>, the signatures for <code>fold_right</code> are</p>
<p>Given a <em>finite</em> Sequence and an optional predicate (by default <code>equal</code>), <code>group</code> returns a sequence of subsequences representing groups of adjacent elements that are "equal" with respect to the predicate. In other words, the groups are such that the predicate is satisfied when it is applied to any two adjacent elements in that group. The sequence returned by <code>group</code> is such that the concatenation of its elements is equal to the original sequence, which is equivalent to saying that the order of the elements is not changed.</p>
<p>If no predicate is provided, adjacent elements in the sequence must all be compile-time <code>Comparable</code>.</p>
<h2><a class="anchor" id="autotoc_md236"></a>
Signature</h2>
<p>Given a Sequence <code>s</code> with tag <code>S(T)</code>, an <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant concept represents compile-time integral values.">IntegralConstant</a></code> <code>Bool</code> holding a value of type <code>bool</code>, and a predicate \( pred : T \times T \to Bool \), <code>group</code> has the following signatures. For the variant with a provided predicate,</p>
<p>Given an arbitrary object <code>x</code>, <code>hana::hash</code> returns a <code><a class="el" href="structboost_1_1hana_1_1type.html" title="C++ type in value-level representation.">hana::type</a></code> representing the hash of <code>x</code>. In normal programming, hashes are usually numerical values that can be used e.g. as indices in an array as part of the implementation of a hash table. In the context of metaprogramming, we are interested in type-level hashes instead. Thus, <code>hana::hash</code> must return a <code><a class="el" href="structboost_1_1hana_1_1type.html" title="C++ type in value-level representation.">hana::type</a></code> object instead of an integer. This <code><a class="el" href="structboost_1_1hana_1_1type.html" title="C++ type in value-level representation.">hana::type</a></code> must somehow summarize the object being hashed, but that summary may of course lose some information.</p>
<p>In order for the <code>hash</code> function to be defined properly, it must be the case that whenever <code>x</code> is equal to <code>y</code>, then <code>hash(x)</code> is equal to <code>hash(y)</code>. This ensures that <code>hana::hash</code> is a function in the mathematical sense of the term.</p>
<h2><a class="anchor" id="autotoc_md237"></a>
Signature</h2>
<p>Given a <code>Hashable</code> <code>H</code>, the signature is</p>
<p>Given two <code>Iterable</code>s <code>xs</code> and <code>ys</code> and a binary predicate <code>pred</code>, <code>lexicographical_compare</code> returns whether <code>xs</code> is to be considered less than <code>ys</code> in a lexicographical ordering. Specifically, let's denote the linearizations of <code>xs</code> and <code>ys</code> by <code>[x1, x2, ...]</code> and <code>[y1, y2, ...]</code>, respectively. If the first couple satisfying the predicate is of the form <code>xi, yi</code>, <code>lexicographical_compare</code> returns true. Otherwise, if the first couple to satisfy the predicate is of the form <code>yi, xi</code>, <code>lexicographical_compare</code> returns false. If no such couple can be found, <code>lexicographical_compare</code> returns whether <code>xs</code> has fewer elements than <code>ys</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This algorithm will short-circuit as soon as it can determine that one sequence is lexicographically less than the other. Hence, it can be used to compare infinite sequences. However, for the procedure to terminate on infinite sequences, the predicate has to be satisfied at a finite index.</dd></dl>
<h2><a class="anchor" id="autotoc_md258"></a>
Signature</h2>
<p>Given two <code>Iterable</code>s <code>It1(T)</code> and <code>It2(T)</code> and a predicate \( pred : T \times T \to Bool \) (where <code>Bool</code> is some <code>Logical</code>), <code>lexicographical_compare</code> has the following signatures. For the variant with a provided predicate,</p>
<p>Given a non-empty structure and an optional binary predicate (<code>less</code> by default), <code>maximum</code> returns the greatest element of the structure, i.e. an element which is greater than or equal to every other element in the structure, according to the predicate.</p>
<p>If the structure contains heterogeneous objects, then the predicate must return a compile-time <code>Logical</code>. If no predicate is provided, the elements in the structure must be Orderable, or compile-time Orderable if the structure is heterogeneous.</p>
<h2><a class="anchor" id="autotoc_md275"></a>
Signature</h2>
<p>Given a Foldable <code>F</code>, a Logical <code>Bool</code> and a predicate \( \mathtt{pred} : T \times T \to Bool \), <code>maximum</code> has the following signatures. For the variant with a provided predicate,</p>
<p>Given a non-empty structure and an optional binary predicate (<code>less</code> by default), <code>minimum</code> returns the least element of the structure, i.e. an element which is less than or equal to every other element in the structure, according to the predicate.</p>
<p>If the structure contains heterogeneous objects, then the predicate must return a compile-time <code>Logical</code>. If no predicate is provided, the elements in the structure must be Orderable, or compile-time Orderable if the structure is heterogeneous.</p>
<h2><a class="anchor" id="autotoc_md278"></a>
Signature</h2>
<p>Given a <code>Foldable</code> <code>F</code>, a Logical <code>Bool</code> and a predicate \( \mathtt{pred} : T \times T \to Bool \), <code>minimum</code> has the following signatures. For the variant with a provided predicate,</p>
<p>Given two monadic functions <code>f</code> and <code>g</code>, <code>monadic_compose</code> returns a new function equivalent to the composition of <code>f</code> with <code>g</code>, except the result of <code>g</code> is <code>chain</code>ed into <code>f</code> instead of simply passed to it, as with normal composition. <code>monadic_compose</code> satisfies </p><div class="fragment"><div class="line">monadic_compose(f, g)(x) == chain(g(x), f)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Unlike <code>compose</code>, <code>monadic_compose</code> does not generalize nicely to arities higher than one. Hence, only unary functions may be used with <code>monadic_compose</code>.</dd></dl>
<h2><a class="anchor" id="autotoc_md283"></a>
Signature</h2>
<p>Given a <code>Monad</code> <code>M</code> and two functions \( f : B \to M(C) \) and \( g : A \to M(B) \), the signature is</p>
<dl class="section note"><dt>Note</dt><dd>This assumes the reader to be accustomed to non-monadic left-folds as explained by <code>hana::fold_left</code>, and to have read the <a class="el" href="group__group-_foldable.html#monadic-folds">primer</a> on monadic folds.</dd></dl>
<p><code>monadic_fold_left&lt;M&gt;</code> is a left-associative monadic fold. Given a <code>Foldable</code> with linearization <code>[x1, ..., xn]</code>, a function <code>f</code> and an optional initial state, <code>monadic_fold_left&lt;M&gt;</code> applies <code>f</code> as follows: </p><div class="fragment"><div class="line"><span class="comment">// with state</span></div>
<div class="line">((((f(state, x1) | f(-, x2)) | f(-, x3)) | ...) | f(-, xn))</div>
<div class="line"> </div>
<div class="line"><span class="comment">// without state</span></div>
<div class="line">((((f(x1, x2) | f(-, x3)) | f(-, x4)) | ...) | f(-, xn))</div>
</div><!-- fragment --><p>where <code>f(-, xk)</code> denotes the partial application of <code>f</code> to <code>xk</code>, and <code>|</code> is just the operator version of the monadic <code>chain</code>.</p>
<p>When the structure is empty, one of two things may happen. If an initial state was provided, it is lifted to the given Monad and returned as-is. Otherwise, if the no-state version of the function was used, an error is triggered. When the stucture contains a single element and the no-state version of the function was used, that single element is lifted into the given Monad and returned as is.</p>
<h2><a class="anchor" id="autotoc_md284"></a>
Signature</h2>
<p>Given a <code>Monad</code> <code>M</code>, a <code>Foldable</code> <code>F</code>, an initial state of tag <code>S</code>, and a function \( f : S \times T \to M(S) \), the signatures of <code>monadic_fold_left&lt;M&gt;</code> are</p>
<dl class="section note"><dt>Note</dt><dd>This assumes the reader to be accustomed to non-monadic right-folds as explained by <code>hana::fold_right</code>, and to have read the <a class="el" href="group__group-_foldable.html#monadic-folds">primer</a> on monadic folds.</dd></dl>
<p><code>monadic_fold_right&lt;M&gt;</code> is a right-associative monadic fold. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and an optional initial state, <code>monadic_fold_right&lt;M&gt;</code> applies <code>f</code> as follows </p><div class="fragment"><div class="line"><span class="comment">// with state</span></div>
<div class="line">(f(x1, -) | (f(x2, -) | (f(x3, -) | (... | f(xn, state)))))</div>
<div class="line"> </div>
<div class="line"><span class="comment">// without state</span></div>
<div class="line">(f(x1, -) | (f(x2, -) | (f(x3, -) | (... | f(xn-1, xn)))))</div>
</div><!-- fragment --><p>where <code>f(xk, -)</code> denotes the partial application of <code>f</code> to <code>xk</code>, and <code>|</code> is just the operator version of the monadic <code>chain</code>. It is worth noting that the order in which the binary function should expect its arguments is reversed from <code>monadic_fold_left&lt;M&gt;</code>.</p>
<p>When the structure is empty, one of two things may happen. If an initial state was provided, it is lifted to the given Monad and returned as-is. Otherwise, if the no-state version of the function was used, an error is triggered. When the stucture contains a single element and the no-state version of the function was used, that single element is lifted into the given Monad and returned as is.</p>
<h2><a class="anchor" id="autotoc_md285"></a>
Signature</h2>
<p>Given a <code>Monad</code> <code>M</code>, a <code>Foldable</code> <code>F</code>, an initial state of tag <code>S</code>, and a function \( f : T \times S \to M(S) \), the signatures of <code>monadic_fold_right&lt;M&gt;</code> are</p>
<p>Specifically, returns an unspecified <code>Product</code> whose first element is a sequence of the elements satisfying the predicate, and whose second element is a sequence of the elements that do not satisfy the predicate.</p>
<h2><a class="anchor" id="autotoc_md315"></a>
Signature</h2>
<p>Given a Sequence <code>S(T)</code>, an <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant concept represents compile-time integral values.">IntegralConstant</a></code> <code>Bool</code> holding a value of type <code>bool</code>, and a predicate \( T \to Bool \), <code>partition</code> has the following signature:</p>
<h2><a class="anchor" id="autotoc_md335"></a>
Signature</h2>
<p>Given <code>F</code> a Functor and <code>U</code> a type that can be compared with <code>T</code>, the signature is</p>
<h2><a class="anchor" id="autotoc_md336"></a>
Signature</h2>
<p>Given <code>F</code> a Functor and <code>Bool</code> a Logical, the signature is</p>
<p>This method has the same semantics as <code>reverse_fold</code> in Boost.Fusion and Boost.MPL, with the extension that an initial state is not required. This method is equivalent to <code>fold_right</code>, except that the accumulating function must take its arguments in reverse order, to match the order used in Fusion. In other words, </p><div class="fragment"><div class="line">reverse_fold(sequence, state, f) == fold_right(sequence, state, <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(f))</div>
<div class="line">reverse_fold(sequence, f) == fold_right(sequence, <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(f))</div>
<div class="ttc" id="agroup__group-functional_html_ga004f884cdbb85c2efe3383c1db450094"><div class="ttname"><a href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">boost::hana::flip</a></div><div class="ttdeci">constexpr auto flip</div><div class="ttdoc">Invoke a function with its two first arguments reversed.</div><div class="ttdef"><b>Definition:</b> flip.hpp:31</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This method is a convenience alias to <code>fold_right</code>. As an alias, <code>reverse_fold</code> is not tag-dispatched on its own and <code>fold_right</code> should be customized instead.</dd></dl>
<h2><a class="anchor" id="autotoc_md340"></a>
Signature</h2>
<p>Given a <code>Foldable</code> <code>F</code> and an optional initial state of tag <code>S</code>, the signatures for <code>reverse_fold</code> are</p>
<p>Given a Sequence and an optional predicate (by default <code>less</code>), <code>sort</code> returns a new sequence containing the same elements as the original, except they are ordered in such a way that if <code>x</code> comes before <code>y</code> in the sequence, then either <code>predicate(x, y)</code> is true, or both <code>predicate(x, y)</code> and <code>predicate(y, x)</code> are false.</p>
<p>Also note that the sort is guaranteed to be stable. Hence, if <code>x</code> comes before <code>y</code> in the original sequence and both <code>predicate(x, y)</code> and <code>predicate(y, x)</code> are false, then <code>x</code> will come before <code>y</code> in the resulting sequence.</p>
<p>If no predicate is provided, the elements in the sequence must all be compile-time <code>Orderable</code>.</p>
<h2><a class="anchor" id="autotoc_md357"></a>
Signature</h2>
<p>Given a <code>Sequence</code> <code>S(T)</code>, a boolean <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant concept represents compile-time integral values.">IntegralConstant</a></code> <code>Bool</code> and a binary predicate \( T \times T \to Bool \), <code>sort</code> has the following signatures. For the variant with a provided predicate,</p>
<p>The first component of the returned <code>Product</code> is a sequence for which all elements satisfy the given predicate. The second component of the returned <code>Product</code> is a sequence containing the remainder of the argument. Both or either sequences may be empty, depending on the input argument. More specifically, </p><div class="fragment"><div class="line">span(xs, predicate) == make_pair(<a class="code" href="group__group-_sequence.html#ga2d4db4ec5ec5bc16fe74f57de12697fd">take_while</a>(xs, predicate),</div>
<div class="line">                                 <a class="code" href="group__group-_iterable.html#ga9f1d02c74a6bdc1db260e0d6a8f1ee56">drop_while</a>(xs, predicate))</div>
<div class="ttc" id="agroup__group-_iterable_html_ga9f1d02c74a6bdc1db260e0d6a8f1ee56"><div class="ttname"><a href="group__group-_iterable.html#ga9f1d02c74a6bdc1db260e0d6a8f1ee56">boost::hana::drop_while</a></div><div class="ttdeci">constexpr auto drop_while</div><div class="ttdoc">Drop elements from an iterable up to, but excluding, the first element for which the predicate is not...</div><div class="ttdef"><b>Definition:</b> drop_while.hpp:44</div></div>
<div class="ttc" id="agroup__group-_sequence_html_ga2d4db4ec5ec5bc16fe74f57de12697fd"><div class="ttname"><a href="group__group-_sequence.html#ga2d4db4ec5ec5bc16fe74f57de12697fd">boost::hana::take_while</a></div><div class="ttdeci">constexpr auto take_while</div><div class="ttdoc">Take elements from a sequence while the predicate is satisfied.</div><div class="ttdef"><b>Definition:</b> take_while.hpp:40</div></div>
</div><!-- fragment --><p> except that <code>make_pair</code> may be an arbitrary <code>Product</code>.</p>
<h2><a class="anchor" id="autotoc_md358"></a>
Signature</h2>
<p>Given a <code>Sequence</code> <code>S(T)</code>, a <code>Logical</code> <code>Bool</code> and a predicate \( T \to Bool \), <code>span</code> has the following signature:</p>
<h2><a class="anchor" id="autotoc_md378"></a>
Signature</h2>
<p>Given <code>F</code> a Functor, the signature is</p>
<p>While <code>fold_left</code> reduces a structure to a summary value from the left, <code>unfold_left</code> builds a sequence from a seed value and a function, starting from the left.</p>
<h2><a class="anchor" id="autotoc_md401"></a>
Signature</h2>
<p>Given a <code>Sequence</code> <code>S</code>, an initial value <code>state</code> of tag <code>I</code>, an arbitrary Product <code>P</code> and a function \( f : I \to P(I, T) \), <code>unfold_left&lt;S&gt;</code> has the following signature:</p>
<p>While <code>fold_right</code> reduces a structure to a summary value from the right, <code>unfold_right</code> builds a sequence from a seed value and a function, starting from the right.</p>
<h2><a class="anchor" id="autotoc_md402"></a>
Signature</h2>
<p>Given a <code>Sequence</code> <code>S</code>, an initial value <code>state</code> of tag <code>I</code>, an arbitrary Product <code>P</code> and a function \( f : I \to P(T, I) \), <code>unfold_right&lt;S&gt;</code> has the following signature:</p>
<p>Given a <code>Sequence</code> and an optional binary predicate, <code>unique</code> returns a new sequence containing only the first element of every subrange of the original sequence whose elements are all equal. In other words, it turns a sequence of the form <code>[a, a, b, c, c, c, d, d, d, a]</code> into a sequence <code>[a, b, c, d, a]</code>. The equality of two elements is determined by the provided <code>predicate</code>, or by <code>equal</code> if no <code>predicate</code> is provided.</p>
<h2><a class="anchor" id="autotoc_md403"></a>
Signature</h2>
<p>Given a <code>Sequence</code> <code>S(T)</code>, a <code>Logical</code> <code>Bool</code> and a binary predicate \( T \times T \to Bool \), <code>unique</code> has the following signature: </p>

</div>
</div>
<a id="ga1393f40da2e8da6e0c12fce953e56a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1393f40da2e8da6e0c12fce953e56a6c">&#9670;&nbsp;</a></span>fix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::fix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fix_8hpp.html">boost/hana/functional/fix.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> forwarded(f)(<a class="code" href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">fix</a>(f), forwarded(x)...);</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="ttc" id="agroup__group-functional_html_ga1393f40da2e8da6e0c12fce953e56a6c"><div class="ttname"><a href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">boost::hana::fix</a></div><div class="ttdeci">constexpr auto fix</div><div class="ttdoc">Return a function computing the fixed point of a function.</div><div class="ttdef"><b>Definition:</b> fix.hpp:53</div></div>
</div><!-- fragment -->
<p>Return a function computing the fixed point of a function. </p>
<p><code>fix</code> is an implementation of the <a href="http://en.wikipedia.org/wiki/Fixed-point_combinator">Y-combinator</a>, also called the fixed-point combinator. It encodes the idea of recursion, and in fact any recursive function can be written in terms of it.</p>
<p>Specifically, <code>fix(f)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">fix</a>(f)(x...) == f(<a class="code" href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">fix</a>(f), x...)</div>
</div><!-- fragment --><p>This definition allows <code>f</code> to use its first argument as a continuation to call itself recursively. Indeed, if <code>f</code> calls its first argument with <code>y...</code>, it is equivalent to calling <code>f(fix(f), y...)</code> per the above equation.</p>
<p>Most of the time, it is more convenient and efficient to define recursive functions without using a fixed-point combinator. However, there are some cases where <code>fix</code> provides either more flexibility (e.g. the ability to change the callback inside <code>f</code>) or makes it possible to write functions that couldn't be defined recursively otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function called as <code>f(self, x...)</code>, where <code>x...</code> are the arguments in the <code>fix(f)(x...)</code> expression and <code>self</code> is <code>fix(f)</code>.</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="autotoc_md30"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fix_8hpp.html">boost/hana/functional/fix.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">BOOST_HANA_CONSTEXPR_STATELESS_LAMBDA <span class="keyword">auto</span> factorial = <a class="code" href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">hana::fix</a>([](<span class="keyword">auto</span> fact, <span class="keyword">auto</span> n) -&gt; <span class="keywordtype">int</span> {</div>
<div class="line">    <span class="keywordflow">if</span> (n == 0) <span class="keywordflow">return</span> 1;</div>
<div class="line">    <span class="keywordflow">else</span>        <span class="keywordflow">return</span> n * fact(n - 1);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(factorial(5) == 120);</div>
<div class="line">}</div>
<div class="ttc" id="afix_8hpp_html"><div class="ttname"><a href="fix_8hpp.html">fix.hpp</a></div><div class="ttdoc">Defines boost::hana::fix.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga004f884cdbb85c2efe3383c1db450094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga004f884cdbb85c2efe3383c1db450094">&#9670;&nbsp;</a></span>flip</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::flip</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="flip_8hpp.html">boost/hana/functional/flip.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; y, <span class="keyword">auto</span>&amp;&amp; ...z) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> forwarded(f)(forwarded(y), forwarded(x), forwarded(z)...);</div>
<div class="line">        };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Invoke a function with its two first arguments reversed. </p>
<p>Specifically, <code>flip(f)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(f)(x, y, z...) == f(y, x, z...)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="flip_8hpp.html">boost/hana/functional/flip.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> <a class="code" href="group__group-_group.html#ga2020c526324f361a2b990fe8d1b07c20">minus</a> = [](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z = 0) {</div>
<div class="line">    <span class="keywordflow">return</span> x - y - z;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-_group.html#ga2020c526324f361a2b990fe8d1b07c20">minus</a>(3, 0) == 3 - 0);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">hana::flip</a>(<a class="code" href="group__group-_group.html#ga2020c526324f361a2b990fe8d1b07c20">minus</a>)(3, 0) == 0 - 3);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-_group.html#ga2020c526324f361a2b990fe8d1b07c20">minus</a>(3, 0, 1) == 3 - 0 - 1);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">hana::flip</a>(<a class="code" href="group__group-_group.html#ga2020c526324f361a2b990fe8d1b07c20">minus</a>)(3, 0, 1) == 0 - 3 - 1);</div>
<div class="line">}</div>
<div class="ttc" id="aflip_8hpp_html"><div class="ttname"><a href="flip_8hpp.html">flip.hpp</a></div><div class="ttdoc">Defines boost::hana::flip.</div></div>
<div class="ttc" id="agroup__group-_group_html_ga2020c526324f361a2b990fe8d1b07c20"><div class="ttname"><a href="group__group-_group.html#ga2020c526324f361a2b990fe8d1b07c20">boost::hana::minus</a></div><div class="ttdeci">constexpr auto minus</div><div class="ttdoc">Subtract two elements of a group.</div><div class="ttdef"><b>Definition:</b> minus.hpp:51</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaef38cf34324c8edbd3597ae71811d00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef38cf34324c8edbd3597ae71811d00d">&#9670;&nbsp;</a></span>id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="id_8hpp.html">boost/hana/functional/id.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> forwarded(x);</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>The identity function &ndash; returns its argument unchanged. </p>
<h3><a class="anchor" id="autotoc_md32"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="id_8hpp.html">boost/hana/functional/id.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">hana::id</a>(1) == 1, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">hana::id</a>(<span class="charliteral">&#39;x&#39;</span>) == <span class="charliteral">&#39;x&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="agroup__group-functional_html_gaef38cf34324c8edbd3597ae71811d00d"><div class="ttname"><a href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">boost::hana::id</a></div><div class="ttdeci">constexpr auto id</div><div class="ttdoc">The identity function  returns its argument unchanged.</div><div class="ttdef"><b>Definition:</b> id.hpp:23</div></div>
<div class="ttc" id="aid_8hpp_html"><div class="ttname"><a href="id_8hpp.html">id.hpp</a></div><div class="ttdoc">Defines boost::hana::id.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga7bdafba6dc801f1d2d83731ad9714557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bdafba6dc801f1d2d83731ad9714557">&#9670;&nbsp;</a></span>infix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::infix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="infix_8hpp.html">boost/hana/functional/infix.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> f) {</div>
<div class="line">        <span class="keywordflow">return</span> unspecified;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return an equivalent function that can also be applied in infix notation. </p>
<p>Specifically, <code>infix(f)</code> is an object such that: </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f)(x1, ..., xn) == f(x1, ..., xn)</div>
<div class="line">x ^<a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f)^ y == f(x, y)</div>
<div class="ttc" id="agroup__group-functional_html_ga7bdafba6dc801f1d2d83731ad9714557"><div class="ttname"><a href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">boost::hana::infix</a></div><div class="ttdeci">constexpr auto infix</div><div class="ttdoc">Return an equivalent function that can also be applied in infix notation.</div><div class="ttdef"><b>Definition:</b> infix.hpp:79</div></div>
</div><!-- fragment --><p>Hence, the returned function can still be applied using the usual function call syntax, but it also gains the ability to be applied in infix notation. The infix syntax allows a great deal of expressiveness, especially when used in combination with some higher order algorithms. Since <code>operator^</code> is left-associative, <code>x ^infix(f)^ y</code> is actually parsed as <code>(x ^infix(f))^ y</code>. However, for flexibility, the order in which both arguments are applied in infix notation does not matter. Hence, it is always the case that </p><div class="fragment"><div class="line">(x ^ <a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f)) ^ y == x ^ (<a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f) ^ y)</div>
</div><!-- fragment --><p>However, note that applying more than one argument in infix notation to the same side of the operator will result in a compile-time assertion: </p><div class="fragment"><div class="line">(<a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f) ^ x) ^ y; <span class="comment">// compile-time assertion</span></div>
<div class="line">y ^ (x ^ <a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f)); <span class="comment">// compile-time assertion</span></div>
</div><!-- fragment --><p>Additionally, a function created with <code>infix</code> may be partially applied in infix notation. Specifically, </p><div class="fragment"><div class="line">(x ^ <a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f))(y1, ..., yn) == f(x, y1, ..., yn)</div>
<div class="line">(<a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f) ^ y)(x1, ..., xn) == f(x1, ..., xn, y)</div>
</div><!-- fragment --><ol type="1">
<li>The <code>^</code> operator was chosen because it is left-associative and has a low enough priority so that most expressions will render the expected behavior.</li>
<li>The operator can't be customimzed because that would require more sophistication in the implementation; I want to keep it as simple as possible. There is also an advantage in having a uniform syntax for infix application. </li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function which gains the ability to be applied in infix notation. The function must be at least binary; a compile-time error will be triggered otherwise.</td></tr>
  </table>
  </dd>
</dl>
<h3><a class="anchor" id="autotoc_md34"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8hpp.html">boost/hana/functional/infix.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> divmod = <a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">hana::infix</a>([](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div>
<div class="line">    <span class="comment">// this could be a more efficient implementation</span></div>
<div class="line">    <span class="keywordflow">return</span> hana::make_pair(x / y, x % y);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>((42 ^divmod^ 23) == hana::make_pair(1, 19));</div>
<div class="line">}</div>
<div class="ttc" id="aequal_8hpp_html"><div class="ttname"><a href="equal_8hpp.html">equal.hpp</a></div><div class="ttdoc">Defines boost::hana::equal.</div></div>
<div class="ttc" id="ainfix_8hpp_html"><div class="ttname"><a href="infix_8hpp.html">infix.hpp</a></div><div class="ttdoc">Defines boost::hana::infix.</div></div>
<div class="ttc" id="apair_8hpp_html"><div class="ttname"><a href="pair_8hpp.html">pair.hpp</a></div><div class="ttdoc">Defines boost::hana::pair.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gafca60c09e1f7a32a2b52baaf6515c279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafca60c09e1f7a32a2b52baaf6515c279">&#9670;&nbsp;</a></span>lockstep</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::lockstep</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lockstep_8hpp.html">boost/hana/functional/lockstep.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; ...g) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> forwarded(f)(forwarded(g)(forwarded(x))...);</div>
<div class="line">        };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Invoke a function with the result of invoking other functions on its arguments, in lockstep. </p>
<p>Specifically, <code>lockstep(f)(g1, ..., gN)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#gafca60c09e1f7a32a2b52baaf6515c279">lockstep</a>(f)(g1, ..., gN)(x1, ..., xN) == f(g1(x1), ..., gN(xN))</div>
<div class="ttc" id="agroup__group-functional_html_gafca60c09e1f7a32a2b52baaf6515c279"><div class="ttname"><a href="group__group-functional.html#gafca60c09e1f7a32a2b52baaf6515c279">boost::hana::lockstep</a></div><div class="ttdeci">constexpr auto lockstep</div><div class="ttdoc">Invoke a function with the result of invoking other functions on its arguments, in lockstep.</div><div class="ttdef"><b>Definition:</b> lockstep.hpp:39</div></div>
</div><!-- fragment --><p>Since each <code>g</code> is invoked on its corresponding argument in lockstep, the number of arguments must match the number of <code>g</code>s.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lockstep_8hpp.html">boost/hana/functional/lockstep.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plus_8hpp.html">boost/hana/plus.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">int</span> to_int(<span class="keywordtype">char</span> c) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(c) - 48;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">int</span> increment(<span class="keywordtype">int</span> i) {</div>
<div class="line">    <span class="keywordflow">return</span> i + 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="group__group-functional.html#gafca60c09e1f7a32a2b52baaf6515c279">hana::lockstep</a>(<a class="code" href="group__group-_monoid.html#gaeb5d4a1e967e319712f9e4791948896c">hana::plus</a>)(to_int, increment)(<span class="charliteral">&#39;3&#39;</span>, 4) == 3 + 5, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="alockstep_8hpp_html"><div class="ttname"><a href="lockstep_8hpp.html">lockstep.hpp</a></div><div class="ttdoc">Defines boost::hana::lockstep.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga35c4fc3c5677b9f558150b90e74d3ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35c4fc3c5677b9f558150b90e74d3ab1">&#9670;&nbsp;</a></span>on</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::on</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="on_8hpp.html">boost/hana/functional/on.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>([](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; g) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> forwarded(f)(g(forwarded(x))...);</div>
<div class="line">        };</div>
<div class="line">    })</div>
</div><!-- fragment -->
<p>Invoke a function with the result of invoking another function on each argument. </p>
<p>Specifically, <code>on(f, g)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(f, g)(x...) == f(g(x)...)</div>
<div class="ttc" id="agroup__group-functional_html_ga35c4fc3c5677b9f558150b90e74d3ab1"><div class="ttname"><a href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">boost::hana::on</a></div><div class="ttdeci">constexpr auto on</div><div class="ttdoc">Invoke a function with the result of invoking another function on each argument.</div><div class="ttdef"><b>Definition:</b> on.hpp:54</div></div>
</div><!-- fragment --><p>For convenience, <code>on</code> also supports infix application as provided by <code>infix</code>.</p>
<dl class="section note"><dt>Note</dt><dd><code>on</code> is associative, i.e. <code>on(f, on(g, h))</code> is equivalent to <code>on(on(f, g), h)</code>.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(f, <a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(g, h))(xs...) == f(<a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(g, h)(xs)...)</div>
<div class="line">                       == f(g(h(xs))...)</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(<a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(f, g), h)(xs...) == <a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(f, g)(h(xs)...)</div>
<div class="line">                       == f(g(h(xs))...)</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md38"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="first_8hpp.html">boost/hana/first.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="on_8hpp.html">boost/hana/functional/on.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="less_8hpp.html">boost/hana/less.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plus_8hpp.html">boost/hana/plus.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sort_8hpp.html">boost/hana/sort.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// infix application</span></div>
<div class="line">constexpr <span class="keyword">auto</span> sorted = hana::sort.by(<a class="code" href="group__group-_orderable.html#gad510011602bdb14686f1c4ec145301c9">hana::less</a> ^<a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">hana::on</a>^ <a class="code" href="group__group-_product.html#ga34bbf4281de06dc3540441e8b2bd24f4">hana::first</a>, hana::make_tuple(</div>
<div class="line">    hana::make_pair(hana::int_c&lt;3&gt;, <span class="charliteral">&#39;x&#39;</span>),</div>
<div class="line">    hana::make_pair(hana::int_c&lt;1&gt;, hana::type_c&lt;void&gt;),</div>
<div class="line">    hana::make_pair(hana::int_c&lt;2&gt;, 9876)</div>
<div class="line">));</div>
<div class="line"> </div>
<div class="line">static_assert(sorted == hana::make_tuple(</div>
<div class="line">    hana::make_pair(hana::int_c&lt;1&gt;, hana::type_c&lt;void&gt;),</div>
<div class="line">    hana::make_pair(hana::int_c&lt;2&gt;, 9876),</div>
<div class="line">    hana::make_pair(hana::int_c&lt;3&gt;, <span class="charliteral">&#39;x&#39;</span>)</div>
<div class="line">), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// function call syntax</span></div>
<div class="line">constexpr <span class="keyword">auto</span> x = hana::make_pair(1, 2);</div>
<div class="line">constexpr <span class="keyword">auto</span> y = hana::make_pair(10, 20);</div>
<div class="line">static_assert(<a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">hana::on</a>(<a class="code" href="group__group-_monoid.html#gaeb5d4a1e967e319712f9e4791948896c">hana::plus</a>, <a class="code" href="group__group-_product.html#ga34bbf4281de06dc3540441e8b2bd24f4">hana::first</a>)(x, y) == 1 + 10, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="afirst_8hpp_html"><div class="ttname"><a href="first_8hpp.html">first.hpp</a></div><div class="ttdoc">Defines boost::hana::first.</div></div>
<div class="ttc" id="agroup__group-_orderable_html_gad510011602bdb14686f1c4ec145301c9"><div class="ttname"><a href="group__group-_orderable.html#gad510011602bdb14686f1c4ec145301c9">boost::hana::less</a></div><div class="ttdeci">constexpr auto less</div><div class="ttdoc">Returns a Logical representing whether x is less than y.</div><div class="ttdef"><b>Definition:</b> less.hpp:37</div></div>
<div class="ttc" id="agroup__group-_product_html_ga34bbf4281de06dc3540441e8b2bd24f4"><div class="ttname"><a href="group__group-_product.html#ga34bbf4281de06dc3540441e8b2bd24f4">boost::hana::first</a></div><div class="ttdeci">constexpr auto first</div><div class="ttdoc">Returns the first element of a pair.</div><div class="ttdef"><b>Definition:</b> first.hpp:33</div></div>
<div class="ttc" id="aintegral__constant_8hpp_html"><div class="ttname"><a href="integral__constant_8hpp.html">integral_constant.hpp</a></div><div class="ttdoc">Defines boost::hana::integral_constant.</div></div>
<div class="ttc" id="aless_8hpp_html"><div class="ttname"><a href="less_8hpp.html">less.hpp</a></div><div class="ttdoc">Defines boost::hana::less.</div></div>
<div class="ttc" id="aon_8hpp_html"><div class="ttname"><a href="on_8hpp.html">on.hpp</a></div><div class="ttdoc">Defines boost::hana::on.</div></div>
<div class="ttc" id="asort_8hpp_html"><div class="ttname"><a href="sort_8hpp.html">sort.hpp</a></div><div class="ttdoc">Defines boost::hana::sort.</div></div>
<div class="ttc" id="atuple_8hpp_html"><div class="ttname"><a href="tuple_8hpp.html">tuple.hpp</a></div><div class="ttdoc">Defines boost::hana::tuple.</div></div>
<div class="ttc" id="atype_8hpp_html"><div class="ttname"><a href="type_8hpp.html">type.hpp</a></div><div class="ttdoc">Defines boost::hana::type and related utilities.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga83e71bae315e299f9f5f9de77b012139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83e71bae315e299f9f5f9de77b012139">&#9670;&nbsp;</a></span>overload</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::overload</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="overload_8hpp.html">boost/hana/functional/overload.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f1, <span class="keyword">auto</span>&amp;&amp; f2, ..., <span class="keyword">auto</span>&amp;&amp; fn) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> forwarded(fk)(forwarded(x)...);</div>
<div class="line">        };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Pick one of several functions to call based on overload resolution. </p>
<p>Specifically, <code>overload(f1, f2, ..., fn)</code> is a function object such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga83e71bae315e299f9f5f9de77b012139">overload</a>(f1, f2, ..., fn)(x...) == fk(x...)</div>
<div class="ttc" id="agroup__group-functional_html_ga83e71bae315e299f9f5f9de77b012139"><div class="ttname"><a href="group__group-functional.html#ga83e71bae315e299f9f5f9de77b012139">boost::hana::overload</a></div><div class="ttdeci">constexpr auto overload</div><div class="ttdoc">Pick one of several functions to call based on overload resolution.</div><div class="ttdef"><b>Definition:</b> overload.hpp:35</div></div>
</div><!-- fragment --><p>where <code>fk</code> is the function of <code>f1, ..., fn</code> that would be called if overload resolution was performed amongst that set of functions only. If more than one function <code>fk</code> would be picked by overload resolution, then the call is ambiguous.</p>
<h3><a class="anchor" id="autotoc_md39"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="overload_8hpp.html">boost/hana/functional/overload.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> on_string = [](std::string <span class="keyword">const</span>&amp; s) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;matched std::string: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> s;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> on_int = [](<span class="keywordtype">int</span> i) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;matched int: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> i;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> f = <a class="code" href="group__group-functional.html#ga83e71bae315e299f9f5f9de77b012139">hana::overload</a>(on_int, on_string);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// prints &quot;matched int: 1&quot;</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(f(1) == 1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// prints &quot;matched std::string: abcdef&quot;</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(f(<span class="stringliteral">&quot;abcdef&quot;</span>) == std::string{<span class="stringliteral">&quot;abcdef&quot;</span>});</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group-assertions_html_ga4796ae107d58b67e0bbccd5ae6f70101"><div class="ttname"><a href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a></div><div class="ttdeci">#define BOOST_HANA_RUNTIME_CHECK(...)</div><div class="ttdoc">Equivalent to BOOST_HANA_RUNTIME_ASSERT, but not influenced by the BOOST_HANA_CONFIG_DISABLE_ASSERTIO...</div><div class="ttdef"><b>Definition:</b> assert.hpp:209</div></div>
<div class="ttc" id="aoverload_8hpp_html"><div class="ttname"><a href="overload_8hpp.html">overload.hpp</a></div><div class="ttdoc">Defines boost::hana::overload.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaa46de6f618d9f14edb1589b36b6e75ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa46de6f618d9f14edb1589b36b6e75ec">&#9670;&nbsp;</a></span>overload_linearly</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::overload_linearly</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="overload__linearly_8hpp.html">boost/hana/functional/overload_linearly.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f1, <span class="keyword">auto</span>&amp;&amp; f2, ..., <span class="keyword">auto</span>&amp;&amp; fn) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> forwarded(fk)(forwarded(x)...);</div>
<div class="line">        };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Call the first function that produces a valid call expression. </p>
<p>Given functions <code>f1, ..., fn</code>, <code>overload_linearly(f1, ..., fn)</code> is a new function that calls the first <code>fk</code> producing a valid call expression with the given arguments. Specifically, </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#gaa46de6f618d9f14edb1589b36b6e75ec">overload_linearly</a>(f1, ..., fn)(args...) == fk(args...)</div>
<div class="ttc" id="agroup__group-functional_html_gaa46de6f618d9f14edb1589b36b6e75ec"><div class="ttname"><a href="group__group-functional.html#gaa46de6f618d9f14edb1589b36b6e75ec">boost::hana::overload_linearly</a></div><div class="ttdeci">constexpr auto overload_linearly</div><div class="ttdoc">Call the first function that produces a valid call expression.</div><div class="ttdef"><b>Definition:</b> overload_linearly.hpp:38</div></div>
</div><!-- fragment --><p>where <code>fk</code> is the <em>first</em> function such that <code>fk(args...)</code> is a valid expression.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="overload__linearly_8hpp.html">boost/hana/functional/overload_linearly.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> f = <a class="code" href="group__group-functional.html#gaa46de6f618d9f14edb1589b36b6e75ec">hana::overload_linearly</a>(</div>
<div class="line">    [](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i + 1; },</div>
<div class="line">    [](std::string s) { <span class="keywordflow">return</span> s + <span class="stringliteral">&quot;d&quot;</span>; },</div>
<div class="line">    [](double) { <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;never called&quot;</span>); }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(f(1) == 2);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(f(<span class="stringliteral">&quot;abc&quot;</span>) == <span class="stringliteral">&quot;abcd&quot;</span>);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(f(2.2) == <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(2.2) + 1);</div>
<div class="line">}</div>
<div class="ttc" id="aoverload__linearly_8hpp_html"><div class="ttname"><a href="overload__linearly_8hpp.html">overload_linearly.hpp</a></div><div class="ttdoc">Defines boost::hana::overload_linearly.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga778b2daa27882e71d28b6f2b38982ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga778b2daa27882e71d28b6f2b38982ddf">&#9670;&nbsp;</a></span>partial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::partial</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partial_8hpp.html">boost/hana/functional/partial.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; ...x) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...y) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> forwarded(f)(forwarded(x)..., forwarded(y)...);</div>
<div class="line">        };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Partially apply a function to some arguments. </p>
<p>Given a function <code>f</code> and some arguments, <code>partial</code> returns a new function corresponding to the partially applied function <code>f</code>. This allows providing some arguments to a function and letting the rest of the arguments be provided later. Specifically, <code>partial(f, x...)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga778b2daa27882e71d28b6f2b38982ddf">partial</a>(f, x...)(y...) == f(x..., y...)</div>
<div class="ttc" id="agroup__group-functional_html_ga778b2daa27882e71d28b6f2b38982ddf"><div class="ttname"><a href="group__group-functional.html#ga778b2daa27882e71d28b6f2b38982ddf">boost::hana::partial</a></div><div class="ttdeci">constexpr auto partial</div><div class="ttdoc">Partially apply a function to some arguments.</div><div class="ttdef"><b>Definition:</b> partial.hpp:43</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The arity of <code>f</code> must match the total number of arguments passed to it, i.e. <code>sizeof...(x) + sizeof...(y)</code>.</dd></dl>
<h2><a class="anchor" id="autotoc_md41"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="partial_8hpp.html">boost/hana/functional/partial.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plus_8hpp.html">boost/hana/plus.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">constexpr <span class="keyword">auto</span> increment = <a class="code" href="group__group-functional.html#ga778b2daa27882e71d28b6f2b38982ddf">hana::partial</a>(<a class="code" href="group__group-_monoid.html#gaeb5d4a1e967e319712f9e4791948896c">hana::plus</a>, 1);</div>
<div class="line">static_assert(increment(2) == 3, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="apartial_8hpp_html"><div class="ttname"><a href="partial_8hpp.html">partial.hpp</a></div><div class="ttdoc">Defines boost::hana::partial.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaefe9fd152cba94be71c2b5b9de689d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefe9fd152cba94be71c2b5b9de689d23">&#9670;&nbsp;</a></span>_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unspecified boost::hana::_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="placeholder_8hpp.html">boost/hana/functional/placeholder.hpp</a>&gt;</code></p>

<p>Create simple functions representing C++ operators inline. </p>
<p>Specifically, <code>_</code> is an object used as a placeholder to build function objects representing calls to C++ operators. It works by overloading the operators between <code>_</code> and any object so that they return a function object which actually calls the corresponding operator on its argument(s). Hence, for any supported operator <code>@</code>: </p><div class="fragment"><div class="line">(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> @ <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>)(x, y) == x @ y</div>
<div class="ttc" id="agroup__group-functional_html_gaefe9fd152cba94be71c2b5b9de689d23"><div class="ttname"><a href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">boost::hana::_</a></div><div class="ttdeci">constexpr unspecified _</div><div class="ttdoc">Create simple functions representing C++ operators inline.</div><div class="ttdef"><b>Definition:</b> placeholder.hpp:70</div></div>
</div><!-- fragment --><p>Operators may also be partially applied to one argument inline: </p><div class="fragment"><div class="line">(x @ <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>)(y) == x @ y</div>
<div class="line">(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> @ y)(x) == x @ y</div>
</div><!-- fragment --><p>When invoked with more arguments than required, functions created with <code>_</code> will discard the superfluous instead of triggering an error: </p><div class="fragment"><div class="line">(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> @ <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>)(x, y, z...) == x @ y</div>
</div><!-- fragment --><p>This makes functions created with <code>_</code> easier to use in higher-order algorithms, which sometime provide more information than necessary to their callbacks.</p>
<h3><a class="anchor" id="autotoc_md42"></a>
Supported operators</h3>
<ul>
<li>Arithmetic: binary <code>+</code>, binary <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>, unary <code>+</code>, unary <code>-</code></li>
<li>Bitwise: <code>~</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
<li>Comparison: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
<li>Logical: <code>||</code>, <code>&amp;&amp;</code>, <code>!</code></li>
<li>Member access: <code>*</code> (dereference), <code>[]</code> (array subscript)</li>
<li>Other: <code>()</code> (function call)</li>
</ul>
<p>More complex functionality like the ability to compose placeholders into larger function objects inline are not supported. This is on purpose; you should either use C++14 generic lambdas or a library like <a href="http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/index.html">Boost.Phoenix</a> if you need bigger guns. The goal here is to save you a couple of characters in simple situations.</p>
<h3><a class="anchor" id="autotoc_md43"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="placeholder_8hpp.html">boost/hana/functional/placeholder.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">constexpr <span class="keyword">auto</span> <a class="code" href="group__group-_monoid.html#gaeb5d4a1e967e319712f9e4791948896c">plus</a> = <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">hana::_</a> + <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">hana::_</a>;</div>
<div class="line">static_assert(<a class="code" href="group__group-_monoid.html#gaeb5d4a1e967e319712f9e4791948896c">plus</a>(1, 2) == 1 + 2, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keyword">auto</span> increment = <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">hana::_</a> + 1;</div>
<div class="line">static_assert(increment(1) == 2, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line">constexpr <span class="keyword">auto</span> twice = 2 * <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">hana::_</a>;</div>
<div class="line">static_assert(twice(1) == 2, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extra arguments are ignored.</span></div>
<div class="line">static_assert(twice(1, <span class="stringliteral">&quot;ignored&quot;</span>) == 2, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="aplaceholder_8hpp_html"><div class="ttname"><a href="placeholder_8hpp.html">placeholder.hpp</a></div><div class="ttdoc">Defines boost::hana::_.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga6e648f0d3fc0209ec024e9d759a5e8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e648f0d3fc0209ec024e9d759a5e8f8">&#9670;&nbsp;</a></span>reverse_partial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::reverse_partial</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reverse__partial_8hpp.html">boost/hana/functional/reverse_partial.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; ...x) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...y) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> forwarded(f)(forwarded(y)..., forwarded(x)...);</div>
<div class="line">        };</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Partially apply a function to some arguments. </p>
<p>Given a function <code>f</code> and some arguments, <code>reverse_partial</code> returns a new function corresponding to <code>f</code> whose last arguments are partially applied. Specifically, <code>reverse_partial(f, x...)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga6e648f0d3fc0209ec024e9d759a5e8f8">reverse_partial</a>(f, x...)(y...) == f(y..., x...)</div>
<div class="ttc" id="agroup__group-functional_html_ga6e648f0d3fc0209ec024e9d759a5e8f8"><div class="ttname"><a href="group__group-functional.html#ga6e648f0d3fc0209ec024e9d759a5e8f8">boost::hana::reverse_partial</a></div><div class="ttdeci">constexpr auto reverse_partial</div><div class="ttdoc">Partially apply a function to some arguments.</div><div class="ttdef"><b>Definition:</b> reverse_partial.hpp:42</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The arity of <code>f</code> must match the total number of arguments passed to it, i.e. <code>sizeof...(x) + sizeof...(y)</code>.</dd></dl>
<h2><a class="anchor" id="autotoc_md44"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="div_8hpp.html">boost/hana/div.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="reverse__partial_8hpp.html">boost/hana/functional/reverse_partial.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">constexpr <span class="keyword">auto</span> half = <a class="code" href="group__group-functional.html#ga6e648f0d3fc0209ec024e9d759a5e8f8">hana::reverse_partial</a>(<a class="code" href="group__group-_euclidean_ring.html#ga4225a7988ce98903228913dde53762df">hana::div</a>, 2);</div>
<div class="line">static_assert(half(4) == 2, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(half(8) == 4, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="adiv_8hpp_html"><div class="ttname"><a href="div_8hpp.html">div.hpp</a></div><div class="ttdoc">Defines boost::hana::div.</div></div>
<div class="ttc" id="agroup__group-_euclidean_ring_html_ga4225a7988ce98903228913dde53762df"><div class="ttname"><a href="group__group-_euclidean_ring.html#ga4225a7988ce98903228913dde53762df">boost::hana::div</a></div><div class="ttdeci">constexpr auto div</div><div class="ttdoc">Generalized integer division.</div><div class="ttdef"><b>Definition:</b> div.hpp:43</div></div>
<div class="ttc" id="areverse__partial_8hpp_html"><div class="ttname"><a href="reverse__partial_8hpp.html">reverse_partial.hpp</a></div><div class="ttdoc">Defines boost::hana::reverse_partial.</div></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
