<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>Boost.Hana: Functor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.7.1</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group-_functor.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Functor<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p>The <code>Functor</code> concept represents types that can be mapped over. </p>
<p>Intuitively, a <a href="http://en.wikipedia.org/wiki/Functor">Functor</a> is some kind of box that can hold generic data and map a function over this data to create a new, transformed box. Because we are only interested in mapping a function over the contents of a black box, the only real requirement for being a functor is to provide a function which can do the mapping, along with a couple of guarantees that the mapping is well-behaved. Those requirements are made precise in the laws below. The pattern captured by <code>Functor</code> is very general, which makes it widely useful. A lot of objects can be made <code>Functor</code>s in one way or another, the most obvious example being sequences with the usual mapping of the function on each element. While this documentation will not go into much more details about the nature of functors, the <a href="https://wiki.haskell.org/Typeclassopedia#Functor">Typeclassopedia</a> is a nice Haskell-oriented resource for such information.</p>
<p>Functors are parametric data types which are parameterized over the data type of the objects they contain. Like everywhere else in Hana, this parametricity is only at the documentation level and it is not enforced.</p>
<p>In this library, the mapping function is called <code>transform</code> after the <code>std::transform</code> algorithm, but other programming languages have given it different names (usually <code>map</code>).</p>
<dl class="section note"><dt>Note</dt><dd>The word <em>functor</em> comes from functional programming, where the concept has been used for a while, notably in the Haskell programming language. Haskell people borrowed the term from <a href="http://en.wikipedia.org/wiki/Category_theory">category theory</a>, which, broadly speaking, is a field of mathematics dealing with abstract structures and transformations between those structures.</dd></dl>
<h2><a class="anchor" id="autotoc_md106"></a>
Minimal complete definitions</h2>
<ol type="1">
<li><code>transform</code><br  />
When <code>transform</code> is specified, <code>adjust_if</code> is defined analogously to <div class="fragment"><div class="line">adjust_if(xs, pred, f) = transform(xs, [](x){</div>
<div class="line">    <span class="keywordflow">if</span> pred(x) <a class="code" href="group__group-_monad.html#gaaddd3789de43cf989babb10cdc0b447a">then</a> f(x) <span class="keywordflow">else</span> x</div>
<div class="line">})</div>
<div class="ttc" id="agroup__group-_monad_html_gaaddd3789de43cf989babb10cdc0b447a"><div class="ttname"><a href="group__group-_monad.html#gaaddd3789de43cf989babb10cdc0b447a">boost::hana::then</a></div><div class="ttdeci">constexpr auto then</div><div class="ttdoc">Sequentially compose two monadic actions, discarding any value produced by the first but not its effe...</div><div class="ttdef"><b>Definition:</b> then.hpp:36</div></div>
</div><!-- fragment --></li>
<li><code>adjust_if</code><br  />
When <code>adjust_if</code> is specified, <code>transform</code> is defined analogously to <div class="fragment"><div class="line">transform(xs, f) = adjust_if(xs, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(<span class="keyword">true</span>), f)</div>
<div class="ttc" id="agroup__group-functional_html_ga835970cb25a0c8dc200f1e5f8943538b"><div class="ttname"><a href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">boost::hana::always</a></div><div class="ttdeci">constexpr auto always</div><div class="ttdoc">Return a constant function returning x regardless of the argument(s) it is invoked with.</div><div class="ttdef"><b>Definition:</b> always.hpp:37</div></div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="autotoc_md107"></a>
Laws</h2>
<p>Let <code>xs</code> be a Functor with tag <code>F(A)</code>, \( f : A \to B \) and \( g : B \to C \). The following laws must be satisfied: </p><div class="fragment"><div class="line">transform(xs, <span class="keywordtype">id</span>) == xs</div>
<div class="line">transform(xs, <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(g, f)) == transform(transform(xs, f), g)</div>
<div class="ttc" id="agroup__group-functional_html_ga3b16146e53efcdf9ecbb9a7b21f8cd0b"><div class="ttname"><a href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">boost::hana::compose</a></div><div class="ttdeci">constexpr auto compose</div><div class="ttdoc">Return the composition of two functions or more.</div><div class="ttdef"><b>Definition:</b> compose.hpp:52</div></div>
</div><!-- fragment --><p> The first line says that mapping the identity function should not do anything, which precludes the functor from doing something nasty behind the scenes. The second line states that mapping the composition of two functions is the same as mapping the first function, and then the second on the result. While the usual functor laws are usually restricted to the above, this library includes other convenience methods and they should satisfy the following equations. Let <code>xs</code> be a Functor with tag <code>F(A)</code>, \( f : A \to A \), \( \mathrm{pred} : A \to \mathrm{Bool} \) for some <code>Logical</code> <code>Bool</code>, and <code>oldval</code>, <code>newval</code>, <code>value</code> objects of tag <code>A</code>. Then, </p><div class="fragment"><div class="line">adjust(xs, <a class="code" href="group__group-_constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>, f) == adjust_if(xs, <a class="code" href="group__group-_comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">equal</a>.to(<a class="code" href="group__group-_constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>), f)</div>
<div class="line">adjust_if(xs, pred, f) == transform(xs, [](x){</div>
<div class="line">    <span class="keywordflow">if</span> pred(x) <a class="code" href="group__group-_monad.html#gaaddd3789de43cf989babb10cdc0b447a">then</a> f(x) <span class="keywordflow">else</span> x</div>
<div class="line">})</div>
<div class="line">replace_if(xs, pred, <a class="code" href="group__group-_constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>) == adjust_if(xs, pred, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(<a class="code" href="group__group-_constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>))</div>
<div class="line">replace(xs, oldval, newval) == replace_if(xs, <a class="code" href="group__group-_comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">equal</a>.to(oldval), newval)</div>
<div class="line">fill(xs, <a class="code" href="group__group-_constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>)             == replace_if(xs, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(<span class="keyword">true</span>), <a class="code" href="group__group-_constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>)</div>
<div class="ttc" id="agroup__group-_comparable_html_gacaf1ebea6b3ab96ac9dcb82f0e64e547"><div class="ttname"><a href="group__group-_comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">boost::hana::equal</a></div><div class="ttdeci">constexpr auto equal</div><div class="ttdoc">Returns a Logical representing whether x is equal to y.</div><div class="ttdef"><b>Definition:</b> equal.hpp:64</div></div>
<div class="ttc" id="agroup__group-_constant_html_ga1687520692a6b0c49e3a69de2980f388"><div class="ttname"><a href="group__group-_constant.html#ga1687520692a6b0c49e3a69de2980f388">boost::hana::value</a></div><div class="ttdeci">constexpr auto value</div><div class="ttdoc">Return the compile-time value associated to a constant.</div><div class="ttdef"><b>Definition:</b> value.hpp:54</div></div>
</div><!-- fragment --><p> The default definition of the methods will satisfy these equations.</p>
<h2><a class="anchor" id="autotoc_md108"></a>
Concrete models</h2>
<p><code><a class="el" href="structboost_1_1hana_1_1lazy.html" title="hana::lazy implements superficial laziness via a monadic interface.">hana::lazy</a></code>, <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time.">hana::optional</a></code>, <code><a class="el" href="structboost_1_1hana_1_1tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length.">hana::tuple</a></code></p>
<h2><a class="anchor" id="autotoc_md109"></a>
Structure-preserving functions for Functors</h2>
<p>A mapping between two functors which also preserves the functor laws is called a natural transformation (the term comes from category theory). A natural transformation is a function <code>f</code> from a functor <code>F</code> to a functor <code>G</code> such that for every other function <code>g</code> with an appropriate signature and for every object <code>xs</code> of tag <code>F(X)</code>, </p><div class="fragment"><div class="line">f(transform(xs, g)) == transform(f(xs), g)</div>
</div><!-- fragment --><p>There are several examples of such transformations, like <code>to&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples.">tuple_tag</a>&gt;</code> when applied to an optional value. Indeed, for any function <code>g</code> and <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time.">hana::optional</a></code> <code>opt</code>, </p><div class="fragment"><div class="line">to&lt;tuple_tag&gt;(transform(opt, g)) == transform(to&lt;tuple_tag&gt;(opt), g)</div>
</div><!-- fragment --><p>Of course, natural transformations are not limited to the <code>to&lt;...&gt;</code> functions. However, note that any conversion function between Functors should be natural for the behavior of the conversion to be intuitive. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
