<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>Boost.Hana: MonadPlus</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.7.1</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group-_monad_plus.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">MonadPlus<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The <code>MonadPlus</code> concept represents Monads with a monoidal structure. </p>
<p>Intuitively, whereas a Monad can be seen as some kind of container or context, a MonadPlus can be seen as a container or a context that can be concatenated with other containers or contexts. There must also be an identity element for this combining operation. For example, a tuple is a MonadPlus, because tuples can be concatenated and the empty tuple would act as an identity for concatenation. How is this different from a Monad which is also a Monoid? The answer is that the monoidal structure on a MonadPlus must <em>not</em> depend of the contents of the structure; it must not require the contents to be a Monoid in order to work.</p>
<p>While sequences are not the only possible model for MonadPlus, the method names used here refer to the MonadPlus of sequences under concatenation. Several useful functions generalizing operations on sequences are included with this concept, like <code>append</code>, <code>prepend</code> and <code>filter</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This documentation does not go into much details about the nature of the MonadPlus concept. However, there is a nice Haskell-oriented <a href="https://en.wikibooks.org/wiki/Haskell/MonadPlus">WikiBook</a> going into further details.</dd></dl>
<h2><a class="anchor" id="autotoc_md139"></a>
Minimal complete definition</h2>
<p><code>concat</code> and <code>empty</code></p>
<h2><a class="anchor" id="autotoc_md140"></a>
Laws</h2>
<p>First, a MonadPlus is required to have a monoidal structure. Hence, it is no surprise that for any MonadPlus <code>M</code>, we require <code>M(T)</code> to be a valid monoid. However, we do not enforce that <code>M(T)</code> actually models the Monoid concept provided by Hana. Further, for all objects <code>a, b, c</code> of data type <code>M(T)</code>, </p><div class="fragment"><div class="line"><span class="comment">// identity</span></div>
<div class="line"><a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(<a class="code" href="group__group-_monad_plus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">empty</a>&lt;M(T)&gt;(), a) == a</div>
<div class="line"><a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(a, <a class="code" href="group__group-_monad_plus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">empty</a>&lt;M(T)&gt;()) == a</div>
<div class="line"> </div>
<div class="line"><span class="comment">// associativity</span></div>
<div class="line"><a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(a, <a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(b, c)) == <a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(<a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(a, b), c)</div>
<div class="ttc" id="agroup__group-_monad_plus_html_ga1946e96c3b4c178c7ae8703724c29c37"><div class="ttname"><a href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">boost::hana::concat</a></div><div class="ttdeci">constexpr auto concat</div><div class="ttdoc">Combine two monadic structures together.</div><div class="ttdef"><b>Definition:</b> concat.hpp:47</div></div>
<div class="ttc" id="agroup__group-_monad_plus_html_gaa6be1e83ad72b9d69b43b4bada0f3a75"><div class="ttname"><a href="group__group-_monad_plus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">boost::hana::empty</a></div><div class="ttdeci">constexpr auto empty</div><div class="ttdoc">Identity of the monadic combination concat.</div><div class="ttdef"><b>Definition:</b> empty.hpp:36</div></div>
</div><!-- fragment --><p>Secondly, a MonadPlus is also required to obey the following laws, which represent the fact that <code>empty&lt;M(T)&gt;()</code> must be some kind of absorbing element for the <code>chain</code> operation. For all objects <code>a</code> of data type <code>M(T)</code> and functions \( f : T \to M(U) \), </p><div class="fragment"><div class="line">chain(<a class="code" href="group__group-_monad_plus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">empty</a>&lt;M(T)&gt;(), f)         == empty&lt;M(U)&gt;()</div>
<div class="line">chain(a, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(<a class="code" href="group__group-_monad_plus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">empty</a>&lt;M(T)&gt;())) == <a class="code" href="group__group-_monad_plus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">empty</a>&lt;M(U)&gt;()</div>
<div class="ttc" id="agroup__group-functional_html_ga835970cb25a0c8dc200f1e5f8943538b"><div class="ttname"><a href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">boost::hana::always</a></div><div class="ttdeci">constexpr auto always</div><div class="ttdoc">Return a constant function returning x regardless of the argument(s) it is invoked with.</div><div class="ttdef"><b>Definition:</b> always.hpp:37</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md141"></a>
Refined concepts</h2>
<p><code>Functor</code>, <code>Applicative</code> and <code>Monad</code></p>
<h2><a class="anchor" id="autotoc_md142"></a>
Concrete models</h2>
<p><code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time.">hana::optional</a></code>, <code><a class="el" href="structboost_1_1hana_1_1tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length.">hana::tuple</a></code> </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga08624924fe05f0cfbfbd6e439db01873"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_monad_plus.html#ga08624924fe05f0cfbfbd6e439db01873">boost::hana::append</a></td></tr>
<tr class="memdesc:ga08624924fe05f0cfbfbd6e439db01873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an element to a monadic structure.  <a href="group__group-_monad_plus.html#ga08624924fe05f0cfbfbd6e439db01873">More...</a><br /></td></tr>
<tr class="separator:ga08624924fe05f0cfbfbd6e439db01873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1946e96c3b4c178c7ae8703724c29c37"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">boost::hana::concat</a></td></tr>
<tr class="memdesc:ga1946e96c3b4c178c7ae8703724c29c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine two monadic structures together.  <a href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">More...</a><br /></td></tr>
<tr class="separator:ga1946e96c3b4c178c7ae8703724c29c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf46c168f721da9effcc7336a997f5d6"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_monad_plus.html#gaaf46c168f721da9effcc7336a997f5d6">boost::hana::cycle</a></td></tr>
<tr class="memdesc:gaaf46c168f721da9effcc7336a997f5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine a monadic structure with itself <code>n</code> times.  <a href="group__group-_monad_plus.html#gaaf46c168f721da9effcc7336a997f5d6">More...</a><br /></td></tr>
<tr class="separator:gaaf46c168f721da9effcc7336a997f5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6be1e83ad72b9d69b43b4bada0f3a75"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gaa6be1e83ad72b9d69b43b4bada0f3a75"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-_monad_plus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">boost::hana::empty</a></td></tr>
<tr class="memdesc:gaa6be1e83ad72b9d69b43b4bada0f3a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity of the monadic combination <code>concat</code>.  <a href="group__group-_monad_plus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">More...</a><br /></td></tr>
<tr class="separator:gaa6be1e83ad72b9d69b43b4bada0f3a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65cc6d9f522fb9e8e3b28d80ee5c822a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_monad_plus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">boost::hana::filter</a></td></tr>
<tr class="memdesc:ga65cc6d9f522fb9e8e3b28d80ee5c822a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a monadic structure using a custom predicate.  <a href="group__group-_monad_plus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">More...</a><br /></td></tr>
<tr class="separator:ga65cc6d9f522fb9e8e3b28d80ee5c822a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3022fdfe454dc9bc1f79b5dfeba13b5e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_monad_plus.html#ga3022fdfe454dc9bc1f79b5dfeba13b5e">boost::hana::prefix</a></td></tr>
<tr class="memdesc:ga3022fdfe454dc9bc1f79b5dfeba13b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a value before each element of a monadic structure.  <a href="group__group-_monad_plus.html#ga3022fdfe454dc9bc1f79b5dfeba13b5e">More...</a><br /></td></tr>
<tr class="separator:ga3022fdfe454dc9bc1f79b5dfeba13b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69afbfd4e91125e3e52fcb409135ca7c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_monad_plus.html#ga69afbfd4e91125e3e52fcb409135ca7c">boost::hana::prepend</a></td></tr>
<tr class="memdesc:ga69afbfd4e91125e3e52fcb409135ca7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepend an element to a monadic structure.  <a href="group__group-_monad_plus.html#ga69afbfd4e91125e3e52fcb409135ca7c">More...</a><br /></td></tr>
<tr class="separator:ga69afbfd4e91125e3e52fcb409135ca7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee54dc1195f9e5cf48bfd51ba231ae5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_monad_plus.html#ga5ee54dc1195f9e5cf48bfd51ba231ae5">boost::hana::mathrm</a></td></tr>
<tr class="memdesc:ga5ee54dc1195f9e5cf48bfd51ba231ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the elements of a monadic structure that are equal to some value.  <a href="group__group-_monad_plus.html#ga5ee54dc1195f9e5cf48bfd51ba231ae5">More...</a><br /></td></tr>
<tr class="separator:ga5ee54dc1195f9e5cf48bfd51ba231ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f48c79d11923d6c1d70b18b7dd3f19"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gad5f48c79d11923d6c1d70b18b7dd3f19"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-_monad_plus.html#gad5f48c79d11923d6c1d70b18b7dd3f19">boost::hana::replicate</a></td></tr>
<tr class="memdesc:gad5f48c79d11923d6c1d70b18b7dd3f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a monadic structure by combining a lifted value with itself <code>n</code> times.  <a href="group__group-_monad_plus.html#gad5f48c79d11923d6c1d70b18b7dd3f19">More...</a><br /></td></tr>
<tr class="separator:gad5f48c79d11923d6c1d70b18b7dd3f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61dab15f6ecf379121d4096fe0c8ab13"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_monad_plus.html#ga61dab15f6ecf379121d4096fe0c8ab13">boost::hana::suffix</a></td></tr>
<tr class="memdesc:ga61dab15f6ecf379121d4096fe0c8ab13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a value after each element of a monadic structure.  <a href="group__group-_monad_plus.html#ga61dab15f6ecf379121d4096fe0c8ab13">More...</a><br /></td></tr>
<tr class="separator:ga61dab15f6ecf379121d4096fe0c8ab13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga08624924fe05f0cfbfbd6e439db01873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08624924fe05f0cfbfbd6e439db01873">&#9670;&nbsp;</a></span>append</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::append</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2append_8hpp.html">boost/hana/fwd/append.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; x) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Append an element to a monadic structure. </p>
<p>Given an element <code>x</code> and a monadic structure <code>xs</code>, <code>append</code> returns a new monadic structure which is the result of lifting <code>x</code> into the monadic structure and then combining that (to the right) with <code>xs</code>. In other words, </p><div class="fragment"><div class="line"><a class="code" href="group__group-_monad_plus.html#ga08624924fe05f0cfbfbd6e439db01873">append</a>(xs, x) == <a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(xs, lift&lt;Xs&gt;(x))</div>
<div class="ttc" id="agroup__group-_monad_plus_html_ga08624924fe05f0cfbfbd6e439db01873"><div class="ttname"><a href="group__group-_monad_plus.html#ga08624924fe05f0cfbfbd6e439db01873">boost::hana::append</a></div><div class="ttdeci">constexpr auto append</div><div class="ttdoc">Append an element to a monadic structure.</div><div class="ttdef"><b>Definition:</b> append.hpp:52</div></div>
</div><!-- fragment --><p> where <code>Xs</code> is the tag of <code>xs</code>. For sequences, this has the intuitive behavior of simply appending an element to the end of the sequence, hence the name.</p>
<blockquote class="doxtable">
<p>#### Rationale for not calling this <code>push_back</code> See the rationale for using <code>prepend</code> instead of <code>push_front</code>. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md57"></a>
Signature</h2>
<p>Given a MonadPlus <code>M</code>, the signature is \( \mathtt{append} : M(T) \times T \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure that will be combined to the left of the element.</td></tr>
    <tr><td class="paramname">x</td><td>An element to combine to the right of the monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md58"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="append_8hpp.html">boost/hana/append.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="group__group-_monad_plus.html#ga08624924fe05f0cfbfbd6e439db01873">hana::append</a>(hana::make_tuple(), 1) == hana::make_tuple(1), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="group__group-_monad_plus.html#ga08624924fe05f0cfbfbd6e439db01873">hana::append</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>), 3.3) == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="group__group-_monad_plus.html#ga08624924fe05f0cfbfbd6e439db01873">hana::append</a>(<a class="code" href="group__group-_monad_plus.html#ga08624924fe05f0cfbfbd6e439db01873">hana::append</a>(<a class="code" href="group__group-_monad_plus.html#ga08624924fe05f0cfbfbd6e439db01873">hana::append</a>(hana::make_tuple(), 1), <span class="charliteral">&#39;2&#39;</span>), 3.3) == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="aappend_8hpp_html"><div class="ttname"><a href="append_8hpp.html">append.hpp</a></div><div class="ttdoc">Defines boost::hana::append.</div></div>
<div class="ttc" id="aequal_8hpp_html"><div class="ttname"><a href="equal_8hpp.html">equal.hpp</a></div><div class="ttdoc">Defines boost::hana::equal.</div></div>
<div class="ttc" id="anamespaceboost_1_1hana_html"><div class="ttname"><a href="namespaceboost_1_1hana.html">boost::hana</a></div><div class="ttdoc">Namespace containing everything in the library.</div><div class="ttdef"><b>Definition:</b> accessors.hpp:20</div></div>
<div class="ttc" id="atuple_8hpp_html"><div class="ttname"><a href="tuple_8hpp.html">tuple.hpp</a></div><div class="ttdoc">Defines boost::hana::tuple.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga1946e96c3b4c178c7ae8703724c29c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1946e96c3b4c178c7ae8703724c29c37">&#9670;&nbsp;</a></span>concat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::concat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2concat_8hpp.html">boost/hana/fwd/concat.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; ys) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Combine two monadic structures together. </p>
<p>Given two monadic structures, <code>concat</code> combines them together and returns a new monadic structure. The exact definition of <code>concat</code> will depend on the exact model of MonadPlus at hand, but for sequences it corresponds intuitively to simple concatenation.</p>
<p>Also note that combination is not required to be commutative. In other words, there is no requirement that </p><div class="fragment"><div class="line"><a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(xs, ys) == <a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(ys, xs)</div>
</div><!-- fragment --><p> and indeed it does not hold in general.</p>
<h2><a class="anchor" id="autotoc_md70"></a>
Signature</h2>
<p>Given a <code>MonadPlus</code> <code>M</code>, the signature of <code>concat</code> is \( \mathtt{concat} : M(T) \times M(T) \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys</td><td>Two monadic structures to combine together.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md71"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="concat_8hpp.html">boost/hana/concat.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>hana::literals;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">static_assert(</div>
<div class="line">    <a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">hana::concat</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>), hana::make_tuple(3.3, 4_c))</div>
<div class="line">        ==</div>
<div class="line">    hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, 4_c)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="aconcat_8hpp_html"><div class="ttname"><a href="concat_8hpp.html">concat.hpp</a></div><div class="ttdoc">Defines boost::hana::concat.</div></div>
<div class="ttc" id="aintegral__constant_8hpp_html"><div class="ttname"><a href="integral__constant_8hpp.html">integral_constant.hpp</a></div><div class="ttdoc">Defines boost::hana::integral_constant.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaaf46c168f721da9effcc7336a997f5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf46c168f721da9effcc7336a997f5d6">&#9670;&nbsp;</a></span>cycle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::cycle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2cycle_8hpp.html">boost/hana/fwd/cycle.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; n) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Combine a monadic structure with itself <code>n</code> times. </p>
<p>Given a monadic structure <code>xs</code> and a non-negative number <code>n</code>, <code>cycle</code> returns a new monadic structure which is the result of combining <code>xs</code> with itself <code>n</code> times using the <code>concat</code> operation. In other words, </p><div class="fragment"><div class="line"><a class="code" href="group__group-_monad_plus.html#gaaf46c168f721da9effcc7336a997f5d6">cycle</a>(xs, n) == <a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(xs, <a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(xs, ... <a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(xs, xs)))</div>
<div class="line">                                  <span class="comment">// ^^^^^ n times total</span></div>
<div class="ttc" id="agroup__group-_monad_plus_html_gaaf46c168f721da9effcc7336a997f5d6"><div class="ttname"><a href="group__group-_monad_plus.html#gaaf46c168f721da9effcc7336a997f5d6">boost::hana::cycle</a></div><div class="ttdeci">constexpr auto cycle</div><div class="ttdoc">Combine a monadic structure with itself n times.</div><div class="ttdef"><b>Definition:</b> cycle.hpp:60</div></div>
</div><!-- fragment --><p>Also note that since <code>concat</code> is required to be associative, we could also have written </p><div class="fragment"><div class="line"><a class="code" href="group__group-_monad_plus.html#gaaf46c168f721da9effcc7336a997f5d6">cycle</a>(xs, n) == <a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(<a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(... <a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(xs, xs), xs), xs)</div>
<div class="line">                          <span class="comment">// ^^^^^ n times total</span></div>
</div><!-- fragment --><p>If <code>n</code> is zero, then the identity of <code>concat</code>, <code>empty</code>, is returned. In the case of sequences, this boils down to returning a sequence containing <code>n</code> copies of itself; for other models it might differ.</p>
<h2><a class="anchor" id="autotoc_md200"></a>
Signature</h2>
<p>Given an <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant concept represents compile-time integral values.">IntegralConstant</a></code> <code>C</code> and a <code>MonadPlus</code> <code>M</code>, the signature is \( \mathrm{cycle} : M(T) \times C \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure to combine with itself a certain number of times.</td></tr>
    <tr><td class="paramname">n</td><td>A non-negative <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant concept represents compile-time integral values.">IntegralConstant</a></code> representing the number of times to combine the monadic structure with itself. If <code>n</code> is zero, <code>cycle</code> returns <code>empty</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md201"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cycle_8hpp.html">boost/hana/cycle.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="group__group-_monad_plus.html#gaaf46c168f721da9effcc7336a997f5d6">hana::cycle</a>(hana::make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>), hana::size_c&lt;2&gt;) == hana::make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;y&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="acycle_8hpp_html"><div class="ttname"><a href="cycle_8hpp.html">cycle.hpp</a></div><div class="ttdoc">Defines boost::hana::cycle.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaa6be1e83ad72b9d69b43b4bada0f3a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6be1e83ad72b9d69b43b4bada0f3a75">&#9670;&nbsp;</a></span>empty</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2empty_8hpp.html">boost/hana/fwd/empty.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= []() {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Identity of the monadic combination <code>concat</code>. </p>
<h2><a class="anchor" id="autotoc_md210"></a>
Signature</h2>
<p>Given a MonadPlus <code>M</code>, the signature is \( \mathtt{empty}_M : \emptyset \to M(T) \).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The tag of the monadic structure to return. This must be a model of the MonadPlus concept.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md211"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="empty_8hpp.html">boost/hana/empty.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::empty&lt;hana::tuple_tag&gt;() == hana::make_tuple());</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::empty&lt;hana::optional_tag&gt;() == hana::nothing);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="aassert_8hpp_html"><div class="ttname"><a href="assert_8hpp.html">assert.hpp</a></div><div class="ttdoc">Defines macros to perform different kinds of assertions.</div></div>
<div class="ttc" id="aempty_8hpp_html"><div class="ttname"><a href="empty_8hpp.html">empty.hpp</a></div><div class="ttdoc">Defines boost::hana::empty.</div></div>
<div class="ttc" id="agroup__group-assertions_html_ga2c5006540936d9f8880e3a39f4fcc035"><div class="ttname"><a href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a></div><div class="ttdeci">#define BOOST_HANA_CONSTANT_CHECK(...)</div><div class="ttdoc">Equivalent to BOOST_HANA_CONSTANT_ASSERT, but not influenced by the BOOST_HANA_CONFIG_DISABLE_ASSERTI...</div><div class="ttdef"><b>Definition:</b> assert.hpp:239</div></div>
<div class="ttc" id="aoptional_8hpp_html"><div class="ttname"><a href="optional_8hpp.html">optional.hpp</a></div><div class="ttdoc">Defines boost::hana::optional.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga65cc6d9f522fb9e8e3b28d80ee5c822a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65cc6d9f522fb9e8e3b28d80ee5c822a">&#9670;&nbsp;</a></span>filter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::filter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2filter_8hpp.html">boost/hana/fwd/filter.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; pred) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Filter a monadic structure using a custom predicate. </p>
<p>Given a monadic structure and a predicate, <code>filter</code> returns a new monadic structure containing only those elements that satisfy the predicate. This is a generalization of the usual <code>filter</code> function for sequences; it works for any MonadPlus. Intuitively, <code>filter</code> is somewhat equivalent to: </p><div class="fragment"><div class="line"><a class="code" href="group__group-_monad_plus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">filter</a>(xs, pred) == flatten(transform(xs, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> pred(x) ? lift&lt;Xs&gt;(x) : <a class="code" href="group__group-_monad_plus.html#gaa6be1e83ad72b9d69b43b4bada0f3a75">empty</a>&lt;Xs&gt;();</div>
<div class="line">})</div>
<div class="ttc" id="agroup__group-_monad_plus_html_ga65cc6d9f522fb9e8e3b28d80ee5c822a"><div class="ttname"><a href="group__group-_monad_plus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">boost::hana::filter</a></div><div class="ttdeci">constexpr auto filter</div><div class="ttdoc">Filter a monadic structure using a custom predicate.</div><div class="ttdef"><b>Definition:</b> filter.hpp:65</div></div>
</div><!-- fragment --><p> In other words, we basically turn a monadic structure containing <code>[x1, ..., xn]</code> into a monadic structure containing </p><div class="fragment"><div class="line">[</div>
<div class="line">    pred(x1) ? [x1] : [],</div>
<div class="line">    pred(x2) ? [x2] : [],</div>
<div class="line">    ...</div>
<div class="line">    pred(xn) ? [xn] : []</div>
<div class="line">]</div>
</div><!-- fragment --><p> and we then <code>flatten</code> that.</p>
<h2><a class="anchor" id="autotoc_md220"></a>
Signature</h2>
<p>Given a <code>MonadPlus</code> <code>M</code> and an <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant concept represents compile-time integral values.">IntegralConstant</a></code> <code>Bool</code> holding a value of type <code>bool</code>, the signature is \( \mathtt{filter} : M(T) \times (T \to \mathtt{Bool}) \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The monadic structure to filter.</td></tr>
    <tr><td class="paramname">pred</td><td>A function called as <code>pred(x)</code> for each element <code>x</code> in the monadic structure and returning whether that element should be <b>kept</b> in the resulting structure. In the current version of the library, the predicate has to return an <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant concept represents compile-time integral values.">IntegralConstant</a></code> holding a value convertible to a <code>bool</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md221"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="filter_8hpp.html">boost/hana/filter.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="compose_8hpp.html">boost/hana/functional/compose.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// First take the type of an object, and then tell whether it&#39;s integral</span></div>
<div class="line">constexpr <span class="keyword">auto</span> is_integral = <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">hana::compose</a>(hana::trait&lt;std::is_integral&gt;, hana::typeid_);</div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="group__group-_monad_plus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">hana::filter</a>(hana::make_tuple(1, 2.0, 3, 4.0), is_integral) == hana::make_tuple(1, 3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="group__group-_monad_plus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">hana::filter</a>(hana::just(3), is_integral) == hana::just(3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_monad_plus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">hana::filter</a>(hana::just(3.0), is_integral) == hana::nothing);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="acompose_8hpp_html"><div class="ttname"><a href="compose_8hpp.html">compose.hpp</a></div><div class="ttdoc">Defines boost::hana::compose.</div></div>
<div class="ttc" id="aext_2std_2integral__constant_8hpp_html"><div class="ttname"><a href="ext_2std_2integral__constant_8hpp.html">integral_constant.hpp</a></div><div class="ttdoc">Adapts std::integral_constant for use with Hana.</div></div>
<div class="ttc" id="afilter_8hpp_html"><div class="ttname"><a href="filter_8hpp.html">filter.hpp</a></div><div class="ttdoc">Defines boost::hana::filter.</div></div>
<div class="ttc" id="agroup__group-functional_html_ga3b16146e53efcdf9ecbb9a7b21f8cd0b"><div class="ttname"><a href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">boost::hana::compose</a></div><div class="ttdeci">constexpr auto compose</div><div class="ttdoc">Return the composition of two functions or more.</div><div class="ttdef"><b>Definition:</b> compose.hpp:52</div></div>
<div class="ttc" id="atype_8hpp_html"><div class="ttname"><a href="type_8hpp.html">type.hpp</a></div><div class="ttdoc">Defines boost::hana::type and related utilities.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga3022fdfe454dc9bc1f79b5dfeba13b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3022fdfe454dc9bc1f79b5dfeba13b5e">&#9670;&nbsp;</a></span>prefix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::prefix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2prefix_8hpp.html">boost/hana/fwd/prefix.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; pref) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Inserts a value before each element of a monadic structure. </p>
<p>Given a monadic structure <code>xs</code> and a value <code>z</code> called the prefix, <code>prefix</code> returns a new monadic structure. <code>prefix</code> satisfies </p><div class="fragment"><div class="line"><a class="code" href="group__group-_monad_plus.html#ga3022fdfe454dc9bc1f79b5dfeba13b5e">prefix</a>(xs, z) == flatten(transform(xs, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(lift&lt;M&gt;(z), lift&lt;M&gt;(x));</div>
<div class="line">}))</div>
<div class="ttc" id="agroup__group-_monad_plus_html_ga3022fdfe454dc9bc1f79b5dfeba13b5e"><div class="ttname"><a href="group__group-_monad_plus.html#ga3022fdfe454dc9bc1f79b5dfeba13b5e">boost::hana::prefix</a></div><div class="ttdeci">constexpr auto prefix</div><div class="ttdoc">Inserts a value before each element of a monadic structure.</div><div class="ttdef"><b>Definition:</b> prefix.hpp:56</div></div>
</div><!-- fragment --><p>For sequences, this simply corresponds to inserting the prefix before each element of the sequence. For example, given a sequence <code>[x1, ..., xn]</code>, <code>prefix</code> will return </p><div class="fragment"><div class="line">[z, x1, z, x2, ..., z, xn]</div>
</div><!-- fragment --><p> As explained above, this can be generalized to other MonadPlus models, with various levels of interest.</p>
<h2><a class="anchor" id="autotoc_md320"></a>
Signature</h2>
<p>Given a MonadPlus <code>M</code>, the signature is \( \mathrm{prefix} : M(T) \times T \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure.</td></tr>
    <tr><td class="paramname">pref</td><td>A value (the prefix) to insert before each element of a monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md321"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="prefix_8hpp.html">boost/hana/prefix.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>std::literals;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        <a class="code" href="group__group-_monad_plus.html#ga3022fdfe454dc9bc1f79b5dfeba13b5e">hana::prefix</a>(hana::make_tuple(<span class="stringliteral">&quot;dog&quot;</span>s, <span class="stringliteral">&quot;car&quot;</span>s, <span class="stringliteral">&quot;house&quot;</span>s), <span class="stringliteral">&quot;my&quot;</span>s)</div>
<div class="line">            ==</div>
<div class="line">        hana::make_tuple(<span class="stringliteral">&quot;my&quot;</span>, <span class="stringliteral">&quot;dog&quot;</span>, <span class="stringliteral">&quot;my&quot;</span>, <span class="stringliteral">&quot;car&quot;</span>, <span class="stringliteral">&quot;my&quot;</span>, <span class="stringliteral">&quot;house&quot;</span>)</div>
<div class="line">    );</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group-assertions_html_ga4796ae107d58b67e0bbccd5ae6f70101"><div class="ttname"><a href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a></div><div class="ttdeci">#define BOOST_HANA_RUNTIME_CHECK(...)</div><div class="ttdoc">Equivalent to BOOST_HANA_RUNTIME_ASSERT, but not influenced by the BOOST_HANA_CONFIG_DISABLE_ASSERTIO...</div><div class="ttdef"><b>Definition:</b> assert.hpp:209</div></div>
<div class="ttc" id="aprefix_8hpp_html"><div class="ttname"><a href="prefix_8hpp.html">prefix.hpp</a></div><div class="ttdoc">Defines boost::hana::prefix.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga69afbfd4e91125e3e52fcb409135ca7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69afbfd4e91125e3e52fcb409135ca7c">&#9670;&nbsp;</a></span>prepend</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::prepend</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2prepend_8hpp.html">boost/hana/fwd/prepend.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; x) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Prepend an element to a monadic structure. </p>
<p>Given a monadic structure <code>xs</code> and an element <code>x</code>, <code>prepend</code> returns a new monadic structure which is the result of lifting <code>x</code> into the monadic structure and then combining that (to the left) with <code>xs</code>. In other words, </p><div class="fragment"><div class="line"><a class="code" href="group__group-_monad_plus.html#ga69afbfd4e91125e3e52fcb409135ca7c">prepend</a>(xs, x) == <a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(lift&lt;Xs&gt;(x), xs)</div>
<div class="ttc" id="agroup__group-_monad_plus_html_ga69afbfd4e91125e3e52fcb409135ca7c"><div class="ttname"><a href="group__group-_monad_plus.html#ga69afbfd4e91125e3e52fcb409135ca7c">boost::hana::prepend</a></div><div class="ttdeci">constexpr auto prepend</div><div class="ttdoc">Prepend an element to a monadic structure.</div><div class="ttdef"><b>Definition:</b> prepend.hpp:57</div></div>
</div><!-- fragment --><p>For sequences, this has the intuitive behavior of simply prepending an element to the beginning of the sequence, hence the name.</p>
<blockquote class="doxtable">
<p>#### Rationale for not calling this <code>push_front</code> While <code>push_front</code> is the de-facto name used in the standard library, it also strongly suggests mutation of the underlying sequence, which is not the case here. The author also finds that <code>push_front</code> suggests too strongly the sole interpretation of putting an element to the front of a sequence, whereas <code>prepend</code> is slightly more nuanced and bears its name better for e.g. <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time.">hana::optional</a></code>. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md322"></a>
Signature</h2>
<p>Given a MonadPlus <code>M</code>, the signature is \( \mathtt{prepend} : M(T) \times T \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure that will be combined to the right of the element.</td></tr>
    <tr><td class="paramname">x</td><td>An element to combine to the left of the monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md323"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="prepend_8hpp.html">boost/hana/prepend.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">static_assert(<a class="code" href="group__group-_monad_plus.html#ga69afbfd4e91125e3e52fcb409135ca7c">hana::prepend</a>(hana::make_tuple(), 1) == hana::make_tuple(1), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="group__group-_monad_plus.html#ga69afbfd4e91125e3e52fcb409135ca7c">hana::prepend</a>(hana::make_tuple(<span class="charliteral">&#39;2&#39;</span>, 3.3), 1) == hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="aprepend_8hpp_html"><div class="ttname"><a href="prepend_8hpp.html">prepend.hpp</a></div><div class="ttdoc">Defines boost::hana::prepend.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga5ee54dc1195f9e5cf48bfd51ba231ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ee54dc1195f9e5cf48bfd51ba231ae5">&#9670;&nbsp;</a></span>mathrm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::hana::mathrm</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2remove_8hpp.html">boost/hana/fwd/remove.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">{remove} : M(T) \times <a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">T \to</a> M(T)</div>
<div class="line">        \f$</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">auto</span> remove = [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-_constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
<div class="ttc" id="agroup__group-_constant_html_ga1687520692a6b0c49e3a69de2980f388"><div class="ttname"><a href="group__group-_constant.html#ga1687520692a6b0c49e3a69de2980f388">boost::hana::value</a></div><div class="ttdeci">constexpr auto value</div><div class="ttdoc">Return the compile-time value associated to a constant.</div><div class="ttdef"><b>Definition:</b> value.hpp:54</div></div>
<div class="ttc" id="agroup__group-core_html_gadc70755c1d059139297814fb3bfeb91e"><div class="ttname"><a href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">boost::hana::to</a></div><div class="ttdeci">constexpr auto to</div><div class="ttdoc">Converts an object from one data type to another.</div><div class="ttdef"><b>Definition:</b> to.hpp:97</div></div>
</div><!-- fragment -->
<p>Remove all the elements of a monadic structure that are equal to some value. </p>
<p>Remove all the elements of a monadic structure that satisfy some predicate.</p>
<p>Given a monadic structure <code>xs</code> and a <code>value</code>, <code>remove</code> returns a new monadic structure equal to <code>xs</code> without all its elements that are equal to the given <code>value</code>. <code>remove</code> is equivalent to <code>remove_if</code> with the <code>equal.to(value)</code> predicate, i.e. </p><div class="fragment"><div class="line">remove(xs, <a class="code" href="group__group-_constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>) == remove_if(xs, <a class="code" href="group__group-_comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">equal</a>.to(<a class="code" href="group__group-_constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>))</div>
<div class="ttc" id="agroup__group-_comparable_html_gacaf1ebea6b3ab96ac9dcb82f0e64e547"><div class="ttname"><a href="group__group-_comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">boost::hana::equal</a></div><div class="ttdeci">constexpr auto equal</div><div class="ttdoc">Returns a Logical representing whether x is equal to y.</div><div class="ttdef"><b>Definition:</b> equal.hpp:64</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md328"></a>
Signature</h2>
<p>Given a MonadPlus <code>M</code> and a value of type <code>T</code>, the signature is</p>
<p>Given a monadic structure <code>xs</code> and a unary predicate, <code>remove_if</code> returns a new monadic structure equal to <code>xs</code> without all its elements that satisfy the predicate. This is equivalent to <code>filter</code> with a negated predicate, i.e. </p><div class="fragment"><div class="line">remove_if(xs, predicate) == <a class="code" href="group__group-_monad_plus.html#ga65cc6d9f522fb9e8e3b28d80ee5c822a">filter</a>(xs, negated predicated)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md331"></a>
Signature</h2>
<p>Given a MonadPlus <code>M</code> and a predicate of type \( T \to Bool \) for some compile-time Logical <code>Bool</code>, the signature is </p>

</div>
</div>
<a id="gad5f48c79d11923d6c1d70b18b7dd3f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5f48c79d11923d6c1d70b18b7dd3f19">&#9670;&nbsp;</a></span>replicate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::replicate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2replicate_8hpp.html">boost/hana/fwd/replicate.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; n) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Create a monadic structure by combining a lifted value with itself <code>n</code> times. </p>
<p>Given a value <code>x</code>, a non-negative <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant concept represents compile-time integral values.">IntegralConstant</a></code> <code>n</code> and the tag of a monadic structure <code>M</code>, <code>replicate</code> creates a new monadic structure which is the result of combining <code>x</code> with itself <code>n</code> times inside the monadic structure. In other words, <code>replicate</code> simply <code>lift</code>s <code>x</code> into the monadic structure, and then combines that with itself <code>n</code> times: </p><div class="fragment"><div class="line">replicate&lt;M&gt;(x, n) == <a class="code" href="group__group-_monad_plus.html#gaaf46c168f721da9effcc7336a997f5d6">cycle</a>(lift&lt;M&gt;(x), n)</div>
</div><!-- fragment --><p>If <code>n</code> is zero, then the identity of the <code>concat</code> operation is returned. In the case of sequences, this corresponds to creating a new sequence holding <code>n</code> copies of <code>x</code>.</p>
<h2><a class="anchor" id="autotoc_md337"></a>
Signature</h2>
<p>Given an <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant concept represents compile-time integral values.">IntegralConstant</a></code> <code>C</code> and MonadPlus <code>M</code>, the signature is \( \mathtt{replicate}_M : T \times C \to M(T) \).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The tag of the returned monadic structure. It must be a model of the MonadPlus concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to lift into a monadic structure and then combine with itself.</td></tr>
    <tr><td class="paramname">n</td><td>A non-negative <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant concept represents compile-time integral values.">IntegralConstant</a></code> representing the number of times to combine <code>lift&lt;M&gt;(x)</code> with itself. If <code>n == 0</code>, <code>replicate</code> returns <code>empty&lt;M&gt;()</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md338"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="replicate_8hpp.html">boost/hana/replicate.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">static_assert(hana::replicate&lt;hana::tuple_tag&gt;(<span class="charliteral">&#39;x&#39;</span>, hana::size_c&lt;2&gt;) == hana::make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;x&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Of course, there can&#39;t be more than one element in an `optional`.</span></div>
<div class="line">static_assert(hana::replicate&lt;hana::optional_tag&gt;(<span class="charliteral">&#39;x&#39;</span>, hana::size_c&lt;2&gt;) == hana::just(<span class="charliteral">&#39;x&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="areplicate_8hpp_html"><div class="ttname"><a href="replicate_8hpp.html">replicate.hpp</a></div><div class="ttdoc">Defines boost::hana::replicate.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga61dab15f6ecf379121d4096fe0c8ab13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61dab15f6ecf379121d4096fe0c8ab13">&#9670;&nbsp;</a></span>suffix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::suffix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2suffix_8hpp.html">boost/hana/fwd/suffix.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; sfx) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Inserts a value after each element of a monadic structure. </p>
<p>Given a monadic structure <code>xs</code> and a value <code>z</code> (called the suffix), <code>suffix</code> returns a new monadic structure such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-_monad_plus.html#ga61dab15f6ecf379121d4096fe0c8ab13">suffix</a>(xs, z) == flatten(transform(xs, [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__group-_monad_plus.html#ga1946e96c3b4c178c7ae8703724c29c37">concat</a>(lift&lt;M&gt;(x), lift&lt;M&gt;(z));</div>
<div class="line">}))</div>
<div class="ttc" id="agroup__group-_monad_plus_html_ga61dab15f6ecf379121d4096fe0c8ab13"><div class="ttname"><a href="group__group-_monad_plus.html#ga61dab15f6ecf379121d4096fe0c8ab13">boost::hana::suffix</a></div><div class="ttdeci">constexpr auto suffix</div><div class="ttdoc">Inserts a value after each element of a monadic structure.</div><div class="ttdef"><b>Definition:</b> suffix.hpp:56</div></div>
</div><!-- fragment --><p>For sequences, this simply corresponds to inserting the suffix after each element of the sequence. For example, given a sequence <code>[x1, ..., xn]</code>, <code>suffix</code> will return </p><div class="fragment"><div class="line">[x1, z, x2, z, ..., xn, z]</div>
</div><!-- fragment --><p> As explained above, this can be generalized to other MonadPlus models, with various levels of interest.</p>
<h2><a class="anchor" id="autotoc_md367"></a>
Signature</h2>
<p>Given a MonadPlus <code>M</code>, the signature is \( \mathtt{suffix} : M(T) \times T \to M(T) \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>A monadic structure.</td></tr>
    <tr><td class="paramname">sfx</td><td>A value (the suffix) to insert after each element of a monadic structure.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md368"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="suffix_8hpp.html">boost/hana/suffix.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">static_assert(</div>
<div class="line">    <a class="code" href="group__group-_monad_plus.html#ga61dab15f6ecf379121d4096fe0c8ab13">hana::suffix</a>(hana::make_tuple(1, 2, 3, 4), 0) == hana::make_tuple(1, 0, 2, 0, 3, 0, 4, 0)</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="asuffix_8hpp_html"><div class="ttname"><a href="suffix_8hpp.html">suffix.hpp</a></div><div class="ttdoc">Defines boost::hana::suffix.</div></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
