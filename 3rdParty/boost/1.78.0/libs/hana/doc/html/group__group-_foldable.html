<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>Boost.Hana: Foldable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.7.1</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group-_foldable.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Foldable<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The <code>Foldable</code> concept represents data structures that can be reduced to a single value. </p>
<p>Generally speaking, folding refers to the concept of summarizing a complex structure as a single value, by successively applying a binary operation which reduces two elements of the structure to a single value. Folds come in many flavors; left folds, right folds, folds with and without an initial reduction state, and their monadic variants. This concept is able to express all of these fold variants.</p>
<p>Another way of seeing <code>Foldable</code> is as data structures supporting internal iteration with the ability to accumulate a result. By internal iteration, we mean that the <em>loop control</em> is in the hand of the structure, not the caller. Hence, it is the structure who decides when the iteration stops, which is normally when the whole structure has been consumed. Since C++ is an eager language, this requires <code>Foldable</code> structures to be finite, or otherwise one would need to loop indefinitely to consume the whole structure.</p>
<dl class="section note"><dt>Note</dt><dd>While the fact that <code>Foldable</code> only works for finite structures may seem overly restrictive in comparison to the Haskell definition of <code>Foldable</code>, a finer grained separation of the concepts should mitigate the issue. For iterating over possibly infinite data structures, see the <code>Iterable</code> concept. For searching a possibly infinite data structure, see the <code>Searchable</code> concept.</dd></dl>
<h2><a class="anchor" id="autotoc_md99"></a>
Minimal complete definition</h2>
<p><code>fold_left</code> or <code>unpack</code></p>
<p>However, please note that a minimal complete definition provided through <code>unpack</code> will be much more compile-time efficient than one provided through <code>fold_left</code>.</p>
<h2><a class="anchor" id="autotoc_md100"></a>
Concrete models</h2>
<p><code><a class="el" href="structboost_1_1hana_1_1map.html" title="Basic associative container requiring unique, Comparable and Hashable keys.">hana::map</a></code>, <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time.">hana::optional</a></code>, <code><a class="el" href="structboost_1_1hana_1_1pair.html" title="Generic container for two elements.">hana::pair</a></code>, <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring unique, Comparable and Hashable keys.">hana::set</a></code>, <code><a class="el" href="structboost_1_1hana_1_1range.html" title="Compile-time half-open interval of hana::integral_constants.">hana::range</a></code>, <code><a class="el" href="structboost_1_1hana_1_1tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length.">hana::tuple</a></code></p>
<p><a class="anchor" id="Foldable-lin"></a></p>
<h2><a class="anchor" id="autotoc_md101"></a>
The linearization of a &lt;tt&gt;Foldable&lt;/tt&gt;</h2>
<p>Intuitively, for a <code>Foldable</code> structure <code>xs</code>, the <em>linearization</em> of <code>xs</code> is the sequence of all the elements in <code>xs</code> as if they had been put in a list: </p><div class="fragment"><div class="line">linearization(xs) = [x1, x2, ..., xn]</div>
</div><!-- fragment --><p>Note that it is always possible to produce such a linearization for a finite <code>Foldable</code> by setting </p><div class="fragment"><div class="line">linearization(xs) = fold_left(xs, [], <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(<a class="code" href="group__group-_monad_plus.html#ga69afbfd4e91125e3e52fcb409135ca7c">prepend</a>))</div>
<div class="ttc" id="agroup__group-_monad_plus_html_ga69afbfd4e91125e3e52fcb409135ca7c"><div class="ttname"><a href="group__group-_monad_plus.html#ga69afbfd4e91125e3e52fcb409135ca7c">boost::hana::prepend</a></div><div class="ttdeci">constexpr auto prepend</div><div class="ttdoc">Prepend an element to a monadic structure.</div><div class="ttdef"><b>Definition:</b> prepend.hpp:57</div></div>
<div class="ttc" id="agroup__group-functional_html_ga004f884cdbb85c2efe3383c1db450094"><div class="ttname"><a href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">boost::hana::flip</a></div><div class="ttdeci">constexpr auto flip</div><div class="ttdoc">Invoke a function with its two first arguments reversed.</div><div class="ttdef"><b>Definition:</b> flip.hpp:31</div></div>
</div><!-- fragment --><p> for an appropriate definition of <code>[]</code> and <code>prepend</code>. The notion of linearization is useful for expressing various properties of <code>Foldable</code> structures, and is used across the documentation. Also note that <code>Iterable</code>s define an <a class="el" href="group__group-_iterable.html#Iterable-lin">extended version</a> of this allowing for infinite structures.</p>
<h2><a class="anchor" id="autotoc_md102"></a>
Compile-time Foldables</h2>
<p>A compile-time <code>Foldable</code> is a <code>Foldable</code> whose total length is known at compile-time. In other words, it is a <code>Foldable</code> whose <code>length</code> method returns a <code>Constant</code> of an unsigned integral type. When folding a compile-time <code>Foldable</code>, the folding can be unrolled, because the final number of steps of the algorithm is known at compile-time.</p>
<p>Additionally, the <code>unpack</code> method is only available to compile-time <code>Foldable</code>s. This is because the return <em>type</em> of <code>unpack</code> depends on the number of objects in the structure. Being able to resolve <code>unpack</code>'s return type at compile-time hence requires the length of the structure to be known at compile-time too.</p>
<p><b>In the current version of the library, only compile-time <code>Foldable</code>s are supported.</b> While it would be possible in theory to support runtime <code>Foldable</code>s too, doing so efficiently requires more research.</p>
<h2><a class="anchor" id="autotoc_md103"></a>
Provided conversion to &lt;tt&gt;Sequence&lt;/tt&gt;s</h2>
<p>Given a tag <code>S</code> which is a <code>Sequence</code>, an object whose tag is a model of the <code>Foldable</code> concept can be converted to an object of tag <code>S</code>. In other words, a <code>Foldable</code> can be converted to a <code>Sequence</code> <code>S</code>, by simply taking the linearization of the <code>Foldable</code> and creating the sequence with that. More specifically, given a <code>Foldable</code> <code>xs</code> with a linearization of <code>[x1, ..., xn]</code> and a <code>Sequence</code> tag <code>S</code>, <code>to&lt;S&gt;(xs)</code> is equivalent to <code>make&lt;S&gt;(x1, ..., xn)</code>. </p><div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2to_8hpp.html">boost/hana/core/to.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="range_8hpp.html">boost/hana/range.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    static_assert(hana::to&lt;hana::tuple_tag&gt;(hana::just(1)) == hana::make_tuple(1), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::to&lt;hana::tuple_tag&gt;(hana::nothing) == hana::make_tuple());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::to&lt;hana::tuple_tag&gt;(hana::make_range(hana::int_c&lt;3&gt;, hana::int_c&lt;6&gt;))</div>
<div class="line">            ==</div>
<div class="line">        hana::tuple_c&lt;int, 3, 4, 5&gt;</div>
<div class="line">    );</div>
<div class="line">}</div>
<div class="ttc" id="aassert_8hpp_html"><div class="ttname"><a href="assert_8hpp.html">assert.hpp</a></div><div class="ttdoc">Defines macros to perform different kinds of assertions.</div></div>
<div class="ttc" id="acore_2to_8hpp_html"><div class="ttname"><a href="core_2to_8hpp.html">to.hpp</a></div><div class="ttdoc">Defines boost::hana::to and related utilities.</div></div>
<div class="ttc" id="aequal_8hpp_html"><div class="ttname"><a href="equal_8hpp.html">equal.hpp</a></div><div class="ttdoc">Defines boost::hana::equal.</div></div>
<div class="ttc" id="agroup__group-assertions_html_ga2c5006540936d9f8880e3a39f4fcc035"><div class="ttname"><a href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a></div><div class="ttdeci">#define BOOST_HANA_CONSTANT_CHECK(...)</div><div class="ttdoc">Equivalent to BOOST_HANA_CONSTANT_ASSERT, but not influenced by the BOOST_HANA_CONFIG_DISABLE_ASSERTI...</div><div class="ttdef"><b>Definition:</b> assert.hpp:239</div></div>
<div class="ttc" id="aintegral__constant_8hpp_html"><div class="ttname"><a href="integral__constant_8hpp.html">integral_constant.hpp</a></div><div class="ttdoc">Defines boost::hana::integral_constant.</div></div>
<div class="ttc" id="anamespaceboost_1_1hana_html"><div class="ttname"><a href="namespaceboost_1_1hana.html">boost::hana</a></div><div class="ttdoc">Namespace containing everything in the library.</div><div class="ttdef"><b>Definition:</b> accessors.hpp:20</div></div>
<div class="ttc" id="aoptional_8hpp_html"><div class="ttname"><a href="optional_8hpp.html">optional.hpp</a></div><div class="ttdoc">Defines boost::hana::optional.</div></div>
<div class="ttc" id="arange_8hpp_html"><div class="ttname"><a href="range_8hpp.html">range.hpp</a></div><div class="ttdoc">Defines boost::hana::range.</div></div>
<div class="ttc" id="atuple_8hpp_html"><div class="ttname"><a href="tuple_8hpp.html">tuple.hpp</a></div><div class="ttdoc">Defines boost::hana::tuple.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md104"></a>
Free model for builtin arrays</h2>
<p>Builtin arrays whose size is known can be folded as-if they were homogeneous tuples. However, note that builtin arrays can't be made more than <code>Foldable</code> (e.g. <code>Iterable</code>) because they can't be empty and they also can't be returned from functions.</p>
<p><a class="anchor" id="monadic-folds"></a></p>
<h2><a class="anchor" id="autotoc_md105"></a>
Primer on monadic folds</h2>
<p>A monadic fold is a fold in which subsequent calls to the binary function are chained with the monadic <code>chain</code> operator of the corresponding Monad. This allows a structure to be folded in a custom monadic context. For example, performing a monadic fold with the <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time.">hana::optional</a></code> monad would require the binary function to return the result as a <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time.">hana::optional</a></code>, and the fold would abort and return <code>nothing</code> whenever one of the accumulation step would fail (i.e. return <code>nothing</code>). If, however, all the reduction steps succeed, then <code>just</code> the result would be returned. Different monads will of course result in different effects. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3159cfa41be18a396926741b0a3fdefd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_foldable.html#ga3159cfa41be18a396926741b0a3fdefd">boost::hana::count</a></td></tr>
<tr class="memdesc:ga3159cfa41be18a396926741b0a3fdefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the structure that compare equal to a given value.  <a href="group__group-_foldable.html#ga3159cfa41be18a396926741b0a3fdefd">More...</a><br /></td></tr>
<tr class="separator:ga3159cfa41be18a396926741b0a3fdefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d71be65d5b98e7d035a3e5c607e1b4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_foldable.html#ga39d71be65d5b98e7d035a3e5c607e1b4">boost::hana::count_if</a></td></tr>
<tr class="memdesc:ga39d71be65d5b98e7d035a3e5c607e1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the structure for which the <code>predicate</code> is satisfied.  <a href="group__group-_foldable.html#ga39d71be65d5b98e7d035a3e5c607e1b4">More...</a><br /></td></tr>
<tr class="separator:ga39d71be65d5b98e7d035a3e5c607e1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0fde17f3b947a0678a1c0c01232f2cc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_foldable.html#gaa0fde17f3b947a0678a1c0c01232f2cc">boost::hana::fold</a> = fold_left</td></tr>
<tr class="memdesc:gaa0fde17f3b947a0678a1c0c01232f2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>fold_left</code>; provided for convenience.  <a href="group__group-_foldable.html#gaa0fde17f3b947a0678a1c0c01232f2cc">More...</a><br /></td></tr>
<tr class="separator:gaa0fde17f3b947a0678a1c0c01232f2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af382f7e644ce3707710bbad313e9c2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_foldable.html#ga2af382f7e644ce3707710bbad313e9c2">boost::hana::for_each</a></td></tr>
<tr class="memdesc:ga2af382f7e644ce3707710bbad313e9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an action on each element of a foldable, discarding the result each time.  <a href="group__group-_foldable.html#ga2af382f7e644ce3707710bbad313e9c2">More...</a><br /></td></tr>
<tr class="separator:ga2af382f7e644ce3707710bbad313e9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19fcf61d8d1179903952c0f564c538aa"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_foldable.html#ga19fcf61d8d1179903952c0f564c538aa">boost::hana::fuse</a></td></tr>
<tr class="memdesc:ga19fcf61d8d1179903952c0f564c538aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a function taking multiple arguments into a function that can be called with a compile-time <code>Foldable</code>.  <a href="group__group-_foldable.html#ga19fcf61d8d1179903952c0f564c538aa">More...</a><br /></td></tr>
<tr class="separator:ga19fcf61d8d1179903952c0f564c538aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0f8f717245620dc28cd7d7fa44d7475"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">boost::hana::length</a></td></tr>
<tr class="memdesc:gaf0f8f717245620dc28cd7d7fa44d7475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in a foldable structure.  <a href="group__group-_foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">More...</a><br /></td></tr>
<tr class="separator:gaf0f8f717245620dc28cd7d7fa44d7475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17fe9c1982c882807f3358b4138c5744"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_foldable.html#ga17fe9c1982c882807f3358b4138c5744">boost::hana::product</a> = see documentation</td></tr>
<tr class="memdesc:ga17fe9c1982c882807f3358b4138c5744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of the numbers of a structure.  <a href="group__group-_foldable.html#ga17fe9c1982c882807f3358b4138c5744">More...</a><br /></td></tr>
<tr class="separator:ga17fe9c1982c882807f3358b4138c5744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ec3ac9a6f5014db943f61ebc9e1e36e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_foldable.html#ga8ec3ac9a6f5014db943f61ebc9e1e36e">boost::hana::size</a> = <a class="el" href="group__group-_foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">hana::length</a></td></tr>
<tr class="memdesc:ga8ec3ac9a6f5014db943f61ebc9e1e36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>length</code>; provided for consistency with the standard library.  <a href="group__group-_foldable.html#ga8ec3ac9a6f5014db943f61ebc9e1e36e">More...</a><br /></td></tr>
<tr class="separator:ga8ec3ac9a6f5014db943f61ebc9e1e36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga650def4b2e98f4273d8b9b7aa5a2fc28"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_foldable.html#ga650def4b2e98f4273d8b9b7aa5a2fc28">boost::hana::sum</a> = see documentation</td></tr>
<tr class="memdesc:ga650def4b2e98f4273d8b9b7aa5a2fc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of the numbers of a structure.  <a href="group__group-_foldable.html#ga650def4b2e98f4273d8b9b7aa5a2fc28">More...</a><br /></td></tr>
<tr class="separator:ga650def4b2e98f4273d8b9b7aa5a2fc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b0c23944364ce61136e10b978ae2170"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_foldable.html#ga7b0c23944364ce61136e10b978ae2170">boost::hana::unpack</a></td></tr>
<tr class="memdesc:ga7b0c23944364ce61136e10b978ae2170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function with the elements of a Foldable as arguments.  <a href="group__group-_foldable.html#ga7b0c23944364ce61136e10b978ae2170">More...</a><br /></td></tr>
<tr class="separator:ga7b0c23944364ce61136e10b978ae2170"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga3159cfa41be18a396926741b0a3fdefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3159cfa41be18a396926741b0a3fdefd">&#9670;&nbsp;</a></span>count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2count_8hpp.html">boost/hana/fwd/count.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-_constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
<div class="ttc" id="agroup__group-_constant_html_ga1687520692a6b0c49e3a69de2980f388"><div class="ttname"><a href="group__group-_constant.html#ga1687520692a6b0c49e3a69de2980f388">boost::hana::value</a></div><div class="ttdeci">constexpr auto value</div><div class="ttdoc">Return the compile-time value associated to a constant.</div><div class="ttdef"><b>Definition:</b> value.hpp:54</div></div>
</div><!-- fragment -->
<p>Return the number of elements in the structure that compare equal to a given value. </p>
<p>Given a Foldable structure <code>xs</code> and a value <code>value</code>, <code>count</code> returns an unsigned integral, or a Constant thereof, representing the number of elements of <code>xs</code> that compare equal to <code>value</code>. For this method to be well-defined, all the elements of the structure must be Comparable with the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure whose elements are counted.</td></tr>
    <tr><td class="paramname">value</td><td>A value compared with each element in the structure. Elements that compare equal to this value are counted, others are not.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md198"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="count_8hpp.html">boost/hana/count.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr <span class="keyword">auto</span> ints = hana::tuple_c&lt;int, 1, 2, 3, 2, 2, 4, 2&gt;;</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#ga3159cfa41be18a396926741b0a3fdefd">hana::count</a>(ints, hana::int_c&lt;2&gt;) == hana::size_c&lt;4&gt;);</div>
<div class="line">    static_assert(<a class="code" href="group__group-_foldable.html#ga3159cfa41be18a396926741b0a3fdefd">hana::count</a>(ints, 2) == 4, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">auto</span> types = hana::tuple_t&lt;int, char, long, short, char, double&gt;;</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#ga3159cfa41be18a396926741b0a3fdefd">hana::count</a>(types, hana::type_c&lt;char&gt;) == hana::size_c&lt;2&gt;);</div>
<div class="line">}</div>
<div class="ttc" id="acount_8hpp_html"><div class="ttname"><a href="count_8hpp.html">count.hpp</a></div><div class="ttdoc">Defines boost::hana::count.</div></div>
<div class="ttc" id="agroup__group-_foldable_html_ga3159cfa41be18a396926741b0a3fdefd"><div class="ttname"><a href="group__group-_foldable.html#ga3159cfa41be18a396926741b0a3fdefd">boost::hana::count</a></div><div class="ttdeci">constexpr auto count</div><div class="ttdoc">Return the number of elements in the structure that compare equal to a given value.</div><div class="ttdef"><b>Definition:</b> count.hpp:41</div></div>
<div class="ttc" id="atype_8hpp_html"><div class="ttname"><a href="type_8hpp.html">type.hpp</a></div><div class="ttdoc">Defines boost::hana::type and related utilities.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga39d71be65d5b98e7d035a3e5c607e1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39d71be65d5b98e7d035a3e5c607e1b4">&#9670;&nbsp;</a></span>count_if</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::count_if</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2count__if_8hpp.html">boost/hana/fwd/count_if.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the number of elements in the structure for which the <code>predicate</code> is satisfied. </p>
<p>Specifically, returns an object of an unsigned integral type, or a <code>Constant</code> holding such an object, which represents the number of elements in the structure satisfying the given <code>predicate</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure whose elements are counted.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the structure, and returning a <code>Logical</code> representing whether <code>x</code> should be counted.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md199"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="count__if_8hpp.html">boost/hana/count_if.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mod_8hpp.html">boost/hana/mod.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"><span class="keyword">using namespace </span>hana::literals;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> is_odd = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x % 2_c != 0_c;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    constexpr <span class="keyword">auto</span> ints = hana::tuple_c&lt;int, 1, 2, 3&gt;;</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#ga39d71be65d5b98e7d035a3e5c607e1b4">hana::count_if</a>(ints, is_odd) == hana::size_c&lt;2&gt;);</div>
<div class="line"> </div>
<div class="line">    constexpr <span class="keyword">auto</span> types = hana::tuple_t&lt;int, char, long, short, char, double&gt;;</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#ga39d71be65d5b98e7d035a3e5c607e1b4">hana::count_if</a>(types, hana::trait&lt;std::is_floating_point&gt;) == hana::size_c&lt;1&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#ga39d71be65d5b98e7d035a3e5c607e1b4">hana::count_if</a>(types, <a class="code" href="group__group-_comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">hana::equal</a>.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(hana::type_c&lt;char&gt;)) == hana::size_c&lt;2&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#ga39d71be65d5b98e7d035a3e5c607e1b4">hana::count_if</a>(types, <a class="code" href="group__group-_comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">hana::equal</a>.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(hana::type_c&lt;void&gt;)) == hana::size_c&lt;0&gt;);</div>
<div class="line">}</div>
<div class="ttc" id="acount__if_8hpp_html"><div class="ttname"><a href="count__if_8hpp.html">count_if.hpp</a></div><div class="ttdoc">Defines boost::hana::count_if.</div></div>
<div class="ttc" id="aext_2std_2integral__constant_8hpp_html"><div class="ttname"><a href="ext_2std_2integral__constant_8hpp.html">integral_constant.hpp</a></div><div class="ttdoc">Adapts std::integral_constant for use with Hana.</div></div>
<div class="ttc" id="agroup__group-_comparable_html_gacaf1ebea6b3ab96ac9dcb82f0e64e547"><div class="ttname"><a href="group__group-_comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">boost::hana::equal</a></div><div class="ttdeci">constexpr auto equal</div><div class="ttdoc">Returns a Logical representing whether x is equal to y.</div><div class="ttdef"><b>Definition:</b> equal.hpp:64</div></div>
<div class="ttc" id="agroup__group-_foldable_html_ga39d71be65d5b98e7d035a3e5c607e1b4"><div class="ttname"><a href="group__group-_foldable.html#ga39d71be65d5b98e7d035a3e5c607e1b4">boost::hana::count_if</a></div><div class="ttdeci">constexpr auto count_if</div><div class="ttdoc">Return the number of elements in the structure for which the predicate is satisfied.</div><div class="ttdef"><b>Definition:</b> count_if.hpp:40</div></div>
<div class="ttc" id="agroup__group-core_html_gadc70755c1d059139297814fb3bfeb91e"><div class="ttname"><a href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">boost::hana::to</a></div><div class="ttdeci">constexpr auto to</div><div class="ttdoc">Converts an object from one data type to another.</div><div class="ttdef"><b>Definition:</b> to.hpp:97</div></div>
<div class="ttc" id="amod_8hpp_html"><div class="ttname"><a href="mod_8hpp.html">mod.hpp</a></div><div class="ttdoc">Defines boost::hana::mod.</div></div>
<div class="ttc" id="anot__equal_8hpp_html"><div class="ttname"><a href="not__equal_8hpp.html">not_equal.hpp</a></div><div class="ttdoc">Defines boost::hana::not_equal.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaa0fde17f3b947a0678a1c0c01232f2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0fde17f3b947a0678a1c0c01232f2cc">&#9670;&nbsp;</a></span>fold</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::fold = fold_left</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2fold_8hpp.html">boost/hana/fwd/fold.hpp</a>&gt;</code></p>

<p>Equivalent to <code>fold_left</code>; provided for convenience. </p>
<p><code>fold</code> is equivalent to <code>fold_left</code>. However, it is not tag-dispatched on its own because it is just an alias to <code>fold_left</code>. Also note that <code>fold</code> can be called with or without an initial state, just like <code>fold_left</code>:</p>
<div class="fragment"><div class="line"><a class="code" href="group__group-_foldable.html#gaa0fde17f3b947a0678a1c0c01232f2cc">fold</a>(xs, state, f) == fold_left(xs, state, f)</div>
<div class="line"><a class="code" href="group__group-_foldable.html#gaa0fde17f3b947a0678a1c0c01232f2cc">fold</a>(xs, f) == fold_left(xs, f)</div>
<div class="ttc" id="agroup__group-_foldable_html_gaa0fde17f3b947a0678a1c0c01232f2cc"><div class="ttname"><a href="group__group-_foldable.html#gaa0fde17f3b947a0678a1c0c01232f2cc">boost::hana::fold</a></div><div class="ttdeci">constexpr auto fold</div><div class="ttdoc">Equivalent to fold_left; provided for convenience.</div><div class="ttdef"><b>Definition:</b> fold.hpp:35</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md226"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fold_8hpp.html">boost/hana/fold.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div>
<div class="line">    std::ostringstream ss;</div>
<div class="line">    ss &lt;&lt; x;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> f = [=](std::string s, <span class="keyword">auto</span> element) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + s + <span class="stringliteral">&quot;, &quot;</span> + to_string(element) + <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// with an initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        <a class="code" href="group__group-_foldable.html#gaa0fde17f3b947a0678a1c0c01232f2cc">hana::fold</a>(hana::make_tuple(2, <span class="charliteral">&#39;3&#39;</span>, 4, 5.0), <span class="stringliteral">&quot;1&quot;</span>, f)</div>
<div class="line">            ==</div>
<div class="line">        <span class="stringliteral">&quot;f(f(f(f(1, 2), 3), 4), 5)&quot;</span></div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// without initial state</span></div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(</div>
<div class="line">        <a class="code" href="group__group-_foldable.html#gaa0fde17f3b947a0678a1c0c01232f2cc">hana::fold</a>(hana::make_tuple(<span class="stringliteral">&quot;1&quot;</span>, 2, <span class="charliteral">&#39;3&#39;</span>, 4, 5.0), f)</div>
<div class="line">            ==</div>
<div class="line">        <span class="stringliteral">&quot;f(f(f(f(1, 2), 3), 4), 5)&quot;</span></div>
<div class="line">    );</div>
<div class="line">}</div>
<div class="ttc" id="afold_8hpp_html"><div class="ttname"><a href="fold_8hpp.html">fold.hpp</a></div><div class="ttdoc">Defines boost::hana::fold.</div></div>
<div class="ttc" id="agroup__group-assertions_html_ga4796ae107d58b67e0bbccd5ae6f70101"><div class="ttname"><a href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a></div><div class="ttdeci">#define BOOST_HANA_RUNTIME_CHECK(...)</div><div class="ttdoc">Equivalent to BOOST_HANA_RUNTIME_ASSERT, but not influenced by the BOOST_HANA_CONFIG_DISABLE_ASSERTIO...</div><div class="ttdef"><b>Definition:</b> assert.hpp:209</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga2af382f7e644ce3707710bbad313e9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2af382f7e644ce3707710bbad313e9c2">&#9670;&nbsp;</a></span>for_each</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::for_each</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2for__each_8hpp.html">boost/hana/fwd/for_each.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">        tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Perform an action on each element of a foldable, discarding the result each time. </p>
<p>Iteration is done from left to right, i.e. in the same order as when using <code>fold_left</code>. If the structure is not finite, this method will not terminate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to iterate over.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> for each element <code>x</code> of the structure. The result of <code>f(x)</code>, whatever it is, is ignored.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md229"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="for__each_8hpp.html">boost/hana/for_each.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    <a class="code" href="group__group-_foldable.html#ga2af382f7e644ce3707710bbad313e9c2">hana::for_each</a>(hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>, <span class="stringliteral">&quot;234&quot;</span>, 5.5), [&amp;](<span class="keyword">auto</span> x) {</div>
<div class="line">        ss &lt;&lt; x &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(ss.str() == <span class="stringliteral">&quot;0 1 234 5.5 &quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="afor__each_8hpp_html"><div class="ttname"><a href="for__each_8hpp.html">for_each.hpp</a></div><div class="ttdoc">Defines boost::hana::for_each.</div></div>
<div class="ttc" id="agroup__group-_foldable_html_ga2af382f7e644ce3707710bbad313e9c2"><div class="ttname"><a href="group__group-_foldable.html#ga2af382f7e644ce3707710bbad313e9c2">boost::hana::for_each</a></div><div class="ttdeci">constexpr auto for_each</div><div class="ttdoc">Perform an action on each element of a foldable, discarding the result each time.</div><div class="ttdef"><b>Definition:</b> for_each.hpp:39</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga19fcf61d8d1179903952c0f564c538aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19fcf61d8d1179903952c0f564c538aa">&#9670;&nbsp;</a></span>fuse</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::fuse</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2fuse_8hpp.html">boost/hana/fwd/fuse.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="group__group-_foldable.html#ga7b0c23944364ce61136e10b978ae2170">unpack</a>(forwarded(xs), forwarded(f));</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="ttc" id="agroup__group-_foldable_html_ga7b0c23944364ce61136e10b978ae2170"><div class="ttname"><a href="group__group-_foldable.html#ga7b0c23944364ce61136e10b978ae2170">boost::hana::unpack</a></div><div class="ttdeci">constexpr auto unpack</div><div class="ttdoc">Invoke a function with the elements of a Foldable as arguments.</div><div class="ttdef"><b>Definition:</b> unpack.hpp:79</div></div>
<div class="ttc" id="agroup__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables.</div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Transform a function taking multiple arguments into a function that can be called with a compile-time <code>Foldable</code>. </p>
<p>This function is provided for convenience as a different way of calling <code>unpack</code>. Specifically, <code>fuse(f)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-_foldable.html#ga19fcf61d8d1179903952c0f564c538aa">fuse</a>(f)(foldable) == <a class="code" href="group__group-_foldable.html#ga7b0c23944364ce61136e10b978ae2170">unpack</a>(foldable, f)</div>
<div class="line">                  == f(x...)</div>
<div class="ttc" id="agroup__group-_foldable_html_ga19fcf61d8d1179903952c0f564c538aa"><div class="ttname"><a href="group__group-_foldable.html#ga19fcf61d8d1179903952c0f564c538aa">boost::hana::fuse</a></div><div class="ttdeci">constexpr auto fuse</div><div class="ttdoc">Transform a function taking multiple arguments into a function that can be called with a compile-time...</div><div class="ttdef"><b>Definition:</b> fuse.hpp:40</div></div>
</div><!-- fragment --><p> where <code>x...</code> are the elements in the foldable. This function is useful when one wants to create a function that accepts a foldable which is not known yet.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not tag-dispatched; customize <code>unpack</code> instead.</dd></dl>
<h2><a class="anchor" id="autotoc_md231"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fuse_8hpp.html">boost/hana/fuse.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> tie = [](<span class="keyword">auto</span>&amp; ...vars) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__group-_foldable.html#ga19fcf61d8d1179903952c0f564c538aa">hana::fuse</a>([&amp;vars...](auto ...values) {</div>
<div class="line">        <span class="comment">// Using an initializer list to sequence the assignments.</span></div>
<div class="line">        int dummy[] = {0, ((void)(vars = values), 0)...};</div>
<div class="line">        (<span class="keywordtype">void</span>)dummy;</div>
<div class="line">    });</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordtype">int</span> a = 0;</div>
<div class="line">    <span class="keywordtype">char</span> b = <span class="charliteral">&#39;\0&#39;</span>;</div>
<div class="line">    <span class="keywordtype">double</span> c = 0;</div>
<div class="line"> </div>
<div class="line">    tie(a, b, c)(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(a == 1 &amp;&amp; b == <span class="charliteral">&#39;2&#39;</span> &amp;&amp; c == 3.3);</div>
<div class="line">}</div>
<div class="ttc" id="afuse_8hpp_html"><div class="ttname"><a href="fuse_8hpp.html">fuse.hpp</a></div><div class="ttdoc">Defines boost::hana::fuse.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaf0f8f717245620dc28cd7d7fa44d7475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0f8f717245620dc28cd7d7fa44d7475">&#9670;&nbsp;</a></span>length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2length_8hpp.html">boost/hana/fwd/length.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; xs) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Return the number of elements in a foldable structure. </p>
<p>Given a <code>Foldable</code> <code>xs</code>, <code>length(xs)</code> must return an object of an unsigned integral type, or an <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant concept represents compile-time integral values.">IntegralConstant</a></code> holding such an object, which represents the number of elements in the structure.</p>
<dl class="section note"><dt>Note</dt><dd>Since only compile-time <code>Foldable</code>s are supported in the library right now, <code>length</code> must always return an <code><a class="el" href="structboost_1_1hana_1_1_integral_constant.html" title="The IntegralConstant concept represents compile-time integral values.">IntegralConstant</a></code>.</dd></dl>
<h2><a class="anchor" id="autotoc_md253"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="length_8hpp.html">boost/hana/length.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">hana::length</a>(hana::make_tuple()) == hana::size_c&lt;0&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">hana::length</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0)) == hana::size_c&lt;3&gt;);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">hana::length</a>(hana::nothing) == hana::size_c&lt;0&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">hana::length</a>(hana::just(<span class="charliteral">&#39;x&#39;</span>)) == hana::size_c&lt;1&gt;);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group-_foldable_html_gaf0f8f717245620dc28cd7d7fa44d7475"><div class="ttname"><a href="group__group-_foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">boost::hana::length</a></div><div class="ttdeci">constexpr auto length</div><div class="ttdoc">Return the number of elements in a foldable structure.</div><div class="ttdef"><b>Definition:</b> length.hpp:34</div></div>
<div class="ttc" id="alength_8hpp_html"><div class="ttname"><a href="length_8hpp.html">length.hpp</a></div><div class="ttdoc">Defines boost::hana::length.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga17fe9c1982c882807f3358b4138c5744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17fe9c1982c882807f3358b4138c5744">&#9670;&nbsp;</a></span>product</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::product = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2product_8hpp.html">boost/hana/fwd/product.hpp</a>&gt;</code></p>

<p>Compute the product of the numbers of a structure. </p>
<p>More generally, <code>product</code> will take any foldable structure containing objects forming a Ring and reduce them using the Ring's binary operation. The initial state for folding is the identity of the Ring's operation. It is sometimes necessary to specify the Ring to use; this is possible by using <code>product&lt;R&gt;</code>. If no Ring is specified, the structure will use the Ring formed by the elements it contains (if it knows it), or <code><a class="el" href="structboost_1_1hana_1_1integral__constant__tag.html" title="Tag representing hana::integral_constant.">integral_constant_tag</a>&lt;int&gt;</code> otherwise. Hence, </p><div class="fragment"><div class="line">product&lt;R&gt;(xs) = fold_left(xs, one&lt;R or inferred Ring&gt;(), <a class="code" href="group__group-_ring.html#ga052d31c269a6a438cc8004c9ad1efdfa">mult</a>)</div>
<div class="line">product&lt;&gt; = product&lt;integral_constant_tag&lt;int&gt;&gt;</div>
<div class="ttc" id="agroup__group-_ring_html_ga052d31c269a6a438cc8004c9ad1efdfa"><div class="ttname"><a href="group__group-_ring.html#ga052d31c269a6a438cc8004c9ad1efdfa">boost::hana::mult</a></div><div class="ttdeci">constexpr auto mult</div><div class="ttdoc">Associative operation of a Ring.</div><div class="ttdef"><b>Definition:</b> mult.hpp:47</div></div>
</div><!-- fragment --><p>For numbers, this will just compute the product of the numbers in the <code>xs</code> structure.</p>
<dl class="section note"><dt>Note</dt><dd>The elements of the structure are not actually required to be in the same Ring, but it must be possible to perform <code>mult</code> on any two adjacent elements of the structure, which requires each pair of adjacent element to at least have a common Ring embedding. The meaning of "adjacent" as used here is that two elements of the structure <code>x</code> and <code>y</code> are adjacent if and only if they are adjacent in the linearization of that structure, as documented by the Iterable concept.</dd>
<dd>
See the documentation for <code>sum</code> to understand why the Ring must sometimes be specified explicitly.</dd></dl>
<h2><a class="anchor" id="autotoc_md324"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="product_8hpp.html">boost/hana/product.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="range_8hpp.html">boost/hana/range.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(</div>
<div class="line">        hana::product&lt;&gt;(hana::make_range(hana::int_c&lt;1&gt;, hana::int_c&lt;6&gt;)) == hana::int_c&lt;1 * 2 * 3 * 4 * 5&gt;</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">        hana::product&lt;&gt;(hana::make_tuple(1, hana::int_c&lt;3&gt;, hana::long_c&lt;-5&gt;, 9)) == 1 * 3 * -5 * 9</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div>
<div class="line">        hana::product&lt;unsigned long&gt;(hana::make_tuple(2ul, 3ul)) == 6ul</div>
<div class="line">    );</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group-assertions_html_gac7aafc41e4dcc7d1f1929fb00f010d2a"><div class="ttname"><a href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a></div><div class="ttdeci">#define BOOST_HANA_CONSTEXPR_CHECK(...)</div><div class="ttdoc">Equivalent to BOOST_HANA_CONSTEXPR_ASSERT, but not influenced by the BOOST_HANA_CONFIG_DISABLE_ASSERT...</div><div class="ttdef"><b>Definition:</b> assert.hpp:300</div></div>
<div class="ttc" id="aproduct_8hpp_html"><div class="ttname"><a href="product_8hpp.html">product.hpp</a></div><div class="ttdoc">Defines boost::hana::product.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga8ec3ac9a6f5014db943f61ebc9e1e36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ec3ac9a6f5014db943f61ebc9e1e36e">&#9670;&nbsp;</a></span>size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::size = <a class="el" href="group__group-_foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">hana::length</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2size_8hpp.html">boost/hana/fwd/size.hpp</a>&gt;</code></p>

<p>Equivalent to <code>length</code>; provided for consistency with the standard library. </p>
<p>This method is an alias to <code>length</code> provided for convenience and consistency with the standard library. As an alias, <code>size</code> is not tag-dispatched on its own and <code>length</code> should be customized instead.</p>
<h2><a class="anchor" id="autotoc_md354"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="size_8hpp.html">boost/hana/size.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#ga8ec3ac9a6f5014db943f61ebc9e1e36e">hana::size</a>(hana::make_tuple()) == hana::size_c&lt;0&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#ga8ec3ac9a6f5014db943f61ebc9e1e36e">hana::size</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0)) == hana::size_c&lt;3&gt;);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#ga8ec3ac9a6f5014db943f61ebc9e1e36e">hana::size</a>(hana::nothing) == hana::size_c&lt;0&gt;);</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-_foldable.html#ga8ec3ac9a6f5014db943f61ebc9e1e36e">hana::size</a>(hana::just(<span class="charliteral">&#39;x&#39;</span>)) == hana::size_c&lt;1&gt;);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group-_foldable_html_ga8ec3ac9a6f5014db943f61ebc9e1e36e"><div class="ttname"><a href="group__group-_foldable.html#ga8ec3ac9a6f5014db943f61ebc9e1e36e">boost::hana::size</a></div><div class="ttdeci">constexpr auto size</div><div class="ttdoc">Equivalent to length; provided for consistency with the standard library.</div><div class="ttdef"><b>Definition:</b> size.hpp:30</div></div>
<div class="ttc" id="asize_8hpp_html"><div class="ttname"><a href="size_8hpp.html">size.hpp</a></div><div class="ttdoc">Defines boost::hana::size.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga650def4b2e98f4273d8b9b7aa5a2fc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga650def4b2e98f4273d8b9b7aa5a2fc28">&#9670;&nbsp;</a></span>sum</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::sum = see documentation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2sum_8hpp.html">boost/hana/fwd/sum.hpp</a>&gt;</code></p>

<p>Compute the sum of the numbers of a structure. </p>
<p>More generally, <code>sum</code> will take any foldable structure containing objects forming a Monoid and reduce them using the Monoid's binary operation. The initial state for folding is the identity of the Monoid. It is sometimes necessary to specify the Monoid to use; this is possible by using <code>sum&lt;M&gt;</code>. If no Monoid is specified, the structure will use the Monoid formed by the elements it contains (if it knows it), or <code><a class="el" href="structboost_1_1hana_1_1integral__constant__tag.html" title="Tag representing hana::integral_constant.">integral_constant_tag</a>&lt;int&gt;</code> otherwise. Hence, </p><div class="fragment"><div class="line">sum&lt;M&gt;(xs) = fold_left(xs, zero&lt;M or inferred Monoid&gt;(), <a class="code" href="group__group-_monoid.html#gaeb5d4a1e967e319712f9e4791948896c">plus</a>)</div>
<div class="line">sum&lt;&gt; = sum&lt;integral_constant_tag&lt;int&gt;&gt;</div>
<div class="ttc" id="agroup__group-_monoid_html_gaeb5d4a1e967e319712f9e4791948896c"><div class="ttname"><a href="group__group-_monoid.html#gaeb5d4a1e967e319712f9e4791948896c">boost::hana::plus</a></div><div class="ttdeci">constexpr auto plus</div><div class="ttdoc">Associative binary operation on a Monoid.</div><div class="ttdef"><b>Definition:</b> plus.hpp:47</div></div>
</div><!-- fragment --><p>For numbers, this will just compute the sum of the numbers in the <code>xs</code> structure.</p>
<dl class="section note"><dt>Note</dt><dd>The elements of the structure are not actually required to be in the same Monoid, but it must be possible to perform <code>plus</code> on any two adjacent elements of the structure, which requires each pair of adjacent element to at least have a common Monoid embedding. The meaning of "adjacent" as used here is that two elements of the structure <code>x</code> and <code>y</code> are adjacent if and only if they are adjacent in the linearization of that structure, as documented by the Iterable concept.</dd></dl>
<h2><a class="anchor" id="autotoc_md369"></a>
Why must we sometimes specify the &lt;tt&gt;Monoid&lt;/tt&gt; by using &lt;tt&gt;sum&lt;M&gt;&lt;/tt&gt;?</h2>
<p>This is because sequence tags like <code><a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples.">tuple_tag</a></code> are not parameterized (by design). Hence, we do not know what kind of objects are in the sequence, so we can't know a <code>0</code> value of which type should be returned when the sequence is empty. Therefore, the type of the <code>0</code> to return in the empty case must be specified explicitly. Other foldable structures like <code><a class="el" href="structboost_1_1hana_1_1range.html" title="Compile-time half-open interval of hana::integral_constants.">hana::range</a></code>s will ignore the suggested Monoid because they know the tag of the objects they contain. This inconsistent behavior is a limitation of the current design with non-parameterized tags, but we have no good solution for now.</p>
<h2><a class="anchor" id="autotoc_md370"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="range_8hpp.html">boost/hana/range.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sum_8hpp.html">boost/hana/sum.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__group-assertions.html#ga2c5006540936d9f8880e3a39f4fcc035">BOOST_HANA_CONSTANT_CHECK</a>(hana::sum&lt;&gt;(hana::make_range(hana::int_c&lt;1&gt;, hana::int_c&lt;6&gt;)) == hana::int_c&lt;15&gt;);</div>
<div class="line"> </div>
<div class="line">static_assert(hana::sum&lt;&gt;(hana::make_tuple(1, hana::int_c&lt;3&gt;, hana::long_c&lt;-5&gt;, 9)) == 8, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line">static_assert(hana::sum&lt;unsigned long&gt;(hana::make_tuple(1ul, 3ul)) == 4ul, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="asum_8hpp_html"><div class="ttname"><a href="sum_8hpp.html">sum.hpp</a></div><div class="ttdoc">Defines boost::hana::sum.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga7b0c23944364ce61136e10b978ae2170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b0c23944364ce61136e10b978ae2170">&#9670;&nbsp;</a></span>unpack</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::unpack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2unpack_8hpp.html">boost/hana/fwd/unpack.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Invoke a function with the elements of a Foldable as arguments. </p>
<p>Given a function and a foldable structure whose length can be known at compile-time, <code>unpack</code> invokes the function with the contents of that structure. In other words, <code>unpack(xs, f)</code> is equivalent to <code>f(x...)</code>, where <code>x...</code> are the elements of the structure. The length of the structure must be known at compile-time, because the version of <code>f</code>'s <code>operator()</code> that will be compiled depends on the number of arguments it is called with, which has to be known at compile-time.</p>
<p>To create a function that accepts a foldable instead of variadic arguments, see <code>fuse</code> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to expand into the function.</td></tr>
    <tr><td class="paramname">f</td><td>A function to be invoked as <code>f(x...)</code>, where <code>x...</code> are the elements of the structure as-if they had been linearized with <code>to&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples.">tuple_tag</a>&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md404"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="unpack_8hpp.html">boost/hana/unpack.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {</div>
<div class="line">        <span class="keywordflow">return</span> x + y + z;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-_foldable.html#ga7b0c23944364ce61136e10b978ae2170">hana::unpack</a>(hana::make_tuple(1, 2, 3), add) == 6);</div>
<div class="line">}</div>
<div class="ttc" id="aconfig_8hpp_html"><div class="ttname"><a href="config_8hpp.html">config.hpp</a></div><div class="ttdoc">Defines configuration macros used throughout the library.</div></div>
<div class="ttc" id="aunpack_8hpp_html"><div class="ttname"><a href="unpack_8hpp.html">unpack.hpp</a></div><div class="ttdoc">Defines boost::hana::unpack.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md405"></a>
Rationale: &lt;tt&gt;unpack&lt;/tt&gt;'s name and parameter order</h2>
<p>It has been suggested a couple of times that <code>unpack</code> be called <code>apply</code> instead, and that the parameter order be reversed to match that of the <a href="http://en.cppreference.com/w/cpp/experimental/apply">proposed std::apply function</a>. However, the name <code>apply</code> is already used to denote normal function application, an use which is consistent with the Boost MPL library and with the rest of the world, especially the functional programming community. Furthermore, the author of this library considers the proposed <code>std::apply</code> to have both an unfortunate name and an unfortunate parameter order. Indeed, taking the function as the first argument means that using <code>std::apply</code> with a lambda function looks like </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">std::apply</a>([](<span class="keyword">auto</span> ...args) {</div>
<div class="line">    use(args...);</div>
<div class="line">}, tuple);</div>
<div class="ttc" id="agroup__group-functional_html_ga30027c383676084be151ef3c6cf2829f"><div class="ttname"><a href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">boost::hana::apply</a></div><div class="ttdeci">constexpr auto apply</div><div class="ttdoc">Invokes a Callable with the given arguments.</div><div class="ttdef"><b>Definition:</b> apply.hpp:40</div></div>
</div><!-- fragment --><p>which is undeniably ugly because of the trailing <code>, tuple)</code> part on the last line. On the other hand, taking the function as a second argument allows one to write </p><div class="fragment"><div class="line"><a class="code" href="group__group-_foldable.html#ga7b0c23944364ce61136e10b978ae2170">hana::unpack</a>(tuple, [](<span class="keyword">auto</span> ...args) {</div>
<div class="line">    use(args...);</div>
<div class="line">});</div>
</div><!-- fragment --><p>which looks much nicer. Because of these observations, the author of this library feels justified to use <code>unpack</code> instead of <code>apply</code>, and to use a sane parameter order. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
