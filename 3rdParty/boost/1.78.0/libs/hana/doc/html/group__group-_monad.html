<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<title>Boost.Hana: Monad</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.7.1</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group-_monad.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Monad<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The <code>Monad</code> concept represents <code>Applicative</code>s with the ability to flatten nested levels of structure. </p>
<p>Historically, Monads are a construction coming from category theory, an abstract branch of mathematics. The functional programming community eventually discovered how Monads could be used to formalize several useful things like side effects, which led to the wide adoption of Monads in that community. However, even in a multi-paradigm language like C++, there are several constructs which turn out to be Monads, like <code>std::optional</code>, <code>std::vector</code> and others.</p>
<p>Everybody tries to introduce <code>Monad</code>s with a different analogy, and most people fail. This is called the [Monad tutorial fallacy][1]. We will try to avoid this trap by not presenting a specific intuition, and we will instead present what monads are mathematically. For specific intuitions, we will let readers who are new to this concept read one of the many excellent tutorials available online. Understanding Monads might take time at first, but once you get it, a lot of patterns will become obvious Monads; this enlightening will be your reward for the hard work.</p>
<p>There are different ways of defining a Monad; Haskell uses a function called <code>bind</code> (<code>&gt;&gt;=</code>) and another one called <code>return</code> (it has nothing to do with C++'s <code>return</code> statement). They then introduce relationships that must be satisfied for a type to be a Monad with those functions. Mathematicians sometimes use a function called <code>join</code> and another one called <code>unit</code>, or they also sometimes use other category theoretic constructions like functor adjunctions and the Kleisli category.</p>
<p>This library uses a composite approach. First, we use the <code>flatten</code> function (equivalent to <code>join</code>) along with the <code>lift</code> function from <code>Applicative</code> (equivalent to <code>unit</code>) to introduce the notion of monadic function composition. We then write the properties that must be satisfied by a Monad using this monadic composition operator, because we feel it shows the link between Monads and Monoids more clearly than other approaches.</p>
<p>Roughly speaking, we will say that a <code>Monad</code> is an <code>Applicative</code> which also defines a way to compose functions returning a monadic result, as opposed to only being able to compose functions returning a normal result. We will then ask for this composition to be associative and to have a neutral element, just like normal function composition. For usual composition, the neutral element is the identity function <code>id</code>. For monadic composition, the neutral element is the <code>lift</code> function defined by <code>Applicative</code>. This construction is made clearer in the laws below.</p>
<dl class="section note"><dt>Note</dt><dd>Monads are known to be a big chunk to swallow. However, it is out of the scope of this documentation to provide a full-blown explanation of the concept. The [Typeclassopedia][2] is a nice Haskell-oriented resource where more information about Monads can be found.</dd></dl>
<h2><a class="anchor" id="autotoc_md137"></a>
Minimal complete definitions</h2>
<p>First, a <code>Monad</code> must be both a <code>Functor</code> and an <code>Applicative</code>. Also, an implementation of <code>flatten</code> or <code>chain</code> satisfying the laws below for monadic composition must be provided.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>ap</code> method for <code>Applicatives</code> may be derived from the minimal complete definition of <code>Monad</code> and <code>Functor</code>; see below for more information.</dd></dl>
<h2><a class="anchor" id="autotoc_md138"></a>
Laws</h2>
<p>To simplify writing the laws, we use the comparison between functions. For two functions <code>f</code> and <code>g</code>, we define </p><div class="fragment"><div class="line">f == g  <span class="keywordflow">if</span> and only <span class="keywordflow">if</span>  f(x) == g(x) <span class="keywordflow">for</span> <a class="code" href="group__group-_searchable.html#ga81ae9764dd7818ad36270c6419fb1082">all</a> x</div>
<div class="ttc" id="agroup__group-_searchable_html_ga81ae9764dd7818ad36270c6419fb1082"><div class="ttname"><a href="group__group-_searchable.html#ga81ae9764dd7818ad36270c6419fb1082">boost::hana::all</a></div><div class="ttdeci">constexpr auto all</div><div class="ttdoc">Returns whether all the keys of the structure are true-valued.</div><div class="ttdef"><b>Definition:</b> all.hpp:30</div></div>
</div><!-- fragment --><p>With the usual composition of functions, we are given two functions \( f : A \to B \) and \( g : B \to C \), and we must produce a new function \( compose(g, f) : A \to C \). This composition of functions is associative, which means that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(h, <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(g, f)) == <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(<a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(h, g), f)</div>
<div class="ttc" id="agroup__group-functional_html_ga3b16146e53efcdf9ecbb9a7b21f8cd0b"><div class="ttname"><a href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">boost::hana::compose</a></div><div class="ttdeci">constexpr auto compose</div><div class="ttdoc">Return the composition of two functions or more.</div><div class="ttdef"><b>Definition:</b> compose.hpp:52</div></div>
</div><!-- fragment --><p>Also, this composition has an identity element, which is the identity function. This simply means that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(f, <span class="keywordtype">id</span>) == <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(<span class="keywordtype">id</span>, f) == f</div>
</div><!-- fragment --><p>This is probably nothing new if you are reading the <code>Monad</code> laws. Now, we can observe that the above is equivalent to saying that functions with the composition operator form a <code>Monoid</code>, where the neutral element is the identity function.</p>
<p>Given an <code>Applicative</code> <code>F</code>, what if we wanted to compose two functions \( f : A \to F(B) \) and \( g : B \to F(C) \)? When the <code>Applicative</code> <code>F</code> is also a <code>Monad</code>, such functions taking normal values but returning monadic values are called <em>monadic functions</em>. To compose them, we obviously can't use normal function composition, since the domains and codomains of <code>f</code> and <code>g</code> do not match properly. Instead, we'll need a new operator &ndash; let's call it <code>monadic_compose</code>: </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga5e0735de01a24f681c55aedfeb6d13bf"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ga5e0735de01a24f681c55aedfeb6d13bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-_monad.html#ga5e0735de01a24f681c55aedfeb6d13bf">boost::hana::tap</a></td></tr>
<tr class="memdesc:ga5e0735de01a24f681c55aedfeb6d13bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tap inside a monadic chain.  <a href="group__group-_monad.html#ga5e0735de01a24f681c55aedfeb6d13bf">More...</a><br /></td></tr>
<tr class="separator:ga5e0735de01a24f681c55aedfeb6d13bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaddd3789de43cf989babb10cdc0b447a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-_monad.html#gaaddd3789de43cf989babb10cdc0b447a">boost::hana::then</a></td></tr>
<tr class="memdesc:gaaddd3789de43cf989babb10cdc0b447a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequentially compose two monadic actions, discarding any value produced by the first but not its effects.  <a href="group__group-_monad.html#gaaddd3789de43cf989babb10cdc0b447a">More...</a><br /></td></tr>
<tr class="separator:gaaddd3789de43cf989babb10cdc0b447a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga5e0735de01a24f681c55aedfeb6d13bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e0735de01a24f681c55aedfeb6d13bf">&#9670;&nbsp;</a></span>tap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::tap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2tap_8hpp.html">boost/hana/fwd/tap.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Tap inside a monadic chain. </p>
<p>Given a function <code>f</code>, <code>tap&lt;M&gt;</code> returns a new function which performs <code>f</code> on its argument and then returns the argument lifted in the <code>M</code> <code>Monad</code>. Combined with the property that <code>chain(m, lift&lt;M&gt;) == m</code>, this provides a way of executing an action inside a monadic chain without influencing its overall result. This is useful to e.g. insert debug statements or perform actions that are not tied to the chain but that need to be executed inside of it.</p>
<dl class="section note"><dt>Note</dt><dd>Since C++ is not a pure language, it is possible to perform side effects inside the <code>f</code> function. Actually, side effects are the only reason why one might want to use <code>tap</code>. However, one should not rely on the side effects being done in any specific order.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The tag (a <code>Monad</code>) of the monads in the tapped monadic chain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function to be executed inside a monadic chain. It will be called as <code>f(x)</code>, where <code>x</code> is a value inside the previous monad in the chain. The result of <code>f</code> is always discarded.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md376"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="chain_8hpp.html">boost/hana/chain.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tap_8hpp.html">boost/hana/tap.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;set&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// We use a sorted container because the order in which the functions</span></div>
<div class="line">    <span class="comment">// are called is unspecified.</span></div>
<div class="line">    std::set&lt;int&gt; before, after;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> xs = hana::make_tuple(1, 2, 3)</div>
<div class="line">        | hana::tap&lt;hana::tuple_tag&gt;([&amp;](<span class="keywordtype">int</span> x) { before.insert(x); })</div>
<div class="line">        | [](<span class="keyword">auto</span> x) { <span class="keywordflow">return</span> hana::make_tuple(x, -x); }</div>
<div class="line">        | hana::tap&lt;hana::tuple_tag&gt;([&amp;](<span class="keywordtype">int</span> x) { after.insert(x); });</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(before == std::set&lt;int&gt;{1, 2, 3});</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(after == std::set&lt;int&gt;{1, -1, 2, -2, 3, -3});</div>
<div class="line">    <a class="code" href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a>(xs == hana::make_tuple(1, -1, 2, -2, 3, -3));</div>
<div class="line">}</div>
<div class="ttc" id="aassert_8hpp_html"><div class="ttname"><a href="assert_8hpp.html">assert.hpp</a></div><div class="ttdoc">Defines macros to perform different kinds of assertions.</div></div>
<div class="ttc" id="achain_8hpp_html"><div class="ttname"><a href="chain_8hpp.html">chain.hpp</a></div><div class="ttdoc">Defines boost::hana::chain.</div></div>
<div class="ttc" id="aequal_8hpp_html"><div class="ttname"><a href="equal_8hpp.html">equal.hpp</a></div><div class="ttdoc">Defines boost::hana::equal.</div></div>
<div class="ttc" id="agroup__group-assertions_html_ga4796ae107d58b67e0bbccd5ae6f70101"><div class="ttname"><a href="group__group-assertions.html#ga4796ae107d58b67e0bbccd5ae6f70101">BOOST_HANA_RUNTIME_CHECK</a></div><div class="ttdeci">#define BOOST_HANA_RUNTIME_CHECK(...)</div><div class="ttdoc">Equivalent to BOOST_HANA_RUNTIME_ASSERT, but not influenced by the BOOST_HANA_CONFIG_DISABLE_ASSERTIO...</div><div class="ttdef"><b>Definition:</b> assert.hpp:209</div></div>
<div class="ttc" id="anamespaceboost_1_1hana_html"><div class="ttname"><a href="namespaceboost_1_1hana.html">boost::hana</a></div><div class="ttdoc">Namespace containing everything in the library.</div><div class="ttdef"><b>Definition:</b> accessors.hpp:20</div></div>
<div class="ttc" id="atap_8hpp_html"><div class="ttname"><a href="tap_8hpp.html">tap.hpp</a></div><div class="ttdoc">Defines boost::hana::tap.</div></div>
<div class="ttc" id="atuple_8hpp_html"><div class="ttname"><a href="tuple_8hpp.html">tuple.hpp</a></div><div class="ttdoc">Defines boost::hana::tuple.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gaaddd3789de43cf989babb10cdc0b447a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaddd3789de43cf989babb10cdc0b447a">&#9670;&nbsp;</a></span>then</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::then</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2then_8hpp.html">boost/hana/fwd/then.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; before, <span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Sequentially compose two monadic actions, discarding any value produced by the first but not its effects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">before</td><td>The first <code>Monad</code> in the monadic composition chain. The result of this monad is ignored, but its effects are combined with that of the second monad.</td></tr>
    <tr><td class="paramname">xs</td><td>The second <code>Monad</code> in the monadic composition chain.</td></tr>
  </table>
  </dd>
</dl>
<h2><a class="anchor" id="autotoc_md377"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div>
<div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div>
<div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="then_8hpp.html">boost/hana/then.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>undefined { };</div>
<div class="line">static_assert(</div>
<div class="line">    <a class="code" href="group__group-_monad.html#gaaddd3789de43cf989babb10cdc0b447a">hana::then</a>(hana::make_tuple(undefined{}, undefined{}), hana::make_tuple(1, 2, 3))</div>
<div class="line">        ==</div>
<div class="line">    hana::make_tuple(</div>
<div class="line">        1, 2, 3,</div>
<div class="line">        1, 2, 3</div>
<div class="line">    )</div>
<div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() { }</div>
<div class="ttc" id="agroup__group-_monad_html_gaaddd3789de43cf989babb10cdc0b447a"><div class="ttname"><a href="group__group-_monad.html#gaaddd3789de43cf989babb10cdc0b447a">boost::hana::then</a></div><div class="ttdeci">constexpr auto then</div><div class="ttdoc">Sequentially compose two monadic actions, discarding any value produced by the first but not its effe...</div><div class="ttdef"><b>Definition:</b> then.hpp:36</div></div>
<div class="ttc" id="athen_8hpp_html"><div class="ttname"><a href="then_8hpp.html">then.hpp</a></div><div class="ttdoc">Defines boost::hana::then.</div></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
