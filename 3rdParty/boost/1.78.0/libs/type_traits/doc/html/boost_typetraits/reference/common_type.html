<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>common_type</title>
<link rel="stylesheet" href="../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../index.html" title="Chapter 1. Boost.TypeTraits">
<link rel="up" href="../reference.html" title="Alphabetical Reference">
<link rel="prev" href="conjunction.html" title="conjunction">
<link rel="next" href="copy_cv.html" title="copy_cv">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="conjunction.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../reference.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="copy_cv.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_typetraits.reference.common_type"></a><a class="link" href="common_type.html" title="common_type">common_type</a>
</h3></div></div></div>
<p>
        <span class="bold"><strong>Header:</strong></span> <code class="computeroutput"> <span class="preprocessor">#include</span>
        <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_traits</span><span class="special">/</span><span class="identifier">common_type</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        or <code class="computeroutput"> <span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_traits</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span><span class="special">...</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">struct</span> <span class="identifier">common_type</span><span class="special">;</span>
  <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span><span class="special">...</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">using</span> <span class="identifier">common_type_t</span> <span class="special">=</span> <span class="keyword">typename</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">...&gt;::</span><span class="identifier">type</span><span class="special">;</span> <span class="comment">// C++11 and above</span>
<span class="special">}</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">common_type</span></code> is a traits class
        used to deduce a type common to a several types, useful as the return type
        of functions operating on multiple input types such as in mixed-mode arithmetic..
      </p>
<p>
        The nested typedef <code class="computeroutput"><span class="special">::</span><span class="identifier">type</span></code>
        could be defined as follows:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span><span class="special">...</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">common_type</span><span class="special">;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">,</span> <span class="keyword">class</span><span class="special">...</span> <span class="identifier">V</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">U</span><span class="special">,</span> <span class="identifier">V</span><span class="special">...&gt;</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">U</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">V</span><span class="special">...&gt;::</span><span class="identifier">type</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">common_type</span><span class="special">&lt;&gt;</span> <span class="special">{</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="link" href="decay.html" title="decay">decay</a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">U</span><span class="special">&gt;</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="link" href="decay.html" title="decay">decay</a><span class="special">&lt;</span>
        <span class="keyword">decltype</span><span class="special">(</span> <a class="link" href="declval.html" title="declval">declval</a><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;()?</span>
            <a class="link" href="declval.html" title="declval">declval</a><span class="special">&lt;</span><span class="keyword">typename</span> <a class="link" href="decay.html" title="decay">decay</a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;():</span>
            <a class="link" href="declval.html" title="declval">declval</a><span class="special">&lt;</span><span class="keyword">typename</span> <a class="link" href="decay.html" title="decay">decay</a><span class="special">&lt;</span><span class="identifier">U</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;()</span> <span class="special">)</span>
    <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
        All parameter types must be complete. This trait is permitted to be specialized
        by a user if at least one template parameter is a user-defined type. <span class="bold"><strong>Note:</strong></span> Such specializations are required when only
        explicit conversions are desired among the <code class="computeroutput"><span class="identifier">common_type</span></code>
        arguments.
      </p>
<p>
        Note that when the compiler does not support variadic templates (and the
        macro <code class="computeroutput"><span class="identifier">BOOST_NO_CXX11_VARIADIC_TEMPLATES</span></code>
        is defined) then the maximum number of template arguments is 9.
      </p>
<h5>
<a name="boost_typetraits.reference.common_type.h0"></a>
        <span class="phrase"><a name="boost_typetraits.reference.common_type.tutorial"></a></span><a class="link" href="common_type.html#boost_typetraits.reference.common_type.tutorial">Tutorial</a>
      </h5>
<p>
        In a nutshell, <code class="computeroutput"><span class="identifier">common_type</span></code>
        is a trait that takes 1 or more types, and returns a type which all of the
        types will convert to. The default definition demands this conversion be
        implicit. However the trait can be specialized for user-defined types which
        want to limit their inter-type conversions to explicit, and yet still want
        to interoperate with the <code class="computeroutput"><span class="identifier">common_type</span></code>
        facility.
      </p>
<p>
        <span class="bold"><strong>Example:</strong></span>
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span>
<span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">U</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">&gt;</span>
<span class="keyword">operator</span><span class="special">+(</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;,</span> <span class="identifier">complex</span><span class="special">&lt;</span><span class="identifier">U</span><span class="special">&gt;);</span>
</pre>
<p>
        In the above example, "mixed-mode" complex arithmetic is allowed.
        The return type is described by <code class="computeroutput"><span class="identifier">common_type</span></code>.
        For example the resulting type of adding a <code class="computeroutput"><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">float</span><span class="special">&gt;</span></code> and <code class="computeroutput"><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code> might be a <code class="computeroutput"><span class="identifier">complex</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span></code>.
      </p>
<p>
        Here is how someone might produce a variadic comparison function:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="special">...</span><span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">...&gt;::</span><span class="identifier">type</span>
<span class="identifier">min</span><span class="special">(</span><span class="identifier">T</span><span class="special">...</span> <span class="identifier">t</span><span class="special">);</span>
</pre>
<p>
        This is a very useful and broadly applicable utility.
      </p>
<h5>
<a name="boost_typetraits.reference.common_type.h1"></a>
        <span class="phrase"><a name="boost_typetraits.reference.common_type.how_to_get_the_common_type_of_types_with_explicit_conversions_"></a></span><a class="link" href="common_type.html#boost_typetraits.reference.common_type.how_to_get_the_common_type_of_types_with_explicit_conversions_">How
        to get the common type of types with explicit conversions?</a>
      </h5>
<p>
        Another choice for the author of the preceding operator could be
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span>
<span class="keyword">typename</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;,</span> <span class="identifier">complex</span><span class="special">&lt;</span><span class="identifier">U</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span>
<span class="keyword">operator</span><span class="special">+(</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;,</span> <span class="identifier">complex</span><span class="special">&lt;</span><span class="identifier">U</span><span class="special">&gt;);</span>
</pre>
<p>
        As the default definition of <code class="computeroutput"><span class="identifier">common_type</span></code>
        demands the conversion be implicit, we need to specialize the trait for complex
        types as follows.
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">U</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">complex</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;,</span> <span class="identifier">complex</span><span class="special">&lt;</span><span class="identifier">U</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">{</span>
    <span class="keyword">typedef</span> <span class="identifier">complex</span><span class="special">&lt;</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">U</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">type</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<h5>
<a name="boost_typetraits.reference.common_type.h2"></a>
        <span class="phrase"><a name="boost_typetraits.reference.common_type.how_important_is_the_order_of_the__code__phrase_role__identifier__common_type__phrase__phrase_role__special___lt__gt___phrase___code__template_arguments_"></a></span><a class="link" href="common_type.html#boost_typetraits.reference.common_type.how_important_is_the_order_of_the__code__phrase_role__identifier__common_type__phrase__phrase_role__special___lt__gt___phrase___code__template_arguments_">How
        important is the order of the <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;&gt;</span></code> template arguments?</a>
      </h5>
<p>
        The order of the template parameters is important.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span><span class="identifier">B</span><span class="special">,</span><span class="identifier">C</span><span class="special">&gt;::</span><span class="identifier">type</span></code> is not equivalent to <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">C</span><span class="special">,</span><span class="identifier">A</span><span class="special">,</span><span class="identifier">B</span><span class="special">&gt;::</span><span class="identifier">type</span></code>, but to <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span><span class="identifier">B</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">,</span> <span class="identifier">C</span><span class="special">&gt;::</span><span class="identifier">type</span></code>.
      </p>
<p>
        Consider
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">A</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">B</span> <span class="special">{};</span>
<span class="keyword">struct</span> <span class="identifier">C</span> <span class="special">{</span>
    <span class="identifier">C</span><span class="special">()</span> <span class="special">{}</span>
    <span class="identifier">C</span><span class="special">(</span><span class="identifier">A</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">{}</span>
    <span class="identifier">C</span><span class="special">(</span><span class="identifier">B</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">{}</span>
    <span class="identifier">C</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">C</span> <span class="keyword">const</span><span class="special">&amp;)</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        The following doesn't compile
      </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">,</span> <span class="identifier">C</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">ABC</span><span class="special">;</span> <span class="comment">// Does not compile</span>
</pre>
<p>
        while
      </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">C</span><span class="special">,</span> <span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">ABC</span><span class="special">;</span>
</pre>
<p>
        compiles.
      </p>
<p>
        Thus, as <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span><span class="identifier">B</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
        is undefined, <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span><span class="identifier">B</span><span class="special">,</span><span class="identifier">C</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
        is also undefined.
      </p>
<p>
        It is intended that clients who wish for <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span>
        <span class="identifier">B</span><span class="special">&gt;</span></code>
        to be well defined to define it themselves:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

<span class="keyword">template</span> <span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">&gt;</span> <span class="special">{</span><span class="keyword">typedef</span> <span class="identifier">C</span> <span class="identifier">type</span><span class="special">;};</span>

<span class="special">}</span>
</pre>
<p>
        Now this client can ask for <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span>
        <span class="identifier">B</span><span class="special">,</span> <span class="identifier">C</span><span class="special">&gt;</span></code> (and
        get the same answer).
      </p>
<p>
        Clients wanting to ask <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span>
        <span class="identifier">B</span><span class="special">,</span> <span class="identifier">C</span><span class="special">&gt;</span></code> in
        any order and get the same result need to add in addition:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

<span class="keyword">template</span> <span class="special">&lt;&gt;</span> <span class="keyword">struct</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">B</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">&gt;</span> <span class="special">{};</span>

<span class="special">}</span>
</pre>
<p>
        This is needed as the specialization of <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span>
        <span class="identifier">B</span><span class="special">&gt;</span></code>
        is not be used implicitly for <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">B</span><span class="special">,</span>
        <span class="identifier">A</span><span class="special">&gt;</span></code>.
      </p>
<h5>
<a name="boost_typetraits.reference.common_type.h3"></a>
        <span class="phrase"><a name="boost_typetraits.reference.common_type.can_the__code__phrase_role__identifier__common_type__phrase___code__of_two_types_be_a_third_type_"></a></span><a class="link" href="common_type.html#boost_typetraits.reference.common_type.can_the__code__phrase_role__identifier__common_type__phrase___code__of_two_types_be_a_third_type_">Can
        the <code class="computeroutput"><span class="identifier">common_type</span></code> of two types
        be a third type?</a>
      </h5>
<p>
        Given the preceding example, one might expect <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span><span class="identifier">B</span><span class="special">&gt;::</span><span class="identifier">type</span></code> to be <code class="computeroutput"><span class="identifier">C</span></code>
        without any intervention from the user. But the default <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;&gt;</span></code> implementation doesn't grant that.
        It is intended that clients who wish for <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span>
        <span class="identifier">B</span><span class="special">&gt;</span></code>
        to be well defined to define it themselves:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

<span class="keyword">template</span> <span class="special">&lt;&gt;</span>
<span class="keyword">struct</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">&gt;</span> <span class="special">{</span><span class="keyword">typedef</span> <span class="identifier">C</span> <span class="identifier">type</span><span class="special">;};</span>

<span class="keyword">template</span> <span class="special">&lt;&gt;</span> <span class="keyword">struct</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">B</span><span class="special">,</span> <span class="identifier">A</span><span class="special">&gt;</span>
<span class="special">:</span> <span class="keyword">public</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">&gt;</span> <span class="special">{};</span>

<span class="special">}</span>
</pre>
<p>
        Now this client can ask for <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span>
        <span class="identifier">B</span><span class="special">&gt;</span></code>.
      </p>
<h5>
<a name="boost_typetraits.reference.common_type.h4"></a>
        <span class="phrase"><a name="boost_typetraits.reference.common_type.how_does__code__phrase_role__identifier__common_type__phrase___code__behave_with_pointers_"></a></span><a class="link" href="common_type.html#boost_typetraits.reference.common_type.how_does__code__phrase_role__identifier__common_type__phrase___code__behave_with_pointers_">How
        does <code class="computeroutput"><span class="identifier">common_type</span></code> behave with
        pointers?</a>
      </h5>
<p>
        Consider
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">C</span> <span class="special">{</span> <span class="special">}:</span>
<span class="keyword">struct</span> <span class="identifier">B</span> <span class="special">:</span> <span class="identifier">C</span> <span class="special">{</span> <span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">A</span> <span class="special">:</span> <span class="identifier">C</span> <span class="special">{</span> <span class="special">};</span>
</pre>
<p>
        Shouldn't <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">*,</span><span class="identifier">B</span><span class="special">*&gt;::</span><span class="identifier">type</span></code>
        be <code class="computeroutput"><span class="identifier">C</span><span class="special">*</span></code>?
        I would say yes, but the default implementation will make it ill-formed.
      </p>
<p>
        The library could add a specialization for pointers, as
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span>
<span class="special">{</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">A</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">B</span><span class="special">&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">*,</span> <span class="identifier">B</span><span class="special">*&gt;</span> <span class="special">{</span>
        <span class="keyword">typedef</span> <span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">&gt;*</span> <span class="identifier">type</span><span class="special">;</span>
    <span class="special">};</span>
<span class="special">}</span>
</pre>
<p>
        But in the absence of a motivating use cases, we prefer not to add more than
        the standard specifies.
      </p>
<p>
        Of course the user can always make this specialization.
      </p>
<h5>
<a name="boost_typetraits.reference.common_type.h5"></a>
        <span class="phrase"><a name="boost_typetraits.reference.common_type.can_you_explain_the_pros_cons_of__code__phrase_role__identifier__common_type__phrase___code__against_boost_typeof_"></a></span><a class="link" href="common_type.html#boost_typetraits.reference.common_type.can_you_explain_the_pros_cons_of__code__phrase_role__identifier__common_type__phrase___code__against_boost_typeof_">Can
        you explain the pros/cons of <code class="computeroutput"><span class="identifier">common_type</span></code>
        against Boost.Typeof?</a>
      </h5>
<p>
        Even if they appear to be close, <code class="computeroutput"><span class="identifier">common_type</span></code>
        and <code class="computeroutput"><span class="identifier">typeof</span></code> have different
        purposes. You use <code class="computeroutput"><span class="identifier">typeof</span></code>
        to get the type of an expression, while you use <code class="computeroutput"><span class="identifier">common_type</span></code>
        to set explicitly the type returned of a template function. Both are complementary,
        and indeed <code class="computeroutput"><span class="identifier">common_type</span></code> is
        approximately equivalent to <code class="computeroutput"><span class="keyword">decltype</span><span class="special">(</span><a class="link" href="declval.html" title="declval">declval</a><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;()</span>
        <span class="special">?</span> <a class="link" href="declval.html" title="declval">declval</a><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;()</span>
        <span class="special">:</span> <a class="link" href="declval.html" title="declval">declval</a><span class="special">&lt;</span><span class="identifier">U</span><span class="special">&gt;())</span></code>.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">common_type</span></code> is also similar
        to <code class="computeroutput"><span class="identifier">promote_args</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="special">...</span><span class="identifier">T</span><span class="special">&gt;</span></code> in
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">/</span><span class="identifier">math</span><span class="special">/</span><span class="identifier">tools</span><span class="special">/</span><span class="identifier">promotion</span><span class="special">.</span><span class="identifier">hpp</span></code>, though
        it is not exactly the same as <code class="computeroutput"><span class="identifier">promote_args</span></code>
        either. <code class="computeroutput"><span class="identifier">common_type</span><span class="special">&lt;</span><span class="identifier">T1</span><span class="special">,</span> <span class="identifier">T2</span><span class="special">&gt;::</span><span class="identifier">type</span></code>
        simply represents the result of some operation on <code class="computeroutput"><span class="identifier">T1</span></code>
        and <code class="computeroutput"><span class="identifier">T2</span></code>, and defaults to the
        type obtained by putting <code class="computeroutput"><span class="identifier">T1</span></code>
        and <code class="computeroutput"><span class="identifier">T2</span></code> into a conditional
        statement.
      </p>
<p>
        It is meant to be customizable (via specialization) if this default is not
        appropriate.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2000, 2011 Adobe Systems Inc, David Abrahams,
      Frederic Bron, Steve Cleary, Beman Dawes, Glen Fernandes, Aleksey Gurtovoy,
      Howard Hinnant, Jesse Jones, Mat Marcus, Itay Maman, John Maddock, Alexander
      Nasonov, Thorsten Ottosen, Roman Perepelitsa, Robert Ramey, Jeremy Siek, Robert
      Stewart and Steven Watanabe<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="conjunction.html"><img src="../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../reference.html"><img src="../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="copy_cv.html"><img src="../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
