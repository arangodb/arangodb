<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<meta name="author" content="Lightweight Error Augmentation Framework written in C&#43;&#43;11 | Emil Dotchevski">
<title>LEAF</title>
<link rel="stylesheet" href="./zajo-dark.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./rouge-github.css">
<meta name="keywords" content="c++,error handling,open source">
<meta name="description" content="Lightweight Error Augmentation Framework">
<link rel="stylesheet" href="./zajo-light.css" disabled=true>
<script>
function switch_style()
{
	var i, tag;
	for( i=0, tag=document.getElementsByTagName("link"); i<tag.length; i++ )
		if( tag[i].rel.indexOf("stylesheet")!=-1 && tag[i].href.includes("zajo-") )
			tag[i].disabled = !tag[i].disabled;
}
</script>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>LEAF<div style="z-index: 3; bottom:-16px; right:4px; position:fixed"><input width="32" height="32" type="image" alt="Skin" src="./skin.png" onclick="this.blur();switch_style();return false;"/></div></h1>
<div class="details">
<span id="author" class="author">Lightweight Error Augmentation Framework written in C&#43;&#43;11 | Emil Dotchevski</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#_abstract">Abstract</a></li>
<li><a href="#support">Support</a></li>
<li><a href="#portability">Portability</a></li>
<li><a href="#distribution">Distribution</a></li>
<li><a href="#tutorial">Tutorial</a>
<ul class="sectlevel2">
<li><a href="#_reporting_errors">Reporting Errors</a></li>
<li><a href="#_checking_for_errors">Checking for Errors</a></li>
<li><a href="#tutorial-result">Error Handling</a></li>
<li><a href="#_working_with_different_error_types">Working with Different Error Types</a></li>
<li><a href="#_working_with_multiple_error_objects">Working with Multiple Error Objects</a></li>
<li><a href="#tutorial-eh">Exception Handling</a></li>
<li><a href="#_using_external_result_types">Using External <code>result</code> Types</a></li>
<li><a href="#tutorial-model">Error Communication Model</a>
<ul class="sectlevel3">
<li><a href="#_noexcept_api"><code>noexcept</code> API</a></li>
<li><a href="#_exception_handling_api">Exception Handling API</a></li>
<li><a href="#tutorial-interoperability">Interoperability</a></li>
</ul>
</li>
<li><a href="#tutorial-loading">Loading of Error Objects</a></li>
<li><a href="#tutorial-on_error">Using <code>on_error</code></a></li>
<li><a href="#tutorial-predicates">Using Predicates to Handle Errors</a></li>
<li><a href="#tutorial-binding_handlers">Binding Error Handlers in a <code>std::tuple</code></a></li>
<li><a href="#tutorial-async">Transporting Error Objects Between Threads</a>
<ul class="sectlevel3">
<li><a href="#tutorial-async_result">Using <code>result&lt;T&gt;</code></a></li>
<li><a href="#tutorial-async_eh">Using Exception Handling</a></li>
</ul>
</li>
<li><a href="#tutorial-classification">Classification of Failures</a></li>
<li><a href="#tutorial-exception_to_result">Converting Exceptions to <code>result&lt;T&gt;</code></a></li>
<li><a href="#tutorial-on_error_in_c_callbacks">Using <code>error_monitor</code> to Report Arbitrary Errors from C-callbacks</a></li>
<li><a href="#tutorial-diagnostic_information">Diagnostic Information</a></li>
<li><a href="#tutorial-std_error_code">Working with <code>std::error_code</code>, <code>std::error_condition</code></a>
<ul class="sectlevel3">
<li><a href="#_introduction">Introduction</a></li>
<li><a href="#_support_in_leaf">Support in LEAF</a></li>
</ul>
</li>
<li><a href="#tutorial-boost_exception_integration">Boost Exception Integration</a></li>
</ul>
</li>
<li><a href="#example">Examples</a></li>
<li><a href="#synopsis">Synopsis</a>
<ul class="sectlevel2">
<li><a href="#synopsis-reporting">Error Reporting</a>
<ul class="sectlevel3">
<li><a href="#error.hpp"><code>error.hpp</code></a></li>
<li><a href="#common.hpp"><code>common.hpp</code></a></li>
<li><a href="#result.hpp"><code>result.hpp</code></a></li>
<li><a href="#on_error.hpp"><code>on_error.hpp</code></a></li>
<li><a href="#exception.hpp"><code>exception.hpp</code></a></li>
<li><a href="#_capture_hpp"><code>capture.hpp</code></a></li>
</ul>
</li>
<li><a href="#tutorial-handling">Error Handling</a>
<ul class="sectlevel3">
<li><a href="#context.hpp"><code>context.hpp</code></a></li>
<li><a href="#handle_errors.hpp"><code>handle_errors.hpp</code></a></li>
<li><a href="#pred.hpp"><code>pred.hpp</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#functions">Reference: Functions</a>
<ul class="sectlevel2">
<li><a href="#activate_context"><code>activate_context</code></a></li>
<li><a href="#capture"><code>capture</code></a></li>
<li><a href="#context_type_from_handlers"><code>context_type_from_handlers</code></a></li>
<li><a href="#current_error"><code>current_error</code></a></li>
<li><a href="#exception"><code>exception</code></a></li>
<li><a href="#exception_to_result"><code>exception_to_result</code></a></li>
<li><a href="#make_context"><code>make_context</code></a></li>
<li><a href="#make_shared_context"><code>make_shared_context</code></a></li>
<li><a href="#new_error"><code>new_error</code></a></li>
<li><a href="#on_error"><code>on_error</code></a></li>
<li><a href="#try_catch"><code>try_catch</code></a></li>
<li><a href="#try_handle_all"><code>try_handle_all</code></a></li>
<li><a href="#try_handle_some"><code>try_handle_some</code></a></li>
</ul>
</li>
<li><a href="#types">Reference: Types</a>
<ul class="sectlevel2">
<li><a href="#context"><code>context</code></a>
<ul class="sectlevel3">
<li><a href="#context::context">Constructors</a></li>
<li><a href="#context::activate"><code>activate</code></a></li>
<li><a href="#context::deactivate"><code>deactivate</code></a></li>
<li><a href="#context::handle_error"><code>handle_error</code></a></li>
<li><a href="#context::is_active"><code>is_active</code></a></li>
<li><a href="#context::print"><code>print</code></a></li>
<li><a href="#context::propagate"><code>propagate</code></a></li>
</ul>
</li>
<li><a href="#context_activator"><code>context_activator</code></a></li>
<li><a href="#diagnostic_info"><code>diagnostic_info</code></a></li>
<li><a href="#error_id"><code>error_id</code></a>
<ul class="sectlevel3">
<li><a href="#error_id::error_id">Constructors</a></li>
<li><a href="#is_error_id"><code>is_error_id</code></a></li>
<li><a href="#error_id::load"><code>load</code></a></li>
<li><a href="#error_id::comparison_operators"><code>operator==</code>, <code>!=</code>, <code>&lt;</code></a></li>
<li><a href="#error_id::operator_bool"><code>operator bool</code></a></li>
<li><a href="#error_id::to_error_code"><code>to_error_code</code></a></li>
<li><a href="#error_id::value"><code>value</code></a></li>
</ul>
</li>
<li><a href="#error_monitor"><code>error_monitor</code></a></li>
<li><a href="#e_api_function"><code>e_api_function</code></a></li>
<li><a href="#e_at_line"><code>e_at_line</code></a></li>
<li><a href="#e_errno"><code>e_errno</code></a></li>
<li><a href="#e_file_name"><code>e_file_name</code></a></li>
<li><a href="#e_LastError"><code>e_LastError</code></a></li>
<li><a href="#e_source_location"><code>e_source_location</code></a></li>
<li><a href="#e_type_info_name"><code>e_type_info_name</code></a></li>
<li><a href="#error_info"><code>error_info</code></a></li>
<li><a href="#polymorphic_context"><code>polymorphic_context</code></a></li>
<li><a href="#result"><code>result</code></a>
<ul class="sectlevel3">
<li><a href="#result::result">Constructors</a></li>
<li><a href="#result::error"><code>error</code></a></li>
<li><a href="#result::load"><code>load</code></a></li>
<li><a href="#result::operator_eq"><code>operator=</code></a></li>
<li><a href="#result::operator_bool"><code>operator bool</code></a></li>
<li><a href="#result::value"><code>value</code>, <code>operator*</code>, <code>-></code></a></li>
</ul>
</li>
<li><a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a></li>
</ul>
</li>
<li><a href="#predicates">Reference: Predicates</a>
<ul class="sectlevel2">
<li><a href="#catch_"><code>catch_</code></a></li>
<li><a href="#if_not"><code>if_not</code></a></li>
<li><a href="#match"><code>match</code></a></li>
<li><a href="#match_member"><code>match_member</code></a></li>
<li><a href="#match_value"><code>match_value</code></a></li>
</ul>
</li>
<li><a href="#traits">Reference: Traits</a>
<ul class="sectlevel2">
<li><a href="#is_predicate"><code>is_predicate</code></a></li>
<li><a href="#is_result_type"><code>is_result_type</code></a></li>
</ul>
</li>
<li><a href="#macros">Reference: Macros</a>
<ul class="sectlevel2">
<li><a href="#BOOST_LEAF_ASSIGN"><code>BOOST_LEAF_ASSIGN</code></a></li>
<li><a href="#BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></a></li>
<li><a href="#BOOST_LEAF_CHECK"><code>BOOST_LEAF_CHECK</code></a></li>
<li><a href="#BOOST_LEAF_EXCEPTION"><code>BOOST_LEAF_EXCEPTION</code></a></li>
<li><a href="#BOOST_LEAF_NEW_ERROR"><code>BOOST_LEAF_NEW_ERROR</code></a></li>
<li><a href="#BOOST_LEAF_THROW_EXCEPTION"><code>BOOST_LEAF_THROW_EXCEPTION</code></a></li>
</ul>
</li>
<li><a href="#rationale">Design</a>
<ul class="sectlevel2">
<li><a href="#_rationale">Rationale</a></li>
<li><a href="#exception_specifications">Critique 1: Error Types Do Not Participate in Function Signatures</a></li>
<li><a href="#translation">Critique 2: LEAF Does Not Facilitate Mapping Between Different Error Types</a></li>
<li><a href="#errors_are_not_implementation_details">Critique 3: LEAF Does Not Treat Low Level Error Types as Implementation Details</a></li>
</ul>
</li>
<li><a href="#_alternatives_to_leaf">Alternatives to LEAF</a>
<ul class="sectlevel2">
<li><a href="#boost_exception">Comparison to Boost Exception</a></li>
<li><a href="#boost_outcome">Comparison to Boost Outcome</a>
<ul class="sectlevel3">
<li><a href="#_design_differences">Design Differences</a></li>
<li><a href="#interoperability">The Interoperability Problem</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_benchmark">Benchmark</a></li>
<li><a href="#_running_the_unit_tests">Running the Unit Tests</a>
<ul class="sectlevel2">
<li><a href="#_meson_build">Meson Build</a></li>
<li><a href="#_boost_build">Boost Build</a></li>
</ul>
</li>
<li><a href="#configuration">Configuration Macros</a></li>
<li><a href="#_limitations">Limitations</a></li>
<li><a href="#_acknowledgements">Acknowledgements</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph text-right">
<p><a href="https://github.com/boostorg/leaf">GitHub</a> | <a href="https://boostorg.github.io/leaf/leaf.pdf">PDF</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_abstract">Abstract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Boost LEAF is a lightweight error handling library for C&#43;&#43;11. Features:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Small single-header format, no dependencies.</p>
</li>
<li>
<p>Designed for maximum efficiency ("happy" path and "sad" path).</p>
</li>
<li>
<p>No dynamic memory allocations, even with heavy payloads.</p>
</li>
<li>
<p>O(1) transport of arbitrary error types (independent of call stack depth).</p>
</li>
<li>
<p>Can be used with or without exception handling.</p>
</li>
<li>
<p>Support for multi-thread programming.</p>
</li>
</ul>
</div>
</div>
</div>
<table class="tableblock frame-none grid-none stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tutorial">Tutorial</a> | <a href="#synopsis">Synopsis</a> | <a href="https://github.com/boostorg/leaf/blob/master/doc/whitepaper.md">Whitepaper</a> | <a href="https://github.com/boostorg/leaf/blob/master/benchmark/benchmark.md">Benchmark</a></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">Reference: <a href="#functions">Functions</a> | <a href="#types">Types</a> | <a href="#predicates">Predicates</a> | <a href="#traits">Traits</a> | <a href="#macros">Macros</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>LEAF is designed with a strong bias towards the common use case where callers of functions which may fail check for success and forward errors up the call stack but do not handle them. In this case, only a trivial success-or-failure discriminant is transported. Actual error objects are communicated directly to the error handling scope, skipping the intermediate check-only frames altogether.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="support">Support</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://Cpplang.slack.com">cpplang on Slack</a> (use the <code>#boost</code> channel)</p>
</li>
<li>
<p><a href="https://lists.boost.org/mailman/listinfo.cgi/boost-users">Boost Users Mailing List</a></p>
</li>
<li>
<p><a href="https://lists.boost.org/mailman/listinfo.cgi/boost">Boost Developers Mailing List</a></p>
</li>
<li>
<p><a href="https://github.com/boostorg/leaf/issues">Report an issue</a> on GitHub</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="portability">Portability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LEAF requires only C&#43;&#43;11, but is tested on many compiler versions and C++ standards.</p>
</div>
<div class="paragraph">
<p>The library uses thread-local storage, except when multi-threading is disabled (e.g. on some embedded platforms). See <a href="#configuration">Configuration Macros</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="distribution">Distribution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copyright &#169; 2018-2021 Emil Dotchevski. Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</p>
</div>
<div class="paragraph">
<p>There are three distribution channels:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>LEAF is included in official <a href="https://www.boost.org/">Boost</a> releases, starting with Boost 1.75.</p>
</li>
<li>
<p>The source code is hosted on <a href="https://github.com/boostorg/leaf">GitHub</a>.</p>
</li>
<li>
<p>For maximum portability, the latest LEAF release is also available in single-header format: simply download <a href="https://raw.githubusercontent.com/boostorg/leaf/gh-pages/leaf.hpp">leaf.hpp</a> (direct download link).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
LEAF does not depend on Boost or other libraries.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tutorial">Tutorial</h2>
<div class="sectionbody">
<div class="paragraph">
<p>What is a failure? It is simply the inability of a function to return a valid result, instead producing an error object describing the reason for the failure.</p>
</div>
<div class="paragraph">
<p>A typical design is to return a variant type, e.g. <code>result&lt;T, E&gt;</code>. Internally, such variant types must store a discriminant (in this case a boolean) to indicate whether the object holds a <code>T</code> or an <code>E</code>.</p>
</div>
<div class="paragraph">
<p>The design of LEAF is informed by the observation that the immediate caller must have access to the discriminant in order to determine the availability of a valid <code>T</code>, but otherwise it rarely needs to access the <code>E</code>. The error object is only needed once an error handling scope is reached.</p>
</div>
<div class="paragraph">
<p>Therefore what would have been a <code>result&lt;T, E&gt;</code> becomes <code>result&lt;T&gt;</code>, which stores the discriminant and (optionally) a <code>T</code>, while the <code>E</code> is communicated directly to the error handling scope where it is needed.</p>
</div>
<div class="paragraph">
<p>The benefit of this decomposition is that <code>result&lt;T&gt;</code> becomes extremely lightweight, as it is not coupled with error types; further, error objects are communicated in O(1) time (independent of the call stack depth). Even very large objects are handled efficiently without dynamic memory allocation.</p>
</div>
<div class="sect2">
<h3 id="_reporting_errors">Reporting Errors</h3>
<div class="paragraph">
<p>A function that reports an error is pretty straight-forward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">err1</span> <span class="p">{</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span> <span class="p">};</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="p">....</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">error_detected</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span> <span class="n">err1</span><span class="o">::</span><span class="n">e1</span> <span class="p">);</span> <span class="c1">// Pass an error object of any type</span>

  <span class="c1">// Produce and return a T.</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#new_error"><code>new_error</code></a></p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_checking_for_errors">Checking for Errors</h3>
<div class="paragraph">
<p>Checking for errors communicated by a <code>leaf::result&lt;T&gt;</code> works as expected:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span>
  <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">r</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">error</span><span class="p">();</span>

  <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
  <span class="c1">// Use v to produce a valid U</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a></p>
</div>
<div class="paragraph">
<p>The boilerplate <code>if</code> statement can be avoided using <code>BOOST_LEAF_AUTO</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">());</span> <span class="c1">// Bail out on error</span>

  <span class="c1">// Use v to produce a valid U</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></a> | <a href="#BOOST_LEAF_CHECK"><code>BOOST_LEAF_CHECK</code></a></p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-result">Error Handling</h3>
<div class="paragraph">
<p>Error handling scopes must use a special syntax to indicate that they need to access error objects. The following excerpt attempts several operations and handles errors of type <code>err1</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">f1</span><span class="p">());</span>
    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">f2</span><span class="p">());</span>

    <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">err1</span> <span class="n">e</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">e</span> <span class="o">==</span> <span class="n">err1</span><span class="o">::</span><span class="n">e1</span> <span class="p">)</span>
      <span class="p">....</span> <span class="c1">// Handle err1::e1</span>
    <span class="k">else</span>
      <span class="p">....</span> <span class="c1">// Handle any other err1 value</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#result"><code>result</code></a> | <a href="#BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></a></p>
</div>
<div class="paragraph">
<p>The first lambda passed to <code>try_handle_some</code> is executed first; it attempts to produce a <code>result&lt;U&gt;</code>, but it may fail (we presume that <code>f1</code> and <code>f2</code> return <code>leaf::result&lt;T&gt;</code>, and <code>g</code> takes two arguments of type <code>T</code> and returns a <code>leaf::result&lt;U&gt;</code>).</p>
</div>
<div class="paragraph">
<p>The second lambda is an error handler: it will be called iff the first lambda fails and an error object of type <code>err1</code> was communicated to LEAF. That object is stored on the stack, local to the <code>try_handle_some</code> function (LEAF knows to allocate this storage because we gave it an error handler that takes an <code>err1</code>). Error handlers passed to <code>leaf::try_handle_some</code> can return a valid <code>leaf::result&lt;U&gt;</code> but are allowed to fail.</p>
</div>
<div class="paragraph">
<p>It is possible for an error handler to specify that it can only deal with a particular value of a given error type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">f1</span><span class="p">());</span>
    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">f2</span><span class="p">());</span>

    <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span> <span class="n">v2</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">err1</span><span class="p">,</span> <span class="n">err1</span><span class="o">::</span><span class="n">e1</span><span class="o">&gt;</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="c1">// Handle err::e1</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">err1</span> <span class="n">e</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="c1">// Handle any other err1 value</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>LEAF considers the provided error handlers in order, and calls the first one for which it can supply arguments, based on the error objects currently being communicated. Above:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The first error handler uses the predicate <code>leaf::match</code> to specify that it should only be considered if an error object of type <code>err1</code> is available, and its value is <code>err1::e1</code>.</p>
</li>
<li>
<p>Otherwise the second error handler will be called if an error object of type <code>err1</code> is available, regardless of its value.</p>
</li>
<li>
<p>Otherwise <code>leaf::try_handle_some</code> fails.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If we want to ensure that all possible failures are handled, we use <code>leaf::try_handle_all</code> instead of <code>leaf::try_handle_some</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">U</span> <span class="n">r</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_all</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">f1</span><span class="p">());</span>
    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">f2</span><span class="p">());</span>

    <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span> <span class="n">v2</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">err1</span><span class="p">,</span> <span class="n">err1</span><span class="o">::</span><span class="n">e1</span><span class="o">&gt;</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span>
  <span class="p">{</span>
    <span class="c1">// Handle err::e1</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">err1</span> <span class="n">e</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">U</span>
  <span class="p">{</span>
    <span class="c1">// Handle any other err1 value</span>
  <span class="p">},</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">U</span>
  <span class="p">{</span>
    <span class="c1">// Handle any other failure</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_all"><code>try_handle_all</code></a></p>
</div>
<div class="paragraph">
<p>The <code>leaf::try_handle_all</code> function enforces at compile time that at least one of the supplied error handlers takes no arguments (and therefore is able to handle any failure). In addition, all error handlers are forced to return a valid <code>U</code>, rather than a <code>leaf::result&lt;U&gt;</code>, so that <code>leaf::try_handle_all</code> is guaranteed to succeed, always.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_working_with_different_error_types">Working with Different Error Types</h3>
<div class="paragraph">
<p>It is of course possible to provide different handlers for different error types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">err1</span> <span class="p">{</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">err2</span> <span class="p">{</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="p">};</span>

<span class="p">....</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">f1</span><span class="p">());</span>
    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">f2</span><span class="p">());</span>

    <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">err1</span> <span class="n">e</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="c1">// Handle errors of type `err1`.</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">err2</span> <span class="n">e</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="c1">// Handle errors of type `err2`.</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#result"><code>result</code></a> | <a href="#BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></a></p>
</div>
<div class="paragraph">
<p>In this case, because we have supplied handlers for <code>err1</code> and for <code>err2</code>, <code>try_handle_some</code> knows to allocate storage on the stack for error objects of both types.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_working_with_multiple_error_objects">Working with Multiple Error Objects</h3>
<div class="paragraph">
<p>It is possible for an error handler to require more than one error object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">err1</span> <span class="p">{</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">err2</span> <span class="p">{</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="p">};</span>

<span class="p">....</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">f1</span><span class="p">());</span>
    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">f2</span><span class="p">());</span>

    <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">err1</span> <span class="n">e1</span><span class="p">,</span> <span class="n">err2</span> <span class="n">e2</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="c1">// Handle failures which communicate both an err1 and an err2 object.</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#result"><code>result</code></a> | <a href="#BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></a></p>
</div>
<div class="paragraph">
<p>Naturally, <code>leaf::new_error</code> can be invoked with multiple error objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="p">....</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">error_detected</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span><span class="n">err1</span><span class="o">::</span><span class="n">e1</span><span class="p">,</span> <span class="n">err2</span><span class="o">::</span><span class="n">e2</span><span class="p">);</span>

  <span class="c1">// Produce and return a T.</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#new_error"><code>new_error</code></a></p>
</div>
<div class="paragraph">
<p>As well, <code>leaf::on_error</code> can be used to automatically associate additional error objects with any failure that is "in flight":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">io_error</span> <span class="p">{</span> <span class="n">open_error</span><span class="p">,</span> <span class="n">read_error</span><span class="p">,</span> <span class="n">write_error</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">parse_error</span> <span class="p">{</span> <span class="n">bad_syntax</span><span class="p">,</span> <span class="n">bad_range</span> <span class="p">};</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parse_line</span><span class="p">(</span> <span class="kt">FILE</span> <span class="o">*</span> <span class="n">f</span> <span class="p">);</span>

<span class="k">struct</span> <span class="nc">e_line</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">process_file</span><span class="p">(</span> <span class="kt">FILE</span> <span class="o">*</span> <span class="n">f</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">current_line</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">current_line</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">current_line</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">auto</span> <span class="n">load</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">on_error</span><span class="p">(</span> <span class="n">e_line</span><span class="p">{</span> <span class="n">current_line</span> <span class="p">}</span> <span class="p">);</span>

    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">parse_line</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>

    <span class="c1">// use v</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#on_error"><code>on_error</code></a> | <a href="#BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></a></p>
</div>
<div class="paragraph">
<p>Presumably, <code>parse_line</code> could fail with an <code>io_error</code> or with a <code>parse_error</code>, but <code>process_file</code> does not handle errors, so it remains neutral to failures, except to attach the <code>current_line</code> if something goes wrong. The object returned by <code>on_error</code> holds a copy of the <code>current_line</code> wrapped in <code>struct e_line</code>. If <code>parse_line</code> succeeds, the <code>e_line</code> object is simply discarded; but if it fails, the <code>e_line</code> object will be automatically attached to the failure.</p>
</div>
<div class="paragraph">
<p>Such failures can then be handled like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">BOOST_LEAF_CHECK</span><span class="p">(</span> <span class="n">process_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">);</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">parse_error</span> <span class="n">e</span><span class="p">,</span> <span class="n">e_line</span> <span class="n">current_line</span>  <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Parse error at line "</span> <span class="o">&lt;&lt;</span> <span class="n">current_line</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">io_error</span> <span class="n">e</span><span class="p">,</span> <span class="n">e_line</span> <span class="n">current_line</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"I/O error at line "</span> <span class="o">&lt;&lt;</span> <span class="n">current_line</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">io_error</span> <span class="n">e</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"I/O error"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#BOOST_LEAF_CHECK"><code>BOOST_LEAF_CHECK</code></a></p>
</div>
<div class="paragraph">
<p>Remember, error handlers are considered in order, so the last one will be called if we get an <code>io_error</code> but no <code>e_line</code> was communicated to LEAF. Alternatively, we can provide a single <code>io_error</code> handler that takes <code>current_line</code> as a pointer-to-const:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">BOOST_LEAF_CHECK</span><span class="p">(</span> <span class="n">process_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">);</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">parse_error</span> <span class="n">e</span><span class="p">,</span> <span class="n">e_line</span> <span class="n">current_line</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Parse error at line "</span> <span class="o">&lt;&lt;</span> <span class="n">current_line</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">io_error</span> <span class="n">e</span><span class="p">,</span> <span class="n">e_line</span> <span class="k">const</span> <span class="o">*</span> <span class="n">current_line</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Parse error"</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">current_line</span> <span class="p">)</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">" at line "</span> <span class="o">&lt;&lt;</span> <span class="n">current_line</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In essence, now the <code>e_line</code> argument is optional, LEAF will provide it if it is available, otherwise pass a null pointer.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-eh">Exception Handling</h3>
<div class="paragraph">
<p>What happens if an operation throws an exception? Not to worry, both <code>leaf::try_handle_some</code> and <code>leaf::try_handle_all</code> catch exceptions and are able to pass them to any compatible error handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">BOOST_LEAF_CHECK</span><span class="p">(</span> <span class="n">process_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">);</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Out of memory!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">parse_error</span> <span class="n">e</span><span class="p">,</span> <span class="n">e_line</span> <span class="n">l</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Parse error at line "</span> <span class="o">&lt;&lt;</span> <span class="n">l</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">io_error</span> <span class="n">e</span><span class="p">,</span> <span class="n">e_line</span> <span class="k">const</span> <span class="o">*</span> <span class="n">l</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Parse error"</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">l</span> <span class="p">)</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">" at line "</span> <span class="o">&lt;&lt;</span> <span class="n">l</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#result"><code>result</code></a> | <a href="#BOOST_LEAF_CHECK"><code>BOOST_LEAF_CHECK</code></a></p>
</div>
<div class="paragraph">
<p>Above, we have simply added an error handler that takes a <code>std::bad_alloc</code>, and everything "just works" as expected: LEAF will dispatch error handlers correctly no matter if failures are communicated via <code>leaf::result</code> or by an exception.</p>
</div>
<div class="paragraph">
<p>Of course, if we use exception handling exclusively, we do not need <code>leaf::result</code> at all. In this case we use <code>leaf::try_catch</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">try_catch</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="n">process_file</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Out of memory!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">parse_error</span> <span class="n">e</span><span class="p">,</span> <span class="n">e_line</span> <span class="n">l</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Parse error at line "</span> <span class="o">&lt;&lt;</span> <span class="n">l</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">io_error</span> <span class="n">e</span><span class="p">,</span> <span class="n">e_line</span> <span class="k">const</span> <span class="o">*</span> <span class="n">l</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Parse error"</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">l</span> <span class="p">)</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">" at line "</span> <span class="o">&lt;&lt;</span> <span class="n">l</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_catch"><code>try_catch</code></a></p>
</div>
<div class="paragraph">
<p>Remarkably, we did not have to change the error handlers! But how does this work? What kind of exceptions does <code>process_file</code> throw?</p>
</div>
<div class="paragraph">
<p>LEAF enables a novel technique of exception handling, which does not use exception type hierarchies to classify failures and does not carry data in exception objects. Recall that when failures are communicated via <code>leaf::result</code>, we call <code>leaf::new_error</code> in a <code>return</code> statement, passing any number of error objects which are sent directly to the correct error handling scope:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">err1</span> <span class="p">{</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">err2</span> <span class="p">{</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="p">};</span>

<span class="p">....</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="p">....</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">error_detected</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span><span class="n">err1</span><span class="o">::</span><span class="n">e1</span><span class="p">,</span> <span class="n">err2</span><span class="o">::</span><span class="n">e2</span><span class="p">);</span>

  <span class="c1">// Produce and return a T.</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#new_error"><code>new_error</code></a></p>
</div>
<div class="paragraph">
<p>When using exception handling this becomes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">err1</span> <span class="p">{</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">err2</span> <span class="p">{</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="p">};</span>

<span class="n">T</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">error_detected</span> <span class="p">)</span>
    <span class="k">throw</span> <span class="n">leaf</span><span class="o">::</span><span class="n">exception</span><span class="p">(</span><span class="n">err1</span><span class="o">::</span><span class="n">e1</span><span class="p">,</span> <span class="n">err2</span><span class="o">::</span><span class="n">e2</span><span class="p">);</span>

  <span class="c1">// Produce and return a T.</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#exception"><code>exception</code></a></p>
</div>
<div class="paragraph">
<p>The <code>leaf::exception</code> function handles the passed error objects just like <code>leaf::new_error</code> does, and then returns an object of a type that derives from <code>std::exception</code> (which the caller throws). Using this technique, the exception type is not important: <code>leaf::try_catch</code> catches all exceptions, then goes through the usual LEAF error handler selection machinery.</p>
</div>
<div class="paragraph">
<p>If instead we want to use the legacy convention of throwing different types to indicate different failures, we simply pass an exception object (that is, an object of a type that derives from <code>std::exception</code>) as the first argument to <code>leaf::exception</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">throw</span> <span class="n">leaf</span><span class="o">::</span><span class="n">exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Error!"</span><span class="p">),</span> <span class="n">err1</span><span class="o">::</span><span class="n">e1</span><span class="p">,</span> <span class="n">err2</span><span class="o">::</span><span class="n">e2</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the returned object will be of type that derives from <code>std::runtime_error</code>, rather than from <code>std::exception</code>.</p>
</div>
<div class="paragraph">
<p>Finally, <code>leaf::on_error</code> "just works" as well. Here is our <code>process_file</code> function rewritten to throw on error, rather than return a <code>leaf::result</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">io_error</span> <span class="p">{</span> <span class="n">open_error</span><span class="p">,</span> <span class="n">read_error</span><span class="p">,</span> <span class="n">write_error</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">parse_error</span> <span class="p">{</span> <span class="n">bad_syntax</span><span class="p">,</span> <span class="n">bad_range</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">parse_line</span><span class="p">(</span> <span class="kt">FILE</span> <span class="o">*</span> <span class="n">f</span> <span class="p">);</span> <span class="c1">// Throws</span>

<span class="k">struct</span> <span class="nc">e_line</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>

<span class="kt">void</span> <span class="nf">process_file</span><span class="p">(</span> <span class="kt">FILE</span> <span class="o">*</span> <span class="n">f</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">current_line</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">current_line</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">current_line</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">auto</span> <span class="n">load</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">on_error</span><span class="p">(</span> <span class="n">e_line</span><span class="p">{</span> <span class="n">current_line</span> <span class="p">}</span> <span class="p">);</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">parse_line</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

    <span class="c1">// use v</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#on_error"><code>on_error</code></a></p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="_using_external_result_types">Using External <code>result</code> Types</h3>
<div class="paragraph">
<p>Static type checking creates difficulties in error handling interoperability in any non-trivial project. Using exception handling alleviates this problem somewhat because in that case error types are not burned into function signatures, so errors easily punch through multiple layers of APIs; but this doesn&#8217;t help C&#43;&#43; in general because the community is fractured on the issue of exception handling. Regardless of any arguments, the reality is that C&#43;&#43; programs need to be able to handle errors communicated through multiple layers of APIs via a plethora of error codes, <code>result</code> types and exceptions.</p>
</div>
<div class="paragraph">
<p>LEAF enables application developers to shake error objects out of each individual library&#8217;s <code>result</code> type and send them to error handling scopes verbatim. Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">lib1</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">lib1</span><span class="o">::</span><span class="n">error_code</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">();</span>
<span class="n">lib2</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">lib2</span><span class="o">::</span><span class="n">error_code</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">g</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="p">);</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>
  <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">a</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">error</span><span class="p">()</span> <span class="p">);</span>

  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">bar</span><span class="p">();</span>
  <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">b</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span> <span class="n">b</span><span class="p">.</span><span class="n">error</span><span class="p">()</span> <span class="p">);</span>

  <span class="k">return</span> <span class="n">g</span><span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">value</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#new_error"><code>new_error</code></a></p>
</div>
<div class="paragraph">
<p>Later we simply call <code>leaf::try_handle_some</code> passing an error handler for each type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">lib1</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="c1">// Handle lib1::error_code</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">lib2</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="c1">// Handle lib2::error_code</span>
  <span class="p">}</span> <span class="p">);</span>
<span class="err">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#result"><code>result</code></a></p>
</div>
<div class="paragraph">
<p>A possible complication is that we might not have the option to return <code>leaf::result&lt;int&gt;</code> from <code>f</code>: a third party API may impose a specific signature on it, forcing it to return a library-specific <code>result</code> type. This would be the case when <code>f</code> is intended to be used as a callback:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="kt">void</span> <span class="nf">register_callback</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">lib3</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">callback</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Can we use LEAF in this case? Actually we can, as long as <code>lib3::result</code> is able to communicate a <code>std::error_code</code>. We just have to let LEAF know, by specializing the <code>is_result_type</code> template:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">is_result_type</span><span class="o">&lt;</span><span class="n">lib3</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#is_result_type"><code>is_result_type</code></a></p>
</div>
<div class="paragraph">
<p>With this in place, <code>f</code> works as before, even though <code>lib3::result</code> isn&#8217;t capable of transporting <code>lib1</code> errors or <code>lib2</code> errors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">lib1</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">lib1</span><span class="o">::</span><span class="n">error_type</span><span class="o">&gt;</span> <span class="n">foo</span><span class="p">();</span>
<span class="n">lib2</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">lib2</span><span class="o">::</span><span class="n">error_type</span><span class="o">&gt;</span> <span class="n">bar</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">g</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="p">);</span>

<span class="n">lib3</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>
  <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">a</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">error</span><span class="p">()</span> <span class="p">);</span>

  <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">bar</span><span class="p">();</span>
  <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">b</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span> <span class="n">b</span><span class="p">.</span><span class="n">error</span><span class="p">()</span> <span class="p">);</span>

  <span class="k">return</span> <span class="n">g</span><span class="p">(</span> <span class="n">a</span><span class="p">.</span><span class="n">value</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#new_error"><code>new_error</code></a></p>
</div>
<div class="paragraph">
<p>The object returned by <code>leaf::new_error</code> converts implicitly to <code>std::error_code</code>, using a LEAF-specific <code>error_category</code>, which makes <code>lib3::result</code> compatible with <code>leaf::try_handle_some</code> (and with <code>leaf::try_handle_all</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">lib3</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">lib3</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">lib1</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">lib3</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="c1">// Handle lib1::error_code</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">lib2</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">lib3</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="c1">// Handle lib2::error_code</span>
  <span class="p">}</span> <span class="p">);</span>
<span class="err">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_some"><code>try_handle_some</code></a></p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-model">Error Communication Model</h3>
<div class="sect3">
<h4 id="_noexcept_api"><code>noexcept</code> API</h4>
<div class="paragraph">
<p>The following figure illustrates how error objects are transported when using LEAF without exception handling:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="LEAF-1.png" alt="LEAF 1">
</div>
<div class="title">Figure 1. LEAF noexcept Error Communication Model</div>
</div>
<div class="paragraph">
<p>The arrows pointing down indicate the call stack order for the functions <code>f1</code> through <code>f5</code>: higher level functions calling lower level functions.</p>
</div>
<div class="paragraph">
<p>Note the call to <code>on_error</code> in <code>f3</code>: it caches the passed error objects of types <code>E1</code> and <code>E3</code> in the returned object <code>load</code>, where they stay ready to be communicated in case any function downstream from <code>f3</code> reports an error. Presumably these objects are relevant to any such failure, but are conveniently accessible only in this scope.</p>
</div>
<div class="paragraph">
<p><em>Figure 1</em> depicts the condition where <code>f5</code> has detected an error. It calls <code>leaf::new_error</code> to create a new, unique <code>error_id</code>. The passed error object of type <code>E2</code> is immediately loaded in the first active <code>context</code> object that provides static storage for it, found in any calling scope (in this case <code>f1</code>), and is associated with the newly-generated <code>error_id</code> (solid arrow);</p>
</div>
<div class="paragraph">
<p>The <code>error_id</code> itself is returned to the immediate caller <code>f4</code>, usually stored in a <code>result&lt;T&gt;</code> object <code>r</code>. That object takes the path shown by dashed arrows, as each error neutral function, unable to handle the failure, forwards it to its immediate caller in the returned value&#8201;&#8212;&#8201;until an error handling scope is reached.</p>
</div>
<div class="paragraph">
<p>When the destructor of the <code>load</code> object in <code>f3</code> executes, it detects that <code>new_error</code> was invoked after its initialization, loads the cached objects of types <code>E1</code> and <code>E3</code> in the first active <code>context</code> object that provides static storage for them, found in any calling scope (in this case <code>f1</code>), and associates them with the last generated <code>error_id</code> (solid arrow).</p>
</div>
<div class="paragraph">
<p>When the error handling scope <code>f1</code> is reached, it probes <code>ctx</code> for any error objects associated with the <code>error_id</code> it received from <code>f2</code>, and processes a list of user-provided error handlers, in order, until it finds a handler with arguments that can be supplied using the available (in <code>ctx</code>) error objects. That handler is called to deal with the failure.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exception_handling_api">Exception Handling API</h4>
<div class="paragraph">
<p>The following figure illustrates the slightly different error communication model used when errors are reported by throwing exceptions:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="LEAF-2.png" alt="LEAF 2">
</div>
<div class="title">Figure 2. LEAF Error Communication Model Using Exception Handling</div>
</div>
<div class="paragraph">
<p>The main difference is that the call to <code>new_error</code> is implicit in the call to the function template <code>leaf::exception</code>, which in this case takes an exception object of type <code>Ex</code>, and returns an exception object of unspecified type that derives publicly from <code>Ex</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="tutorial-interoperability">Interoperability</h4>
<div class="paragraph">
<p>Ideally, when an error is detected, a program using LEAF would always call <a href="#new_error"><code>new_error</code></a>, ensuring that each encountered failure is definitely assigned a unique <a href="#error_id"><code>error_id</code></a>, which then is reliably delivered, by an exception or by a <code>result&lt;T&gt;</code> object, to the appropriate error handling scope.</p>
</div>
<div class="paragraph">
<p>Alas, this is not always possible.</p>
</div>
<div class="paragraph">
<p>For example, the error may need to be communicated through uncooperative 3rd-party interfaces. To facilitate this transmission, a error ID may be encoded in a <code>std::error_code</code>. As long as a 3rd-party interface is able to transport a <code>std::error_code</code>, it should be compatible with LEAF.</p>
</div>
<div class="paragraph">
<p>Further, it is sometimes necessary to communicate errors through an interface that does not even use <code>std::error_code</code>. An example of this is when an external lower-level library throws an exception, which is unlikely to be able to carry an <code>error_id</code>.</p>
</div>
<div class="paragraph">
<p>To support this tricky use case, LEAF provides the function <a href="#current_error"><code>current_error</code></a>, which returns the error ID returned by the most recent call (from this thread) to <a href="#new_error"><code>new_error</code></a>. One possible approach to solving the problem is to use the following logic (implemented by the <a href="#error_monitor"><code>error_monitor</code></a> type):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Before calling the uncooperative API, call <a href="#current_error"><code>current_error</code></a> and cache the returned value.</p>
</li>
<li>
<p>Call the API, then call <code>current_error</code> again:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>If this returns the same value as before, pass the error objects to <code>new_error</code> to associate them with a new <code>error_id</code>;</p>
</li>
<li>
<p>else, associate the error objects with the <code>error_id</code> value returned by the second call to <code>current_error</code>.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that if the above logic is nested (e.g. one function calling another), <code>new_error</code> will be called only by the inner-most function, because that call guarantees that all calling functions will hit the <code>else</code> branch.</p>
</div>
<div class="paragraph">
<p>For a detailed tutorial see <a href="#tutorial-on_error_in_c_callbacks">Using <code>error_monitor</code> to Report Arbitrary Errors from C-callbacks</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
To avoid ambiguities, whenever possible, use the <a href="#exception"><code>exception</code></a> function template when throwing exceptions to ensure that the exception object transports a unique <code>error_id</code>; better yet, use the <a href="#BOOST_LEAF_THROW_EXCEPTION"><code>BOOST_LEAF_THROW_EXCEPTION</code></a> macro, which in addition will capture <code>__FILE__</code> and <code>__LINE__</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="tutorial-loading">Loading of Error Objects</h3>
<div class="paragraph">
<p>To load an error object is to move it into an active <a href="#context"><code>context</code></a>, usually local to a <a href="#try_handle_some"><code>try_handle_some</code></a>, a <a href="#try_handle_all"><code>try_handle_all</code></a> or a <a href="#try_catch"><code>try_catch</code></a> scope in the calling thread, where it becomes uniquely associated with a specific <a href="#error_id"><code>error_id</code></a>&#8201;&#8212;&#8201;or discarded if storage is not available.</p>
</div>
<div class="paragraph">
<p>Various LEAF functions take a list of error objects to load. As an example, if a function <code>copy_file</code> that takes the name of the input file and the name of the output file as its arguments detects a failure, it could communicate an error code <code>ec</code>, plus the two relevant file names using <a href="#new_error"><code>new_error</code></a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="n">e_input_name</span><span class="p">{</span><span class="n">n1</span><span class="p">},</span> <span class="n">e_output_name</span><span class="p">{</span><span class="n">n2</span><span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, error objects may be loaded using a <code>result&lt;T&gt;</code> that is already communicating an error. This way they become associated with that error, rather than with a new error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">fn</span> <span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span> <span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">....;</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">load</span><span class="p">(</span> <span class="n">e_file_name</span><span class="p">{</span><span class="n">fn</span><span class="p">}</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#result::load"><code>load</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Success! Use <code>r.value()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>f()</code> has failed; here we associate an additional <code>e_file_name</code> with the error. However, this association occurs iff in the call stack leading to <code>g</code> there are error handlers that take an <code>e_file_name</code> argument. Otherwise, the object passed to <code>load</code> is discarded. In other words, the passed objects are loaded iff the program actually uses them to handle errors.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Besides error objects, <code>load</code> can take function arguments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If we pass a function that takes no arguments, it is invoked, and the returned error object is loaded.</p>
<div class="paragraph">
<p>Consider that if we pass to <code>load</code> an error object that is not needed by any error handler, it will be discarded. If the object is expensive to compute, it would be better if the computation can be skipped as well. Passing a function with no arguments to <code>load</code> is an excellent way to achieve this behavior:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">struct</span> <span class="nc">info</span> <span class="p">{</span> <span class="p">....</span> <span class="p">};</span>

<span class="n">info</span> <span class="n">compute_info</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">operation</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">file_name</span> <span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">try_something</span><span class="p">()</span> <span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">....</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">load</span><span class="p">(</span> <i class="conum" data-value="2"></i><b>(2)</b>
      <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span>
      <span class="p">{</span>
        <span class="k">return</span> <span class="n">compute_info</span><span class="p">();</span>
      <span class="p">}</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#result::load"><code>load</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Success! Use <code>r.value()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>try_something</code> has failed; <code>compute_info</code> will only be called if an error handler exists which takes a <code>info</code> argument.</td>
</tr>
</table>
</div>
</li>
<li>
<p>If we pass a function that takes a single argument of type <code>E &amp;</code>, LEAF calls the function with the object of type <code>E</code> currently loaded in an active <code>context</code>, associated with the error. If no such object is available, a new one is default-initialized and then passed to the function.</p>
<div class="paragraph">
<p>For example, if an operation that involves many different files fails, a program may provide for collecting all relevant file names in a <code>e_relevant_file_names</code> object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">struct</span> <span class="nc">e_relevant_file_names</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">operation</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">file_name</span> <span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">try_something</span><span class="p">()</span> <span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">....</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">load</span><span class="p">(</span> <i class="conum" data-value="2"></i><b>(2)</b>
      <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">e_relevant_file_names</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">e</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">file_name</span><span class="p">);</span>
      <span class="p">}</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#result::load"><code>load</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Success! Use <code>r.value()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>try_something</code> has failed&#8201;&#8212;&#8201;add <code>file_name</code> to the <code>e_relevant_file_names</code> object, associated with the <code>error_id</code> communicated in <code>r</code>. Note, however, that the passed function will only be called iff in the call stack there are error handlers that take an <code>e_relevant_file_names</code> object.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-on_error">Using <code>on_error</code></h3>
<div class="paragraph">
<p>It is not typical for an error reporting function to be able to supply all of the data needed by a suitable error handling function in order to recover from the failure. For example, a function that reports <code>FILE</code> failures may not have access to the file name, yet an error handling function needs it in order to print a useful error message.</p>
</div>
<div class="paragraph">
<p>Of course the file name is typically readily available in the call stack leading to the failed <code>FILE</code> operation. Below, while <code>parse_info</code> can&#8217;t report the file name, <code>parse_file</code> can and does:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">info</span><span class="o">&gt;</span> <span class="n">parse_info</span><span class="p">(</span> <span class="kt">FILE</span> <span class="o">*</span> <span class="n">f</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">info</span><span class="o">&gt;</span> <span class="n">parse_file</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">file_name</span> <span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">load</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">on_error</span><span class="p">(</span><span class="n">leaf</span><span class="o">::</span><span class="n">e_file_name</span><span class="p">{</span><span class="n">file_name</span><span class="p">});</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="k">if</span><span class="p">(</span> <span class="kt">FILE</span> <span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="s">"r"</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">parse_info</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span> <span class="n">error_enum</span><span class="o">::</span><span class="n">file_open_error</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#on_error"><code>on_error</code></a> | <a href="#new_error"><code>new_error</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>parse_info</code> parses <code>f</code>, communicating errors using <code>result&lt;info&gt;</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using <code>on_error</code> ensures that the file name is included with any error reported out of <code>parse_file</code>. All we need to do is hold on to the returned object <code>load</code>; when it expires, if an error is being reported, the passed <code>e_file_name</code> value will be automatically associated with it.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>on_error</code>&#8201;&#8212;&#8201; like <code>load</code>&#8201;&#8212;&#8201;can be passed any number of arguments.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When we invoke <code>on_error</code>, we can pass three kinds of arguments:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Actual error objects (like in the example above);</p>
</li>
<li>
<p>Functions that take no arguments and return an error object;</p>
</li>
<li>
<p>Functions that take an error object by mutable reference.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If we want to use <code>on_error</code> to capture <code>errno</code>, we can&#8217;t just pass <a href="#e_errno"><code>e_errno</code></a> to it, because at that time it hasn&#8217;t been set (yet). Instead, we&#8217;d pass a function that returns it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="kt">void</span> <span class="nf">read_file</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">auto</span> <span class="n">load</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">on_error</span><span class="p">([]{</span> <span class="k">return</span> <span class="n">e_errno</span><span class="p">{</span><span class="n">errno</span><span class="p">};</span> <span class="p">});</span>

  <span class="p">....</span>
  <span class="kt">size_t</span> <span class="n">nr1</span><span class="o">=</span><span class="n">fread</span><span class="p">(</span><span class="n">buf1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">count1</span><span class="p">,</span><span class="n">f</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">ferror</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">throw</span> <span class="n">leaf</span><span class="o">::</span><span class="n">exception</span><span class="p">();</span>

  <span class="kt">size_t</span> <span class="n">nr2</span><span class="o">=</span><span class="n">fread</span><span class="p">(</span><span class="n">buf2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">count2</span><span class="p">,</span><span class="n">f</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">ferror</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">throw</span> <span class="n">leaf</span><span class="o">::</span><span class="n">exception</span><span class="p">();</span>

  <span class="kt">size_t</span> <span class="n">nr3</span><span class="o">=</span><span class="n">fread</span><span class="p">(</span><span class="n">buf3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">count3</span><span class="p">,</span><span class="n">f</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">ferror</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">throw</span> <span class="n">leaf</span><span class="o">::</span><span class="n">exception</span><span class="p">();</span>
  <span class="p">....</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Above, if a <code>throw</code> statement is reached, LEAF will invoke the function passed to <code>on_error</code> and associate the returned <code>e_errno</code> object with the exception.</p>
</div>
<div class="paragraph">
<p>The final argument type that can be passed to <code>on_error</code> is a function that takes a single mutable error object reference. In this case, <code>on_error</code> uses it similarly to how such functions are used by <code>load</code>; see <a href="#tutorial-loading">Loading of Error Objects</a>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-predicates">Using Predicates to Handle Errors</h3>
<div class="paragraph">
<p>Usually, LEAF error handlers are selected based on the type of the arguments they take and the type of the available error objects. When an error handler takes a predicate type as an argument, the <a href="#handler_selection_procedure">handler selection procedure</a> is able to also take into account the <em>value</em> of the available error objects.</p>
</div>
<div class="paragraph">
<p>Consider this error code enum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">my_error</span>
<span class="p">{</span>
  <span class="n">e1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
  <span class="n">e2</span><span class="p">,</span>
  <span class="n">e3</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We could handle <code>my_error</code> errors like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">my_error</span> <span class="n">e</span> <span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">switch</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">case</span> <span class="n">my_error</span><span class="o">::</span><span class="n">e1</span><span class="p">:</span>
        <span class="p">....;</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="n">my_error</span><span class="o">::</span><span class="n">e2</span><span class="p">:</span>
      <span class="k">case</span> <span class="n">my_error</span><span class="o">::</span><span class="n">e3</span><span class="p">:</span>
        <span class="p">....;</span> <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="k">break</span><span class="p">;</span>
      <span class="nl">default:</span>
        <span class="p">....;</span> <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler will be selected if we&#8217;ve got a <code>my_error</code> object.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Handle <code>e1</code> errors.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Handle <code>e2</code> and <code>e3</code> errors.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Handle bad <code>my_error</code> values.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code>my_error</code> object is available, LEAF will call our error handler. If not, the failure will be forwarded to our caller.</p>
</div>
<div class="paragraph">
<p>This can be rewritten using the <a href="#match"><code>match</code></a> predicate to organize the different cases in different error handlers. The following is equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">my_error</span><span class="p">,</span> <span class="n">my_error</span><span class="o">::</span><span class="n">e1</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">assert</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span> <span class="o">==</span> <span class="n">my_error</span><span class="o">::</span><span class="n">e1</span><span class="p">);</span>
    <span class="p">....;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">my_error</span><span class="p">,</span> <span class="n">my_error</span><span class="o">::</span><span class="n">e2</span><span class="p">,</span> <span class="n">my_error</span><span class="o">::</span><span class="n">e3</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">assert</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span> <span class="o">==</span> <span class="n">my_error</span><span class="o">::</span><span class="n">e2</span> <span class="o">||</span> <span class="n">m</span><span class="p">.</span><span class="n">matched</span> <span class="o">==</span> <span class="n">my_error</span><span class="o">::</span><span class="n">e3</span><span class="p">);</span>
    <span class="p">....;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">my_error</span> <span class="n">e</span> <span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="p">....;</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We&#8217;ve got a <code>my_error</code> object that compares equal to <code>e1</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We`ve got a <code>my_error</code> object that compares equal to either <code>e2</code> or <code>e3</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Handle bad <code>my_error</code> values.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The first argument to the <code>match</code> template generally specifies the type <code>E</code> of the error object <code>e</code> that must be available for the error handler to be considered at all. Typically, the rest of the arguments are values. The error handler is dropped if <code>e</code> does not compare equal to any of them.</p>
</div>
<div class="paragraph">
<p>In particular, <code>match</code> works great with <code>std::error_code</code>. The following handler is designed to handle <code>ENOENT</code> errors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">errc</span><span class="o">::</span><span class="n">no_such_file_or_directory</span><span class="o">&gt;</span> <span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This, however, requires C&#43;&#43;17 or newer, because it is impossible to infer the type of the error enum (in this case, <code>std::errc</code>) from the specified type <code>std::error_code</code>, and C&#43;&#43;11 does not allow <code>auto</code> template arguments. LEAF provides the following workaround, compatible with C&#43;&#43;11:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">leaf</span><span class="o">::</span><span class="n">condition</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">errc</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">errc</span><span class="o">::</span><span class="n">no_such_file_or_directory</span><span class="o">&gt;</span> <span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, it is possible to select a handler based on <code>std::error_category</code>. The following handler will match any <code>std::error_code</code> of the <code>std::generic_category</code> (requires C&#43;&#43;17 or newer):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="p">[](</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="p">,</span> <span class="n">leaf</span><span class="o">::</span><span class="n">category</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">errc</span><span class="o">&gt;&gt;</span> <span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See <a href="#match"><code>match</code></a> for more examples.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following predicates are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#match"><code>match</code></a>: as described above.</p>
</li>
<li>
<p><a href="#match_value"><code>match_value</code></a>: where <code>match&lt;E, V&#8230;&#8203;&gt;</code> compares the object <code>e</code> of type <code>E</code> with the values <code>V&#8230;&#8203;</code>, <code>match_value&lt;E, V&#8230;&#8203;&gt;</code> compare <code>e.value</code> with the values <code>V&#8230;&#8203;</code>.</p>
</li>
<li>
<p><a href="#match_member"><code>match_member</code></a>: similar to <code>match_value</code>, but takes a pointer to the data member to compare; that is, <code>match_member&lt;&amp;E::value, V&#8230;&#8203;&gt;</code> is equvialent to <code>match_value&lt;E, V&#8230;&#8203;&gt;</code>. Note, however, that <code>match_member</code> requires C&#43;&#43;17 or newer, while <code>match_value</code> does not.</p>
</li>
<li>
<p><code><a href="#catch_">catch_</a>&lt;Ex&#8230;&#8203;&gt;</code>: Similar to <code>match</code>, but checks whether the caught <code>std::exception</code> object can be <code>dynamic_cast</code> to any of the <code>Ex</code> types.</p>
</li>
<li>
<p><a href="#if_not"><code>if_not</code></a> is a special predicate that takes any other predicate <code>Pred</code> and requires that an error object of type <code>E</code> is available and that <code>Pred</code> evaluates to <code>false</code>. For example, <code>if_not&lt;match&lt;E, V&#8230;&#8203;&gt;&gt;</code> requires that an object <code>e</code> of type <code>E</code> is available, and that it does not compare equal to any of the specified <code>V&#8230;&#8203;</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, the predicate system is easily extensible, see <a href="#predicates">Predicates</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See also <a href="#tutorial-std_error_code">Working with <code>std::error_code</code>, <code>std::error_condition</code></a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-binding_handlers">Binding Error Handlers in a <code>std::tuple</code></h3>
<div class="paragraph">
<p>Consider this snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_all</span><span class="p">(</span>

  <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">my_error_enum</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">read_file_error_enum</span> <span class="n">y</span><span class="p">,</span> <span class="n">e_file_name</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">fn</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">},</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_all"><code>try_handle_all</code></a> | <a href="#e_file_name"><code>e_file_name</code></a></p>
</div>
<div class="paragraph">
<p>Looks pretty simple, but what if we need to attempt a different set of operations yet use the same handlers? We could repeat the same thing with a different function passed as <code>TryBlock</code> for <code>try_handle_all</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_all</span><span class="p">(</span>

  <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">g</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">my_error_enum</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">read_file_error_enum</span> <span class="n">y</span><span class="p">,</span> <span class="n">e_file_name</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">fn</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">},</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>That works, but it is better to bind our error handlers in a <code>std::tuple</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">auto</span> <span class="n">error_handlers</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span>

  <span class="p">[](</span><span class="n">my_error_enum</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">read_file_error_enum</span> <span class="n">y</span><span class="p">,</span> <span class="n">e_file_name</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">fn</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">},</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>error_handlers</code> tuple can later be used with any error handling function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_all</span><span class="p">(</span>

  <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span>
  <span class="p">{</span>
    <span class="c1">// Operations which may fail </span><i class="conum" data-value="1"></i><b>(1)</b>
  <span class="p">},</span>

  <span class="n">error_handlers</span> <span class="p">);</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_all</span><span class="p">(</span>

  <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span>
  <span class="p">{</span>
    <span class="c1">// Different operations which may fail </span><i class="conum" data-value="2"></i><b>(2)</b>
  <span class="p">},</span>

  <span class="n">error_handlers</span> <span class="p">);</span> <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_all"><code>try_handle_all</code></a> | <a href="#error_info"><code>error_info</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>One set of operations which may fail&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A different set of operations which may fail&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203; both using the same <code>error_handlers</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Error handling functions accept a <code>std::tuple</code> of error handlers in place of any error handler. The behavior is as if the tuple is unwrapped in-place.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-async">Transporting Error Objects Between Threads</h3>
<div class="paragraph">
<p>Error objects are stored on the stack in an instance of the <a href="#context"><code>context</code></a> class template in the scope of e.g. <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a> functions. When using concurrency, we need a mechanism to collect error objects in one thread, then use them to handle errors in another thread.</p>
</div>
<div class="paragraph">
<p>LEAF offers two interfaces for this purpose, one using <code>result&lt;T&gt;</code>, and another designed for programs that use exception handling.</p>
</div>
<div class="sect3">
<h4 id="tutorial-async_result">Using <code>result&lt;T&gt;</code></h4>
<div class="paragraph">
<p>Let&#8217;s assume we have a <code>task</code> that we want to launch asynchronously, which produces a <code>task_result</code> but could also fail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">task_result</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Because the task will run asynchronously, in case of a failure we need it to capture the relevant error objects but not handle errors. To this end, in the main thread we bind our error handlers in a <code>std::tuple</code>, which we will later use to handle errors from each completed asynchronous task (see <a href="#tutorial-binding_handlers">tutorial</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">auto</span> <span class="n">error_handlers</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span>

  <span class="p">[](</span><span class="n">E1</span> <span class="n">e1</span><span class="p">,</span> <span class="n">E2</span> <span class="n">e2</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//Deal with E1, E2</span>
    <span class="p">....</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">E3</span> <span class="n">e3</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//Deal with E3</span>
    <span class="p">....</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Why did we start with this step? Because we need to create a <a href="#context"><code>context</code></a> object to collect the error objects we need. We could just instantiate the <code>context</code> template with <code>E1</code>, <code>E2</code> and <code>E3</code>, but that would be prone to errors, since it could get out of sync with the handlers we use. Thankfully LEAF can deduce the types we need automatically, we just need to show it our <code>error_handlers</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">leaf</span><span class="o">::</span><span class="n">polymorphic_context</span><span class="o">&gt;</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">make_shared_context</span><span class="p">(</span><span class="n">error_handlers</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>polymorphic_context</code> type is an abstract base class that has the same members as any instance of the <code>context</code> class template, allowing us to erase its exact type. In this case what we&#8217;re holding in <code>ctx</code> is a <code>context&lt;E1, E2, E3&gt;</code>, where <code>E1</code>, <code>E2</code> and <code>E3</code> were deduced automatically from the <code>error_handlers</code> tuple we passed to <code>make_shared_context</code>.</p>
</div>
<div class="paragraph">
<p>We&#8217;re now ready to launch our asynchronous task:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">task_result</span><span class="o">&gt;&gt;</span> <span class="n">launch_task</span><span class="p">()</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span>
    <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">leaf</span><span class="o">::</span><span class="n">polymorphic_context</span><span class="o">&gt;</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">make_shared_context</span><span class="p">(</span><span class="n">error_handlers</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">capture</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="p">);</span>
    <span class="p">}</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#make_shared_context"><code>make_shared_context</code></a> | <a href="#capture"><code>capture</code></a></p>
</div>
<div class="paragraph">
<p>That&#8217;s it! Later when we <code>get</code> the <code>std::future</code>, we can process the returned <code>result&lt;task_result&gt;</code> in a call to <a href="#try_handle_some"><code>try_handle_some</code></a>, using the <code>error_handlers</code> tuple we created earlier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="c1">//std::future&lt;leaf::result&lt;task_result&gt;&gt; fut;</span>
<span class="n">fut</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>

<span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">fut</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
    <span class="c1">//Success!</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">}</span>
  <span class="p">},</span>

  <span class="n">error_handlers</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#result"><code>result</code></a> | <a href="#BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></a></p>
</div>
<div class="paragraph">
<p>The reason this works is that in case the <code>leaf::result&lt;T&gt;</code> communicates a failure, it is able to hold a <code>shared_ptr&lt;polymorphic_context&gt;</code> object. That is why earlier instead of calling <code>task()</code> directly, we called <code>leaf::capture</code>: it calls the passed function and, in case that fails, it stores the <code>shared_ptr&lt;polymorphic_context&gt;</code> we created in the returned <code>result&lt;T&gt;</code>, which now doesn&#8217;t just communicate the fact that an error has occurred, but also holds the <code>context</code> object that <code>try_handle_some</code> needs in order to supply a suitable handler with arguments.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Follow this link to see a complete example program: <a href="https://github.com/boostorg/leaf/blob/master/example/capture_in_result.cpp?ts=4">capture_in_result.cpp</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="tutorial-async_eh">Using Exception Handling</h4>
<div class="paragraph">
<p>Let&#8217;s assume we have an asynchronous <code>task</code> which produces a <code>task_result</code> but could also throw:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">task_result</span> <span class="nf">task</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Just like we saw in <a href="#tutorial-async_result">Using <code>result&lt;T&gt;</code></a>, first we will bind our error handlers in a <code>std::tuple</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">auto</span> <span class="n">handle_errors</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span>

  <span class="p">[](</span><span class="n">E1</span> <span class="n">e1</span><span class="p">,</span> <span class="n">E2</span> <span class="n">e2</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//Deal with E1, E2</span>
    <span class="p">....</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">E3</span> <span class="n">e3</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//Deal with E3</span>
    <span class="p">....</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Launching the task looks the same as before, except that we don&#8217;t use <code>result&lt;T&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">task_result</span><span class="o">&gt;</span> <span class="n">launch_task</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span>
    <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">leaf</span><span class="o">::</span><span class="n">polymorphic_context</span><span class="o">&gt;</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">make_shared_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle_error</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">capture</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">task</span><span class="p">);</span>
    <span class="p">}</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#make_shared_context"><code>make_shared_context</code></a> | <a href="#capture"><code>capture</code></a></p>
</div>
<div class="paragraph">
<p>That&#8217;s it! Later when we <code>get</code> the <code>std::future</code>, we can process the returned <code>task_result</code> in a call to <a href="#try_catch"><code>try_catch</code></a>, using the <code>error_handlers</code> we saved earlier, as if it was generated locally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="c1">//std::future&lt;task_result&gt; fut;</span>
<span class="n">fut</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>

<span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_catch</span><span class="p">(</span>

  <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span>
  <span class="p">{</span>
    <span class="n">task_result</span> <span class="n">r</span> <span class="o">=</span> <span class="n">fut</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="c1">// Throws on error</span>
    <span class="c1">//Success!</span>
  <span class="p">},</span>

  <span class="n">error_handlers</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_catch"><code>try_catch</code></a></p>
</div>
<div class="paragraph">
<p>This works similarly to using <code>result&lt;T&gt;</code>, except that the <code>std::shared_ptr&lt;polymorphic_context&gt;</code> is transported in an exception object (of unspecified type which <a href="#try_catch"><code>try_catch</code></a> recognizes and then automatically unwraps the original exception).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Follow this link to see a complete example program: <a href="https://github.com/boostorg/leaf/blob/master/example/capture_in_exception.cpp?ts=4">capture_in_exception.cpp</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="tutorial-classification">Classification of Failures</h3>
<div class="paragraph">
<p>It is common for an interface to define an <code>enum</code> that lists all possible error codes that the API reports. The benefit of this approach is that the list is complete and usually well documented:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="n">error_code</span>
<span class="p">{</span>
  <span class="p">....</span>
  <span class="n">read_error</span><span class="p">,</span>
  <span class="n">size_error</span><span class="p">,</span>
  <span class="n">eof_error</span><span class="p">,</span>
  <span class="p">....</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The disadvantage of such flat enums is that they do not support handling of a whole class of failures. Consider the following LEAF error handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="p">....</span>
<span class="p">[](</span><span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">error_code</span><span class="p">,</span> <span class="n">size_error</span><span class="p">,</span> <span class="n">read_error</span><span class="p">,</span> <span class="n">eof_error</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">leaf</span><span class="o">::</span><span class="n">e_file_name</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to access "</span> <span class="o">&lt;&lt;</span> <span class="n">fn</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">},</span>
<span class="p">....</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#match"><code>match</code></a> | <a href="#e_file_name"><code>e_file_name</code></a></p>
</div>
<div class="paragraph">
<p>It will get called if the value of the <code>error_code</code> enum communicated with the failure is one of <code>size_error</code>, <code>read_error</code> or <code>eof_error</code>. In short, the idea is to handle any input error.</p>
</div>
<div class="paragraph">
<p>But what if later we add support for detecting and reporting a new type of input error, e.g. <code>permissions_error</code>? It is easy to add that to our <code>error_code</code> enum; but now our input error handler won&#8217;t recognize this new input error&#8201;&#8212;&#8201;and we have a bug.</p>
</div>
<div class="paragraph">
<p>If we can use exceptions, the situation is better because exception types can be organized in a hierarchy in order to classify failures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">struct</span> <span class="nc">input_error</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">read_error</span><span class="o">:</span> <span class="n">input_error</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">size_error</span><span class="o">:</span> <span class="n">input_error</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">eof_error</span><span class="o">:</span> <span class="n">input_error</span> <span class="p">{</span> <span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In terms of LEAF, our input error exception handler now looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="p">[](</span><span class="n">input_error</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">leaf</span><span class="o">::</span><span class="n">e_file_name</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to access "</span> <span class="o">&lt;&lt;</span> <span class="n">fn</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">},</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This is future-proof, but still not ideal, because it is not possible to refine the classification of the failure after the exception object has been thrown.</p>
</div>
<div class="paragraph">
<p>LEAF supports a novel style of error handling where the classification of failures does not use error code values or exception type hierarchies. Instead of our <code>error_code</code> enum, we could define:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="p">....</span>
<span class="k">struct</span> <span class="nc">input_error</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">read_error</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">size_error</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">eof_error</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">....</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>With this in place, we could define a function <code>file_read</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">file_read</span><span class="p">(</span> <span class="kt">FILE</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span> <span class="n">ferror</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span><span class="n">input_error</span><span class="p">{},</span> <span class="n">read_error</span><span class="p">{},</span> <span class="n">leaf</span><span class="o">::</span><span class="n">e_errno</span><span class="p">{</span><span class="n">errno</span><span class="p">});</span> <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="k">if</span><span class="p">(</span> <span class="n">n</span><span class="o">!=</span><span class="n">size</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span><span class="n">input_error</span><span class="p">{},</span> <span class="n">eof_error</span><span class="p">{});</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#new_error"><code>new_error</code></a> | <a href="#e_errno"><code>e_errno</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This error is classified as <code>input_error</code> and <code>read_error</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This error is classified as <code>input_error</code> and <code>eof_error</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Or, even better:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">file_read</span><span class="p">(</span> <span class="kt">FILE</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">load</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">on_error</span><span class="p">(</span><span class="n">input_error</span><span class="p">{});</span> <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span> <span class="n">ferror</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span><span class="n">read_error</span><span class="p">{},</span> <span class="n">leaf</span><span class="o">::</span><span class="n">e_errno</span><span class="p">{</span><span class="n">errno</span><span class="p">});</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="k">if</span><span class="p">(</span> <span class="n">n</span><span class="o">!=</span><span class="n">size</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span><span class="n">eof_error</span><span class="p">{});</span> <i class="conum" data-value="3"></i><b>(3)</b>

  <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#on_error"><code>on_error</code></a> | <a href="#new_error"><code>new_error</code></a> | <a href="#e_errno"><code>e_errno</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Any error escaping this scope will be classified as <code>input_error</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In addition, this error is classified as <code>read_error</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>In addition, this error is classified as <code>eof_error</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This technique works just as well if we choose to use exception handling, we just call <code>leaf::exception</code> instead of <code>leaf::new_error</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="kt">void</span> <span class="nf">file_read</span><span class="p">(</span> <span class="kt">FILE</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">load</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">on_error</span><span class="p">(</span><span class="n">input_error</span><span class="p">{});</span>

  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span> <span class="n">ferror</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">throw</span> <span class="n">leaf</span><span class="o">::</span><span class="n">exception</span><span class="p">(</span><span class="n">read_error</span><span class="p">{},</span> <span class="n">leaf</span><span class="o">::</span><span class="n">e_errno</span><span class="p">{</span><span class="n">errno</span><span class="p">});</span>

  <span class="k">if</span><span class="p">(</span> <span class="n">n</span><span class="o">!=</span><span class="n">size</span> <span class="p">)</span>
    <span class="k">throw</span> <span class="n">leaf</span><span class="o">::</span><span class="n">exception</span><span class="p">(</span><span class="n">eof_error</span><span class="p">{});</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#on_error"><code>on_error</code></a> | <a href="#exception"><code>exception</code></a> | <a href="#e_errno"><code>e_errno</code></a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the type of the first argument passed to <code>leaf::exception</code> derives from <code>std::exception</code>, it will be used to initialize the returned exception object taken by <code>throw</code>. Here this is not the case, so the function returns a default-initialized <code>std::exception</code> object, while the first (and any other) argument is associated with the failure.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we can write a future-proof handler for any <code>input_error</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="p">....</span>
<span class="p">[](</span><span class="n">input_error</span><span class="p">,</span> <span class="n">leaf</span><span class="o">::</span><span class="n">e_file_name</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to access "</span> <span class="o">&lt;&lt;</span> <span class="n">fn</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">},</span>
<span class="p">....</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Remarkably, because the classification of the failure does not depend on error codes or on exception types, this error handler can be used with <code>try_catch</code> if we use exception handling, or with <code>try_handle_some</code>/<code>try_handle_all</code> if we do not.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-exception_to_result">Converting Exceptions to <code>result&lt;T&gt;</code></h3>
<div class="paragraph">
<p>It is sometimes necessary to catch exceptions thrown by a lower-level library function, and report the error through different means, to a higher-level library which may not use exception handling.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Error handlers that take arguments of types that derive from <code>std::exception</code> work correctly&#8201;&#8212;&#8201;regardless of whether the error object itself is thrown as an exception, or <a href="#tutorial-loading">loaded</a> into a <a href="#context"><code>context</code></a>. The technique described here is only needed when the exception must be communicated through functions which are not exception-safe, or are compiled with exception handling disabled.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Suppose we have an exception type hierarchy and a function <code>compute_answer_throws</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">class</span> <span class="nc">error_base</span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">error_a</span><span class="o">:</span> <span class="k">public</span> <span class="n">error_base</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">error_b</span><span class="o">:</span> <span class="k">public</span> <span class="n">error_base</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">error_c</span><span class="o">:</span> <span class="k">public</span> <span class="n">error_base</span> <span class="p">{</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">compute_answer_throws</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">switch</span><span class="p">(</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="mi">4</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="nl">default:</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="k">throw</span> <span class="n">error_a</span><span class="p">();</span>
    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="k">throw</span> <span class="n">error_b</span><span class="p">();</span>
    <span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="k">throw</span> <span class="n">error_c</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can write a simple wrapper using <code>exception_to_result</code>, which calls <code>compute_answer_throws</code> and switches to <code>result&lt;int&gt;</code> for error handling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">compute_answer</span><span class="p">()</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">exception_to_result</span><span class="o">&lt;</span><span class="n">error_a</span><span class="p">,</span> <span class="n">error_b</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="p">[]</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">compute_answer_throws</span><span class="p">();</span>
    <span class="p">}</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#exception_to_result"><code>exception_to_result</code></a></p>
</div>
<div class="paragraph">
<p>The <code>exception_to_result</code> template takes any number of exception types. All exception types thrown by the passed function are caught, and an attempt is made to convert the exception object to each of the specified types. Each successfully-converted slice of the caught exception object, as well as the return value of <code>std::current_exception</code>, are copied and <a href="#tutorial-loading">loaded</a>, and in the end the exception is converted to a <code><a href="#result">result</a>&lt;T&gt;</code> object.</p>
</div>
<div class="paragraph">
<p>(In our example, <code>error_a</code> and <code>error_b</code> slices as communicated as error objects, but <code>error_c</code> exceptions will still be captured by <code>std::exception_ptr</code>).</p>
</div>
<div class="paragraph">
<p>Here is a simple function which prints successfully computed answers, forwarding any error (originally reported by throwing an exception) to its caller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">print_answer</span><span class="p">()</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">compute_answer</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Answer: "</span> <span class="o">&lt;&lt;</span> <span class="n">answer</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></a></p>
</div>
<div class="paragraph">
<p>Finally, here is a scope that handles the errors&#8201;&#8212;&#8201;it will work correctly regardless of whether <code>error_a</code> and <code>error_b</code> objects are thrown as exceptions or not.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_all</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">BOOST_LEAF_CHECK</span><span class="p">(</span><span class="n">print_answer</span><span class="p">());</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">error_a</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Error A!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">error_b</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Error B!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Unknown error!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_all"><code>try_handle_all</code></a> | <a href="#result"><code>result</code></a> | <a href="#BOOST_LEAF_CHECK"><code>BOOST_LEAF_CHECK</code></a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The complete program illustrating this technique is available <a href="https://github.com/boostorg/leaf/blob/master/example/exception_to_result.cpp?ts=4">here</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-on_error_in_c_callbacks">Using <code>error_monitor</code> to Report Arbitrary Errors from C-callbacks</h3>
<div class="paragraph">
<p>Communicating information pertaining to a failure detected in a C callback is tricky, because C callbacks are limited to a specific static signature, which may not use C&#43;&#43; types.</p>
</div>
<div class="paragraph">
<p>LEAF makes this easy. As an example, we&#8217;ll write a program that uses Lua and reports a failure from a C&#43;&#43; function registered as a C callback, called from a Lua program. The failure will be propagated from C&#43;&#43;, through the Lua interpreter (written in C), back to the C&#43;&#43; function which called it.</p>
</div>
<div class="paragraph">
<p>C/C&#43;&#43; functions designed to be invoked from a Lua program must use the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c"><span class="kt">int</span> <span class="nf">do_work</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">L</span> <span class="p">)</span> <span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Arguments are passed on the Lua stack (which is accessible through <code>L</code>). Results too are pushed onto the Lua stack.</p>
</div>
<div class="paragraph">
<p>First, let&#8217;s initialize the Lua interpreter and register a function, <code>do_work</code>, as a C callback available for Lua programs to call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">lua_State</span><span class="o">&gt;</span> <span class="n">init_lua_state</span><span class="p">()</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">lua_State</span><span class="o">&gt;</span> <span class="n">L</span><span class="p">(</span><span class="n">lua_open</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">lua_close</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="n">lua_register</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">L</span><span class="p">,</span> <span class="s">"do_work"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">do_work</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="n">luaL_dostring</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">L</span><span class="p">,</span> <span class="s">"\ </span><span class="err"><i class="conum" data-value="3"></i><b>(3)</b>
</span><span class="se">\n</span><span class="s">      function call_do_work()\
</span><span class="se">\n</span><span class="s">          return do_work()\
</span><span class="se">\n</span><span class="s">      end"</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">L</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Create a new <code>lua_State</code>. We&#8217;ll use <code>std::shared_ptr</code> for automatic cleanup.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Register the <code>do_work</code> C&#43;&#43; function as a C callback, under the global name <code>do_work</code>. With this, calls from Lua programs to <code>do_work</code> will land in the <code>do_work</code> C&#43;&#43; function.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Pass some Lua code as a <code>C</code> string literal to Lua. This creates a global Lua function called <code>call_do_work</code>, which we will later ask Lua to execute.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next, let&#8217;s define our <code>enum</code> used to communicate <code>do_work</code> failures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="n">do_work_error_code</span>
<span class="p">{</span>
  <span class="n">ec1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
  <span class="n">ec2</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re now ready to define the <code>do_work</code> callback function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="kt">int</span> <span class="n">do_work</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">L</span> <span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">if</span><span class="p">(</span> <span class="n">success</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">lua_pushnumber</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span><span class="n">ec1</span><span class="p">);</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="k">return</span> <span class="n">luaL_error</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">"do_work_error"</span><span class="p">);</span> <i class="conum" data-value="4"></i><b>(4)</b>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#new_error"><code>new_error</code></a> | <a href="#error_id::load"><code>load</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>"Sometimes" <code>do_work</code> fails.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In case of success, push the result on the Lua stack, return back to Lua.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Generate a new <code>error_id</code> and associate a <code>do_work_error_code</code> with it. Normally, we&#8217;d return this in a <code>leaf::result&lt;T&gt;</code>, but the <code>do_work</code> function signature (required by Lua) does not permit this.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Tell the Lua interpreter to abort the Lua program.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now we&#8217;ll write the function that calls the Lua interpreter to execute the Lua function <code>call_do_work</code>, which in turn calls <code>do_work</code>. We&#8217;ll return <code><a href="#result">result</a>&lt;int&gt;</code>, so that our caller can get the answer in case of success, or an error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">call_lua</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">L</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">lua_getfield</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">LUA_GLOBALSINDEX</span><span class="p">,</span> <span class="s">"call_do_work"</span><span class="p">);</span>

  <span class="n">error_monitor</span> <span class="n">cur_err</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span> <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">lua_pcall</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="p">{</span>
    <span class="k">auto</span> <span class="n">load</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">on_error</span><span class="p">(</span><span class="n">e_lua_error_message</span><span class="p">{</span><span class="n">lua_tostring</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="mi">1</span><span class="p">)});</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="n">lua_pop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">cur_err</span><span class="p">.</span><span class="n">assigned_error_id</span><span class="p">().</span><span class="n">load</span><span class="p">(</span><span class="n">e_lua_pcall_error</span><span class="p">{</span><span class="n">err</span><span class="p">});</span> <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">lua_tonumber</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="n">lua_pop</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#on_error"><code>on_error</code></a> | <a href="#error_monitor"><code>error_monitor</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Ask the Lua interpreter to call the global Lua function <code>call_do_work</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>on_error</code> works as usual.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>load</code> will use the <code>error_id</code> generated in our Lua callback. This is the same <code>error_id</code> the <code>on_error</code> uses as well.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Success! Just return the <code>int</code> answer.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, here is the <code>main</code> function which exercises <code>call_lua</code>, each time handling any failure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">lua_State</span><span class="o">&gt;</span> <span class="n">L</span><span class="o">=</span><span class="n">init_lua_state</span><span class="p">();</span>

  <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">!=</span><span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_all</span><span class="p">(</span>

      <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
      <span class="p">{</span>
        <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">call_lua</span><span class="p">(</span><span class="o">&amp;*</span><span class="n">L</span><span class="p">));</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"do_work succeeded, answer="</span> <span class="o">&lt;&lt;</span> <span class="n">answer</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
      <span class="p">},</span>

      <span class="p">[](</span><span class="n">do_work_error_code</span> <span class="n">e</span><span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
      <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Got do_work_error_code = "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span>  <span class="s">"!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="p">},</span>

      <span class="p">[](</span><span class="n">e_lua_pcall_error</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">,</span> <span class="n">e_lua_error_message</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
      <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Got e_lua_pcall_error, Lua error code = "</span> <span class="o">&lt;&lt;</span> <span class="n">err</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
      <span class="p">},</span>

      <span class="p">[](</span><span class="n">leaf</span><span class="o">::</span><span class="n">error_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">unmatched</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span>
          <span class="s">"Unknown failure detected"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span>
          <span class="s">"Cryptic diagnostic information follows"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span>
          <span class="n">unmatched</span><span class="p">;</span>
      <span class="p">}</span> <span class="p">);</span>
  <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_all"><code>try_handle_all</code></a> | <a href="#result"><code>result</code></a> | <a href="#BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></a> | <a href="#error_info"><code>error_info</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the call to <code>call_lua</code> succeeded, just print the answer.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Handle <code>do_work</code> failures.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Handle all other <code>lua_pcall</code> failures.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Follow this link to see the complete program: <a href="https://github.com/boostorg/leaf/blob/master/example/lua_callback_result.cpp?ts=4">lua_callback_result.cpp</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When using Lua with C&#43;&#43;, we need to protect the Lua interpreter from exceptions that may be thrown from C&#43;&#43; functions installed as <code>lua_CFunction</code> callbacks. Here is the program from this section rewritten to use a C&#43;&#43; exception to safely communicate errors out of the <code>do_work</code> function: <a href="https://github.com/boostorg/leaf/blob/master/example/lua_callback_eh.cpp?ts=4">lua_callback_eh.cpp</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-diagnostic_information">Diagnostic Information</h3>
<div class="paragraph">
<p>LEAF is able to automatically generate diagnostic messages that include information about all error objects available to error handlers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">error_code</span>
<span class="p">{</span>
  <span class="n">read_error</span><span class="p">,</span>
  <span class="n">write_error</span>
<span class="p">};</span>

<span class="p">....</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_all</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span> <span class="n">error_code</span><span class="o">::</span><span class="n">write_error</span><span class="p">,</span> <span class="n">leaf</span><span class="o">::</span><span class="n">e_file_name</span><span class="p">{</span> <span class="s">"file.txt"</span> <span class="p">}</span> <span class="p">);</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">error_code</span><span class="p">,</span> <span class="n">error_code</span><span class="o">::</span><span class="n">read_error</span><span class="o">&gt;</span> <span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Read error!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">verbose_diagnostic_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">info</span> <span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Unrecognized error detected, cryptic diagnostic information follows.</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We handle all failures that occur in this try block.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>One or more error handlers that should handle all possible failures.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The "catch all" error handler is required by <code>try_handle_all</code>. It will be called if LEAF is unable to use another error handler.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>verbose_diagnostic_info</code> output for the snippet above tells us that we got an <code>error_code</code> with value <code>1</code> (<code>write_error</code>), and an object of type <code>e_file_name</code> with <code>"file.txt"</code> stored in its <code>.value</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">Unrecognized error detected, cryptic diagnostic information follows.
leaf::verbose_diagnostic_info for Error ID = 1:
[with Name = error_code]: 1
Unhandled error objects:
[with Name = boost::leaf::e_file_name]: file.txt</pre>
</div>
</div>
<div class="paragraph">
<p>To print each error object, LEAF attempts to bind an unqualified call to <code>operator&lt;&lt;</code>, passing a <code>std::ostream</code> and the error object. If that fails, it will also attempt to bind <code>operator&lt;&lt;</code> that takes the <code>.value</code> of the error type. If that also does not compile, the error object value will not appear in diagnostic messages, though LEAF will still print its type.</p>
</div>
<div class="paragraph">
<p>Even with error types that define a printable <code>.value</code>, the user may still want to overload <code>operator&lt;&lt;</code> for the enclosing <code>struct</code>, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">struct</span> <span class="nc">e_errno</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

  <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">e_errno</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">e</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">"errno = "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">", </span><span class="se">\"</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">strerror</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'"'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>e_errno</code> type above is designed to hold <code>errno</code> values. The defined <code>operator&lt;&lt;</code> overload will automatically include the output from <code>strerror</code> when <code>e_errno</code> values are printed (LEAF defines <code>e_errno</code> in <code>&lt;boost/leaf/common.hpp&gt;</code>, together with other commonly-used error types).</p>
</div>
<div class="paragraph">
<p>Using <code>verbose_diagnostic_info</code> comes at a cost. Normally, when the program attempts to communicate error objects of types which are not used in any error handling scope in the current call stack, they are discarded, which saves cycles. However, if an error handler is provided that takes <code>verbose_diagnostic_info</code> argument, before such objects are discarded, they are printed and appended to a <code>std::string</code> (this is the case with <code>e_file_name</code> in our example above). Such objects appear under <code>Unhandled error objects</code> in the output from <code>verbose_diagnostic_info</code>.</p>
</div>
<div class="paragraph">
<p>If handling <code>verbose_diagnostic_info</code> is considered too costly, use <code>diagnostic_info</code> instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_all</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">new_error</span><span class="p">(</span> <span class="n">error_code</span><span class="o">::</span><span class="n">write_error</span><span class="p">,</span> <span class="n">leaf</span><span class="o">::</span><span class="n">e_file_name</span><span class="p">{</span> <span class="s">"file.txt"</span> <span class="p">}</span> <span class="p">);</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">error_code</span><span class="p">,</span> <span class="n">error_code</span><span class="o">::</span><span class="n">read_error</span><span class="o">&gt;</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Read error!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">diagnostic_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">info</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Unrecognized error detected, cryptic diagnostic information follows.</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the output may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">Unrecognized error detected, cryptic diagnostic information follows.
leaf::diagnostic_info for Error ID = 1:
[with Name = error_code]: 1
Detected 1 attempt to communicate an unexpected error object of type [with Name = boost::leaf::e_file_name]</pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the diagnostic information for <code>e_file_name</code> changed: LEAF no longer prints it before discarding it, and so <code>diagnostic_info</code> can only inform about the type of the discarded object, but not its value.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The automatically-generated diagnostic messages are developer-friendly, but not user-friendly. Therefore, <code>operator&lt;&lt;</code> overloads for error types should only print technical information in English, and should not attempt to localize strings or to format a user-friendly message; this should be done in error handling functions specifically designed for that purpose.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="tutorial-std_error_code">Working with <code>std::error_code</code>, <code>std::error_condition</code></h3>
<div class="sect3">
<h4 id="_introduction">Introduction</h4>
<div class="paragraph">
<p>The relationship between <code>std::error_code</code> and <code>std::error_condition</code> is not easily understood from reading the standard specifications. This section explains how they&#8217;re supposed to be used, and how LEAF interacts with them.</p>
</div>
<div class="paragraph">
<p>The idea behind <code>std::error_code</code> is to encode both an integer value representing an error code, as well as the domain of that value. The domain is represented by a <code>std::error_category</code> <span class="underline">reference</span>. Conceptually, a <code>std::error_code</code> is like a <code>pair&lt;std::error_category const &amp;, int&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say we have this <code>enum</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">libfoo_error</span>
<span class="p">{</span>
  <span class="n">e1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">e2</span><span class="p">,</span>
  <span class="n">e3</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We want to be able to transport <code>libfoo_error</code> values in <code>std::error_code</code> objects. This erases their static type, which enables them to travel freely across API boundaries. To this end, we must define a <code>std::error_category</code> that represents our <code>libfoo_error</code> type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">error_category</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">libfoo_error_category</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">category</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">error_category</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="k">override</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="s">"libfoo"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">message</span><span class="p">(</span><span class="kt">int</span> <span class="n">code</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
      <span class="k">switch</span><span class="p">(</span> <span class="n">libfoo_error</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="k">case</span> <span class="n">libfoo_error</span><span class="o">::</span><span class="n">e1</span><span class="p">:</span> <span class="k">return</span> <span class="s">"e1"</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">libfoo_error</span><span class="o">::</span><span class="n">e2</span><span class="p">:</span> <span class="k">return</span> <span class="s">"e2"</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">libfoo_error</span><span class="o">::</span><span class="n">e3</span><span class="p">:</span> <span class="k">return</span> <span class="s">"e3"</span><span class="p">;</span>
        <span class="nl">default:</span> <span class="k">return</span> <span class="s">"error"</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">category</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We also need to inform the standard library that <code>libfoo_error</code> is compatible with <code>std::error_code</code>, and provide a factory function which can be used to make <code>std::error_code</code> objects out of <code>libfoo_error</code> values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_error_code_enum</span><span class="o">&lt;</span><span class="n">libfoo_error</span><span class="o">&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="nf">make_error_code</span><span class="p">(</span><span class="n">libfoo_error</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">libfoo_error_category</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>With this in place, if we receive a <code>std::error_code</code>, we can easily check if it represents some of the <code>libfoo_error</code> values we&#8217;re interested in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="nf">f</span><span class="p">();</span>

<span class="p">....</span>
<span class="k">auto</span> <span class="n">ec</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span>
<span class="k">if</span><span class="p">(</span> <span class="n">ec</span> <span class="o">==</span> <span class="n">libfoo_error</span><span class="o">::</span><span class="n">e1</span> <span class="o">||</span> <span class="n">ec</span> <span class="o">==</span> <span class="n">libfoo_error</span><span class="o">::</span><span class="n">e2</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// We got either a libfoo_error::e1 or a libfoo_error::e2</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This works because the standard library detects that <code>std::is_error_code_enum&lt;libfoo_error&gt;::value</code> is <code>true</code>, and then uses <code>make_error_code</code> to create a <code>std::error_code</code> object it actually uses to compare to <code>ec</code>.</p>
</div>
<div class="paragraph">
<p>So far so good, but remember, the standard library defines another type also, <code>std::error_condition</code>. The first confusing thing is that in terms of its physical representation, <code>std::error_condition</code> is identical to <code>std::error_code</code>; that is, it is also like a pair of <code>std::error_category</code> reference and an <code>int</code>. Why do we need two different types which use identical physical representation?</p>
</div>
<div class="paragraph">
<p>The key to answering this question is to understand that <code>std::error_code</code> objects are designed to be returned from functions to indicate failures. In contrast, <code>std::error_condition</code> objects are <span class="underline">never</span> supposed to be communicated; their purpose is to interpret the <code>std::error_code</code> values being communicated. The idea is that in a given program there may be multiple different "physical" (maybe platform-specific) <code>std::error_code</code> values which all indicate the same "logical" <code>std::error_condition</code>.</p>
</div>
<div class="paragraph">
<p>This leads us to the second confusing thing about <code>std::error_condition</code>: it uses the same <code>std::error_category</code> type, but for a completely different purpose: to specify what <code>std::error_code</code> values are equivalent to what <code>std::error_condition</code> values.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say that in addition to <code>libfoo</code>, our program uses another library, <code>libbar</code>, which communicates failures in terms of <code>std::error_code</code> with a different error category. Perhaps <code>libbar_error</code> looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">libbar_error</span>
<span class="p">{</span>
  <span class="n">e1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">e2</span><span class="p">,</span>
  <span class="n">e3</span><span class="p">,</span>
  <span class="n">e4</span>
<span class="p">};</span>

<span class="c1">// Boilerplate omitted:</span>
<span class="c1">// - libbar_error_category()</span>
<span class="c1">// - specialization of std::is_error_code_enum</span>
<span class="c1">// - make_error_code factory function for libbar_error.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can now use <code>std::error_condition</code> to define the <em>logical</em> error conditions represented by the <code>std::error_code</code> values communicated by <code>libfoo</code> and <code>libbar</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">my_error_condition</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">{</span>
  <span class="n">c1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">c2</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">error_category</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">libfoo_error_category</span><span class="p">()</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">{</span>
  <span class="k">struct</span> <span class="nc">category</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">error_category</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="k">override</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="s">"my_error_condition"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">message</span><span class="p">(</span><span class="kt">int</span> <span class="n">cond</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
      <span class="k">switch</span><span class="p">(</span> <span class="n">my_error_condition</span><span class="p">(</span><span class="n">code</span><span class="p">)</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="k">case</span> <span class="n">my_error_condition</span><span class="o">::</span><span class="n">c1</span><span class="p">:</span> <span class="k">return</span> <span class="s">"c1"</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">my_error_condition</span><span class="o">::</span><span class="n">c2</span><span class="p">:</span> <span class="k">return</span> <span class="s">"c2"</span><span class="p">;</span>
        <span class="nl">default:</span> <span class="k">return</span> <span class="s">"error"</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">equivalent</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cond</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span>
    <span class="p">{</span>
      <span class="k">switch</span><span class="p">(</span> <span class="n">my_error_condition</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="k">case</span> <span class="n">my_error_condition</span><span class="o">::</span><span class="n">c1</span><span class="p">:</span> <i class="conum" data-value="3"></i><b>(3)</b>
          <span class="k">return</span>
            <span class="n">code</span> <span class="o">==</span> <span class="n">libfoo_error</span><span class="o">::</span><span class="n">e1</span> <span class="o">||</span>
            <span class="n">code</span> <span class="o">==</span> <span class="n">libbar_error</span><span class="o">::</span><span class="n">e3</span> <span class="o">||</span>
            <span class="n">code</span> <span class="o">==</span> <span class="n">libbar_error</span><span class="o">::</span><span class="n">e4</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">my_error_condition</span><span class="o">::</span><span class="n">c2</span><span class="p">:</span> <i class="conum" data-value="4"></i><b>(4)</b>
          <span class="k">return</span>
            <span class="n">code</span> <span class="o">==</span> <span class="n">libfoo_error</span><span class="o">::</span><span class="n">e2</span> <span class="o">||</span>
            <span class="n">code</span> <span class="o">==</span> <span class="n">libbar_error</span><span class="o">::</span><span class="n">e1</span> <span class="o">||</span>
            <span class="n">code</span> <span class="o">==</span> <span class="n">libbar_error</span><span class="o">::</span><span class="n">e2</span><span class="p">;</span>
        <span class="nl">default:</span>
          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">category</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span> <i class="conum" data-value="5"></i><b>(5)</b>
  <span class="k">class</span> <span class="nc">is_error_condition_enum</span><span class="o">&lt;</span><span class="n">my_error_condition</span><span class="o">&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">error_condition</span> <span class="nf">make_error_condition</span><span class="p">(</span><span class="n">my_error_condition</span> <span class="n">e</span><span class="p">)</span> <i class="conum" data-value="6"></i><b>(6)</b>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">error_condition</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">my_error_condition_error_category</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Enumeration of the two logical error conditions, <code>c1</code> and <code>c2</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Define the <code>std::error_category</code> for <code>std::error_condition</code> objects that represent a <code>my_error_condition</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here we specify that any of <code>libfoo:error::e1</code>, <code>libbar_error::e3</code> and <code>libbar_error::e4</code> are logically equivalent to <code>my_error_condition::c1</code>, and that&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>&#8230;&#8203;any of <code>libfoo:error::e2</code>, <code>libbar_error::e1</code> and <code>libbar_error::e2</code> are logically equivalent to <code>my_error_condition::c2</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This specialization tells the standard library that the <code>my_error_condition</code> enum is designed to be used with <code>std::error_condition</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The factory function to make <code>std::error_condition</code> objects out of <code>my_error_condition</code> values.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Phew!</p>
</div>
<div class="paragraph">
<p>Now, if we have a <code>std::error_code</code> object <code>ec</code>, we can easily check if it is equivalent to <code>my_error_condition::c1</code> like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">if</span><span class="p">(</span> <span class="n">ec</span> <span class="o">==</span> <span class="n">my_error_condition</span><span class="o">::</span><span class="n">c1</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// We have a c1 in our hands</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, remember that beyond defining the <code>std::error_category</code> for <code>std::error_condition</code> objects initialized with a <code>my_error_condition</code> value, we don&#8217;t need to interact with the actual <code>std::error_condition</code> instances: they&#8217;re created when needed to compare to a <code>std::error_code</code>, and that&#8217;s pretty much all they&#8217;re good for.</p>
</div>
</div>
<div class="sect3">
<h4 id="_support_in_leaf">Support in LEAF</h4>
<div class="paragraph">
<p>The <code>match</code> predicate can be used as an argument to a LEAF error handler to match a <code>std::error_code</code> with a given error condition. For example, to handle <code>my_error_condition::c1</code> (see above), we could use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="p">,</span> <span class="n">my_error_condition</span><span class="o">::</span><span class="n">c1</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span> <span class="o">==</span> <span class="n">my_error_condition</span><span class="o">::</span><span class="n">c1</span><span class="p">);</span>
    <span class="p">....</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#match"><code>match</code></a> for more examples.</p>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="tutorial-boost_exception_integration">Boost Exception Integration</h3>
<div class="paragraph">
<p>Instead of the <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/get_error_info.html"><code>boost::get_error_info</code></a> API defined by Boost Exception, it is possible to use LEAF error handlers directly. Consider the following use of <code>boost::get_error_info</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_info</span><span class="o">&lt;</span><span class="k">struct</span> <span class="nc">my_info_</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_info</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">();</span> <span class="c1">// Throws using boost::throw_exception</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">try</span>
  <span class="p">{</span>
    <span class="n">f</span><span class="p">();</span>
  <span class="p">},</span>
  <span class="k">catch</span><span class="p">(</span> <span class="n">boost</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span> <span class="n">e</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">get_error_info</span><span class="o">&lt;</span><span class="n">my_info</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">)</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Got my_info with value = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We can rewrite <code>g</code> to access <code>my_info</code> using LEAF:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="cp">#include &lt;boost/leaf/handle_errors.hpp&gt;
</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">leaf</span><span class="o">::</span><span class="n">try_catch</span><span class="p">(</span>

    <span class="p">[]</span>
    <span class="p">{</span>
      <span class="n">f</span><span class="p">();</span>
    <span class="p">},</span>

    <span class="p">[](</span> <span class="n">my_info</span> <span class="n">x</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Got my_info with value = "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_catch"><code>try_catch</code></a></p>
</div>
<div class="paragraph">
<p>Taking <code>my_info</code> means that the handler will only be selected if the caught exception object carries <code>my_info</code> (which LEAF accesses via <code>boost::get_error_info</code>).</p>
</div>
<div class="paragraph">
<p>The use of <a href="#match"><code>match</code></a> is also supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">leaf</span><span class="o">::</span><span class="n">try_catch</span><span class="p">(</span>

    <span class="p">[]</span>
    <span class="p">{</span>
      <span class="n">f</span><span class="p">();</span>
    <span class="p">},</span>

    <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match_value</span><span class="o">&lt;</span><span class="n">my_info</span><span class="p">,</span> <span class="mi">42</span><span class="o">&gt;</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Got my_info with value = 42"</span><span class="p">;</span>
    <span class="p">}</span> <span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Above, the handler will be selected if the caught exception object carries <code>my_info</code> with <code>.value()</code> equal to 42.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="example">Examples</h2>
<div class="sectionbody">
<div class="paragraph">
<p>See <a href="https://github.com/boostorg/leaf/tree/master/example">github</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="synopsis">Synopsis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section lists each public header file in LEAF, documenting the definitions it provides.</p>
</div>
<div class="paragraph">
<p>LEAF headers are designed to minimize coupling:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Headers needed to report or forward but not handle errors are lighter than headers providing error handling functionality.</p>
</li>
<li>
<p>Headers that provide exception handling or throwing functionality are separate from headers that provide error handling or reporting but do not use exceptions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A standalone single-header option is available; please see <a href="#distribution">Distribution</a>.</p>
</div>
<hr>
<div class="sect2">
<h3 id="synopsis-reporting">Error Reporting</h3>
<div class="sect3">
<h4 id="error.hpp"><code>error.hpp</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">class</span> <span class="nc">error_id</span>
  <span class="p">{</span>
  <span class="nl">public:</span>

    <span class="n">error_id</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Enum</span><span class="p">&gt;</span>
    <span class="n">error_id</span><span class="p">(</span> <span class="n">Enum</span> <span class="n">e</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_error_code_enum</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">Enum</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">*</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">error_id</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ec</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="n">to_error_code</span><span class="p">()</span> <span class="k">const</span> <span class="n">noexept</span><span class="p">;</span>

    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">a</span><span class="p">,</span> <span class="n">error_id</span> <span class="n">b</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">a</span><span class="p">,</span> <span class="n">error_id</span> <span class="n">b</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">a</span><span class="p">,</span> <span class="n">error_id</span> <span class="n">b</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Item</span><span class="p">&gt;</span>
    <span class="n">error_id</span> <span class="n">load</span><span class="p">(</span> <span class="n">Item</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">item</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">error_id</span> <span class="n">x</span> <span class="p">);</span>
  <span class="p">};</span>

  <span class="kt">bool</span> <span class="n">is_error_id</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ec</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Item</span><span class="p">&gt;</span>
  <span class="n">error_id</span> <span class="n">new_error</span><span class="p">(</span> <span class="n">Item</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">item</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="n">error_id</span> <span class="n">current_error</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="c1">//////////////////////////////////////////</span>

  <span class="k">class</span> <span class="nc">polymorphic_context</span>
  <span class="p">{</span>
  <span class="nl">protected:</span>

    <span class="n">polymorphic_context</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="o">~</span><span class="n">polymorphic_context</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="nl">public:</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">activate</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">deactivate</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">is_active</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">propagate</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">//////////////////////////////////////////</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ctx</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">context_activator</span>
  <span class="p">{</span>
    <span class="n">context_activator</span><span class="p">(</span> <span class="n">context_activator</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">context_activator</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">context_activator</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="nl">public:</span>

    <span class="k">explicit</span> <span class="n">context_activator</span><span class="p">(</span> <span class="n">Ctx</span> <span class="o">&amp;</span> <span class="n">ctx</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">context_activator</span><span class="p">(</span> <span class="n">context_activator</span> <span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="o">~</span><span class="n">context_activator</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ctx</span><span class="p">&gt;</span>
  <span class="n">context_activator</span><span class="o">&lt;</span><span class="n">Ctx</span><span class="o">&gt;</span> <span class="n">activate_context</span><span class="p">(</span> <span class="n">Ctx</span> <span class="o">&amp;</span> <span class="n">ctx</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">R</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_result_type</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">R</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_result_type</span><span class="o">&lt;</span><span class="n">R</span> <span class="k">const</span><span class="o">&gt;:</span> <span class="n">is_result_type</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span>
  <span class="p">{</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span>

<span class="cp">#define BOOST_LEAF_ASSIGN(v, r)\
  auto &amp;&amp; &lt;&lt;temp&gt;&gt; = r;\
  if( !&lt;&lt;temp&gt;&gt; )\
    return &lt;&lt;temp&gt;&gt;.error();\
  v = std::forward&lt;decltype(&lt;&lt;temp&gt;&gt;)&gt;(&lt;&lt;temp&gt;&gt;).value()
</span>
<span class="cp">#define BOOST_LEAF_AUTO(v, r)\
  BOOST_LEAF_ASSIGN(auto v, r)
</span>
<span class="cp">#define BOOST_LEAF_CHECK(r)\
		auto &amp;&amp; &lt;&lt;temp&gt;&gt; = r;\
		if( &lt;&lt;temp&gt;&gt; )\
      ;\
    else\
			return &lt;&lt;temp&gt;&gt;.error()
</span>
<span class="cp">#define BOOST_LEAF_NEW_ERROR &lt;&lt;inject e_source_location voodoo&gt;&gt; ::boost::leaf::new_error</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p>Reference: <a href="#error_id"><code>error_id</code></a> | <a href="#is_error_id"><code>is_error_id</code></a> | <a href="#new_error"><code>new_error</code></a> | <a href="#current_error"><code>current_error</code></a> | <a href="#polymorphic_context"><code>polymorphic_context</code></a> | <a href="#context_activator"><code>context_activator</code></a> | <a href="#activate_context"><code>activate_context</code></a> | <a href="#is_result_type"><code>is_result_type</code></a> | <a href="#BOOST_LEAF_ASSIGN"><code>BOOST_LEAF_ASSIGN</code></a> | <a href="#BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></a> | <a href="#BOOST_LEAF_CHECK"><code>BOOST_LEAF_CHECK</code></a> | <a href="#BOOST_LEAF_NEW_ERROR"><code>BOOST_LEAF_NEW_ERROR</code></a></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="common.hpp"><code>common.hpp</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/common.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">struct</span> <span class="nc">e_api_function</span> <span class="p">{</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>

  <span class="k">struct</span> <span class="nc">e_file_name</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>

  <span class="k">struct</span> <span class="nc">e_type_info_name</span> <span class="p">{</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>

  <span class="k">struct</span> <span class="nc">e_at_line</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>

  <span class="k">struct</span> <span class="nc">e_errno</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">e_errno</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">);</span>
  <span class="p">};</span>

  <span class="k">namespace</span> <span class="n">windows</span>
  <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">e_LastError</span>
    <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">value</span><span class="p">;</span>
      <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">e_LastError</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">);</span>
    <span class="p">};</span>
  <span class="p">}</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p>Reference: <a href="#e_api_function"><code>e_api_function</code></a> | <a href="#e_file_name"><code>e_file_name</code></a> | <a href="#e_at_line"><code>e_at_line</code></a> | <a href="#e_type_info_name"><code>e_type_info_name</code></a> | <a href="#e_source_location"><code>e_source_location</code></a> | <a href="#e_errno"><code>e_errno</code></a> | <a href="#e_LastError"><code>e_LastError</code></a></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="result.hpp"><code>result.hpp</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">result</span>
  <span class="p">{</span>
  <span class="nl">public:</span>

    <span class="n">result</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">T</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">U</span> <span class="o">&amp;&amp;</span> <span class="n">u</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="n">enabled_if_T_can_be_inited_with_U</span><span class="o">&gt;&gt;</span> <span class="p">);</span>

    <span class="n">result</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">err</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">polymorphic_context</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Enum</span><span class="p">&gt;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">Enum</span> <span class="n">e</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_error_code_enum</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">Enum</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">*</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ec</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span><span class="p">(</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="n">result</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">T</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">();</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">T</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">();</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">T</span> <span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">();</span>

    <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;&gt;</span> <span class="n">error</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Item</span><span class="p">&gt;</span>
    <span class="n">error_id</span> <span class="n">load</span><span class="p">(</span> <span class="n">Item</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">item</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
  <span class="p">{</span>
  <span class="nl">public:</span>

    <span class="n">result</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">err</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">polymorphic_context</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Enum</span><span class="p">&gt;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">Enum</span> <span class="n">e</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_error_code_enum</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">Enum</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">*</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ec</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span><span class="p">(</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="n">result</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;&gt;</span> <span class="n">error</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Item</span><span class="p">&gt;</span>
    <span class="n">error_id</span> <span class="n">load</span><span class="p">(</span> <span class="n">Item</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">item</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">struct</span> <span class="nc">bad_result</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span> <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_result_type</span><span class="o">&lt;</span><span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p>Reference: <a href="#result"><code>result</code></a> | <a href="#is_result_type"><code>is_result_type</code></a></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="on_error.hpp"><code>on_error.hpp</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/on_error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Item</span><span class="p">&gt;</span>
  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;&gt;</span> <span class="n">on_error</span><span class="p">(</span> <span class="n">Item</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">e</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">error_monitor</span>
  <span class="p">{</span>
  <span class="nl">public:</span>

    <span class="n">error_monitor</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">error_id</span> <span class="n">check</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">error_id</span> <span class="n">assigned_error_id</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p>Reference: <a href="#on_error"><code>on_error</code></a> | <a href="#error_monitor"><code>error_monitor</code></a></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exception.hpp"><code>exception.hpp</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ex</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">-</span><span class="n">exception</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;&gt;</span> <span class="n">exception</span><span class="p">(</span> <span class="n">Ex</span> <span class="o">&amp;&amp;</span><span class="p">,</span> <span class="n">E</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E1</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">-</span><span class="n">exception</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;&gt;</span> <span class="n">exception</span><span class="p">(</span> <span class="n">E1</span> <span class="o">&amp;&amp;</span><span class="p">,</span> <span class="n">E</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">-</span><span class="n">exception</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;&gt;</span> <span class="n">exception</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ex</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">-</span><span class="n">exception</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;&gt;</span> <span class="n">exception</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">id</span><span class="p">,</span> <span class="n">Ex</span> <span class="o">&amp;&amp;</span><span class="p">,</span> <span class="n">E</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E1</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">-</span><span class="n">exception</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;&gt;</span> <span class="n">exception</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">id</span><span class="p">,</span> <span class="n">E1</span> <span class="o">&amp;&amp;</span><span class="p">,</span> <span class="n">E</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">-</span><span class="n">exception</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;&gt;</span> <span class="n">exception</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">id</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span>

<span class="cp">#define BOOST_LEAF_EXCEPTION &lt;&lt;inject e_source_location voodoo&gt;&gt; ::boost::leaf::exception
</span>
<span class="cp">#define BOOST_LEAF_THROW_EXCEPTION &lt;&lt;inject e_source_location + invoke boost::throw_exception voodoo&gt;&gt; ::boost::leaf::exception</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p>Reference: <a href="#exception"><code>exception</code></a> | <a href="#BOOST_LEAF_EXCEPTION"><code>BOOST_LEAF_EXCEPTION</code></a> | <a href="#BOOST_LEAF_THROW_EXCEPTION"><code>BOOST_LEAF_THROW_EXCEPTION</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Only enabled if std::is_base_of&lt;std::exception, Ex&gt;::value.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Only enabled if !std::is_base_of&lt;std::exception, E1&gt;::value.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_capture_hpp"><code>capture.hpp</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/capture_exception.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">A</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">())...))</span>
  <span class="n">capture</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">polymorphic_context</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">F</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">A</span><span class="p">...</span> <span class="n">a</span><span class="p">);</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Ex</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="o">&lt;&lt;</span><span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;-</span><span class="n">deduced</span><span class="o">&gt;&gt;</span> <span class="n">exception_to_result</span><span class="p">(</span> <span class="n">F</span> <span class="o">&amp;&amp;</span> <span class="n">f</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p>Reference: <a href="#capture"><code>capture</code></a> | <a href="#exception_to_result"><code>exception_to_result</code></a></p>
</div>
</div>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="tutorial-handling">Error Handling</h3>
<div class="sect3">
<h4 id="context.hpp"><code>context.hpp</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">context</span>
  <span class="p">{</span>
    <span class="n">context</span><span class="p">(</span> <span class="n">context</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">context</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">context</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="nl">public:</span>

    <span class="n">context</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">context</span><span class="p">(</span> <span class="n">context</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="o">~</span><span class="n">context</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">activate</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">deactivate</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">is_active</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">propagate</span> <span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">R</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">H</span><span class="p">&gt;</span>
    <span class="n">R</span> <span class="n">handle_error</span><span class="p">(</span> <span class="n">R</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">//////////////////////////////////////////</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">H</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">context_type_from_handlers</span> <span class="o">=</span> <span class="k">typename</span> <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">&gt;&gt;::</span><span class="n">type</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span>  <span class="nc">H</span><span class="p">&gt;</span>
  <span class="n">BOOST_LEAF_CONSTEXPR</span> <span class="n">context_type_from_handlers</span><span class="o">&lt;</span><span class="n">H</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">make_context</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span>  <span class="nc">H</span><span class="p">&gt;</span>
  <span class="n">BOOST_LEAF_CONSTEXPR</span> <span class="n">context_type_from_handlers</span><span class="o">&lt;</span><span class="n">H</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">make_context</span><span class="p">(</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span>  <span class="nc">H</span><span class="p">&gt;</span>
  <span class="n">context_ptr</span> <span class="n">make_shared_context</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span>  <span class="nc">H</span><span class="p">&gt;</span>
  <span class="n">context_ptr</span> <span class="n">make_shared_context</span><span class="p">(</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p>Reference: <a href="#context"><code>context</code></a> | <a href="#context_type_from_handlers"><code>context_type_from_handlers</code></a> | <a href="#make_context"><code>make_context</code></a> | <a href="#make_shared_context"><code>make_shared_context</code></a></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handle_errors.hpp"><code>handle_errors.hpp</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_errors.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TryBlock</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">H</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">TryBlock</span><span class="o">&gt;</span><span class="p">()().</span><span class="n">value</span><span class="p">())</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">try_handle_all</span><span class="p">(</span> <span class="n">TryBlock</span> <span class="o">&amp;&amp;</span> <span class="n">try_block</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">h</span> <span class="p">);</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TryBlock</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">H</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">TryBlock</span><span class="o">&gt;</span><span class="p">()())</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">try_handle_some</span><span class="p">(</span> <span class="n">TryBlock</span> <span class="o">&amp;&amp;</span> <span class="n">try_block</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">h</span> <span class="p">);</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TryBlock</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">H</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">TryBlock</span><span class="o">&gt;</span><span class="p">()())</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">try_catch</span><span class="p">(</span> <span class="n">TryBlock</span> <span class="o">&amp;&amp;</span> <span class="n">try_block</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">h</span> <span class="p">);</span>

  <span class="c1">//////////////////////////////////////////</span>

  <span class="k">class</span> <span class="nc">error_info</span>
  <span class="p">{</span>
    <span class="c1">//No public constructors</span>

  <span class="nl">public:</span>

    <span class="n">error_id</span> <span class="n">error</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">exception_caught</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="k">const</span> <span class="o">*</span> <span class="n">exception</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">error_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">x</span> <span class="p">);</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">diagnostic_info</span><span class="o">:</span> <span class="k">public</span> <span class="n">error_info</span>
  <span class="p">{</span>
    <span class="c1">//No public constructors</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">diagnostic_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">x</span> <span class="p">);</span>
  <span class="p">};</span>

  <span class="k">class</span> <span class="nc">verbose_diagnostic_info</span><span class="o">:</span> <span class="k">public</span> <span class="n">error_info</span>
  <span class="p">{</span>
    <span class="c1">//No public constructors</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">diagnostic_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">x</span> <span class="p">);</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p>Reference: <a href="#try_handle_all"><code>try_handle_all</code></a> | <a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#try_catch"><code>try_catch</code></a> | <a href="#error_info"><code>error_info</code></a> | <a href="#diagnostic_info"><code>diagnostic_info</code></a> | <a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pred.hpp"><code>pred.hpp</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/pred.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">V</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">match</span>
  <span class="p">{</span>
    <span class="n">E</span> <span class="n">matched</span><span class="p">;</span>

    <span class="c1">// Other members not specified</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">V</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">&lt;</span><span class="n">match</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span> <span class="n">V</span><span class="p">...</span><span class="o">&gt;&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">V</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">match_value</span>
  <span class="p">{</span>
    <span class="n">E</span> <span class="n">matched</span><span class="p">;</span>

    <span class="c1">// Other members not specified</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">V</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">&lt;</span><span class="n">match_value</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span> <span class="n">V</span><span class="p">...</span><span class="o">&gt;&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">...&gt;</span>
  <span class="k">struct</span> <span class="nc">match_member</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">T</span> <span class="n">E</span><span class="o">::*</span> <span class="n">P</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">V</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">member</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span> <span class="n">V</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">E</span> <span class="n">matched</span><span class="p">;</span>

    <span class="c1">// Other members not specified</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">auto</span> <span class="n">P</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">V</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">&lt;</span><span class="n">match_member</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span> <span class="n">V</span><span class="p">...</span><span class="o">&gt;&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Ex</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">catch_</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">matched</span><span class="p">;</span>

    <span class="c1">// Other members not specified</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ex</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">catch_</span><span class="o">&lt;</span><span class="n">Ex</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">Ex</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">matched</span><span class="p">;</span>

    <span class="c1">// Other members not specified</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Ex</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">&lt;</span><span class="n">catch_</span><span class="o">&lt;</span><span class="n">Ex</span><span class="p">...</span><span class="o">&gt;&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Pred</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">if_not</span>
  <span class="p">{</span>
    <span class="n">E</span> <span class="n">matched</span><span class="p">;</span>

    <span class="c1">// Other members not specified</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Pred</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">&lt;</span><span class="n">if_not</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ErrorCodeEnum</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="n">category</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ec</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Enum</span><span class="p">,</span> <span class="k">class</span> <span class="nc">EnumType</span> <span class="o">=</span> <span class="n">Enum</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">condition</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p>Reference: <a href="#match"><code>match</code></a> | <a href="#match_value"><code>match_value</code></a> | <a href="#match_member"><code>match_member</code></a> | <a href="#catch_"><code>catch_</code></a> | <a href="#if_not"><code>if_not</code></a> | <a href="#category"><code>category</code></a> | <a href="#condition"><code>condition</code></a></p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="functions">Reference: Functions</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The contents of each Reference section are organized alphabetically.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect2">
<h3 id="activate_context"><code>activate_context</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ctx</span><span class="p">&gt;</span>
  <span class="n">context_activator</span><span class="o">&lt;</span><span class="n">Ctx</span><span class="o">&gt;</span> <span class="n">activate_context</span><span class="p">(</span> <span class="n">Ctx</span> <span class="o">&amp;</span> <span class="n">ctx</span> <span class="p">)</span> <span class="k">noexcept</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">context_activator</span><span class="o">&lt;</span><span class="n">Ctx</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
  <span class="p">}</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#context_activator"><code>context_activator</code></a></p>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">context</span><span class="o">&lt;</span><span class="n">E1</span><span class="p">,</span> <span class="n">E2</span><span class="p">,</span> <span class="n">E3</span><span class="o">&gt;</span> <span class="n">ctx</span><span class="p">;</span>

<span class="p">{</span>
  <span class="k">auto</span> <span class="n">active_context</span> <span class="o">=</span> <span class="n">activate_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="p">}</span> <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Activate <code>ctx</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Automatically deactivate <code>ctx</code>.</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="capture"><code>capture</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/capture.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">A</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">())...))</span>
  <span class="n">capture</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">polymorphic_context</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">F</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">A</span><span class="p">...</span> <span class="n">a</span><span class="p">);</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#polymorphic_context"><code>polymorphic_context</code></a></p>
</div>
<div class="paragraph">
<p>This function can be used to capture error objects stored in a <a href="#context"><code>context</code></a> in one thread and transport them to a different thread for handling, either in a <code><a href="#result">result</a>&lt;T&gt;</code> object or in an exception.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The same type returned by <code>F</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Uses an internal <a href="#context_activator"><code>context_activator</code></a> to <a href="#context::activate"><code>activate</code></a> <code>*ctx</code>, then invokes <code>std::forward&lt;F&gt;(f)(std::forward&lt;A&gt;(a)&#8230;&#8203;)</code>. Then:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>If the returned value <code>r</code> is not a <code>result&lt;T&gt;</code> type (see <a href="#is_result_type"><code>is_result_type</code></a>), it is forwarded to the caller.</p>
</li>
<li>
<p>Otherwise:</p>
<div class="ulist">
<ul>
<li>
<p>If <code>!r</code>, the return value of <code>capture</code> is initialized with <code>ctx</code>;</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An object of type <code>leaf::<a href="#result">result</a>&lt;T&gt;</code> can be initialized with a <code>std::shared_ptr&lt;leaf::polymorphic_context&gt;</code>.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>otherwise, it is initialized with <code>r</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>In case <code>f</code> throws, <code>capture</code> catches the exception in a <code>std::exception_ptr</code>, and throws a different exception of unspecified type that transports both the <code>std::exception_ptr</code> as well as <code>ctx</code>. This exception type is recognized by <a href="#try_catch"><code>try_catch</code></a>, which automatically unpacks the original exception and propagates the contents of <code>*ctx</code> (presumably, in a different thread).</p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#tutorial-async">Transporting Error Objects Between Threads</a> from the Tutorial.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="context_type_from_handlers"><code>context_type_from_handlers</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">H</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">context_type_from_handlers</span> <span class="o">=</span> <span class="k">typename</span> <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">&gt;&gt;::</span><span class="n">type</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">auto</span> <span class="n">error_handlers</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span>

  <span class="p">[](</span><span class="n">e_this</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">e_that</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">....</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">leaf</span><span class="o">::</span><span class="n">diagnostic_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">info</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="p">....</span>
  <span class="p">},</span>
  <span class="p">....</span> <span class="p">);</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">context_type_from_handlers</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">error_handlers</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ctx</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>ctx</code> will be of type <code>context&lt;e_this, e_that&gt;</code>, deduced automatically from the specified error handlers.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Alternatively, a suitable context may be created by calling <a href="#make_context"><code>make_context</code></a>, or allocated dynamically by calling <a href="#make_shared_context"><code>make_shared_context</code></a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="current_error"><code>current_error</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="n">error_id</span> <span class="n">current_error</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The <code>error_id</code> value returned the last time <a href="#new_error"><code>new_error</code></a> was invoked from the calling thread.</p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#on_error"><code>on_error</code></a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="exception"><code>exception</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ex</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">&gt;&gt;</span> <span class="n">exception</span><span class="p">(</span> <span class="n">Ex</span> <span class="o">&amp;&amp;</span> <span class="n">ex</span><span class="p">,</span> <span class="n">E</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">e</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E1</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">&gt;&gt;</span> <span class="n">exception</span><span class="p">(</span> <span class="n">E1</span> <span class="o">&amp;&amp;</span> <span class="n">e1</span><span class="p">,</span> <span class="n">E</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">e</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">&gt;&gt;</span> <span class="n">exception</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ex</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span> <i class="conum" data-value="4"></i><b>(4)</b>
  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">&gt;&gt;</span> <span class="n">exception</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">id</span><span class="p">,</span> <span class="n">Ex</span> <span class="o">&amp;&amp;</span> <span class="n">ex</span><span class="p">,</span> <span class="n">E</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">e</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E1</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span> <i class="conum" data-value="5"></i><b>(5)</b>
  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">&gt;&gt;</span> <span class="n">exception</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">id</span><span class="p">,</span> <span class="n">E1</span> <span class="o">&amp;&amp;</span> <span class="n">e1</span><span class="p">,</span> <span class="n">E</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">e</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">&gt;&gt;</span> <span class="n">exception</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">id</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="6"></i><b>(6)</b>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>exception</code> function is overloaded: it can be invoked with no arguments, or else there are several alternatives, selected using <code>std::enable_if</code> based on the type of the passed arguments:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Selected if the first argument is not of type <code>error_id</code> and is an exception object, that is, iff <code>Ex</code> derives publicly from <code>std::exception</code>. In this case the return value is of unspecified type which derives publicly from <code>Ex</code> <strong>and</strong> from class <a href="#error_id"><code>error_id</code></a>, such that:
<div class="ulist">
<ul>
<li>
<p>its <code>Ex</code> subobject is initialized by <code>std::forward&lt;Ex&gt;(ex)</code>;</p>
</li>
<li>
<p>its <code>error_id</code> subobject is initialized by <code><a href="#new_error">new_error</a>(std::forward&lt;E&gt;(e)&#8230;&#8203;</code>).</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Selected if the first argument is not of type <code>error_id</code> and is not an exception object. In this case the return value is of unspecified type which derives publicly from <code>std::exception</code> <strong>and</strong> from class <code>error_id</code>, such that:
<div class="ulist">
<ul>
<li>
<p>its <code>std::exception</code> subobject is default-initialized;</p>
</li>
<li>
<p>its <code>error_id</code> subobject is initialized by <code><a href="#new_error">new_error</a>(std::forward&lt;E1&gt;(e1), std::forward&lt;E&gt;(e)&#8230;&#8203;</code>).</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>If the fuction is invoked without arguments, the return value is of unspecified type which derives publicly from <code>std::exception</code> <strong>and</strong> from class <code>error_id</code>, such that:
<div class="ulist">
<ul>
<li>
<p>its <code>std::exception</code> subobject is default-initialized;</p>
</li>
<li>
<p>its <code>error_id</code> subobject is initialized by <code><a href="#new_error">new_error</a>()</code>.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Selected if the first argument is of type <code>error_id</code> and the second argument is an exception object, that is, iff <code>Ex</code> derives publicly from <code>std::exception</code>. In this case the return value is of unspecified type which derives publicly from <code>Ex</code> <strong>and</strong> from class <a href="#error_id"><code>error_id</code></a>, such that:
<div class="ulist">
<ul>
<li>
<p>its <code>Ex</code> subobject is initialized by <code>std::forward&lt;Ex&gt;(ex)</code>;</p>
</li>
<li>
<p>its <code>error_id</code> subobject is initialized by <code>id.<a href="#error_id::load"><code>load</code></a>(std::forward&lt;E&gt;(e)&#8230;&#8203;)</code>.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Selected if the first argument is of type <code>error_id</code> and the second argument is not an exception object. In this case the return value is of unspecified type which derives publicly from <code>std::exception</code> <strong>and</strong> from class <code>error_id</code>, such that:
<div class="ulist">
<ul>
<li>
<p>its <code>std::exception</code> subobject is default-initialized;</p>
</li>
<li>
<p>its <code>error_id</code> subobject is initialized by <code>id.<a href="#error_id::load"><code>load</code></a>(std::forward&lt;E1&gt;(e1), std::forward&lt;E&gt;(e)&#8230;&#8203;</code>).</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>If <code>exception</code> is invoked with just an <code>error_id</code> object, the return value is of unspecified type which derives publicly from <code>std::exception</code> <strong>and</strong> from class <code>error_id</code>, such that:
<div class="ulist">
<ul>
<li>
<p>its <code>std::exception</code> subobject is default-initialized;</p>
</li>
<li>
<p>its <code>error_id</code> subobject is initialized by copying from <code>id</code>.</p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The first three overloads return an exception object that is associated with a new <code>error_id</code>. The second three overloads return an exception object that is associated with the specified <code>error_id</code>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example 1:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">struct</span> <span class="nc">my_exception</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">throw</span> <span class="n">leaf</span><span class="o">::</span><span class="n">exception</span><span class="p">(</span><span class="n">my_exception</span><span class="p">{});</span> <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Throws an exception of a type that derives from <code>error_id</code> and from <code>my_exception</code> (because <code>my_exception</code> derives from <code>std::exception</code>).</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example 2:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">my_error</span> <span class="p">{</span> <span class="n">e1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span> <span class="p">};</span> <i class="conum" data-value="1"></i><b>(1)</b>

<span class="k">throw</span> <span class="n">leaf</span><span class="o">::</span><span class="n">exception</span><span class="p">(</span><span class="n">my_error</span><span class="o">::</span><span class="n">e1</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Throws an exception of a type that derives from <code>error_id</code> and from <code>std::exception</code> (because <code>my_error</code> does not derive from <code>std::exception</code>).</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To automatically capture <code>__FILE__</code>, <code>__LINE__</code> and <code>__FUNCTION__</code> with the returned object, use <a href="#BOOST_LEAF_EXCEPTION"><code>BOOST_LEAF_EXCEPTION</code></a> instead of <code>leaf::exception</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="exception_to_result"><code>exception_to_result</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/capture.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Ex</span><span class="p">,</span> <span class="k">class</span> <span class="nc">F</span><span class="p">&gt;</span>
  <span class="o">&lt;&lt;</span><span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;-</span><span class="n">deduced</span><span class="o">&gt;&gt;</span> <span class="n">exception_to_result</span><span class="p">(</span> <span class="n">F</span> <span class="o">&amp;&amp;</span> <span class="n">f</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function can be used to catch exceptions from a lower-level library and convert them to <code><a href="#result">result</a>&lt;T&gt;</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>Where <code>f</code> returns a type <code>T</code>, <code>exception_to_result</code> returns <code>leaf::result&lt;T&gt;</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Catches all exceptions, then captures <code>std::current_exception</code> in a <code>std::exception_ptr</code> object, which is <a href="#tutorial-loading">loaded</a> with the returned <code>result&lt;T&gt;</code>.</p>
</li>
<li>
<p>Attempts to convert the caught exception, using <code>dynamic_cast</code>, to each type <code>Ex<sub>i</sub></code> in <code>Ex&#8230;&#8203;</code>. If the cast to <code>Ex<sub>i</sub></code> succeeds, the <code>Ex<sub>i</sub></code> slice of the caught exception is loaded with the returned <code>result&lt;T&gt;</code>.</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
An error handler that takes an argument of an exception type (that is, of a type that derives from <code>std::exception</code>) will work correctly whether the object is thrown as an exception or communicated via <a href="#new_error"><code>new_error</code></a> (or converted using <code>exception_to_result</code>).
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="kt">int</span> <span class="nf">compute_answer_throws</span><span class="p">();</span>

<span class="c1">//Call compute_answer, convert exceptions to result&lt;int&gt;</span>
<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">compute_answer</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">exception_to_result</span><span class="o">&lt;</span><span class="n">ex_type1</span><span class="p">,</span> <span class="n">ex_type2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">compute_answer_throws</span><span class="p">());</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>At a later time we can invoke <a href="#try_handle_some"><code>try_handle_some</code></a> / <a href="#try_handle_all"><code>try_handle_all</code></a> as usual, passing handlers that take <code>ex_type1</code> or <code>ex_type2</code>, for example by reference:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">compute_answer</span><span class="p">());</span>
    <span class="c1">//Use answer</span>
    <span class="p">....</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">ex_type1</span> <span class="o">&amp;</span> <span class="n">ex1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//Handle ex_type1</span>
    <span class="p">....</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">ex_type2</span> <span class="o">&amp;</span> <span class="n">ex2</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//Handle ex_type2</span>
    <span class="p">....</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//Handle any other exception from compute_answer.</span>
    <span class="p">....</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#result"><code>result</code></a> | <a href="#BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></a></p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When a handler takes an argument of an exception type (that is, a type that derives from <code>std::exception</code>), if the object is thrown, the argument will be matched dynamically (using <code>dynamic_cast</code>); otherwise (e.g. after being converted by <code>exception_to_result</code>) it will be matched based on its static type only (which is the same behavior used for types that do not derive from <code>std::exception</code>).
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#tutorial-exception_to_result">Converting Exceptions to <code>result&lt;T&gt;</code></a> from the tutorial.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="make_context"><code>make_context</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span>  <span class="nc">H</span><span class="p">&gt;</span>
  <span class="n">context_type_from_handlers</span><span class="o">&lt;</span><span class="n">H</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">make_context</span><span class="p">()</span> <span class="k">noexcept</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span>  <span class="nc">H</span><span class="p">&gt;</span>
  <span class="n">context_type_from_handlers</span><span class="o">&lt;</span><span class="n">H</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">make_context</span><span class="p">(</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="p">)</span> <span class="k">noexcept</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">}</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#context_type_from_handlers"><code>context_type_from_handlers</code></a></p>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">auto</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">make_context</span><span class="p">(</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="p">[](</span> <span class="n">e_this</span> <span class="p">)</span> <span class="p">{</span> <span class="p">....</span> <span class="p">},</span>
  <span class="p">[](</span> <span class="n">e_that</span> <span class="p">)</span> <span class="p">{</span> <span class="p">....</span> <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>decltype(ctx)</code> is <code>leaf::context&lt;e_this, e_that&gt;</code>.</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="make_shared_context"><code>make_shared_context</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span>  <span class="nc">H</span><span class="p">&gt;</span>
  <span class="n">context_ptr</span> <span class="n">make_shared_context</span><span class="p">()</span> <span class="k">noexcept</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">leaf_detail</span><span class="o">::</span><span class="n">polymorphic_context_impl</span><span class="o">&lt;</span><span class="n">context_type_from_handlers</span><span class="o">&lt;</span><span class="n">H</span><span class="p">...</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span>  <span class="nc">H</span><span class="p">&gt;</span>
  <span class="n">context_ptr</span> <span class="n">make_shared_context</span><span class="p">(</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="p">)</span> <span class="k">noexcept</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">leaf_detail</span><span class="o">::</span><span class="n">polymorphic_context_impl</span><span class="o">&lt;</span><span class="n">context_type_from_handlers</span><span class="o">&lt;</span><span class="n">H</span><span class="p">...</span><span class="o">&gt;&gt;&gt;</span><span class="p">();</span>
  <span class="p">}</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#context_type_from_handlers"><code>context_type_from_handlers</code></a></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#tutorial-async">Transporting Error Objects Between Threads</a> from the tutorial.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="new_error"><code>new_error</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Item</span><span class="p">&gt;</span>
  <span class="n">error_id</span> <span class="n">new_error</span><span class="p">(</span><span class="n">Item</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">item</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p>Each of the <code>Item&#8230;&#8203;</code> types must be no-throw movable.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">error_id</span> <span class="n">id</span> <span class="o">=</span> <span class="o">&lt;&lt;</span><span class="n">generate</span><span class="o">-</span><span class="k">new</span><span class="o">-</span><span class="n">unique</span><span class="o">-</span><span class="n">id</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">return</span> <span class="n">id</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">)...);</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A new <code>error_id</code> value, which is unique across the entire program.</p>
</dd>
<dt class="hdlist1">Ensures: </dt>
<dd>
<p><code>id.value()!=0</code>, where <code>id</code> is the returned <code>error_id</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>new_error</code> discards error objects which are not used in any active error handling calling scope.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
When loaded into a <code>context</code>, an error object of a type <code>E</code> will overwrite the previously loaded object of type <code>E</code>, if any.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="on_error"><code>on_error</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/on_error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Item</span><span class="p">&gt;</span>
  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;&gt;</span> <span class="n">on_error</span><span class="p">(</span><span class="n">Item</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">item</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p>Each of the <code>Item&#8230;&#8203;</code> types must be no-throw movable.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>All <code>item&#8230;&#8203;</code> objects are forwarded and stored, together with the value returned from <code>std::unhandled_exceptions</code>, into the returned object of unspecified type, which should be captured by <code>auto</code> and kept alive in the calling scope. When that object is destroyed, if an error has occurred since <code>on_error</code> was invoked, LEAF will process the stored items to obtain error objects to be associated with the failure.</p>
<div class="paragraph">
<p>On error, LEAF first needs to deduce an <code>error_id</code> value <code>err</code> to associate error objects with. This is done using the following logic:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>If <a href="#new_error"><code>new_error</code></a> was invoked (by the calling thread) since the object returned by <code>on_error</code> was created, <code>err</code> is initialized with the value returned by <a href="#current_error"><code>current_error</code></a>;</p>
</li>
<li>
<p>Otherwise, if <code>std::unhandled_exceptions</code> returns a greater value than it returned during initialization, <code>err</code> is initialized with the value returned by <a href="#new_error"><code>new_error</code></a>;</p>
</li>
<li>
<p>Otherwise, the stored <code>item&#8230;&#8203;</code> objects are discarded and no further action is taken (no error has occurred).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Next, LEAF proceeds similarly to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">err</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">)...);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The difference is that unlike <a href="#error_id::load"><code>load</code></a>, <code>on_error</code> will not overwrite any error objects already associated with <code>err</code>.</p>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See <a href="#tutorial-on_error">Using <code>on_error</code></a> from the Tutorial.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="try_catch"><code>try_catch</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_errors.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TryBlock</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">H</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">TryBlock</span><span class="o">&gt;</span><span class="p">()())</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">try_catch</span><span class="p">(</span> <span class="n">TryBlock</span> <span class="o">&amp;&amp;</span> <span class="n">try_block</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">h</span> <span class="p">);</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>try_catch</code> function works similarly to <a href="#try_handle_some"><code>try_handle_some</code></a>, except that it does not use or understand the semantics of <code>result&lt;T&gt;</code> types; instead:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It assumes that the <code>try_block</code> throws to indicate a failure, in which case <code>try_catch</code> will attempt to find a suitable handler among <code>h&#8230;&#8203;</code>;</p>
</li>
<li>
<p>If a suitable handler isn&#8217;t found, the original exception is re-thrown using <code>throw;</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#tutorial-eh">Exception Handling</a> from the <a href="#tutorial">Tutorial</a> section.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="try_handle_all"><code>try_handle_all</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_errors.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TryBlock</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">H</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">TryBlock</span><span class="o">&gt;</span><span class="p">()().</span><span class="n">value</span><span class="p">())</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">try_handle_all</span><span class="p">(</span> <span class="n">TryBlock</span> <span class="o">&amp;&amp;</span> <span class="n">try_block</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">h</span> <span class="p">);</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>try_handle_all</code> function works similarly to <a href="#try_handle_some"><code>try_handle_some</code></a>, except:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In addition, it requires that at least one of  <code>h&#8230;&#8203;</code> can be used to handle any error (this requirement is enforced at compile time);</p>
</li>
<li>
<p>If the <code>try_block</code> returns some <code>result&lt;T&gt;</code> type, it must be possible to initialize a value of type <code>T</code> with the value returned by each of <code>h&#8230;&#8203;</code>, and</p>
</li>
<li>
<p>Because it is required to handle all errors, <code>try_handle_all</code> unwraps the <code>result&lt;T&gt;</code> object <code>r</code> returned by the <code>try_block</code>, returning <code>r.value()</code> instead of <code>r</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See also <a href="#tutorial-result">Error Handling</a> from the <a href="#tutorial">Tutorial</a> section.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="try_handle_some"><code>try_handle_some</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_errors.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TryBlock</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">H</span><span class="p">&gt;</span>
  <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">decay</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">TryBlock</span><span class="o">&gt;</span><span class="p">()())</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">try_handle_some</span><span class="p">(</span> <span class="n">TryBlock</span> <span class="o">&amp;&amp;</span> <span class="n">try_block</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">h</span> <span class="p">);</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The <code>try_block</code> function may not take any arguments.</p>
</li>
<li>
<p>The type <code>R</code> returned by the <code>try_block</code> function must be a <code>result&lt;T&gt;</code> type (see <a href="#is_result_type"><code>is_result_type</code></a>). It is valid for the <code>try_block</code> to return <code>leaf::<a href="#result">result</a>&lt;T&gt;</code>, however this is not a requirement.</p>
</li>
<li>
<p>Each of the <code>h&#8230;&#8203;</code> functions:</p>
<div class="ulist">
<ul>
<li>
<p>must return a type that can be used to initialize an object of the type <code>R</code>; in case R is a <code>result&lt;void&gt;</code> (that is, in case of success it does not communicate a value), handlers that return <code>void</code> are permitted. If such a handler is selected, the <code>try_handle_some</code> return value is initialized by <code>{}</code>;</p>
</li>
<li>
<p>may take any error objects, by value, by (<code>const</code>) reference, or as pointer (to <code>const</code>);</p>
</li>
<li>
<p>may take arguments, by value, of any predicate type: <a href="#catch_"><code>catch_</code></a>, <a href="#match"><code>match</code></a>, <a href="#match_value"><code>match_value</code></a>, <a href="#match_member"><code>match_member</code></a>, <a href="#if_not"><code>if_not</code></a>, or of any user-defined predicate type <code>Pred</code> for which <code><a href="#is_predicate">is_predicate</a>&lt;Pred&gt;::value</code> is <code>true</code>;</p>
</li>
<li>
<p>may take an <a href="#error_info"><code>error_info</code></a> argument by <code>const &amp;</code>;</p>
</li>
<li>
<p>may take a <a href="#diagnostic_info"><code>diagnostic_info</code></a> argument by <code>const &amp;</code>;</p>
</li>
<li>
<p>may take a <a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a> argument by <code>const &amp;</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Creates a local <code><a href="#context">context</a>&lt;E&#8230;&#8203;&gt;</code> object <code>ctx</code>, where the <code>E&#8230;&#8203;</code> types are automatically deduced from the types of arguments taken by each of <code>h&#8230;&#8203;</code>, which guarantees that <code>ctx</code> is able to store all of the types required to handle errors.</p>
</li>
<li>
<p>Invokes the <code>try_block</code>:</p>
<div class="ulist">
<ul>
<li>
<p>if the returned object <code>r</code> indicates success <span class="underline">and</span> the <code>try_block</code> did not throw, <code>r</code> is forwarded to the caller.</p>
</li>
<li>
<p>otherwise, LEAF  considers each of the <code>h&#8230;&#8203;</code> handlers, in order, until it finds one that it can supply with arguments using the error objects currently stored in <code>ctx</code>, associated with <code>r.error()</code>. The first such handler is invoked and its return value is used to initialize the return value of <code>try_handle_some</code>, which can indicate success if the handler was able to handle the error, or failure if it was not.</p>
</li>
<li>
<p>if <code>try_handle_some</code> is unable to find a suitable handler, it returns <code>r</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>try_handle_some</code> is exception-neutral: it does not throw exceptions, however the <code>try_block</code> and any of <code>h&#8230;&#8203;</code> are permitted to throw.
</td>
</tr>
</table>
</div>
<div id="handler_selection_procedure" class="dlist">
<dl>
<dt class="hdlist1">Handler Selection Procedure: </dt>
<dd>
<div class="paragraph">
<p>A handler <code>h</code> is suitable to handle the failure reported by <code>r</code> iff <code>try_handle_some</code> is able to produce values to pass as its arguments, using the error objects currently available in <code>ctx</code>, associated with the error ID obtained by calling <code>r.error()</code>. As soon as it is determined that an argument value can not be produced, the current handler is dropped and the selection process continues with the next handler, if any.</p>
</div>
<div class="paragraph">
<p>The return value of <code>r.error()</code> must be implicitly convertible to <a href="#error_id"><code>error_id</code></a>. Naturally, the <code>leaf::result</code> template satisfies this requirement. If an external <code>result</code> type is used instead, usually <code>r.error()</code> would return a <code>std::error_code</code>, which is able to communicate LEAF error IDs; see <a href="#tutorial-interoperability">Interoperability</a>.</p>
</div>
<div class="paragraph">
<p>If <code>err</code> is the <code>error_id</code> obtained from <code>r.error()</code>, each argument <code>a<sub>i</sub></code> taken by the handler currently under consideration is produced as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>a<sub>i</sub></code> is of type <code>A<sub>i</sub></code>, <code>A<sub>i</sub> const&amp;</code> or <code>A<sub>i</sub>&amp;</code>:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>If an error object of type <code>A<sub>i</sub></code>, associated with <code>err</code>, is currently available in <code>ctx</code>, <code>a<sub>i</sub></code> is initialized with a reference to that object; otherwise</p>
</li>
<li>
<p>If <code>A<sub>i</sub></code> derives from <code>std::exception</code>, and the <code>try_block</code> throws an object <code>ex</code> of type that derives from <code>std::exception</code>, LEAF obtains <code>A<sub>i</sub>* p = dynamic_cast&lt;A<sub>i</sub>*&gt;(&amp;ex)</code>. The handler is dropped if <code>p</code> is null, otherwise <code>a<sub>i</sub></code> is initialized with <code>*p</code>.</p>
</li>
<li>
<p>Otherwise the handler is dropped.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="p">....</span>
<span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">leaf</span><span class="o">::</span><span class="n">e_file_name</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">fn</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"File Name: </span><span class="se">\"</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">fn</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">'"'</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#e_file_name"><code>e_file_name</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In case the <code>try_block</code> indicates a failure, this handler will be selected if <code>ctx</code> stores an <code>e_file_name</code> associated with the error. Because this is the only supplied handler, if an <code>e_file_name</code> is not available, <code>try_handle_some</code> will return the <code>leaf::result&lt;int&gt;</code> returned by <code>f</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Print the file name, handle the error.</td>
</tr>
</table>
</div>
</li>
<li>
<p>If <code>a<sub>i</sub></code> is of type <code>A<sub>i</sub></code> <code>const*</code> or <code>A<sub>i</sub>*</code>, <code>try_handle_some</code> is always able to produce it: first it attempts to produce it as if it is taken by reference; if that fails, rather than dropping the handler, <code>a<sub>i</sub></code> is initialized with <code>0</code>.</p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="p">....</span>
<span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">leaf</span><span class="o">::</span><span class="n">e_file_name</span> <span class="k">const</span> <span class="o">*</span> <span class="n">fn</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">fn</span> <span class="p">)</span> <i class="conum" data-value="2"></i><b>(2)</b>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"File Name: </span><span class="se">\"</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">fn</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">'"'</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span>
<span class="err">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#e_file_name"><code>e_file_name</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler can be selected to handle any error, because it takes <code>e_file_name</code> as a <code>const *</code> (and nothing else).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If an <code>e_file_name</code> is available with the current error, print it.</td>
</tr>
</table>
</div>
</li>
<li>
<p>If <code>a<sub>i</sub></code> is of a predicate type <code>Pred</code> (for which <code><a href="#is_predicate">is_predicate</a>&lt;Pred&gt;::value</code> is <code>true</code>), <code>E</code> is deduced as <code>typename Pred::error_type</code>, and then:</p>
<div class="ulist">
<ul>
<li>
<p>If <code>E</code> is not <code>void</code>, and an error object <code>e</code> of type <code>E</code>, associated with <code>err</code>, is not currently stored in <code>ctx</code>, the handler is dropped; otherwise the handler is dropped  if the expression <code>Pred::evaluate(e)</code> returns <code>false</code>.</p>
</li>
<li>
<p>if <code>E</code> is <code>void</code>, and a <code>std::exception</code> was not caught, the handler is dropped; otherwise the handler is dropped if the expression <code>Pred::evaluate(e)</code>, where <code>e</code> is of type <code>std::exception const &amp;</code>, returns <code>false</code>.</p>
</li>
<li>
<p>To invoke the handler, the <code>Pred</code> argument <code>a<sub>i</sub></code> is initialized with <code>Pred{e}</code>.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See also: <a href="#predicates">Predicates</a>.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>If <code>a<sub>i</sub></code> is of type <code>error_info const &amp;</code>,  <code>try_handle_some</code> is always able to produce it.</p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="p">....</span>
<span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">leaf</span><span class="o">::</span><span class="n">error_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">info</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"leaf::error_info:"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">return</span> <span class="n">info</span><span class="p">.</span><span class="n">error</span><span class="p">();</span> <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#error_info"><code>error_info</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler matches any error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Print error information.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Return the original error, which will be returned out of <code>try_handle_some</code>.</td>
</tr>
</table>
</div>
</li>
<li>
<p>If <code>a<sub>i</sub></code> is of type <code>diagnostic_info const &amp;</code>,  <code>try_handle_some</code> is always able to produce it.</p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="p">....</span>
<span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// throws</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">leaf</span><span class="o">::</span><span class="n">diagnostic_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">info</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"leaf::diagnostic_information:"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">return</span> <span class="n">info</span><span class="p">.</span><span class="n">error</span><span class="p">();</span> <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#diagnostic_info"><code>diagnostic_info</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler matches any error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Print diagnostic information, including limited information about dropped error objects.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Return the original error, which will be returned out of <code>try_handle_some</code>.</td>
</tr>
</table>
</div>
</li>
<li>
<p>If <code>a<sub>i</sub></code> is of type <code>verbose_diagnostic_info const &amp;</code>,  <code>try_handle_some</code> is always able to produce it.</p>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="p">....</span>
<span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// throws</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">leaf</span><span class="o">::</span><span class="n">verbose_diagnostic_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">info</span><span class="p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"leaf::verbose_diagnostic_information:"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="k">return</span> <span class="n">info</span><span class="p">.</span><span class="n">error</span><span class="p">();</span> <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This handler matches any error.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Print verbose diagnostic information, including values of dropped error objects.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Return the original error, which will be returned out of <code>try_handle_some</code>.</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="types">Reference: Types</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The contents of each Reference section are organized alphabetically.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect2">
<h3 id="context"><code>context</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">context</span>
  <span class="p">{</span>
    <span class="n">context</span><span class="p">(</span> <span class="n">context</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">context</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">context</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="nl">public:</span>

    <span class="n">context</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">context</span><span class="p">(</span> <span class="n">context</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="o">~</span><span class="n">context</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">activate</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">deactivate</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">is_active</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">propagate</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">R</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">H</span><span class="p">&gt;</span>
    <span class="n">R</span> <span class="n">handle_error</span><span class="p">(</span> <span class="n">error_id</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">H</span><span class="p">&gt;</span>
  <span class="k">using</span> <span class="n">context_type_from_handlers</span> <span class="o">=</span> <span class="k">typename</span> <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">&gt;&gt;::</span><span class="n">type</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#context::context">Constructors</a> | <a href="#context::activate"><code>activate</code></a> | <a href="#context::deactivate"><code>deactivate</code></a> | <a href="#context::is_active"><code>is_active</code></a> | <a href="#context::propagate"><code>propagate</code></a> | <a href="#context::print"><code>print</code></a> | <a href="#context::handle_error"><code>handle_error</code></a> | <a href="#context_type_from_handlers"><code>context_type_from_handlers</code></a></p>
</div>
<div class="paragraph">
<p>The <code>context</code> class template provides storage for each of the specified <code>E&#8230;&#8203;</code> types. Typically, <code>context</code> objects are not used directly; they&#8217;re created internally when the <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a> functions are invoked, instantiated with types that are automatically deduced from the types of the arguments of the passed handlers.</p>
</div>
<div class="paragraph">
<p>Independently, users can create <code>context</code> objects if they need to capture error objects and then transport them, by moving the <code>context</code> object itself.</p>
</div>
<div class="paragraph">
<p>Even in that case it is recommended that users do not instantiate the <code>context</code> template by explicitly listing the <code>E&#8230;&#8203;</code> types they want it to be able to store. Instead, use <a href="#context_type_from_handlers"><code>context_type_from_handlers</code></a> or call the <a href="#make_context"><code>make_context</code></a> function template, which deduce the correct <code>E&#8230;&#8203;</code> types from a captured list of handler function objects.</p>
</div>
<div class="paragraph">
<p>To be able to load up error objects in a <code>context</code> object, it must be activated. Activating a <code>context</code> object <code>ctx</code> binds it to the calling thread, setting thread-local pointers of the stored <code>E&#8230;&#8203;</code> types to point to the corresponding storage within <code>ctx</code>. It is possible, even likely, to have more than one active <code>context</code> in any given thread. In this case, activation/deactivation must happen in a LIFO manner. For this reason, it is best to use a <a href="#context_activator"><code>context_activator</code></a>, which relies on RAII to activate and deactivate a <code>context</code>.</p>
</div>
<div class="paragraph">
<p>When a <code>context</code> is deactivated, it detaches from the calling thread, restoring the thread-local pointers to their pre-<code>activate</code> values. Typically, at this point the stored error objects, if any, are either discarded (by default) or moved to corresponding storage in other <code>context</code> objects active in the calling thread (if available), by calling <a href="#context::propagate"><code>propagate</code></a>.</p>
</div>
<div class="paragraph">
<p>While error handling typically uses <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a>, it is also possible to handle errors by calling the member function <a href="#context::handle_error"><code>handle_error</code></a>. It takes an <a href="#error_id"><code>error_id</code></a>, and attempts to select an error handler based on the error objects stored in <code>*this</code>, associated with the passed <code>error_id</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>context</code> objects can be moved, as long as they aren&#8217;t active.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Moving an active <code>context</code> results in undefined behavior.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect3">
<h4 id="context::context">Constructors</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span>
  <span class="n">context</span><span class="o">&lt;</span><span class="n">E</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">context</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span>
  <span class="n">context</span><span class="o">&lt;</span><span class="n">E</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">context</span><span class="p">(</span> <span class="n">context</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The default constructor initializes an empty <code>context</code> object: it provides storage for, but does not contain any error objects.</p>
</div>
<div class="paragraph">
<p>The move constructor moves the stored error objects from one <code>context</code> to the other.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Moving an active <code>context</code> object results in undefined behavior.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="context::activate"><code>activate</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">context</span><span class="o">&lt;</span><span class="n">E</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">activate</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p><code>!<a href="#context::is_active">is_active</a>()</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Associates <code>*this</code> with the calling thread.</p>
</dd>
<dt class="hdlist1">Ensures: </dt>
<dd>
<p><code><a href="#context::is_active">is_active</a>()</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>When a context is associated with a thread, thread-local pointers are set to point each <code>E&#8230;&#8203;</code> type in its store, while the previous value of each such pointer is preserved in the <code>context</code> object, so that the effect of <code>activate</code> can be undone by calling <code>deactivate</code>.</p>
</div>
<div class="paragraph">
<p>When an error object is <a href="#tutorial-loading">loaded</a>, it is moved in the last activated (in the calling thread) <code>context</code> object that provides storage for its type (note that this may or may not be the last activated <code>context</code> object). If no such storage is available, the error object is discarded.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="context::deactivate"><code>deactivate</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">context</span><span class="o">&lt;</span><span class="n">E</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">deactivate</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#context::is_active">is_active</a>()</code>;</p>
</li>
<li>
<p><code>*this</code> must be the last activated <code>context</code> object in the calling thread.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Un-associates <code>*this</code> with the calling thread.</p>
</dd>
<dt class="hdlist1">Ensures: </dt>
<dd>
<p><code>!<a href="#context::is_active">is_active</a>()</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>When a context is deactivated, the thread-local pointers that currently point to each individual error object storage in it are restored to their original value prior to calling <a href="#context::activate"><code>activate</code></a>.</p>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="context::handle_error"><code>handle_error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_errors.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">R</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">H</span><span class="p">&gt;</span>
  <span class="n">R</span> <span class="n">context</span><span class="o">&lt;</span><span class="n">E</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">handle_error</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">err</span><span class="p">,</span> <span class="n">H</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">h</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This function works similarly to <a href="#try_handle_all"><code>try_handle_all</code></a>, but rather than calling a <code>try_block</code> and obtaining the <a href="#error_id"><code>error_id</code></a> from a returned <code>result</code> type, it matches error objects (stored in <code>*this</code>, associated with <code>err</code>) with a suitable error handler from the <code>h&#8230;&#8203;</code> pack.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The caller is required to specify the return type <code>R</code>. This is because in general the supplied handlers may return different types (which must all be convertible to <code>R</code>).
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="context::is_active"><code>is_active</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span>
  <span class="kt">bool</span> <span class="n">context</span><span class="o">&lt;</span><span class="n">E</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">is_active</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>true</code> if the <code>*this</code> is active in any thread, <code>false</code> otherwise.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="context::print"><code>print</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">context</span><span class="o">&lt;</span><span class="n">E</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">print</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Prints all error objects currently stored in <code>*this</code>, together with the unique error ID each individual error object is associated with.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="context::propagate"><code>propagate</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/context.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">context</span><span class="o">&lt;</span><span class="n">E</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">propagate</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p><code>!<a href="#context::is_active">is_active</a>()</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Each stored error object of some type <code>E</code> is moved into another <code>context</code> object active in the call stack that provides storage for objects of type <code>E</code>, if any, or discarded.</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="context_activator"><code>context_activator</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ctx</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">context_activator</span>
  <span class="p">{</span>
    <span class="n">context_activator</span><span class="p">(</span> <span class="n">context_activator</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">context_activator</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">context_activator</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="nl">public:</span>

    <span class="k">explicit</span> <span class="n">context_activator</span><span class="p">(</span> <span class="n">Ctx</span> <span class="o">&amp;</span> <span class="n">ctx</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">context_activator</span><span class="p">(</span> <span class="n">context_activator</span> <span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="o">~</span><span class="n">context_activator</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>context_activator</code> is a simple class that activates and deactivates a <a href="#context"><code>context</code></a> using RAII:</p>
</div>
<div class="paragraph">
<p>If <code><a href="#context::is_active">ctx.is_active</a></code>() is <code>true</code> at the time the <code>context_activator</code> is initialized, the constructor and the destructor have no effects. Otherwise:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The constructor stores a reference to <code>ctx</code> in <code>*this</code> and calls <code><a href="#context::activate">ctx.activate</a></code>().</p>
</li>
<li>
<p>The destructor:</p>
<div class="ulist">
<ul>
<li>
<p>Has no effects if <code>ctx.is_active()</code> is <code>false</code> (that is, it is valid to call <a href="#context::deactivate"><code>deactivate</code></a> manually, before the <code>context_activator</code> object expires);</p>
</li>
<li>
<p>Otherwise, calls <code><a href="#context::deactivate">ctx.deactivate</a></code>() and, if there are new uncaught exceptions since the constructor was called, the destructor calls <code><a href="#context::propagate">ctx.propagate</a></code>().</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>For automatic deduction of <code>Ctx</code>, use <a href="#activate_context"><code>activate_context</code></a>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="diagnostic_info"><code>diagnostic_info</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_errors.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">class</span> <span class="nc">diagnostic_info</span><span class="o">:</span> <span class="k">public</span> <span class="n">error_info</span>
  <span class="p">{</span>
    <span class="c1">//Constructors unspecified</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">diagnostic_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">x</span> <span class="p">);</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Handlers passed to <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a> may take an argument of type <code>diagnostic_info const &amp;</code> if they need to print diagnostic information about the error.</p>
</div>
<div class="paragraph">
<p>The message printed by <code>operator&lt;&lt;</code> includes the message printed by <code>error_info</code>, followed by basic information about error objects that were communicated to LEAF (to be associated with the error) for which there was no storage available in any active <a href="#context"><code>context</code></a> (these error objects were discarded by LEAF, because no handler needed them).</p>
</div>
<div class="paragraph">
<p>The additional information is limited to the type name of the first such error object, as well as their total count.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The behavior of <code>diagnostic_info</code> (and <a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a>) is affected by the value of the macro <code>BOOST_LEAF_DIAGNOSTICS</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If it is 1 (the default), LEAF produces <code>diagnostic_info</code> but only if an active error handling context on the call stack takes an argument of type <code>diagnostic_info</code>;</p>
</li>
<li>
<p>If it is 0, the <code>diagnostic_info</code> functionality is stubbed out even for error handling contexts that take an argument of type <code>diagnostic_info</code>. This could shave a few cycles off the error path in some programs (but it is probably not worth it).</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="error_id"><code>error_id</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">class</span> <span class="nc">error_id</span>
  <span class="p">{</span>
  <span class="nl">public:</span>

    <span class="n">error_id</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Enum</span><span class="p">&gt;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">Enum</span> <span class="n">e</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_error_code_enum</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">Enum</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">*</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">error_id</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ec</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="n">to_error_code</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">a</span><span class="p">,</span> <span class="n">error_id</span> <span class="n">b</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">a</span><span class="p">,</span> <span class="n">error_id</span> <span class="n">b</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">a</span><span class="p">,</span> <span class="n">error_id</span> <span class="n">b</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Item</span><span class="p">&gt;</span>
    <span class="n">error_id</span> <span class="n">load</span><span class="p">(</span> <span class="n">Item</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">item</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">error_id</span> <span class="n">x</span> <span class="p">);</span>
  <span class="p">};</span>

  <span class="kt">bool</span> <span class="n">is_error_id</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ec</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span>
  <span class="n">error_id</span> <span class="n">new_error</span><span class="p">(</span> <span class="n">E</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">e</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="n">error_id</span> <span class="n">current_error</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#error_id::error_id">Constructors</a> | <a href="#error_id::value"><code>value</code></a> | <a href="#error_id::operator_bool"><code>operator bool</code></a> | <a href="#error_id::to_error_code"><code>to_error_code</code></a> | <a href="#error_id::comparison_operators"><code>operator==</code>, <code>!=</code>, <code>&lt;</code></a> | <a href="#error_id::load"><code>load</code></a> | <a href="#is_error_id"><code>is_error_id</code></a> | <a href="#new_error"><code>new_error</code></a> | <a href="#current_error"><code>current_error</code></a></p>
</div>
<div class="paragraph">
<p>Values of type <code>error_id</code> identify a specific occurrence of a failure across the entire program. They can be copied, moved, assigned to, and compared to other <code>error_id</code> objects. They&#8217;re as efficient as an <code>int</code>.</p>
</div>
<hr>
<div class="sect3">
<h4 id="error_id::error_id">Constructors</h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="n">error_id</span><span class="o">::</span><span class="n">error_id</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Enum</span><span class="p">&gt;</span>
  <span class="n">error_id</span><span class="o">::</span><span class="n">error_id</span><span class="p">(</span> <span class="n">Enum</span> <span class="n">e</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_error_code_enum</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">Enum</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">*</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="n">error_id</span><span class="o">::</span><span class="n">error_id</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ec</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A default-initialized <code>error_id</code> object does not represent a specific failure. It compares equal to any other default-initialized <code>error_id</code> object. All other <code>error_id</code> objects identify a specific occurrence of a failure.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
When using an object of type <code>error_id</code> to initialize a <code>result&lt;T&gt;</code> object, it will be initialized in error state, even when passing a default-initialized <code>error_id</code> value.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Converting an <code>error_id</code> object to <code>std::error_code</code> uses an unspecified <code>std::error_category</code> which LEAF recognizes. This allows an <code>error_id</code> to be transported through interfaces that work with <code>std::error_code</code>. The <code>std::error_code</code> constructor allows the original <code>error_id</code> to be restored.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
To check if a given <code>std::error_code</code> is actually carrying an <code>error_id</code>, use <a href="#is_error_id"><code>is_error_id</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Typically, users create new <code>error_id</code> objects by invoking <a href="#new_error"><code>new_error</code></a>. The constructor that takes <code>std::error_code</code>, and the one that takes a type <code>Enum</code> for which <code>std::is_error_code_enum&lt;Enum&gt;::value</code> is <code>true</code>, have the following effects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>ec.value()</code> is <code>0</code>, the effect is the same as using the default constructor.</p>
</li>
<li>
<p>Otherwise, if <code><a href="#is_error_id">is_error_id</a>(ec)</code> is <code>true</code>, the original <code>error_id</code> value is used to initialize <code>*this</code>;</p>
</li>
<li>
<p>Otherwise, <code>*this</code> is initialized by the value returned by <a href="#new_error"><code>new_error</code></a>, while <code>ec</code> is passed to <code>load</code>, which enables handlers used with <code>try_handle_some</code>, <code>try_handle_all</code> or <code>try_catch</code> to receive it as an argument of type <code>std::error_code</code>.</p>
</li>
</ul>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="is_error_id"><code>is_error_id</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="kt">bool</span> <span class="n">is_error_id</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ec</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>true</code> if <code>ec</code> uses the LEAF-specific <code>std::error_category</code> that identifies it as carrying an error ID rather than another error code; otherwise returns <code>false</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error_id::load"><code>load</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Item</span><span class="p">&gt;</span>
  <span class="n">error_id</span> <span class="n">error_id</span><span class="o">::</span><span class="n">load</span><span class="p">(</span> <span class="n">Item</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">item</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p>Each of the <code>Item&#8230;&#8203;</code> types must be no-throw movable.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>value()==0</code>, all of <code>item&#8230;&#8203;</code> are discarded and no further action is taken.</p>
</li>
<li>
<p>Otherwise, what happens with each <code>item</code> depends on its type:</p>
<div class="ulist">
<ul>
<li>
<p>If it is a function that takes a single argument of some type <code>E &amp;</code>, that function is called with the object of type <code>E</code> currently associated with <code>*this</code>. If no such object exists, a default-initialized object is associated with <code>*this</code> and then passed to the function.</p>
</li>
<li>
<p>If it is a function that takes no arguments, than function is called to obtain an error object, which is associated with <code>*this</code>.</p>
</li>
<li>
<p>Otherwise, the <code>item</code> itself is assumed to be an error object, which is associated with <code>*this</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>*this</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>load</code> discards error objects which are not used in any active error handling calling scope.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
When loaded into a <code>context</code>, an error object of a type <code>E</code> will overwrite the previously loaded object of type <code>E</code>, if any.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">See also: </dt>
<dd>
<p><a href="#tutorial-loading">Loading of Error Objects</a>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error_id::comparison_operators"><code>operator==</code>, <code>!=</code>, <code>&lt;</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">a</span><span class="p">,</span> <span class="n">error_id</span> <span class="n">b</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">a</span><span class="p">,</span> <span class="n">error_id</span> <span class="n">b</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">a</span><span class="p">,</span> <span class="n">error_id</span> <span class="n">b</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>These functions have the usual semantics, comparing <code>a.value()</code> and <code>b.value()</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The exact strict weak ordering implemented by <code>operator&lt;</code> is not specified. In particular, if for two <code>error_id</code> objects <code>a</code> and <code>b</code>, <code>a &lt; b</code> is true, it does not follow that the failure identified by <code>a</code> ocurred earlier than the one identified by <code>b</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error_id::operator_bool"><code>operator bool</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

    <span class="k">explicit</span> <span class="n">error_id</span><span class="o">::</span><span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if <code>return value()!=0</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error_id::to_error_code"><code>to_error_code</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

    <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="n">error_id</span><span class="o">::</span><span class="n">to_error_code</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Returns a <code>std::error_code</code> with the same <code>value()</code> as <code>*this</code>, using an unspecified <code>std::error_category</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The returned object can be used to initialize an <code>error_id</code>, in which case the original <code>error_id</code> value will be restored.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use <a href="#is_error_id"><code>is_error_id</code></a> to check if a given <code>std::error_code</code> carries an <code>error_id</code>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="error_id::value"><code>value</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">error_id</span><span class="o">::</span><span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>*this</code> was initialized using the default constructor, returns 0.</p>
</li>
<li>
<p>Otherwise returns an <code>int</code> that is guaranteed to not be 0: a program-wide unique identifier of the failure.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="error_monitor"><code>error_monitor</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/on_error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">class</span> <span class="nc">error_monitor</span>
  <span class="p">{</span>
  <span class="nl">public:</span>

    <span class="n">error_monitor</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">error_id</span> <span class="n">check</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">error_id</span> <span class="n">assigned_error_id</span><span class="p">(</span> <span class="n">E</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">e</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This class helps obtain an <a href="#error_id"><code>error_id</code></a> to associate error objects with, when augmenting failures communicated using LEAF through uncooperative APIs that do not use LEAF to report errors (and therefore do not return an <code>error_id</code> on error).</p>
</div>
<div class="paragraph">
<p>The common usage of this class is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">error_code</span> <span class="n">compute_value</span><span class="p">(</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">out_value</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>

<span class="n">leaf</span><span class="o">::</span><span class="n">error</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">augmenter</span><span class="p">()</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="n">leaf</span><span class="o">::</span><span class="n">error_monitor</span> <span class="n">cur_err</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">ec</span> <span class="o">=</span> <span class="n">compute_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span> <span class="n">failure</span><span class="p">(</span><span class="n">ec</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">cur_err</span><span class="p">.</span><span class="n">assigned_error_id</span><span class="p">().</span><span class="n">load</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="p">...);</span> <i class="conum" data-value="3"></i><b>(3)</b>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <i class="conum" data-value="4"></i><b>(4)</b>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Uncooperative third-party API that does not use LEAF, but may result in calling a user callback that does use LEAF. In case our callback reports a failure, we&#8217;ll augment it with error objects available in the calling scope, even though <code>compute_value</code> can not communicate an <a href="#error_id"><code>error_id</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Initialize an <code>error_monitor</code> object.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The call to <code>compute_value</code> has failed:
<div class="ulist">
<ul>
<li>
<p>If <a href="#new_error"><code>new_error</code></a> was invoked (by the calling thread) after the <code>augment</code> object was initialized, <code>assigned_error_id</code> returns the last <code>error_id</code> returned by <code>new_error</code>. This would be the case if the failure originates in our callback (invoked internally by <code>compute_value</code>).</p>
</li>
<li>
<p>Else, <code>assigned_error_id</code> invokes <code>new_error</code> and returns that <code>error_id</code>.</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The call was successful, return the computed value.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>check</code> function works similarly, but instead of invoking <code>new_error</code> it returns a default-initialized <code>error_id</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See <a href="#tutorial-on_error_in_c_callbacks">Using <code>error_monitor</code> to Report Arbitrary Errors from C-callbacks</a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="e_api_function"><code>e_api_function</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/common.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">struct</span> <span class="nc">e_api_function</span> <span class="p">{</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">value</span><span class="p">;};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>e_api_function</code> type is designed to capture the name of the API function that failed. For example, if you&#8217;re reporting an error from <code>fread</code>, you could use <code>leaf::e_api_function {"fread"}</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The passed value is stored as a C string (<code>char const *</code>), so <code>value</code> should only be initialized with a string literal.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="e_at_line"><code>e_at_line</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/common.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">struct</span> <span class="nc">e_at_line</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>e_at_line</code> can be used to communicate the line number when reporting errors (for example parse errors) about a text file.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="e_errno"><code>e_errno</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/common.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">struct</span> <span class="nc">e_errno</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">e_errno</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">err</span> <span class="p">);</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To capture <code>errno</code>, use <code>e_errno</code>. When printed in automatically-generated diagnostic messages, <code>e_errno</code> objects use <code>strerror</code> to convert the <code>errno</code> code to string.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="e_file_name"><code>e_file_name</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/common.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">struct</span> <span class="nc">e_file_name</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When a file operation fails, you could use <code>e_file_name</code> to store the name of the file.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
It is probably better to define your own file name wrappers to avoid clashes if different modules all use <code>leaf::e_file_name</code>. It is best to use a descriptive name that clarifies what kind of file name it is (e.g. <code>e_source_file_name</code>, <code>e_destination_file_name</code>), or at least define <code>e_file_name</code> in a given module&#8217;s namespace.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="e_LastError"><code>e_LastError</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/common.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">namespace</span> <span class="n">windows</span>
  <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">e_LastError</span>
    <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">value</span><span class="p">;</span>
      <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">e_LastError</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">err</span> <span class="p">);</span>
    <span class="p">};</span>
  <span class="p">}</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>e_LastError</code> is designed to communicate <code>GetLastError()</code> values on Windows.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="e_source_location"><code>e_source_location</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">struct</span> <span class="nc">e_source_location</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">file</span><span class="p">;</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">line</span><span class="p">;</span>
    <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">function</span><span class="p">;</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">e_source_location</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">x</span> <span class="p">);</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <a href="#BOOST_LEAF_NEW_ERROR"><code>BOOST_LEAF_NEW_ERROR</code></a>, <a href="#BOOST_LEAF_EXCEPTION"><code>BOOST_LEAF_EXCEPTION</code></a> and <a href="#BOOST_LEAF_THROW_EXCEPTION"><code>BOOST_LEAF_THROW_EXCEPTION</code></a> macros capture <code>__FILE__</code>, <code>__LINE__</code> and <code>__FUNCTION__</code> into a <code>e_source_location</code> object.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="e_type_info_name"><code>e_type_info_name</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/common.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">struct</span> <span class="nc">e_type_info_name</span> <span class="p">{</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>e_type_info_name</code> is designed to store the return value of <code>std::type_info::name</code>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="error_info"><code>error_info</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_errors.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">class</span> <span class="nc">error_info</span>
  <span class="p">{</span>
    <span class="c1">//Constructors unspecified</span>

  <span class="nl">public:</span>

    <span class="n">error_id</span> <span class="n">error</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">exception_caught</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="k">const</span> <span class="o">*</span> <span class="n">exception</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">error_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">x</span> <span class="p">);</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Handlers passed to error handling functions such as <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a> may take an argument of type <code>error_info const &amp;</code> to receive generic information about the error being handled.</p>
</div>
<div class="paragraph">
<p>The <code>error</code> member function returns the program-wide unique <a href="#error_id"><code>error_id</code></a> of the error.</p>
</div>
<div class="paragraph">
<p>The <code>exception_caught</code> member function returns <code>true</code> if the handler that received <code>*this</code> is being invoked to handle an exception, <code>false</code> otherwise.</p>
</div>
<div class="paragraph">
<p>If handling an exception, the <code>exception</code> member function returns a pointer to the <code>std::exception</code> subobject of the caught exception, or <code>0</code> if that exception could not be converted to <code>std::exception</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
It is illegal to call the <code>exception</code> member function unless <code>exception_caught()</code> is <code>true</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>operator&lt;&lt;</code> overload prints diagnostic information about each error object currently stored in the <a href="#context"><code>context</code></a> local to the <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a> scope that invoked the handler, but only if it is associated with the <a href="#error_id"><code>error_id</code></a> returned by <code>error()</code>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="polymorphic_context"><code>polymorphic_context</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">class</span> <span class="nc">polymorphic_context</span>
  <span class="p">{</span>
  <span class="nl">protected:</span>

    <span class="n">polymorphic_context</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="o">~</span><span class="n">polymorphic_context</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="nl">public:</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">activate</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">deactivate</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">is_active</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">propagate</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>polymorphic_context</code> class is an abstract base type which can be used to erase the type of the exact instantiation of the <a href="#context"><code>context</code></a> class template used. See <a href="#make_shared_context"><code>make_shared_context</code></a>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="result"><code>result</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">result</span>
  <span class="p">{</span>
  <span class="nl">public:</span>

    <span class="n">result</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">T</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">U</span> <span class="o">&amp;&amp;</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="n">enabled_if_T_can_be_inited_with_U</span><span class="o">&gt;&gt;</span> <span class="p">);</span>

    <span class="n">result</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">err</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">polymorphic_context</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Enum</span><span class="p">&gt;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">Enum</span> <span class="n">e</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_error_code_enum</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">Enum</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">*</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ec</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span><span class="p">(</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="n">result</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">T</span> <span class="o">&amp;</span> <span class="n">value</span><span class="p">();</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">T</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">();</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">T</span> <span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">();</span>

    <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;&gt;</span> <span class="n">error</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Item</span><span class="p">&gt;</span>
    <span class="n">error_id</span> <span class="n">load</span><span class="p">(</span> <span class="n">Item</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">item</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
  <span class="p">{</span>
  <span class="nl">public:</span>

    <span class="n">result</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span><span class="p">(</span> <span class="n">error_id</span> <span class="n">err</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">polymorphic_context</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Enum</span><span class="p">&gt;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">Enum</span> <span class="n">e</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_error_code_enum</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">Enum</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">*</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ec</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span><span class="p">(</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="n">result</span><span class="p">(</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="n">result</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="n">result</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;&gt;</span> <span class="n">error</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Item</span><span class="p">&gt;</span>
    <span class="n">error_id</span> <span class="n">load</span><span class="p">(</span> <span class="n">Item</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">item</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">struct</span> <span class="nc">bad_result</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span> <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result::result">Constructors</a> | <a href="#result::operator_eq"><code>operator=</code></a> | <a href="#result::operator_bool"><code>operator bool</code></a> | <a href="#result::value"><code>value</code>, <code>operator*</code>, <code>-></code></a> | <a href="#result::error"><code>error</code></a> | <a href="#result::load"><code>load</code></a></p>
</div>
<div class="paragraph">
<p>The <code>result&lt;T&gt;</code> type can be returned by functions which produce a value of type <code>T</code> but may fail doing so.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p><code>T</code> must be movable, and its move constructor may not throw.</p>
</dd>
<dt class="hdlist1">Invariant: </dt>
<dd>
<p>A <code>result&lt;T&gt;</code> object is in one of three states:</p>
<div class="ulist">
<ul>
<li>
<p>Value state, in which case it contains an object of type <code>T</code>, and <code><a href="#result::value">value</a></code>/<code><a href="#result::value">operator*</a></code>/<code><a href="#result::value">operator-></a></code> can be used to access the contained value.</p>
</li>
<li>
<p>Error state, in which case it contains an error ID, and calling <code><a href="#result::value">value</a></code>/<code><a href="#result::value">operator*</a></code>/<code><a href="#result::value">operator-></a></code> throws <code>leaf::bad_result</code>.</p>
</li>
<li>
<p>Error capture state, which is the same as the Error state, but in addition to the error ID, it holds a <code>std::shared_ptr&lt;<a href="#polymorphic_context">polymorphic_context</a>&gt;</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>result&lt;T&gt;</code> objects are nothrow-moveable but are not copyable.</p>
</div>
<hr>
<div class="sect3">
<h4 id="result::result">Constructors</h4>
<div class="openblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result</span><span class="p">(</span> <span class="n">T</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">v</span> <span class="p">);</span> <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
  <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result</span><span class="p">(</span> <span class="n">U</span> <span class="o">&amp;&amp;</span> <span class="n">u</span><span class="p">,</span> <span class="o">&lt;&lt;</span><span class="n">enabled_if_T_can_be_inited_with_U</span><span class="o">&gt;&gt;</span> <span class="p">);</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result</span><span class="p">(</span> <span class="n">leaf</span><span class="o">::</span><span class="n">error_id</span> <span class="n">err</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Enum</span><span class="p">&gt;</span>
  <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result</span><span class="p">(</span> <span class="n">Enum</span> <span class="n">e</span><span class="p">,</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_error_code_enum</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">Enum</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">*</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ec</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">polymorphic_context</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">ctx</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result</span><span class="p">(</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
  <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">result</span><span class="p">(</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Not available if <code>T</code> is <code>void</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Available if an object of type <code>T</code> can be initialized with <code>std::forward&lt;U&gt;(u)</code>. This is to enable e.g. <code>result&lt;std::string&gt;</code> to be initialized with a string literal.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requires: </dt>
<dd>
<p><code>T</code> must be movable, and its move constructor may not throw; or <code>void</code>.</p>
</dd>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Establishes the <code>result&lt;T&gt;</code> invariant:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>To get a <code>result&lt;T&gt;</code> in <a href="#result">Value state</a>, initialize it with an object of type <code>T</code> or use the default constructor.</p>
</li>
<li>
<p>To get a <code>result&lt;T&gt;</code> in <a href="#result">Error state</a>, initialize it with:</p>
<div class="ulist">
<ul>
<li>
<p>an <a href="#error_id"><code>error_id</code></a> object.</p>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Initializing a <code>result&lt;T&gt;</code> with a default-initialized <code>error_id</code> object (for which <code>.value()</code> returns <code>0</code>) will still result in <a href="#result">Error state</a>!
</td>
</tr>
</table>
</div>
</li>
<li>
<p>a <code>std::error_code</code> object.</p>
</li>
<li>
<p>an object of type <code>Enum</code> for which <code>std::is_error_code_enum&lt;Enum&gt;::value</code> is <code>true</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>To get a <code>result&lt;T&gt;</code> in <a href="#result">Error capture state</a>, initialize it with a <code>std::shared_ptr&lt;<a href="#polymorphic_context">polymorphic_context</a>&gt;</code> (which can be obtained by calling e.g. <a href="#make_shared_context"><code>make_shared_context</code></a>).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>When a <code>result</code> object is initialized with a <code>std::error_code</code> object, it is used to initialize an <code>error_id</code> object, then the behavior is the same as if initialized with <code>error_id</code>.</p>
</div>
</dd>
<dt class="hdlist1">Throws: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializing the <code>result&lt;T&gt;</code> in Value state may throw, depending on which constructor of <code>T</code> is invoked;</p>
</li>
<li>
<p>Other constructors do not throw.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A <code>result</code> that is in value state converts to <code>true</code> in boolean contexts. A <code>result</code> that is not in value state converts to <code>false</code> in boolean contexts.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>result&lt;T&gt;</code> objects are nothrow-moveable but are not copyable.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::error"><code>error</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">E</span><span class="p">&gt;</span>
  <span class="o">&lt;&lt;</span><span class="n">unspecified</span><span class="o">-</span><span class="n">type</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">error</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns: A proxy object of unspecified type, implicitly convertible to any instance of the <code>result</code> class template, as well as to <a href="#error_id"><code>error_id</code></a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the proxy object is converted to some <code>result&lt;U&gt;</code>:</p>
<div class="ulist">
<ul>
<li>
<p>If <code>*this</code> is in <a href="#result">Value state</a>, returns <code>result&lt;U&gt;(error_id())</code>.</p>
</li>
<li>
<p>Otherwise the state of <code>*this</code> is moved into the returned <code>result&lt;U&gt;</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the proxy object is converted to an <code>error_id</code>:</p>
<div class="ulist">
<ul>
<li>
<p>If <code>*this</code> is in <a href="#result">Value state</a>, returns a default-initialized <a href="#error_id"><code>error_id</code></a> object.</p>
</li>
<li>
<p>If <code>*this</code> is in <a href="#result">Error capture state</a>, all captured error objects are <a href="#tutorial-loading">loaded</a> in the calling thread, and the captured <code>error_id</code> value is returned.</p>
</li>
<li>
<p>If <code>*this</code> is in <a href="#result">Error state</a>, returns the stored <code>error_id</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the proxy object is not used, the state of <code>*this</code> is not modified.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The returned proxy object refers to <code>*this</code>; avoid holding on to it.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::load"><code>load</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Item</span><span class="p">&gt;</span>
  <span class="n">error_id</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">load</span><span class="p">(</span> <span class="n">Item</span> <span class="o">&amp;&amp;</span> <span class="p">...</span> <span class="n">item</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This member function is designed for use in <code>return</code> statements in functions that return <code>result&lt;T&gt;</code> to forward additional error objects to the caller.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>As if <code>error_id(this->error()).load(std::forward&lt;Item&gt;(item)&#8230;&#8203;)</code>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p><code>*this</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::operator_eq"><code>operator=</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
  <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Destroys <code>*this</code>, then re-initializes it as if using the appropriate <code>result&lt;T&gt;</code> constructor. Basic exception-safety guarantee.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::operator_bool"><code>operator bool</code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span> <span class="kt">bool</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>If <code>*this</code> is in <a href="#result">value state</a>, returns <code>true</code>, otherwise returns <code>false</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="result::value"><code>value</code>, <code>operator*</code>, <code>-></code></h4>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/result.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="kt">void</span> <span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">T</span> <span class="o">&amp;</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">();</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">T</span> <span class="o">&amp;</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">*</span><span class="p">();</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">T</span> <span class="k">const</span> <span class="o">*</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">T</span> <span class="o">*</span> <span class="n">result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">-&gt;</span><span class="p">();</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="k">struct</span> <span class="nc">bad_result</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span> <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Only when <code>T</code> is <code>void</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Only when <code>T</code> is not <code>void</code>.</td>
</tr>
</table>
</div>
<div id="result::bad_result" class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>If <code>*this</code> is in <a href="#result">value state</a>, returns a reference (or pointer) to the stored value, otherwise throws <code>bad_result</code>.</p>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="verbose_diagnostic_info"><code>verbose_diagnostic_info</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/handle_errors.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">class</span> <span class="nc">verbose_diagnostic_info</span><span class="o">:</span> <span class="k">public</span> <span class="n">error_info</span>
  <span class="p">{</span>
    <span class="c1">//Constructors unspecified</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">verbose_diagnostic_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">x</span> <span class="p">);</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Handlers passed to error handling functions such as <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> or <a href="#try_catch"><code>try_catch</code></a> may take an argument of type <code>verbose_diagnostic_info const &amp;</code> if they need to print diagnostic information about the error.</p>
</div>
<div class="paragraph">
<p>The message printed by <code>operator&lt;&lt;</code> includes the message printed by <code>error_info</code>, followed by information about error objects that were communicated to LEAF (to be associated with the error) for which there was no storage available in any active <a href="#context"><code>context</code></a> (these error objects were discarded by LEAF, because no handler needed them).</p>
</div>
<div class="paragraph">
<p>The additional information includes the types and the values of all such error objects.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The behavior of <code>verbose_diagnostic_info</code> (and <a href="#diagnostic_info"><code>diagnostic_info</code></a>) is affected by the value of the macro <code>BOOST_LEAF_DIAGNOSTICS</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If it is 1 (the default), LEAF produces <code>verbose_diagnostic_info</code> but only if an active error handling context on the call stack takes an argument of type <code>verbose_diagnostic_info</code>;</p>
</li>
<li>
<p>If it is 0, the <code>verbose_diagnostic_info</code> functionality is stubbed out even for error handling contexts that take an argument of type <code>verbose_diagnostic_info</code>. This could save some cycles on the error path in some programs (but is probably not worth it).</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Using <code>verbose_diagnostic_info</code> will likely allocate memory dynamically.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="predicates">Reference: Predicates</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The contents of each Reference section are organized alphabetically.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A predicate is a special type of error handler argument which enables the <a href="#handler_selection_procedure">handler selection procedure</a> to consider the <em>value</em> of available error objects, not only their type; see <a href="#tutorial-predicates">Using Predicates to Handle Errors</a>.</p>
</div>
<div class="paragraph">
<p>The following predicates are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#match"><code>match</code></a></p>
</li>
<li>
<p><a href="#match_value"><code>match_value</code></a></p>
</li>
<li>
<p><a href="#match_member"><code>match_member</code></a></p>
</li>
<li>
<p><a href="#catch_"><code>catch_</code></a></p>
</li>
<li>
<p><a href="#if_not"><code>if_not</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, any user-defined type <code>Pred</code> for which <code><a href="#is_predicate">is_predicate</a>&lt;Pred&gt;::value</code> is <code>true</code> is treated as a predicate. In this case, it is required that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Pred</code> defines an accessible member type <code>error_type</code> to specify the error object type it requires;</p>
</li>
<li>
<p><code>Pred</code> defines an accessible static member function <code>evaluate</code>, which returns a boolean type, and can be invoked with an object of type <code>error_type const &amp;</code>;</p>
</li>
<li>
<p>A <code>Pred</code> instance can be initialized with an object of type <code>error_type</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When an error handler takes an argument of a predicate type <code>Pred</code>, the <a href="#handler_selection_procedure">handler selection procedure</a> drops the handler if an error object <code>e</code> of type <code>Pred::error_type</code> is not available. Otherwise, the handler is dropped if <code>Pred::evaluate(e)</code> returns <code>false</code>. If the handler is invoked, the <code>Pred</code> argument is initialized with <code>Pred{e}</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Predicates are evaluated before the error handler is invoked, and so they may not access dynamic state (of course the error handler itself can access dynamic state, e.g. by means of lambda expression captures).
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example 1:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">my_error</span> <span class="p">{</span> <span class="n">e1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span> <span class="p">};</span>

<span class="k">struct</span> <span class="nc">my_pred</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">error_type</span> <span class="o">=</span> <span class="n">my_error</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="k">static</span> <span class="kt">bool</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">my_error</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="n">my_error</span> <span class="n">matched</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">&lt;</span><span class="n">my_pred</span><span class="o">&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This predicate requires an error object of type <code>my_error</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The handler selection procedure will call this function with an object <code>e</code> of type <code>my_error</code> to evaluate the predicate&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;and if successful, initialize the <code>my_pred</code> error handler argument with <code>my_pred{e}</code>.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example 2:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">struct</span> <span class="nc">my_pred</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">error_type</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">e_errno</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="k">static</span> <span class="kt">bool</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">leaf</span><span class="o">::</span><span class="n">e_errno</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="n">leaf</span><span class="o">::</span><span class="n">e_errno</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">matched</span><span class="p">;</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">&lt;</span><span class="n">my_pred</span><span class="o">&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This predicate requires an error object of type <a href="#e_errno"><code>e_errno</code></a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The handler selection procedure will call this function with an object <code>e</code> of type <code>e_errno</code> to evaluate the predicate&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;and if successful, initialize the <code>my_pred</code> error handler argument with <code>my_pred{e}</code>.</td>
</tr>
</table>
</div>
<hr>
<div class="sect2">
<h3 id="catch_"><code>catch_</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/pred.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Ex</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">catch_</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">matched</span><span class="p">;</span>

    <span class="c1">// Other members not specified</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ex</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">catch_</span><span class="o">&lt;</span><span class="n">Ex</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">Ex</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">matched</span><span class="p">;</span>

    <span class="c1">// Other members not specified</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Ex</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">&lt;</span><span class="n">catch_</span><span class="o">&lt;</span><span class="n">Ex</span><span class="p">...</span><span class="o">&gt;&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#is_predicate"><code>is_predicate</code></a></p>
</div>
<div class="paragraph">
<p>When an error handler takes an argument of type that is an instance of the <code>catch_</code> template, the <a href="#handler_selection_procedure">handler selection procedure</a> first checks if a <code>std::exception</code> was caught. If not, the handler is dropped. Otherwise, the handler is dropped if the caught <code>std::exception</code> can not be <code>dynamic_cast</code> to any of the specified types <code>Ex&#8230;&#8203;</code>.</p>
</div>
<div class="paragraph">
<p>If the error handler is invoked, the <code>matched</code> member can be used to access the exception object.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See also: <a href="#tutorial-predicates">Using Predicates to Handle Errors</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
While <code>catch_</code> requires that the caught exception object is of type that derives from <code>std::exception</code>, it is not required that the <code>Ex&#8230;&#8203;</code> types derive from <code>std::exception</code>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example 1:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">struct</span> <span class="nc">ex1</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">ex2</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span> <span class="p">};</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">try_catch</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// throws</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">leaf</span><span class="o">::</span><span class="n">catch_</span><span class="o">&lt;</span><span class="n">ex1</span><span class="p">,</span> <span class="n">ex2</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="n">assert</span><span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">ex1</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">.</span><span class="n">matched</span><span class="p">)</span> <span class="o">||</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">ex2</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">.</span><span class="n">matched</span><span class="p">));</span>
    <span class="p">....</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The handler is selected if <code>f</code> throws an exception of type <code>ex1</code> or <code>ex2</code>.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example 2:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">struct</span> <span class="nc">ex1</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span> <span class="p">};</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">ex1</span> <span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">....</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The handler is selected if <code>f</code> throws an exception of type <code>ex1</code>. Notice that if we&#8217;re interested in only one exception type, as long as that type derives from <code>std::exception</code>, the use of <code>catch_</code> is not required.</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="if_not"><code>if_not</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/pred.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">if_not</span>
  <span class="p">{</span>
    <span class="o">&lt;&lt;</span><span class="n">deduced</span><span class="o">&gt;&gt;</span> <span class="n">matched</span><span class="p">;</span>

    <span class="c1">// Other members not specified</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">P</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">&lt;</span><span class="n">if_not</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#is_predicate"><code>is_predicate</code></a></p>
</div>
<div class="paragraph">
<p>When an error handler takes an argument of type <code>if_not&lt;P&gt;</code>, where <code>P</code> is another predicate type, the <a href="#handler_selection_procedure">handler selection procedure</a> first checks if an error object of the type <code>E</code> required by <code>P</code> is available. If not, the handler is dropped. Otherwise, the handler is dropped if <code>P</code> evaluates to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>If the error handler is invoked, <code>matched</code> can be used to access the matched object <code>E</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See also <a href="#tutorial-predicates">Using Predicates to Handle Errors</a>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">my_enum</span> <span class="p">{</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span> <span class="p">};</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">if_not</span><span class="o">&lt;</span><span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">my_enum</span><span class="p">,</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e1</span><span class="p">,</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e2</span><span class="o">&gt;&gt;</span> <span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="p">....</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#match"><code>match</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The handler is selected if an object of type <code>my_enum</code>, which <span class="underline"><strong>does not</strong></span> compare equal to <code>e1</code> or to <code>e2</code>, <span class="underline"><strong>is</strong></span> associated with the detected error.</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="match"><code>match</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/pred.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">V</span><span class="p">&gt;</span>
  <span class="k">class</span> <span class="nc">match</span>
  <span class="p">{</span>
    <span class="o">&lt;&lt;</span><span class="n">deduced</span><span class="o">&gt;&gt;</span> <span class="n">matched</span><span class="p">;</span>

    <span class="c1">// Other members not specified</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">V</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">&lt;</span><span class="n">match</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span> <span class="n">V</span><span class="p">...</span><span class="o">&gt;&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#is_predicate"><code>is_predicate</code></a></p>
</div>
<div class="paragraph">
<p>When an error handler takes an argument of type <code>match&lt;E, V&#8230;&#8203;&gt;</code>, the <a href="#handler_selection_procedure">handler selection procedure</a> first checks if an error object <code>e</code> of type <code>E</code> is available. If it is not available, the handler is dropped. Otherwise, the handler is dropped if the following condition is not met:</p>
</div>
<div class="paragraph text-center">
<p><code>p<sub>1</sub> || p<sub>2</sub> || &#8230;&#8203; p<sub>n</sub></code>.</p>
</div>
<div class="paragraph">
<p>Generally, <code>p<sub>i</sub></code> is equivalent to <code>e == V<sub>i</sub></code>, except if <code>V<sub>i</sub></code> is pointer to a function</p>
</div>
<div class="paragraph text-center">
<p><code>bool (*V<sub>i</sub>)(T x)</code>.</p>
</div>
<div class="paragraph">
<p>In this case it is required that <code>V<sub>i</sub> != 0</code> and that <code>x</code> can be initialized with <code>E const &amp;</code>, and <code>p<sub>i</sub></code> is equivalent to:</p>
</div>
<div class="paragraph text-center">
<p><code>V<sub>i</sub>(e)</code>.</p>
</div>
<div id="category" class="paragraph">
<p>In particular, it is valid to pass pointer to the function <code>leaf::category&lt;Enum&gt;</code> for any <code>V<sub>i</sub></code>, where:</p>
</div>
<div class="paragraph text-center">
<p><code>std::is_error_code_enum&lt;Enum&gt;::value || std::is_error_condition_enum&lt;Enum&gt;::value</code>.</p>
</div>
<div class="paragraph">
<p>In this case, <code>p<sub>i</sub></code> is equivalent to:</p>
</div>
<div class="paragraph text-center">
<p><code>&amp;e.category() == &amp;std::error_code(Enum{}).category()</code>.</p>
</div>
<div class="paragraph">
<p>If the error handler is invoked, <code>matched</code> can be used to access <code>e</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See also <a href="#tutorial-predicates">Using Predicates to Handle Errors</a>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example 1: Handling of a subset of enum values.</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">my_enum</span> <span class="p">{</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span> <span class="p">};</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">my_enum</span><span class="p">,</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e1</span><span class="p">,</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e2</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">my_enum</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span> <span class="o">==</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e1</span> <span class="o">||</span> <span class="n">m</span><span class="p">.</span><span class="n">matched</span> <span class="o">==</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e2</span><span class="p">);</span>
    <span class="p">....</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The handler is selected if an object of type <code>my_enum</code>, which compares equal to <code>e1</code> or to <code>e2</code>, is associated with the detected error.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example 2: Handling of a subset of std::error_code enum values (requires at least C&#43;&#43;17, see Example 4 for a C&#43;&#43;11-compatible workaround).</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">my_enum</span> <span class="p">{</span> <span class="n">e1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span> <span class="p">};</span>

<span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">is_error_code_enum</span><span class="o">&lt;</span><span class="n">my_enum</span><span class="o">&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="p">,</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e1</span><span class="p">,</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e2</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span> <span class="o">==</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e1</span> <span class="o">||</span> <span class="n">m</span><span class="p">.</span><span class="n">matched</span> <span class="o">==</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e2</span><span class="p">);</span>
    <span class="p">....</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The handler is selected if an object of type <code>std::error_code</code>, which compares equal to <code>e1</code> or to <code>e2</code>, is associated with the detected error.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example 3: Handling of a specific std::error_code::category (requires at least C&#43;&#43;17).</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">enum_a</span> <span class="p">{</span> <span class="n">a1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">enum_b</span> <span class="p">{</span> <span class="n">b1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span> <span class="p">};</span>

<span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">is_error_code_enum</span><span class="o">&lt;</span><span class="n">enum_a</span><span class="o">&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{</span> <span class="p">};</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">is_error_code_enum</span><span class="o">&lt;</span><span class="n">enum_b</span><span class="o">&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="p">,</span> <span class="n">leaf</span><span class="o">::</span><span class="n">category</span><span class="o">&lt;</span><span class="n">enum_a</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">enum_b</span><span class="o">::</span><span class="n">b2</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span><span class="p">.</span><span class="n">category</span><span class="p">()</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="n">error_code</span><span class="p">(</span><span class="n">enum_</span><span class="p">{}).</span><span class="n">category</span><span class="p">()</span> <span class="o">||</span> <span class="n">m</span><span class="p">.</span><span class="n">matched</span> <span class="o">==</span> <span class="n">enum_b</span><span class="o">::</span><span class="n">b2</span><span class="p">);</span>
    <span class="p">....</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The handler is selected if an object of type <code>std::error_code</code>, which either has the same <code>std::error_category</code> as that of <code>enum_a</code> or compares equal to <code>enum_b::b2</code>, is associated with the detected error.</td>
</tr>
</table>
</div>
<div id="condition" class="paragraph">
<p>The use of the <code>leaf::category</code> template requires automatic deduction of the type of each <code>V<sub>i</sub></code>, which in turn requires C&#43;&#43;17 or newer. The same applies to the use of <code>std::error_code</code> as <code>E</code>, but LEAF provides a compatible C&#43;&#43;11 workaround for this case, using the template <code>condition</code>. The following is equivalent to Example 2:</p>
</div>
<div class="listingblock">
<div class="title">Example 4: Handling of a subset of std::error_code enum values using the C&#43;&#43;11-compatible API.</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">enum</span> <span class="k">class</span> <span class="nc">my_enum</span> <span class="p">{</span> <span class="n">e1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span> <span class="p">};</span>

<span class="k">namespace</span> <span class="n">std</span>
<span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">is_error_code_enum</span><span class="o">&lt;</span><span class="n">my_enum</span><span class="o">&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">leaf</span><span class="o">::</span><span class="n">condition</span><span class="o">&lt;</span><span class="n">my_enum</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e1</span><span class="p">,</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e2</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">error_code</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span> <span class="o">==</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e1</span> <span class="o">||</span> <span class="n">m</span><span class="p">.</span><span class="n">matched</span> <span class="o">==</span> <span class="n">my_enum</span><span class="o">::</span><span class="n">e2</span><span class="p">);</span>
    <span class="p">....</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of a set of values, the <code>match</code> template can be given pointers to functions that implement a custom comparison. In the following example, we define a handler which will be selected to handle any error that communicates an object of the user-defined type <code>severity</code> with value greater than 4:</p>
</div>
<div class="listingblock">
<div class="title">Example 5: Handling of failures with severity::value greater than a specified threshold (requires at least C&#43;&#43;17).</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">struct</span> <span class="nc">severity</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">S</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">severity_greater_than</span><span class="p">(</span> <span class="n">severity</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">e</span> <span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">e</span><span class="p">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">S</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">severity</span><span class="p">,</span> <span class="n">severity_greater_than</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;&gt;</span> <span class="n">m</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">severity</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span><span class="p">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">);</span>
    <span class="p">....</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="match_member"><code>match_member</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/pred.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">auto</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">V</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">match_member</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">T</span> <span class="n">E</span><span class="o">::*</span> <span class="n">P</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">V</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">match_member</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span> <span class="n">V</span><span class="p">...</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">E</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">matched</span><span class="p">;</span>

    <span class="c1">// Other members not specified</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">auto</span> <span class="n">P</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">V</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">&lt;</span><span class="n">match_member</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span> <span class="n">V</span><span class="p">...</span><span class="o">&gt;&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#is_predicate"><code>is_predicate</code></a></p>
</div>
<div class="paragraph">
<p>This predicate is similar to <a href="#match_value"><code>match_value</code></a>, but able to bind any accessible data member of <code>E</code>; e.g. <code>match_member&lt;&amp;E::value, V&#8230;&#8203;&gt;</code> is equivalent to <code>match_value&lt;E, V&#8230;&#8203;&gt;</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See also <a href="#tutorial-predicates">Using Predicates to Handle Errors</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>match_member</code> requires at least C&#43;&#43;17, whereas <code>match_value</code> does not.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="match_value"><code>match_value</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/pred.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">V</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">match_value</span>
  <span class="p">{</span>
    <span class="n">E</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">matched</span><span class="p">;</span>

    <span class="c1">// Other members not specified</span>
  <span class="p">};</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">E</span><span class="p">,</span> <span class="k">auto</span><span class="p">...</span> <span class="n">V</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">&lt;</span><span class="n">match_value</span><span class="o">&lt;</span><span class="n">E</span><span class="p">,</span> <span class="n">V</span><span class="p">...</span><span class="o">&gt;&gt;:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#is_predicate"><code>is_predicate</code></a></p>
</div>
<div class="paragraph">
<p>This predicate is similar to <a href="#match"><code>match</code></a>, but where <code>match</code> compares the available error object <code>e</code> of type <code>E</code> to the specified values <code>V&#8230;&#8203;</code>, <code>match_value</code> works with <code>e.value</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See also <a href="#tutorial-predicates">Using Predicates to Handle Errors</a>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">struct</span> <span class="nc">e_errno</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// returns leaf::result&lt;T&gt;</span>
  <span class="p">},</span>

  <span class="p">[](</span> <span class="n">leaf</span><span class="o">::</span><span class="n">match_value</span><span class="o">&lt;</span><span class="n">e_errno</span><span class="p">,</span> <span class="n">ENOENT</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">)</span>
  <span class="p">{</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">e_errno</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">matched</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">ENOENT</span><span class="p">);</span>
    <span class="p">....</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The handler is selected if an object of type <a href="#e_errno"><code>e_errno</code></a>, with <code>.value</code> equal to <code>ENOENT</code>, is associated with the detected error.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="traits">Reference: Traits</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The contents of each Reference section are organized alphabetically.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="is_predicate"><code>is_predicate</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/pred.hpp&gt;&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_predicate</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>is_predicate</code> template is used by the <a href="#handler_selection_procedure">handler selection procedure</a> to detect predicate types. See <a href="#tutorial-predicates">Using Predicates to Handle Errors</a>.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="is_result_type"><code>is_result_type</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span> <span class="k">namespace</span> <span class="n">leaf</span> <span class="p">{</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">R</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">is_result_type</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span>
  <span class="p">{</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The error handling functionality provided by <a href="#try_handle_some"><code>try_handle_some</code></a> and <a href="#try_handle_all"><code>try_handle_all</code></a>&#8201;&#8212;&#8201;including the ability to <a href="#tutorial-loading">load</a> error objects of arbitrary types&#8201;&#8212;&#8201;is compatible with any external <code>result&lt;T&gt;</code> type R, as long as for a given object <code>r</code> of type <code>R</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code>bool(r)</code> is <code>true</code>, <code>r</code> indicates success, in which case it is valid to call <code>r.value()</code> to recover the <code>T</code> value.</p>
</li>
<li>
<p>Otherwise <code>r</code> indicates a failure, in which case it is valid to call <code>r.error()</code>. The returned value is used to initialize an <code>error_id</code> (note: <code>error_id</code> can be initialized by <code>std::error_code</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To use an external <code>result&lt;T&gt;</code>  type R, you must specialize the <code>is_result_type</code> template so that <code>is_result_type&lt;R&gt;::value</code> evaluates to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>Naturally, the provided <code>leaf::<a href="#result">result</a>&lt;T&gt;</code> class template satisfies these requirements. In addition, it allows error objects to be transported across thread boundaries, using a <code>std::shared_ptr&lt;<a href="#polymorphic_context">polymorphic_context</a>&gt;</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="macros">Reference: Macros</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The contents of each Reference section are organized alphabetically.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect2">
<h3 id="BOOST_LEAF_ASSIGN"><code>BOOST_LEAF_ASSIGN</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="cp">#define BOOST_LEAF_ASSIGN(v, r)\
  auto &amp;&amp; &lt;&lt;temp&gt;&gt; = r;\
  if( !&lt;&lt;temp&gt;&gt; )\
    return &lt;&lt;temp&gt;&gt;.error();\
  v = std::forward&lt;decltype(&lt;&lt;temp&gt;&gt;)&gt;(&lt;&lt;temp&gt;&gt;).value()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>BOOST_LEAF_ASSIGN</code> is useful when calling a function that returns <code>result&lt;T&gt;</code> (other than <code>result&lt;void&gt;</code>), if the desired behavior is to forward any errors to the caller verbatim.</p>
</div>
<div class="paragraph">
<p>In case of success, the result <code>value()</code> of type <code>T</code> is assigned to the specified variable <code>v</code>, which must have been declared prior to invoking <code>BOOST_LEAF_ASSIGN</code>. However, it is possible to use <code>BOOST_LEAF_ASSIGN</code> to declare a new variable, by passing in <code>v</code> its type together with its name, e.g. <code>BOOST_LEAF_ASSIGN(auto &amp;&amp; x, f())</code> calls <code>f</code>, forwards errors to the caller, while capturing successful values in <code>x</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See also <a href="#BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="cp">#define BOOST_LEAF_AUTO(v, r)\
  BOOST_LEAF_ASSIGN(auto v, r)</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#BOOST_LEAF_ASSIGN"><code>BOOST_LEAF_ASSIGN</code></a></p>
</div>
<div class="paragraph">
<p><code>BOOST_LEAF_AUTO</code> is useful when calling a function that returns <code>result&lt;T&gt;</code> (other than <code>result&lt;void&gt;</code>), if the desired behavior is to forward any errors to the caller verbatim.</p>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">compute_value</span><span class="p">();</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">add_values</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">compute_value</span><span class="p">());</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">compute_value</span><span class="p">());</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="k">return</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Call <code>compute_value</code>, bail out on failure, define a local variable <code>v1</code> on success.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Call <code>compute_value</code> again, bail out on failure, define a local variable <code>v2</code> on success.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course, we could write <code>add_value</code> without using <code>BOOST_LEAF_AUTO</code>. This is equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">leaf::result&lt;float&gt; add_values()
{
  auto v1 = compute_value();
  if( !v1 )
    return v1.error();

  auto v2 = compute_value();
  if( !v2 )
    return v2.error();

  return v1.value() + v2.value();
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See also <a href="#BOOST_LEAF_ASSIGN"><code>BOOST_LEAF_ASSIGN</code></a>.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="BOOST_LEAF_CHECK"><code>BOOST_LEAF_CHECK</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="cp">#define BOOST_LEAF_CHECK(r)\
    auto &amp;&amp; &lt;&lt;temp&gt;&gt; = r;\
    if( &lt;&lt;temp&gt;&gt; )\
      ;\
    else\
      return &lt;&lt;temp&gt;&gt;.error()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>BOOST_LEAF_CHECK</code> is useful when calling a function that returns <code>result&lt;void&gt;</code>, if the desired behavior is to forward any errors to the caller verbatim.</p>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">send_message</span><span class="p">(</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">msg</span> <span class="p">);</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">compute_value</span><span class="p">();</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">say_hello_and_compute_value</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">BOOST_LEAF_CHECK</span><span class="p">(</span><span class="n">send_message</span><span class="p">(</span><span class="s">"Hello!"</span><span class="p">));</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="k">return</span> <span class="n">compute_value</span><span class="p">();</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Try to send a message, then compute a value, report errors using BOOST_LEAF_CHECK.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Equivalent implementation without <code>BOOST_LEAF_CHECK</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="nowrap">leaf::result&lt;float&gt; add_values()
{
  auto r = send_message("Hello!");
  if( !r )
    return r.error();

  return compute_value();
}</pre>
</div>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="BOOST_LEAF_EXCEPTION"><code>BOOST_LEAF_EXCEPTION</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="cp">#define BOOST_LEAF_EXCEPTION &lt;&lt;voodoo&gt;&gt;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p><code>BOOST_LEAF_EXCEPTION(e&#8230;&#8203;)</code> is equivalent to <code>leaf::<a href="#exception">exception</a>(e&#8230;&#8203;)</code>, except the current source location is automatically passed, in a <code><a href="#e_source_location"><code>e_source_location</code></a></code> object (in addition to all <code>e&#8230;&#8203;</code> objects).</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="BOOST_LEAF_NEW_ERROR"><code>BOOST_LEAF_NEW_ERROR</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/error.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="cp">#define BOOST_LEAF_NEW_ERROR &lt;&lt;voodoo&gt;&gt;</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p><code>BOOST_LEAF_NEW_ERROR(e&#8230;&#8203;)</code> is equivalent to <code>leaf::<a href="#new_error">new_error</a>(e&#8230;&#8203;)</code>, except the current source location is automatically passed, in a <code><a href="#e_source_location"><code>e_source_location</code></a></code> object (in addition to all <code>e&#8230;&#8203;</code> objects).</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="BOOST_LEAF_THROW_EXCEPTION"><code>BOOST_LEAF_THROW_EXCEPTION</code></h3>
<div class="listingblock">
<div class="title">#include &lt;boost/leaf/exception.hpp&gt;</div>
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="cp">#define BOOST_LEAF_THROW_EXCEPTION throw BOOST_LEAF_EXCEPTION</span></code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Throws the exception object returned by <a href="#BOOST_LEAF_EXCEPTION"><code>BOOST_LEAF_EXCEPTION</code></a>.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rationale">Design</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_rationale">Rationale</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Definition: </dt>
<dd>
<p>Objects that carry information about error conditions are called error objects. For example, objects of type <code>std::error_code</code> are error objects.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The following reasoning is independent of the mechanism used to transport error objects, whether it is exception handling or anything else.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Definition: </dt>
<dd>
<p>Depending on their interaction with error objects, functions can be classified as follows:</p>
<div class="ulist">
<ul>
<li>
<p><strong>Error initiating</strong>: functions that initiate error conditions by creating new error objects.</p>
</li>
<li>
<p><strong>Error neutral</strong>: functions that forward to the caller error objects communicated by lower-level functions they call.</p>
</li>
<li>
<p><strong>Error handling</strong>: functions that dispose of error objects they have received, recovering normal program operation.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>A crucial observation is that <em>error initiating</em> functions are typically low-level functions that lack any context and can not determine, much less dictate, the correct program behavior in response to the errors they may initiate. Error conditions which (correctly) lead to termination in some programs may (correctly) be ignored in others; yet other programs may recover from them and resume normal operation.</p>
</div>
<div class="paragraph">
<p>The same reasoning applies to <em>error neutral</em> functions, but in this case there is the additional issue that the errors they need to communicate, in general, are initiated by functions multiple levels removed from them in the call chain, functions which usually are&#8201;&#8212;&#8201;and should be treated as&#8201;&#8212;&#8201;implementation details. An <em>error neutral</em> function should not be coupled with error object types communicated by <em>error initiating</em> functions, for the same reason it should not be coupled with any other aspect of their interface.</p>
</div>
<div class="paragraph">
<p>Finally, <em>error handling</em> functions, by definition, have the full context they need to deal with at least some, if not all, failures. In their scope it is an absolute necessity that the author knows exactly what information must be communicated by lower level functions in order to recover from each error condition. Specifically, none of this necessary information can be treated as implementation details; in this case, the coupling which is to be avoided in <em>error neutral</em> functions is in fact desirable.</p>
</div>
<div class="paragraph">
<p>We&#8217;re now ready to define our</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Design goals: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><strong>Error initiating</strong> functions should be able to communicate <span class="underline">all</span> information available to them that is relevant to the failure being reported.</p>
</li>
<li>
<p><strong>Error neutral</strong> functions should not be coupled with error types communicated by lower-level <em>error initiating</em> functions. They should be able to augment any failure with additional relevant information available to them.</p>
</li>
<li>
<p><strong>Error handling</strong> functions should be able to access all the information communicated by <em>error initiating</em> or <em>error neutral</em> functions that is needed in order to deal with failures.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The design goal that <em>error neutral</em> functions are not coupled with the static type of error objects that pass through them seems to require dynamic polymorphism and therefore dynamic memory allocations (the Boost Exception library meets this design goal at the cost of dynamic memory allocation).</p>
</div>
<div class="paragraph">
<p>As it turns out, dynamic memory allocation is not necessary due to the following</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Fact: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><strong>Error handling</strong> functions "know" which of the information <em>error initiating</em> and <em>error neutral</em> functions are <span class="underline">able</span> to communicate is <span class="underline">actually needed</span> in order to deal with failures in a particular program. Ideally, no resources should be <span class="line-through">used</span> wasted storing or communicating information which is not currently needed to handle errors, <span class="underline">even if it is relevant to the failure</span>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For example, if a library function is able to communicate an error code but the program does not need to know the exact error code, then that information may be ignored at the time the library function attempts to communicate it. On the other hand, if an <em>error handling</em> function needs that information, the memory needed to store it can be reserved statically in its scope.</p>
</div>
<div class="paragraph">
<p>The LEAF functions <a href="#try_handle_some"><code>try_handle_some</code></a>, <a href="#try_handle_all"><code>try_handle_all</code></a> and <a href="#try_catch"><code>try_catch</code></a> implement this idea. Users provide error handling lambda functions, each taking arguments of the types it needs in order to recover from a particular error condition. LEAF simply provides the space needed to store these types (in the form of a <code>std::tuple</code>, using automatic storage duration) until they are passed to a suitable handler.</p>
</div>
<div class="paragraph">
<p>At the time this space is reserved in the scope of an error handling function, <code>thread_local</code> pointers of the required error types are set to point to the corresponding objects within it. Later on, <em>error initiating</em> or <em>error neutral</em> functions wanting to communicate an error object of a given type <code>E</code> use the corresponding <code>thread_local</code> pointer to detect if there is currently storage available for this type:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the pointer is not null, storage is available and the object is moved into the pointed storage, exactly once&#8201;&#8212;&#8201;regardless of how many levels of function calls must unwind before an <em>error handling</em> function is reached.</p>
</li>
<li>
<p>If the pointer is null, storage is not available and the error object is discarded, since no error handling function makes any use of it in this program&#8201;&#8212;&#8201;saving resources.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This almost works, except we need to make sure that <em>error handling</em> functions are protected from accessing stale error objects stored in response to previous failures, which would be a serious logic error. To this end, each occurrence of an error is assigned a unique <a href="#error_id"><code>error_id</code></a>. Each of the <code>E&#8230;&#8203;</code> objects stored in error handling scopes is assigned an <code>error_id</code> as well, permanently associating it with a particular failure.</p>
</div>
<div class="paragraph">
<p>Thus, to handle a failure we simply match the available error objects (associated with its unique <code>error_id</code>) with the argument types required by each user-provided error handling function. In terms of C&#43;&#43; exception handling, it is as if we could write something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">try</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">process_file</span><span class="p">();</span>

  <span class="c1">//Success, use r:</span>
  <span class="p">....</span>
<span class="p">}</span>

<span class="k">catch</span><span class="p">(</span><span class="n">file_read_error</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">e_file_name</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">fn</span><span class="p">,</span> <span class="n">e_errno</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span>
    <span class="s">"Could not read "</span> <span class="o">&lt;&lt;</span> <span class="n">fn</span> <span class="o">&lt;&lt;</span> <span class="s">", errno="</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">catch</span><span class="p">(</span><span class="n">file_read_error</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">e_errno</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span>
    <span class="s">"File read error, errno="</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">catch</span><span class="p">(</span><span class="n">file_read_error</span> <span class="o">&amp;</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"File read error!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course this syntax is not valid, so LEAF uses lambda functions to express the same idea:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">try_catch</span><span class="p">(</span>

  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">process_file</span><span class="p">();</span> <span class="c1">//Throws in case of failure, error objects stored inside the try_catch scope</span>

    <span class="c1">//Success, use r:</span>
    <span class="p">....</span>
  <span class="p">}</span>

  <span class="p">[](</span><span class="n">file_read_error</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">e_file_name</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">fn</span><span class="p">,</span> <span class="n">e_errno</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span>
      <span class="s">"Could not read "</span> <span class="o">&lt;&lt;</span> <span class="n">fn</span> <span class="o">&lt;&lt;</span> <span class="s">", errno="</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">file_read_error</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">e_errno</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span>
      <span class="s">"File read error, errno="</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">file_read_error</span> <span class="o">&amp;</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"File read error!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_catch"><code>try_catch</code></a> | <a href="#e_file_name"><code>e_file_name</code></a> | <a href="#e_errno"><code>e_errno</code></a></p>
</div>
<div class="paragraph">
<p>Similar syntax works without exception handling as well. Below is the same snippet, written using <code><a href="#result">result</a>&lt;T&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">return</span> <span class="n">leaf</span><span class="o">::</span><span class="n">try_handle_some</span><span class="p">(</span>

  <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
  <span class="p">{</span>
    <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">process_file</span><span class="p">());</span> <span class="c1">//In case of errors, error objects are stored inside the try_handle_some scope</span>

    <span class="c1">//Success, use r:</span>
    <span class="p">....</span>

    <span class="k">return</span> <span class="p">{</span> <span class="p">};</span>
  <span class="p">}</span>

  <span class="p">[](</span><span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">error_enum</span><span class="p">,</span> <span class="n">file_read_error</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">e_file_name</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">fn</span><span class="p">,</span> <span class="n">e_errno</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span>
      <span class="s">"Could not read "</span> <span class="o">&lt;&lt;</span> <span class="n">fn</span> <span class="o">&lt;&lt;</span> <span class="s">", errno="</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">error_enum</span><span class="p">,</span> <span class="n">file_read_error</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">e_errno</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span>
      <span class="s">"File read error, errno="</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="p">[](</span><span class="n">leaf</span><span class="o">::</span><span class="n">match</span><span class="o">&lt;</span><span class="n">error_enum</span><span class="p">,</span> <span class="n">file_read_error</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"File read error!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#try_handle_some"><code>try_handle_some</code></a> | <a href="#match"><code>match</code></a> | <a href="#e_file_name"><code>e_file_name</code></a> | <a href="#e_errno"><code>e_errno</code></a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please post questions and feedback on the Boost Developers Mailing List.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="exception_specifications">Critique 1: Error Types Do Not Participate in Function Signatures</h3>
<div class="paragraph">
<p>A knee-jerk critique of the LEAF design is that it does not statically enforce that each possible error condition is recognized and handled by the program. One idea I&#8217;ve heard from multiple sources is to add <code>E&#8230;&#8203;</code> parameter pack to <code>result&lt;T&gt;</code>, essentially turning it into <code>expected&lt;T,E&#8230;&#8203;&gt;</code>, so we could write something along these lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">expected</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">E1</span><span class="p">,</span> <span class="n">E2</span><span class="p">,</span> <span class="n">E3</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>

<span class="n">expected</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">E1</span><span class="p">,</span> <span class="n">E3</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">()</span> <span class="k">noexcept</span> <i class="conum" data-value="2"></i><b>(2)</b>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">expected</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">E1</span><span class="p">,</span> <span class="n">E2</span><span class="p">,</span> <span class="n">E3</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span> <span class="c1">//Success, return the T</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">.</span><span class="n">handle_error</span><span class="o">&lt;</span><span class="n">E2</span><span class="o">&gt;</span><span class="p">(</span> <span class="p">[]</span> <span class="p">(</span> <span class="p">....</span> <span class="p">)</span> <i class="conum" data-value="3"></i><b>(3)</b>
      <span class="p">{</span>
        <span class="p">....</span>
      <span class="p">}</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>f</code> may only return error objects of type <code>E1</code>, <code>E2</code>, <code>E3</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>g</code> narrows that to only <code>E1</code> and <code>E3</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Because <code>g</code> may only return error objects of type <code>E1</code> and <code>E3</code>, it uses <code>handle_error</code> to deal with <code>E2</code>. In case <code>r</code> contains <code>E1</code> or <code>E3</code>, <code>handle_error</code> simply returns <code>r</code>, narrowing the error type parameter pack from <code>E1, E2, E3</code> down to <code>E1, E3</code>. If <code>r</code> contains an <code>E2</code>, <code>handle_error</code> calls the supplied lambda, which is required to return one of <code>E1</code>, <code>E3</code> (or a valid <code>T</code>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The motivation here is to help avoid bugs in functions that handle errors that pop out of <code>g</code>: as long as the programmer deals with <code>E1</code> and <code>E3</code>, he can rest assured that no error is left unhandled.</p>
</div>
<div class="paragraph">
<p>Congratulations, we&#8217;ve just discovered exception specifications. The difference is that exception specifications, before being removed from C&#43;&#43;, were enforced dynamically, while this idea is equivalent to statically-enforced exception specifications, like they are in Java.</p>
</div>
<div class="paragraph">
<p>Why not use the equivalent of exception specifications, even if they are enforced statically?</p>
</div>
<div class="quoteblock">
<blockquote>
The short answer is that nobody knows how to fix exception specifications in any language, because the dynamic enforcement C&#43;&#43; chose has only different (not greater or fewer) problems than the static enforcement Java chose. &#8230;&#8203; When you go down the Java path, people love exception specifications until they find themselves all too often encouraged, or even forced, to add <code>throws Exception</code>, which immediately renders the exception specification entirely meaningless. (Example: Imagine writing a Java generic that manipulates an arbitrary type <code>T</code>).<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>
</blockquote>
<div class="attribution">
&#8212; Herb Sutter
</div>
</div>
<div class="paragraph">
<p>Consider again the example above: assuming we don&#8217;t want important error-related information to be lost, values of type <code>E1</code> and/or <code>E3</code> must be able to encode any <code>E2</code> value dynamically. But like Sutter points out, in generic contexts we don&#8217;t know what errors may result in calling a user-supplied function. The only way around that is to specify a single type (e.g. <code>std::error_code</code>) that can communicate any and all errors, which ultimately defeats the idea of using static type checking to enforce correct error handling.</p>
</div>
<div class="paragraph">
<p>That said, in every program there are certain <em>error handling</em> functions (e.g. <code>main</code>) which are required to handle any error, and it is highly desirable to be able to enforce this requirement at compile-time. In LEAF, the <code>try_handle_all</code> function implements this idea: if the user fails to supply at least one handler that will match any error, the result is a compile error. This guarantees that the scope invoking <code>try_handle_all</code> is prepared to recover from any failure.</p>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="translation">Critique 2: LEAF Does Not Facilitate Mapping Between Different Error Types</h3>
<div class="paragraph">
<p>Most C&#43;&#43; programs use multiple C and C&#43;&#43; libraries, and each library may provide its own system of error codes. But because it is difficult to define static interfaces that can communicate arbitrary error code types, a popular idea is to map each library-specific error code to a common program-wide enum.</p>
</div>
<div class="paragraph">
<p>For example, if we have&#8201;&#8212;&#8201;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">lib_a</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="n">error</span>
  <span class="p">{</span>
    <span class="n">ok</span><span class="p">,</span>
    <span class="n">ec1</span><span class="p">,</span>
    <span class="n">ec2</span><span class="p">,</span>
    <span class="p">....</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">lib_b</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="n">error</span>
  <span class="p">{</span>
    <span class="n">ok</span><span class="p">,</span>
    <span class="n">ec1</span><span class="p">,</span>
    <span class="n">ec2</span><span class="p">,</span>
    <span class="p">....</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8201;&#8212;&#8201;we could define:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">namespace</span> <span class="n">program</span>
<span class="p">{</span>
  <span class="k">enum</span> <span class="n">error</span>
  <span class="p">{</span>
    <span class="n">ok</span><span class="p">,</span>
    <span class="n">lib_a_ec1</span><span class="p">,</span>
    <span class="n">lib_a_ec2</span><span class="p">,</span>
    <span class="p">....</span>
    <span class="n">lib_b_ec1</span><span class="p">,</span>
    <span class="n">lib_b_ec2</span><span class="p">,</span>
    <span class="p">....</span>
  <span class="p">};</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An error handling library could provide conversion API that uses the C&#43;&#43; static type system to automate the mapping between the different error enums. For example, it may define a class template <code>result&lt;T,E&gt;</code> with value-or-error variant semantics, so that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>lib_a</code> errors are transported in <code>result&lt;T,lib_a::error&gt;</code>,</p>
</li>
<li>
<p><code>lib_b</code> errors are transported in <code>result&lt;T,lib_b::error&gt;</code>,</p>
</li>
<li>
<p>then both are automatically mapped to <code>result&lt;T,program::error&gt;</code> once control reaches the appropriate scope.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are several problems with this idea:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is prone to errors, both during the initial implementation as well as under maintenance.</p>
</li>
<li>
<p>It does not compose well. For example, if both of <code>lib_a</code> and <code>lib_b</code> use <code>lib_c</code>, errors that originate in <code>lib_c</code> would be obfuscated by the different APIs exposed by each of <code>lib_a</code> and <code>lib_b</code>.</p>
</li>
<li>
<p>It presumes that all errors in the program can be specified by exactly one error code, which is false.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To elaborate on the last point, consider a program that attempts to read a configuration file from three different locations: in case all of the attempts fail, it should communicate each of the failures. In theory <code>result&lt;T,E&gt;</code> handles this case well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">struct</span> <span class="nc">attempted_location</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span><span class="p">;</span>
  <span class="n">error</span> <span class="n">ec</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">config_error</span>
<span class="p">{</span>
  <span class="n">attempted_location</span> <span class="n">current_dir</span><span class="p">,</span> <span class="n">user_dir</span><span class="p">,</span> <span class="n">app_dir</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">result</span><span class="o">&lt;</span><span class="n">config</span><span class="p">,</span><span class="n">config_error</span><span class="o">&gt;</span> <span class="n">read_config</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This looks nice, until we realize what the <code>config_error</code> type means for the automatic mapping API we wanted to define: an <code>enum</code> can not represent a <code>struct</code>. It is a fact that we can not assume that all error conditions can be fully specified by an <code>enum</code>; an error handling library must be able to transport arbitrary static types efficiently.</p>
</div>
</div>
<div class="sect2">
<h3 id="errors_are_not_implementation_details">Critique 3: LEAF Does Not Treat Low Level Error Types as Implementation Details</h3>
<div class="paragraph">
<p>This critique is a combination of <a href="#exception_specifications">Critique 1</a> and <a href="#translation">Critique 2</a>, but it deserves special attention. Let&#8217;s consider this example using LEAF:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">read_line</span><span class="p">(</span> <span class="n">reader</span> <span class="o">&amp;</span> <span class="n">r</span> <span class="p">);</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">parsed_line</span><span class="o">&gt;</span> <span class="n">parse_line</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">line</span> <span class="p">);</span>

<span class="n">leaf</span><span class="o">::</span><span class="n">result</span><span class="o">&lt;</span><span class="n">parsed_line</span><span class="o">&gt;</span> <span class="n">read_and_parse_line</span><span class="p">(</span> <span class="n">reader</span> <span class="o">&amp;</span> <span class="n">r</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">read_line</span><span class="p">(</span><span class="n">r</span><span class="p">));</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="n">BOOST_LEAF_AUTO</span><span class="p">(</span><span class="n">parsed</span><span class="p">,</span> <span class="n">parse_line</span><span class="p">(</span><span class="n">line</span><span class="p">));</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="k">return</span> <span class="n">parsed</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#result"><code>result</code></a> | <a href="#BOOST_LEAF_AUTO"><code>BOOST_LEAF_AUTO</code></a></p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Read a line, forward errors to the caller.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Parse the line, forward errors to the caller.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The objection is that LEAF will forward verbatim the errors that are detected in <code>read_line</code> or <code>parse_line</code> to the caller of  <code>read_and_parse_line</code>. The premise of this objection is that such low-level errors are implementation details and should be treated as such. Under this premise, <code>read_and_parse_line</code> should act as a translator of sorts, in both directions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When called, it should translate its own arguments to call <code>read_line</code> and <code>parse_line</code>;</p>
</li>
<li>
<p>If an error is detected, it should translate the errors from the error types returned by <code>read_line</code> and <code>parse_line</code> to a higher-level type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The motivation is to isolate the caller of <code>read_and_parse_line</code> from its implementation details <code>read_line</code> and <code>parse_line</code>.</p>
</div>
<div class="paragraph">
<p>There are two possible ways to implement this translation:</p>
</div>
<div class="paragraph">
<p><strong>1)</strong> <code>read_and_parse_line</code> understands the semantics of <strong>all possible failures</strong> that may be reported by both <code>read_line</code> and <code>parse_line</code>, implementing a non-trivial mapping which both <em>erases</em> information that is considered not relevant to its caller, as well as encodes <em>different</em> semantics in the error it reports. In this case <code>read_and_parse_line</code> assumes full responsibility for describing precisely what went wrong, using its own type specifically designed for the job.</p>
</div>
<div class="paragraph">
<p><strong>2)</strong> <code>read_and_parse_line</code> returns an error object that essentially indicates which of the two inner functions failed, and also transports the original error object without understanding its semantics and without any loss of information, wrapping it in a new error type.</p>
</div>
<div class="paragraph">
<p>The problem with <strong>1)</strong> is that typically the caller of <code>read_and_parse_line</code> is not going to handle the error, but it does need to forward it to its caller. In our attempt to protect the <strong>one</strong> error handling function from "implementation details", we&#8217;ve coupled the interface of <strong>all</strong> intermediate error neutral functions with the static types of errors they do not understand and do not handle.</p>
</div>
<div class="paragraph">
<p>Consider the case where <code>read_line</code> communicates <code>errno</code> in its errors. What is <code>read_and_parse_line</code> supposed to do with e.g. <code>EACCESS</code>? Turn it into <code>READ_AND_PARSE_LINE_EACCESS</code>? To what end, other than to obfuscate the original (already complex and platform-specific) semantics of <code>errno</code>?</p>
</div>
<div class="paragraph">
<p>And what if the call to <code>read</code> is polymorphic, which is also typical? What if it involves a user-supplied function object? What kinds of errors does it return and why should <code>read_and_parse_line</code> care?</p>
</div>
<div class="paragraph">
<p>Therefore, we&#8217;re left with <strong>2)</strong>. There&#8217;s almost nothing wrong with this option, since it passes any and all error-related information from lower level functions without any loss. However, using a wrapper type to grant (presumably dynamic) access to any lower-level error type it may be transporting is cumbersome and (like Niall Douglas <a href="#interoperability">explains</a>) in general probably requires dynamic allocations. It is better to use independent error types that communicate the additional information not available in the original error object, while error handlers rely on LEAF to provide efficient access to any and all low-level error types, as needed.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_alternatives_to_leaf">Alternatives to LEAF</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/boost-exception.html">Boost Exception</a></p>
</li>
<li>
<p><a href="https://ned14.github.io/outcome">Boost Outcome</a></p>
</li>
<li>
<p><a href="https://github.com/TartanLlama/expected"><code>tl::expected</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Below we offer a comparison of Boost LEAF to Boost Exception and to Boost Outcome.</p>
</div>
<div class="sect2">
<h3 id="boost_exception">Comparison to Boost Exception</h3>
<div class="paragraph">
<p>While LEAF can be used without exception handling, in the use case when errors are communicated by throwing exceptions, it can be viewed as a better, more efficient alternative to Boost Exception. LEAF has the following advantages over Boost Exception:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>LEAF does not allocate memory dynamically;</p>
</li>
<li>
<p>LEAF does not waste system resources communicating error objects not used by specific error handling functions;</p>
</li>
<li>
<p>LEAF does not store the error objects in the exception object, and therefore it is able to augment exceptions thrown by external libraries (Boost Exception can only augment exceptions of types that derive from <code>boost::exception</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following tables outline the differences between the two libraries which should be considered when code that uses Boost Exception is refactored to use LEAF instead.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is possible to access Boost Exception error information using the LEAF error handling interface. See <a href="#tutorial-boost_exception_integration">Boost Exception Integration</a>.
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 1. Defining a custom type for transporting values of type T</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">typedef</span> <span class="n">error_info</span><span class="o">&lt;</span><span class="k">struct</span> <span class="nc">my_info_</span><span class="p">,</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">my_info</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/error_info.html"><code>boost::error_info</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">struct</span> <span class="nc">my_info</span> <span class="p">{</span> <span class="n">T</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span></code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 2. Passing arbitrary info at the point of the throw</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">throw</span> <span class="nf">my_exception</span><span class="p">()</span> <span class="o">&lt;&lt;</span>
  <span class="n">my_info</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
  <span class="n">my_info</span><span class="p">(</span><span class="n">y</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception_operator_shl.html"><code>operator&lt;&lt;</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">throw</span> <span class="n">leaf</span><span class="o">::</span><span class="n">exception</span><span class="p">(</span> <span class="n">my_exception</span><span class="p">(),</span>
  <span class="n">my_info</span><span class="p">{</span><span class="n">x</span><span class="p">},</span>
  <span class="n">my_info</span><span class="p">{</span><span class="n">y</span><span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#exception"><code>exception</code></a></p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 3. Augmenting exceptions in error neutral contexts</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">try</span>
<span class="p">{</span>
  <span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span> <span class="n">boost</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span> <span class="n">e</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">my_info</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="k">throw</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception.html"><code>boost::exception</code></a> | <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception_operator_shl.html"><code>operator&lt;&lt;</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">auto</span> <span class="n">load</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">::</span><span class="n">on_error</span><span class="p">(</span> <span class="n">my_info</span><span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="p">);</span>

<span class="n">f</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#on_error"><code>on_error</code></a></p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 4. Obtaining arbitrary info at the point of the catch</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">try</span>
<span class="p">{</span>
  <span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span> <span class="n">my_exception</span> <span class="o">&amp;</span> <span class="n">e</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span> <span class="n">T</span> <span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="n">get_error_info</span><span class="o">&lt;</span><span class="n">my_info</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//my_info is available in e.</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/get_error_info.html"><code>boost::get_error_info</code></a></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="n">leaf</span><span class="o">::</span><span class="n">try_catch</span><span class="p">(</span>
  <span class="p">[]</span>
  <span class="p">{</span>
    <span class="n">f</span><span class="p">();</span> <span class="c1">// throws</span>
  <span class="p">}</span>
  <span class="p">[](</span><span class="n">my_exception</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">my_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">//my_info is available with</span>
    <span class="c1">//the caught exception.</span>
  <span class="p">}</span> <span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#try_catch"><code>try_catch</code></a></p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 5. Transporting of error objects</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>All supplied <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/error_info.html"><code>boost::error_info</code></a> objects are allocated dynamically and stored in the <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception.html"><code>boost::exception</code></a> subobject of exception objects.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>User-defined error objects are stored statically in the scope of <a href="#try_catch"><code>try_catch</code></a>, but only if their types are needed to handle errors; otherwise they are discarded.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 6. Transporting of error objects across thread boundaries</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="https://www.boost.org/doc/libs/release/libs/exception/doc/exception_ptr.html"><code>boost::exception_ptr</code></a> automatically captures <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/error_info.html"><code>boost::error_info</code></a> objects stored in a <code>boost::exception</code> and can transport them across thread boundaries.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Transporting error objects across thread boundaries requires the use of <a href="#capture"><code>capture</code></a>.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stripes-none stretch">
<caption class="title">Table 7. Printing of error objects in automatically-generated diagnostic information messages</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Boost Exception</th>
<th class="tableblock halign-left valign-top">LEAF</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>boost::error_info</code> types may define conversion to <code>std::string</code> by providing <code>to_string</code> overloads <strong>or</strong> by overloading <code>operator&lt;&lt;</code> for <code>std::ostream</code>.</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>LEAF does not use <code>to_string</code>. Error types may define <code>operator&lt;&lt;</code> overloads for <code>std::ostream</code>.</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The fact that Boost Exception stores all supplied <code>boost::error_info</code> objects&#8201;&#8212;&#8201;while LEAF discards them if they aren&#8217;t needed&#8201;&#8212;&#8201;affects the completeness of the message we get when we print <code>leaf::<a href="#diagnostic_info">diagnostic_info</a></code> objects, compared to the string returned by <a href="https://www.boost.org/doc/libs/release/libs/exception/doc/diagnostic_information.html"><code>boost::diagnostic_information</code></a>.</p>
</div>
<div class="paragraph">
<p>If the user requires a complete diagnostic message, the solution is to use <code>leaf::<a href="#verbose_diagnostic_info">verbose_diagnostic_info</a></code>. In this case, before unused error objects are discarded by LEAF, they are converted to string and printed. Note that this allocates memory dynamically.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="boost_outcome">Comparison to Boost Outcome</h3>
<div class="sect3">
<h4 id="_design_differences">Design Differences</h4>
<div class="paragraph">
<p>Like LEAF, the <a href="https://ned14.github.io/outcome">Boost Outcome</a> library is designed to work in low latency environments. It provides two class templates, <code>result&lt;&gt;</code> and <code>outcome&lt;&gt;</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>result&lt;T,EC,NVP&gt;</code> can be used as the return type in <code>noexcept</code> functions which may fail, where <code>T</code> specifies the type of the return value in case of success, while <code>EC</code> is an "error code" type. Semantically, <code>result&lt;T,EC&gt;</code> is similar to <code>std::variant&lt;T,EC&gt;</code>. Naturally, <code>EC</code> defaults to <code>std::error_code</code>.</p>
</li>
<li>
<p><code>outcome&lt;T,EC,EP,NVP&gt;</code> is similar to <code>result&lt;&gt;</code>, but in case of failure, in addition to the "error code" type <code>EC</code> it can hold a "pointer" object of type <code>EP</code>, which defaults to <code>std::exception_ptr</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>NVP</code> is a policy type used to customize the behavior of <code>.value()</code> when the <code>result&lt;&gt;</code> or the <code>outcome&lt;&gt;</code> object contains an error.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The idea is to use <code>result&lt;&gt;</code> to communicate failures which can be fully specified by an "error code", and <code>outcome&lt;&gt;</code> to communicate failures that require additional information.</p>
</div>
<div class="paragraph">
<p>Another way to describe this design is that <code>result&lt;&gt;</code> is used when it suffices to return an error object of some static type <code>EC</code>, while <code>outcome&lt;&gt;</code> can also transport a polymorphic error object, using the pointer type <code>EP</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the default configuration of <code>outcome&lt;T&gt;</code> the additional information&#8201;&#8212;&#8201;or the additional polymorphic object&#8201;&#8212;&#8201;is an exception object held by <code>std::exception_ptr</code>. This targets the use case when an exception thrown by a lower-level library function needs to be transported through some intermediate contexts that are not exception-safe, to a higher-level context able to handle it. LEAF directly supports this use as well, see <a href="#exception_to_result"><code>exception_to_result</code></a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Similar reasoning drives the design of LEAF as well. The difference is that while both libraries recognize the need to transport "something else" in addition to an "error code", LEAF provides an efficient solution to this problem, while Outcome shifts this burden to the user.</p>
</div>
<div class="paragraph">
<p>The <code>leaf::result&lt;&gt;</code> template deletes both <code>EC</code> and <code>EP</code>, which decouples it from the type of the error objects that are transported in case of a failure. This enables lower-level functions to freely communicate anything and everything they "know" about the failure: error code, even multiple error codes, file names, URLs, port numbers, etc. At the same time, the higher-level error handling functions control which of this information is needed in a specific client program and which is not. This is ideal, because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Authors of lower-level library functions lack context to determine which of the information that is both relevant to the error <em>and</em> naturally available to them needs to be communicated in order for a particular client program to recover from that error;</p>
</li>
<li>
<p>Authors of higher-level error handling functions can easily and confidently make this determination, which they communicate naturally to LEAF, by simply writing the different error handlers. LEAF will transport the needed error objects while discarding the ones handlers don&#8217;t care to use, saving resources.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The LEAF examples include an adaptation of the program from the <a href="https://ned14.github.io/outcome/tutorial/essential/result/">Boost Outcome <code>result&lt;&gt;</code> tutorial</a>. You can <a href="https://github.com/boostorg/leaf/blob/master/example/print_half.cpp?ts=4">view it on GitHub</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Programs using LEAF for error handling are not required to use <code>leaf::result&lt;T&gt;</code>; for example, it is possible to use <code>outcome::result&lt;T&gt;</code> with LEAF.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="interoperability">The Interoperability Problem</h4>
<div class="paragraph">
<p>The Boost Outcome documentation discusses the important problem of bringing together multiple libraries&#8201;&#8212;&#8201;each using its own error reporting mechanism&#8201;&#8212;&#8201;and incorporating them in a robust error handling infrastructure in a client program.</p>
</div>
<div class="paragraph">
<p>Users are advised that whenever possible they should use a common error handling system throughout their entire codebase, but because this is not practical, both the <code>result&lt;&gt;</code> and the <code>outcome&lt;&gt;</code> templates can carry user-defined "payloads".</p>
</div>
<div class="paragraph">
<p>The following analysis is from the Boost Outcome documentation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>If library A uses <code>result&lt;T, libraryA::failure_info&gt;</code>, and library B uses <code>result&lt;T, libraryB::error_info&gt;</code> and so on, there becomes a problem for the application writer who is bringing in these third party dependencies and tying them together into an application. As a general rule, each third party library author will not have built in explicit interoperation support for unknown other third party libraries. The problem therefore lands with the application writer.</p>
</div>
<div class="paragraph">
<p>The application writer has one of three choices:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>In the application, the form of result used is <code>result&lt;T, std::variant&lt;E1, E2, &#8230;&#8203;&gt;&gt;</code> where <code>E1, E2 …</code> are the failure types for every third party library in use in the application. This has the advantage of preserving the original information exactly, but comes with a certain amount of use inconvenience and maybe excessive coupling between high level layers and implementation detail.</p>
</li>
<li>
<p>One can translate/map the third party’s failure type into the application’s failure type at the point of the failure exiting the third party library and entering the application. One might do this, say, with a C preprocessor macro wrapping every invocation of the third party API from the application. This approach may lose the original failure detail, or mis-map under certain circumstances if the mapping between the two systems is not one-one.</p>
</li>
<li>
<p>One can type erase the third party’s failure type into some application failure type, which can later be reconstituted if necessary. <strong>This is the cleanest solution with the least coupling issues and no problems with mis-mapping</strong>, but it almost certainly requires the use of <code>malloc</code> which the previous two did not.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>The analysis above (emphasis added) is clear and precise, but LEAF and Boost Outcome tackle the interoperability problem differently:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The Boost Outcome design asserts that the "cleanest" solution based on type-erasure is suboptimal ("almost certainly requires the use of <code>malloc</code>"), and instead provides a system for injecting custom converters into the <code>outcome::convert</code> namespace, used to translate between library-specific and program-wide error types, even though this approach "may lose the original failure detail".</p>
</li>
<li>
<p>The LEAF design asserts that coupling the signatures of <a href="#rationale">error neutral</a> functions with the static types of the error objects they need to forward to the caller <a href="#translation">does not scale</a>, and instead transports error objects directly to error handling scopes where they are stored statically, effectively implementing the third choice outlined above (without the use of <code>malloc</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Further, consider that Outcome aims to hopefully become <em>the</em> one error handling API all libraries would use, and in theory everyone would benefit from uniformity and standardization. But the reality is that this is wishful thinking. In fact, that reality is reflected in the design of <code>outcome::result&lt;&gt;</code>, in its lack of commitment to using <code>std::error_code</code> for its intended purpose: to be <em>the</em> standard type for transporting error codes. The fact is that <code>std::error_code</code> became <em>yet another</em> error code type programmers need to understand and support.</p>
</div>
<div class="paragraph">
<p>In contrast, the design of LEAF acknowledges that C&#43;&#43; programmers don&#8217;t even agree on what a string is. If your project uses 10 different libraries, this probably means 15 different ways to report errors, sometimes across uncooperative interfaces (e.g. C APIs). LEAF helps you get the job done.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_benchmark">Benchmark</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/boostorg/leaf/blob/master/benchmark/benchmark.md">This benchmark</a> compares the performance of LEAF, Boost Outcome and <code>tl::expected</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_running_the_unit_tests">Running the Unit Tests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The unit tests can be run with <a href="https://mesonbuild.com">Meson Build</a> or with Boost Build. To run the unit tests:</p>
</div>
<div class="sect2">
<h3 id="_meson_build">Meson Build</h3>
<div class="paragraph">
<p>Clone LEAF into any local directory and execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="sh"><span class="nb">cd </span>leaf
meson bld/debug
<span class="nb">cd </span>bld/debug
meson <span class="nb">test</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>See <code>meson_options.txt</code> found in the root directory for available build options.</p>
</div>
</div>
<div class="sect2">
<h3 id="_boost_build">Boost Build</h3>
<div class="paragraph">
<p>Assuming the current working directory is <code>&lt;boostroot&gt;/libs/leaf</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="sh">../../b2 <span class="nb">test</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration">Configuration Macros</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following configuration macros are recognized:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BOOST_LEAF_DIAGNOSTICS</code>: Defining this macro to <code>0</code> stubs out both <a href="#diagnostic_info"><code>diagnostic_info</code></a> and <a href="#verbose_diagnostic_info"><code>verbose_diagnostic_info</code></a>, which could improve the performance of the error path in some programs (if the macro is left undefined, LEAF defines it as <code>1</code>).</p>
</li>
<li>
<p><code>BOOST_LEAF_NO_EXCEPTIONS</code>: Disables all exception handling support. If left undefined, LEAF defines it based on the compiler configuration (e.g. <code>-fno-exceptions</code>).</p>
</li>
<li>
<p><code>BOOST_LEAF_NO_THREADS</code>: Disable all multi-thread support.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_limitations">Limitations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LEAF requires C&#43;&#43;11, including <code>thread_local</code> support, except when compiled with <code>BOOST_LEAF_NO_THREADS</code> (which can be useful on some embedded platforms).</p>
</div>
<div class="paragraph">
<p>When using dynamic linking, it is required that error types are declared with <code>default</code> visibility, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight nowrap"><code data-lang="c++"><span class="k">struct</span> <span class="nc">__attribute__</span> <span class="p">((</span><span class="n">visibility</span> <span class="p">(</span><span class="s">"default"</span><span class="p">)))</span> <span class="n">my_error_info</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This works as expected except on Windows, where thread-local storage is not shared between the individual binary modules. For this reason, to transport error objects across DLL boundaries, it is required that they&#8217;re captured in a <a href="#polymorphic_context"><code>polymorphic_context</code></a>, just like when <a href="#tutorial-async">Transporting Error Objects Between Threads</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When using dynamic linking, it is always best to define module interfaces in terms of C (and implement them in C&#43;&#43; if appropriate).
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_acknowledgements">Acknowledgements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Special thanks to Peter Dimov and Sorin Fetche.</p>
</div>
<div class="paragraph">
<p>Ivo Belchev, Sean Palmer, Jason King, Vinnie Falco, Glen Fernandes, Augustín Bergé&#8201;&#8212;&#8201;thanks for the valuable feedback.</p>
</div>
<div class="paragraph">
<p>Documentation rendered by <a href="https://asciidoctor.org/">Asciidoctor</a> with <a href="https://github.com/zajo/asciidoctor_skin">these customizations</a>.</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. <a href="https://herbsutter.com/2007/01/24/questions-about-exception-specifications/" class="bare">https://herbsutter.com/2007/01/24/questions-about-exception-specifications/</a>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>