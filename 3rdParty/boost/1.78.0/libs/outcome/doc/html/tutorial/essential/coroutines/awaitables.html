<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Coroutine awaitables - Boost.Outcome documentation</title>
<link rel="stylesheet" href="../../../css/boost.css" type="text/css">
<meta name="generator" content="Hugo 0.52 with Boostdoc theme">
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>

<link rel="icon" href="../../../images/favicon.ico" type="image/ico"/>
<body><div class="spirit-nav">
<a accesskey="p" href="../../../tutorial/essential/coroutines/try.html"><img src="../../../images/prev.png" alt="Prev"></a>
    <a accesskey="u" href="../../../tutorial/essential/coroutines.html"><img src="../../../images/up.png" alt="Up"></a>
    <a accesskey="h" href="../../../index.html"><img src="../../../images/home.png" alt="Home"></a><a accesskey="n" href="../../../tutorial/essential/coroutines/returning.html"><img src="../../../images/next.png" alt="Next"></a></div><div id="content">
  <div class="titlepage"><div><div><h1 style="clear: both">Coroutine awaitables</h1></div></div></div>
  <p>The second part of the support is provided by header <code>&lt;boost/outcome/coroutine_support.hpp&gt;</code>
(or <code>&lt;boost/outcome/experimental/coroutine_support.hpp&gt;</code> if you want Coroutine support for
Experimental Outcome). This adds into namespace <code>BOOST_OUTCOME_V2_NAMESPACE::awaitables</code> (or
<code>BOOST_OUTCOME_V2_NAMESPACE::experimental::awaitables</code>) these awaitable types suitable
for returning from a Coroutinised function:</p>

<ul>
<li><a href="../../../reference/types/awaitables/eager.html" class="api-reference"><code>eager&lt;T&gt;</code></a>


<p>An eagerly evaluated Coroutine: invoking <code>co_await</code> upon a function returning one
of these immediately begins the execution of the function now. If the function never
suspends, the overhead is similar to calling an ordinary function.</p></li>

<li><a href="../../../reference/types/awaitables/lazy.html" class="api-reference"><code>lazy&lt;T&gt;</code></a>


<p>A lazily evaluated Coroutine (often named <code>task&lt;T&gt;</code> in most C++ Coroutine
literature): invoking <code>co_await</code> upon a function returning one of these causes the
function to be immediately suspended as soon as execution begins. Only resuming
the execution of the coroutine proceeds execution.</p></li>

<li><p><code>atomic_eager&lt;T&gt;</code></p>

<p><code>eager&lt;T&gt;</code> does not employ thread synchronisation during resumption of dependent
coroutines which is fine if you do not traverse kernel threads during a
suspend-resume cycle. If you do however potentially traverse kernel threads
during suspend-resume, you ought to use <code>atomic_eager&lt;T&gt;</code> instead &ndash; this uses
atomics to synchronise the setting and checking of state to ensure correctness.</p></li>

<li><p><code>atomic_lazy&lt;T&gt;</code></p>

<p>Same for <code>lazy&lt;T&gt;</code> as <code>atomic_eager&lt;T&gt;</code> is for <code>eager&lt;T&gt;</code>.</p></li>
</ul>


        </div><p><small>Last revised: April 07, 2020 at 10:22:38 &#43;0100</small></p>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../../../tutorial/essential/coroutines/try.html"><img src="../../../images/prev.png" alt="Prev"></a>
    <a accesskey="u" href="../../../tutorial/essential/coroutines.html"><img src="../../../images/up.png" alt="Up"></a>
    <a accesskey="h" href="../../../index.html"><img src="../../../images/home.png" alt="Home"></a><a accesskey="n" href="../../../tutorial/essential/coroutines/returning.html"><img src="../../../images/next.png" alt="Next"></a></div></body>
</html>
