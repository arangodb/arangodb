<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Boost.Locale: Boundary Analysis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="boost-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Locale
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__boundary.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Boundary Analysis</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boost::locale::boundary::boundary_point&lt; IteratorType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a boundary point in the text.  <a href="classboost_1_1locale_1_1boundary_1_1boundary__point.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1locale_1_1boundary_1_1break__info.html">boost::locale::boundary::break_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used for representing boundary point that follows the offset.  <a href="structboost_1_1locale_1_1boundary_1_1break__info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__indexing.html">boost::locale::boundary::boundary_indexing&lt; CharType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This facet generates an index for boundary analysis for a given text.  <a href="classboost_1_1locale_1_1boundary_1_1boundary__indexing.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index&lt; BaseIterator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds an index of segments in the text range and allows to iterate over them.  <a href="classboost_1_1locale_1_1boundary_1_1segment__index.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds an index of <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary points</a> and allows iterating over them.  <a href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment.html">boost::locale::boundary::segment&lt; IteratorType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a segment object that represents a pair of two iterators that define the range where this segment exits and a rule that defines it.  <a href="classboost_1_1locale_1_1boundary_1_1segment.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7b4dd7af8fad53fabd77e629da24d466"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; break_info &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga7b4dd7af8fad53fabd77e629da24d466">boost::locale::boundary::index_type</a></td></tr>
<tr class="separator:ga7b4dd7af8fad53fabd77e629da24d466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f2faacb9d196ebc659ad5382ea2ca5"><td class="memItemLeft" align="right" valign="top">typedef BaseIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::base_iterator</a></td></tr>
<tr class="separator:ga06f2faacb9d196ebc659ad5382ea2ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7a775e77dbbca3495e11d646df96fd2"><td class="memItemLeft" align="right" valign="top">typedef unspecified_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::iterator</a></td></tr>
<tr class="separator:gaf7a775e77dbbca3495e11d646df96fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f8e61b5babc3f0fa95f5fb8acae3724"><td class="memItemLeft" align="right" valign="top">typedef unspecified_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga5f8e61b5babc3f0fa95f5fb8acae3724">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::const_iterator</a></td></tr>
<tr class="separator:ga5f8e61b5babc3f0fa95f5fb8acae3724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga067c663d18faee08adb3355701ae72ba"><td class="memItemLeft" align="right" valign="top">typedef segment&lt; base_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga067c663d18faee08adb3355701ae72ba">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::value_type</a></td></tr>
<tr class="separator:ga067c663d18faee08adb3355701ae72ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3189e2eaf4386cdf37598e0ba16cfd5"><td class="memItemLeft" align="right" valign="top">typedef BaseIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::base_iterator</a></td></tr>
<tr class="separator:gab3189e2eaf4386cdf37598e0ba16cfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1af6e72b3c384edcebc0cf319fe97efe"><td class="memItemLeft" align="right" valign="top">typedef unspecified_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::iterator</a></td></tr>
<tr class="separator:ga1af6e72b3c384edcebc0cf319fe97efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9ce9158eb2fb030c1baf93376203d16"><td class="memItemLeft" align="right" valign="top">typedef unspecified_iterator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gac9ce9158eb2fb030c1baf93376203d16">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::const_iterator</a></td></tr>
<tr class="separator:gac9ce9158eb2fb030c1baf93376203d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7328a860cf485a4bd8f17658c291e1"><td class="memItemLeft" align="right" valign="top">typedef boundary_point<br class="typebreak"/>
&lt; base_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga7f7328a860cf485a4bd8f17658c291e1">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::value_type</a></td></tr>
<tr class="separator:ga7f7328a860cf485a4bd8f17658c291e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4785439a3f03ee455c93830b8f1366c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4785439a3f03ee455c93830b8f1366c"></a>
typedef segment_index<br class="typebreak"/>
&lt; std::string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad4785439a3f03ee455c93830b8f1366c">boost::locale::boundary::ssegment_index</a></td></tr>
<tr class="memdesc:gad4785439a3f03ee455c93830b8f1366c"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:gad4785439a3f03ee455c93830b8f1366c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579cfdfccf9c682ac4dae5fb65d4a843"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga579cfdfccf9c682ac4dae5fb65d4a843"></a>
typedef segment_index<br class="typebreak"/>
&lt; std::wstring::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga579cfdfccf9c682ac4dae5fb65d4a843">boost::locale::boundary::wssegment_index</a></td></tr>
<tr class="memdesc:ga579cfdfccf9c682ac4dae5fb65d4a843"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:ga579cfdfccf9c682ac4dae5fb65d4a843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fff9ef7a0971ed3c686f3e8d5c56bf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6fff9ef7a0971ed3c686f3e8d5c56bf4"></a>
typedef segment_index<br class="typebreak"/>
&lt; std::u16string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga6fff9ef7a0971ed3c686f3e8d5c56bf4">boost::locale::boundary::u16ssegment_index</a></td></tr>
<tr class="memdesc:ga6fff9ef7a0971ed3c686f3e8d5c56bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:ga6fff9ef7a0971ed3c686f3e8d5c56bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a7b82f5a7e29bd079dd48ca13b79f20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3a7b82f5a7e29bd079dd48ca13b79f20"></a>
typedef segment_index<br class="typebreak"/>
&lt; std::u32string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga3a7b82f5a7e29bd079dd48ca13b79f20">boost::locale::boundary::u32ssegment_index</a></td></tr>
<tr class="memdesc:ga3a7b82f5a7e29bd079dd48ca13b79f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:ga3a7b82f5a7e29bd079dd48ca13b79f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82c153957bff0be844a5ce4490d4e7f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82c153957bff0be844a5ce4490d4e7f8"></a>
typedef segment_index&lt; char <br class="typebreak"/>
const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga82c153957bff0be844a5ce4490d4e7f8">boost::locale::boundary::csegment_index</a></td></tr>
<tr class="memdesc:ga82c153957bff0be844a5ce4490d4e7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:ga82c153957bff0be844a5ce4490d4e7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ce0d14d0466a28c205b5dc9d0d6a36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29ce0d14d0466a28c205b5dc9d0d6a36"></a>
typedef segment_index&lt; wchar_t <br class="typebreak"/>
const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga29ce0d14d0466a28c205b5dc9d0d6a36">boost::locale::boundary::wcsegment_index</a></td></tr>
<tr class="memdesc:ga29ce0d14d0466a28c205b5dc9d0d6a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:ga29ce0d14d0466a28c205b5dc9d0d6a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa20a99d93e3202680bb0660481e1d414"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa20a99d93e3202680bb0660481e1d414"></a>
typedef segment_index<br class="typebreak"/>
&lt; char16_t const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaa20a99d93e3202680bb0660481e1d414">boost::locale::boundary::u16csegment_index</a></td></tr>
<tr class="memdesc:gaa20a99d93e3202680bb0660481e1d414"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:gaa20a99d93e3202680bb0660481e1d414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc781106af79ec27693fa8012d54cb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaacc781106af79ec27693fa8012d54cb9"></a>
typedef segment_index<br class="typebreak"/>
&lt; char32_t const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaacc781106af79ec27693fa8012d54cb9">boost::locale::boundary::u32csegment_index</a></td></tr>
<tr class="memdesc:gaacc781106af79ec27693fa8012d54cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:gaacc781106af79ec27693fa8012d54cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga485e82cdd9debd15dc4fd6f57be10727"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga485e82cdd9debd15dc4fd6f57be10727"></a>
typedef boundary_point_index<br class="typebreak"/>
&lt; std::string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga485e82cdd9debd15dc4fd6f57be10727">boost::locale::boundary::sboundary_point_index</a></td></tr>
<tr class="memdesc:ga485e82cdd9debd15dc4fd6f57be10727"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:ga485e82cdd9debd15dc4fd6f57be10727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad539aad8c788c8e90cdf08aeed5df4a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad539aad8c788c8e90cdf08aeed5df4a3"></a>
typedef boundary_point_index<br class="typebreak"/>
&lt; std::wstring::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad539aad8c788c8e90cdf08aeed5df4a3">boost::locale::boundary::wsboundary_point_index</a></td></tr>
<tr class="memdesc:gad539aad8c788c8e90cdf08aeed5df4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:gad539aad8c788c8e90cdf08aeed5df4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba43501d4ed1922c9446db3bf14a918f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba43501d4ed1922c9446db3bf14a918f"></a>
typedef boundary_point_index<br class="typebreak"/>
&lt; std::u16string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaba43501d4ed1922c9446db3bf14a918f">boost::locale::boundary::u16sboundary_point_index</a></td></tr>
<tr class="memdesc:gaba43501d4ed1922c9446db3bf14a918f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:gaba43501d4ed1922c9446db3bf14a918f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1379f8968dd611be0b59d04218a1aae8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1379f8968dd611be0b59d04218a1aae8"></a>
typedef boundary_point_index<br class="typebreak"/>
&lt; std::u32string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga1379f8968dd611be0b59d04218a1aae8">boost::locale::boundary::u32sboundary_point_index</a></td></tr>
<tr class="memdesc:ga1379f8968dd611be0b59d04218a1aae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:ga1379f8968dd611be0b59d04218a1aae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31f0617de9388783205020a8679b40af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga31f0617de9388783205020a8679b40af"></a>
typedef boundary_point_index<br class="typebreak"/>
&lt; char const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga31f0617de9388783205020a8679b40af">boost::locale::boundary::cboundary_point_index</a></td></tr>
<tr class="memdesc:ga31f0617de9388783205020a8679b40af"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:ga31f0617de9388783205020a8679b40af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcb5bcc788909afeb8c68d857284cb59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabcb5bcc788909afeb8c68d857284cb59"></a>
typedef boundary_point_index<br class="typebreak"/>
&lt; wchar_t const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gabcb5bcc788909afeb8c68d857284cb59">boost::locale::boundary::wcboundary_point_index</a></td></tr>
<tr class="memdesc:gabcb5bcc788909afeb8c68d857284cb59"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:gabcb5bcc788909afeb8c68d857284cb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a89414f77d0b11b7fa8c3a5fa896266"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a89414f77d0b11b7fa8c3a5fa896266"></a>
typedef boundary_point_index<br class="typebreak"/>
&lt; char16_t const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga1a89414f77d0b11b7fa8c3a5fa896266">boost::locale::boundary::u16cboundary_point_index</a></td></tr>
<tr class="memdesc:ga1a89414f77d0b11b7fa8c3a5fa896266"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:ga1a89414f77d0b11b7fa8c3a5fa896266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d16a23d328240464f9068cf58fb38d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1d16a23d328240464f9068cf58fb38d7"></a>
typedef boundary_point_index<br class="typebreak"/>
&lt; char32_t const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga1d16a23d328240464f9068cf58fb38d7">boost::locale::boundary::u32cboundary_point_index</a></td></tr>
<tr class="memdesc:ga1d16a23d328240464f9068cf58fb38d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:ga1d16a23d328240464f9068cf58fb38d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5031c17bd3f7ddc5138546af121064"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaac5031c17bd3f7ddc5138546af121064"></a>
typedef segment<br class="typebreak"/>
&lt; std::string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaac5031c17bd3f7ddc5138546af121064">boost::locale::boundary::ssegment</a></td></tr>
<tr class="memdesc:gaac5031c17bd3f7ddc5138546af121064"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:gaac5031c17bd3f7ddc5138546af121064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0e28d417ee314f3035c7561ed5134a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaca0e28d417ee314f3035c7561ed5134a"></a>
typedef segment<br class="typebreak"/>
&lt; std::wstring::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaca0e28d417ee314f3035c7561ed5134a">boost::locale::boundary::wssegment</a></td></tr>
<tr class="memdesc:gaca0e28d417ee314f3035c7561ed5134a"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:gaca0e28d417ee314f3035c7561ed5134a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5084d9529f752361d18c2196f38df3c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5084d9529f752361d18c2196f38df3c0"></a>
typedef segment<br class="typebreak"/>
&lt; std::u16string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga5084d9529f752361d18c2196f38df3c0">boost::locale::boundary::u16ssegment</a></td></tr>
<tr class="memdesc:ga5084d9529f752361d18c2196f38df3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:ga5084d9529f752361d18c2196f38df3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffcc722694a39291a9ea7f68a95e1e27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaffcc722694a39291a9ea7f68a95e1e27"></a>
typedef segment<br class="typebreak"/>
&lt; std::u32string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaffcc722694a39291a9ea7f68a95e1e27">boost::locale::boundary::u32ssegment</a></td></tr>
<tr class="memdesc:gaffcc722694a39291a9ea7f68a95e1e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:gaffcc722694a39291a9ea7f68a95e1e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a89ba0de6cad23a0f1b0b90ca5296f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7a89ba0de6cad23a0f1b0b90ca5296f0"></a>
typedef segment&lt; char const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga7a89ba0de6cad23a0f1b0b90ca5296f0">boost::locale::boundary::csegment</a></td></tr>
<tr class="memdesc:ga7a89ba0de6cad23a0f1b0b90ca5296f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:ga7a89ba0de6cad23a0f1b0b90ca5296f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d26aae843dad891a3bfa736871e843"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9d26aae843dad891a3bfa736871e843"></a>
typedef segment&lt; wchar_t const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gab9d26aae843dad891a3bfa736871e843">boost::locale::boundary::wcsegment</a></td></tr>
<tr class="memdesc:gab9d26aae843dad891a3bfa736871e843"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:gab9d26aae843dad891a3bfa736871e843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff9e98f81ad61dbcd480fc61780fee1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ff9e98f81ad61dbcd480fc61780fee1"></a>
typedef segment&lt; char16_t const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga5ff9e98f81ad61dbcd480fc61780fee1">boost::locale::boundary::u16csegment</a></td></tr>
<tr class="memdesc:ga5ff9e98f81ad61dbcd480fc61780fee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:ga5ff9e98f81ad61dbcd480fc61780fee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2077b28c5de700fb5bff9688fe410d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf2077b28c5de700fb5bff9688fe410d6"></a>
typedef segment&lt; char32_t const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaf2077b28c5de700fb5bff9688fe410d6">boost::locale::boundary::u32csegment</a></td></tr>
<tr class="memdesc:gaf2077b28c5de700fb5bff9688fe410d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience typedef <br/></td></tr>
<tr class="separator:gaf2077b28c5de700fb5bff9688fe410d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e193c81052ef1795f1b53b46bc2095"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">boost::locale::boundary::rule_type</a></td></tr>
<tr class="memdesc:ga25e193c81052ef1795f1b53b46bc2095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags used with word boundary analysis &ndash; the type of the word, line or sentence boundary found.  <a href="#ga25e193c81052ef1795f1b53b46bc2095">More...</a><br/></td></tr>
<tr class="separator:ga25e193c81052ef1795f1b53b46bc2095"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga15de9963ce9bb6037c8525901dfbf641"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boost::locale::boundary::boundary_type</a> { <a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641ae80c964112541d88af9b875dafb6605d">boost::locale::boundary::character</a>, 
<a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">boost::locale::boundary::word</a>, 
<a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9">boost::locale::boundary::sentence</a>, 
<a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a72895419fdd7219b3695cf0abd602ea4">boost::locale::boundary::line</a>
 }</td></tr>
<tr class="separator:ga15de9963ce9bb6037c8525901dfbf641"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga47bc5ece5c461aa4c538354a9e80a707"><td class="memTemplParams" colspan="2">template&lt;typename BaseIterator &gt; </td></tr>
<tr class="memitem:ga47bc5ece5c461aa4c538354a9e80a707"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga47bc5ece5c461aa4c538354a9e80a707">boost::locale::boundary::operator==</a> (BaseIterator const &amp;l, boundary_point&lt; BaseIterator &gt; const &amp;r)</td></tr>
<tr class="separator:ga47bc5ece5c461aa4c538354a9e80a707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab92086846a31a6826c00a3df90027f0f"><td class="memTemplParams" colspan="2">template&lt;typename BaseIterator &gt; </td></tr>
<tr class="memitem:gab92086846a31a6826c00a3df90027f0f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gab92086846a31a6826c00a3df90027f0f">boost::locale::boundary::operator!=</a> (BaseIterator const &amp;l, boundary_point&lt; BaseIterator &gt; const &amp;r)</td></tr>
<tr class="separator:gab92086846a31a6826c00a3df90027f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c354f4cc03677b58c97038cd84dc465"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga2c354f4cc03677b58c97038cd84dc465">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::segment_index</a> ()</td></tr>
<tr class="separator:ga2c354f4cc03677b58c97038cd84dc465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06ddc335e95479ec51e9b16d0f829bb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga06ddc335e95479ec51e9b16d0f829bb3">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::segment_index</a> (boundary_type type, base_iterator begin, base_iterator end, rule_type mask, std::locale const &amp;loc=std::locale())</td></tr>
<tr class="separator:ga06ddc335e95479ec51e9b16d0f829bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46a5f584d5a1a43ad4bc0fff07183fcc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga46a5f584d5a1a43ad4bc0fff07183fcc">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::segment_index</a> (boundary_type type, base_iterator begin, base_iterator end, std::locale const &amp;loc=std::locale())</td></tr>
<tr class="separator:ga46a5f584d5a1a43ad4bc0fff07183fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8187f58177fc89ef2f8f818a37111363"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga8187f58177fc89ef2f8f818a37111363">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::segment_index</a> (boundary_point_index&lt; base_iterator &gt; const &amp;)</td></tr>
<tr class="separator:ga8187f58177fc89ef2f8f818a37111363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7941dc874ca05d2ef2a03f781c5b78a"><td class="memItemLeft" align="right" valign="top">segment_index const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gae7941dc874ca05d2ef2a03f781c5b78a">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::operator=</a> (boundary_point_index&lt; base_iterator &gt; const &amp;)</td></tr>
<tr class="separator:gae7941dc874ca05d2ef2a03f781c5b78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa2a756b10d3522743204b45b794bb3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gafa2a756b10d3522743204b45b794bb3e">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::map</a> (boundary_type type, base_iterator begin, base_iterator end, std::locale const &amp;loc=std::locale())</td></tr>
<tr class="separator:gafa2a756b10d3522743204b45b794bb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf74ff9c86c177efa8f74856277d659af"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaf74ff9c86c177efa8f74856277d659af">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::begin</a> () const </td></tr>
<tr class="separator:gaf74ff9c86c177efa8f74856277d659af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8757062d2446b35675b585651c5fea9f"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga8757062d2446b35675b585651c5fea9f">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::end</a> () const </td></tr>
<tr class="separator:ga8757062d2446b35675b585651c5fea9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2480236106971797460187777f2a4411"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga2480236106971797460187777f2a4411">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::find</a> (base_iterator p) const </td></tr>
<tr class="separator:ga2480236106971797460187777f2a4411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72b4ceb5bacec0eded2601c43a4d671a"><td class="memItemLeft" align="right" valign="top">rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga72b4ceb5bacec0eded2601c43a4d671a">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::rule</a> () const </td></tr>
<tr class="separator:ga72b4ceb5bacec0eded2601c43a4d671a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad19735180401edb15acbdbbeb21e5a73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad19735180401edb15acbdbbeb21e5a73">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::rule</a> (rule_type v)</td></tr>
<tr class="separator:gad19735180401edb15acbdbbeb21e5a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7faa10d536c85df0f2d5cac85f2bbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gace7faa10d536c85df0f2d5cac85f2bbc">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::full_select</a> () const </td></tr>
<tr class="separator:gace7faa10d536c85df0f2d5cac85f2bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga205fd51daa439a18527675e663a0802f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga205fd51daa439a18527675e663a0802f">boost::locale::boundary::segment_index&lt; BaseIterator &gt;::full_select</a> (bool v)</td></tr>
<tr class="separator:ga205fd51daa439a18527675e663a0802f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6993dd50ad8cf2db8921e5cf668a69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaba6993dd50ad8cf2db8921e5cf668a69">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::boundary_point_index</a> ()</td></tr>
<tr class="separator:gaba6993dd50ad8cf2db8921e5cf668a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc189288792012cfdb21c07fddbadc4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gacc189288792012cfdb21c07fddbadc4f">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::boundary_point_index</a> (boundary_type type, base_iterator begin, base_iterator end, rule_type mask, std::locale const &amp;loc=std::locale())</td></tr>
<tr class="separator:gacc189288792012cfdb21c07fddbadc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b926379fa2fcc7f87dc067953049d69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga9b926379fa2fcc7f87dc067953049d69">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::boundary_point_index</a> (boundary_type type, base_iterator begin, base_iterator end, std::locale const &amp;loc=std::locale())</td></tr>
<tr class="separator:ga9b926379fa2fcc7f87dc067953049d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac48665ff53789c6ee44a423963b6550d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gac48665ff53789c6ee44a423963b6550d">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::boundary_point_index</a> (segment_index&lt; base_iterator &gt; const &amp;other)</td></tr>
<tr class="separator:gac48665ff53789c6ee44a423963b6550d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83d57b993b00686b2cac711667c6a931"><td class="memItemLeft" align="right" valign="top">boundary_point_index const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga83d57b993b00686b2cac711667c6a931">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::operator=</a> (segment_index&lt; base_iterator &gt; const &amp;other)</td></tr>
<tr class="separator:ga83d57b993b00686b2cac711667c6a931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b4b5d5cf80b55302a88e7b36c812418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga6b4b5d5cf80b55302a88e7b36c812418">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::map</a> (boundary_type type, base_iterator begin, base_iterator end, std::locale const &amp;loc=std::locale())</td></tr>
<tr class="separator:ga6b4b5d5cf80b55302a88e7b36c812418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56f42a32f0378b6e157671f9e17bd66f"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga56f42a32f0378b6e157671f9e17bd66f">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::begin</a> () const </td></tr>
<tr class="separator:ga56f42a32f0378b6e157671f9e17bd66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3d66d578e32a63b3f0ffbb59740667b"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaf3d66d578e32a63b3f0ffbb59740667b">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::end</a> () const </td></tr>
<tr class="separator:gaf3d66d578e32a63b3f0ffbb59740667b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bb71a287afca990e85b17246568492d"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga0bb71a287afca990e85b17246568492d">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::find</a> (base_iterator p) const </td></tr>
<tr class="separator:ga0bb71a287afca990e85b17246568492d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d214029f1a780b7bf6e3f23a3004c03"><td class="memItemLeft" align="right" valign="top">rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga1d214029f1a780b7bf6e3f23a3004c03">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::rule</a> () const </td></tr>
<tr class="separator:ga1d214029f1a780b7bf6e3f23a3004c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e63913f51109e05a24a7136472a975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga56e63913f51109e05a24a7136472a975">boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::rule</a> (rule_type v)</td></tr>
<tr class="separator:ga56e63913f51109e05a24a7136472a975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e70e909a5fb4d2cf87b485894c9b4db"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5e70e909a5fb4d2cf87b485894c9b4db"></a>
template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga5e70e909a5fb4d2cf87b485894c9b4db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga5e70e909a5fb4d2cf87b485894c9b4db">boost::locale::boundary::operator==</a> (segment&lt; IteratorL &gt; const &amp;l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:ga5e70e909a5fb4d2cf87b485894c9b4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two segments. <br/></td></tr>
<tr class="separator:ga5e70e909a5fb4d2cf87b485894c9b4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4458cb23aa62b0f94396d3300e838f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae4458cb23aa62b0f94396d3300e838f9"></a>
template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:gae4458cb23aa62b0f94396d3300e838f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gae4458cb23aa62b0f94396d3300e838f9">boost::locale::boundary::operator!=</a> (segment&lt; IteratorL &gt; const &amp;l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:gae4458cb23aa62b0f94396d3300e838f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two segments. <br/></td></tr>
<tr class="separator:gae4458cb23aa62b0f94396d3300e838f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01671fcf3519166189dff3664f68c870"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga01671fcf3519166189dff3664f68c870"></a>
template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga01671fcf3519166189dff3664f68c870"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga01671fcf3519166189dff3664f68c870">boost::locale::boundary::operator&lt;</a> (segment&lt; IteratorL &gt; const &amp;l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:ga01671fcf3519166189dff3664f68c870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two segments. <br/></td></tr>
<tr class="separator:ga01671fcf3519166189dff3664f68c870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef3ac4dbd5172a67ec68e27fe6a7a008"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaef3ac4dbd5172a67ec68e27fe6a7a008"></a>
template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:gaef3ac4dbd5172a67ec68e27fe6a7a008"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaef3ac4dbd5172a67ec68e27fe6a7a008">boost::locale::boundary::operator&lt;=</a> (segment&lt; IteratorL &gt; const &amp;l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:gaef3ac4dbd5172a67ec68e27fe6a7a008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two segments. <br/></td></tr>
<tr class="separator:gaef3ac4dbd5172a67ec68e27fe6a7a008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga458e3170d3967ae25c4a40a3970701ba"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga458e3170d3967ae25c4a40a3970701ba"></a>
template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga458e3170d3967ae25c4a40a3970701ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga458e3170d3967ae25c4a40a3970701ba">boost::locale::boundary::operator&gt;</a> (segment&lt; IteratorL &gt; const &amp;l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:ga458e3170d3967ae25c4a40a3970701ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two segments. <br/></td></tr>
<tr class="separator:ga458e3170d3967ae25c4a40a3970701ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9854493e000ea610108d4689d2f6f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4d9854493e000ea610108d4689d2f6f1"></a>
template&lt;typename IteratorL , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga4d9854493e000ea610108d4689d2f6f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga4d9854493e000ea610108d4689d2f6f1">boost::locale::boundary::operator&gt;=</a> (segment&lt; IteratorL &gt; const &amp;l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:ga4d9854493e000ea610108d4689d2f6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two segments. <br/></td></tr>
<tr class="separator:ga4d9854493e000ea610108d4689d2f6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e4d38b1dd21bd663847fdbc09fca46"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga22e4d38b1dd21bd663847fdbc09fca46"></a>
template&lt;typename CharType , typename Traits , typename Alloc , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga22e4d38b1dd21bd663847fdbc09fca46"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga22e4d38b1dd21bd663847fdbc09fca46">boost::locale::boundary::operator==</a> (std::basic_string&lt; CharType, Traits, Alloc &gt; const &amp;l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:ga22e4d38b1dd21bd663847fdbc09fca46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br/></td></tr>
<tr class="separator:ga22e4d38b1dd21bd663847fdbc09fca46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb7b2978a45e993d6aa9922cbc381e8b"><td class="memTemplParams" colspan="2"><a class="anchor" id="gabb7b2978a45e993d6aa9922cbc381e8b"></a>
template&lt;typename CharType , typename Traits , typename Alloc , typename IteratorR &gt; </td></tr>
<tr class="memitem:gabb7b2978a45e993d6aa9922cbc381e8b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gabb7b2978a45e993d6aa9922cbc381e8b">boost::locale::boundary::operator!=</a> (std::basic_string&lt; CharType, Traits, Alloc &gt; const &amp;l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:gabb7b2978a45e993d6aa9922cbc381e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br/></td></tr>
<tr class="separator:gabb7b2978a45e993d6aa9922cbc381e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57b915b6feed86f731424c5a5ed531c"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac57b915b6feed86f731424c5a5ed531c"></a>
template&lt;typename CharType , typename Traits , typename Alloc , typename IteratorR &gt; </td></tr>
<tr class="memitem:gac57b915b6feed86f731424c5a5ed531c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gac57b915b6feed86f731424c5a5ed531c">boost::locale::boundary::operator&lt;</a> (std::basic_string&lt; CharType, Traits, Alloc &gt; const &amp;l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:gac57b915b6feed86f731424c5a5ed531c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br/></td></tr>
<tr class="separator:gac57b915b6feed86f731424c5a5ed531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec0814b0634157834f1ecd949ea4f935"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaec0814b0634157834f1ecd949ea4f935"></a>
template&lt;typename CharType , typename Traits , typename Alloc , typename IteratorR &gt; </td></tr>
<tr class="memitem:gaec0814b0634157834f1ecd949ea4f935"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaec0814b0634157834f1ecd949ea4f935">boost::locale::boundary::operator&lt;=</a> (std::basic_string&lt; CharType, Traits, Alloc &gt; const &amp;l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:gaec0814b0634157834f1ecd949ea4f935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br/></td></tr>
<tr class="separator:gaec0814b0634157834f1ecd949ea4f935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad19346448d1464f02f706a3d90932837"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad19346448d1464f02f706a3d90932837"></a>
template&lt;typename CharType , typename Traits , typename Alloc , typename IteratorR &gt; </td></tr>
<tr class="memitem:gad19346448d1464f02f706a3d90932837"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad19346448d1464f02f706a3d90932837">boost::locale::boundary::operator&gt;</a> (std::basic_string&lt; CharType, Traits, Alloc &gt; const &amp;l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:gad19346448d1464f02f706a3d90932837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br/></td></tr>
<tr class="separator:gad19346448d1464f02f706a3d90932837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48fc6bd37670c164d9fcdf918d20ab9f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga48fc6bd37670c164d9fcdf918d20ab9f"></a>
template&lt;typename CharType , typename Traits , typename Alloc , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga48fc6bd37670c164d9fcdf918d20ab9f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga48fc6bd37670c164d9fcdf918d20ab9f">boost::locale::boundary::operator&gt;=</a> (std::basic_string&lt; CharType, Traits, Alloc &gt; const &amp;l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:ga48fc6bd37670c164d9fcdf918d20ab9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br/></td></tr>
<tr class="separator:ga48fc6bd37670c164d9fcdf918d20ab9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e22ac8a99d4e743942c5d6e94270e27"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1e22ac8a99d4e743942c5d6e94270e27"></a>
template&lt;typename Iterator , typename CharType , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:ga1e22ac8a99d4e743942c5d6e94270e27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga1e22ac8a99d4e743942c5d6e94270e27">boost::locale::boundary::operator==</a> (segment&lt; Iterator &gt; const &amp;l, std::basic_string&lt; CharType, Traits, Alloc &gt; const &amp;r)</td></tr>
<tr class="memdesc:ga1e22ac8a99d4e743942c5d6e94270e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br/></td></tr>
<tr class="separator:ga1e22ac8a99d4e743942c5d6e94270e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab36f95a4500a4c2a31b2ece4a0ae9cd1"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab36f95a4500a4c2a31b2ece4a0ae9cd1"></a>
template&lt;typename Iterator , typename CharType , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:gab36f95a4500a4c2a31b2ece4a0ae9cd1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gab36f95a4500a4c2a31b2ece4a0ae9cd1">boost::locale::boundary::operator!=</a> (segment&lt; Iterator &gt; const &amp;l, std::basic_string&lt; CharType, Traits, Alloc &gt; const &amp;r)</td></tr>
<tr class="memdesc:gab36f95a4500a4c2a31b2ece4a0ae9cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br/></td></tr>
<tr class="separator:gab36f95a4500a4c2a31b2ece4a0ae9cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf992487402ed47358bf790a6372059d"><td class="memTemplParams" colspan="2"><a class="anchor" id="gabf992487402ed47358bf790a6372059d"></a>
template&lt;typename Iterator , typename CharType , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:gabf992487402ed47358bf790a6372059d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gabf992487402ed47358bf790a6372059d">boost::locale::boundary::operator&lt;</a> (segment&lt; Iterator &gt; const &amp;l, std::basic_string&lt; CharType, Traits, Alloc &gt; const &amp;r)</td></tr>
<tr class="memdesc:gabf992487402ed47358bf790a6372059d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br/></td></tr>
<tr class="separator:gabf992487402ed47358bf790a6372059d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab800ff341ec09a99c803dd5fd56e5a81"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab800ff341ec09a99c803dd5fd56e5a81"></a>
template&lt;typename Iterator , typename CharType , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:gab800ff341ec09a99c803dd5fd56e5a81"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gab800ff341ec09a99c803dd5fd56e5a81">boost::locale::boundary::operator&lt;=</a> (segment&lt; Iterator &gt; const &amp;l, std::basic_string&lt; CharType, Traits, Alloc &gt; const &amp;r)</td></tr>
<tr class="memdesc:gab800ff341ec09a99c803dd5fd56e5a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br/></td></tr>
<tr class="separator:gab800ff341ec09a99c803dd5fd56e5a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32c4f420aae266e1d6d4b37e716cc30"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf32c4f420aae266e1d6d4b37e716cc30"></a>
template&lt;typename Iterator , typename CharType , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:gaf32c4f420aae266e1d6d4b37e716cc30"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaf32c4f420aae266e1d6d4b37e716cc30">boost::locale::boundary::operator&gt;</a> (segment&lt; Iterator &gt; const &amp;l, std::basic_string&lt; CharType, Traits, Alloc &gt; const &amp;r)</td></tr>
<tr class="memdesc:gaf32c4f420aae266e1d6d4b37e716cc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br/></td></tr>
<tr class="separator:gaf32c4f420aae266e1d6d4b37e716cc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfbbd6c86914627ffdc08397023b020a"><td class="memTemplParams" colspan="2"><a class="anchor" id="gadfbbd6c86914627ffdc08397023b020a"></a>
template&lt;typename Iterator , typename CharType , typename Traits , typename Alloc &gt; </td></tr>
<tr class="memitem:gadfbbd6c86914627ffdc08397023b020a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gadfbbd6c86914627ffdc08397023b020a">boost::locale::boundary::operator&gt;=</a> (segment&lt; Iterator &gt; const &amp;l, std::basic_string&lt; CharType, Traits, Alloc &gt; const &amp;r)</td></tr>
<tr class="memdesc:gadfbbd6c86914627ffdc08397023b020a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare string and segment. <br/></td></tr>
<tr class="separator:gadfbbd6c86914627ffdc08397023b020a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04c0513778ff3cf9712dd03244a7ecb3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga04c0513778ff3cf9712dd03244a7ecb3"></a>
template&lt;typename CharType , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga04c0513778ff3cf9712dd03244a7ecb3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga04c0513778ff3cf9712dd03244a7ecb3">boost::locale::boundary::operator==</a> (CharType const *l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:ga04c0513778ff3cf9712dd03244a7ecb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br/></td></tr>
<tr class="separator:ga04c0513778ff3cf9712dd03244a7ecb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8256de904b797b2a57905d3a53f87d7"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab8256de904b797b2a57905d3a53f87d7"></a>
template&lt;typename CharType , typename IteratorR &gt; </td></tr>
<tr class="memitem:gab8256de904b797b2a57905d3a53f87d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gab8256de904b797b2a57905d3a53f87d7">boost::locale::boundary::operator!=</a> (CharType const *l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:gab8256de904b797b2a57905d3a53f87d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br/></td></tr>
<tr class="separator:gab8256de904b797b2a57905d3a53f87d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3bf0c32d4deefe23fa474960b0dea6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5d3bf0c32d4deefe23fa474960b0dea6"></a>
template&lt;typename CharType , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga5d3bf0c32d4deefe23fa474960b0dea6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga5d3bf0c32d4deefe23fa474960b0dea6">boost::locale::boundary::operator&lt;</a> (CharType const *l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:ga5d3bf0c32d4deefe23fa474960b0dea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br/></td></tr>
<tr class="separator:ga5d3bf0c32d4deefe23fa474960b0dea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8fc1bd6bf20fe5337dd91dab7f9084c"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad8fc1bd6bf20fe5337dd91dab7f9084c"></a>
template&lt;typename CharType , typename IteratorR &gt; </td></tr>
<tr class="memitem:gad8fc1bd6bf20fe5337dd91dab7f9084c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad8fc1bd6bf20fe5337dd91dab7f9084c">boost::locale::boundary::operator&lt;=</a> (CharType const *l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:gad8fc1bd6bf20fe5337dd91dab7f9084c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br/></td></tr>
<tr class="separator:gad8fc1bd6bf20fe5337dd91dab7f9084c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa79f6bb9e721e55d071d7898a3010f8e"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa79f6bb9e721e55d071d7898a3010f8e"></a>
template&lt;typename CharType , typename IteratorR &gt; </td></tr>
<tr class="memitem:gaa79f6bb9e721e55d071d7898a3010f8e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaa79f6bb9e721e55d071d7898a3010f8e">boost::locale::boundary::operator&gt;</a> (CharType const *l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:gaa79f6bb9e721e55d071d7898a3010f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br/></td></tr>
<tr class="separator:gaa79f6bb9e721e55d071d7898a3010f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb2d214673569bf63a5ef97847d8bc3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4fb2d214673569bf63a5ef97847d8bc3"></a>
template&lt;typename CharType , typename IteratorR &gt; </td></tr>
<tr class="memitem:ga4fb2d214673569bf63a5ef97847d8bc3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga4fb2d214673569bf63a5ef97847d8bc3">boost::locale::boundary::operator&gt;=</a> (CharType const *l, segment&lt; IteratorR &gt; const &amp;r)</td></tr>
<tr class="memdesc:ga4fb2d214673569bf63a5ef97847d8bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br/></td></tr>
<tr class="separator:ga4fb2d214673569bf63a5ef97847d8bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa32c6dabd5833c3f4806a7a40c0808"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2aa32c6dabd5833c3f4806a7a40c0808"></a>
template&lt;typename Iterator , typename CharType &gt; </td></tr>
<tr class="memitem:ga2aa32c6dabd5833c3f4806a7a40c0808"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga2aa32c6dabd5833c3f4806a7a40c0808">boost::locale::boundary::operator==</a> (segment&lt; Iterator &gt; const &amp;l, CharType const *r)</td></tr>
<tr class="memdesc:ga2aa32c6dabd5833c3f4806a7a40c0808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br/></td></tr>
<tr class="separator:ga2aa32c6dabd5833c3f4806a7a40c0808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf50154c65385afc65e206b5fa34fc4ac"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf50154c65385afc65e206b5fa34fc4ac"></a>
template&lt;typename Iterator , typename CharType &gt; </td></tr>
<tr class="memitem:gaf50154c65385afc65e206b5fa34fc4ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaf50154c65385afc65e206b5fa34fc4ac">boost::locale::boundary::operator!=</a> (segment&lt; Iterator &gt; const &amp;l, CharType const *r)</td></tr>
<tr class="memdesc:gaf50154c65385afc65e206b5fa34fc4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br/></td></tr>
<tr class="separator:gaf50154c65385afc65e206b5fa34fc4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4be80936d6d852d8a07322ea46c49dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad4be80936d6d852d8a07322ea46c49dd"></a>
template&lt;typename Iterator , typename CharType &gt; </td></tr>
<tr class="memitem:gad4be80936d6d852d8a07322ea46c49dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad4be80936d6d852d8a07322ea46c49dd">boost::locale::boundary::operator&lt;</a> (segment&lt; Iterator &gt; const &amp;l, CharType const *r)</td></tr>
<tr class="memdesc:gad4be80936d6d852d8a07322ea46c49dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br/></td></tr>
<tr class="separator:gad4be80936d6d852d8a07322ea46c49dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f813e25280a6165cc270ced46bc8c58"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1f813e25280a6165cc270ced46bc8c58"></a>
template&lt;typename Iterator , typename CharType &gt; </td></tr>
<tr class="memitem:ga1f813e25280a6165cc270ced46bc8c58"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga1f813e25280a6165cc270ced46bc8c58">boost::locale::boundary::operator&lt;=</a> (segment&lt; Iterator &gt; const &amp;l, CharType const *r)</td></tr>
<tr class="memdesc:ga1f813e25280a6165cc270ced46bc8c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br/></td></tr>
<tr class="separator:ga1f813e25280a6165cc270ced46bc8c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b12a40f6e30c03e064973a66f8697b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4b12a40f6e30c03e064973a66f8697b8"></a>
template&lt;typename Iterator , typename CharType &gt; </td></tr>
<tr class="memitem:ga4b12a40f6e30c03e064973a66f8697b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga4b12a40f6e30c03e064973a66f8697b8">boost::locale::boundary::operator&gt;</a> (segment&lt; Iterator &gt; const &amp;l, CharType const *r)</td></tr>
<tr class="memdesc:ga4b12a40f6e30c03e064973a66f8697b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br/></td></tr>
<tr class="separator:ga4b12a40f6e30c03e064973a66f8697b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae867939516d7fd9cbca258414a0c8377"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae867939516d7fd9cbca258414a0c8377"></a>
template&lt;typename Iterator , typename CharType &gt; </td></tr>
<tr class="memitem:gae867939516d7fd9cbca258414a0c8377"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#gae867939516d7fd9cbca258414a0c8377">boost::locale::boundary::operator&gt;=</a> (segment&lt; Iterator &gt; const &amp;l, CharType const *r)</td></tr>
<tr class="memdesc:gae867939516d7fd9cbca258414a0c8377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare C string and segment. <br/></td></tr>
<tr class="separator:gae867939516d7fd9cbca258414a0c8377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66d8f6c9b1c81c36a55aecebd4960b5d"><td class="memTemplParams" colspan="2">template&lt;typename CharType , typename TraitsType , typename Iterator &gt; </td></tr>
<tr class="memitem:ga66d8f6c9b1c81c36a55aecebd4960b5d"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CharType, <br class="typebreak"/>
TraitsType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga66d8f6c9b1c81c36a55aecebd4960b5d">boost::locale::boundary::operator&lt;&lt;</a> (std::basic_ostream&lt; CharType, TraitsType &gt; &amp;out, segment&lt; Iterator &gt; const &amp;tok)</td></tr>
<tr class="separator:ga66d8f6c9b1c81c36a55aecebd4960b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99daacb708289fe81def9f1ce4486515"><td class="memItemLeft" align="right" valign="top">rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga99daacb708289fe81def9f1ce4486515">boost::locale::boundary::boundary_rule</a> (boundary_type t)</td></tr>
<tr class="separator:ga99daacb708289fe81def9f1ce4486515"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga960209e8a9453221641eda6bd8c4989b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga960209e8a9453221641eda6bd8c4989b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>boost::locale::boundary::segment_index&lt; BaseIterator &gt;::boundary_point_index&lt; base_iterator &gt;</b></td></tr>
<tr class="separator:ga960209e8a9453221641eda6bd8c4989b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8ba2e18ec3780af8f001ba85e40b9e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa8ba2e18ec3780af8f001ba85e40b9e2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>boost::locale::boundary::boundary_point_index&lt; BaseIterator &gt;::segment_index&lt; base_iterator &gt;</b></td></tr>
<tr class="separator:gaa8ba2e18ec3780af8f001ba85e40b9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Flags that describe a type of word selected</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpabac8d1452313f3e83b136f6f21b6d18"></a><a class="anchor" id="bl_boundary_word_rules"></a> </p>
</td></tr>
<tr class="memitem:ga90cf4f01b95658f659685377226677e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga90cf4f01b95658f659685377226677e7"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga90cf4f01b95658f659685377226677e7">boost::locale::boundary::word_none</a> = 0x0000F</td></tr>
<tr class="memdesc:ga90cf4f01b95658f659685377226677e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not a word, like white space or punctuation mark. <br/></td></tr>
<tr class="separator:ga90cf4f01b95658f659685377226677e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac78a3a6b9e671e253a2591cb56a479b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaac78a3a6b9e671e253a2591cb56a479b"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaac78a3a6b9e671e253a2591cb56a479b">boost::locale::boundary::word_number</a> = 0x000F0</td></tr>
<tr class="memdesc:gaac78a3a6b9e671e253a2591cb56a479b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word that appear to be a number. <br/></td></tr>
<tr class="separator:gaac78a3a6b9e671e253a2591cb56a479b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b7e6ce2fcb185845fa85a1a4c42b3c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8b7e6ce2fcb185845fa85a1a4c42b3c4"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga8b7e6ce2fcb185845fa85a1a4c42b3c4">boost::locale::boundary::word_letter</a> = 0x00F00</td></tr>
<tr class="memdesc:ga8b7e6ce2fcb185845fa85a1a4c42b3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word that contains letters, excluding kana and ideographic characters. <br/></td></tr>
<tr class="separator:ga8b7e6ce2fcb185845fa85a1a4c42b3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d8c63e1f3f8c898c645352206a78ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga52d8c63e1f3f8c898c645352206a78ef"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga52d8c63e1f3f8c898c645352206a78ef">boost::locale::boundary::word_kana</a> = 0x0F000</td></tr>
<tr class="memdesc:ga52d8c63e1f3f8c898c645352206a78ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word that contains kana characters. <br/></td></tr>
<tr class="separator:ga52d8c63e1f3f8c898c645352206a78ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga705ab96f9e62810c8ed977c90d404ef8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga705ab96f9e62810c8ed977c90d404ef8"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga705ab96f9e62810c8ed977c90d404ef8">boost::locale::boundary::word_ideo</a> = 0xF0000</td></tr>
<tr class="memdesc:ga705ab96f9e62810c8ed977c90d404ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word that contains ideographic characters. <br/></td></tr>
<tr class="separator:ga705ab96f9e62810c8ed977c90d404ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ab98808dbb1cc4a346dcc2554c9d8dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3ab98808dbb1cc4a346dcc2554c9d8dc"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga3ab98808dbb1cc4a346dcc2554c9d8dc">boost::locale::boundary::word_any</a> = 0xFFFF0</td></tr>
<tr class="memdesc:ga3ab98808dbb1cc4a346dcc2554c9d8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any word including numbers, 0 is special flag, equivalent to 15. <br/></td></tr>
<tr class="separator:ga3ab98808dbb1cc4a346dcc2554c9d8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae412d31a918dc793500fed7278663047"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae412d31a918dc793500fed7278663047"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gae412d31a918dc793500fed7278663047">boost::locale::boundary::word_letters</a> = 0xFFF00</td></tr>
<tr class="memdesc:gae412d31a918dc793500fed7278663047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any word, excluding numbers but including letters, kana and ideograms. <br/></td></tr>
<tr class="separator:gae412d31a918dc793500fed7278663047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5de65589628267ab7f2a51f4147d43f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5de65589628267ab7f2a51f4147d43f9"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga5de65589628267ab7f2a51f4147d43f9">boost::locale::boundary::word_kana_ideo</a> = 0xFF000</td></tr>
<tr class="memdesc:ga5de65589628267ab7f2a51f4147d43f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word that includes kana or ideographic characters. <br/></td></tr>
<tr class="separator:ga5de65589628267ab7f2a51f4147d43f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad11031065617b6be9d4662d2c06afd52"><td class="memItemLeft" align="right" valign="top">static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad11031065617b6be9d4662d2c06afd52">boost::locale::boundary::word_mask</a> = 0xFFFFF</td></tr>
<tr class="separator:gad11031065617b6be9d4662d2c06afd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Flags that describe a type of line break</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp99d1c759163f3082dff790a7e8e04eb5"></a><a class="anchor" id="bl_boundary_line_rules"></a> </p>
</td></tr>
<tr class="memitem:gaa6a7b6ea3c63a1101a945b82eb10ebd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa6a7b6ea3c63a1101a945b82eb10ebd0"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaa6a7b6ea3c63a1101a945b82eb10ebd0">boost::locale::boundary::line_soft</a> = 0x0F</td></tr>
<tr class="memdesc:gaa6a7b6ea3c63a1101a945b82eb10ebd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Soft line break: optional but not required. <br/></td></tr>
<tr class="separator:gaa6a7b6ea3c63a1101a945b82eb10ebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04faac8129ca14e4e5a789652ee8ecab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga04faac8129ca14e4e5a789652ee8ecab"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga04faac8129ca14e4e5a789652ee8ecab">boost::locale::boundary::line_hard</a> = 0xF0</td></tr>
<tr class="memdesc:ga04faac8129ca14e4e5a789652ee8ecab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hard line break: like break is required (as per CR/LF) <br/></td></tr>
<tr class="separator:ga04faac8129ca14e4e5a789652ee8ecab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33fb765abbab27ee07cf70bfab8f47e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga33fb765abbab27ee07cf70bfab8f47e0"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga33fb765abbab27ee07cf70bfab8f47e0">boost::locale::boundary::line_any</a> = 0xFF</td></tr>
<tr class="memdesc:ga33fb765abbab27ee07cf70bfab8f47e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Soft or Hard line break. <br/></td></tr>
<tr class="separator:ga33fb765abbab27ee07cf70bfab8f47e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5d8f2ac695f14b58d5df277aa5939f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad5d8f2ac695f14b58d5df277aa5939f9"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad5d8f2ac695f14b58d5df277aa5939f9">boost::locale::boundary::line_mask</a> = 0xFF</td></tr>
<tr class="memdesc:gad5d8f2ac695f14b58d5df277aa5939f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select all types of line breaks. <br/></td></tr>
<tr class="separator:gad5d8f2ac695f14b58d5df277aa5939f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Flags that describe a type of sentence break</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpfb13ccc6dee7f63c89f426c484168b62"></a><a class="anchor" id="bl_boundary_sentence_rules"></a> </p>
</td></tr>
<tr class="memitem:ga3befefe67f79691c117bf5588741355b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3befefe67f79691c117bf5588741355b"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga3befefe67f79691c117bf5588741355b">boost::locale::boundary::sentence_term</a> = 0x0F</td></tr>
<tr class="memdesc:ga3befefe67f79691c117bf5588741355b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sentence was terminated with a sentence terminator like ".", "!" possible followed by hard separator like CR, LF, PS. <br/></td></tr>
<tr class="separator:ga3befefe67f79691c117bf5588741355b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67883341dd3d8f786e7281d40790000"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf67883341dd3d8f786e7281d40790000"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gaf67883341dd3d8f786e7281d40790000">boost::locale::boundary::sentence_sep</a> = 0xF0</td></tr>
<tr class="memdesc:gaf67883341dd3d8f786e7281d40790000"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sentence does not contain terminator like ".", "!" but ended with hard separator like CR, LF, PS or end of input. <br/></td></tr>
<tr class="separator:gaf67883341dd3d8f786e7281d40790000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2042518b20123ec14fbf71458ec9c79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae2042518b20123ec14fbf71458ec9c79"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gae2042518b20123ec14fbf71458ec9c79">boost::locale::boundary::sentence_any</a> = 0xFF</td></tr>
<tr class="memdesc:gae2042518b20123ec14fbf71458ec9c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either first or second sentence break type;. <br/></td></tr>
<tr class="separator:gae2042518b20123ec14fbf71458ec9c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd2a521edb550e75c624000a1089934c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacd2a521edb550e75c624000a1089934c"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gacd2a521edb550e75c624000a1089934c">boost::locale::boundary::sentence_mask</a> = 0xFF</td></tr>
<tr class="memdesc:gacd2a521edb550e75c624000a1089934c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select all sentence breaking points. <br/></td></tr>
<tr class="separator:gacd2a521edb550e75c624000a1089934c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Flags that describe a type of character break.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp3e1d3241fbeb9a60e2aefb02fdc6f34a"></a> At this point break iterator does not distinguish different kinds of characters so it is used for consistency. </p>
</td></tr>
<tr class="memitem:ga9f9e97f7d234139cabe4c4df92a6d4b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9f9e97f7d234139cabe4c4df92a6d4b5"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#ga9f9e97f7d234139cabe4c4df92a6d4b5">boost::locale::boundary::character_any</a> = 0xF</td></tr>
<tr class="memdesc:ga9f9e97f7d234139cabe4c4df92a6d4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not in use, just for consistency. <br/></td></tr>
<tr class="separator:ga9f9e97f7d234139cabe4c4df92a6d4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad151135cfe341d3c1f63bf459f6a1f4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad151135cfe341d3c1f63bf459f6a1f4c"></a>
static const rule_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__boundary.html#gad151135cfe341d3c1f63bf459f6a1f4c">boost::locale::boundary::character_mask</a> = 0xF</td></tr>
<tr class="memdesc:gad151135cfe341d3c1f63bf459f6a1f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select all character breaking points. <br/></td></tr>
<tr class="separator:gad151135cfe341d3c1f63bf459f6a1f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module contains all operations required for boundary analysis of text: character, word, like and sentence boundaries</p>
<p>This module contains all operations required for boundary analysis of text: character, word, like and sentence boundaries </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga06f2faacb9d196ebc659ad5382ea2ca5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BaseIterator <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::base_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of the iterator used to iterate over the original text </p>

</div>
</div>
<a class="anchor" id="gab3189e2eaf4386cdf37598e0ba16cfd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BaseIterator <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::base_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of the iterator used to iterate over the original text </p>

</div>
</div>
<a class="anchor" id="ga5f8e61b5babc3f0fa95f5fb8acae3724"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_iterator_type <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>The bidirectional iterator that iterates over <a class="el" href="group__boundary.html#ga067c663d18faee08adb3355701ae72ba">value_type</a> objects.</p>
<ul>
<li>The iterators may be invalidated by use of any non-const member function including but not limited to <a class="el" href="group__boundary.html#gad19735180401edb15acbdbbeb21e5a73">rule(rule_type)</a> and <a class="el" href="group__boundary.html#ga205fd51daa439a18527675e663a0802f">full_select(bool)</a>.</li>
<li>The returned value_type object is valid as long as iterator points to it. So this following code is wrong as t used after p was updated: <div class="fragment"><div class="line">segment_index&lt;some_iterator&gt;::iterator p=index.begin();</div>
<div class="line">segment&lt;some_iterator&gt; &amp;t = *p;</div>
<div class="line">++p;</div>
<div class="line">cout &lt;&lt; t.str() &lt;&lt; endl;</div>
</div><!-- fragment --> </li>
</ul>

</div>
</div>
<a class="anchor" id="gac9ce9158eb2fb030c1baf93376203d16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_iterator_type <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>The bidirectional iterator that iterates over <a class="el" href="group__boundary.html#ga7f7328a860cf485a4bd8f17658c291e1">value_type</a> objects.</p>
<ul>
<li>The iterators may be invalidated by use of any non-const member function including but not limited to <a class="el" href="group__boundary.html#ga56e63913f51109e05a24a7136472a975">rule(rule_type)</a> member function.</li>
<li>The returned value_type object is valid as long as iterator points to it. So this following code is wrong as t used after p was updated: <div class="fragment"><div class="line">boundary_point_index&lt;some_iterator&gt;::iterator p=index.begin();</div>
<div class="line">boundary_point&lt;some_iterator&gt; &amp;t = *p;</div>
<div class="line">++p;</div>
<div class="line"><a class="code" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a> r = t-&gt;rule();</div>
</div><!-- fragment --> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga7b4dd7af8fad53fabd77e629da24d466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;break_info&gt; <a class="el" href="group__boundary.html#ga7b4dd7af8fad53fabd77e629da24d466">boost::locale::boundary::index_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type holds the analysis of the text - all its break points with marks </p>

</div>
</div>
<a class="anchor" id="gaf7a775e77dbbca3495e11d646df96fd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_iterator_type <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The bidirectional iterator that iterates over <a class="el" href="group__boundary.html#ga067c663d18faee08adb3355701ae72ba">value_type</a> objects.</p>
<ul>
<li>The iterators may be invalidated by use of any non-const member function including but not limited to <a class="el" href="group__boundary.html#gad19735180401edb15acbdbbeb21e5a73">rule(rule_type)</a> and <a class="el" href="group__boundary.html#ga205fd51daa439a18527675e663a0802f">full_select(bool)</a>.</li>
<li>The returned value_type object is valid as long as iterator points to it. So this following code is wrong as t used after p was updated: <div class="fragment"><div class="line">segment_index&lt;some_iterator&gt;::iterator p=index.begin();</div>
<div class="line">segment&lt;some_iterator&gt; &amp;t = *p;</div>
<div class="line">++p;</div>
<div class="line">cout &lt;&lt; t.str() &lt;&lt; endl;</div>
</div><!-- fragment --> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga1af6e72b3c384edcebc0cf319fe97efe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef unspecified_iterator_type <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The bidirectional iterator that iterates over <a class="el" href="group__boundary.html#ga7f7328a860cf485a4bd8f17658c291e1">value_type</a> objects.</p>
<ul>
<li>The iterators may be invalidated by use of any non-const member function including but not limited to <a class="el" href="group__boundary.html#ga56e63913f51109e05a24a7136472a975">rule(rule_type)</a> member function.</li>
<li>The returned value_type object is valid as long as iterator points to it. So this following code is wrong as t used after p was updated: <div class="fragment"><div class="line">boundary_point_index&lt;some_iterator&gt;::iterator p=index.begin();</div>
<div class="line">boundary_point&lt;some_iterator&gt; &amp;t = *p;</div>
<div class="line">++p;</div>
<div class="line"><a class="code" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a> r = t-&gt;rule();</div>
</div><!-- fragment --> </li>
</ul>

</div>
</div>
<a class="anchor" id="ga25e193c81052ef1795f1b53b46bc2095"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">boost::locale::boundary::rule_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags used with word boundary analysis &ndash; the type of the word, line or sentence boundary found. </p>
<p>It is a bit-mask that represents various combinations of rules used to select this specific boundary. </p>

</div>
</div>
<a class="anchor" id="ga067c663d18faee08adb3355701ae72ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef segment&lt;base_iterator&gt; <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type dereferenced by the <a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">iterator</a> and <a class="el" href="group__boundary.html#ga5f8e61b5babc3f0fa95f5fb8acae3724">const_iterator</a>. It is an object that represents selected segment. </p>

</div>
</div>
<a class="anchor" id="ga7f7328a860cf485a4bd8f17658c291e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boundary_point&lt;base_iterator&gt; <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type dereferenced by the <a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">iterator</a> and <a class="el" href="group__boundary.html#gac9ce9158eb2fb030c1baf93376203d16">const_iterator</a>. It is an object that represents the selected <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point.html">boundary point</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga15de9963ce9bb6037c8525901dfbf641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boost::locale::boundary::boundary_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type describes a possible boundary analysis alternatives. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga15de9963ce9bb6037c8525901dfbf641ae80c964112541d88af9b875dafb6605d"></a>character</em>&#160;</td><td class="fielddoc">
<p>Analyse the text for character boundaries. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6"></a>word</em>&#160;</td><td class="fielddoc">
<p>Analyse the text for word boundaries. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9"></a>sentence</em>&#160;</td><td class="fielddoc">
<p>Analyse the text for Find sentence boundaries. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga15de9963ce9bb6037c8525901dfbf641a72895419fdd7219b3695cf0abd602ea4"></a>line</em>&#160;</td><td class="fielddoc">
<p>Analyse the text for positions suitable for line breaks. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf74ff9c86c177efa8f74856277d659af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">iterator</a> on the beginning of the segments range.</p>
<p>Preconditions: the <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">segment_index</a> should have a mapping</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The returned iterator is invalidated by access to any non-const member functions of this object </p>

</div>
</div>
<a class="anchor" id="ga56f42a32f0378b6e157671f9e17bd66f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">iterator</a> on the beginning of the boundary points range.</p>
<p>Preconditions: this <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them. ">boundary_point_index</a> should have a mapping</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The returned iterator is invalidated by access to any non-const member functions of this object </p>

</div>
</div>
<a class="anchor" id="gaba6993dd50ad8cf2db8921e5cf668a69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::boundary_point_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>When this object is constructed by default it does not include a valid index, thus calling <a class="el" href="group__boundary.html#ga56f42a32f0378b6e157671f9e17bd66f">begin()</a>, <a class="el" href="group__boundary.html#gaf3d66d578e32a63b3f0ffbb59740667b">end()</a> or <a class="el" href="group__boundary.html#ga0bb71a287afca990e85b17246568492d">find()</a> member functions would lead to undefined behavior </p>

</div>
</div>
<a class="anchor" id="gacc189288792012cfdb21c07fddbadc4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::boundary_point_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::locale const &amp;&#160;</td>
          <td class="paramname"><em>loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">segment_index</a> for boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">type</a> of the text in range [begin,end) using a rule <em>mask</em> for locale <em>loc</em>. </p>

</div>
</div>
<a class="anchor" id="ga9b926379fa2fcc7f87dc067953049d69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::boundary_point_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::locale const &amp;&#160;</td>
          <td class="paramname"><em>loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">segment_index</a> for boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">type</a> of the text in range [begin,end) selecting all possible boundary points (full mask) for locale <em>loc</em>. </p>

</div>
</div>
<a class="anchor" id="gac48665ff53789c6ee44a423963b6550d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::boundary_point_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; <a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them. ">boundary_point_index</a> from a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>. It copies all indexing information and uses the default rule (all possible boundary points)</p>
<p>This operation is very cheap, so if you use <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them. ">boundary_point_index</a> and <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">segment_index</a> on same text range it is much better to create one from another rather then indexing the same range twice.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__boundary.html#ga1d214029f1a780b7bf6e3f23a3004c03">rule()</a> flags are not copied </dd></dl>

</div>
</div>
<a class="anchor" id="ga99daacb708289fe81def9f1ce4486515"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rule_type boost::locale::boundary::boundary_rule </td>
          <td>(</td>
          <td class="paramtype">boundary_type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the mask that covers all variants for specific boundary type </p>

</div>
</div>
<a class="anchor" id="ga8757062d2446b35675b585651c5fea9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <a class="el" href="group__boundary.html#gaf7a775e77dbbca3495e11d646df96fd2">iterator</a> on the ending of the segments range.</p>
<p>Preconditions: the <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">segment_index</a> should have a mapping</p>
<p>The returned iterator is invalidated by access to any non-const member functions of this object </p>

</div>
</div>
<a class="anchor" id="gaf3d66d578e32a63b3f0ffbb59740667b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the <a class="el" href="group__boundary.html#ga1af6e72b3c384edcebc0cf319fe97efe">iterator</a> on the ending of the boundary points range.</p>
<p>Preconditions: this <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them. ">boundary_point_index</a> should have a mapping</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>The returned iterator is invalidated by access to any non-const member functions of this object </p>

</div>
</div>
<a class="anchor" id="ga2480236106971797460187777f2a4411"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a first valid segment following a position <em>p</em>.</p>
<p>If <em>p</em> is inside a valid segment this segment is selected:</p>
<p>For example: For <a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">word</a> boundary analysis with <a class="el" href="group__boundary.html#ga3ab98808dbb1cc4a346dcc2554c9d8dc">word_any</a> <a class="el" href="group__boundary.html#ga72b4ceb5bacec0eded2601c43a4d671a">rule()</a>:</p>
<ul>
<li>"to| be or ", would point to "be",</li>
<li>"t|o be or ", would point to "to",</li>
<li>"to be or| ", would point to end.</li>
</ul>
<p>Preconditions: the <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">segment_index</a> should have a mapping and <em>p</em> should be valid iterator to the text in the mapped range.</p>
<p>The returned iterator is invalidated by access to any non-const member functions of this object </p>

</div>
</div>
<a class="anchor" id="ga0bb71a287afca990e85b17246568492d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find a first valid boundary point on a position <em>p</em> or following it.</p>
<p>For example: For <a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a99aad8b8a5e25baa9f695abe5e574bb6">word</a> boundary analysis of the text "to be or"</p>
<ul>
<li>"|to be", would return boundary point at "|to be",</li>
<li>"t|o be", would point to "to| be"</li>
</ul>
<p>Preconditions: the <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them. ">boundary_point_index</a> should have a mapping and <em>p</em> should be valid iterator to the text in the mapped range.</p>
<p>The returned iterator is invalidated by access to any non-const member functions of this object </p>

</div>
</div>
<a class="anchor" id="gace7faa10d536c85df0f2d5cac85f2bbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::full_select </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the full_select property value - should segment include in the range values that not belong to specific <a class="el" href="group__boundary.html#ga72b4ceb5bacec0eded2601c43a4d671a">rule()</a> or not.</p>
<p>The default value is false.</p>
<p>For example for <a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9">sentence</a> boundary with rule <a class="el" href="group__boundary.html#ga3befefe67f79691c117bf5588741355b">sentence_term</a> the segments of text "Hello! How\nare you?" are "Hello!\", "are you?" when <a class="el" href="group__boundary.html#gace7faa10d536c85df0f2d5cac85f2bbc">full_select()</a> is false because "How\n" is selected as sentence by a rule spits the text by line feed. If <a class="el" href="group__boundary.html#gace7faa10d536c85df0f2d5cac85f2bbc">full_select()</a> is true the returned segments are "Hello! ", "How\nare you?" where "How\n" is joined with the following part "are you?" </p>

</div>
</div>
<a class="anchor" id="ga205fd51daa439a18527675e663a0802f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::full_select </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the full_select property value - should segment include in the range values that not belong to specific <a class="el" href="group__boundary.html#ga72b4ceb5bacec0eded2601c43a4d671a">rule()</a> or not.</p>
<p>The default value is false.</p>
<p>For example for <a class="el" href="group__boundary.html#gga15de9963ce9bb6037c8525901dfbf641a88aa1509eace7589f5df87d4694871e9">sentence</a> boundary with rule <a class="el" href="group__boundary.html#ga3befefe67f79691c117bf5588741355b">sentence_term</a> the segments of text "Hello! How\nare you?" are "Hello!\", "are you?" when <a class="el" href="group__boundary.html#gace7faa10d536c85df0f2d5cac85f2bbc">full_select()</a> is false because "How\n" is selected as sentence by a rule spits the text by line feed. If <a class="el" href="group__boundary.html#gace7faa10d536c85df0f2d5cac85f2bbc">full_select()</a> is true the returned segments are "Hello! ", "How\nare you?" where "How\n" is joined with the following part "are you?" </p>

</div>
</div>
<a class="anchor" id="gafa2a756b10d3522743204b45b794bb3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::locale const &amp;&#160;</td>
          <td class="paramname"><em>loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new index for boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">type</a> of the text in range [begin,end) for locale <em>loc</em>.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__boundary.html#ga72b4ceb5bacec0eded2601c43a4d671a">rule()</a> and <a class="el" href="group__boundary.html#gace7faa10d536c85df0f2d5cac85f2bbc">full_select()</a> remain unchanged. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="boundary_8cpp-example.html#a8">boundary.cpp</a>, and <a class="el" href="wboundary_8cpp-example.html#a8">wboundary.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga6b4b5d5cf80b55302a88e7b36c812418"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::locale const &amp;&#160;</td>
          <td class="paramname"><em>loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new index for boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">type</a> of the text in range [begin,end) for locale <em>loc</em>.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__boundary.html#ga1d214029f1a780b7bf6e3f23a3004c03">rule()</a> remains unchanged. </dd></dl>

</div>
</div>
<a class="anchor" id="gab92086846a31a6826c00a3df90027f0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::locale::boundary::operator!= </td>
          <td>(</td>
          <td class="paramtype">BaseIterator const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boundary_point&lt; BaseIterator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the boundary point <em>r</em> points to different location from an iterator <em>l</em> </p>

</div>
</div>
<a class="anchor" id="ga66d8f6c9b1c81c36a55aecebd4960b5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharType , typename TraitsType , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CharType,TraitsType&gt;&amp; boost::locale::boundary::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CharType, TraitsType &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">segment&lt; Iterator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the segment to the stream character by character </p>

</div>
</div>
<a class="anchor" id="gae7941dc874ca05d2ef2a03f781c5b78a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">segment_index const&amp; <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; <a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy an index from a <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>. It copies all indexing information and uses the default rule (all possible segments)</p>
<p>This operation is very cheap, so if you use <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them. ">boundary_point_index</a> and <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">segment_index</a> on same text range it is much better to create one from another rather then indexing the same range twice.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__boundary.html#ga72b4ceb5bacec0eded2601c43a4d671a">rule()</a> flags are not copied </dd></dl>

</div>
</div>
<a class="anchor" id="ga83d57b993b00686b2cac711667c6a931"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boundary_point_index const&amp; <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>&lt; <a class="el" href="group__boundary.html#gab3189e2eaf4386cdf37598e0ba16cfd5">base_iterator</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them. ">boundary_point_index</a> from a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">segment_index</a>. It copies all indexing information and keeps the current <a class="el" href="group__boundary.html#ga1d214029f1a780b7bf6e3f23a3004c03">rule()</a> unchanged</p>
<p>This operation is very cheap, so if you use <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them. ">boundary_point_index</a> and <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">segment_index</a> on same text range it is much better to create one from another rather then indexing the same range twice.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__boundary.html#ga1d214029f1a780b7bf6e3f23a3004c03">rule()</a> flags are not copied </dd></dl>

</div>
</div>
<a class="anchor" id="ga47bc5ece5c461aa4c538354a9e80a707"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::locale::boundary::operator== </td>
          <td>(</td>
          <td class="paramtype">BaseIterator const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boundary_point&lt; BaseIterator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the boundary point <em>r</em> points to same location as an iterator <em>l</em> </p>

</div>
</div>
<a class="anchor" id="ga72b4ceb5bacec0eded2601c43a4d671a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rule_type <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::rule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the mask of rules that are used </p>

</div>
</div>
<a class="anchor" id="gad19735180401edb15acbdbbeb21e5a73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mask of rules that are used </p>

</div>
</div>
<a class="anchor" id="ga1d214029f1a780b7bf6e3f23a3004c03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rule_type <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::rule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the mask of rules that are used </p>

</div>
</div>
<a class="anchor" id="ga56e63913f51109e05a24a7136472a975"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boost::locale::boundary::boundary_point_index</a>&lt; BaseIterator &gt;::rule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mask of rules that are used </p>

</div>
</div>
<a class="anchor" id="ga2c354f4cc03677b58c97038cd84dc465"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::segment_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor.</p>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>When this object is constructed by default it does not include a valid index, thus calling <a class="el" href="group__boundary.html#gaf74ff9c86c177efa8f74856277d659af">begin()</a>, <a class="el" href="group__boundary.html#ga8757062d2446b35675b585651c5fea9f">end()</a> or <a class="el" href="group__boundary.html#ga2480236106971797460187777f2a4411">find()</a> member functions would lead to undefined behavior </p>

</div>
</div>
<a class="anchor" id="ga06ddc335e95479ec51e9b16d0f829bb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::segment_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga25e193c81052ef1795f1b53b46bc2095">rule_type</a>&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::locale const &amp;&#160;</td>
          <td class="paramname"><em>loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">segment_index</a> for boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">type</a> of the text in range [begin,end) using a rule <em>mask</em> for locale <em>loc</em>. </p>

</div>
</div>
<a class="anchor" id="ga46a5f584d5a1a43ad4bc0fff07183fcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::segment_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">boundary_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::locale const &amp;&#160;</td>
          <td class="paramname"><em>loc</em> = <code>std::locale()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">segment_index</a> for boundary analysis <a class="el" href="group__boundary.html#ga15de9963ce9bb6037c8525901dfbf641">type</a> of the text in range [begin,end) selecting all possible segments (full mask) for locale <em>loc</em>. </p>

</div>
</div>
<a class="anchor" id="ga8187f58177fc89ef2f8f818a37111363"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html">boost::locale::boundary::segment_index</a>&lt; BaseIterator &gt;::segment_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>&lt; <a class="el" href="group__boundary.html#ga06f2faacb9d196ebc659ad5382ea2ca5">base_iterator</a> &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">segment_index</a> from a <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html">boundary_point_index</a>. It copies all indexing information and used default rule (all possible segments)</p>
<p>This operation is very cheap, so if you use <a class="el" href="classboost_1_1locale_1_1boundary_1_1boundary__point__index.html" title="This class holds an index of boundary points and allows iterating over them. ">boundary_point_index</a> and <a class="el" href="classboost_1_1locale_1_1boundary_1_1segment__index.html" title="This class holds an index of segments in the text range and allows to iterate over them...">segment_index</a> on same text range it is much better to create one from another rather then indexing the same range twice.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__boundary.html#ga72b4ceb5bacec0eded2601c43a4d671a">rule()</a> flags are not copied </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gad11031065617b6be9d4662d2c06afd52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const rule_type boost::locale::boundary::word_mask = 0xFFFFF</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Full word mask - select all possible variants </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

    <li class="footer">
&copy; Copyright 2009-2012 Artyom Beilis,  Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License</a>, Version 1.0.
    </li>
   </ul>
 </div>
</body>
</html>
