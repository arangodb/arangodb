<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.15"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Generic Image Library: Class Hierarchy</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-boost.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div class="boost-header">
      <table border="0" cellpadding="7" cellspacing="0" width="100%" summary="header">
	<tr>
	  <td valign="top" width="300">
            <h3><a href="../index.html"><img alt="Boost GIL" src="../_static/gil.png" border="0"></a></h3>
	  </td>
	  <td ><h1 align="center"><a href="../index.html"></a></h1></td>
	  <td></td>
	</tr>
      </table>
    </div>
    <hr/>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Class Hierarchy</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">This inheritance list is sorted roughly, but not completely, alphabetically:</div><div class="directory">
<div class="levels">[detail level <span onclick="javascript:toggleLevel(1);">1</span><span onclick="javascript:toggleLevel(2);">2</span><span onclick="javascript:toggleLevel(3);">3</span>]</div><table class="directory">
<tr id="row_0_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1alpha__t.html" target="_self">alpha_t</a></td><td class="desc">Alpha </td></tr>
<tr id="row_1_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1any__image.html" target="_self">any_image&lt; Images &gt;</a></td><td class="desc">Represents a run-time specified image. Note it does NOT model <a class="el" href="structboost_1_1gil_1_1_image_concept.html" title="2-dimensional image whose value type models PixelValueConcept">ImageConcept</a> </td></tr>
<tr id="row_2_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1any__image__view.html" target="_self">any_image_view&lt; Views &gt;</a></td><td class="desc">Represents a run-time specified image view. Models <a class="el" href="structboost_1_1gil_1_1_has_dynamic_x_step_type_concept.html" title="Concept for iterators, locators and views that can define a type just like the given iterator,...">HasDynamicXStepTypeConcept</a>, <a class="el" href="structboost_1_1gil_1_1_has_dynamic_y_step_type_concept.html" title="Concept for locators and views that can define a type just like the given locator or view,...">HasDynamicYStepTypeConcept</a>, Note that this class does NOT model <a class="el" href="structboost_1_1gil_1_1_image_view_concept.html" title="GIL&#39;s 2-dimensional view over immutable GIL pixels.">ImageViewConcept</a> </td></tr>
<tr id="row_3_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_assignable.html" target="_self">Assignable&lt; T &gt;</a></td><td class="desc">Concept of copy assignment requirement </td></tr>
<tr id="row_4_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1binary__operation__obj.html" target="_self">binary_operation_obj&lt; Derived, Result &gt;</a></td><td class="desc">A generic binary operation on viewsUse this class as a convenience superclass when defining an operation for any image views. Many operations have different behavior when the two views are compatible. This class checks for compatibility and invokes apply_compatible(V1,V2) or apply_incompatible(V1,V2) of the subclass. You must provide apply_compatible(V1,V2) method in your subclass, but apply_incompatible(V1,V2) is not required and the default throws std::bad_cast </td></tr>
<tr id="row_5_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1binary__operation__obj.html" target="_self">binary_operation_obj&lt; copy_and_convert_pixels_fn&lt; CC &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_6_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1binary__operation__obj.html" target="_self">binary_operation_obj&lt; copy_pixels_fn &gt;</a></td><td class="desc"></td></tr>
<tr id="row_7_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1binary__operation__obj.html" target="_self">binary_operation_obj&lt; equal_pixels_fn, bool &gt;</a></td><td class="desc"></td></tr>
<tr id="row_8_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1bit__aligned__image__type.html" target="_self">bit_aligned_image_type&lt; ChannelBitSizes, Layout, Alloc &gt;</a></td><td class="desc">Returns the type of a packed image whose pixels may not be byte aligned. For example, an "rgb222" image is bit-aligned because its pixel spans six bits </td></tr>
<tr id="row_9_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_9_" class="arrow" onclick="toggleFolder('9_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1bit__aligned__image__type.html" target="_self">bit_aligned_image_type&lt; mp11::mp_list_c&lt; unsigned, Size1 &gt;, Layout, Alloc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_9_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1bit__aligned__image1__type.html" target="_self">bit_aligned_image1_type&lt; Size1, Layout, Alloc &gt;</a></td><td class="desc">Returns the type of a single-channel bit-aligned image given the bit size of its channel and its layout </td></tr>
<tr id="row_10_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_10_" class="arrow" onclick="toggleFolder('10_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1bit__aligned__image__type.html" target="_self">bit_aligned_image_type&lt; mp11::mp_list_c&lt; unsigned, Size1, Size2 &gt;, Layout, Alloc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_10_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1bit__aligned__image2__type.html" target="_self">bit_aligned_image2_type&lt; Size1, Size2, Layout, Alloc &gt;</a></td><td class="desc">Returns the type of a two channel bit-aligned image given the bit size of its channels and its layout </td></tr>
<tr id="row_11_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_11_" class="arrow" onclick="toggleFolder('11_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1bit__aligned__image__type.html" target="_self">bit_aligned_image_type&lt; mp11::mp_list_c&lt; unsigned, Size1, Size2, Size3 &gt;, Layout, Alloc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_11_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1bit__aligned__image3__type.html" target="_self">bit_aligned_image3_type&lt; Size1, Size2, Size3, Layout, Alloc &gt;</a></td><td class="desc">Returns the type of a three channel bit-aligned image given the bit size of its channels and its layout </td></tr>
<tr id="row_12_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_12_" class="arrow" onclick="toggleFolder('12_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1bit__aligned__image__type.html" target="_self">bit_aligned_image_type&lt; mp11::mp_list_c&lt; unsigned, Size1, Size2, Size3, Size4 &gt;, Layout, Alloc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_12_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1bit__aligned__image4__type.html" target="_self">bit_aligned_image4_type&lt; Size1, Size2, Size3, Size4, Layout, Alloc &gt;</a></td><td class="desc">Returns the type of a four channel bit-aligned image given the bit size of its channels and its layout </td></tr>
<tr id="row_13_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_13_" class="arrow" onclick="toggleFolder('13_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1bit__aligned__image__type.html" target="_self">bit_aligned_image_type&lt; mp11::mp_list_c&lt; unsigned, Size1, Size2, Size3, Size4, Size5 &gt;, Layout, Alloc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_13_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1bit__aligned__image5__type.html" target="_self">bit_aligned_image5_type&lt; Size1, Size2, Size3, Size4, Size5, Layout, Alloc &gt;</a></td><td class="desc">Returns the type of a five channel bit-aligned image given the bit size of its channels and its layout </td></tr>
<tr id="row_14_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1bit__aligned__pixel__iterator.html" target="_self">bit_aligned_pixel_iterator&lt; NonAlignedPixelReference &gt;</a></td><td class="desc">An iterator over non-byte-aligned pixels. Models <a class="el" href="structboost_1_1gil_1_1_pixel_iterator_concept.html" title="An STL random access traversal iterator over a model of PixelConcept.">PixelIteratorConcept</a>, <a class="el" href="structboost_1_1gil_1_1_pixel_based_concept.html" title="Concept for all pixel-based GIL constructs.">PixelBasedConcept</a>, <a class="el" href="structboost_1_1gil_1_1_memory_based_iterator_concept.html" title="Concept of a random-access iterator that can be advanced in memory units (bytes or bits)">MemoryBasedIteratorConcept</a>, <a class="el" href="structboost_1_1gil_1_1_has_dynamic_x_step_type_concept.html" title="Concept for iterators, locators and views that can define a type just like the given iterator,...">HasDynamicXStepTypeConcept</a> </td></tr>
<tr id="row_15_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1bit__range.html" target="_self">bit_range&lt; RangeSize, IsMutable &gt;</a></td><td class="desc"></td></tr>
<tr id="row_16_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1bit__range.html" target="_self">bit_range&lt; bit_size, IsMutable &gt;</a></td><td class="desc"></td></tr>
<tr id="row_17_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1black__t.html" target="_self">black_t</a></td><td class="desc">Black </td></tr>
<tr id="row_18_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1blue__t.html" target="_self">blue_t</a></td><td class="desc">Blue </td></tr>
<tr id="row_19_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1byte__to__memunit.html" target="_self">byte_to_memunit&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_20_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1byte__to__memunit.html" target="_self">byte_to_memunit&lt; Iterator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_21_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__converter.html" target="_self">channel_converter&lt; SrcChannelV, DstChannelV &gt;</a></td><td class="desc">A unary function object converting between channel types </td></tr>
<tr id="row_22_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__converter__unsigned_3_01float32__t_00_01_dst_channel_v_01_4.html" target="_self">channel_converter_unsigned&lt; float32_t, DstChannelV &gt;</a></td><td class="desc">Float32_t conversion </td></tr>
<tr id="row_23_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__converter__unsigned_3_01float32__t_00_01uint32__t_01_4.html" target="_self">channel_converter_unsigned&lt; float32_t, uint32_t &gt;</a></td><td class="desc">32 bit &lt;-&gt; float channel conversion </td></tr>
<tr id="row_24_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__converter__unsigned_3_01uint32__t_00_01float32__t_01_4.html" target="_self">channel_converter_unsigned&lt; uint32_t, float32_t &gt;</a></td><td class="desc">32 bit &lt;-&gt; float channel conversion </td></tr>
<tr id="row_25_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1channel__converter__unsigned__impl.html" target="_self">channel_converter_unsigned_impl&lt; SrcChannelV, DstChannelV, SrcIsIntegral, DstIsIntegral &gt;</a></td><td class="desc">This is the default implementation. Performance specializatons are provided </td></tr>
<tr id="row_26_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1channel__converter__unsigned__impl.html" target="_self">channel_converter_unsigned_impl&lt; SrcChannelV, DstChannelV, detail::is_channel_integral&lt; SrcChannelV &gt;::value, detail::is_channel_integral&lt; DstChannelV &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_27_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__mapping__type_3_01planar__pixel__reference_3_01_channel_reference_00_01_color_space_01_4_01_4.html" target="_self">channel_mapping_type&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="desc">Specifies the color space type of a planar pixel reference. Required by <a class="el" href="structboost_1_1gil_1_1_pixel_based_concept.html" title="Concept for all pixel-based GIL constructs.">PixelBasedConcept</a> </td></tr>
<tr id="row_28_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__multiplier.html" target="_self">channel_multiplier&lt; ChannelValue &gt;</a></td><td class="desc">A function object to multiply two channels. result = a * b / max_value </td></tr>
<tr id="row_29_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__multiplier__unsigned.html" target="_self">channel_multiplier_unsigned&lt; ChannelValue &gt;</a></td><td class="desc">This is the default implementation. Performance specializatons are provided </td></tr>
<tr id="row_30_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__multiplier__unsigned_3_01float32__t_01_4.html" target="_self">channel_multiplier_unsigned&lt; float32_t &gt;</a></td><td class="desc">Specialization of channel_multiply for float 0..1 channels </td></tr>
<tr id="row_31_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__multiplier__unsigned_3_01uint16__t_01_4.html" target="_self">channel_multiplier_unsigned&lt; uint16_t &gt;</a></td><td class="desc">Specialization of channel_multiply for 16-bit unsigned channels </td></tr>
<tr id="row_32_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__multiplier__unsigned_3_01uint8__t_01_4.html" target="_self">channel_multiplier_unsigned&lt; uint8_t &gt;</a></td><td class="desc">Specialization of channel_multiply for 8-bit unsigned channels </td></tr>
<tr id="row_33_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__type.html" target="_self">channel_type&lt; P &gt;</a></td><td class="desc"></td></tr>
<tr id="row_34_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__type.html" target="_self">channel_type&lt; Deref::value_type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_35_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__type.html" target="_self">channel_type&lt; DFn::value_type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_36_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__type.html" target="_self">channel_type&lt; Iterator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_37_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__type.html" target="_self">channel_type&lt; L &gt;</a></td><td class="desc"></td></tr>
<tr id="row_38_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__type.html" target="_self">channel_type&lt; Loc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_39_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__type.html" target="_self">channel_type&lt; memory_based_2d_locator&lt; SI &gt;::parent_t &gt;</a></td><td class="desc"></td></tr>
<tr id="row_40_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__type.html" target="_self">channel_type&lt; Pixel &gt;</a></td><td class="desc"></td></tr>
<tr id="row_41_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__type.html" target="_self">channel_type&lt; PixelBased &gt;</a></td><td class="desc"></td></tr>
<tr id="row_42_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__type_3_01planar__pixel__reference_3_01_channel_reference_00_01_color_space_01_4_01_4.html" target="_self">channel_type&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="desc">Specifies the color space type of a planar pixel reference. Required by <a class="el" href="structboost_1_1gil_1_1_homogeneous_pixel_based_concept.html" title="Concept for homogeneous pixel-based GIL constructs.">HomogeneousPixelBasedConcept</a> </td></tr>
<tr id="row_43_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__type.html" target="_self">channel_type&lt; virtual_2d_locator&lt; D, TR &gt;::parent_t &gt;</a></td><td class="desc"></td></tr>
<tr id="row_44_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__type.html" target="_self">channel_type&lt; XIt &gt;</a></td><td class="desc"></td></tr>
<tr id="row_45_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_channel_concept.html" target="_self">ChannelConcept&lt; T &gt;</a></td><td class="desc">A channel is the building block of a color. Color is defined as a mixture of primary colors and a channel defines the degree to which each primary color is used in the mixture </td></tr>
<tr id="row_46_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_channel_convertible_concept.html" target="_self">ChannelConvertibleConcept&lt; SrcChannel, DstChannel &gt;</a></td><td class="desc">A channel is convertible to another one if the <code>channel_convert</code> algorithm is defined for the two channels </td></tr>
<tr id="row_47_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1_channel_is_mutable_concept.html" target="_self">ChannelIsMutableConcept&lt; T &gt;</a></td><td class="desc"></td></tr>
<tr id="row_48_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_channel_mapping_concept.html" target="_self">ChannelMappingConcept&lt; CM &gt;</a></td><td class="desc">Channel mapping concept </td></tr>
<tr id="row_49_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channels__are__compatible.html" target="_self">channels_are_compatible&lt; T1, T2 &gt;</a></td><td class="desc">Predicate metafunction returning whether two channels are compatible </td></tr>
<tr id="row_50_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_channels_compatible_concept.html" target="_self">ChannelsCompatibleConcept&lt; Channel1, Channel2 &gt;</a></td><td class="desc">Channels are compatible if their associated value types (ignoring constness and references) are the same </td></tr>
<tr id="row_51_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_channel_value_concept.html" target="_self">ChannelValueConcept&lt; T &gt;</a></td><td class="desc">A channel that supports default construction </td></tr>
<tr id="row_52_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_collection_image_view_concept.html" target="_self">CollectionImageViewConcept&lt; View &gt;</a></td><td class="desc">GIL view as Collection </td></tr>
<tr id="row_53_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1color__converted__view__type.html" target="_self">color_converted_view_type&lt; SrcView, DstP, CC &gt;</a></td><td class="desc">Returns the type of a view that does color conversion upon dereferencing its pixels </td></tr>
<tr id="row_54_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1color__converted__view__type_3_01any__image__view_3_01_views_8_8_8_01_4_00_01_dst_p_01_4.html" target="_self">color_converted_view_type&lt; any_image_view&lt; Views... &gt;, DstP &gt;</a></td><td class="desc">Returns the type of a runtime-specified view, color-converted to a given pixel type with the default coor converter </td></tr>
<tr id="row_55_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1color__converted__view__type_3_01any__image__view_3_01_views_8_8_8_01_4_00_01_dst_p_00_01_c_c_01_4.html" target="_self">color_converted_view_type&lt; any_image_view&lt; Views... &gt;, DstP, CC &gt;</a></td><td class="desc">Returns the type of a runtime-specified view, color-converted to a given pixel type with user specified color converter </td></tr>
<tr id="row_56_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1color__converted__view__type.html" target="_self">color_converted_view_type&lt; View, DstP, CC &gt;</a></td><td class="desc"></td></tr>
<tr id="row_57_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1color__space__type_3_01planar__pixel__reference_3_01_channel_reference_00_01_color_space_01_4_01_4.html" target="_self">color_space_type&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="desc">Specifies the color space type of a planar pixel reference. Required by <a class="el" href="structboost_1_1gil_1_1_pixel_based_concept.html" title="Concept for all pixel-based GIL constructs.">PixelBasedConcept</a> </td></tr>
<tr id="row_58_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_color_base_concept.html" target="_self">ColorBaseConcept&lt; ColorBase &gt;</a></td><td class="desc">A color base is a container of color elements (such as channels, channel references or channel pointers) </td></tr>
<tr id="row_59_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_color_bases_compatible_concept.html" target="_self">ColorBasesCompatibleConcept&lt; ColorBase1, ColorBase2 &gt;</a></td><td class="desc">Two color bases are compatible if they have the same color space and their elements are compatible, semantic-pairwise </td></tr>
<tr id="row_60_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_color_base_value_concept.html" target="_self">ColorBaseValueConcept&lt; ColorBase &gt;</a></td><td class="desc">Color base that also has a default-constructor. Refines <a class="el" href="structboost_1_1gil_1_1_regular.html" title="Concept for type regularity requirement.">Regular</a> </td></tr>
<tr id="row_61_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_color_space_concept.html" target="_self">ColorSpaceConcept&lt; CS &gt;</a></td><td class="desc">Color space type concept </td></tr>
<tr id="row_62_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_color_spaces_compatible_concept.html" target="_self">ColorSpacesCompatibleConcept&lt; CS1, CS2 &gt;</a></td><td class="desc">Two color spaces are compatible if they are the same </td></tr>
<tr id="row_63_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1const__iterator__type.html" target="_self">const_iterator_type&lt; It &gt;</a></td><td class="desc">Returns the type of an iterator just like the input iterator, except operating over immutable values </td></tr>
<tr id="row_64_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1contains__color.html" target="_self">contains_color&lt; ColorBase, Color &gt;</a></td><td class="desc">A predicate metafunction determining whether a given color base contains a given color </td></tr>
<tr id="row_65_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1copier__n.html" target="_self">copier_n&lt; I, O &gt;</a></td><td class="desc"></td></tr>
<tr id="row_66_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1copier__n_3_01_i_00_01iterator__from__2d_3_01_o_l_01_4_01_4.html" target="_self">copier_n&lt; I, iterator_from_2d&lt; OL &gt; &gt;</a></td><td class="desc">Destination range is delimited by image iterators </td></tr>
<tr id="row_67_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1copier__n_3_01iterator__from__2d_3_01_i_l_01_4_00_01iterator__from__2d_3_01_o_l_01_4_01_4.html" target="_self">copier_n&lt; iterator_from_2d&lt; IL &gt;, iterator_from_2d&lt; OL &gt; &gt;</a></td><td class="desc">Both source and destination ranges are delimited by image iterators </td></tr>
<tr id="row_68_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1copier__n_3_01iterator__from__2d_3_01_i_l_01_4_00_01_o_01_4.html" target="_self">copier_n&lt; iterator_from_2d&lt; IL &gt;, O &gt;</a></td><td class="desc">Source range is delimited by image iterators </td></tr>
<tr id="row_69_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_copy_constructible.html" target="_self">CopyConstructible&lt; T &gt;</a></td><td class="desc">Concept of copy construction requirement </td></tr>
<tr id="row_70_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1cyan__t.html" target="_self">cyan_t</a></td><td class="desc">Cyan </td></tr>
<tr id="row_71_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1dec.html" target="_self">dec&lt; T &gt;</a></td><td class="desc">Operator&ndash; wrapped in a function object </td></tr>
<tr id="row_72_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1default__channel__converter.html" target="_self">default_channel_converter</a></td><td class="desc">Same as <a class="el" href="structboost_1_1gil_1_1channel__converter.html" title="A unary function object converting between channel types.">channel_converter</a>, except it takes the destination channel by reference, which allows us to move the templates from the class level to the method level. This is important when invoking it on heterogeneous pixels </td></tr>
<tr id="row_73_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1default__color__converter.html" target="_self">default_color_converter</a></td><td class="desc">Class for color-converting one pixel to another </td></tr>
<tr id="row_74_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1default__color__converter__impl.html" target="_self">default_color_converter_impl&lt; C1, C2 &gt;</a></td><td class="desc">Color Convertion function object. To be specialized for every src/dst color space </td></tr>
<tr id="row_75_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1default__color__converter__impl_3_01_c_00_01_c_01_4.html" target="_self">default_color_converter_impl&lt; C, C &gt;</a></td><td class="desc">When the color space is the same, color convertion performs channel depth conversion </td></tr>
<tr id="row_76_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1default__color__converter__impl_3_01_c1_00_01rgba__t_01_4.html" target="_self">default_color_converter_impl&lt; C1, rgba_t &gt;</a></td><td class="desc">Converting any pixel type to RGBA. Note: Supports homogeneous pixels only </td></tr>
<tr id="row_77_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1default__color__converter__impl_3_01cmyk__t_00_01gray__t_01_4.html" target="_self">default_color_converter_impl&lt; cmyk_t, gray_t &gt;</a></td><td class="desc">CMYK to Gray </td></tr>
<tr id="row_78_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1default__color__converter__impl_3_01cmyk__t_00_01rgb__t_01_4.html" target="_self">default_color_converter_impl&lt; cmyk_t, rgb_t &gt;</a></td><td class="desc">CMYK to RGB (not the fastest code in the world) </td></tr>
<tr id="row_79_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1default__color__converter__impl_3_01gray__t_00_01cmyk__t_01_4.html" target="_self">default_color_converter_impl&lt; gray_t, cmyk_t &gt;</a></td><td class="desc">Gray to CMYK </td></tr>
<tr id="row_80_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1default__color__converter__impl_3_01gray__t_00_01rgb__t_01_4.html" target="_self">default_color_converter_impl&lt; gray_t, rgb_t &gt;</a></td><td class="desc">Gray to RGB </td></tr>
<tr id="row_81_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1default__color__converter__impl_3_01rgb__t_00_01cmyk__t_01_4.html" target="_self">default_color_converter_impl&lt; rgb_t, cmyk_t &gt;</a></td><td class="desc">RGB to CMYK (not the fastest code in the world) </td></tr>
<tr id="row_82_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1default__color__converter__impl_3_01rgb__t_00_01gray__t_01_4.html" target="_self">default_color_converter_impl&lt; rgb_t, gray_t &gt;</a></td><td class="desc">RGB to Gray </td></tr>
<tr id="row_83_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1default__color__converter__impl_3_01rgba__t_00_01_c2_01_4.html" target="_self">default_color_converter_impl&lt; rgba_t, C2 &gt;</a></td><td class="desc">Converting RGBA to any pixel type. Note: Supports homogeneous pixels only </td></tr>
<tr id="row_84_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1default__color__converter__impl_3_01rgba__t_00_01rgba__t_01_4.html" target="_self">default_color_converter_impl&lt; rgba_t, rgba_t &gt;</a></td><td class="desc">Unfortunately RGBA to RGBA must be explicitly provided - otherwise we get ambiguous specialization error </td></tr>
<tr id="row_85_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_default_constructible.html" target="_self">DefaultConstructible&lt; T &gt;</a></td><td class="desc">Concept of default construction requirement </td></tr>
<tr id="row_86_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1deref__base.html" target="_self">deref_base&lt; ConstT, Value, Reference, ConstReference, ArgType, ResultType, IsMutable &gt;</a></td><td class="desc">Helper base class for pixel dereference adaptors </td></tr>
<tr id="row_87_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_87_" class="arrow" onclick="toggleFolder('87_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1deref__base.html" target="_self">deref_base&lt; color_convert_deref_fn&lt; SrcConstRefP, DstP, CC &gt;, DstP, DstP, const DstP &amp;, SrcConstRefP, DstP, false &gt;</a></td><td class="desc"></td></tr>
<tr id="row_87_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1color__convert__deref__fn.html" target="_self">color_convert_deref_fn&lt; SrcConstRefP, DstP, CC &gt;</a></td><td class="desc">Function object that given a source pixel, returns it converted to a given color space and channel depth. Models: <a class="el" href="structboost_1_1gil_1_1_pixel_dereference_adaptor_concept.html" title="Represents a unary function object that can be invoked upon dereferencing a pixel iterator.">PixelDereferenceAdaptorConcept</a> </td></tr>
<tr id="row_88_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_88_" class="arrow" onclick="toggleFolder('88_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1deref__base.html" target="_self">deref_base&lt; deref_compose&lt; D1::const_t, D2::const_t &gt;, D1::value_type, D1::reference, D1::const_reference, D2::argument_type, D1::result_type, D1::is_mutable &amp;&amp;D2::is_mutable &gt;</a></td><td class="desc"></td></tr>
<tr id="row_88_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1deref__compose.html" target="_self">deref_compose&lt; D1, D2 &gt;</a></td><td class="desc">Composes two dereference function objects. Similar to std::unary_compose but needs to pull some aliases from the component types. Models: <a class="el" href="structboost_1_1gil_1_1_pixel_dereference_adaptor_concept.html" title="Represents a unary function object that can be invoked upon dereferencing a pixel iterator.">PixelDereferenceAdaptorConcept</a> </td></tr>
<tr id="row_89_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1dereference__iterator__adaptor.html" target="_self">dereference_iterator_adaptor&lt; Iterator, DFn &gt;</a></td><td class="desc">An adaptor over an existing iterator that provides for custom filter on dereferencing the object. Models: <a class="el" href="structboost_1_1gil_1_1_iterator_adaptor_concept.html" title="Iterator adaptor is a forward iterator adapting another forward iterator.">IteratorAdaptorConcept</a>, <a class="el" href="structboost_1_1gil_1_1_pixel_iterator_concept.html" title="An STL random access traversal iterator over a model of PixelConcept.">PixelIteratorConcept</a> </td></tr>
<tr id="row_90_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1derived__image__type.html" target="_self">derived_image_type&lt; Image, T, L, IsPlanar &gt;</a></td><td class="desc">Constructs a homogeneous image type from a source image type by changing some of the properties.Use use_default for the properties of the source image that you want to keep </td></tr>
<tr id="row_91_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1derived__iterator__type.html" target="_self">derived_iterator_type&lt; Iterator, T, L, IsPlanar, IsStep, IsMutable &gt;</a></td><td class="desc">Constructs a pixel iterator type from a source pixel iterator type by changing some of the properties.Use use_default for the properties of the source view that you want to keep </td></tr>
<tr id="row_92_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1derived__pixel__reference__type.html" target="_self">derived_pixel_reference_type&lt; Ref, T, L, IsPlanar, IsMutable &gt;</a></td><td class="desc">Constructs a pixel reference type from a source pixel reference type by changing some of the properties.Use use_default for the properties of the source view that you want to keep </td></tr>
<tr id="row_93_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1derived__view__type.html" target="_self">derived_view_type&lt; View, T, L, IsPlanar, StepX, IsMutable &gt;</a></td><td class="desc">Constructs an image view type from a source view type by changing some of the properties.Use use_default for the properties of the source view that you want to keep </td></tr>
<tr id="row_94_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1devicen__color__t.html" target="_self">devicen_color_t&lt; N &gt;</a></td><td class="desc">Unnamed color </td></tr>
<tr id="row_95_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1devicen__t.html" target="_self">devicen_t&lt; N &gt;</a></td><td class="desc">Unnamed color space of 1, 3, 4, or 5 channels </td></tr>
<tr id="row_96_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1dynamic__x__step__type.html" target="_self">dynamic_x_step_type&lt; IteratorOrLocatorOrView &gt;</a></td><td class="desc">Base template for types that model <a class="el" href="structboost_1_1gil_1_1_has_dynamic_x_step_type_concept.html" title="Concept for iterators, locators and views that can define a type just like the given iterator,...">HasDynamicXStepTypeConcept</a> </td></tr>
<tr id="row_97_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1dynamic__y__step__type.html" target="_self">dynamic_y_step_type&lt; LocatorOrView &gt;</a></td><td class="desc">Base template for types that model <a class="el" href="structboost_1_1gil_1_1_has_dynamic_y_step_type_concept.html" title="Concept for locators and views that can define a type just like the given locator or view,...">HasDynamicYStepTypeConcept</a> </td></tr>
<tr id="row_98_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_98_" class="arrow" onclick="toggleFolder('98_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1dynamic__y__step__type.html" target="_self">dynamic_y_step_type&lt; dynamic_x_step_type&lt; transposed_type&lt; View &gt;::type &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_98_0_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_98_0_" class="arrow" onclick="toggleFolder('98_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1dynamic__xy__step__type.html" target="_self">dynamic_xy_step_type&lt; transposed_type&lt; View &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_98_0_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1dynamic__xy__step__transposed__type.html" target="_self">dynamic_xy_step_transposed_type&lt; View &gt;</a></td><td class="desc">Returns the type of a transposed view that has a dynamic step along both X and Y </td></tr>
<tr id="row_99_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_99_" class="arrow" onclick="toggleFolder('99_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1dynamic__y__step__type.html" target="_self">dynamic_y_step_type&lt; dynamic_x_step_type&lt; View &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_99_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1dynamic__xy__step__type.html" target="_self">dynamic_xy_step_type&lt; View &gt;</a></td><td class="desc">Returns the type of a view that has a dynamic step along both X and Y </td></tr>
<tr id="row_100_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1element__const__reference__type.html" target="_self">element_const_reference_type&lt; ColorBase &gt;</a></td><td class="desc">Specifies the return type of the constant element accessor at_c of a homogeneous color base </td></tr>
<tr id="row_101_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1element__reference__type.html" target="_self">element_reference_type&lt; ColorBase &gt;</a></td><td class="desc">Specifies the return type of the mutable element accessor at_c of a homogeneous color base </td></tr>
<tr id="row_102_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1element__type.html" target="_self">element_type&lt; ColorBase &gt;</a></td><td class="desc">Specifies the element type of a homogeneous color base </td></tr>
<tr id="row_103_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1element__type.html" target="_self">element_type&lt; P &gt;</a></td><td class="desc"></td></tr>
<tr id="row_104_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1equal__n__fn_3_01boost_1_1gil_1_1iterator__from__2d_3_01_loc_01_4_00_01_it_01_4.html" target="_self">equal_n_fn&lt; boost::gil::iterator_from_2d&lt; Loc &gt;, It &gt;</a></td><td class="desc"></td></tr>
<tr id="row_105_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1equal__n__fn_3_01boost_1_1gil_1_1iterator__from__2d_3_01_loc1_01629d3bb430b0f68b56ea86189659092c.html" target="_self">equal_n_fn&lt; boost::gil::iterator_from_2d&lt; Loc1 &gt;, boost::gil::iterator_from_2d&lt; Loc2 &gt; &gt;</a></td><td class="desc">Both source and destination ranges are delimited by image iterators </td></tr>
<tr id="row_106_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1equal__n__fn_3_01_it_00_01boost_1_1gil_1_1iterator__from__2d_3_01_loc_01_4_01_4.html" target="_self">equal_n_fn&lt; It, boost::gil::iterator_from_2d&lt; Loc &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_107_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1equal__n__fn_3_01pixel_3_01_t_00_01_c_s_01_4_01const_01_5_00_01pf9bfe8ab8bfc90e04b4b4cc6781043d9.html" target="_self">equal_n_fn&lt; pixel&lt; T, CS &gt; const *, pixel&lt; T, CS &gt; const * &gt;</a></td><td class="desc"></td></tr>
<tr id="row_108_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1equal__n__fn_3_01planar__pixel__iterator_3_01_i_c_00_01_c_s_01_4d72b7921e34c93820ef294c57244dd71.html" target="_self">equal_n_fn&lt; planar_pixel_iterator&lt; IC, CS &gt;, planar_pixel_iterator&lt; IC, CS &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_109_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_equality_comparable.html" target="_self">EqualityComparable&lt; T &gt;</a></td><td class="desc">Concept of == and != comparability requirement </td></tr>
<tr id="row_110_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1detail_1_1file__stream__device.html" target="_self">file_stream_device&lt; FormatTag &gt;</a></td><td class="desc"></td></tr>
<tr id="row_111_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_forward_collection_image_view_concept.html" target="_self">ForwardCollectionImageViewConcept&lt; View &gt;</a></td><td class="desc">GIL view as ForwardCollection </td></tr>
<tr id="row_112_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1get__dynamic__image__reader.html" target="_self">get_dynamic_image_reader&lt; T, FormatTag, Enable &gt;</a></td><td class="desc">Helper metafunction to generate dynamic image reader type </td></tr>
<tr id="row_113_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1get__dynamic__image__writer.html" target="_self">get_dynamic_image_writer&lt; T, FormatTag, Enable &gt;</a></td><td class="desc">Helper metafunction to generate dynamic image writer type </td></tr>
<tr id="row_114_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1get__reader.html" target="_self">get_reader&lt; T, FormatTag, ConversionPolicy, Enable &gt;</a></td><td class="desc">Helper metafunction to generate image reader type </td></tr>
<tr id="row_115_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1get__reader__backend.html" target="_self">get_reader_backend&lt; T, FormatTag, Enable &gt;</a></td><td class="desc">Helper metafunction to generate image backend type </td></tr>
<tr id="row_116_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1get__scanline__reader.html" target="_self">get_scanline_reader&lt; T, FormatTag &gt;</a></td><td class="desc">Helper metafunction to generate image scanline_reader type </td></tr>
<tr id="row_117_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1get__writer.html" target="_self">get_writer&lt; T, FormatTag, Enable &gt;</a></td><td class="desc">Helper metafunction to generate writer type </td></tr>
<tr id="row_118_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1gray__color__t.html" target="_self">gray_color_t</a></td><td class="desc">Gray </td></tr>
<tr id="row_119_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1green__t.html" target="_self">green_t</a></td><td class="desc">Green </td></tr>
<tr id="row_120_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_has_dynamic_x_step_type_concept.html" target="_self">HasDynamicXStepTypeConcept&lt; T &gt;</a></td><td class="desc">Concept for iterators, locators and views that can define a type just like the given iterator, locator or view, except it supports runtime specified step along the X navigation </td></tr>
<tr id="row_121_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_has_dynamic_y_step_type_concept.html" target="_self">HasDynamicYStepTypeConcept&lt; T &gt;</a></td><td class="desc">Concept for locators and views that can define a type just like the given locator or view, except it supports runtime specified step along the Y navigation </td></tr>
<tr id="row_122_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_has_transposed_type_concept.html" target="_self">HasTransposedTypeConcept&lt; T &gt;</a></td><td class="desc">Concept for locators and views that can define a type just like the given locator or view, except X and Y is swapped </td></tr>
<tr id="row_123_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1homogeneous__color__base_3_01_element_00_01_layout_00_011_01_4.html" target="_self">homogeneous_color_base&lt; Element, Layout, 1 &gt;</a></td><td class="desc">A homogeneous color base holding one color element. Models <a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_concept.html" title="Color base whose elements all have the same type.">HomogeneousColorBaseConcept</a> or <a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_value_concept.html" title="Homogeneous color base that also has a default constructor. Refines Regular.">HomogeneousColorBaseValueConcept</a> </td></tr>
<tr id="row_124_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1homogeneous__color__base_3_01_element_00_01_layout_00_012_01_4.html" target="_self">homogeneous_color_base&lt; Element, Layout, 2 &gt;</a></td><td class="desc">A homogeneous color base holding two color elements Models <a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_concept.html" title="Color base whose elements all have the same type.">HomogeneousColorBaseConcept</a> or <a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_value_concept.html" title="Homogeneous color base that also has a default constructor. Refines Regular.">HomogeneousColorBaseValueConcept</a> </td></tr>
<tr id="row_125_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1homogeneous__color__base_3_01_element_00_01_layout_00_013_01_4.html" target="_self">homogeneous_color_base&lt; Element, Layout, 3 &gt;</a></td><td class="desc">A homogeneous color base holding three color elements. Models <a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_concept.html" title="Color base whose elements all have the same type.">HomogeneousColorBaseConcept</a> or <a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_value_concept.html" title="Homogeneous color base that also has a default constructor. Refines Regular.">HomogeneousColorBaseValueConcept</a> </td></tr>
<tr id="row_126_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1homogeneous__color__base_3_01_element_00_01_layout_00_014_01_4.html" target="_self">homogeneous_color_base&lt; Element, Layout, 4 &gt;</a></td><td class="desc">A homogeneous color base holding four color elements. Models <a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_concept.html" title="Color base whose elements all have the same type.">HomogeneousColorBaseConcept</a> or <a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_value_concept.html" title="Homogeneous color base that also has a default constructor. Refines Regular.">HomogeneousColorBaseValueConcept</a> </td></tr>
<tr id="row_127_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1homogeneous__color__base_3_01_element_00_01_layout_00_015_01_4.html" target="_self">homogeneous_color_base&lt; Element, Layout, 5 &gt;</a></td><td class="desc">A homogeneous color base holding five color elements. Models <a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_concept.html" title="Color base whose elements all have the same type.">HomogeneousColorBaseConcept</a> or <a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_value_concept.html" title="Homogeneous color base that also has a default constructor. Refines Regular.">HomogeneousColorBaseValueConcept</a> </td></tr>
<tr id="row_128_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_concept.html" target="_self">HomogeneousColorBaseConcept&lt; ColorBase &gt;</a></td><td class="desc">Color base whose elements all have the same type </td></tr>
<tr id="row_129_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_value_concept.html" target="_self">HomogeneousColorBaseValueConcept&lt; ColorBase &gt;</a></td><td class="desc">Homogeneous color base that also has a default constructor. Refines <a class="el" href="structboost_1_1gil_1_1_regular.html" title="Concept for type regularity requirement.">Regular</a> </td></tr>
<tr id="row_130_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_homogeneous_pixel_based_concept.html" target="_self">HomogeneousPixelBasedConcept&lt; P &gt;</a></td><td class="desc">Concept for homogeneous pixel-based GIL constructs </td></tr>
<tr id="row_131_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_homogeneous_pixel_concept.html" target="_self">HomogeneousPixelConcept&lt; P &gt;</a></td><td class="desc">Homogeneous pixel concept </td></tr>
<tr id="row_132_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_homogeneous_pixel_value_concept.html" target="_self">HomogeneousPixelValueConcept&lt; P &gt;</a></td><td class="desc">Homogeneous pixel concept that is a <a class="el" href="structboost_1_1gil_1_1_regular.html" title="Concept for type regularity requirement.">Regular</a> type </td></tr>
<tr id="row_133_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_133_" class="arrow" onclick="toggleFolder('133_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1identity.html" target="_self">identity&lt; T &gt;</a></td><td class="desc">Identity taken from SGI STL </td></tr>
<tr id="row_133_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1channel__converter__unsigned_3_01_t_00_01_t_01_4.html" target="_self">channel_converter_unsigned&lt; T, T &gt;</a></td><td class="desc">Converting a channel to itself - identity operation </td></tr>
<tr id="row_134_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1identity.html" target="_self">identity&lt; ChannelValue &gt;</a></td><td class="desc"></td></tr>
<tr id="row_135_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1image.html" target="_self">image&lt; Pixel, IsPlanar, Alloc &gt;</a></td><td class="desc">Container interface over image view. Models <a class="el" href="structboost_1_1gil_1_1_image_concept.html" title="2-dimensional image whose value type models PixelValueConcept">ImageConcept</a>, <a class="el" href="structboost_1_1gil_1_1_pixel_based_concept.html" title="Concept for all pixel-based GIL constructs.">PixelBasedConcept</a> </td></tr>
<tr id="row_136_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1image__is__basic.html" target="_self">image_is_basic&lt; Img &gt;</a></td><td class="desc">Basic images must use basic views and std::allocator </td></tr>
<tr id="row_137_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1image__type.html" target="_self">image_type&lt; T, L, IsPlanar, Alloc &gt;</a></td><td class="desc">Returns the type of a homogeneous image given the channel type, layout, and whether it operates on planar data </td></tr>
<tr id="row_138_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1image__view.html" target="_self">image_view&lt; Loc &gt;</a></td><td class="desc">A lightweight object that interprets memory as a 2D array of pixels. Models <a class="el" href="structboost_1_1gil_1_1_image_view_concept.html" title="GIL&#39;s 2-dimensional view over immutable GIL pixels.">ImageViewConcept</a>,<a class="el" href="structboost_1_1gil_1_1_pixel_based_concept.html" title="Concept for all pixel-based GIL constructs.">PixelBasedConcept</a>,<a class="el" href="structboost_1_1gil_1_1_has_dynamic_x_step_type_concept.html" title="Concept for iterators, locators and views that can define a type just like the given iterator,...">HasDynamicXStepTypeConcept</a>,<a class="el" href="structboost_1_1gil_1_1_has_dynamic_y_step_type_concept.html" title="Concept for locators and views that can define a type just like the given locator or view,...">HasDynamicYStepTypeConcept</a>,<a class="el" href="structboost_1_1gil_1_1_has_transposed_type_concept.html" title="Concept for locators and views that can define a type just like the given locator or view,...">HasTransposedTypeConcept</a> </td></tr>
<tr id="row_139_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_image_concept.html" target="_self">ImageConcept&lt; Image &gt;</a></td><td class="desc">2-dimensional image whose value type models <a class="el" href="structboost_1_1gil_1_1_pixel_value_concept.html" title="Pixel concept that is a Regular type.">PixelValueConcept</a> </td></tr>
<tr id="row_140_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_image_view_concept.html" target="_self">ImageViewConcept&lt; View &gt;</a></td><td class="desc">GIL's 2-dimensional view over immutable GIL pixels </td></tr>
<tr id="row_141_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1inc.html" target="_self">inc&lt; T &gt;</a></td><td class="desc">Operator++ wrapped in a function object </td></tr>
<tr id="row_142_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1is__input__device.html" target="_self">is_input_device&lt; IODevice &gt;</a></td><td class="desc"></td></tr>
<tr id="row_143_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1is__iterator__adaptor.html" target="_self">is_iterator_adaptor&lt; It &gt;</a></td><td class="desc"><a class="el" href="structboost_1_1gil_1_1_metafunction.html" title="Concept for type as metafunction requirement.">Metafunction</a> predicate determining whether the given iterator is a plain one or an adaptor over another iterator. Examples of adaptors are the step iterator and the dereference iterator adaptor </td></tr>
<tr id="row_144_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1is__output__device.html" target="_self">is_output_device&lt; IODevice &gt;</a></td><td class="desc"></td></tr>
<tr id="row_145_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1is__pixel_3_01bit__aligned__pixel__reference_3_01_b_00_01_c_00_01_l_00_01_m_01_4_01_4.html" target="_self">is_pixel&lt; bit_aligned_pixel_reference&lt; B, C, L, M &gt; &gt;</a></td><td class="desc"><a class="el" href="structboost_1_1gil_1_1_metafunction.html" title="Concept for type as metafunction requirement.">Metafunction</a> predicate that flags bit_aligned_pixel_reference as a model of <a class="el" href="structboost_1_1gil_1_1_pixel_concept.html" title="Pixel concept - A color base whose elements are channels.">PixelConcept</a>. Required by <a class="el" href="structboost_1_1gil_1_1_pixel_concept.html" title="Pixel concept - A color base whose elements are channels.">PixelConcept</a> </td></tr>
<tr id="row_146_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1is__pixel_3_01planar__pixel__reference_3_01_channel_reference_00_01_color_space_01_4_01_4.html" target="_self">is_pixel&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="desc"><a class="el" href="structboost_1_1gil_1_1_metafunction.html" title="Concept for type as metafunction requirement.">Metafunction</a> predicate that flags <a class="el" href="structboost_1_1gil_1_1planar__pixel__reference.html" title="A reference proxy to a planar pixel.">planar_pixel_reference</a> as a model of <a class="el" href="structboost_1_1gil_1_1_pixel_concept.html" title="Pixel concept - A color base whose elements are channels.">PixelConcept</a>. Required by <a class="el" href="structboost_1_1gil_1_1_pixel_concept.html" title="Pixel concept - A color base whose elements are channels.">PixelConcept</a> </td></tr>
<tr id="row_147_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1is__planar_3_01planar__pixel__reference_3_01_channel_reference_00_01_color_space_01_4_01_4.html" target="_self">is_planar&lt; planar_pixel_reference&lt; ChannelReference, ColorSpace &gt; &gt;</a></td><td class="desc">Specifies that <a class="el" href="structboost_1_1gil_1_1planar__pixel__reference.html" title="A reference proxy to a planar pixel.">planar_pixel_reference</a> represents a planar construct. Required by <a class="el" href="structboost_1_1gil_1_1_pixel_based_concept.html" title="Concept for all pixel-based GIL constructs.">PixelBasedConcept</a> </td></tr>
<tr id="row_148_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1is__read__device.html" target="_self">is_read_device&lt; FormatTag, T, D &gt;</a></td><td class="desc"></td></tr>
<tr id="row_149_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1is__read__only.html" target="_self">is_read_only&lt; Conversion_Policy &gt;</a></td><td class="desc">Determines if reader type is read only ( no conversion ) </td></tr>
<tr id="row_150_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1is__read__supported.html" target="_self">is_read_supported&lt; Pixel, FormatTag &gt;</a></td><td class="desc"></td></tr>
<tr id="row_151_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1is__write__device.html" target="_self">is_write_device&lt; FormatTag, T, D &gt;</a></td><td class="desc"></td></tr>
<tr id="row_152_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1detail_1_1istream__device.html" target="_self">istream_device&lt; FormatTag &gt;</a></td><td class="desc"></td></tr>
<tr id="row_153_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__adaptor__get__base.html" target="_self">iterator_adaptor_get_base&lt; It &gt;</a></td><td class="desc">Returns the base iterator for a given iterator adaptor. Provide an specialization when introducing new iterator adaptors </td></tr>
<tr id="row_154_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__adaptor__rebind.html" target="_self">iterator_adaptor_rebind&lt; It, NewBaseIt &gt;</a></td><td class="desc">Changes the base iterator of an iterator adaptor. Provide an specialization when introducing new iterator adaptors </td></tr>
<tr id="row_155_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__add__deref.html" target="_self">iterator_add_deref&lt; Iterator, Deref &gt;</a></td><td class="desc">Returns the type (and creates an instance) of an iterator that invokes the given dereference adaptor upon dereferencing </td></tr>
<tr id="row_156_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__add__deref_3_01dereference__iterator__adaptor_3_01_iterator_00_0927b7f3fa453e9b4decea8a0c8e52f27.html" target="_self">iterator_add_deref&lt; dereference_iterator_adaptor&lt; Iterator, PREV_DEREF &gt;, Deref &gt;</a></td><td class="desc">For dereference iterator adaptors, compose the new function object after the old one </td></tr>
<tr id="row_157_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html" target="_self">iterator_from_2d&lt; Loc2 &gt;</a></td><td class="desc">Provides 1D random-access navigation to the pixels of the image. Models: <a class="el" href="structboost_1_1gil_1_1_pixel_iterator_concept.html" title="An STL random access traversal iterator over a model of PixelConcept.">PixelIteratorConcept</a>, <a class="el" href="structboost_1_1gil_1_1_pixel_based_concept.html" title="Concept for all pixel-based GIL constructs.">PixelBasedConcept</a>, <a class="el" href="structboost_1_1gil_1_1_has_dynamic_x_step_type_concept.html" title="Concept for iterators, locators and views that can define a type just like the given iterator,...">HasDynamicXStepTypeConcept</a> </td></tr>
<tr id="row_158_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__basic.html" target="_self">iterator_is_basic&lt; Iterator &gt;</a></td><td class="desc">Determines if a given pixel iterator is basic Basic iterators must use <a class="el" href="structboost_1_1gil_1_1pixel.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept,...">gil::pixel</a> (if interleaved), <a class="el" href="structboost_1_1gil_1_1planar__pixel__iterator.html" title="An iterator over planar pixels. Models HomogeneousColorBaseConcept, PixelIteratorConcept,...">gil::planar_pixel_iterator</a> (if planar) and <a class="el" href="classboost_1_1gil_1_1memory__based__step__iterator.html" title="MEMORY-BASED STEP ITERATOR.">gil::memory_based_step_iterator</a> (if step). They must use the standard constness rules </td></tr>
<tr id="row_159_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__basic_3_01memory__based__step__iterator_3_01pixel_3_01_t_00_01_l_01_4_01_5_01_4_01_4.html" target="_self">iterator_is_basic&lt; memory_based_step_iterator&lt; pixel&lt; T, L &gt; * &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_160_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__basic_3_01memory__based__step__iterator_3_01pixel_3_01_t_00_49e6005b45e6301328ca4342b3cea079.html" target="_self">iterator_is_basic&lt; memory_based_step_iterator&lt; pixel&lt; T, L &gt; const * &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_161_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__basic_3_01memory__based__step__iterator_3_01planar__pixel__i11756f255913088facaf56838bba8ad0.html" target="_self">iterator_is_basic&lt; memory_based_step_iterator&lt; planar_pixel_iterator&lt; T *, CS &gt; &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_162_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__basic_3_01memory__based__step__iterator_3_01planar__pixel__i1e167244adb96adf7850fda415bdbfe9.html" target="_self">iterator_is_basic&lt; memory_based_step_iterator&lt; planar_pixel_iterator&lt; T const *, CS &gt; &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_163_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__basic_3_01pixel_3_01_t_00_01_l_01_4_01_5_01_4.html" target="_self">iterator_is_basic&lt; pixel&lt; T, L &gt; * &gt;</a></td><td class="desc"></td></tr>
<tr id="row_164_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__basic_3_01pixel_3_01_t_00_01_l_01_4_01const_01_5_01_4.html" target="_self">iterator_is_basic&lt; pixel&lt; T, L &gt; const * &gt;</a></td><td class="desc"></td></tr>
<tr id="row_165_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__basic_3_01planar__pixel__iterator_3_01_t_01_5_00_01_c_s_01_4_01_4.html" target="_self">iterator_is_basic&lt; planar_pixel_iterator&lt; T *, CS &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_166_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__basic_3_01planar__pixel__iterator_3_01_t_01const_01_5_00_01_c_s_01_4_01_4.html" target="_self">iterator_is_basic&lt; planar_pixel_iterator&lt; T const *, CS &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_167_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__mutable.html" target="_self">iterator_is_mutable&lt; It &gt;</a></td><td class="desc"><a class="el" href="structboost_1_1gil_1_1_metafunction.html" title="Concept for type as metafunction requirement.">Metafunction</a> predicate returning whether the given iterator allows for changing its values </td></tr>
<tr id="row_168_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__mutable.html" target="_self">iterator_is_mutable&lt; Iterator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_169_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_169_" class="arrow" onclick="toggleFolder('169_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__mutable.html" target="_self">iterator_is_mutable&lt; L::x_iterator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_169_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1locator__is__mutable.html" target="_self">locator_is_mutable&lt; L &gt;</a></td><td class="desc">Determines if the given locator is mutable (i.e. its pixels can be changed) </td></tr>
<tr id="row_170_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__mutable.html" target="_self">iterator_is_mutable&lt; Loc::x_iterator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_171_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_171_" class="arrow" onclick="toggleFolder('171_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__mutable.html" target="_self">iterator_is_mutable&lt; V::x_iterator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_171_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1view__is__mutable.html" target="_self">view_is_mutable&lt; V &gt;</a></td><td class="desc">Determines if the given view is mutable (i.e. its pixels can be changed) </td></tr>
<tr id="row_172_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__step.html" target="_self">iterator_is_step&lt; I &gt;</a></td><td class="desc">Determines if the given iterator has a step that could be set dynamically </td></tr>
<tr id="row_173_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__step.html" target="_self">iterator_is_step&lt; iterator_adaptor_get_base&lt; It &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_174_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_174_" class="arrow" onclick="toggleFolder('174_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__step.html" target="_self">iterator_is_step&lt; L::x_iterator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_174_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1locator__is__step__in__x.html" target="_self">locator_is_step_in_x&lt; L &gt;</a></td><td class="desc">Determines if the given locator has a horizontal step that could be set dynamically </td></tr>
<tr id="row_175_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_175_" class="arrow" onclick="toggleFolder('175_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__step.html" target="_self">iterator_is_step&lt; L::y_iterator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_175_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1locator__is__step__in__y.html" target="_self">locator_is_step_in_y&lt; L &gt;</a></td><td class="desc">Determines if the given locator has a vertical step that could be set dynamically </td></tr>
<tr id="row_176_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_176_" class="arrow" onclick="toggleFolder('176_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__step.html" target="_self">iterator_is_step&lt; V::xy_locator ::x_iterator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_176_0_" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_176_0_" class="arrow" onclick="toggleFolder('176_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1locator__is__step__in__x.html" target="_self">locator_is_step_in_x&lt; V::xy_locator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_176_0_0_" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1view__is__step__in__x.html" target="_self">view_is_step_in_x&lt; V &gt;</a></td><td class="desc">Determines if the given view has a horizontal step that could be set dynamically </td></tr>
<tr id="row_177_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_177_" class="arrow" onclick="toggleFolder('177_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__is__step.html" target="_self">iterator_is_step&lt; V::xy_locator ::y_iterator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_177_0_" class="even" style="display:none;"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span id="arr_177_0_" class="arrow" onclick="toggleFolder('177_0_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1locator__is__step__in__y.html" target="_self">locator_is_step_in_y&lt; V::xy_locator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_177_0_0_" class="even" style="display:none;"><td class="entry"><span style="width:48px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1view__is__step__in__y.html" target="_self">view_is_step_in_y&lt; V &gt;</a></td><td class="desc">Determines if the given view has a vertical step that could be set dynamically </td></tr>
<tr id="row_178_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__type.html" target="_self">iterator_type&lt; T, L, IsPlanar, IsStep, IsMutable &gt;</a></td><td class="desc">Returns the type of a homogeneous iterator given the channel type, layout, whether it operates on planar data, whether it is a step iterator, and whether it is mutable </td></tr>
<tr id="row_179_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__type__from__pixel.html" target="_self">iterator_type_from_pixel&lt; Pixel, IsPlanar, IsStep, IsMutable &gt;</a></td><td class="desc">Returns the type of a pixel iterator given the pixel type, whether it operates on planar data, whether it is a step iterator, and whether it is mutable </td></tr>
<tr id="row_180_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1iterator__type__from__pixel.html" target="_self">iterator_type_from_pixel&lt; const bit_aligned_pixel_reference&lt; B, C, L, M &gt;, IsPlanar, IsStep, IsMutable &gt;</a></td><td class="desc"></td></tr>
<tr id="row_181_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_iterator_adaptor_concept.html" target="_self">IteratorAdaptorConcept&lt; Iterator &gt;</a></td><td class="desc">Iterator adaptor is a forward iterator adapting another forward iterator </td></tr>
<tr id="row_182_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1kth__channel__deref__fn.html" target="_self">kth_channel_deref_fn&lt; K, SrcP &gt;</a></td><td class="desc">Function object that returns a grayscale reference of the K-th channel (specified as a template parameter) of a given reference. Models: <a class="el" href="structboost_1_1gil_1_1_pixel_dereference_adaptor_concept.html" title="Represents a unary function object that can be invoked upon dereferencing a pixel iterator.">PixelDereferenceAdaptorConcept</a>.If the input is a pixel value or constant reference, the function object is immutable. Otherwise it is mutable (and returns non-const reference to the k-th channel) </td></tr>
<tr id="row_183_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1kth__channel__view__type.html" target="_self">kth_channel_view_type&lt; K, View &gt;</a></td><td class="desc">Given a source image view type View, returns the type of an image view over a given channel of View.If the channels in the source view are adjacent in memory (such as planar non-step view or single-channel view) then the return view is a single-channel non-step view. If the channels are non-adjacent (interleaved and/or step view) then the return view is a single-channel step view </td></tr>
<tr id="row_184_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1kth__semantic__element__const__reference__type.html" target="_self">kth_semantic_element_const_reference_type&lt; ColorBase, K &gt;</a></td><td class="desc">Specifies the return type of the constant semantic_at_c&lt;K&gt;(color_base); </td></tr>
<tr id="row_185_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_185_" class="arrow" onclick="toggleFolder('185_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1kth__semantic__element__const__reference__type.html" target="_self">kth_semantic_element_const_reference_type&lt; ColorBase, color_index_type&lt; ColorBase, Color &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_185_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1color__element__const__reference__type.html" target="_self">color_element_const_reference_type&lt; ColorBase, Color &gt;</a></td><td class="desc">Specifies the return type of the constant element accessor by color name, get_color(color_base, Color()); </td></tr>
<tr id="row_186_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1kth__semantic__element__reference__type.html" target="_self">kth_semantic_element_reference_type&lt; ColorBase, K &gt;</a></td><td class="desc">Specifies the return type of the mutable semantic_at_c&lt;K&gt;(color_base); </td></tr>
<tr id="row_187_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_187_" class="arrow" onclick="toggleFolder('187_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1kth__semantic__element__reference__type.html" target="_self">kth_semantic_element_reference_type&lt; ColorBase, color_index_type&lt; ColorBase, Color &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_187_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1color__element__reference__type.html" target="_self">color_element_reference_type&lt; ColorBase, Color &gt;</a></td><td class="desc">Specifies the return type of the mutable element accessor by color name, get_color(color_base, Color()); </td></tr>
<tr id="row_188_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1kth__semantic__element__type.html" target="_self">kth_semantic_element_type&lt; ColorBase, K &gt;</a></td><td class="desc">Specifies the type of the K-th semantic element of a color base </td></tr>
<tr id="row_189_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_189_" class="arrow" onclick="toggleFolder('189_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1kth__semantic__element__type.html" target="_self">kth_semantic_element_type&lt; ColorBase, color_index_type&lt; ColorBase, Color &gt;::value &gt;</a></td><td class="desc"></td></tr>
<tr id="row_189_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1color__element__type.html" target="_self">color_element_type&lt; ColorBase, Color &gt;</a></td><td class="desc">Specifies the type of the element associated with a given color tag </td></tr>
<tr id="row_190_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1layout.html" target="_self">layout&lt; ColorSpace, ChannelMapping &gt;</a></td><td class="desc">Represents a color space and ordering of channels in memory </td></tr>
<tr id="row_191_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_191_" class="arrow" onclick="toggleFolder('191_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1layout.html" target="_self">layout&lt; devicen_t&lt; N &gt;::type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_191_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1devicen__layout__t.html" target="_self">devicen_layout_t&lt; N &gt;</a></td><td class="desc">Unnamed color layout of up to five channels </td></tr>
<tr id="row_192_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1locator__is__basic.html" target="_self">locator_is_basic&lt; Loc &gt;</a></td><td class="desc">Determines if a given locator is basic. A basic locator is memory-based and has basic x_iterator and y_iterator </td></tr>
<tr id="row_193_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1locator__type.html" target="_self">locator_type&lt; T, L, IsPlanar, IsStepX, IsMutable &gt;</a></td><td class="desc">Returns the type of a homogeneous locator given the channel type, layout, whether it operates on planar data and whether it has a step horizontally </td></tr>
<tr id="row_194_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1magenta__t.html" target="_self">magenta_t</a></td><td class="desc">Magenta </td></tr>
<tr id="row_195_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_memory_based_iterator_concept.html" target="_self">MemoryBasedIteratorConcept&lt; Iterator &gt;</a></td><td class="desc">Concept of a random-access iterator that can be advanced in memory units (bytes or bits) </td></tr>
<tr id="row_196_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1memunit__step__fn.html" target="_self">memunit_step_fn&lt; Iterator &gt;</a></td><td class="desc">Function object that returns the memory unit distance between two iterators and advances a given iterator a given number of mem units (bytes or bits) </td></tr>
<tr id="row_197_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_metafunction.html" target="_self">Metafunction&lt; T &gt;</a></td><td class="desc">Concept for type as metafunction requirement </td></tr>
<tr id="row_198_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_channel_concept.html" target="_self">MutableChannelConcept&lt; T &gt;</a></td><td class="desc">A channel that allows for modifying its value </td></tr>
<tr id="row_199_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_color_base_concept.html" target="_self">MutableColorBaseConcept&lt; ColorBase &gt;</a></td><td class="desc">Color base which allows for modifying its elements </td></tr>
<tr id="row_200_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_homogeneous_color_base_concept.html" target="_self">MutableHomogeneousColorBaseConcept&lt; ColorBase &gt;</a></td><td class="desc">Homogeneous color base that allows for modifying its elements </td></tr>
<tr id="row_201_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_homogeneous_pixel_concept.html" target="_self">MutableHomogeneousPixelConcept&lt; P &gt;</a></td><td class="desc">Homogeneous pixel concept that allows for changing its channels </td></tr>
<tr id="row_202_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_image_view_concept.html" target="_self">MutableImageViewConcept&lt; View &gt;</a></td><td class="desc">GIL's 2-dimensional view over mutable GIL pixels </td></tr>
<tr id="row_203_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_iterator_adaptor_concept.html" target="_self">MutableIteratorAdaptorConcept&lt; Iterator &gt;</a></td><td class="desc">Iterator adaptor that is mutable </td></tr>
<tr id="row_204_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_pixel_concept.html" target="_self">MutablePixelConcept&lt; P &gt;</a></td><td class="desc">Pixel concept that allows for changing its channels </td></tr>
<tr id="row_205_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_pixel_iterator_concept.html" target="_self">MutablePixelIteratorConcept&lt; Iterator &gt;</a></td><td class="desc">Pixel iterator that allows for changing its pixel </td></tr>
<tr id="row_206_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_pixel_locator_concept.html" target="_self">MutablePixelLocatorConcept&lt; Loc &gt;</a></td><td class="desc">GIL's 2-dimensional locator over mutable GIL pixels </td></tr>
<tr id="row_207_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_random_access2_d_image_view_concept.html" target="_self">MutableRandomAccess2DImageViewConcept&lt; View &gt;</a></td><td class="desc">2-dimensional view over mutable values </td></tr>
<tr id="row_208_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_random_access2_d_locator_concept.html" target="_self">MutableRandomAccess2DLocatorConcept&lt; Loc &gt;</a></td><td class="desc">2-dimensional locator over mutable pixels </td></tr>
<tr id="row_209_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_random_access_n_d_image_view_concept.html" target="_self">MutableRandomAccessNDImageViewConcept&lt; View &gt;</a></td><td class="desc">N-dimensional view over mutable values </td></tr>
<tr id="row_210_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_random_access_n_d_locator_concept.html" target="_self">MutableRandomAccessNDLocatorConcept&lt; Loc &gt;</a></td><td class="desc">N-dimensional locator over mutable pixels </td></tr>
<tr id="row_211_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_mutable_step_iterator_concept.html" target="_self">MutableStepIteratorConcept&lt; Iterator &gt;</a></td><td class="desc">Step iterator that allows for modifying its current value </td></tr>
<tr id="row_212_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1nth__channel__deref__fn.html" target="_self">nth_channel_deref_fn&lt; SrcP &gt;</a></td><td class="desc">Function object that returns a grayscale reference of the N-th channel of a given reference. Models: <a class="el" href="structboost_1_1gil_1_1_pixel_dereference_adaptor_concept.html" title="Represents a unary function object that can be invoked upon dereferencing a pixel iterator.">PixelDereferenceAdaptorConcept</a>.If the input is a pixel value or constant reference, the function object is immutable. Otherwise it is mutable (and returns non-const reference to the n-th channel) </td></tr>
<tr id="row_213_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1nth__channel__view__type.html" target="_self">nth_channel_view_type&lt; View &gt;</a></td><td class="desc">Given a source image view type View, returns the type of an image view over a single channel of ViewIf the channels in the source view are adjacent in memory (such as planar non-step view or single-channel view) then the return view is a single-channel non-step view. If the channels are non-adjacent (interleaved and/or step view) then the return view is a single-channel step view </td></tr>
<tr id="row_214_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1nth__channel__view__type_3_01any__image__view_3_01_views_8_8_8_01_4_01_4.html" target="_self">nth_channel_view_type&lt; any_image_view&lt; Views... &gt; &gt;</a></td><td class="desc">Given a runtime source image view, returns the type of a runtime image view over a single channel of the source view </td></tr>
<tr id="row_215_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1num__channels.html" target="_self">num_channels&lt; PixelBased &gt;</a></td><td class="desc">Returns the number of channels of a pixel-based GIL construct </td></tr>
<tr id="row_216_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1detail_1_1ostream__device.html" target="_self">ostream_device&lt; FormatTag &gt;</a></td><td class="desc"></td></tr>
<tr id="row_217_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1packed__dynamic__channel__reference_3_01_bit_field_00_01_num_bits_00_01false_01_4.html" target="_self">packed_dynamic_channel_reference&lt; BitField, NumBits, false &gt;</a></td><td class="desc">Models a constant subbyte channel reference whose bit offset is a runtime parameter. Models <a class="el" href="structboost_1_1gil_1_1_channel_concept.html" title="A channel is the building block of a color. Color is defined as a mixture of primary colors and a cha...">ChannelConcept</a> Same as packed_channel_reference, except that the offset is a runtime parameter </td></tr>
<tr id="row_218_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1packed__dynamic__channel__reference_3_01_bit_field_00_01_num_bits_00_01true_01_4.html" target="_self">packed_dynamic_channel_reference&lt; BitField, NumBits, true &gt;</a></td><td class="desc">Models a mutable subbyte channel reference whose bit offset is a runtime parameter. Models <a class="el" href="structboost_1_1gil_1_1_channel_concept.html" title="A channel is the building block of a color. Color is defined as a mixture of primary colors and a cha...">ChannelConcept</a> Same as packed_channel_reference, except that the offset is a runtime parameter </td></tr>
<tr id="row_219_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__image__type.html" target="_self">packed_image_type&lt; BitField, ChannelBitSizes, Layout, Alloc &gt;</a></td><td class="desc">Returns the type of an interleaved packed image: an image whose channels may not be byte-aligned, but whose pixels are byte aligned </td></tr>
<tr id="row_220_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_220_" class="arrow" onclick="toggleFolder('220_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__image__type.html" target="_self">packed_image_type&lt; BitField, mp11::mp_list_c&lt; unsigned, Size1 &gt;, Layout, Alloc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_220_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__image1__type.html" target="_self">packed_image1_type&lt; BitField, Size1, Layout, Alloc &gt;</a></td><td class="desc">Returns the type of a single-channel image given its bitfield type, the bit size of its channel and its layout </td></tr>
<tr id="row_221_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_221_" class="arrow" onclick="toggleFolder('221_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__image__type.html" target="_self">packed_image_type&lt; BitField, mp11::mp_list_c&lt; unsigned, Size1, Size2 &gt;, Layout, Alloc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_221_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__image2__type.html" target="_self">packed_image2_type&lt; BitField, Size1, Size2, Layout, Alloc &gt;</a></td><td class="desc">Returns the type of a two channel image given its bitfield type, the bit size of its channels and its layout </td></tr>
<tr id="row_222_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_222_" class="arrow" onclick="toggleFolder('222_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__image__type.html" target="_self">packed_image_type&lt; BitField, mp11::mp_list_c&lt; unsigned, Size1, Size2, Size3 &gt;, Layout, Alloc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_222_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__image3__type.html" target="_self">packed_image3_type&lt; BitField, Size1, Size2, Size3, Layout, Alloc &gt;</a></td><td class="desc">Returns the type of a three channel image given its bitfield type, the bit size of its channels and its layout </td></tr>
<tr id="row_223_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_223_" class="arrow" onclick="toggleFolder('223_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__image__type.html" target="_self">packed_image_type&lt; BitField, mp11::mp_list_c&lt; unsigned, Size1, Size2, Size3, Size4 &gt;, Layout, Alloc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_223_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__image4__type.html" target="_self">packed_image4_type&lt; BitField, Size1, Size2, Size3, Size4, Layout, Alloc &gt;</a></td><td class="desc">Returns the type of a four channel image given its bitfield type, the bit size of its channels and its layout </td></tr>
<tr id="row_224_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_224_" class="arrow" onclick="toggleFolder('224_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__image__type.html" target="_self">packed_image_type&lt; BitField, mp11::mp_list_c&lt; unsigned, Size1, Size2, Size3, Size4, Size5 &gt;, Layout, Alloc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_224_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__image5__type.html" target="_self">packed_image5_type&lt; BitField, Size1, Size2, Size3, Size4, Size5, Layout, Alloc &gt;</a></td><td class="desc">Returns the type of a five channel image given its bitfield type, the bit size of its channels and its layout </td></tr>
<tr id="row_225_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__pixel.html" target="_self">packed_pixel&lt; BitField, ChannelRefs, Layout &gt;</a></td><td class="desc">Heterogeneous pixel value whose channel references can be constructed from the pixel bitfield and their index. Models <a class="el" href="structboost_1_1gil_1_1_color_base_value_concept.html" title="Color base that also has a default-constructor. Refines Regular.">ColorBaseValueConcept</a>, <a class="el" href="structboost_1_1gil_1_1_pixel_value_concept.html" title="Pixel concept that is a Regular type.">PixelValueConcept</a>, <a class="el" href="structboost_1_1gil_1_1_pixel_based_concept.html" title="Concept for all pixel-based GIL constructs.">PixelBasedConcept</a> Typical use for this is a model of a packed pixel (like 565 RGB) </td></tr>
<tr id="row_226_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__pixel__type.html" target="_self">packed_pixel_type&lt; BitField, ChannelBitSizes, Layout &gt;</a></td><td class="desc">Returns the type of a packed pixel given its bitfield type, the bit size of its channels and its layout </td></tr>
<tr id="row_227_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__pixel__type.html" target="_self">packed_pixel_type&lt; BitField, mp11::mp_list_c&lt; unsigned, NumBits &gt;, Layout &gt;</a></td><td class="desc"></td></tr>
<tr id="row_228_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1packed__pixel__type.html" target="_self">packed_pixel_type&lt; detail::min_fast_uint&lt; NumBits &gt;::type, mp11::mp_list_c&lt; unsigned, NumBits &gt;, Layout &gt;</a></td><td class="desc"></td></tr>
<tr id="row_229_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1pixel.html" target="_self">pixel&lt; ChannelValue, Layout &gt;</a></td><td class="desc">Represents a pixel value (a container of channels). Models: <a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_value_concept.html" title="Homogeneous color base that also has a default constructor. Refines Regular.">HomogeneousColorBaseValueConcept</a>, <a class="el" href="structboost_1_1gil_1_1_pixel_value_concept.html" title="Pixel concept that is a Regular type.">PixelValueConcept</a>, <a class="el" href="structboost_1_1gil_1_1_homogeneous_pixel_based_concept.html" title="Concept for homogeneous pixel-based GIL constructs.">HomogeneousPixelBasedConcept</a> </td></tr>
<tr id="row_230_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1pixel__2d__locator__base.html" target="_self">pixel_2d_locator_base&lt; Loc, XIterator, YIterator &gt;</a></td><td class="desc">Base class for models of <a class="el" href="structboost_1_1gil_1_1_pixel_locator_concept.html" title="GIL&#39;s 2-dimensional locator over immutable GIL pixels.">PixelLocatorConcept</a>Pixel locator is similar to a pixel iterator, but allows for 2D navigation of pixels within an image view. It has a 2D difference_type and supports random access operations like: </td></tr>
<tr id="row_231_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_231_" class="arrow" onclick="toggleFolder('231_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1pixel__2d__locator__base.html" target="_self">pixel_2d_locator_base&lt; memory_based_2d_locator&lt; StepIterator &gt;, iterator_adaptor_get_base&lt; StepIterator &gt;::type, StepIterator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_231_0_" class="even" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1memory__based__2d__locator.html" target="_self">memory_based_2d_locator&lt; StepIterator &gt;</a></td><td class="desc">Memory-based pixel locator. Models: <a class="el" href="structboost_1_1gil_1_1_pixel_locator_concept.html" title="GIL&#39;s 2-dimensional locator over immutable GIL pixels.">PixelLocatorConcept</a>,<a class="el" href="structboost_1_1gil_1_1_has_dynamic_x_step_type_concept.html" title="Concept for iterators, locators and views that can define a type just like the given iterator,...">HasDynamicXStepTypeConcept</a>,<a class="el" href="structboost_1_1gil_1_1_has_dynamic_y_step_type_concept.html" title="Concept for locators and views that can define a type just like the given locator or view,...">HasDynamicYStepTypeConcept</a>,<a class="el" href="structboost_1_1gil_1_1_has_transposed_type_concept.html" title="Concept for locators and views that can define a type just like the given locator or view,...">HasTransposedTypeConcept</a>The class takes a step iterator as a parameter. The step iterator provides navigation along the vertical axis while its base iterator provides horizontal navigation </td></tr>
<tr id="row_232_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_232_" class="arrow" onclick="toggleFolder('232_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1pixel__2d__locator__base.html" target="_self">pixel_2d_locator_base&lt; virtual_2d_locator&lt; DerefFn, IsTransposed &gt;, position_iterator&lt; DerefFn, IsTransposed &gt;, position_iterator&lt; DerefFn, 1-IsTransposed &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_232_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1virtual__2d__locator.html" target="_self">virtual_2d_locator&lt; DerefFn, IsTransposed &gt;</a></td><td class="desc">A 2D locator over a virtual image Upon dereferencing, invokes a given function object passing it its coordinates. Models: <a class="el" href="structboost_1_1gil_1_1_pixel_locator_concept.html" title="GIL&#39;s 2-dimensional locator over immutable GIL pixels.">PixelLocatorConcept</a>, <a class="el" href="structboost_1_1gil_1_1_has_dynamic_x_step_type_concept.html" title="Concept for iterators, locators and views that can define a type just like the given iterator,...">HasDynamicXStepTypeConcept</a>, <a class="el" href="structboost_1_1gil_1_1_has_dynamic_y_step_type_concept.html" title="Concept for locators and views that can define a type just like the given locator or view,...">HasDynamicYStepTypeConcept</a>, <a class="el" href="structboost_1_1gil_1_1_has_transposed_type_concept.html" title="Concept for locators and views that can define a type just like the given locator or view,...">HasTransposedTypeConcept</a> </td></tr>
<tr id="row_233_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1pixel__is__reference.html" target="_self">pixel_is_reference&lt; Pixel &gt;</a></td><td class="desc">Given a model of a pixel, determines whether the model represents a pixel reference (as opposed to pixel value) </td></tr>
<tr id="row_234_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1pixel__reference__is__basic.html" target="_self">pixel_reference_is_basic&lt; PixelRef &gt;</a></td><td class="desc">Determines if a given pixel reference is basic Basic references must use <a class="el" href="structboost_1_1gil_1_1pixel.html" title="Represents a pixel value (a container of channels). Models: HomogeneousColorBaseValueConcept,...">gil::pixel</a>&amp; (if interleaved), <a class="el" href="structboost_1_1gil_1_1planar__pixel__reference.html" title="A reference proxy to a planar pixel.">gil::planar_pixel_reference</a> (if planar). They must use the standard constness rules </td></tr>
<tr id="row_235_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1pixel__reference__is__mutable.html" target="_self">pixel_reference_is_mutable&lt; R &gt;</a></td><td class="desc">Determines if the given pixel reference is mutable (i.e. its channels can be changed) </td></tr>
<tr id="row_236_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1pixel__reference__is__proxy.html" target="_self">pixel_reference_is_proxy&lt; PixelReference &gt;</a></td><td class="desc">Determines whether the given pixel reference is a proxy class or a native C++ reference </td></tr>
<tr id="row_237_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1pixel__reference__type.html" target="_self">pixel_reference_type&lt; T, L, IsPlanar, IsMutable &gt;</a></td><td class="desc">Returns the type of a homogeneous pixel reference given the channel type, layout, whether it operates on planar data and whether it is mutable </td></tr>
<tr id="row_238_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1pixel__value__type.html" target="_self">pixel_value_type&lt; Channel, Layout &gt;</a></td><td class="desc">Returns the type of a homogeneous pixel given the channel type and layout </td></tr>
<tr id="row_239_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_pixel_based_concept.html" target="_self">PixelBasedConcept&lt; P &gt;</a></td><td class="desc">Concept for all pixel-based GIL constructs </td></tr>
<tr id="row_240_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_pixel_concept.html" target="_self">PixelConcept&lt; P &gt;</a></td><td class="desc">Pixel concept - A color base whose elements are channels </td></tr>
<tr id="row_241_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_pixel_convertible_concept.html" target="_self">PixelConvertibleConcept&lt; SrcP, DstP &gt;</a></td><td class="desc">Pixel convertible concept Convertibility is non-symmetric and implies that one pixel can be converted to another, approximating the color. Conversion is explicit and sometimes lossy </td></tr>
<tr id="row_242_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_pixel_dereference_adaptor_concept.html" target="_self">PixelDereferenceAdaptorConcept&lt; D &gt;</a></td><td class="desc">Represents a unary function object that can be invoked upon dereferencing a pixel iterator </td></tr>
<tr id="row_243_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1_pixel_image_view_is_mutable_concept.html" target="_self">PixelImageViewIsMutableConcept&lt; View &gt;</a></td><td class="desc"></td></tr>
<tr id="row_244_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_pixel_iterator_concept.html" target="_self">PixelIteratorConcept&lt; Iterator &gt;</a></td><td class="desc">An STL random access traversal iterator over a model of <a class="el" href="structboost_1_1gil_1_1_pixel_concept.html" title="Pixel concept - A color base whose elements are channels.">PixelConcept</a> </td></tr>
<tr id="row_245_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1_pixel_iterator_is_mutable_concept.html" target="_self">PixelIteratorIsMutableConcept&lt; Iterator &gt;</a></td><td class="desc"></td></tr>
<tr id="row_246_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_pixel_locator_concept.html" target="_self">PixelLocatorConcept&lt; Loc &gt;</a></td><td class="desc">GIL's 2-dimensional locator over immutable GIL pixels </td></tr>
<tr id="row_247_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1pixels__are__compatible.html" target="_self">pixels_are_compatible&lt; P1, P2 &gt;</a></td><td class="desc">Returns whether two pixels are compatible Pixels are compatible if their channels and color space types are compatible. Compatible pixels can be assigned and copy constructed from one another </td></tr>
<tr id="row_248_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_248_" class="arrow" onclick="toggleFolder('248_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1pixels__are__compatible.html" target="_self">pixels_are_compatible&lt; V1::value_type, V2::value_type &gt;</a></td><td class="desc"></td></tr>
<tr id="row_248_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1views__are__compatible.html" target="_self">views_are_compatible&lt; V1, V2 &gt;</a></td><td class="desc">Returns whether two views are compatible </td></tr>
<tr id="row_249_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_pixels_compatible_concept.html" target="_self">PixelsCompatibleConcept&lt; P1, P2 &gt;</a></td><td class="desc">Concept for pixel compatibility Pixels are compatible if their channels and color space types are compatible. Compatible pixels can be assigned and copy constructed from one another </td></tr>
<tr id="row_250_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_pixel_value_concept.html" target="_self">PixelValueConcept&lt; P &gt;</a></td><td class="desc">Pixel concept that is a <a class="el" href="structboost_1_1gil_1_1_regular.html" title="Concept for type regularity requirement.">Regular</a> type </td></tr>
<tr id="row_251_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1planar__pixel__iterator.html" target="_self">planar_pixel_iterator&lt; ChannelPtr, ColorSpace &gt;</a></td><td class="desc">An iterator over planar pixels. Models <a class="el" href="structboost_1_1gil_1_1_homogeneous_color_base_concept.html" title="Color base whose elements all have the same type.">HomogeneousColorBaseConcept</a>, <a class="el" href="structboost_1_1gil_1_1_pixel_iterator_concept.html" title="An STL random access traversal iterator over a model of PixelConcept.">PixelIteratorConcept</a>, <a class="el" href="structboost_1_1gil_1_1_homogeneous_pixel_based_concept.html" title="Concept for homogeneous pixel-based GIL constructs.">HomogeneousPixelBasedConcept</a>, <a class="el" href="structboost_1_1gil_1_1_memory_based_iterator_concept.html" title="Concept of a random-access iterator that can be advanced in memory units (bytes or bits)">MemoryBasedIteratorConcept</a>, <a class="el" href="structboost_1_1gil_1_1_has_dynamic_x_step_type_concept.html" title="Concept for iterators, locators and views that can define a type just like the given iterator,...">HasDynamicXStepTypeConcept</a> </td></tr>
<tr id="row_252_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1planar__pixel__reference.html" target="_self">planar_pixel_reference&lt; ChannelReference, ColorSpace &gt;</a></td><td class="desc">A reference proxy to a planar pixel </td></tr>
<tr id="row_253_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1plus__asymmetric.html" target="_self">plus_asymmetric&lt; T1, T2 &gt;</a></td><td class="desc">Plus function object whose arguments may be of different type </td></tr>
<tr id="row_254_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1point.html" target="_self">point&lt; T &gt;</a></td><td class="desc">2D point both axes of which have the same dimension typeModels: <a class="el" href="structboost_1_1gil_1_1_point2_d_concept.html" title="2-dimensional point concept">Point2DConcept</a> </td></tr>
<tr id="row_255_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_point2_d_concept.html" target="_self">Point2DConcept&lt; P &gt;</a></td><td class="desc">2-dimensional point concept </td></tr>
<tr id="row_256_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1point.html" target="_self">point&lt; std::ptrdiff_t &gt;</a></td><td class="desc"></td></tr>
<tr id="row_257_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_point_n_d_concept.html" target="_self">PointNDConcept&lt; P &gt;</a></td><td class="desc">N-dimensional point concept </td></tr>
<tr id="row_258_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1position__iterator.html" target="_self">position_iterator&lt; Deref, Dim &gt;</a></td><td class="desc">An iterator that remembers its current X,Y position and invokes a function object with it upon dereferencing. Used to create virtual image views. Models: <a class="el" href="structboost_1_1gil_1_1_step_iterator_concept.html" title="Step iterator concept.">StepIteratorConcept</a>, <a class="el" href="structboost_1_1gil_1_1_pixel_iterator_concept.html" title="An STL random access traversal iterator over a model of PixelConcept.">PixelIteratorConcept</a>, <a class="el" href="structboost_1_1gil_1_1_pixel_based_concept.html" title="Concept for all pixel-based GIL constructs.">PixelBasedConcept</a>, <a class="el" href="structboost_1_1gil_1_1_has_dynamic_x_step_type_concept.html" title="Concept for iterators, locators and views that can define a type just like the given iterator,...">HasDynamicXStepTypeConcept</a> </td></tr>
<tr id="row_259_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1promote__integral.html" target="_self">promote_integral&lt; T, PromoteUnsignedToUnsigned, UseCheckedInteger, IsIntegral &gt;</a></td><td class="desc">Meta-function to define an integral type with size than is (roughly) twice the bit size of T </td></tr>
<tr id="row_260_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_random_access2_d_image_concept.html" target="_self">RandomAccess2DImageConcept&lt; Image &gt;</a></td><td class="desc">2-dimensional container of values </td></tr>
<tr id="row_261_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_random_access2_d_image_view_concept.html" target="_self">RandomAccess2DImageViewConcept&lt; View &gt;</a></td><td class="desc">2-dimensional view over immutable values </td></tr>
<tr id="row_262_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1_random_access2_d_image_view_is_mutable_concept.html" target="_self">RandomAccess2DImageViewIsMutableConcept&lt; View &gt;</a></td><td class="desc"></td></tr>
<tr id="row_263_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_random_access2_d_locator_concept.html" target="_self">RandomAccess2DLocatorConcept&lt; Loc &gt;</a></td><td class="desc">2-dimensional locator over immutable values </td></tr>
<tr id="row_264_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_random_access_n_d_image_concept.html" target="_self">RandomAccessNDImageConcept&lt; Image &gt;</a></td><td class="desc">N-dimensional container of values </td></tr>
<tr id="row_265_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_random_access_n_d_image_view_concept.html" target="_self">RandomAccessNDImageViewConcept&lt; View &gt;</a></td><td class="desc">N-dimensional view over immutable values </td></tr>
<tr id="row_266_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1_random_access_n_d_image_view_is_mutable_concept.html" target="_self">RandomAccessNDImageViewIsMutableConcept&lt; View &gt;</a></td><td class="desc"></td></tr>
<tr id="row_267_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_random_access_n_d_locator_concept.html" target="_self">RandomAccessNDLocatorConcept&lt; Loc &gt;</a></td><td class="desc">N-dimensional locator over immutable values </td></tr>
<tr id="row_268_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1_random_access_n_d_locator_is_mutable_concept.html" target="_self">RandomAccessNDLocatorIsMutableConcept&lt; Loc &gt;</a></td><td class="desc"></td></tr>
<tr id="row_269_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1file__stream__device_1_1read__tag.html" target="_self">file_stream_device&lt; FormatTag &gt;::read_tag</a></td><td class="desc">Used to overload the constructor </td></tr>
<tr id="row_270_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1reader__base.html" target="_self">reader_base&lt; FormatTag, ConversionPolicy &gt;</a></td><td class="desc"></td></tr>
<tr id="row_271_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1red__t.html" target="_self">red_t</a></td><td class="desc">Red </td></tr>
<tr id="row_272_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_regular.html" target="_self">Regular&lt; T &gt;</a></td><td class="desc">Concept for type regularity requirement </td></tr>
<tr id="row_273_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_reversible_collection_image_view_concept.html" target="_self">ReversibleCollectionImageViewConcept&lt; View &gt;</a></td><td class="desc">GIL view as ReversibleCollection </td></tr>
<tr id="row_274_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1rgb__to__luminance__fn.html" target="_self">rgb_to_luminance_fn&lt; RedChannel, GreenChannel, BlueChannel, GrayChannelValue &gt;</a></td><td class="desc">Red * .3 + green * .59 + blue * .11 + .5 </td></tr>
<tr id="row_275_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_same_type.html" target="_self">SameType&lt; T, U &gt;</a></td><td class="desc">Concept of types equivalence requirement </td></tr>
<tr id="row_276_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1scanline__read__iterator.html" target="_self">scanline_read_iterator&lt; Reader &gt;</a></td><td class="desc">Input iterator to read images </td></tr>
<tr id="row_277_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1size.html" target="_self">size&lt; ColorBase &gt;</a></td><td class="desc">Returns an integral constant type specifying the number of elements in a color base </td></tr>
<tr id="row_278_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1std__fill__t.html" target="_self">std_fill_t</a></td><td class="desc">Struct to do std::fill </td></tr>
<tr id="row_279_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1detail_1_1step__iterator__adaptor.html" target="_self">step_iterator_adaptor&lt; Derived, Iterator, SFn &gt;</a></td><td class="desc">An adaptor over an existing iterator that changes the step unit </td></tr>
<tr id="row_280_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_280_" class="arrow" onclick="toggleFolder('280_')">&#9658;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1detail_1_1step__iterator__adaptor.html" target="_self">step_iterator_adaptor&lt; memory_based_step_iterator&lt; Iterator &gt;, Iterator, memunit_step_fn&lt; Iterator &gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_280_0_" style="display:none;"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="classboost_1_1gil_1_1memory__based__step__iterator.html" target="_self">memory_based_step_iterator&lt; Iterator &gt;</a></td><td class="desc">MEMORY-BASED STEP ITERATOR </td></tr>
<tr id="row_281_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_step_iterator_concept.html" target="_self">StepIteratorConcept&lt; Iterator &gt;</a></td><td class="desc">Step iterator concept </td></tr>
<tr id="row_282_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_swappable.html" target="_self">Swappable&lt; T &gt;</a></td><td class="desc">Concept of swap operation requirement </td></tr>
<tr id="row_283_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1transposed__type.html" target="_self">transposed_type&lt; LocatorOrView &gt;</a></td><td class="desc"></td></tr>
<tr id="row_284_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1type__from__x__iterator.html" target="_self">type_from_x_iterator&lt; XIterator &gt;</a></td><td class="desc">Given a pixel iterator defining access to pixels along a row, returns the types of the corresponding built-in step_iterator, xy_locator, <a class="el" href="classboost_1_1gil_1_1image__view.html" title="A lightweight object that interprets memory as a 2D array of pixels. Models ImageViewConcept,...">image_view</a> </td></tr>
<tr id="row_285_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1type__to__index.html" target="_self">type_to_index&lt; Types, T &gt;</a></td><td class="desc">Returns the index corresponding to the first occurrance of a given given type in </td></tr>
<tr id="row_286_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1detail_1_1type__to__index.html" target="_self">type_to_index&lt; ColorBase::layout_t::color_space_t, Color &gt;</a></td><td class="desc"></td></tr>
<tr id="row_287_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1view__is__basic.html" target="_self">view_is_basic&lt; View &gt;</a></td><td class="desc">Basic views must be over basic locators </td></tr>
<tr id="row_288_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1view__type.html" target="_self">view_type&lt; T, L, IsPlanar, IsStepX, IsMutable &gt;</a></td><td class="desc">Returns the type of a homogeneous view given the channel type, layout, whether it operates on planar data and whether it has a step horizontally </td></tr>
<tr id="row_289_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1view__type__from__pixel.html" target="_self">view_type_from_pixel&lt; Pixel, IsPlanar, IsStepX, IsMutable &gt;</a></td><td class="desc">Returns the type of a view the pixel type, whether it operates on planar data and whether it has a step horizontally </td></tr>
<tr id="row_290_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1view__type__from__pixel.html" target="_self">view_type_from_pixel&lt; Pixel, IsPlanar &gt;</a></td><td class="desc"></td></tr>
<tr id="row_291_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1_views_compatible_concept.html" target="_self">ViewsCompatibleConcept&lt; V1, V2 &gt;</a></td><td class="desc">Views are compatible if they have the same color spaces and compatible channel values </td></tr>
<tr id="row_292_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structboost_1_1gil_1_1yellow__t.html" target="_self">yellow_t</a></td><td class="desc">Yellow </td></tr>
</table>
</div><!-- directory -->
</div><!-- contents -->
     <!-- HTML footer for doxygen 1.8.13-->
     <!-- start footer part -->
     <hr class="footer"/>
     <address class="footer">
      <small>
        Generated by &#160;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.15
      </small>
    </address>
  </body>
</html>
