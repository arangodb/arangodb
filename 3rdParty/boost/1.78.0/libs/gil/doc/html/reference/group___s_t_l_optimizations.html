<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.15"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Generic Image Library: Performance overloads of STL algorithms</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-boost.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div class="boost-header">
      <table border="0" cellpadding="7" cellspacing="0" width="100%" summary="header">
	<tr>
	  <td valign="top" width="300">
            <h3><a href="../index.html"><img alt="Boost GIL" src="../_static/gil.png" border="0"></a></h3>
	  </td>
	  <td ><h1 align="center"><a href="../index.html"></a></h1></td>
	  <td></td>
	</tr>
      </table>
    </div>
    <hr/>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Performance overloads of STL algorithms<div class="ingroups"><a class="el" href="group___image_view.html">Image View</a> &raquo; <a class="el" href="group___image_view_algorithm.html">Algorithms and Utility Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>overloads of STL algorithms allowing more efficient implementation when used with GIL constructs  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8e23fe06d31c7cce605e4bf8255e1ee9"><td class="memTemplParams" colspan="2"><a id="ga8e23fe06d31c7cce605e4bf8255e1ee9"></a>
template&lt;typename T , typename CS &gt; </td></tr>
<tr class="memitem:ga8e23fe06d31c7cce605e4bf8255e1ee9"><td class="memTemplItemLeft" align="right" valign="top">BOOST_FORCEINLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___s_t_l_optimizations.html#ga8e23fe06d31c7cce605e4bf8255e1ee9">copy</a> (<a class="el" href="structboost_1_1gil_1_1pixel.html">boost::gil::pixel</a>&lt; T, CS &gt; *first, <a class="el" href="structboost_1_1gil_1_1pixel.html">boost::gil::pixel</a>&lt; T, CS &gt; *last, <a class="el" href="structboost_1_1gil_1_1pixel.html">boost::gil::pixel</a>&lt; T, CS &gt; *dst) -&gt; <a class="el" href="structboost_1_1gil_1_1pixel.html">boost::gil::pixel</a>&lt; T, CS &gt; *</td></tr>
<tr class="memdesc:ga8e23fe06d31c7cce605e4bf8255e1ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy when both src and dst are interleaved and of the same type can be just memmove. <br /></td></tr>
<tr class="separator:ga8e23fe06d31c7cce605e4bf8255e1ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f5c40052f8914c1713b7a57ff23544a"><td class="memTemplParams" colspan="2"><a id="ga7f5c40052f8914c1713b7a57ff23544a"></a>
template&lt;typename T , typename CS &gt; </td></tr>
<tr class="memitem:ga7f5c40052f8914c1713b7a57ff23544a"><td class="memTemplItemLeft" align="right" valign="top">BOOST_FORCEINLINE <a class="el" href="structboost_1_1gil_1_1pixel.html">boost::gil::pixel</a>&lt; T, CS &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___s_t_l_optimizations.html#ga7f5c40052f8914c1713b7a57ff23544a">copy</a> (const <a class="el" href="structboost_1_1gil_1_1pixel.html">boost::gil::pixel</a>&lt; T, CS &gt; *first, const <a class="el" href="structboost_1_1gil_1_1pixel.html">boost::gil::pixel</a>&lt; T, CS &gt; *last, <a class="el" href="structboost_1_1gil_1_1pixel.html">boost::gil::pixel</a>&lt; T, CS &gt; *dst)</td></tr>
<tr class="memdesc:ga7f5c40052f8914c1713b7a57ff23544a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy when both src and dst are interleaved and of the same type can be just memmove. <br /></td></tr>
<tr class="separator:ga7f5c40052f8914c1713b7a57ff23544a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga445b366c1ef9e7cf58824395f65cce60"><td class="memTemplParams" colspan="2"><a id="ga445b366c1ef9e7cf58824395f65cce60"></a>
template&lt;typename CS , typename IC1 , typename IC2 &gt; </td></tr>
<tr class="memitem:ga445b366c1ef9e7cf58824395f65cce60"><td class="memTemplItemLeft" align="right" valign="top">BOOST_FORCEINLINE <a class="el" href="structboost_1_1gil_1_1planar__pixel__iterator.html">boost::gil::planar_pixel_iterator</a>&lt; IC2, CS &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___s_t_l_optimizations.html#ga445b366c1ef9e7cf58824395f65cce60">copy</a> (<a class="el" href="structboost_1_1gil_1_1planar__pixel__iterator.html">boost::gil::planar_pixel_iterator</a>&lt; IC1, CS &gt; first, <a class="el" href="structboost_1_1gil_1_1planar__pixel__iterator.html">boost::gil::planar_pixel_iterator</a>&lt; IC1, CS &gt; last, <a class="el" href="structboost_1_1gil_1_1planar__pixel__iterator.html">boost::gil::planar_pixel_iterator</a>&lt; IC2, CS &gt; dst)</td></tr>
<tr class="memdesc:ga445b366c1ef9e7cf58824395f65cce60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy when both src and dst are planar pointers is copy for each channel. <br /></td></tr>
<tr class="separator:ga445b366c1ef9e7cf58824395f65cce60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa989f3992b09c1f2d00eb9a98cbf1f"><td class="memTemplParams" colspan="2"><a id="ga5aa989f3992b09c1f2d00eb9a98cbf1f"></a>
template&lt;typename IL , typename OL &gt; </td></tr>
<tr class="memitem:ga5aa989f3992b09c1f2d00eb9a98cbf1f"><td class="memTemplItemLeft" align="right" valign="top">BOOST_FORCEINLINE <a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; OL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___s_t_l_optimizations.html#ga5aa989f3992b09c1f2d00eb9a98cbf1f">copy1</a> (<a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; IL &gt; first, <a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; IL &gt; last, <a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; OL &gt; dst)</td></tr>
<tr class="memdesc:ga5aa989f3992b09c1f2d00eb9a98cbf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::copy(I1,I1,I2) with I1 and I2 being a iterator_from_2d <br /></td></tr>
<tr class="separator:ga5aa989f3992b09c1f2d00eb9a98cbf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab999be608ae006f1127b8bb5145a227"><td class="memTemplParams" colspan="2">template&lt;typename IL , typename V &gt; </td></tr>
<tr class="memitem:gaab999be608ae006f1127b8bb5145a227"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___s_t_l_optimizations.html#gaab999be608ae006f1127b8bb5145a227">fill</a> (<a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; IL &gt; first, <a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; IL &gt; last, const V &amp;val)</td></tr>
<tr class="memdesc:gaab999be608ae006f1127b8bb5145a227"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::fill(I,I,V) with I being a iterator_from_2d  <a href="group___s_t_l_optimizations.html#gaab999be608ae006f1127b8bb5145a227">More...</a><br /></td></tr>
<tr class="separator:gaab999be608ae006f1127b8bb5145a227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2902a23650ef266e80874ce5df076079"><td class="memTemplParams" colspan="2">template&lt;typename Loc1 , typename Loc2 &gt; </td></tr>
<tr class="memitem:ga2902a23650ef266e80874ce5df076079"><td class="memTemplItemLeft" align="right" valign="top">BOOST_FORCEINLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___s_t_l_optimizations.html#ga2902a23650ef266e80874ce5df076079">equal</a> (<a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; Loc1 &gt; first, <a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; Loc1 &gt; last, <a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; Loc2 &gt; first2)</td></tr>
<tr class="memdesc:ga2902a23650ef266e80874ce5df076079"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::equal(I1,I1,I2) with I1 and I2 being a iterator_from_2d  <a href="group___s_t_l_optimizations.html#ga2902a23650ef266e80874ce5df076079">More...</a><br /></td></tr>
<tr class="separator:ga2902a23650ef266e80874ce5df076079"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>overloads of STL algorithms allowing more efficient implementation when used with GIL constructs </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2902a23650ef266e80874ce5df076079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2902a23650ef266e80874ce5df076079">&#9670;&nbsp;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_FORCEINLINE bool std::equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; Loc1 &gt;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; Loc1 &gt;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; Loc2 &gt;&#160;</td>
          <td class="paramname"><em>first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>std::equal(I1,I1,I2) with I1 and I2 being a iterator_from_2d </p>
<p>Invoked when one calls std::equal(I1,I1,I2) with I1 and I2 being a iterator_from_2d (which is a 1D iterator over the pixels in an image). Attempts to demote the source and destination iterators to simpler/faster types if the corresponding range is contiguous. For contiguous images (i.e. images that have no alignment gap at the end of each row) it is more efficient to use the underlying pixel iterator that does not check for the end of rows. If the underlying pixel iterator happens to be a fundamental planar/interleaved pointer, the call may further resolve to memcmp. Otherwise it resolves to copying each row using the underlying pixel iterator </p>

</div>
</div>
<a id="gaab999be608ae006f1127b8bb5145a227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab999be608ae006f1127b8bb5145a227">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void std::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; IL &gt;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1gil_1_1iterator__from__2d.html">boost::gil::iterator_from_2d</a>&lt; IL &gt;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>std::fill(I,I,V) with I being a iterator_from_2d </p>
<p>Invoked when one calls std::fill(I,I,V) with I being a iterator_from_2d (which is a 1D iterator over the pixels in an image). For contiguous images (i.e. images that have no alignment gap at the end of each row) it is more efficient to use the underlying pixel iterator that does not check for the end of rows. For non-contiguous images fill resolves to fill of each row using the underlying pixel iterator, which is still faster </p>

</div>
</div>
</div><!-- contents -->
     <!-- HTML footer for doxygen 1.8.13-->
     <!-- start footer part -->
     <hr class="footer"/>
     <address class="footer">
      <small>
        Generated by &#160;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.15
      </small>
    </address>
  </body>
</html>
