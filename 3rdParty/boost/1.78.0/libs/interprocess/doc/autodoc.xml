<?xml version="1.0" standalone="yes"?>
<library-reference id="boost_interprocess_header_reference"><title>Boost.Interprocess Header Reference</title><header name="boost/interprocess/allocators/adaptive_pool.hpp">
<para>Describes adaptive_pool pooled shared memory STL compatible allocator </para><namespace name="boost">
<namespace name="interprocess">
<class name="adaptive_pool"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="MaxFreeBlocks"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="OverheadPercent"><type>unsigned char</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc...</para><para>This node allocator shares a segregated storage between all instances of <classname alt="boost::interprocess::adaptive_pool">adaptive_pool</classname> with equal sizeof(T) placed in the same segment group. NodesPerBlock is the number of nodes allocated at once when the allocator needs runs out of nodes. MaxFreeBlocks is the maximum number of totally free blocks that the adaptive node pool will hold. The rest of the totally free blocks will be deallocated with the segment manager.</para><para>OverheadPercent is the (approximated) maximum size overhead (1-20%) of the allocator: (memory usable for nodes / total memory allocated from the segment manager) </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <classname alt="boost::interprocess::adaptive_pool">adaptive_pool</classname> from <classname alt="boost::interprocess::adaptive_pool">adaptive_pool</classname> </para></description><typedef name="other"><type><classname>adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef>
</struct><typedef name="segment_manager"><type>implementation_defined::segment_manager</type></typedef>
<typedef name="void_pointer"><type>segment_manager::void_pointer</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="size_type"><type>segment_manager::size_type</type></typedef>
<typedef name="difference_type"><type>segment_manager::difference_type</type></typedef>
<method-group name="private member functions">
</method-group>
<copy-assignment><type><classname>adaptive_pool</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP2"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>adaptive_pool</classname>&lt; T2, SegmentManager2, N2, F2, OP2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related <classname alt="boost::interprocess::adaptive_pool">adaptive_pool</classname> </para></description></copy-assignment>
<method-group name="public member functions">
<method name="get_node_pool" cv="const"><type>void *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method>
<method name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method name="deallocate_free_blocks"><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method>
<method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
<method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
<method name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method>
<method name="deallocate_individual"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
</method-group>
<constructor><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Not assignable from other <classname alt="boost::interprocess::adaptive_pool">adaptive_pool</classname> Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> </para></description></constructor>
<constructor><parameter name="other"><paramtype>const <classname>adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other <classname alt="boost::interprocess::adaptive_pool">adaptive_pool</classname>. Increments the reference count of the associated node pool. Never throws </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related <classname alt="boost::interprocess::adaptive_pool">adaptive_pool</classname>. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> </para></description></constructor>
<destructor><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor>
<method-group name="friend functions">
<method name="swap"><type>friend void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
</method-group>
</class>


















<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of <classname alt="boost::interprocess::adaptive_pool">adaptive_pool</classname> </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of <classname alt="boost::interprocess::adaptive_pool">adaptive_pool</classname> </para></description></function>




























</namespace>
</namespace>
</header>
<header name="boost/interprocess/allocators/allocator.hpp">
<para>Describes an allocator that allocates portions of fixed size memory buffer (shared memory, mapped file...) </para><namespace name="boost">
<namespace name="interprocess">
<class name="allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
    </template><description><para>An STL compatible allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc... </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains an allocator that allocates objects of type T2 </para></description><typedef name="other"><type><classname>allocator</classname>&lt; T2, SegmentManager &gt;</type></typedef>
</struct><typedef name="segment_manager"><type>SegmentManager</type></typedef>
<typedef name="void_pointer"><type>SegmentManager::void_pointer</type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<typedef name="pointer"><type>boost::intrusive::pointer_traits&lt; cvoid_ptr &gt;::template rebind_pointer&lt; T &gt;::type</type></typedef>
<typedef name="const_pointer"><type>boost::intrusive::pointer_traits&lt; pointer &gt;::template rebind_pointer&lt; const T &gt;::type</type></typedef>
<typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="size_type"><type>segment_manager::size_type</type></typedef>
<typedef name="difference_type"><type>segment_manager::difference_type</type></typedef>
<typedef name="version"><type>boost::interprocess::version_type&lt; <classname>allocator</classname>, 2 &gt;</type></typedef>
<method-group name="public member functions">
<method name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<method name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_ptr</paramtype><default>0</default></parameter><description><para>Allocates memory for an array of count elements. Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name=""><paramtype>size_type</paramtype></parameter><description><para>Deallocates memory previously allocated. Never throws </para></description></method>
<method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
<method name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method>
<method name="deallocate_individual"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
<method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
<method name="construct"><type>void</type><template>
          <template-type-parameter name="P"/>
        </template><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="p"><paramtype>P &amp;&amp;</paramtype></parameter><description><para>Constructs an object Throws if T's constructor throws For backwards compatibility with libraries using C++03 allocators </para></description></method>
<method name="destroy"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method>
</method-group>
<constructor><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Constructor from the segment manager. Never throws </para></description></constructor>
<constructor><parameter name="other"><paramtype>const <classname>allocator</classname> &amp;</paramtype></parameter><description><para>Constructor from other allocator. Never throws </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>allocator</classname>&lt; T2, SegmentManager &gt; &amp;</paramtype></parameter><description><para>Constructor from related allocator. Never throws </para></description></constructor>
<method-group name="friend functions">
<method name="swap"><type>friend void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swap segment manager. Does not throw. If each allocator is placed in different memory segments, the result is undefined. </para></description></method>
</method-group>
</class>
















<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="SegmentManager"/>
        </template><parameter name="alloc1"><paramtype>const <classname>allocator</classname>&lt; T, SegmentManager &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>allocator</classname>&lt; T, SegmentManager &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of allocator </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="SegmentManager"/>
        </template><parameter name="alloc1"><paramtype>const <classname>allocator</classname>&lt; T, SegmentManager &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>allocator</classname>&lt; T, SegmentManager &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of allocator </para></description></function>






























</namespace>
</namespace>
</header>
<header name="boost/interprocess/allocators/cached_adaptive_pool.hpp">
<para>Describes cached_adaptive_pool pooled shared memory STL compatible allocator </para><namespace name="boost">
<namespace name="interprocess">
<class name="cached_adaptive_pool"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="MaxFreeBlocks"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="OverheadPercent"><type>unsigned char</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc...</para><para>This node allocator shares a segregated storage between all instances of <classname alt="boost::interprocess::cached_adaptive_pool">cached_adaptive_pool</classname> with equal sizeof(T) placed in the same memory segment. But also caches some nodes privately to avoid some synchronization overhead.</para><para>NodesPerBlock is the minimum number of nodes of nodes allocated at once when the allocator needs runs out of nodes. MaxFreeBlocks is the maximum number of totally free blocks that the adaptive node pool will hold. The rest of the totally free blocks will be deallocated with the segment manager.</para><para>OverheadPercent is the (approximated) maximum size overhead (1-20%) of the allocator: (memory usable for nodes / total memory allocated from the segment manager) </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <classname alt="boost::interprocess::cached_adaptive_pool">cached_adaptive_pool</classname> from <classname alt="boost::interprocess::cached_adaptive_pool">cached_adaptive_pool</classname> </para></description><typedef name="other"><type><classname>cached_adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef>
</struct><typedef name="segment_manager"><type>implementation_defined::segment_manager</type></typedef>
<typedef name="void_pointer"><type>segment_manager::void_pointer</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="size_type"><type>segment_manager::size_type</type></typedef>
<typedef name="difference_type"><type>segment_manager::difference_type</type></typedef>
<method-group name="private member functions">
</method-group>
<copy-assignment><type><classname>cached_adaptive_pool</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP2"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T2, SegmentManager2, N2, F2, OP2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related <classname alt="boost::interprocess::cached_adaptive_pool">cached_adaptive_pool</classname> </para></description></copy-assignment>
<copy-assignment><type><classname>cached_adaptive_pool</classname> &amp;</type><parameter name=""><paramtype>const <classname>cached_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Not assignable from other <classname alt="boost::interprocess::cached_adaptive_pool">cached_adaptive_pool</classname> </para></description></copy-assignment>
<method-group name="public member functions">
<method name="get_node_pool" cv="const"><type>node_pool_t *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method>
<method name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method name="deallocate_free_blocks"><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method>
<method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
<method name="construct"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object. Throws if T's copy constructor throws </para></description></method>
<method name="destroy"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method>
<method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="allocate_individual"><type>multiallocation_chain</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
<method name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method>
<method name="deallocate_individual"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
<method name="set_max_cached_nodes"><type>void</type><parameter name="newmax"><paramtype>size_type</paramtype></parameter><description><para>Sets the new max cached nodes value. This can provoke deallocations if "newmax" is less than current cached nodes. Never throws </para></description></method>
<method name="get_max_cached_nodes" cv="const"><type>size_type</type><description><para>Returns the max cached nodes parameter. Never throws </para></description></method>
</method-group>
<constructor><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> </para></description></constructor>
<constructor><parameter name="other"><paramtype>const <classname>cached_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other <classname alt="boost::interprocess::cached_adaptive_pool">cached_adaptive_pool</classname>. Increments the reference count of the associated node pool. Never throws </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related <classname alt="boost::interprocess::cached_adaptive_pool">cached_adaptive_pool</classname>. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> </para></description></constructor>
<destructor><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor>
<method-group name="friend functions">
<method name="swap"><type>friend void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
</method-group>
</class>














<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of <classname alt="boost::interprocess::cached_adaptive_pool">cached_adaptive_pool</classname> </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>cached_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of <classname alt="boost::interprocess::cached_adaptive_pool">cached_adaptive_pool</classname> </para></description></function>
































</namespace>
</namespace>
</header>
<header name="boost/interprocess/allocators/cached_node_allocator.hpp">
<para>Describes cached_cached_node_allocator pooled shared memory STL compatible allocator </para><namespace name="boost">
<namespace name="interprocess">
<class name="cached_node_allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
    </template><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <classname alt="boost::interprocess::cached_node_allocator">cached_node_allocator</classname> from <classname alt="boost::interprocess::cached_node_allocator">cached_node_allocator</classname> </para></description><typedef name="other"><type><classname>cached_node_allocator</classname>&lt; T2, SegmentManager &gt;</type></typedef>
</struct><typedef name="segment_manager"><type>implementation_defined::segment_manager</type></typedef>
<typedef name="void_pointer"><type>segment_manager::void_pointer</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="size_type"><type>SegmentManager::size_type</type></typedef>
<typedef name="difference_type"><type>SegmentManager::difference_type</type></typedef>
<method-group name="private member functions">
</method-group>
<copy-assignment><type><classname>cached_node_allocator</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>cached_node_allocator</classname>&lt; T2, SegmentManager2, N2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related <classname alt="boost::interprocess::cached_node_allocator">cached_node_allocator</classname> </para></description></copy-assignment>
<copy-assignment><type><classname>cached_node_allocator</classname> &amp;</type><parameter name=""><paramtype>const <classname>cached_node_allocator</classname> &amp;</paramtype></parameter><description><para>Not assignable from other <classname alt="boost::interprocess::cached_node_allocator">cached_node_allocator</classname> </para></description></copy-assignment>
<method-group name="public member functions">
<method name="get_node_pool" cv="const"><type>node_pool_t *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method>
<method name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method name="deallocate_free_blocks"><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method>
<method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
<method name="construct"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Default construct an object. Throws if T's default constructor throws </para></description></method>
<method name="destroy"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method>
<method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="allocate_individual"><type>multiallocation_chain</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
<method name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method>
<method name="deallocate_individual"><type>void</type><parameter name="it"><paramtype>multiallocation_chain</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
<method name="set_max_cached_nodes"><type>void</type><parameter name="newmax"><paramtype>size_type</paramtype></parameter><description><para>Sets the new max cached nodes value. This can provoke deallocations if "newmax" is less than current cached nodes. Never throws </para></description></method>
<method name="get_max_cached_nodes" cv="const"><type>size_type</type><description><para>Returns the max cached nodes parameter. Never throws </para></description></method>
</method-group>
<constructor><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> </para></description></constructor>
<constructor><parameter name="other"><paramtype>const <classname>cached_node_allocator</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other <classname alt="boost::interprocess::cached_node_allocator">cached_node_allocator</classname>. Increments the reference count of the associated node pool. Never throws </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>cached_node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related <classname alt="boost::interprocess::cached_node_allocator">cached_node_allocator</classname>. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> </para></description></constructor>
<destructor><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor>
<method-group name="friend functions">
<method name="swap"><type>friend void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
</method-group>
</class>












<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NPC"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>cached_node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>cached_node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of <classname alt="boost::interprocess::cached_node_allocator">cached_node_allocator</classname> </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NPC"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>cached_node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>cached_node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of <classname alt="boost::interprocess::cached_node_allocator">cached_node_allocator</classname> </para></description></function>


































</namespace>
</namespace>
</header>
<header name="boost/interprocess/allocators/node_allocator.hpp">
<para>Describes node_allocator pooled shared memory STL compatible allocator </para><namespace name="boost">
<namespace name="interprocess">
<class name="node_allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc... This node allocator shares a segregated storage between all instances of <classname alt="boost::interprocess::node_allocator">node_allocator</classname> with equal sizeof(T) placed in the same segment group. NodesPerBlock is the number of nodes allocated at once when the allocator runs out of nodes </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <classname alt="boost::interprocess::node_allocator">node_allocator</classname> from <classname alt="boost::interprocess::node_allocator">node_allocator</classname> </para></description><typedef name="other"><type><classname>node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt;</type></typedef>
</struct><typedef name="segment_manager"><type>implementation_defined::segment_manager</type></typedef>
<typedef name="void_pointer"><type>segment_manager::void_pointer</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="size_type"><type>segment_manager::size_type</type></typedef>
<typedef name="difference_type"><type>segment_manager::difference_type</type></typedef>
<method-group name="private member functions">
</method-group>
<copy-assignment><type><classname>node_allocator</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>node_allocator</classname>&lt; T2, SegmentManager2, N2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related <classname alt="boost::interprocess::node_allocator">node_allocator</classname> </para></description></copy-assignment>
<method-group name="public member functions">
<method name="get_node_pool" cv="const"><type>void *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method>
<method name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method name="deallocate_free_blocks"><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method>
<method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
<method name="construct"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object. Throws if T's copy constructor throws </para></description></method>
<method name="destroy"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method>
<method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
<method name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method>
<method name="deallocate_individual"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
</method-group>
<constructor><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Not assignable from other <classname alt="boost::interprocess::node_allocator">node_allocator</classname> Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> </para></description></constructor>
<constructor><parameter name="other"><paramtype>const <classname>node_allocator</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other <classname alt="boost::interprocess::node_allocator">node_allocator</classname>. Increments the reference count of the associated node pool. Never throws </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related <classname alt="boost::interprocess::node_allocator">node_allocator</classname>. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> </para></description></constructor>
<destructor><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor>
<method-group name="friend functions">
<method name="swap"><type>friend void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
</method-group>
</class>










<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NPC"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of <classname alt="boost::interprocess::node_allocator">node_allocator</classname> </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NPC"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>node_allocator</classname>&lt; T, S, NPC &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of <classname alt="boost::interprocess::node_allocator">node_allocator</classname> </para></description></function>




































</namespace>
</namespace>
</header>
<header name="boost/interprocess/allocators/private_adaptive_pool.hpp">
<para>Describes private_adaptive_pool_base pooled shared memory STL compatible allocator </para><namespace name="boost">
<namespace name="interprocess">
<class name="private_adaptive_pool"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="MaxFreeBlocks"><type>std::size_t</type></template-nontype-parameter>
      <template-nontype-parameter name="OverheadPercent"><type>unsigned char</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc... This allocator has its own node pool.</para><para>NodesPerBlock is the minimum number of nodes of nodes allocated at once when the allocator needs runs out of nodes. MaxFreeBlocks is the maximum number of totally free blocks that the adaptive node pool will hold. The rest of the totally free blocks will be deallocated with the segment manager.</para><para>OverheadPercent is the (approximated) maximum size overhead (1-20%) of the allocator: (memory usable for nodes / total memory allocated from the segment manager) </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <classname alt="boost::interprocess::private_adaptive_pool">private_adaptive_pool</classname> from <classname alt="boost::interprocess::private_adaptive_pool">private_adaptive_pool</classname> </para></description><typedef name="other"><type><classname>private_adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef>
</struct><typedef name="segment_manager"><type>implementation_defined::segment_manager</type></typedef>
<typedef name="void_pointer"><type>segment_manager::void_pointer</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="size_type"><type>segment_manager::size_type</type></typedef>
<typedef name="difference_type"><type>segment_manager::difference_type</type></typedef>
<method-group name="private member functions">
</method-group>
<copy-assignment><type><classname>private_adaptive_pool</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F2"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP2"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>private_adaptive_pool</classname>&lt; T2, SegmentManager2, N2, F2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related <classname alt="boost::interprocess::private_adaptive_pool">private_adaptive_pool</classname> </para></description></copy-assignment>
<copy-assignment><type><classname>private_adaptive_pool</classname> &amp;</type><parameter name=""><paramtype>const <classname>private_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Not assignable from other <classname alt="boost::interprocess::private_adaptive_pool">private_adaptive_pool</classname> </para></description></copy-assignment>
<method-group name="public member functions">
<method name="get_node_pool" cv="const"><type>node_pool_t *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method>
<method name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method name="deallocate_free_blocks"><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method>
<method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
<method name="construct"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object. Throws if T's copy constructor throws </para></description></method>
<method name="destroy"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method>
<method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
<method name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method>
<method name="deallocate_individual"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
</method-group>
<constructor><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> </para></description></constructor>
<constructor><parameter name="other"><paramtype>const <classname>private_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other <classname alt="boost::interprocess::private_adaptive_pool">private_adaptive_pool</classname>. Increments the reference count of the associated node pool. Never throws </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T2, SegmentManager, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related <classname alt="boost::interprocess::private_adaptive_pool">private_adaptive_pool</classname>. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> </para></description></constructor>
<destructor><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor>
<method-group name="friend functions">
<method name="swap"><type>friend void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
</method-group>
</class>








<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of <classname alt="boost::interprocess::private_adaptive_pool">private_adaptive_pool</classname> </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>private_adaptive_pool</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of <classname alt="boost::interprocess::private_adaptive_pool">private_adaptive_pool</classname> </para></description></function>






































</namespace>
</namespace>
</header>
<header name="boost/interprocess/allocators/private_node_allocator.hpp">
<para>Describes private_node_allocator_base pooled shared memory STL compatible allocator </para><namespace name="boost">
<namespace name="interprocess">
<class name="private_node_allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a segment manager as memory source. The internal pointer type will of the same type (raw, smart) as "typename SegmentManager::void_pointer" type. This allows placing the allocator in shared memory, memory mapped-files, etc... This allocator has its own node pool. NodesPerBlock is the number of nodes allocated at once when the allocator needs runs out of nodes </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <classname alt="boost::interprocess::private_node_allocator">private_node_allocator</classname> from <classname alt="boost::interprocess::private_node_allocator">private_node_allocator</classname> </para></description><typedef name="other"><type><classname>private_node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt;</type></typedef>
</struct><typedef name="segment_manager"><type>implementation_defined::segment_manager</type></typedef>
<typedef name="void_pointer"><type>segment_manager::void_pointer</type></typedef>
<typedef name="pointer"><type>implementation_defined::pointer</type></typedef>
<typedef name="const_pointer"><type>implementation_defined::const_pointer</type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="size_type"><type>segment_manager::size_type</type></typedef>
<typedef name="difference_type"><type>segment_manage::difference_type</type></typedef>
<method-group name="private member functions">
</method-group>
<copy-assignment><type><classname>private_node_allocator</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="SegmentManager2"/>
          <template-nontype-parameter name="N2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>private_node_allocator</classname>&lt; T2, SegmentManager2, N2 &gt; &amp;</paramtype></parameter><description><para>Not assignable from related <classname alt="boost::interprocess::private_node_allocator">private_node_allocator</classname> </para></description></copy-assignment>
<copy-assignment><type><classname>private_node_allocator</classname> &amp;</type><parameter name=""><paramtype>const <classname>private_node_allocator</classname> &amp;</paramtype></parameter><description><para>Not assignable from other <classname alt="boost::interprocess::private_node_allocator">private_node_allocator</classname> </para></description></copy-assignment>
<method-group name="public member functions">
<method name="get_node_pool" cv="const"><type>node_pool_t *</type><description><para>Returns a pointer to the node pool. Never throws </para></description></method>
<method name="get_segment_manager" cv="const"><type>segment_manager *</type><description><para>Returns the segment manager. Never throws </para></description></method>
<method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>cvoid_pointer</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="deallocate"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method name="deallocate_free_blocks"><type>void</type><description><para>Deallocates all free blocks of the pool </para></description></method>
<method name="address" cv="const"><type>pointer</type><parameter name="value"><paramtype>reference</paramtype></parameter><description><para>Returns address of mutable object. Never throws </para></description></method>
<method name="address" cv="const"><type>const_pointer</type><parameter name="value"><paramtype>const_reference</paramtype></parameter><description><para>Returns address of non mutable object. Never throws </para></description></method>
<method name="construct"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="v"><paramtype>const_reference</paramtype></parameter><description><para>Copy construct an object. Throws if T's copy constructor throws </para></description></method>
<method name="destroy"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Destroys object. Throws if object's destructor throws </para></description></method>
<method name="size" cv="const"><type>size_type</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. This size only works for memory allocated with allocate, allocation_command and allocate_many. </para></description></method>
<method name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i]in a contiguous block of memory. The elements must be deallocated </para></description></method>
<method name="deallocate_many"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. The elements must be deallocated with deallocate(...) </para></description></method>
<method name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory </para></description></method>
<method name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
<method name="deallocate_one"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method>
<method name="deallocate_individual"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1 in a contiguous block of memory. The minimum number to be allocated is min_elements, the preferred and maximum number is preferred_elements. The number of actually allocated elements is will be assigned to received_size. Memory allocated with this function must be deallocated only with deallocate_one(). </para></description></method>
</method-group>
<constructor><parameter name="segment_mngr"><paramtype>segment_manager *</paramtype></parameter><description><para>Constructor from a segment manager. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> </para></description></constructor>
<constructor><parameter name="other"><paramtype>const <classname>private_node_allocator</classname> &amp;</paramtype></parameter><description><para>Copy constructor from other <classname alt="boost::interprocess::private_node_allocator">private_node_allocator</classname>. Increments the reference count of the associated node pool. Never throws </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="other"><paramtype>const <classname>private_node_allocator</classname>&lt; T2, SegmentManager, NodesPerBlock &gt; &amp;</paramtype></parameter><description><para>Copy constructor from related <classname alt="boost::interprocess::private_node_allocator">private_node_allocator</classname>. If not present, constructs a node pool. Increments the reference count of the associated node pool. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> </para></description></constructor>
<destructor><description><para>Destructor, removes node_pool_t from memory if its reference count reaches to zero. Never throws </para></description></destructor>
<method-group name="friend functions">
<method name="swap"><type>friend void</type><parameter name="alloc1"><paramtype>self_t &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
</method-group>
</class>






<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>private_node_allocator</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>private_node_allocator</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Equality test for same type of <classname alt="boost::interprocess::private_node_allocator">private_node_allocator</classname> </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="S"/>
          <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="F"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="OP"><type>unsigned char</type></template-nontype-parameter>
        </template><parameter name="alloc1"><paramtype>const <classname>private_node_allocator</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><parameter name="alloc2"><paramtype>const <classname>private_node_allocator</classname>&lt; T, S, NodesPerBlock, F, OP &gt; &amp;</paramtype></parameter><description><para>Inequality test for same type of <classname alt="boost::interprocess::private_node_allocator">private_node_allocator</classname> </para></description></function>








































</namespace>
</namespace>
</header>
<header name="boost/interprocess/anonymous_shared_memory.hpp">
<para>Describes a function that creates anonymous shared memory that can be shared between forked processes </para><namespace name="boost">
<namespace name="interprocess">






<function name="anonymous_shared_memory"><type><classname>mapped_region</classname></type><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="address"><paramtype>void *</paramtype><default>0</default></parameter><description><para>A function that creates an anonymous shared memory segment of size "size". If "address" is passed the function will try to map the segment in that address. Otherwise the operating system will choose the mapping address. The function returns a <classname alt="boost::interprocess::mapped_region">mapped_region</classname> holding that segment or throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> if the function fails. </para></description></function>










































</namespace>
</namespace>
</header>
<header name="boost/interprocess/containers/allocation_type.hpp">
<namespace name="boost">
<namespace name="interprocess">
<data-member name="allocate_new" specifiers="static"><type>const allocation_type</type></data-member>
<data-member name="expand_fwd" specifiers="static"><type>const allocation_type</type></data-member>
<data-member name="expand_bwd" specifiers="static"><type>const allocation_type</type></data-member>
<data-member name="shrink_in_place" specifiers="static"><type>const allocation_type</type></data-member>
<data-member name="try_shrink_in_place" specifiers="static"><type>const allocation_type</type></data-member>
<data-member name="nothrow_allocation" specifiers="static"><type>const allocation_type</type></data-member>
<data-member name="zero_memory" specifiers="static"><type>const allocation_type</type></data-member>

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/containers/containers_fwd.hpp">
</header>
<header name="boost/interprocess/containers/deque.hpp">
<namespace name="boost">
<namespace name="interprocess">

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/containers/flat_map.hpp">
<namespace name="boost">
<namespace name="interprocess">

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/containers/flat_set.hpp">
<namespace name="boost">
<namespace name="interprocess">

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/containers/list.hpp">
<namespace name="boost">
<namespace name="interprocess">

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/containers/map.hpp">
<namespace name="boost">
<namespace name="interprocess">

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/containers/pair.hpp">
<namespace name="boost">
<namespace name="interprocess">

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/containers/set.hpp">
<namespace name="boost">
<namespace name="interprocess">

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/containers/slist.hpp">
<namespace name="boost">
<namespace name="interprocess">

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/containers/stable_vector.hpp">
<namespace name="boost">
<namespace name="interprocess">

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/containers/string.hpp">
<namespace name="boost">
<namespace name="interprocess">

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/containers/vector.hpp">
<namespace name="boost">
<namespace name="interprocess">

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/containers/version_type.hpp">
<namespace name="boost">
<namespace name="interprocess">

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/creation_tags.hpp">
<namespace name="boost">
<namespace name="interprocess">
<struct name="create_only_t"><description><para>Tag to indicate that the resource must be only created </para></description></struct><struct name="open_copy_on_write_t"><description><para>Tag to indicate that the resource must be only opened for reading </para></description></struct><struct name="open_only_t"><description><para>Tag to indicate that the resource must be only opened </para></description></struct><struct name="open_or_create_t"><description><para>Tag to indicate that the resource must be created. If already created, it must be opened. </para></description></struct><struct name="open_read_only_t"><description><para>Tag to indicate that the resource must be only opened for reading </para></description></struct><struct name="open_read_private_t"><description><para>Tag to indicate that the resource must be only opened privately for reading </para></description></struct><data-member name="create_only" specifiers="static"><type>const <classname>create_only_t</classname></type><description><para>Value to indicate that the resource must be only created </para></description></data-member>
<data-member name="open_only" specifiers="static"><type>const <classname>open_only_t</classname></type><description><para>Value to indicate that the resource must be only opened </para></description></data-member>
<data-member name="open_read_only" specifiers="static"><type>const <classname>open_read_only_t</classname></type><description><para>Value to indicate that the resource must be only opened for reading </para></description></data-member>
<data-member name="open_or_create" specifiers="static"><type>const <classname>open_or_create_t</classname></type><description><para>Value to indicate that the resource must be created. If already created, it must be opened. </para></description></data-member>
<data-member name="open_copy_on_write" specifiers="static"><type>const <classname>open_copy_on_write_t</classname></type><description><para>Value to indicate that the resource must be only opened for reading </para></description></data-member>

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/errors.hpp">
<para>Describes the error numbering of interprocess classes </para><namespace name="boost">
<namespace name="interprocess">
<enum name="error_code_t"><enumvalue name="no_error"><default>= 0</default></enumvalue><enumvalue name="system_error"/><enumvalue name="other_error"/><enumvalue name="security_error"/><enumvalue name="read_only_error"/><enumvalue name="io_error"/><enumvalue name="path_error"/><enumvalue name="not_found_error"/><enumvalue name="busy_error"/><enumvalue name="already_exists_error"/><enumvalue name="not_empty_error"/><enumvalue name="is_directory_error"/><enumvalue name="out_of_space_error"/><enumvalue name="out_of_memory_error"/><enumvalue name="out_of_resource_error"/><enumvalue name="lock_error"/><enumvalue name="sem_error"/><enumvalue name="mode_error"/><enumvalue name="size_error"/><enumvalue name="corrupted_error"/><enumvalue name="not_such_file_or_directory"/><enumvalue name="invalid_argument"/><enumvalue name="timeout_when_locking_error"/><enumvalue name="timeout_when_waiting_error"/><enumvalue name="owner_dead_error"/><enumvalue name="not_recoverable"/></enum>
<typedef name="native_error_t"><type>int</type></typedef>

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/exceptions.hpp">
<para>Describes exceptions thrown by interprocess classes </para><namespace name="boost">
<namespace name="interprocess">
<class name="bad_alloc"><inherit access="public">boost::interprocess::interprocess_exception</inherit><description><para>This exception is thrown when a memory request can't be fulfilled. </para></description><method-group name="public member functions">
<method name="what" cv="const noexcept"><type>const char *</type></method>
</method-group>
<constructor/>
</class><class name="interprocess_exception"><inherit access="public">exception</inherit><description><para>This class is the base class of all exceptions thrown by boost::interprocess </para></description><method-group name="public member functions">
<method name="what" cv="const noexcept"><type>const char *</type></method>
<method name="get_native_error" cv="const noexcept"><type>native_error_t</type></method>
<method name="get_error_code" cv="const noexcept"><type>error_code_t</type></method>
</method-group>
<constructor cv="noexcept"><parameter name="err"><paramtype>const char *</paramtype></parameter></constructor>
<constructor><parameter name="err_info"><paramtype>const error_info &amp;</paramtype></parameter><parameter name="str"><paramtype>const char *</paramtype><default>0</default></parameter></constructor>
<destructor/>
</class><class name="lock_exception"><inherit access="public">boost::interprocess::interprocess_exception</inherit><description><para>This is the exception thrown by shared <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> family when a deadlock situation is detected or when using a <classname alt="boost::interprocess::interprocess_condition">interprocess_condition</classname> the <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> is not locked </para></description><method-group name="public member functions">
<method name="what" cv="const noexcept"><type>const char *</type></method>
</method-group>
<constructor cv="noexcept"><parameter name="err"><paramtype>error_code_t</paramtype><default>lock_error</default></parameter></constructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/file_mapping.hpp">
<para>Describes file_mapping and mapped region classes </para><namespace name="boost">
<namespace name="interprocess">
<class name="file_mapping"><description><para>A class that wraps a file-mapping that can be used to create mapped regions from the mapped files </para></description><method-group name="public member functions">
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>file_mapping</classname> &amp;</paramtype></parameter><description><para>Swaps to file_mappings. Does not throw. </para></description></method>
<method name="get_mode" cv="const noexcept"><type>mode_t</type><description><para>Returns access mode used in the constructor </para></description></method>
<method name="get_mapping_handle" cv="const noexcept"><type>mapping_handle_t</type><description><para>Obtains the mapping handle to be used with <classname alt="boost::interprocess::mapped_region">mapped_region</classname> </para></description></method>
<method name="get_name" cv="const noexcept"><type>const char *</type><description><para>Returns the name of the file used in the constructor. </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Constructs an empty file mapping. Does not throw </para></description></constructor>
<constructor><parameter name="filename"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Opens a file mapping of file "filename", starting in offset "file_offset", and the mapping's size will be "size". The mapping can be opened for read-only "read_only" or read-write "read_write" modes. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></constructor>
<constructor><parameter name="filename"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Opens a file mapping of file "filename", starting in offset "file_offset", and the mapping's size will be "size". The mapping can be opened for read-only "read_only" or read-write "read_write" modes. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor cv="noexcept"><parameter name="moved"><paramtype><classname>file_mapping</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s file mapping object to *this. After the call, "moved" does not represent any file mapping object. Does not throw </para></description></constructor>
<copy-assignment cv="noexcept"><type><classname>file_mapping</classname> &amp;</type><parameter name="moved"><paramtype><classname>file_mapping</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s file mapping to *this. After the call, "moved" does not represent any file mapping. Does not throw </para></description></copy-assignment>
<destructor><description><para>Destroys the file mapping. All mapped regions created from this are still valid. Does not throw </para></description></destructor>
<method-group name="public static functions">
<method name="remove" specifiers="static"><type>bool</type><parameter name="filename"><paramtype>const char *</paramtype></parameter><description><para>Removes the file named "filename" even if it's been memory mapped. Returns true on success. The function might fail in some operating systems if the file is being used other processes and no deletion permission was shared. </para></description></method>
<method name="remove" specifiers="static"><type>bool</type><parameter name="filename"><paramtype>const wchar_t *</paramtype></parameter><description><para>Removes the file named "filename" even if it's been memory mapped. Returns true on success. The function might fail in some operating systems if the file is being used other processes and no deletion permission was shared.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/indexes/flat_map_index.hpp">
<para>Describes index adaptor of boost::map container, to use it as name/shared memory index </para><namespace name="boost">
<namespace name="interprocess">
<class name="flat_map_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><inherit access="public">flat_map_index_aux::index_t&lt; MapConfig &gt;</inherit><description><para>Index type based in flat_map. Just derives from flat_map and defines the interface needed by managed memory segments. </para></description><method-group name="public member functions">
<method name="reserve"><type>void</type><parameter name="n"><paramtype>typename segment_manager_base::size_type</paramtype></parameter><purpose>This reserves memory to optimize the insertion of n elements in the index. </purpose></method>
<method name="shrink_to_fit"><type>void</type><purpose>This frees all unnecessary memory. </purpose></method>
</method-group>
<constructor><parameter name="segment_mngr"><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><purpose>Constructor. Takes a pointer to the segment manager. Can throw. </purpose></constructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/indexes/iset_index.hpp">
<para>Describes index adaptor of boost::intrusive::set container, to use it as name/shared memory index </para><namespace name="boost">
<namespace name="interprocess">
<class name="iset_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><inherit access="public">iset_index_aux::index_t&lt; MapConfig &gt;</inherit><description><para>Index type based in boost::intrusive::set. Just derives from boost::intrusive::set and defines the interface needed by managed memory segments </para></description><typedef name="iterator"><type>index_type::iterator</type></typedef>
<typedef name="const_iterator"><type>index_type::const_iterator</type></typedef>
<typedef name="insert_commit_data"><type>index_type::insert_commit_data</type></typedef>
<typedef name="value_type"><type>index_type::value_type</type></typedef>
<method-group name="public member functions">
<method name="reserve"><type>void</type><parameter name=""><paramtype>typename MapConfig::segment_manager_base::size_type</paramtype></parameter><description><para>This reserves memory to optimize the insertion of n elements in the index </para></description></method>
<method name="shrink_to_fit"><type>void</type><purpose>This frees all unnecessary memory. </purpose></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const intrusive_compare_key_type &amp;</paramtype></parameter></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const intrusive_compare_key_type &amp;</paramtype></parameter></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const intrusive_compare_key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name=""><paramtype>typename MapConfig::segment_manager_base *</paramtype></parameter><description><para>Constructor. Takes a pointer to the segment manager. Can throw </para></description></constructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/indexes/iunordered_set_index.hpp">
<para>Describes index adaptor of boost::intrusive::unordered_set container, to use it as name/shared memory index </para><namespace name="boost">
<namespace name="interprocess">
<class name="iunordered_set_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><inherit access="private">iunordered_set_index_aux::allocator_holder&lt; MapConfig &gt;</inherit><inherit access="public">iunordered_set_index_aux::index_t&lt; MapConfig &gt;</inherit><description><para>Index type based in boost::intrusive::set. Just derives from boost::intrusive::set and defines the interface needed by managed memory segments </para></description><typedef name="iterator"><type>index_type::iterator</type></typedef>
<typedef name="const_iterator"><type>index_type::const_iterator</type></typedef>
<typedef name="insert_commit_data"><type>index_type::insert_commit_data</type></typedef>
<typedef name="value_type"><type>index_type::value_type</type></typedef>
<typedef name="bucket_ptr"><type>index_type::bucket_ptr</type></typedef>
<typedef name="bucket_type"><type>index_type::bucket_type</type></typedef>
<typedef name="bucket_traits"><type>index_type::bucket_traits</type></typedef>
<typedef name="size_type"><type>index_type::size_type</type></typedef>
<typedef name="difference_type"><type>index_type::difference_type</type></typedef>
<method-group name="public member functions">
<method name="reserve"><type>void</type><parameter name="new_n"><paramtype>size_type</paramtype></parameter><description><para>This reserves memory to optimize the insertion of n elements in the index </para></description></method>
<method name="shrink_to_fit"><type>void</type><description><para>This tries to free unused memory previously allocated. </para></description></method>
<method name="find"><type>iterator</type><parameter name="key"><paramtype>const intrusive_compare_key_type &amp;</paramtype></parameter></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="key"><paramtype>const intrusive_compare_key_type &amp;</paramtype></parameter></method>
<method name="insert_check"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="key"><paramtype>const intrusive_compare_key_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
<method name="insert_commit"><type>iterator</type><parameter name="val"><paramtype>value_type &amp;</paramtype></parameter><parameter name="commit_data"><paramtype>insert_commit_data &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="mngr"><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><description><para>Constructor. Takes a pointer to the segment manager. Can throw </para></description></constructor>
<destructor/>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/indexes/map_index.hpp">
<para>Describes index adaptor of boost::map container, to use it as name/shared memory index </para><namespace name="boost">
<namespace name="interprocess">
<class name="map_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><inherit access="public">boost::container::map&lt; MapConfig &gt;</inherit><description><para>Index type based in boost::interprocess::map. Just derives from boost::interprocess::map and defines the interface needed by managed memory segments </para></description><method-group name="public member functions">
<method name="reserve"><type>void</type><parameter name=""><paramtype>typename segment_manager_base::size_type</paramtype></parameter><description><para>This reserves memory to optimize the insertion of n elements in the index </para></description></method>
<method name="shrink_to_fit"><type>void</type><description><para>This tries to free previously allocate unused memory. </para></description></method>
</method-group>
<constructor><parameter name="segment_mngr"><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><description><para>Constructor. Takes a pointer to the segment manager. Can throw </para></description></constructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/indexes/null_index.hpp">
<para>Describes a null index adaptor, so that if we don't want to construct named objects, we can use this null index type to save resources. </para><namespace name="boost">
<namespace name="interprocess">
<class name="null_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><description><para>Null index type used to save compilation time when named indexes are not needed. </para></description><typedef name="iterator"><type>int *</type></typedef>
<typedef name="const_iterator"><type>const int *</type></typedef>
<method-group name="public member functions">
<method name="begin" cv="const"><type>const_iterator</type><description><para>begin() is equal to end() </para></description></method>
<method name="begin"><type>iterator</type><description><para>begin() is equal to end() </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para>begin() is equal to end() </para></description></method>
<method name="end"><type>iterator</type><description><para>begin() is equal to end() </para></description></method>
</method-group>
<constructor><parameter name=""><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><purpose>Empty constructor. </purpose></constructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/indexes/unordered_map_index.hpp">
<para>Describes index adaptor of boost::unordered_map container, to use it as name/shared memory index </para><namespace name="boost">
<namespace name="interprocess">
<class name="unordered_map_index"><template>
      <template-type-parameter name="MapConfig"/>
    </template><inherit access="public">unordered_map_index_aux::index_t&lt; MapConfig &gt;</inherit><description><para>Index type based in unordered_map. Just derives from unordered_map and defines the interface needed by managed memory segments </para></description><method-group name="public member functions">
<method name="reserve"><type>void</type><parameter name="n"><paramtype>typename segment_manager_base::size_type</paramtype></parameter><description><para>This reserves memory to optimize the insertion of n elements in the index </para></description></method>
<method name="shrink_to_fit"><type>void</type><description><para>This tries to free previously allocate unused memory. </para></description></method>
</method-group>
<constructor><parameter name="segment_mngr"><paramtype><classname>segment_manager_base</classname> *</paramtype></parameter><description><para>Constructor. Takes a pointer to the segment manager. Can throw </para></description></constructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/interprocess_fwd.hpp">
<para>This header file forward declares the basic interprocess types:<itemizedlist>
<listitem><para><classname alt="boost::interprocess::offset_ptr">boost::interprocess::offset_ptr</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::permissions">boost::interprocess::permissions</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::mapped_region">boost::interprocess::mapped_region</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::file_mapping">boost::interprocess::file_mapping</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::shared_memory_object">boost::interprocess::shared_memory_object</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::windows_shared_memory">boost::interprocess::windows_shared_memory</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::xsi_shared_memory">boost::interprocess::xsi_shared_memory</classname>;</para>
</listitem></itemizedlist>
</para><para>The following synchronization mechanisms and locks:<itemizedlist>
<listitem><para><classname alt="boost::interprocess::null_mutex">boost::interprocess::null_mutex</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::interprocess_mutex">boost::interprocess::interprocess_mutex</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::interprocess_recursive_mutex">boost::interprocess::interprocess_recursive_mutex</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::interprocess_semaphore">boost::interprocess::interprocess_semaphore</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::named_mutex">boost::interprocess::named_mutex</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::named_recursive_mutex">boost::interprocess::named_recursive_mutex</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::named_semaphore">boost::interprocess::named_semaphore</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::interprocess_sharable_mutex">boost::interprocess::interprocess_sharable_mutex</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::interprocess_condition">boost::interprocess::interprocess_condition</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::scoped_lock">boost::interprocess::scoped_lock</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::sharable_lock">boost::interprocess::sharable_lock</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::upgradable_lock">boost::interprocess::upgradable_lock</classname>;</para>
</listitem></itemizedlist>
</para><para>The following mutex families:<itemizedlist>
<listitem><para><classname alt="boost::interprocess::mutex_family">boost::interprocess::mutex_family</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::null_mutex_family">boost::interprocess::null_mutex_family</classname>;</para>
</listitem></itemizedlist>
</para><para>The following allocators:<itemizedlist>
<listitem><para><classname alt="boost::interprocess::allocator">boost::interprocess::allocator</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::node_allocator">boost::interprocess::node_allocator</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::private_node_allocator">boost::interprocess::private_node_allocator</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::cached_node_allocator">boost::interprocess::cached_node_allocator</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::adaptive_pool">boost::interprocess::adaptive_pool</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::private_adaptive_pool">boost::interprocess::private_adaptive_pool</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::cached_adaptive_pool">boost::interprocess::cached_adaptive_pool</classname>;</para>
</listitem></itemizedlist>
</para><para>The following allocation algorithms:<itemizedlist>
<listitem><para><classname alt="boost::interprocess::simple_seq_fit">boost::interprocess::simple_seq_fit</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::rbtree_best_fit">boost::interprocess::rbtree_best_fit</classname>;</para>
</listitem></itemizedlist>
</para><para>The following index types:<itemizedlist>
<listitem><para><classname alt="boost::interprocess::flat_map_index">boost::interprocess::flat_map_index</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::iset_index">boost::interprocess::iset_index</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::iunordered_set_index">boost::interprocess::iunordered_set_index</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::map_index">boost::interprocess::map_index</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::null_index">boost::interprocess::null_index</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::unordered_map_index">boost::interprocess::unordered_map_index</classname>;</para>
</listitem></itemizedlist>
</para><para>The following managed memory types:<itemizedlist>
<listitem><para><classname alt="boost::interprocess::segment_manager">boost::interprocess::segment_manager</classname>;</para>
</listitem><listitem><para><classname alt="boost::interprocess::basic_managed_external_buffer">boost::interprocess::basic_managed_external_buffer</classname></para>
</listitem><listitem><para>boost::interprocess::managed_external_buffer</para>
</listitem><listitem><para>boost::interprocess::wmanaged_external_buffer</para>
</listitem><listitem><para><classname alt="boost::interprocess::basic_managed_shared_memory">boost::interprocess::basic_managed_shared_memory</classname></para>
</listitem><listitem><para>boost::interprocess::managed_shared_memory</para>
</listitem><listitem><para>boost::interprocess::wmanaged_shared_memory</para>
</listitem><listitem><para><classname alt="boost::interprocess::basic_managed_windows_shared_memory">boost::interprocess::basic_managed_windows_shared_memory</classname></para>
</listitem><listitem><para>boost::interprocess::managed_windows_shared_memory</para>
</listitem><listitem><para>boost::interprocess::wmanaged_windows_shared_memory</para>
</listitem><listitem><para><classname alt="boost::interprocess::basic_managed_xsi_shared_memory">boost::interprocess::basic_managed_xsi_shared_memory</classname></para>
</listitem><listitem><para>boost::interprocess::managed_xsi_shared_memory</para>
</listitem><listitem><para>boost::interprocess::wmanaged_xsi_shared_memory</para>
</listitem><listitem><para>boost::interprocess::fixed_managed_shared_memory</para>
</listitem><listitem><para>boost::interprocess::wfixed_managed_shared_memory</para>
</listitem><listitem><para><classname alt="boost::interprocess::basic_managed_heap_memory">boost::interprocess::basic_managed_heap_memory</classname></para>
</listitem><listitem><para>boost::interprocess::managed_heap_memory</para>
</listitem><listitem><para>boost::interprocess::wmanaged_heap_memory</para>
</listitem><listitem><para><classname alt="boost::interprocess::basic_managed_mapped_file">boost::interprocess::basic_managed_mapped_file</classname></para>
</listitem><listitem><para>boost::interprocess::managed_mapped_file</para>
</listitem><listitem><para>boost::interprocess::wmanaged_mapped_file</para>
</listitem></itemizedlist>
</para><para>The following exception types:<itemizedlist>
<listitem><para><classname alt="boost::interprocess::interprocess_exception">boost::interprocess::interprocess_exception</classname></para>
</listitem><listitem><para><classname alt="boost::interprocess::lock_exception">boost::interprocess::lock_exception</classname></para>
</listitem><listitem><para><classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname></para>
</listitem></itemizedlist>
</para><para>The following stream types:<itemizedlist>
<listitem><para><classname alt="boost::interprocess::basic_bufferbuf">boost::interprocess::basic_bufferbuf</classname></para>
</listitem><listitem><para><classname alt="boost::interprocess::basic_ibufferstream">boost::interprocess::basic_ibufferstream</classname></para>
</listitem><listitem><para><classname alt="boost::interprocess::basic_obufferstream">boost::interprocess::basic_obufferstream</classname></para>
</listitem><listitem><para><classname alt="boost::interprocess::basic_bufferstream">boost::interprocess::basic_bufferstream</classname></para>
</listitem><listitem><para><classname alt="boost::interprocess::basic_vectorbuf">boost::interprocess::basic_vectorbuf</classname></para>
</listitem><listitem><para><classname alt="boost::interprocess::basic_ivectorstream">boost::interprocess::basic_ivectorstream</classname></para>
</listitem><listitem><para><classname alt="boost::interprocess::basic_ovectorstream">boost::interprocess::basic_ovectorstream</classname></para>
</listitem><listitem><para><classname alt="boost::interprocess::basic_vectorstream">boost::interprocess::basic_vectorstream</classname></para>
</listitem></itemizedlist>
</para><para>The following smart pointer types:<itemizedlist>
<listitem><para><classname alt="boost::interprocess::scoped_ptr">boost::interprocess::scoped_ptr</classname></para>
</listitem><listitem><para><classname alt="boost::interprocess::intrusive_ptr">boost::interprocess::intrusive_ptr</classname></para>
</listitem><listitem><para><classname alt="boost::interprocess::shared_ptr">boost::interprocess::shared_ptr</classname></para>
</listitem><listitem><para><classname alt="boost::interprocess::weak_ptr">boost::interprocess::weak_ptr</classname></para>
</listitem></itemizedlist>
</para><para>The following interprocess communication types:<itemizedlist>
<listitem><para><classname alt="boost::interprocess::message_queue_t">boost::interprocess::message_queue_t</classname>;</para>
</listitem><listitem><para>boost::interprocess::message_queue; </para>
</listitem></itemizedlist>
</para></header>
<header name="boost/interprocess/ipc/message_queue.hpp">
<para>Describes an inter-process message queue. This class allows sending messages between processes and allows blocking, non-blocking and timed sending and receiving. </para><namespace name="boost">
<namespace name="interprocess">
<class name="message_queue_t"><template>
      <template-type-parameter name="VoidPointer"/>
    </template><description><para>A class that allows sending messages between processes. </para></description><typedef name="void_pointer"><type>VoidPointer</type></typedef>
<typedef name="char_ptr"><type>boost::intrusive::pointer_traits&lt; void_pointer &gt;::template rebind_pointer&lt; char &gt;::type</type></typedef>
<typedef name="difference_type"><type>boost::intrusive::pointer_traits&lt; char_ptr &gt;::difference_type</type></typedef>
<typedef name="size_type"><type>boost::container::dtl::make_unsigned&lt; difference_type &gt;::type</type></typedef>
<method-group name="public member functions">
<method name="send"><type>void</type><parameter name="buffer"><paramtype>const void *</paramtype></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype></parameter><parameter name="priority"><paramtype>unsigned int</paramtype></parameter><description><para>Sends a message stored in buffer "buffer" with size "buffer_size" in the message queue with priority "priority". If the message queue is full the sender is blocked. Throws interprocess_error on error. </para></description></method>
<method name="try_send"><type>bool</type><parameter name="buffer"><paramtype>const void *</paramtype></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype></parameter><parameter name="priority"><paramtype>unsigned int</paramtype></parameter><description><para>Sends a message stored in buffer "buffer" with size "buffer_size" through the message queue with priority "priority". If the message queue is full the sender is not blocked and returns false, otherwise returns true. Throws interprocess_error on error. </para></description></method>
<method name="timed_send"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="buffer"><paramtype>const void *</paramtype></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype></parameter><parameter name="priority"><paramtype>unsigned int</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Sends a message stored in buffer "buffer" with size "buffer_size" in the message queue with priority "priority". If the message queue is full the sender retries until time "abs_time" is reached. Returns true if the message has been successfully sent. Returns false if timeout is reached. Throws interprocess_error on error. </para></description></method>
<method name="receive"><type>void</type><parameter name="buffer"><paramtype>void *</paramtype></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype></parameter><parameter name="recvd_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="priority"><paramtype>unsigned int &amp;</paramtype></parameter><description><para>Receives a message from the message queue. The message is stored in buffer "buffer", which has size "buffer_size". The received message has size "recvd_size" and priority "priority". If the message queue is empty the receiver is blocked. Throws interprocess_error on error. </para></description></method>
<method name="try_receive"><type>bool</type><parameter name="buffer"><paramtype>void *</paramtype></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype></parameter><parameter name="recvd_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="priority"><paramtype>unsigned int &amp;</paramtype></parameter><description><para>Receives a message from the message queue. The message is stored in buffer "buffer", which has size "buffer_size". The received message has size "recvd_size" and priority "priority". If the message queue is empty the receiver is not blocked and returns false, otherwise returns true. Throws interprocess_error on error. </para></description></method>
<method name="timed_receive"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="buffer"><paramtype>void *</paramtype></parameter><parameter name="buffer_size"><paramtype>size_type</paramtype></parameter><parameter name="recvd_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="priority"><paramtype>unsigned int &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Receives a message from the message queue. The message is stored in buffer "buffer", which has size "buffer_size". The received message has size "recvd_size" and priority "priority". If the message queue is empty the receiver retries until time "abs_time" is reached. Returns true if the message has been successfully sent. Returns false if timeout is reached. Throws interprocess_error on error. </para></description></method>
<method name="get_max_msg" cv="const"><type>size_type</type><description><para>Returns the maximum number of messages allowed by the queue. The message queue must be opened or created previously. Otherwise, returns 0. Never throws </para></description></method>
<method name="get_max_msg_size" cv="const"><type>size_type</type><description><para>Returns the maximum size of message allowed by the queue. The message queue must be opened or created previously. Otherwise, returns 0. Never throws </para></description></method>
<method name="get_num_msg" cv="const"><type>size_type</type><description><para>Returns the number of messages currently stored. Never throws </para></description></method>
</method-group>
<constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="max_num_msg"><paramtype>size_type</paramtype></parameter><parameter name="max_msg_size"><paramtype>size_type</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a process shared message queue with name "name". For this message queue, the maximum number of messages will be "max_num_msg" and the maximum message size will be "max_msg_size". Throws on error and if the queue was previously created. </para></description></constructor>
<constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="max_num_msg"><paramtype>size_type</paramtype></parameter><parameter name="max_msg_size"><paramtype>size_type</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a process shared message queue with name "name". If the queue is created, the maximum number of messages will be "max_num_msg" and the maximum message size will be "max_msg_size". If queue was previously created the queue will be opened and "max_num_msg" and "max_msg_size" parameters are ignored. Throws on error. </para></description></constructor>
<constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a previously created process shared message queue with name "name". If the queue was not previously created or there are no free resources, throws an error. </para></description></constructor>
<constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="max_num_msg"><paramtype>size_type</paramtype></parameter><parameter name="max_msg_size"><paramtype>size_type</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a process shared message queue with name "name". For this message queue, the maximum number of messages will be "max_num_msg" and the maximum message size will be "max_msg_size". Throws on error and if the queue was previously created.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="max_num_msg"><paramtype>size_type</paramtype></parameter><parameter name="max_msg_size"><paramtype>size_type</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a process shared message queue with name "name". If the queue is created, the maximum number of messages will be "max_num_msg" and the maximum message size will be "max_msg_size". If queue was previously created the queue will be opened and "max_num_msg" and "max_msg_size" parameters are ignored. Throws on error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a previously created process shared message queue with name "name". If the queue was not previously created or there are no free resources, throws an error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. All opened message queues are still valid after destruction. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the message queue from the system use remove(). </para></description></destructor>
<method-group name="public static functions">
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Removes the message queue from the system. Returns false on error. Never throws </para></description></method>
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Removes the message queue from the system. Returns false on error. Never throws</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class><enum name="mqblock_types"><enumvalue name="blocking"/><enumvalue name="timed"/><enumvalue name="non_blocking"/></enum>
<typedef name="message_queue"><description><para>Typedef for a default message queue to be used between processes </para></description><type><classname>message_queue_t</classname>&lt; <classname>offset_ptr</classname>&lt; void &gt; &gt;</type></typedef>

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/managed_external_buffer.hpp">
<para>Describes a named user memory allocation user class. </para><namespace name="boost">
<namespace name="interprocess">
<class name="basic_managed_external_buffer"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic user memory named object creation class. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; </para></description><typedef name="size_type"><type>base_t::size_type</type></typedef>
<method-group name="public member functions">
<method name="grow"><type>void</type><parameter name="extra_bytes"><paramtype>size_type</paramtype></parameter></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>basic_managed_external_buffer</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed heap memories managed by *this and other. Never throws. </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="addr"><paramtype>void *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><description><para>Creates and places the segment manager. This can throw The external memory supplied by the user shall be aligned to the maximum value between <computeroutput>alignof(std::max_align_t)</computeroutput> and the strictest alignment of any over-aligned type to be built inside that memory. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="addr"><paramtype>void *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><description><para>Creates and places the segment manager. This can throw The external memory supplied by the user shall be aligned to the maximum value between <computeroutput>alignof(std::max_align_t)</computeroutput> and the strictest alignment of any over-aligned type to be built inside that memory. </para></description></constructor>
<constructor cv="noexcept"><parameter name="moved"><paramtype><classname>basic_managed_external_buffer</classname> &amp;&amp;</paramtype></parameter><purpose>Moves the ownership of "moved"'s managed memory to *this. Does not throw. </purpose></constructor>
<copy-assignment cv="noexcept"><type><classname>basic_managed_external_buffer</classname> &amp;</type><parameter name="moved"><paramtype><classname>basic_managed_external_buffer</classname> &amp;&amp;</paramtype></parameter><purpose>Moves the ownership of "moved"'s managed memory to *this. Does not throw. </purpose></copy-assignment>
</class><typedef name="managed_external_buffer"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_external_buffer">basic_managed_external_buffer</classname> of narrow characters </para></description><type><classname>basic_managed_external_buffer</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>null_mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef name="wmanaged_external_buffer"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_external_buffer">basic_managed_external_buffer</classname> of wide characters </para></description><type><classname>basic_managed_external_buffer</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>null_mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/managed_heap_memory.hpp">
<para>Describes a named heap memory allocation user class. </para><namespace name="boost">
<namespace name="interprocess">
<class name="basic_managed_heap_memory"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic heap memory named object creation class. Initializes the heap memory segment. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; </para></description><typedef name="size_type"><type>base_t::size_type</type></typedef>
<method-group name="public member functions">
<method name="grow"><type>bool</type><parameter name="extra_bytes"><paramtype>size_type</paramtype></parameter><description><para>Tries to resize internal heap memory so that we have room for more objects. WARNING: If memory is reallocated, all the objects will be binary-copied to the new buffer. To be able to use this function, all pointers constructed in this buffer must be offset pointers. Otherwise, the result is undefined. Returns true if the growth has been successful, so you will have some extra bytes to allocate new objects. If returns false, the heap allocation has failed. </para></description></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>basic_managed_heap_memory</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed heap memories managed by *this and other. Never throws. </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor>
<destructor><description><para>Destructor. Liberates the heap memory holding the managed data. Never throws. </para></description></destructor>
<constructor><parameter name="size"><paramtype>size_type</paramtype></parameter><description><para>Creates heap memory and initializes the segment manager. This can throw. </para></description></constructor>
<constructor cv="noexcept"><parameter name="moved"><paramtype><classname>basic_managed_heap_memory</classname> &amp;&amp;</paramtype></parameter><purpose>Moves the ownership of "moved"'s managed memory to *this. Does not throw. </purpose></constructor>
<copy-assignment cv="noexcept"><type><classname>basic_managed_heap_memory</classname> &amp;</type><parameter name="moved"><paramtype><classname>basic_managed_heap_memory</classname> &amp;&amp;</paramtype></parameter><purpose>Moves the ownership of "moved"'s managed memory to *this. Does not throw. </purpose></copy-assignment>
</class><typedef name="managed_heap_memory"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_heap_memory">basic_managed_heap_memory</classname> of narrow characters </para></description><type><classname>basic_managed_heap_memory</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>null_mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef name="wmanaged_heap_memory"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_heap_memory">basic_managed_heap_memory</classname> of wide characters </para></description><type><classname>basic_managed_heap_memory</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>null_mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/managed_mapped_file.hpp">
<namespace name="boost">
<namespace name="interprocess">
<class name="basic_managed_mapped_file"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic mapped file named object creation class. Initializes the mapped file. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; </para></description><typedef name="size_type"><description><para>Unsigned integral type enough to represent the size of a <classname alt="boost::interprocess::basic_managed_mapped_file">basic_managed_mapped_file</classname>. </para></description><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>basic_managed_mapped_file</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed mapped memories managed by *this and other. Never throws. </para></description></method>
<method name="flush"><type>bool</type><description><para>Flushes cached data to file. Never throws </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Creates mapped file and creates and places the segment manager. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates mapped file and creates and places the segment manager. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates mapped file and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager in copy_on_write mode. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager in read-only mode. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates mapped file and creates and places the segment manager. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates mapped file and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager in copy_on_write mode. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created mapped file and its segment manager in read-only mode. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor cv="noexcept"><parameter name="moved"><paramtype><classname>basic_managed_mapped_file</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></constructor>
<copy-assignment cv="noexcept"><type><classname>basic_managed_mapped_file</classname> &amp;</type><parameter name="moved"><paramtype><classname>basic_managed_mapped_file</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></copy-assignment>
<destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor>
<method-group name="public static functions">
<method name="grow" specifiers="static"><type>bool</type><parameter name="filename"><paramtype>const char *</paramtype></parameter><parameter name="extra_bytes"><paramtype>size_type</paramtype></parameter><description><para>Tries to resize mapped file so that we have room for more objects.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file </para></description></method>
<method name="shrink_to_fit" specifiers="static"><type>bool</type><parameter name="filename"><paramtype>const char *</paramtype></parameter><description><para>Tries to resize mapped file to minimized the size of the file.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file </para></description></method>
<method name="grow" specifiers="static"><type>bool</type><parameter name="filename"><paramtype>const wchar_t *</paramtype></parameter><parameter name="extra_bytes"><paramtype>size_type</paramtype></parameter><description><para>Tries to resize mapped file so that we have room for more objects.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
<method name="shrink_to_fit" specifiers="static"><type>bool</type><parameter name="filename"><paramtype>const wchar_t *</paramtype></parameter><description><para>Tries to resize mapped file to minimized the size of the file.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class><typedef name="managed_mapped_file"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_mapped_file">basic_managed_mapped_file</classname> of narrow characters </para></description><type><classname>basic_managed_mapped_file</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef name="wmanaged_mapped_file"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_mapped_file">basic_managed_mapped_file</classname> of wide characters </para></description><type><classname>basic_managed_mapped_file</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/managed_shared_memory.hpp">
<namespace name="boost">
<namespace name="interprocess">
<class name="basic_managed_shared_memory"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic shared memory named object creation class. Initializes the shared memory segment. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; </para></description><method-group name="public member functions">
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>basic_managed_shared_memory</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed shared memories managed by *this and other. Never throws. </para></description></method>
</method-group>
<destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor>
<constructor><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates shared memory and creates and places the segment manager. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates shared memory and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. in copy_on_write mode. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. in read-only mode. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates shared memory and creates and places the segment manager. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates shared memory and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. in copy_on_write mode. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. in read-only mode. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. This can throw.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name="moved"><paramtype><classname>basic_managed_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></constructor>
<copy-assignment><type><classname>basic_managed_shared_memory</classname> &amp;</type><parameter name="moved"><paramtype><classname>basic_managed_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></copy-assignment>
<method-group name="public static functions">
<method name="grow" specifiers="static"><type>bool</type><parameter name="shmname"><paramtype>const char *</paramtype></parameter><parameter name="extra_bytes"><paramtype>size_type</paramtype></parameter><description><para>Tries to resize the managed shared memory object so that we have room for more objects.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file </para></description></method>
<method name="shrink_to_fit" specifiers="static"><type>bool</type><parameter name="shmname"><paramtype>const char *</paramtype></parameter><description><para>Tries to resize the managed shared memory to minimized the size of the file.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file </para></description></method>
<method name="grow" specifiers="static"><type>bool</type><parameter name="shmname"><paramtype>const wchar_t *</paramtype></parameter><parameter name="extra_bytes"><paramtype>size_type</paramtype></parameter><description><para>Tries to resize the managed shared memory object so that we have room for more objects.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
<method name="shrink_to_fit" specifiers="static"><type>bool</type><parameter name="shmname"><paramtype>const wchar_t *</paramtype></parameter><description><para>Tries to resize the managed shared memory to minimized the size of the file.</para><para>This function is not synchronized so no other thread or process should be reading or writing the file</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class><typedef name="managed_shared_memory"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_shared_memory">basic_managed_shared_memory</classname> of narrow characters </para></description><type><classname>basic_managed_shared_memory</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef name="wmanaged_shared_memory"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_shared_memory">basic_managed_shared_memory</classname> of wide characters </para></description><type><classname>basic_managed_shared_memory</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef name="fixed_managed_shared_memory"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_shared_memory">basic_managed_shared_memory</classname> of narrow characters to be placed in a fixed address </para></description><type><classname>basic_managed_shared_memory</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname>, void * &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef name="wfixed_managed_shared_memory"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_shared_memory">basic_managed_shared_memory</classname> of narrow characters to be placed in a fixed address </para></description><type><classname>basic_managed_shared_memory</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname>, void * &gt;,<classname>iset_index</classname> &gt;</type></typedef>

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/managed_windows_shared_memory.hpp">
<namespace name="boost">
<namespace name="interprocess">
<class name="basic_managed_windows_shared_memory"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic managed windows shared memory creation class. Initializes the shared memory segment. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; Unlike <classname alt="boost::interprocess::basic_managed_shared_memory">basic_managed_shared_memory</classname>, it has no kernel persistence and the shared memory is destroyed when all processes destroy all their <classname alt="boost::interprocess::windows_shared_memory">windows_shared_memory</classname> objects and mapped regions for the same shared memory or the processes end/crash.</para><para>Warning: <classname alt="boost::interprocess::basic_managed_windows_shared_memory">basic_managed_windows_shared_memory</classname> and <classname alt="boost::interprocess::basic_managed_shared_memory">basic_managed_shared_memory</classname> can't communicate between them. </para></description><typedef name="size_type"><type>base_t::size_type</type></typedef>
<method-group name="public member functions">
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>basic_managed_windows_shared_memory</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed mapped memories managed by *this and other. Never throws. </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates shared memory and creates and places the segment manager. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates shared memory and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager in copy_on_write mode. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager in read-only mode. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates shared memory and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_copy_on_write_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager in copy_on_write mode. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager in read-only mode. This can throw. </para></description></constructor>
<constructor cv="noexcept"><parameter name="moved"><paramtype><classname>basic_managed_windows_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></constructor>
<copy-assignment cv="noexcept"><type><classname>basic_managed_windows_shared_memory</classname> &amp;</type><parameter name="moved"><paramtype><classname>basic_managed_windows_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></copy-assignment>
<destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. All mapped regions are still valid after destruction. When all mapped regions and <classname alt="boost::interprocess::basic_managed_windows_shared_memory">basic_managed_windows_shared_memory</classname> objects referring the shared memory are destroyed, the operating system will destroy the shared memory. </para></description></destructor>
</class><typedef name="managed_windows_shared_memory"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_windows_shared_memory">basic_managed_windows_shared_memory</classname> of narrow characters </para></description><type><classname>basic_managed_windows_shared_memory</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef name="wmanaged_windows_shared_memory"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_windows_shared_memory">basic_managed_windows_shared_memory</classname> of wide characters </para></description><type><classname>basic_managed_windows_shared_memory</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/managed_xsi_shared_memory.hpp">
<namespace name="boost">
<namespace name="interprocess">
<class name="basic_managed_xsi_shared_memory"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="AllocationAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><description><para>A basic X/Open System Interface (XSI) shared memory named object creation class. Initializes the shared memory segment. Inherits all basic functionality from basic_managed_memory_impl&lt;CharType, AllocationAlgorithm, IndexType&gt; </para></description><typedef name="size_type"><type>base_t::size_type</type></typedef>
<method-group name="public member functions">
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>basic_managed_xsi_shared_memory</classname> &amp;</paramtype></parameter><description><para>Swaps the ownership of the managed shared memories managed by *this and other. Never throws. </para></description></method>
<method name="get_shmid" cv="const noexcept"><type>int</type></method>
</method-group>
<destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor>
<constructor cv="noexcept"><description><para>Default constructor. Does nothing. Useful in combination with move semantics </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates shared memory and creates and places the segment manager. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates shared memory and creates and places the segment manager if segment was not created. If segment was created it connects to the segment. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_read_only_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. in read-only mode. This can throw. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><parameter name="addr"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Connects to a created shared memory and its segment manager. This can throw. </para></description></constructor>
<constructor cv="noexcept"><parameter name="moved"><paramtype><classname>basic_managed_xsi_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></constructor>
<copy-assignment cv="noexcept"><type><classname>basic_managed_xsi_shared_memory</classname> &amp;</type><parameter name="moved"><paramtype><classname>basic_managed_xsi_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s managed memory to *this. Does not throw </para></description></copy-assignment>
<method-group name="public static functions">
<method name="remove" specifiers="static"><type>bool</type><parameter name="shmid"><paramtype>int</paramtype></parameter><description><para>Erases a XSI shared memory object identified by shmid from the system. Returns false on error. Never throws </para></description></method>
</method-group>
</class><typedef name="managed_xsi_shared_memory"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_xsi_shared_memory">basic_managed_xsi_shared_memory</classname> of narrow characters </para></description><type><classname>basic_managed_xsi_shared_memory</classname>&lt; char,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>
<typedef name="wmanaged_xsi_shared_memory"><description><para>Typedef for a default <classname alt="boost::interprocess::basic_managed_xsi_shared_memory">basic_managed_xsi_shared_memory</classname> of wide characters </para></description><type><classname>basic_managed_xsi_shared_memory</classname>&lt; wchar_t,<classname>rbtree_best_fit</classname>&lt; <classname>mutex_family</classname> &gt;,<classname>iset_index</classname> &gt;</type></typedef>

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/mapped_region.hpp">
<para>Describes mapped region class </para><namespace name="boost">
<namespace name="interprocess">
<class name="mapped_region"><description><para>The <classname alt="boost::interprocess::mapped_region">mapped_region</classname> class represents a portion or region created from a memory_mappable object.</para><para>The OS can map a region bigger than the requested one, as region must be multiple of the page size, but <classname alt="boost::interprocess::mapped_region">mapped_region</classname> will always refer to the region specified by the user. </para></description><enum name="advice_types"><enumvalue name="advice_normal"><description><para>Specifies that the application has no advice to give on its behavior with respect to the region. It is the default characteristic if no advice is given for a range of memory. </para></description></enumvalue><enumvalue name="advice_sequential"><description><para>Specifies that the application expects to access the region sequentially from lower addresses to higher addresses. The implementation can lower the priority of preceding pages within the region once a page have been accessed. </para></description></enumvalue><enumvalue name="advice_random"><description><para>Specifies that the application expects to access the region in a random order, and prefetching is likely not advantageous. </para></description></enumvalue><enumvalue name="advice_willneed"><description><para>Specifies that the application expects to access the region in the near future. The implementation can prefetch pages of the region. </para></description></enumvalue><enumvalue name="advice_dontneed"><description><para>Specifies that the application expects that it will not access the region in the near future. The implementation can unload pages within the range to save system resources. </para></description></enumvalue><description><para>This enum specifies region usage behaviors that an application can specify to the mapped region implementation. </para></description></enum>
<method-group name="public member functions">
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>mapped_region</classname> &amp;</paramtype></parameter><description><para>Swaps the <classname alt="boost::interprocess::mapped_region">mapped_region</classname> with another mapped region </para></description></method>
<method name="get_size" cv="const noexcept"><type>std::size_t</type><purpose>Returns the size of the mapping. Never throws. </purpose></method>
<method name="get_address" cv="const noexcept"><type>void *</type><description><para>Returns the base address of the mapping. Never throws. </para></description></method>
<method name="get_mode" cv="const noexcept"><type>mode_t</type><description><para>Returns the mode of the mapping used to construct the mapped region. Never throws. </para></description></method>
<method name="flush"><type>bool</type><parameter name="mapping_offset"><paramtype>std::size_t</paramtype><default>0</default></parameter><parameter name="numbytes"><paramtype>std::size_t</paramtype><default>0</default></parameter><parameter name="async"><paramtype>bool</paramtype><default>true</default></parameter><description><para>Flushes to the disk a byte range within the mapped memory. If 'async' is true, the function will return before flushing operation is completed If 'async' is false, function will return once data has been written into the underlying device (i.e., in mapped files OS cached information is written to disk). Never throws. Returns false if operation could not be performed. </para></description></method>
<method name="shrink_by"><type>bool</type><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><parameter name="from_back"><paramtype>bool</paramtype><default>true</default></parameter><description><para>Shrinks current mapped region. If after shrinking there is no longer need for a previously mapped memory page, accessing that page can trigger a segmentation fault. Depending on the OS, this operation might fail (XSI shared memory), it can decommit storage and free a portion of the virtual address space (e.g.POSIX) or this function can release some physical memory without freeing any virtual address space(Windows). Returns true on success. Never throws. </para></description></method>
<method name="advise"><type>bool</type><parameter name="advise"><paramtype>advice_types</paramtype></parameter><description><para>Advises the implementation on the expected behavior of the application with respect to the data in the region. The implementation may use this information to optimize handling of the region data. This function has no effect on the semantics of access to memory in the region, although it may affect the performance of access. If the advise type is not known to the implementation, the function returns false. True otherwise. </para></description></method>
</method-group>
<constructor><template>
          <template-type-parameter name="MemoryMappable"/>
        </template><parameter name="mapping"><paramtype>const MemoryMappable &amp;</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="offset"><paramtype>offset_t</paramtype><default>0</default></parameter><parameter name="size"><paramtype>std::size_t</paramtype><default>0</default></parameter><parameter name="address"><paramtype>const void *</paramtype><default>0</default></parameter><parameter name="map_options"><paramtype>map_options_t</paramtype><default>default_map_options</default></parameter><description><para>Creates a mapping region of the mapped memory "mapping", starting in offset "offset", and the mapping's size will be "size". The mapping can be opened for read only, read-write or copy-on-write.</para><para>If an address is specified, both the offset and the address must be multiples of the page size.</para><para>The map is created using "default_map_options". This flag is OS dependant and it should not be changed unless the user needs to specify special options.</para><para>In Windows systems "map_options" is a DWORD value passed as "dwDesiredAccess" to "MapViewOfFileEx". If "default_map_options" is passed it's initialized to zero. "map_options" is XORed with FILE_MAP_[COPY|READ|WRITE].</para><para>In UNIX systems and POSIX mappings "map_options" is an int value passed as "flags" to "mmap". If "default_map_options" is specified it's initialized to MAP_NOSYNC if that option exists and to zero otherwise. "map_options" XORed with MAP_PRIVATE or MAP_SHARED.</para><para>In UNIX systems and XSI mappings "map_options" is an int value passed as "shmflg" to "shmat". If "default_map_options" is specified it's initialized to zero. "map_options" is XORed with SHM_RDONLY if needed.</para><para>The OS could allocate more pages than size/page_size(), but get_address() will always return the address passed in this function (if not null) and get_size() will return the specified size. </para></description></constructor>
<constructor cv="noexcept"><description><para>Default constructor. Address will be 0 (nullptr). Size will be 0. Does not throw </para></description></constructor>
<constructor cv="noexcept"><parameter name="other"><paramtype><classname>mapped_region</classname> &amp;&amp;</paramtype></parameter><description><para>Move constructor. *this will be constructed taking ownership of "other"'s region and "other" will be left in default constructor state. </para></description></constructor>
<destructor><description><para>Destroys the mapped region. Does not throw </para></description></destructor>
<copy-assignment cv="noexcept"><type><classname>mapped_region</classname> &amp;</type><parameter name="other"><paramtype><classname>mapped_region</classname> &amp;&amp;</paramtype></parameter><description><para>Move assignment. If *this owns a memory mapped region, it will be destroyed and it will take ownership of "other"'s memory mapped region. </para></description></copy-assignment>
<method-group name="public static functions">
<method name="get_page_size" cv="noexcept" specifiers="static"><type>std::size_t</type><description><para>Returns the size of the page. This size is the minimum memory that will be used by the system when mapping a memory mappable source and will restrict the address and the offset to map. </para></description></method>
</method-group>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/mem_algo/rbtree_best_fit.hpp">
<para>Describes a best-fit algorithm based in an intrusive red-black tree used to allocate objects in shared memory. This class is intended as a base class for single segment and multi-segment implementations. </para><namespace name="boost">
<namespace name="interprocess">
<class name="rbtree_best_fit"><template>
      <template-type-parameter name="MutexFamily"/>
      <template-type-parameter name="VoidPointer"/>
      <template-nontype-parameter name="MemAlignment"><type>std::size_t</type></template-nontype-parameter>
    </template><description><para>This class implements an algorithm that stores the free nodes in a red-black tree to have logarithmic search/insert times. </para></description><typedef name="mutex_family"><purpose>Shared mutex family used for the rest of the Interprocess framework. </purpose><type>MutexFamily</type></typedef>
<typedef name="void_pointer"><purpose>Pointer type to be used with the rest of the Interprocess framework. </purpose><type>VoidPointer</type></typedef>
<typedef name="multiallocation_chain"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="difference_type"><type>boost::intrusive::pointer_traits&lt; char_ptr &gt;::difference_type</type></typedef>
<typedef name="size_type"><type>boost::container::dtl::make_unsigned&lt; difference_type &gt;::type</type></typedef>
<data-member name="PayloadPerAllocation" specifiers="static"><type>const size_type</type></data-member>
<method-group name="public member functions">
<method name="allocate"><type>void *</type><parameter name="nbytes"><paramtype>size_type</paramtype></parameter><purpose>Allocates bytes, returns 0 if there is not more memory. </purpose></method>
<method name="deallocate"><type>void</type><parameter name="addr"><paramtype>void *</paramtype></parameter><purpose>Deallocates previously allocated bytes. </purpose></method>
<method name="get_size" cv="const"><type>size_type</type><purpose>Returns the size of the memory segment. </purpose></method>
<method name="get_free_memory" cv="const"><type>size_type</type><purpose>Returns the number of free bytes of the segment. </purpose></method>
<method name="zero_free_memory"><type>void</type><description><para>Initializes to zero all the memory that's not in use. This function is normally used for security reasons. </para></description></method>
<method name="grow"><type>void</type><parameter name="extra_size"><paramtype>size_type</paramtype></parameter><description><para>Increases managed memory in extra_size bytes more </para></description></method>
<method name="shrink_to_fit"><type>void</type><purpose>Decreases managed memory as much as possible. </purpose></method>
<method name="all_memory_deallocated"><type>bool</type><purpose>Returns true if all allocated memory has been deallocated. </purpose></method>
<method name="check_sanity"><type>bool</type><description><para>Makes an internal sanity check and returns true if success </para></description></method>
<method name="allocation_command"><type>T *</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>T *&amp;</paramtype></parameter></method>
<method name="raw_allocation_command"><type>void *</type><parameter name="command"><paramtype>boost::interprocess::allocation_type</paramtype></parameter><parameter name="limit_object"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse_ptr"><paramtype>void *&amp;</paramtype></parameter><parameter name="sizeof_object"><paramtype>size_type</paramtype><default>1</default></parameter></method>
<method name="size" cv="const"><type>size_type</type><parameter name="ptr"><paramtype>const void *</paramtype></parameter><purpose>Returns the size of the buffer previously allocated pointed by ptr. </purpose></method>
<method name="allocate_aligned"><type>void *</type><parameter name="nbytes"><paramtype>size_type</paramtype></parameter><parameter name="alignment"><paramtype>size_type</paramtype></parameter><description><para>Allocates aligned bytes, returns 0 if there is not more memory. Alignment must be power of 2 </para></description></method>
</method-group>
<constructor><parameter name="size"><paramtype>size_type</paramtype></parameter><parameter name="extra_hdr_bytes"><paramtype>size_type</paramtype></parameter><description><para>Constructor. "size" is the total size of the managed memory segment, "extra_hdr_bytes" indicates the extra bytes beginning in the sizeof(rbtree_best_fit) offset that the allocator should not use at all. </para></description></constructor>
<destructor><purpose>Destructor. </purpose></destructor>
<method-group name="public static functions">
<method name="get_min_size" specifiers="static"><type>size_type</type><parameter name="extra_hdr_bytes"><paramtype>size_type</paramtype></parameter><purpose>Obtains the minimum size needed by the algorithm. </purpose></method>
</method-group>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/mem_algo/simple_seq_fit.hpp">
<para>Describes sequential fit algorithm used to allocate objects in shared memory. </para><namespace name="boost">
<namespace name="interprocess">
<class name="simple_seq_fit"><template>
      <template-type-parameter name="MutexFamily"/>
      <template-type-parameter name="VoidPointer"/>
    </template><description><para>This class implements the simple sequential fit algorithm with a simply linked list of free buffers. </para></description><typedef name="size_type"><type>base_t::size_type</type></typedef>
<method-group name="public member functions">
</method-group>
<constructor><parameter name="segment_size"><paramtype>size_type</paramtype></parameter><parameter name="extra_hdr_bytes"><paramtype>size_type</paramtype></parameter><description><para>Constructor. "size" is the total size of the managed memory segment, "extra_hdr_bytes" indicates the extra bytes beginning in the sizeof(simple_seq_fit) offset that the allocator should not use at all. </para></description></constructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/offset_ptr.hpp">
<para>Describes a smart pointer that stores the offset between this pointer and target pointee, called offset_ptr. </para><namespace name="boost">
<namespace name="interprocess">
<class name="offset_ptr"><template>
      <template-type-parameter name="PointedType"><purpose><para>The type of the pointee. </para></purpose></template-type-parameter>
      <template-type-parameter name="DifferenceType"><purpose><para>A signed integer type that can represent the arithmetic operations on the pointer </para></purpose></template-type-parameter>
      <template-type-parameter name="OffsetType"><purpose><para>An unsigned integer type that can represent the distance between two pointers reinterpret_cast-ed as unsigned integers. This type should be at least of the same size of std::uintptr_t. In some systems it's possible to communicate between 32 and 64 bit processes using 64 bit offsets. </para></purpose></template-type-parameter>
      <template-nontype-parameter name="OffsetAlignment"><type>std::size_t</type><purpose><para>Alignment of the OffsetType stored inside. In some systems might be necessary to align it to 64 bits in order to communicate 32 and 64 bit processes using 64 bit offsets.</para></purpose></template-nontype-parameter>
    </template><description><para>A smart pointer that stores the offset between between the pointer and the the object it points. This allows offset allows special properties, since the pointer is independent from the address of the pointee, if the pointer and the pointee are still separated by the same offset. This feature converts <classname alt="boost::interprocess::offset_ptr">offset_ptr</classname> in a smart pointer that can be placed in shared memory and memory mapped files mapped in different addresses in every process.</para><para>
b&gt;Note: <classname alt="boost::interprocess::offset_ptr">offset_ptr</classname> uses implementation defined properties, present in most platforms, for performance reasons:<itemizedlist>
<listitem><para>Assumes that OffsetType representation of nullptr is (OffsetType)zero.</para>
</listitem><listitem><para>Assumes that incrementing a OffsetType obtained from a pointer is equivalent to incrementing the pointer and then converting it back to OffsetType. </para>
</listitem></itemizedlist>
</para></description><typedef name="element_type"><type>PointedType</type></typedef>
<typedef name="pointer"><type>PointedType *</type></typedef>
<typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="value_type"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="difference_type"><type>DifferenceType</type></typedef>
<typedef name="iterator_category"><type>std::random_access_iterator_tag</type></typedef>
<typedef name="offset_type"><type>OffsetType</type></typedef>
<typedef name="rebind"><description><para>Compatibility with pointer_traits </para></description><type><classname>offset_ptr</classname>&lt; U, DifferenceType, OffsetType, OffsetAlignment &gt;</type></typedef>
<method-group name="public member functions">
<method name="get" cv="const noexcept"><type>pointer</type><description><para>Obtains raw pointer from offset. Never throws. </para></description></method>
<method name="get_offset" cv="const noexcept"><type>offset_type</type></method>
<method name="operator-&gt;" cv="const noexcept"><type>pointer</type><description><para>Pointer-like -&gt; operator. It can return 0 pointer. Never throws. </para></description></method>
<method name="operator *" cv="const noexcept"><type>reference</type><description><para>Dereferencing operator, if it is a null <classname alt="boost::interprocess::offset_ptr">offset_ptr</classname> behavior is undefined. Never throws. </para></description></method>
<method name="operator[]" cv="const noexcept"><type>reference</type><parameter name="idx"><paramtype>difference_type</paramtype></parameter><description><para>Indexing operator. Never throws. </para></description></method>
<method name="operator+=" cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><parameter name="offset"><paramtype>difference_type</paramtype></parameter><description><para><classname alt="boost::interprocess::offset_ptr">offset_ptr</classname> += difference_type. Never throws. </para></description></method>
<method name="operator-=" cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><parameter name="offset"><paramtype>difference_type</paramtype></parameter><description><para><classname alt="boost::interprocess::offset_ptr">offset_ptr</classname> -= difference_type. Never throws. </para></description></method>
<method name="operator++" cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><parameter name=""><paramtype>void</paramtype></parameter><description><para>++<classname alt="boost::interprocess::offset_ptr">offset_ptr</classname>. Never throws. </para></description></method>
<method name="operator++" cv="noexcept"><type><classname>offset_ptr</classname></type><parameter name=""><paramtype>int</paramtype></parameter><description><para>offset_ptr++. Never throws. </para></description></method>
<method name="operator--" cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><parameter name=""><paramtype>void</paramtype></parameter><description><para>–<classname alt="boost::interprocess::offset_ptr">offset_ptr</classname>. Never throws. </para></description></method>
<method name="operator--" cv="noexcept"><type><classname>offset_ptr</classname></type><parameter name=""><paramtype>int</paramtype></parameter><description><para><classname alt="boost::interprocess::offset_ptr">offset_ptr</classname>–. Never throws. </para></description></method>
<method name="conversion-operator" cv="const noexcept" specifiers="explicit"><type>bool</type><description><para>safe bool conversion operator. Never throws. </para></description></method>
<method name="operator!" cv="const noexcept"><type>bool</type><description><para>Not operator. Not needed in theory, but improves portability. Never throws </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Default constructor (null pointer). Never throws. </para></description></constructor>
<constructor cv="noexcept"><parameter name="ptr"><paramtype>pointer</paramtype></parameter><description><para>Constructor from raw pointer (allows "0" pointer conversion). Never throws. </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr"><paramtype>T *</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Constructor from other pointer. Never throws. </para></description></constructor>
<constructor cv="noexcept"><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname> &amp;</paramtype></parameter><description><para>Constructor from other <classname alt="boost::interprocess::offset_ptr">offset_ptr</classname> Never throws. </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname>&lt; T2, DifferenceType, OffsetType, OffsetAlignment &gt; &amp;</paramtype></parameter><description><para>Constructor from other <classname alt="boost::interprocess::offset_ptr">offset_ptr</classname>. Only takes part in overload resolution if T2* is convertible to PointedType*. Never throws. </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname>&lt; T2, DifferenceType, OffsetType, OffsetAlignment &gt; &amp;</paramtype></parameter><description><para>Constructor from other <classname alt="boost::interprocess::offset_ptr">offset_ptr</classname>. Only takes part in overload resolution if PointedType* is constructible from T2* other than via a conversion (e.g. cast to a derived class). Never throws. </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Emulates static_cast operator. Never throws. </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Emulates const_cast operator. Never throws. </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Emulates dynamic_cast operator. Never throws. </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><description><para>Emulates reinterpret_cast operator. Never throws. </para></description></constructor>
<copy-assignment cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><parameter name="from"><paramtype>pointer</paramtype></parameter><description><para>Assignment from pointer (saves extra conversion). Never throws. </para></description></copy-assignment>
<copy-assignment cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname> &amp;</paramtype></parameter><description><para>Assignment from other <classname alt="boost::interprocess::offset_ptr">offset_ptr</classname>. Never throws. </para></description></copy-assignment>
<copy-assignment cv="noexcept"><type><classname>offset_ptr</classname> &amp;</type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname>&lt; T2, DifferenceType, OffsetType, OffsetAlignment &gt; &amp;</paramtype></parameter><description><para>Assignment from related <classname alt="boost::interprocess::offset_ptr">offset_ptr</classname>. If pointers of pointee types are assignable, offset_ptrs will be assignable. Never throws. </para></description></copy-assignment>
<method-group name="public static functions">
<method name="pointer_to" cv="noexcept" specifiers="static"><type><classname>offset_ptr</classname></type><parameter name="r"><paramtype>reference</paramtype></parameter><description><para>Compatibility with pointer_traits </para></description></method>
</method-group>
<method-group name="friend functions">
<method name="operator+" cv="noexcept"><type>friend <classname>offset_ptr</classname></type><parameter name="diff"><paramtype>difference_type</paramtype></parameter><parameter name="right"><paramtype><classname>offset_ptr</classname></paramtype></parameter><description><para>difference_type + <classname alt="boost::interprocess::offset_ptr">offset_ptr</classname> operation </para></description></method>
<method name="operator+" cv="noexcept"><type>friend <classname>offset_ptr</classname></type><parameter name="left"><paramtype><classname>offset_ptr</classname></paramtype></parameter><parameter name="diff"><paramtype>difference_type</paramtype></parameter><description><para><classname alt="boost::interprocess::offset_ptr">offset_ptr</classname> + difference_type operation </para></description></method>
<method name="operator-" cv="noexcept"><type>friend <classname>offset_ptr</classname></type><parameter name="left"><paramtype><classname>offset_ptr</classname></paramtype></parameter><parameter name="diff"><paramtype>difference_type</paramtype></parameter><description><para><classname alt="boost::interprocess::offset_ptr">offset_ptr</classname> - diff operation </para></description></method>
<method name="operator-" cv="noexcept"><type>friend <classname>offset_ptr</classname></type><parameter name="diff"><paramtype>difference_type</paramtype></parameter><parameter name="right"><paramtype><classname>offset_ptr</classname></paramtype></parameter><description><para><classname alt="boost::interprocess::offset_ptr">offset_ptr</classname> - diff operation </para></description></method>
<method name="operator-" cv="noexcept"><type>friend difference_type</type><parameter name="pt"><paramtype>const <classname>offset_ptr</classname> &amp;</paramtype></parameter><parameter name="pt2"><paramtype>const <classname>offset_ptr</classname> &amp;</paramtype></parameter><description><para><classname alt="boost::interprocess::offset_ptr">offset_ptr</classname> - <classname alt="boost::interprocess::offset_ptr">offset_ptr</classname> operation </para></description></method>
</method-group>
<method-group name="private member functions">
<method name="assign" cv="noexcept"><type>void</type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname>&lt; T2, DifferenceType, OffsetType, OffsetAlignment &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method>
<method name="assign" cv="noexcept"><type>void</type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="ptr"><paramtype>const <classname>offset_ptr</classname>&lt; T2, DifferenceType, OffsetType, OffsetAlignment &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method>
</method-group>
</class><function name="operator&lt;&lt;"><type>std::basic_ostream&lt; E, T &gt; &amp;</type><template>
          <template-type-parameter name="E"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="W"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
          <template-nontype-parameter name="Z"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; E, T &gt; &amp;</paramtype></parameter><parameter name="p"><paramtype><classname>offset_ptr</classname>&lt; W, X, Y, Z &gt; const &amp;</paramtype></parameter><description><para>operator&lt;&lt; for offset ptr </para></description></function>
<function name="operator&gt;&gt;"><type>std::basic_istream&lt; E, T &gt; &amp;</type><template>
          <template-type-parameter name="E"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="W"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
          <template-nontype-parameter name="Z"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="is"><paramtype>std::basic_istream&lt; E, T &gt; &amp;</paramtype></parameter><parameter name="p"><paramtype><classname>offset_ptr</classname>&lt; W, X, Y, Z &gt; &amp;</paramtype></parameter><description><para>operator&gt;&gt; for offset ptr </para></description></function>
<function name="static_pointer_cast"><type><classname>boost::interprocess::offset_ptr</classname>&lt; T1, P1, O1, A1 &gt;</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="P1"/>
          <template-type-parameter name="O1"/>
          <template-nontype-parameter name="A1"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>boost::interprocess::offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><purpose>Simulation of static_cast between pointers. Never throws. </purpose></function>
<function name="const_pointer_cast"><type><classname>boost::interprocess::offset_ptr</classname>&lt; T1, P1, O1, A1 &gt;</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="P1"/>
          <template-type-parameter name="O1"/>
          <template-nontype-parameter name="A1"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>boost::interprocess::offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><purpose>Simulation of const_cast between pointers. Never throws. </purpose></function>
<function name="dynamic_pointer_cast"><type><classname>boost::interprocess::offset_ptr</classname>&lt; T1, P1, O1, A1 &gt;</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="P1"/>
          <template-type-parameter name="O1"/>
          <template-nontype-parameter name="A1"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>boost::interprocess::offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><purpose>Simulation of dynamic_cast between pointers. Never throws. </purpose></function>
<function name="reinterpret_pointer_cast"><type><classname>boost::interprocess::offset_ptr</classname>&lt; T1, P1, O1, A1 &gt;</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="P1"/>
          <template-type-parameter name="O1"/>
          <template-nontype-parameter name="A1"><type>std::size_t</type></template-nontype-parameter>
          <template-type-parameter name="T2"/>
          <template-type-parameter name="P2"/>
          <template-type-parameter name="O2"/>
          <template-nontype-parameter name="A2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="r"><paramtype>const <classname>boost::interprocess::offset_ptr</classname>&lt; T2, P2, O2, A2 &gt; &amp;</paramtype></parameter><purpose>Simulation of reinterpret_cast between pointers. Never throws. </purpose></function>











































</namespace>
</namespace>
</header>
<header name="boost/interprocess/permissions.hpp">
<para>Describes permissions class </para><namespace name="boost">
<namespace name="interprocess">
<class name="permissions"><description><para>The permissions class represents permissions to be set to shared memory or files, that can be constructed form usual permission representations: a SECURITY_ATTRIBUTES pointer in windows or ORed rwx chmod integer in UNIX. </para></description><method-group name="public member functions">
<method name="set_default" cv="noexcept"><type>void</type><description><para>Sets permissions to default values: A null security attributes pointer for windows or 0644 for UNIX. </para></description></method>
<method name="set_unrestricted" cv="noexcept"><type>void</type><description><para>Sets permissions to unrestricted access: A null DACL for windows or 0666 for UNIX. </para></description></method>
<method name="set_permissions" cv="noexcept"><type>void</type><parameter name="perm"><paramtype>os_permissions_type</paramtype></parameter><description><para>Sets permissions from a user provided os-dependent permissions. </para></description></method>
<method name="get_permissions" cv="const noexcept"><type>os_permissions_type</type><description><para>Returns stored os-dependent permissions </para></description></method>
</method-group>
<constructor cv="noexcept"><parameter name="type"><paramtype>os_permissions_type</paramtype></parameter><description><para>Constructs a permissions object from a user provided os-dependent permissions. </para></description></constructor>
<constructor cv="noexcept"><description><para>Constructs a default permissions object: A null security attributes pointer for windows or 0644 for UNIX. </para></description></constructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/segment_manager.hpp">
<para>Describes the object placed in a memory segment that provides named object allocation capabilities for single-segment and multi-segment allocations. </para><namespace name="boost">
<namespace name="interprocess">
<class name="segment_manager"><template>
      <template-type-parameter name="CharType"/>
      <template-type-parameter name="MemoryAlgorithm"/>
      <template-nontype-parameter name="IndexType"><type>template&lt; class IndexConfig &gt; class</type></template-nontype-parameter>
    </template><inherit access="public">boost::interprocess::segment_manager_base&lt; MemoryAlgorithm &gt;</inherit><description><para>This object is placed in the beginning of memory segment and implements the allocation (named or anonymous) of portions of the segment. This object contains two indexes that maintain an association between a name and a portion of the segment.</para><para>The first index contains the mappings for normal named objects using the char type specified in the template parameter.</para><para>The second index contains the association for unique instances. The key will be the const char * returned from type_info.name() function for the unique type to be constructed.</para><para>segment_manager&lt;CharType, MemoryAlgorithm, IndexType&gt; inherits publicly from segment_manager_base&lt;MemoryAlgorithm&gt; and inherits from it many public functions related to anonymous object and raw memory allocation. See <classname alt="boost::interprocess::segment_manager_base">segment_manager_base</classname> reference to know about those functions. </para></description><struct name="allocator"><template>
      <template-type-parameter name="T"/>
    </template><description><para>This is the default allocator to allocate types T from this managed segment </para></description><typedef name="type"><type><classname>boost::interprocess::allocator</classname>&lt; T, <classname>segment_manager</classname> &gt;</type></typedef>
</struct><struct name="deleter"><template>
      <template-type-parameter name="T"/>
    </template><description><para>This is the default deleter to delete types T from this managed segment. </para></description><typedef name="type"><type><classname>boost::interprocess::deleter</classname>&lt; T, <classname>segment_manager</classname> &gt;</type></typedef>
</struct><typedef name="memory_algorithm"><type>MemoryAlgorithm</type></typedef>
<typedef name="void_pointer"><type>segment_manager_base_t::void_pointer</type></typedef>
<typedef name="size_type"><type>segment_manager_base_t::size_type</type></typedef>
<typedef name="difference_type"><type>segment_manager_base_t::difference_type</type></typedef>
<typedef name="char_type"><type>CharType</type></typedef>
<typedef name="segment_manager_base_type"><type><classname>segment_manager_base</classname>&lt; MemoryAlgorithm &gt;</type></typedef>
<typedef name="mutex_family"><type>segment_manager_base_t::mutex_family</type></typedef>
<typedef name="const_named_iterator"><type>transform_iterator&lt; typename named_index_t::const_iterator, named_transform &gt;</type></typedef>
<typedef name="const_unique_iterator"><type>transform_iterator&lt; typename unique_index_t::const_iterator, unique_transform &gt;</type></typedef>
<data-member name="PayloadPerAllocation" specifiers="static"><type>const size_type</type></data-member>
<method-group name="public member functions">
<method name="find"><type>std::pair&lt; T *, size_type &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Tries to find a previous named/unique allocation. Returns the address and the object count. On failure the first member of the returned pair is 0. </para></description></method>
<method name="find_no_lock"><type>std::pair&lt; T *, size_type &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Tries to find a previous named/unique allocation. Returns the address and the object count. On failure the first member of the returned pair is 0. This search is not mutex-protected! Use it only inside atomic_func() calls, where the internal mutex is guaranteed to be locked. </para></description></method>
<method name="construct"><type>construct_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Returns throwing "construct" proxy object </para></description></method>
<method name="find_or_construct"><type>construct_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Returns throwing "search or construct" proxy object </para></description></method>
<method name="construct"><type>construct_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Returns no throwing "construct" proxy object </para></description></method>
<method name="find_or_construct"><type>construct_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Returns no throwing "search or construct" proxy object </para></description></method>
<method name="construct_it"><type>construct_iter_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><purpose>Returns throwing "construct from iterators" proxy object. </purpose></method>
<method name="find_or_construct_it"><type>construct_iter_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Returns throwing "search or construct from iterators" proxy object </para></description></method>
<method name="construct_it"><type>construct_iter_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Returns no throwing "construct from iterators" proxy object </para></description></method>
<method name="find_or_construct_it"><type>construct_iter_proxy&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Returns no throwing "search or construct from iterators" proxy object </para></description></method>
<method name="atomic_func"><type>void</type><template>
          <template-type-parameter name="Func"/>
        </template><parameter name="f"><paramtype>Func &amp;</paramtype></parameter><description><para>Calls object function blocking recursive <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> and guarantees that no new named_alloc or destroy will be executed by any process while executing the object function call </para></description></method>
<method name="try_atomic_func"><type>bool</type><template>
          <template-type-parameter name="Func"/>
        </template><parameter name="f"><paramtype>Func &amp;</paramtype></parameter><description><para>Tries to calls a functor guaranteeing that no new construction, search or destruction will be executed by any process while executing the object function call. If the atomic function can't be immediatelly executed because the internal mutex is already locked, returns false. If the functor throws, this function throws. </para></description></method>
<method name="destroy"><type>bool</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="name"><paramtype>char_ptr_holder_t</paramtype></parameter><description><para>Destroys a previously created named/unique instance. Returns false if the object was not present. </para></description></method>
<method name="destroy_ptr"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="p"><paramtype>const T *</paramtype></parameter><description><para>Destroys an anonymous, unique or named object using its address </para></description></method>
<method name="reserve_named_objects"><type>void</type><parameter name="num"><paramtype>size_type</paramtype></parameter><description><para>Preallocates needed index resources to optimize the creation of "num" named objects in the managed memory segment. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory. </para></description></method>
<method name="reserve_unique_objects"><type>void</type><parameter name="num"><paramtype>size_type</paramtype></parameter><description><para>Preallocates needed index resources to optimize the creation of "num" unique objects in the managed memory segment. Can throw <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> if there is no enough memory. </para></description></method>
<method name="shrink_to_fit_indexes"><type>void</type><description><para>Calls shrink_to_fit in both named and unique object indexes to try to free unused memory from those indexes. </para></description></method>
<method name="get_num_named_objects"><type>size_type</type><description><para>Returns the number of named objects stored in the segment. </para></description></method>
<method name="get_num_unique_objects"><type>size_type</type><description><para>Returns the number of unique objects stored in the segment. </para></description></method>
<method name="named_begin" cv="const"><type>const_named_iterator</type><description><para>Returns a constant iterator to the beginning of the information about the named allocations performed in this segment manager </para></description></method>
<method name="named_end" cv="const"><type>const_named_iterator</type><description><para>Returns a constant iterator to the end of the information about the named allocations performed in this segment manager </para></description></method>
<method name="unique_begin" cv="const"><type>const_unique_iterator</type><description><para>Returns a constant iterator to the beginning of the information about the unique allocations performed in this segment manager </para></description></method>
<method name="unique_end" cv="const"><type>const_unique_iterator</type><description><para>Returns a constant iterator to the end of the information about the unique allocations performed in this segment manager </para></description></method>
<method name="get_allocator"><type><classname>allocator</classname>&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><description><para>Returns an instance of the default allocator for type T initialized that allocates memory from this segment manager. </para></description></method>
<method name="get_deleter"><type><classname>deleter</classname>&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><description><para>Returns an instance of the default deleter for type T that will delete an object constructed in this segment manager. </para></description></method>
</method-group>
<constructor specifiers="explicit"><parameter name="segment_size"><paramtype>size_type</paramtype></parameter><description><para>Constructor of the segment manager "size" is the size of the memory segment where the segment manager is being constructed. Can throw </para></description></constructor>
<method-group name="public static functions">
<method name="get_instance_name" specifiers="static"><type>const CharType *</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr"><paramtype>const T *</paramtype></parameter><description><para>Returns the name of an object created with construct/find_or_construct functions. Does not throw </para></description></method>
<method name="get_instance_length" specifiers="static"><type>size_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr"><paramtype>const T *</paramtype></parameter><description><para>Returns the length of an object created with construct/find_or_construct functions. Does not throw. </para></description></method>
<method name="get_instance_type" specifiers="static"><type>instance_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="ptr"><paramtype>const T *</paramtype></parameter><description><para>Returns is the the name of an object created with construct/find_or_construct functions. Does not throw </para></description></method>
<method name="get_min_size" specifiers="static"><type>size_type</type><description><para>Obtains the minimum size needed by the segment manager </para></description></method>
</method-group>
</class><class name="segment_manager_base"><template>
      <template-type-parameter name="MemoryAlgorithm"/>
    </template><inherit access="private">MemoryAlgorithm</inherit><description><para>This object is the public base class of segment manager. This class only depends on the memory allocation algorithm and implements all the allocation features not related to named or unique objects.</para><para>Storing a reference to <classname alt="boost::interprocess::segment_manager">segment_manager</classname> forces the holder class to be dependent on index types and character types. When such dependence is not desirable and only anonymous and raw allocations are needed, <classname alt="boost::interprocess::segment_manager_base">segment_manager_base</classname> is the correct answer. </para></description><typedef name="segment_manager_base_type"><type><classname>segment_manager_base</classname>&lt; MemoryAlgorithm &gt;</type></typedef>
<typedef name="void_pointer"><type>MemoryAlgorithm::void_pointer</type></typedef>
<typedef name="mutex_family"><type>MemoryAlgorithm::mutex_family</type></typedef>
<typedef name="memory_algorithm"><type>MemoryAlgorithm</type></typedef>
<data-member name="PayloadPerAllocation" specifiers="static"><type>const size_type</type><description><para>This constant indicates the payload size associated with each allocation of the memory algorithm </para></description></data-member>
<method-group name="public member functions">
<method name="get_size" cv="const"><type>size_type</type><description><para>Returns the size of the memory segment </para></description></method>
<method name="get_free_memory" cv="const"><type>size_type</type><description><para>Returns the number of free bytes of the memory segment </para></description></method>
<method name="allocate"><type>void *</type><parameter name="nbytes"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Allocates nbytes bytes. This function is only used in single-segment management. Never throws </para></description></method>
<method name="get_memory_algorithm"><type>MemoryAlgorithm &amp;</type><description><para>Returns a reference to the internal memory algorithm. This function is useful for custom memory algorithms that need additional configuration options after construction. Never throws. This function should be only used by advanced users. </para></description></method>
<method name="get_memory_algorithm" cv="const"><type>const MemoryAlgorithm &amp;</type><description><para>Returns a const reference to the internal memory algorithm. This function is useful for custom memory algorithms that need additional configuration options after construction. Never throws. This function should be only used by advanced users. </para></description></method>
<method name="allocate"><type>void *</type><parameter name="nbytes"><paramtype>size_type</paramtype></parameter><description><para>Allocates nbytes bytes. Throws <classname alt="boost::interprocess::bad_alloc">boost::interprocess::bad_alloc</classname> on failure </para></description></method>
<method name="allocate_aligned"><type>void *</type><parameter name="nbytes"><paramtype>size_type</paramtype></parameter><parameter name="alignment"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Allocates nbytes bytes. This function is only used in single-segment management. Never throws </para></description></method>
<method name="allocate_aligned"><type>void *</type><parameter name="nbytes"><paramtype>size_type</paramtype></parameter><parameter name="alignment"><paramtype>size_type</paramtype></parameter><description><para>Allocates nbytes bytes. This function is only used in single-segment management. Throws <classname alt="boost::interprocess::bad_alloc">bad_alloc</classname> when fails </para></description></method>
<method name="deallocate"><type>void</type><parameter name="addr"><paramtype>void *</paramtype></parameter><description><para>Deallocates the bytes allocated with allocate/allocate_many() pointed by addr </para></description></method>
<method name="grow"><type>void</type><parameter name="extra_size"><paramtype>size_type</paramtype></parameter><description><para>Increases managed memory in extra_size bytes more. This only works with single-segment management. </para></description></method>
<method name="shrink_to_fit"><type>void</type><description><para>Decreases managed memory to the minimum. This only works with single-segment management. </para></description></method>
<method name="all_memory_deallocated"><type>bool</type><description><para>Returns the result of "all_memory_deallocated()" function of the used memory algorithm </para></description></method>
<method name="check_sanity"><type>bool</type><description><para>Returns the result of "check_sanity()" function of the used memory algorithm </para></description></method>
<method name="zero_free_memory"><type>void</type><description><para>Writes to zero free memory (memory not yet allocated) of the memory algorithm </para></description></method>
<method name="size" cv="const"><type>size_type</type><parameter name="ptr"><paramtype>const void *</paramtype></parameter><purpose>Returns the size of the buffer previously allocated pointed by ptr. </purpose></method>
</method-group>
<constructor><parameter name="sz"><paramtype>size_type</paramtype></parameter><parameter name="reserved_bytes"><paramtype>size_type</paramtype></parameter><description><para>Constructor of the <classname alt="boost::interprocess::segment_manager_base">segment_manager_base</classname></para><para>"size" is the size of the memory segment where the basic segment manager is being constructed.</para><para>"reserved_bytes" is the number of bytes after the end of the memory algorithm object itself that the memory algorithm will exclude from dynamic allocation</para><para>Can throw </para></description></constructor>
<method-group name="public static functions">
<method name="get_min_size" specifiers="static"><type>size_type</type><parameter name="size"><paramtype>size_type</paramtype></parameter><description><para>Obtains the minimum size needed by the segment manager </para></description></method>
</method-group>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/shared_memory_object.hpp">
<para>Describes a shared memory object management class. </para><namespace name="boost">
<namespace name="interprocess">
<class name="shared_memory_object"><description><para>A class that wraps a shared memory mapping that can be used to create mapped regions from the mapped files </para></description><method-group name="public member functions">
<method name="swap" cv="noexcept"><type>void</type><parameter name="moved"><paramtype><classname>shared_memory_object</classname> &amp;</paramtype></parameter><purpose>Swaps the shared_memory_objects. Does not throw. </purpose></method>
<method name="truncate"><type>void</type><parameter name="length"><paramtype>offset_t</paramtype></parameter><purpose>Sets the size of the shared memory mapping. </purpose></method>
<method name="get_name" cv="const noexcept"><type>const char *</type><purpose>Returns the name of the shared memory object. </purpose></method>
<method name="get_size" cv="const noexcept"><type>bool</type><parameter name="size"><paramtype>offset_t &amp;</paramtype></parameter><description><para>Returns true if the size of the shared memory object can be obtained and writes the size in the passed reference </para></description></method>
<method name="get_mode" cv="const noexcept"><type>mode_t</type><purpose>Returns access mode. </purpose></method>
<method name="get_mapping_handle" cv="const noexcept"><type>mapping_handle_t</type><purpose>Returns mapping handle. Never throws. </purpose></method>
</method-group>
<constructor cv="noexcept"><purpose>Default constructor. Represents an empty <classname alt="boost::interprocess::shared_memory_object">shared_memory_object</classname>. </purpose></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a shared memory object with name "name" and mode "mode", with the access mode "mode" If the file previously exists, throws an error. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Tries to create a shared memory object with name "name" and mode "mode", with the access mode "mode". If the file previously exists, it tries to open it with mode "mode". Otherwise throws an error. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Tries to open a shared memory object with name "name", with the access mode "mode". If the file does not previously exist, it throws an error. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a shared memory object with name "name" and mode "mode", with the access mode "mode" If the file previously exists, throws an error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Tries to create a shared memory object with name "name" and mode "mode", with the access mode "mode". If the file previously exists, it tries to open it with mode "mode". Otherwise throws an error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Tries to open a shared memory object with name "name", with the access mode "mode". If the file does not previously exist, it throws an error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor cv="noexcept"><parameter name="moved"><paramtype><classname>shared_memory_object</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory object to *this. After the call, "moved" does not represent any shared memory object. Does not throw </para></description></constructor>
<copy-assignment cv="noexcept"><type><classname>shared_memory_object</classname> &amp;</type><parameter name="moved"><paramtype><classname>shared_memory_object</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory to *this. After the call, "moved" does not represent any shared memory. Does not throw </para></description></copy-assignment>
<destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. All mapped regions are still valid after destruction. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor>
<method-group name="public static functions">
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a shared memory object from the system. Returns false on error. Never throws </para></description></method>
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a shared memory object from the system. Returns false on error. Never throws</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/smart_ptr/deleter.hpp">
<para>Describes the functor to delete objects from the segment. </para><namespace name="boost">
<namespace name="interprocess">
<class name="deleter"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SegmentManager"/>
    </template><description><para>A deleter that uses the segment manager's destroy_ptr function to destroy the passed pointer resource.</para><para>This deleter is used </para></description><typedef name="pointer"><type>boost::intrusive::pointer_traits&lt; typename SegmentManager::void_pointer &gt;::template rebind_pointer&lt; T &gt;::type</type></typedef>
<method-group name="public member functions">
<method name="operator()"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter></method>
</method-group>
<constructor cv="noexcept"><parameter name="pmngr"><paramtype>segment_manager_pointer</paramtype></parameter></constructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/smart_ptr/enable_shared_from_this.hpp">
<para>Describes an utility to form a shared pointer from this </para><namespace name="boost">
<namespace name="interprocess">

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/smart_ptr/intrusive_ptr.hpp">
<para>Describes an intrusive ownership pointer. </para><namespace name="boost">
<namespace name="interprocess">
<class name="intrusive_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="VoidPointer"/>
    </template><description><para>The <classname alt="boost::interprocess::intrusive_ptr">intrusive_ptr</classname> class template stores a pointer to an object with an embedded reference count. <classname alt="boost::interprocess::intrusive_ptr">intrusive_ptr</classname> is parameterized on T (the type of the object pointed to) and VoidPointer(a void pointer type that defines the type of pointer that <classname alt="boost::interprocess::intrusive_ptr">intrusive_ptr</classname> will store). intrusive_ptr&lt;T, void *&gt; defines a class with a T* member whereas <classname alt="boost::interprocess::intrusive_ptr">intrusive_ptr</classname>&lt;T, offset_ptr&lt;void&gt; &gt; defines a class with a offset_ptr&lt;T&gt; member. Relies on unqualified calls to:</para><para>void intrusive_ptr_add_ref(T * p) BOOST_NOEXCEPT; void intrusive_ptr_release(T * p) BOOST_NOEXCEPT;</para><para>with (p != 0)</para><para>The object is responsible for destroying itself. </para></description><typedef name="pointer"><purpose>Provides the type of the internal stored pointer. </purpose><type>boost::intrusive::pointer_traits&lt; VoidPointer &gt;::template rebind_pointer&lt; T &gt;::type</type></typedef>
<typedef name="element_type"><purpose>Provides the type of the stored pointer. </purpose><type>T</type></typedef>
<method-group name="public member functions">
<method name="reset" cv="noexcept"><type>void</type><description><para>Release internal pointer and set it to 0. If internal pointer is not 0, calls intrusive_ptr_release(to_raw_pointer(m_ptr)). Does not throw </para></description></method>
<method name="get" cv="noexcept"><type>pointer &amp;</type><description><para>Returns a reference to the internal pointer. Does not throw </para></description></method>
<method name="get" cv="const noexcept"><type>const pointer &amp;</type><description><para>Returns a reference to the internal pointer. Does not throw </para></description></method>
<method name="operator *" cv="const noexcept"><type>T &amp;</type><description><para>Returns *get(). Does not throw </para></description></method>
<method name="operator-&gt;" cv="const noexcept"><type>const pointer &amp;</type><description><para>Returns *get(). Does not throw </para></description></method>
<method name="operator-&gt;" cv="noexcept"><type>pointer &amp;</type><description><para>Returns get(). Does not throw </para></description></method>
<method name="conversion-operator" cv="const noexcept"><type>unspecified_bool_type</type><description><para>Conversion to boolean. Does not throw </para></description></method>
<method name="operator!" cv="const noexcept"><type>bool</type><description><para>Not operator. Does not throw </para></description></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname> &amp;</paramtype></parameter><description><para>Exchanges the contents of the two smart pointers. Does not throw </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Constructor. Initializes internal pointer to 0. Does not throw </para></description></constructor>
<constructor cv="noexcept"><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="add_ref"><paramtype>bool</paramtype><default>true</default></parameter><description><para>Constructor. Copies pointer and if "p" is not zero and "add_ref" is true calls intrusive_ptr_add_ref(to_raw_pointer(p)). Does not throw </para></description></constructor>
<constructor cv="noexcept"><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname> const &amp;</paramtype></parameter><description><para>Copy constructor. Copies the internal pointer and if "p" is not zero calls intrusive_ptr_add_ref(to_raw_pointer(p)). Does not throw </para></description></constructor>
<constructor cv="noexcept"><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname> &amp;&amp;</paramtype></parameter><purpose>Move constructor. Moves the internal pointer. Does not throw. </purpose></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="U"/>
        </template><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname>&lt; U, VP &gt; const &amp;</paramtype></parameter><description><para>Constructor from related. Copies the internal pointer and if "p" is not zero calls intrusive_ptr_add_ref(to_raw_pointer(p)). Does not throw </para></description></constructor>
<destructor><purpose>Destructor. Calls reset(). Does not throw. </purpose></destructor>
<copy-assignment cv="noexcept"><type><classname>intrusive_ptr</classname> &amp;</type><parameter name="rhs"><paramtype>BOOST_COPY_ASSIGN_REF(<classname>intrusive_ptr</classname>)</paramtype></parameter><description><para>Assignment operator. Equivalent to intrusive_ptr(r).swap(*this). Does not throw </para></description></copy-assignment>
<copy-assignment cv="noexcept"><type><classname>intrusive_ptr</classname> &amp;</type><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname> &amp;&amp;</paramtype></parameter><description><para>Move Assignment operator Does not throw </para></description></copy-assignment>
<copy-assignment cv="noexcept"><type><classname>intrusive_ptr</classname> &amp;</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname>&lt; U, VP &gt; const &amp;</paramtype></parameter><description><para>Assignment from related. Equivalent to intrusive_ptr(r).swap(*this). Does not throw </para></description></copy-assignment>
<copy-assignment cv="noexcept"><type><classname>intrusive_ptr</classname> &amp;</type><parameter name="rhs"><paramtype>pointer</paramtype></parameter><description><para>Assignment from pointer. Equivalent to intrusive_ptr(r).swap(*this). Does not throw </para></description></copy-assignment>
</class>





































<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; U, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a.get() == b.get(). Does not throw </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; U, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a.get() != b.get(). Does not throw </para></description></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype>const typename <classname>intrusive_ptr</classname>&lt; T, VP &gt;::pointer &amp;</paramtype></parameter><description><para>Returns a.get() == b. Does not throw </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype>const typename <classname>intrusive_ptr</classname>&lt; T, VP &gt;::pointer &amp;</paramtype></parameter><description><para>Returns a.get() != b. Does not throw </para></description></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype>const typename <classname>intrusive_ptr</classname>&lt; T, VP &gt;::pointer &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a == b.get(). Does not throw </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype>const typename <classname>intrusive_ptr</classname>&lt; T, VP &gt;::pointer &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a != b.get(). Does not throw </para></description></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="a"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; const &amp;</paramtype></parameter><description><para>Returns a.get() &lt; b.get(). Does not throw </para></description></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="lhs"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt; &amp;</paramtype></parameter><description><para>Exchanges the contents of the two intrusive_ptrs. Does not throw </para></description></function>
<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; E, T &gt; &amp;</type><template>
          <template-type-parameter name="E"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; E, T &gt; &amp;</paramtype></parameter><parameter name="p"><paramtype><classname>intrusive_ptr</classname>&lt; Y, VP &gt; const &amp;</paramtype></parameter></function>
<function name="to_raw_pointer"><type><classname>boost::interprocess::intrusive_ptr</classname>&lt; T, VP &gt;::pointer</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VP"/>
        </template><parameter name="p"><paramtype><classname>intrusive_ptr</classname>&lt; T, VP &gt;</paramtype></parameter><description><para>Returns p.get(). Does not throw </para></description></function>

</namespace>
</namespace>
</header>
<header name="boost/interprocess/smart_ptr/scoped_ptr.hpp">
<para>Describes the smart pointer scoped_ptr </para><namespace name="boost">
<namespace name="interprocess">
<class name="scoped_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Deleter"/>
    </template><inherit access="private">Deleter</inherit><description><para><classname alt="boost::interprocess::scoped_ptr">scoped_ptr</classname> stores a pointer to a dynamically allocated object. The object pointed to is guaranteed to be deleted, either on destruction of the <classname alt="boost::interprocess::scoped_ptr">scoped_ptr</classname>, or via an explicit reset. The user can avoid this deletion using release(). <classname alt="boost::interprocess::scoped_ptr">scoped_ptr</classname> is parameterized on T (the type of the object pointed to) and Deleter (the functor to be executed to delete the internal pointer). The internal pointer will be of the same pointer type as typename Deleter::pointer type (that is, if typename Deleter::pointer is offset_ptr&lt;void&gt;, the internal pointer will be offset_ptr&lt;T&gt;). </para></description><typedef name="element_type"><type>T</type></typedef>
<typedef name="deleter_type"><type>Deleter</type></typedef>
<typedef name="pointer"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="unspecified_bool_type"><type>pointer this_type::*</type></typedef>
<method-group name="public member functions">
<method name="reset"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype><default>0</default></parameter><description><para>Deletes the object pointed to by the stored pointer and then stores a copy of p. Never throws </para></description></method>
<method name="reset"><type>void</type><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="d"><paramtype>const Deleter &amp;</paramtype></parameter><description><para>Deletes the object pointed to by the stored pointer and then stores a copy of p and a copy of d. </para></description></method>
<method name="release" cv="noexcept"><type>pointer</type><description><para>Assigns internal pointer as 0 and returns previous pointer. This will avoid deletion on destructor </para></description></method>
<method name="operator *" cv="const noexcept"><type>reference</type><description><para>Returns a reference to the object pointed to by the stored pointer. Never throws. </para></description></method>
<method name="operator-&gt;" cv="noexcept"><type>pointer &amp;</type><description><para>Returns the internal stored pointer. Never throws. </para></description></method>
<method name="operator-&gt;" cv="const noexcept"><type>const pointer &amp;</type><description><para>Returns the internal stored pointer. Never throws. </para></description></method>
<method name="get" cv="noexcept"><type>pointer &amp;</type><description><para>Returns the stored pointer. Never throws. </para></description></method>
<method name="get" cv="const noexcept"><type>const pointer &amp;</type><description><para>Returns the stored pointer. Never throws. </para></description></method>
<method name="conversion-operator" cv="const noexcept"><type>unspecified_bool_type</type><description><para>Conversion to bool Never throws </para></description></method>
<method name="operator!" cv="const noexcept"><type>bool</type><description><para>Returns true if the stored pointer is 0. Never throws. </para></description></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="b"><paramtype><classname>scoped_ptr</classname> &amp;</paramtype></parameter><description><para>Exchanges the internal pointer and deleter with other <classname alt="boost::interprocess::scoped_ptr">scoped_ptr</classname> Never throws. </para></description></method>
</method-group>
<constructor specifiers="explicit"><parameter name="p"><paramtype>const pointer &amp;</paramtype><default>0</default></parameter><parameter name="d"><paramtype>const Deleter &amp;</paramtype><default>Deleter()</default></parameter><description><para>Constructs a <classname alt="boost::interprocess::scoped_ptr">scoped_ptr</classname>, storing a copy of p(which can be 0) and d. Does not throw. </para></description></constructor>
<destructor><description><para>If the stored pointer is not 0, destroys the object pointed to by the stored pointer. calling the operator() of the stored deleter. Never throws </para></description></destructor>
</class>



































<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="a"><paramtype><classname>scoped_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>scoped_ptr</classname>&lt; T, D &gt; &amp;</paramtype></parameter><description><para>Exchanges the internal pointer and deleter with other <classname alt="boost::interprocess::scoped_ptr">scoped_ptr</classname> Never throws. </para></description></function>
<function name="to_raw_pointer"><type><classname>scoped_ptr</classname>&lt; T, D &gt;::pointer</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="D"/>
        </template><parameter name="p"><paramtype><classname>scoped_ptr</classname>&lt; T, D &gt; const &amp;</paramtype></parameter><description><para>Returns a copy of the stored pointer Never throws </para></description></function>











</namespace>
</namespace>
</header>
<header name="boost/interprocess/smart_ptr/shared_ptr.hpp">
<para>Describes the smart pointer shared_ptr </para><namespace name="boost">
<namespace name="interprocess">
<class name="enable_shared_from_this"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="A"/>
      <template-type-parameter name="D"/>
    </template><description><para>This class is used as a base class that allows a <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> to the current object to be obtained from within a member function. <classname alt="boost::interprocess::enable_shared_from_this">enable_shared_from_this</classname> defines two member functions called shared_from_this that return a shared_ptr&lt;T&gt; and shared_ptr&lt;T const&gt;, depending on constness, to this. </para></description><method-group name="public member functions">
<method name="shared_from_this"><type><classname>shared_ptr</classname>&lt; T, A, D &gt;</type></method>
<method name="shared_from_this" cv="const"><type><classname>shared_ptr</classname>&lt; T const, A, D &gt;</type></method>
</method-group>
</class><struct name="managed_shared_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="ManagedMemory"/>
    </template><description><para>Returns the type of a shared pointer of type T with the allocator <classname alt="boost::interprocess::allocator">boost::interprocess::allocator</classname> allocator and <classname alt="boost::interprocess::deleter">boost::interprocess::deleter</classname> deleter that can be constructed in the given managed segment type. </para></description><typedef name="void_allocator"><type>ManagedMemory::template <classname>allocator</classname>&lt; void &gt;::<classname>type</classname></type></typedef>
<typedef name="deleter"><type>ManagedMemory::template deleter&lt; T &gt;::<classname>type</classname></type></typedef>
<typedef name="type"><type><classname>shared_ptr</classname>&lt; T, void_allocator, deleter &gt;</type></typedef>
</struct><class name="shared_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="VoidAllocator"/>
      <template-type-parameter name="Deleter"/>
    </template><description><para><classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> stores a pointer to a dynamically allocated object. The object pointed to is guaranteed to be deleted when the last <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> pointing to it is destroyed or reset.</para><para><classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> is parameterized on T (the type of the object pointed to), VoidAllocator (the void allocator to be used to allocate the auxiliary data) and Deleter (the deleter whose operator() will be used to delete the object.</para><para>The internal pointer will be of the same pointer type as typename VoidAllocator::pointer type (that is, if typename VoidAllocator::pointer is offset_ptr&lt;void&gt;, the internal pointer will be offset_ptr&lt;T&gt;).</para><para>Because the implementation uses reference counting, cycles of <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> instances will not be reclaimed. For example, if main() holds a <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> to A, which directly or indirectly holds a <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> back to A, A's use count will be 2. Destruction of the original <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> will leave A dangling with a use count of 1. Use <classname alt="boost::interprocess::weak_ptr">weak_ptr</classname> to "break cycles." </para></description><typedef name="element_type"><type>T</type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<typedef name="void_ptr"><type>boost::container::allocator_traits&lt; VoidAllocator &gt;::pointer</type></typedef>
<typedef name="pointer"><type>boost::intrusive::pointer_traits&lt; void_ptr &gt;::template rebind_pointer&lt; T &gt;::type</type></typedef>
<typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="const_deleter_pointer"><type>boost::intrusive::pointer_traits&lt; void_ptr &gt;::template rebind_pointer&lt; const Deleter &gt;::type</type></typedef>
<typedef name="const_allocator_pointer"><type>boost::intrusive::pointer_traits&lt; void_ptr &gt;::template rebind_pointer&lt; const VoidAllocator &gt;::type</type></typedef>
<method-group name="public member functions">
<method name="reset"><type>void</type><description><para>This is equivalent to: this_type().swap(*this); </para></description></method>
<method name="reset"><type>void</type><template>
          <template-type-parameter name="Pointer"/>
        </template><parameter name="p"><paramtype>const Pointer &amp;</paramtype></parameter><parameter name="a"><paramtype>const VoidAllocator &amp;</paramtype><default>VoidAllocator()</default></parameter><parameter name="d"><paramtype>const Deleter &amp;</paramtype><default>Deleter()</default></parameter><description><para>This is equivalent to: this_type(p, a, d).swap(*this); </para></description></method>
<method name="reset"><type>void</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter></method>
<method name="operator *" cv="const"><type>reference</type><description><para>Returns a reference to the pointed type </para></description></method>
<method name="operator-&gt;" cv="const"><type>pointer</type><description><para>Returns the pointer pointing to the owned object </para></description></method>
<method name="get" cv="const"><type>pointer</type><description><para>Returns the pointer pointing to the owned object </para></description></method>
<method name="operator!" cv="const"><type>bool</type><description><para>Not operator. Returns true if this-&gt;get() != 0, false otherwise </para></description></method>
<method name="unique" cv="const"><type>bool</type><description><para>Returns use_count() == 1. unique() might be faster than use_count() </para></description></method>
<method name="use_count" cv="const"><type>long</type><description><para>Returns the number of <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> objects, *this included, that share ownership with *this, or an unspecified nonnegative value when *this is empty. use_count() is not necessarily efficient. Use only for debugging and testing purposes, not for production code. </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; &amp;</paramtype></parameter><description><para>Exchanges the contents of the two smart pointers. </para></description></method>
</method-group>
<constructor><description><para>Constructs an empty <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname>. Use_count() == 0 &amp;&amp; get()== 0. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="a"><paramtype>const VoidAllocator &amp;</paramtype><default>VoidAllocator()</default></parameter><parameter name="d"><paramtype>const Deleter &amp;</paramtype><default>Deleter()</default></parameter><description><para>Constructs a <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> that owns the pointer p. Auxiliary data will be allocated with a copy of a and the object will be deleted with a copy of d. Requirements: Deleter and A's copy constructor must not throw. </para></description></constructor>
<constructor><parameter name="r"><paramtype>const <classname>shared_ptr</classname> &amp;</paramtype></parameter><description><para>Copy constructs a <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname>. If r is empty, constructs an empty <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname>. Otherwise, constructs a <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> that shares ownership with r. Never throws. </para></description></constructor>
<constructor><parameter name="other"><paramtype>const <classname>shared_ptr</classname> &amp;</paramtype></parameter><parameter name="p"><paramtype>const pointer &amp;</paramtype></parameter><description><para>Constructs a <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> that shares ownership with other and stores p. Postconditions: get() == p &amp;&amp; use_count() == r.use_count(). Throws: nothing. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><description><para>If r is empty, constructs an empty <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname>. Otherwise, constructs a <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> that shares ownership with r. Never throws. </para></description></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>weak_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><description><para>Constructs a <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> that shares ownership with r and stores a copy of the pointer stored in r. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="other"><paramtype><classname>shared_ptr</classname> &amp;&amp;</paramtype></parameter><description><para>Move-Constructs a <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> that takes ownership of other resource and other is put in default-constructed state. Throws: nothing. </para></description></constructor>
<copy-assignment><type><classname>shared_ptr</classname> &amp;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><description><para>Equivalent to shared_ptr(r).swap(*this). Never throws </para></description></copy-assignment>
<copy-assignment><type><classname>shared_ptr</classname> &amp;</type><parameter name="r"><paramtype>BOOST_COPY_ASSIGN_REF(<classname>shared_ptr</classname>)</paramtype></parameter><description><para>Equivalent to shared_ptr(r).swap(*this). Never throws </para></description></copy-assignment>
<copy-assignment><type><classname>shared_ptr</classname> &amp;</type><parameter name="other"><paramtype><classname>shared_ptr</classname> &amp;&amp;</paramtype></parameter><description><para>Move-assignment. Equivalent to shared_ptr(other).swap(*this). Never throws </para></description></copy-assignment>
</class>
























<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VoidAllocator2"/>
          <template-type-parameter name="Deleter2"/>
        </template><parameter name="a"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator2, Deleter2 &gt; const &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VoidAllocator2"/>
          <template-type-parameter name="Deleter2"/>
        </template><parameter name="a"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator2, Deleter2 &gt; const &amp;</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="VoidAllocator2"/>
          <template-type-parameter name="Deleter2"/>
        </template><parameter name="a"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator2, Deleter2 &gt; const &amp;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
        </template><parameter name="a"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; &amp;</paramtype></parameter></function>
<function name="static_pointer_cast"><type><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function>
<function name="const_pointer_cast"><type><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function>
<function name="dynamic_pointer_cast"><type><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
          <template-type-parameter name="U"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; U, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function>
<function name="to_raw_pointer"><type>T *</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
        </template><parameter name="p"><paramtype><classname>shared_ptr</classname>&lt; T, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function>
<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; E, T &gt; &amp;</type><template>
          <template-type-parameter name="E"/>
          <template-type-parameter name="T"/>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="VoidAllocator"/>
          <template-type-parameter name="Deleter"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; E, T &gt; &amp;</paramtype></parameter><parameter name="p"><paramtype><classname>shared_ptr</classname>&lt; Y, VoidAllocator, Deleter &gt; const &amp;</paramtype></parameter></function>
<function name="make_managed_shared_ptr"><type><classname>managed_shared_ptr</classname>&lt; T, ManagedMemory &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="ManagedMemory"/>
        </template><parameter name="constructed_object"><paramtype>T *</paramtype></parameter><parameter name="managed_memory"><paramtype>ManagedMemory &amp;</paramtype></parameter><description><para>Returns an instance of a shared pointer constructed with the default allocator and deleter from a pointer of type T that has been allocated in the passed managed segment </para></description></function>
<function name="make_managed_shared_ptr"><type><classname>managed_shared_ptr</classname>&lt; T, ManagedMemory &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="ManagedMemory"/>
        </template><parameter name="constructed_object"><paramtype>T *</paramtype></parameter><parameter name="managed_memory"><paramtype>ManagedMemory &amp;</paramtype></parameter><parameter name=""><paramtype>const std::nothrow_t &amp;</paramtype></parameter><description><para>Returns an instance of a shared pointer constructed with the default allocator and deleter from a pointer of type T that has been allocated in the passed managed segment. Does not throw, return null shared pointer in error. </para></description></function>













</namespace>
</namespace>
</header>
<header name="boost/interprocess/smart_ptr/unique_ptr.hpp">
<para>This header provides utilities to define a unique_ptr that plays nicely with managed segments. </para><namespace name="boost">
<namespace name="interprocess">
<struct name="managed_unique_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="ManagedMemory"/>
    </template><description><para>Returns the type of a unique pointer of type T with <classname alt="boost::interprocess::deleter">boost::interprocess::deleter</classname> deleter that can be constructed in the given managed segment type. </para></description><typedef name="type"><type>boost::movelib::unique_ptr&lt; T, typename ManagedMemory::template <classname>deleter</classname>&lt; T &gt;::type &gt;</type></typedef>
</struct>























<function name="make_managed_unique_ptr"><type><classname>managed_unique_ptr</classname>&lt; T, ManagedMemory &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="ManagedMemory"/>
        </template><parameter name="constructed_object"><paramtype>T *</paramtype></parameter><parameter name="managed_memory"><paramtype>ManagedMemory &amp;</paramtype></parameter><description><para>Returns an instance of a unique pointer constructed with boost::interproces::deleter from a pointer of type T that has been allocated in the passed managed segment </para></description></function>
























</namespace>
</namespace>
</header>
<header name="boost/interprocess/smart_ptr/weak_ptr.hpp">
<para>Describes the smart pointer weak_ptr. </para><namespace name="boost">
<namespace name="interprocess">
<struct name="managed_weak_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="ManagedMemory"/>
    </template><description><para>Returns the type of a weak pointer of type T with the allocator <classname alt="boost::interprocess::allocator">boost::interprocess::allocator</classname> allocator and <classname alt="boost::interprocess::deleter">boost::interprocess::deleter</classname> deleter that can be constructed in the given managed segment type. </para></description><typedef name="type"><type><classname>weak_ptr</classname>&lt; T, typename ManagedMemory::template <classname>allocator</classname>&lt; void &gt;::<classname>type</classname>, typename ManagedMemory::template <classname>deleter</classname>&lt; T &gt;::<classname>type</classname> &gt;</type></typedef>
</struct><class name="weak_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="A"/>
      <template-type-parameter name="D"/>
    </template><description><para>The <classname alt="boost::interprocess::weak_ptr">weak_ptr</classname> class template stores a "weak reference" to an object that's already managed by a <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname>. To access the object, a <classname alt="boost::interprocess::weak_ptr">weak_ptr</classname> can be converted to a <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> using the <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> constructor or the member function lock. When the last <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> to the object goes away and the object is deleted, the attempt to obtain a <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> from the <classname alt="boost::interprocess::weak_ptr">weak_ptr</classname> instances that refer to the deleted object will fail: the constructor will throw an exception of type bad_weak_ptr, and weak_ptr::lock will return an empty <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname>.</para><para>Every <classname alt="boost::interprocess::weak_ptr">weak_ptr</classname> meets the CopyConstructible and Assignable requirements of the C++ Standard Library, and so can be used in standard library containers. Comparison operators are supplied so that <classname alt="boost::interprocess::weak_ptr">weak_ptr</classname> works with the standard library's associative containers.</para><para><classname alt="boost::interprocess::weak_ptr">weak_ptr</classname> operations never throw exceptions.</para><para>The class template is parameterized on T, the type of the object pointed to. </para></description><typedef name="element_type"><type>T</type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<method-group name="public member functions">
<method name="lock" cv="const"><type><classname>shared_ptr</classname>&lt; T, A, D &gt;</type><description><para>Returns: expired()? shared_ptr&lt;T&gt;(): shared_ptr&lt;T&gt;(*this).</para><para>Throws: nothing. </para></description></method>
<method name="use_count" cv="const"><type>long</type><description><para>Returns: 0 if *this is empty; otherwise, the number of <classname alt="boost::interprocess::shared_ptr">shared_ptr</classname> objects that share ownership with *this.</para><para>Throws: nothing.</para><para>Notes: use_count() is not necessarily efficient. Use only for debugging and testing purposes, not for production code. </para></description></method>
<method name="expired" cv="const"><type>bool</type><description><para>Returns: Returns: use_count() == 0.</para><para>Throws: nothing.</para><para>Notes: expired() may be faster than use_count(). </para></description></method>
<method name="reset"><type>void</type><description><para>Effects: Equivalent to: weak_ptr().swap(*this). </para></description></method>
<method name="swap"><type>void</type><parameter name="other"><paramtype>this_type &amp;</paramtype></parameter><description><para>Effects: Exchanges the contents of the two smart pointers.</para><para>Throws: nothing. </para></description></method>
</method-group>
<constructor><description><para>Effects: Constructs an empty <classname alt="boost::interprocess::weak_ptr">weak_ptr</classname>. Postconditions: use_count() == 0. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>weak_ptr</classname>&lt; Y, A, D &gt; const &amp;</paramtype></parameter><description><para>Effects: If r is empty, constructs an empty <classname alt="boost::interprocess::weak_ptr">weak_ptr</classname>; otherwise, constructs a <classname alt="boost::interprocess::weak_ptr">weak_ptr</classname> that shares ownership with r as if by storing a copy of the pointer stored in r.</para><para>Postconditions: use_count() == r.use_count().</para><para>Throws: nothing. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, A, D &gt; const &amp;</paramtype></parameter><description><para>Effects: If r is empty, constructs an empty <classname alt="boost::interprocess::weak_ptr">weak_ptr</classname>; otherwise, constructs a <classname alt="boost::interprocess::weak_ptr">weak_ptr</classname> that shares ownership with r as if by storing a copy of the pointer stored in r.</para><para>Postconditions: use_count() == r.use_count().</para><para>Throws: nothing. </para></description></constructor>
<copy-assignment><type><classname>weak_ptr</classname> &amp;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>weak_ptr</classname>&lt; Y, A, D &gt; const &amp;</paramtype></parameter><description><para>Effects: Equivalent to weak_ptr(r).swap(*this).</para><para>Throws: nothing.</para><para>Notes: The implementation is free to meet the effects (and the implied guarantees) via different means, without creating a temporary. </para></description></copy-assignment>
<copy-assignment><type><classname>weak_ptr</classname> &amp;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="r"><paramtype><classname>shared_ptr</classname>&lt; Y, A, D &gt; const &amp;</paramtype></parameter><description><para>Effects: Equivalent to weak_ptr(r).swap(*this).</para><para>Throws: nothing.</para><para>Notes: The implementation is free to meet the effects (and the implied guarantees) via different means, without creating a temporary. </para></description></copy-assignment>
</class>




















<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
          <template-type-parameter name="D"/>
          <template-type-parameter name="U"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="D2"/>
        </template><parameter name="a"><paramtype><classname>weak_ptr</classname>&lt; T, A, D &gt; const &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>weak_ptr</classname>&lt; U, A2, D2 &gt; const &amp;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="A"/>
          <template-type-parameter name="D"/>
        </template><parameter name="a"><paramtype><classname>weak_ptr</classname>&lt; T, A, D &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype><classname>weak_ptr</classname>&lt; T, A, D &gt; &amp;</paramtype></parameter></function>
<function name="make_managed_weak_ptr"><type><classname>managed_weak_ptr</classname>&lt; T, ManagedMemory &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="ManagedMemory"/>
        </template><parameter name="constructed_object"><paramtype>T *</paramtype></parameter><parameter name="managed_memory"><paramtype>ManagedMemory &amp;</paramtype></parameter><description><para>Returns an instance of a weak pointer constructed with the default allocator and deleter from a pointer of type T that has been allocated in the passed managed segment </para></description></function>

























</namespace>
</namespace>
</header>
<header name="boost/interprocess/streams/bufferstream.hpp">
<para>This file defines basic_bufferbuf, basic_ibufferstream, basic_obufferstream, and basic_bufferstream classes. These classes represent streamsbufs and streams whose sources or destinations are fixed size character buffers. </para><namespace name="boost">
<namespace name="interprocess">
<class name="basic_bufferbuf"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_streambuf&lt; CharT, CharTraits &gt;</inherit><description><para>A streambuf class that controls the transmission of elements to and from a basic_xbufferstream. The elements are transmitted from a to a fixed size buffer </para></description><typedef name="char_type"><type>CharT</type></typedef>
<typedef name="int_type"><type>CharTraits::int_type</type></typedef>
<typedef name="pos_type"><type>CharTraits::pos_type</type></typedef>
<typedef name="off_type"><type>CharTraits::off_type</type></typedef>
<typedef name="traits_type"><type>CharTraits</type></typedef>
<typedef name="basic_streambuf_t"><type>std::basic_streambuf&lt; char_type, traits_type &gt;</type></typedef>
<method-group name="public member functions">
<method name="buffer" cv="const"><type>std::pair&lt; CharT *, std::size_t &gt;</type><description><para>Returns the pointer and size of the internal buffer. Does not throw. </para></description></method>
<method name="buffer"><type>void</type><parameter name="buf"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the underlying buffer to a new value Does not throw. </para></description></method>
</method-group>
<constructor specifiers="explicit"><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Does not throw. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="buf"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Assigns formatting buffer. Does not throw. </para></description></constructor>
<destructor/>
</class><class name="basic_bufferstream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_iostream&lt; CharT, CharTraits &gt;</inherit><description><para>A basic_iostream class that uses a fixed size character buffer as its formatting buffer. </para></description><typedef name="char_type"><type>std::basic_ios&lt; CharT, CharTraits &gt;::char_type</type></typedef>
<typedef name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef>
<typedef name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef>
<typedef name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef>
<typedef name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef>
<method-group name="public member functions">
<method name="rdbuf" cv="const"><type><classname>basic_bufferbuf</classname>&lt; CharT, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method>
<method name="buffer" cv="const"><type>std::pair&lt; CharT *, std::size_t &gt;</type><description><para>Returns the pointer and size of the internal buffer. Does not throw. </para></description></method>
<method name="buffer"><type>void</type><parameter name="buf"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the underlying buffer to a new value. Resets stream position. Does not throw. </para></description></method>
</method-group>
<constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Does not throw. </para></description></constructor>
<constructor><parameter name="buf"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Assigns formatting buffer. Does not throw. </para></description></constructor>
<destructor/>
</class><class name="basic_ibufferstream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_istream&lt; CharT, CharTraits &gt;</inherit><description><para>A basic_istream class that uses a fixed size character buffer as its formatting buffer. </para></description><typedef name="char_type"><type>std::basic_ios&lt; CharT, CharTraits &gt;::char_type</type></typedef>
<typedef name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef>
<typedef name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef>
<typedef name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef>
<typedef name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef>
<method-group name="public member functions">
<method name="rdbuf" cv="const"><type><classname>basic_bufferbuf</classname>&lt; CharT, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method>
<method name="buffer" cv="const"><type>std::pair&lt; const CharT *, std::size_t &gt;</type><description><para>Returns the pointer and size of the internal buffer. Does not throw. </para></description></method>
<method name="buffer"><type>void</type><parameter name="buf"><paramtype>const CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the underlying buffer to a new value. Resets stream position. Does not throw. </para></description></method>
</method-group>
<constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in</default></parameter><description><para>Constructor. Does not throw. </para></description></constructor>
<constructor><parameter name="buf"><paramtype>const CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in</default></parameter><description><para>Constructor. Assigns formatting buffer. Does not throw. </para></description></constructor>
<destructor/>
</class><class name="basic_obufferstream"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_ostream&lt; CharT, CharTraits &gt;</inherit><description><para>A basic_ostream class that uses a fixed size character buffer as its formatting buffer. </para></description><typedef name="char_type"><type>std::basic_ios&lt; CharT, CharTraits &gt;::char_type</type></typedef>
<typedef name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef>
<typedef name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef>
<typedef name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef>
<typedef name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef>
<method-group name="public member functions">
<method name="rdbuf" cv="const"><type><classname>basic_bufferbuf</classname>&lt; CharT, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method>
<method name="buffer" cv="const"><type>std::pair&lt; CharT *, std::size_t &gt;</type><description><para>Returns the pointer and size of the internal buffer. Does not throw. </para></description></method>
<method name="buffer"><type>void</type><parameter name="buf"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><description><para>Sets the underlying buffer to a new value. Resets stream position. Does not throw. </para></description></method>
</method-group>
<constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::out</default></parameter><description><para>Constructor. Does not throw. </para></description></constructor>
<constructor><parameter name="buf"><paramtype>CharT *</paramtype></parameter><parameter name="length"><paramtype>std::size_t</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::out</default></parameter><description><para>Constructor. Assigns formatting buffer. Does not throw. </para></description></constructor>
<destructor/>
</class><typedef name="bufferbuf"><type><classname>basic_bufferbuf</classname>&lt; char &gt;</type></typedef>
<typedef name="bufferstream"><type><classname>basic_bufferstream</classname>&lt; char &gt;</type></typedef>
<typedef name="ibufferstream"><type><classname>basic_ibufferstream</classname>&lt; char &gt;</type></typedef>
<typedef name="obufferstream"><type><classname>basic_obufferstream</classname>&lt; char &gt;</type></typedef>
<typedef name="wbufferbuf"><type><classname>basic_bufferbuf</classname>&lt; wchar_t &gt;</type></typedef>
<typedef name="wbufferstream"><type><classname>basic_bufferstream</classname>&lt; wchar_t &gt;</type></typedef>
<typedef name="wibufferstream"><type><classname>basic_ibufferstream</classname>&lt; wchar_t &gt;</type></typedef>
<typedef name="wobufferstream"><type><classname>basic_obufferstream</classname>&lt; wchar_t &gt;</type></typedef>

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/streams/vectorstream.hpp">
<para>This file defines basic_vectorbuf, basic_ivectorstream, basic_ovectorstream, and basic_vectorstreamclasses. These classes represent streamsbufs and streams whose sources or destinations are STL-like vectors that can be swapped with external vectors to avoid unnecessary allocations/copies. </para><namespace name="boost">
<namespace name="interprocess">
<class name="basic_ivectorstream"><template>
      <template-type-parameter name="CharVector"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_istream&lt; CharVector::value_type, CharTraits &gt;</inherit><description><para>A basic_istream class that holds a character vector specified by CharVector template parameter as its formatting buffer. The vector must have contiguous storage, like std::vector, boost::interprocess::vector or boost::interprocess::basic_string </para></description><typedef name="vector_type"><type>CharVector</type></typedef>
<typedef name="char_type"><type>std::basic_ios&lt; typename CharVector::value_type, CharTraits &gt;::char_type</type></typedef>
<typedef name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef>
<typedef name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef>
<typedef name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef>
<typedef name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef>
<method-group name="public member functions">
<method name="rdbuf" cv="const"><type><classname>basic_vectorbuf</classname>&lt; CharVector, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method>
<method name="swap_vector"><type>void</type><parameter name="vect"><paramtype>vector_type &amp;</paramtype></parameter><description><para>Swaps the underlying vector with the passed vector. This function resets the read position in the stream. Does not throw. </para></description></method>
<method name="vector" cv="const"><type>const vector_type &amp;</type><description><para>Returns a const reference to the internal vector. Does not throw. </para></description></method>
<method name="reserve"><type>void</type><parameter name="size"><paramtype>typename vector_type::size_type</paramtype></parameter><description><para>Calls reserve() method of the internal vector. Resets the stream to the first position. Throws if the internals vector's reserve throws. </para></description></method>
<method name="clear"><type>void</type><description><para>Calls clear() method of the internal vector. Resets the stream to the first position. </para></description></method>
</method-group>
<constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in</default></parameter><description><para>Constructor. Throws if vector_type default constructor throws. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="VectorParameter"/>
        </template><parameter name="param"><paramtype>const VectorParameter &amp;</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in</default></parameter><description><para>Constructor. Throws if vector_type(const VectorParameter &amp;param) throws. </para></description></constructor>
</class><class name="basic_ovectorstream"><template>
      <template-type-parameter name="CharVector"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_ostream&lt; CharVector::value_type, CharTraits &gt;</inherit><description><para>A basic_ostream class that holds a character vector specified by CharVector template parameter as its formatting buffer. The vector must have contiguous storage, like std::vector, boost::interprocess::vector or boost::interprocess::basic_string </para></description><typedef name="vector_type"><type>CharVector</type></typedef>
<typedef name="char_type"><type>std::basic_ios&lt; typename CharVector::value_type, CharTraits &gt;::char_type</type></typedef>
<typedef name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef>
<typedef name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef>
<typedef name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef>
<typedef name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef>
<method-group name="public member functions">
<method name="rdbuf" cv="const"><type><classname>basic_vectorbuf</classname>&lt; CharVector, CharTraits &gt; *</type><description><para>Returns the address of the stored stream buffer. </para></description></method>
<method name="swap_vector"><type>void</type><parameter name="vect"><paramtype>vector_type &amp;</paramtype></parameter><description><para>Swaps the underlying vector with the passed vector. This function resets the write position in the stream. Does not throw. </para></description></method>
<method name="vector" cv="const"><type>const vector_type &amp;</type><description><para>Returns a const reference to the internal vector. Does not throw. </para></description></method>
<method name="reserve"><type>void</type><parameter name="size"><paramtype>typename vector_type::size_type</paramtype></parameter><description><para>Calls reserve() method of the internal vector. Resets the stream to the first position. Throws if the internals vector's reserve throws. </para></description></method>
</method-group>
<constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type default constructor throws. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="VectorParameter"/>
        </template><parameter name="param"><paramtype>const VectorParameter &amp;</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type(const VectorParameter &amp;param) throws. </para></description></constructor>
</class><class name="basic_vectorbuf"><template>
      <template-type-parameter name="CharVector"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_streambuf&lt; CharVector::value_type, CharTraits &gt;</inherit><description><para>A streambuf class that controls the transmission of elements to and from a <classname alt="boost::interprocess::basic_ivectorstream">basic_ivectorstream</classname>, <classname alt="boost::interprocess::basic_ovectorstream">basic_ovectorstream</classname> or <classname alt="boost::interprocess::basic_vectorstream">basic_vectorstream</classname>. It holds a character vector specified by CharVector template parameter as its formatting buffer. The vector must have contiguous storage, like std::vector, boost::interprocess::vector or boost::interprocess::basic_string </para></description><typedef name="vector_type"><type>CharVector</type></typedef>
<typedef name="char_type"><type>CharVector::value_type</type></typedef>
<typedef name="int_type"><type>CharTraits::int_type</type></typedef>
<typedef name="pos_type"><type>CharTraits::pos_type</type></typedef>
<typedef name="off_type"><type>CharTraits::off_type</type></typedef>
<typedef name="traits_type"><type>CharTraits</type></typedef>
<method-group name="public member functions">
<method name="swap_vector"><type>void</type><parameter name="vect"><paramtype>vector_type &amp;</paramtype></parameter><description><para>Swaps the underlying vector with the passed vector. This function resets the read/write position in the stream. Does not throw. </para></description></method>
<method name="vector" cv="const"><type>const vector_type &amp;</type><description><para>Returns a const reference to the internal vector. Does not throw. </para></description></method>
<method name="reserve"><type>void</type><parameter name="size"><paramtype>typename vector_type::size_type</paramtype></parameter><description><para>Preallocates memory from the internal vector. Resets the stream to the first position. Throws if the internals vector's memory allocation throws. </para></description></method>
<method name="clear"><type>void</type><description><para>Calls clear() method of the internal vector. Resets the stream to the first position. </para></description></method>
</method-group>
<constructor specifiers="explicit"><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type default constructor throws. </para></description></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="VectorParameter"/>
        </template><parameter name="param"><paramtype>const VectorParameter &amp;</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type(const VectorParameter &amp;param) throws. </para></description></constructor>
</class><class name="basic_vectorstream"><template>
      <template-type-parameter name="CharVector"/>
      <template-type-parameter name="CharTraits"/>
    </template><inherit access="public">std::basic_iostream&lt; CharVector::value_type, CharTraits &gt;</inherit><description><para>A basic_iostream class that holds a character vector specified by CharVector template parameter as its formatting buffer. The vector must have contiguous storage, like std::vector, boost::interprocess::vector or boost::interprocess::basic_string </para></description><typedef name="vector_type"><type>CharVector</type></typedef>
<typedef name="char_type"><type>std::basic_ios&lt; typename CharVector::value_type, CharTraits &gt;::char_type</type></typedef>
<typedef name="int_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::int_type</type></typedef>
<typedef name="pos_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::pos_type</type></typedef>
<typedef name="off_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::off_type</type></typedef>
<typedef name="traits_type"><type>std::basic_ios&lt; char_type, CharTraits &gt;::traits_type</type></typedef>
<method-group name="public member functions">
<method name="rdbuf" cv="const"><type><classname>basic_vectorbuf</classname>&lt; CharVector, CharTraits &gt; *</type></method>
<method name="swap_vector"><type>void</type><parameter name="vect"><paramtype>vector_type &amp;</paramtype></parameter><description><para>Swaps the underlying vector with the passed vector. This function resets the read/write position in the stream. Does not throw. </para></description></method>
<method name="vector" cv="const"><type>const vector_type &amp;</type><description><para>Returns a const reference to the internal vector. Does not throw. </para></description></method>
<method name="reserve"><type>void</type><parameter name="size"><paramtype>typename vector_type::size_type</paramtype></parameter><description><para>Calls reserve() method of the internal vector. Resets the stream to the first position. Throws if the internals vector's reserve throws. </para></description></method>
<method name="clear"><type>void</type><description><para>Calls clear() method of the internal vector. Resets the stream to the first position. </para></description></method>
</method-group>
<constructor><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type default constructor throws. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="VectorParameter"/>
        </template><parameter name="param"><paramtype>const VectorParameter &amp;</paramtype></parameter><parameter name="mode"><paramtype>std::ios_base::openmode</paramtype><default>std::ios_base::in|std::ios_base::out</default></parameter><description><para>Constructor. Throws if vector_type(const VectorParameter &amp;param) throws. </para></description></constructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/cv_status.hpp">
<namespace name="boost">
<namespace name="interprocess">
















































<function name="BOOST_SCOPED_ENUM_DECLARE_BEGIN"><type/><parameter name=""><paramtype>cv_status</paramtype></parameter></function>
</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/file_lock.hpp">
<para>Describes a class that wraps file locking capabilities. </para><namespace name="boost">
<namespace name="interprocess">
<class name="file_lock"><description><para>A file lock, is a mutual exclusion utility similar to a mutex using a file. A file lock has sharable and exclusive locking capabilities and can be used with <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> and <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> classes. A file lock can't guarantee synchronization between threads of the same process so just use file locks to synchronize threads from different processes. </para></description><method-group name="public member functions">
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>file_lock</classname> &amp;</paramtype></parameter><description><para>Swaps two file_locks. Does not throw. </para></description></method>
<method name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive, or sharable ownership of the mutex, it waits until it can obtain the ownership. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting. If no other thread has exclusive, or sharable ownership of the mutex this succeeds. Returns: If it can acquire exclusive ownership immediately returns true. If it has to wait, returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive, or sharable ownership of the mutex or abs_time is reached. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="unlock"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The calling thread releases the exclusive ownership of the mutex. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="lock_sharable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that owns a mutex object calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="lock_shared"><type>void</type><description><para>Same as <computeroutput>lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="try_lock_sharable"><type>bool</type><description><para>Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting. If no other thread has exclusive ownership of the mutex this succeeds. Returns: If it can acquire sharable ownership immediately returns true. If it has to wait, returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="try_lock_shared"><type>bool</type><description><para>Same as <computeroutput>try_lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="timed_lock_sharable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached. Returns: If acquires sharable ownership, returns true. Otherwise returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="try_lock_shared_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_shared_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="unlock_sharable"><type>void</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The calling thread releases the sharable ownership of the mutex. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="unlock_shared"><type>void</type><description><para>Same as <computeroutput>unlock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Constructs an empty file mapping. Does not throw </para></description></constructor>
<constructor><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a file lock. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> if the file does not exist or there are no operating system resources. </para></description></constructor>
<constructor><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a file lock. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> if the file does not exist or there are no operating system resources.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor cv="noexcept"><parameter name="moved"><paramtype><classname>file_lock</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s file mapping object to *this. After the call, "moved" does not represent any file mapping object. Does not throw </para></description></constructor>
<copy-assignment cv="noexcept"><type><classname>file_lock</classname> &amp;</type><parameter name="moved"><paramtype><classname>file_lock</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s file mapping to *this. After the call, "moved" does not represent any file mapping. Does not throw </para></description></copy-assignment>
<destructor><purpose>Closes a file lock. Does not throw. </purpose></destructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/interprocess_condition.hpp">
<para>Describes process-shared variables interprocess_condition class </para><namespace name="boost">
<namespace name="interprocess">
<class name="interprocess_condition"><description><para>This class is a condition variable that can be placed in shared memory or memory mapped files. Destroys the object of type std::condition_variable_any</para><para>Unlike std::condition_variable in C++11, it is NOT safe to invoke the destructor if all threads have been only notified. It is required that they have exited their respective wait functions. </para></description><method-group name="public member functions">
<method name="notify_one"><type>void</type><description><para>If there is a thread waiting on *this, change that thread's state to ready. Otherwise there is no effect. </para></description></method>
<method name="notify_all"><type>void</type><description><para>Change the state of all threads waiting on *this to ready. If there are no waiting threads, notify_all() has no effect. </para></description></method>
<method name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><description><para>Releases the lock on the <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;notify_one() or this-&gt;notify_all(), and then reacquires the lock. </para></description></method>
<method name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) wait(lock) </para></description></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Releases the lock on the <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;notify_one() or this-&gt;notify_all(), or until time abs_time is reached, and then reacquires the lock. Returns: false if time abs_time is reached, otherwise true. </para></description></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) { if (!timed_wait(lock, abs_time)) return pred(); } return true; </para></description></method>
<method name="wait_until"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="wait_until"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="wait_for"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts. </para></description></method>
<method name="wait_for"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts </para></description></method>
</method-group>
<constructor><purpose>Constructs a <classname alt="boost::interprocess::interprocess_condition">interprocess_condition</classname>. On error throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>. </purpose></constructor>
<destructor><description><para>Destroys *this liberating system resources. </para></description></destructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/interprocess_condition_any.hpp">
<para>Describes process-shared variables interprocess_condition_any class </para><namespace name="boost">
<namespace name="interprocess">
<class name="interprocess_condition_any"><description><para>This class is a condition variable that can be placed in shared memory or memory mapped files.</para><para>The <classname alt="boost::interprocess::interprocess_condition_any">interprocess_condition_any</classname> class is a generalization of <classname alt="boost::interprocess::interprocess_condition">interprocess_condition</classname>. Whereas <classname alt="boost::interprocess::interprocess_condition">interprocess_condition</classname> works only on Locks with mutex_type == <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> <classname alt="boost::interprocess::interprocess_condition_any">interprocess_condition_any</classname> can operate on any user-defined lock that meets the BasicLockable requirements (lock()/unlock() member functions).</para><para>Unlike std::condition_variable_any in C++11, it is NOT safe to invoke the destructor if all threads have been only notified. It is required that they have exited their respective wait functions. </para></description><method-group name="public member functions">
<method name="notify_one"><type>void</type><description><para>If there is a thread waiting on *this, change that thread's state to ready. Otherwise there is no effect. </para></description></method>
<method name="notify_all"><type>void</type><description><para>Change the state of all threads waiting on *this to ready. If there are no waiting threads, notify_all() has no effect. </para></description></method>
<method name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><description><para>Releases the lock on the <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;notify_one() or this-&gt;notify_all(), and then reacquires the lock. </para></description></method>
<method name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) wait(lock) </para></description></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Releases the lock on the <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;notify_one() or this-&gt;notify_all(), or until time abs_time is reached, and then reacquires the lock. Returns: false if time abs_time is reached, otherwise true. </para></description></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) { if (!timed_wait(lock, abs_time)) return pred(); } return true; </para></description></method>
<method name="wait_until"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="wait_until"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="wait_for"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts. </para></description></method>
<method name="wait_for"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts </para></description></method>
</method-group>
<constructor><purpose>Constructs a <classname alt="boost::interprocess::interprocess_condition_any">interprocess_condition_any</classname>. On error throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>. </purpose></constructor>
<destructor><description><para>Destroys *this liberating system resources. </para></description></destructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/interprocess_mutex.hpp">
<para>Describes a mutex class that can be placed in memory shared by several processes. </para><namespace name="boost">
<namespace name="interprocess">
<class name="interprocess_mutex"><description><para>Wraps a <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> that can be placed in shared memory and can be shared between processes. Allows timed lock tries </para></description><method-group name="public member functions">
<method name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex, it waits until it can obtain the ownership. If a thread takes ownership of the mutex the mutex must be unlocked by the same mutex. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex returns immediately. Returns: If the thread acquires ownership of the mutex, returns true, if the another thread has ownership of the mutex, returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread will try to obtain exclusive ownership of the mutex if it can do so in until the specified time is reached. If the mutex supports recursive locking, the mutex must be unlocked the same number of times it is locked. Returns: If the thread acquires ownership of the mutex, returns true, if the timeout expires returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="unlock"><type>void</type><description><para>Effects: The calling thread releases the exclusive ownership of the mutex. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
</method-group>
<constructor><description><para>Constructor. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></constructor>
<destructor><description><para>Destructor. If any process uses the mutex after the destructor is called the result is undefined. Does not throw. </para></description></destructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/interprocess_recursive_mutex.hpp">
<para>Describes interprocess_recursive_mutex and shared_recursive_try_mutex classes </para><namespace name="boost">
<namespace name="interprocess">
<class name="interprocess_recursive_mutex"><description><para>Wraps a <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> that can be placed in shared memory and can be shared between processes. Allows several locking calls by the same process. Allows timed lock tries </para></description><method-group name="public member functions">
<method name="lock"><type>void</type><description><para>Effects: The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex, it waits until it can obtain the ownership. If a thread takes ownership of the mutex the mutex must be unlocked by the same mutex. The mutex must be unlocked the same number of times it is locked. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program shall not deadlock if the thread that has ownership calls this function. </para></description></method>
<method name="try_lock"><type>bool</type><description><para>Tries to lock the <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname>, returns false when <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> is already locked, returns true when success. The mutex must be unlocked the same number of times it is locked. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> if a severe error is found</para><para>Note: A program shall not deadlock if the thread that has ownership calls this function. </para></description></method>
<method name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Tries to lock the <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname>, if <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> can't be locked before abs_time time, returns false. The mutex must be unlocked the same number of times it is locked. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> if a severe error is found</para><para>Note: A program shall not deadlock if the thread that has ownership calls this function. </para></description></method>
<method name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="unlock"><type>void</type><description><para>Effects: The calling thread releases the exclusive ownership of the mutex. If the mutex supports recursive locking, the mutex must be unlocked the same number of times it is locked. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
</method-group>
<constructor><description><para>Constructor. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></constructor>
<destructor><description><para>Destructor. If any process uses the mutex after the destructor is called the result is undefined. Does not throw. </para></description></destructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/interprocess_semaphore.hpp">
<para>Describes a interprocess_semaphore class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class name="interprocess_semaphore"><description><para>Wraps a <classname alt="boost::interprocess::interprocess_semaphore">interprocess_semaphore</classname> that can be placed in shared memory and can be shared between processes. Allows timed lock tries </para></description><method-group name="public member functions">
<method name="post"><type>void</type><description><para>Increments the <classname alt="boost::interprocess::interprocess_semaphore">interprocess_semaphore</classname> count. If there are processes/threads blocked waiting for the <classname alt="boost::interprocess::interprocess_semaphore">interprocess_semaphore</classname>, then one of these processes will return successfully from its wait function. If there is an error an <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> exception is thrown. </para></description></method>
<method name="wait"><type>void</type><description><para>Decrements the <classname alt="boost::interprocess::interprocess_semaphore">interprocess_semaphore</classname>. If the <classname alt="boost::interprocess::interprocess_semaphore">interprocess_semaphore</classname> value is not greater than zero, then the calling process/thread blocks until it can decrement the counter. If there is an error an <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> exception is thrown. </para></description></method>
<method name="try_wait"><type>bool</type><description><para>Decrements the <classname alt="boost::interprocess::interprocess_semaphore">interprocess_semaphore</classname> if the <classname alt="boost::interprocess::interprocess_semaphore">interprocess_semaphore</classname>'s value is greater than zero and returns true. If the value is not greater than zero returns false. If there is an error an <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> exception is thrown. </para></description></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Decrements the <classname alt="boost::interprocess::interprocess_semaphore">interprocess_semaphore</classname> if the <classname alt="boost::interprocess::interprocess_semaphore">interprocess_semaphore</classname>'s value is greater than zero and returns true. Otherwise, waits for the <classname alt="boost::interprocess::interprocess_semaphore">interprocess_semaphore</classname> to the posted or the timeout expires. If the timeout expires, the function returns false. If the <classname alt="boost::interprocess::interprocess_semaphore">interprocess_semaphore</classname> is posted the function returns true. If there is an error throws sem_exception </para></description></method>
</method-group>
<constructor><parameter name="initialCount"><paramtype>unsigned int</paramtype></parameter><description><para>Creates a <classname alt="boost::interprocess::interprocess_semaphore">interprocess_semaphore</classname> with the given initial count. <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> if there is an error. </para></description></constructor>
<destructor><description><para>Destroys the <classname alt="boost::interprocess::interprocess_semaphore">interprocess_semaphore</classname>. Does not throw </para></description></destructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/interprocess_sharable_mutex.hpp">
<para>Describes interprocess_sharable_mutex class </para><namespace name="boost">
<namespace name="interprocess">
<class name="interprocess_sharable_mutex"><description><para>Wraps a <classname alt="boost::interprocess::interprocess_sharable_mutex">interprocess_sharable_mutex</classname> that can be placed in shared memory and can be shared between processes. Allows timed lock tries </para></description><method-group name="private member functions">
</method-group>
<constructor><parameter name=""><paramtype>const <classname>interprocess_sharable_mutex</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>interprocess_sharable_mutex</classname> &amp;</type><parameter name=""><paramtype>const <classname>interprocess_sharable_mutex</classname> &amp;</paramtype></parameter></copy-assignment>
<method-group name="public member functions">
<method name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive or sharable ownership of the mutex, it waits until it can obtain the ownership. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting. If no other thread has exclusive or sharable ownership of the mutex this succeeds. Returns: If it can acquire exclusive ownership immediately returns true. If it has to wait, returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive or sharable ownership of the mutex or abs_time is reached. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="unlock"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The calling thread releases the exclusive ownership of the mutex. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="lock_sharable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="lock_shared"><type>void</type><description><para>Same as <computeroutput>lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="try_lock_sharable"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting. If no other thread has exclusive ownership of the mutex this succeeds. Returns: If it can acquire sharable ownership immediately returns true. If it has to wait, returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock_shared"><type>bool</type><description><para>Same as <computeroutput>try_lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="timed_lock_sharable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached. Returns: If acquires sharable ownership, returns true. Otherwise returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock_shared_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_shared_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="unlock_sharable"><type>void</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The calling thread releases the sharable ownership of the mutex. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="unlock_shared"><type>void</type><description><para>Same as <computeroutput>unlock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
</method-group>
<constructor><description><para>Constructs the sharable lock. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></constructor>
<destructor><description><para>Destroys the sharable lock. Does not throw. </para></description></destructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/interprocess_upgradable_mutex.hpp">
<para>Describes interprocess_upgradable_mutex class </para><namespace name="boost">
<namespace name="interprocess">
<class name="interprocess_upgradable_mutex"><description><para>Wraps a <classname alt="boost::interprocess::interprocess_upgradable_mutex">interprocess_upgradable_mutex</classname> that can be placed in shared memory and can be shared between processes. Allows timed lock tries </para></description><method-group name="private member functions">
</method-group>
<constructor><parameter name=""><paramtype>const <classname>interprocess_upgradable_mutex</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>interprocess_upgradable_mutex</classname> &amp;</type><parameter name=""><paramtype>const <classname>interprocess_upgradable_mutex</classname> &amp;</paramtype></parameter></copy-assignment>
<method-group name="public member functions">
<method name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive, sharable or upgradable ownership of the mutex, it waits until it can obtain the ownership. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting. If no other thread has exclusive, sharable or upgradable ownership of the mutex this succeeds. Returns: If it can acquire exclusive ownership immediately returns true. If it has to wait, returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive, sharable or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="unlock"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The calling thread releases the exclusive ownership of the mutex. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="lock_sharable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="lock_shared"><type>void</type><description><para>Same as <computeroutput>lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="try_lock_sharable"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting. If no other thread has exclusive ownership of the mutex this succeeds. Returns: If it can acquire sharable ownership immediately returns true. If it has to wait, returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock_shared"><type>bool</type><description><para>Same as <computeroutput>try_lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="timed_lock_sharable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached. Returns: If acquires sharable ownership, returns true. Otherwise returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock_shared_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_shared_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="unlock_sharable"><type>void</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The calling thread releases the sharable ownership of the mutex. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="unlock_shared"><type>void</type><description><para>Same as <computeroutput>unlock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="lock_upgradable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain upgradable ownership of the mutex, and if another thread has exclusive or upgradable ownership of the mutex, waits until it can obtain the ownership. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock_upgradable"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire upgradable ownership of the mutex without waiting. If no other thread has exclusive or upgradable ownership of the mutex this succeeds. Returns: If it can acquire upgradable ownership immediately returns true. If it has to wait, returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="timed_lock_upgradable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire upgradable ownership of the mutex waiting if necessary until no other thread has exclusive or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires upgradable ownership, returns true. Otherwise returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="unlock_upgradable"><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The calling thread releases the upgradable ownership of the mutex. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="unlock_and_lock_upgradable"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The thread atomically releases exclusive ownership and acquires upgradable ownership. This operation is non-blocking. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="unlock_and_lock_sharable"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The thread atomically releases exclusive ownership and acquires sharable ownership. This operation is non-blocking. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="unlock_upgradable_and_lock_sharable"><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and acquires sharable ownership. This operation is non-blocking. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="unlock_upgradable_and_lock"><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and acquires exclusive ownership. This operation will block until all threads with sharable ownership release their sharable lock. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="try_unlock_upgradable_and_lock"><type>bool</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership. This operation will fail if there are threads with sharable ownership, but it will maintain upgradable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="timed_unlock_upgradable_and_lock"><type>*bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership, waiting if necessary until abs_time. This operation will fail if there are threads with sharable ownership or timeout reaches, but it will maintain upgradable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="try_unlock_sharable_and_lock"><type>bool</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The thread atomically releases sharable ownership and tries to acquire exclusive ownership. This operation will fail if there are threads with sharable or upgradable ownership, but it will maintain sharable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="try_unlock_sharable_and_lock_upgradable"><type>bool</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The thread atomically releases sharable ownership and tries to acquire upgradable ownership. This operation will fail if there are threads with sharable or upgradable ownership, but it will maintain sharable ownership. Returns: If acquires upgradable ownership, returns true. Otherwise returns false. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
</method-group>
<constructor><description><para>Constructs the upgradable lock. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></constructor>
<destructor><description><para>Destroys the upgradable lock. Does not throw. </para></description></destructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/lock_options.hpp">
<para>Describes the lock options with associated with interprocess_mutex lock constructors. </para><namespace name="boost">
<namespace name="interprocess">
<struct name="accept_ownership_type"><purpose>Type to indicate to a mutex lock constructor that the mutex is already locked. </purpose></struct><struct name="defer_lock_type"><purpose>Type to indicate to a mutex lock constructor that must not lock the mutex. </purpose></struct><struct name="try_to_lock_type"><purpose>Type to indicate to a mutex lock constructor that must try to lock the mutex. </purpose></struct><data-member name="defer_lock" specifiers="static"><type>const <classname>defer_lock_type</classname></type><description><para>An object indicating that the locking must be deferred. </para></description></data-member>
<data-member name="try_to_lock" specifiers="static"><type>const <classname>try_to_lock_type</classname></type><description><para>An object indicating that a try_lock() operation must be executed. </para></description></data-member>
<data-member name="accept_ownership" specifiers="static"><type>const <classname>accept_ownership_type</classname></type><description><para>An object indicating that the ownership of lockable object must be accepted by the new owner. </para></description></data-member>

















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/mutex_family.hpp">
<para>Describes a shared interprocess_mutex family fit algorithm used to allocate objects in shared memory. </para><namespace name="boost">
<namespace name="interprocess">
<struct name="mutex_family"><description><para>Describes <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> family to use with Interprocess framework based on boost::interprocess synchronization objects. </para></description><typedef name="mutex_type"><type><classname>boost::interprocess::interprocess_mutex</classname></type></typedef>
<typedef name="recursive_mutex_type"><type><classname>boost::interprocess::interprocess_recursive_mutex</classname></type></typedef>
</struct><struct name="null_mutex_family"><description><para>Describes <classname alt="boost::interprocess::interprocess_mutex">interprocess_mutex</classname> family to use with Interprocess frameworks based on null operation synchronization objects. </para></description><typedef name="mutex_type"><type><classname>boost::interprocess::null_mutex</classname></type></typedef>
<typedef name="recursive_mutex_type"><type><classname>boost::interprocess::null_mutex</classname></type></typedef>
</struct>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/named_condition.hpp">
<para>Describes a named condition class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class name="named_condition"><description><para>A global condition variable that can be created by name. This condition variable is designed to work with <classname alt="boost::interprocess::named_mutex">named_mutex</classname> and can't be placed in shared memory or memory mapped files. </para></description><method-group name="public member functions">
<method name="notify_one"><type>*void</type><description><para>If there is a thread waiting on *this, change that thread's state to ready. Otherwise there is no effect. </para></description></method>
<method name="notify_all"><type>void</type><description><para>Change the state of all threads waiting on *this to ready. If there are no waiting threads, notify_all() has no effect. </para></description></method>
<method name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><description><para>Releases the lock on the <classname alt="boost::interprocess::named_mutex">named_mutex</classname> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;notify_one() or this-&gt;notify_all(), and then reacquires the lock. </para></description></method>
<method name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) wait(lock) </para></description></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Releases the lock on the <classname alt="boost::interprocess::named_mutex">named_mutex</classname> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;notify_one() or this-&gt;notify_all(), or until time abs_time is reached, and then reacquires the lock. Returns: false if time abs_time is reached, otherwise true. </para></description></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) { if (!timed_wait(lock, abs_time)) return pred(); } return true; </para></description></method>
<method name="wait_until"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="wait_until"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="wait_for"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts. </para></description></method>
<method name="wait_for"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts </para></description></method>
</method-group>
<constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a global condition with a name. If the condition can't be created throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> </para></description></constructor>
<constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global condition with a name. If the condition is created, this call is equivalent to named_condition(create_only_t, ... ) If the condition is already created, this call is equivalent named_condition(open_only_t, ... ) Does not throw </para></description></constructor>
<constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global condition with a name if that condition is previously created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>. </para></description></constructor>
<constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens a global condition with a name if that condition is previously created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>. Creates a global condition with a name. If the condition can't be created throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname></para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global condition with a name. If the condition is created, this call is equivalent to named_condition(create_only_t, ... ) If the condition is already created, this call is equivalent named_condition(open_only_t, ... ) Does not throw</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global condition with a name if that condition is previously created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor>
<method-group name="public static functions">
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named condition from the system. Returns false on error. Never throws. </para></description></method>
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named condition from the system. Returns false on error. Never throws.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/named_condition_any.hpp">
<para>Describes a named condition class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class name="named_condition_any"><description><para>A global condition variable that can be created by name. This condition variable is designed to work with <classname alt="boost::interprocess::named_mutex">named_mutex</classname> and can't be placed in shared memory or memory mapped files. </para></description><method-group name="public member functions">
<method name="notify_one"><type>*void</type><description><para>If there is a thread waiting on *this, change that thread's state to ready. Otherwise there is no effect. </para></description></method>
<method name="notify_all"><type>void</type><description><para>Change the state of all threads waiting on *this to ready. If there are no waiting threads, notify_all() has no effect. </para></description></method>
<method name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><description><para>Releases the lock on the <classname alt="boost::interprocess::named_mutex">named_mutex</classname> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;notify_one() or this-&gt;notify_all(), and then reacquires the lock. </para></description></method>
<method name="wait"><type>void</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) wait(lock) </para></description></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Releases the lock on the <classname alt="boost::interprocess::named_mutex">named_mutex</classname> object associated with lock, blocks the current thread of execution until readied by a call to this-&gt;notify_one() or this-&gt;notify_all(), or until time abs_time is reached, and then reacquires the lock. Returns: false if time abs_time is reached, otherwise true. </para></description></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>The same as: while (!pred()) { if (!timed_wait(lock, abs_time)) return pred(); } return true; </para></description></method>
<method name="wait_until"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="wait_until"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="TimePoint"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="wait_for"><type>cv_status</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts. </para></description></method>
<method name="wait_for"><type>bool</type><template>
          <template-type-parameter name="L"/>
          <template-type-parameter name="Duration"/>
          <template-type-parameter name="Pr"/>
        </template><parameter name="lock"><paramtype>L &amp;</paramtype></parameter><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><parameter name="pred"><paramtype>Pr</paramtype></parameter><description><para>Same as <computeroutput>timed_wait</computeroutput>, but this function is modeled after the standard library interface and uses relative timeouts </para></description></method>
</method-group>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a global condition with a name. If the condition can't be created throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global condition with a name. If the condition is created, this call is equivalent to named_condition_any(create_only_t, ... ) If the condition is already created, this call is equivalent named_condition_any(open_only_t, ... ) Does not throw </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global condition with a name if that condition is previously created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a global condition with a name. If the condition can't be created throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname></para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global condition with a name. If the condition is created, this call is equivalent to named_condition_any(create_only_t, ... ) If the condition is already created, this call is equivalent named_condition_any(open_only_t, ... ) Does not throw</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global condition with a name if that condition is previously created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor>
<method-group name="public static functions">
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named condition from the system. Returns false on error. Never throws. </para></description></method>
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named condition from the system. Returns false on error. Never throws.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/named_mutex.hpp">
<para>Describes a named mutex class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class name="named_mutex"><description><para>A mutex with a global name, so it can be found from different processes. This mutex can't be placed in shared memory, and each process should have it's own <classname alt="boost::interprocess::named_mutex">named_mutex</classname>. </para></description><method-group name="public member functions">
<method name="unlock"><type>void</type><description><para>Unlocks a previously locked mutex. </para></description></method>
<method name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Locks the mutex, sleeps when the mutex is already locked. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> if a severe error is found</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Tries to lock the mutex, returns false when the mutex is already locked, returns true when success. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> if a severe error is found</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Tries to lock the the mutex until time abs_time, Returns false when timeout expires, returns true when locks. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> if a severe error is found</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
</method-group>
<constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a global mutex with a name. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></constructor>
<constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global mutex with a name. If the mutex is created, this call is equivalent to named_mutex(create_only_t, ... ) If the mutex is already created, this call is equivalent named_mutex(open_only_t, ... ) Does not throw </para></description></constructor>
<constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global mutex with a name if that mutex is previously created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>. </para></description></constructor>
<constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a global mutex with a name. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global mutex with a name. If the mutex is created, this call is equivalent to named_mutex(create_only_t, ... ) If the mutex is already created, this call is equivalent named_mutex(open_only_t, ... ) Does not throw</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global mutex with a name if that mutex is previously created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor>
<method-group name="public static functions">
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named mutex from the system. Returns false on error. Never throws. </para></description></method>
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named mutex from the system. Returns false on error. Never throws.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/named_recursive_mutex.hpp">
<para>Describes a named named_recursive_mutex class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class name="named_recursive_mutex"><description><para>A recursive mutex with a global name, so it can be found from different processes. This mutex can't be placed in shared memory, and each process should have it's own <classname alt="boost::interprocess::named_recursive_mutex">named_recursive_mutex</classname>. </para></description><method-group name="public member functions">
<method name="unlock"><type>void</type><description><para>Unlocks a previously locked <classname alt="boost::interprocess::named_recursive_mutex">named_recursive_mutex</classname>. </para></description></method>
<method name="lock"><type>void</type><description><para>Locks <classname alt="boost::interprocess::named_recursive_mutex">named_recursive_mutex</classname>, sleeps when <classname alt="boost::interprocess::named_recursive_mutex">named_recursive_mutex</classname> is already locked. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> if a severe error is found.</para><para>Note: A program shall not deadlock if the thread that has ownership calls this function. </para></description></method>
<method name="try_lock"><type>bool</type><description><para>Tries to lock the <classname alt="boost::interprocess::named_recursive_mutex">named_recursive_mutex</classname>, returns false when <classname alt="boost::interprocess::named_recursive_mutex">named_recursive_mutex</classname> is already locked, returns true when success. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> if a severe error is found.</para><para>Note: A program shall not deadlock if the thread that has ownership calls this function. </para></description></method>
<method name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Tries to lock the <classname alt="boost::interprocess::named_recursive_mutex">named_recursive_mutex</classname> until time abs_time, Returns false when timeout expires, returns true when locks. Throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> if a severe error is found</para><para>Note: A program shall not deadlock if the thread that has ownership calls this function. </para></description></method>
<method name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
</method-group>
<constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a global recursive_mutex with a name. If the recursive_mutex can't be created throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> </para></description></constructor>
<constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global recursive_mutex with a name. If the recursive_mutex is created, this call is equivalent to named_recursive_mutex(create_only_t, ... ) If the recursive_mutex is already created, this call is equivalent named_recursive_mutex(open_only_t, ... ) Does not throw </para></description></constructor>
<constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global recursive_mutex with a name if that recursive_mutex is previously created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>. </para></description></constructor>
<constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a global recursive_mutex with a name. If the recursive_mutex can't be created throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname></para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global recursive_mutex with a name. If the recursive_mutex is created, this call is equivalent to named_recursive_mutex(create_only_t, ... ) If the recursive_mutex is already created, this call is equivalent named_recursive_mutex(open_only_t, ... ) Does not throw</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global recursive_mutex with a name if that recursive_mutex is previously created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor>
<method-group name="public static functions">
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named recursive mutex from the system </para></description></method>
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named recursive mutex from the system</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/named_semaphore.hpp">
<para>Describes a named semaphore class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class name="named_semaphore"><description><para>A semaphore with a global name, so it can be found from different processes. Allows several resource sharing patterns and efficient acknowledgment mechanisms. </para></description><method-group name="public member functions">
<method name="post"><type>void</type><description><para>Increments the semaphore count. If there are processes/threads blocked waiting for the semaphore, then one of these processes will return successfully from its wait function. If there is an error an <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> exception is thrown. </para></description></method>
<method name="wait"><type>void</type><description><para>Decrements the semaphore. If the semaphore value is not greater than zero, then the calling process/thread blocks until it can decrement the counter. If there is an error an <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> exception is thrown. </para></description></method>
<method name="try_wait"><type>bool</type><description><para>Decrements the semaphore if the semaphore's value is greater than zero and returns true. If the value is not greater than zero returns false. If there is an error an <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> exception is thrown. </para></description></method>
<method name="timed_wait"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Decrements the semaphore if the semaphore's value is greater than zero and returns true. Otherwise, waits for the semaphore to the posted or the timeout expires. If the timeout expires, the function returns false. If the semaphore is posted the function returns true. If there is an error throws sem_exception </para></description></method>
</method-group>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="initialCount"><paramtype>unsigned int</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a global semaphore with a name, and an initial count. If the semaphore can't be created throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="initialCount"><paramtype>unsigned int</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global semaphore with a name, and an initial count. If the semaphore is created, this call is equivalent to named_semaphore(create_only_t, ...) If the semaphore is already created, this call is equivalent to named_semaphore(open_only_t, ... ) and initialCount is ignored. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global semaphore with a name if that semaphore is previously. created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="initialCount"><paramtype>unsigned int</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a global semaphore with a name, and an initial count. If the semaphore can't be created throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname></para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="initialCount"><paramtype>unsigned int</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global semaphore with a name, and an initial count. If the semaphore is created, this call is equivalent to named_semaphore(create_only_t, ...) If the semaphore is already created, this call is equivalent to named_semaphore(open_only_t, ... ) and initialCount is ignored.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global semaphore with a name if that semaphore is previously. created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor>
<method-group name="public static functions">
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named semaphore from the system. Returns false on error. Never throws. </para></description></method>
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named semaphore from the system. Returns false on error. Never throws.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/named_sharable_mutex.hpp">
<para>Describes a named sharable mutex class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class name="named_sharable_mutex"><description><para>A sharable mutex with a global name, so it can be found from different processes. This mutex can't be placed in shared memory, and each process should have it's own named sharable mutex. </para></description><method-group name="public member functions">
<method name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive or sharable ownership of the mutex, it waits until it can obtain the ownership. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting. If no other thread has exclusive or sharable ownership of the mutex this succeeds. Returns: If it can acquire exclusive ownership immediately returns true. If it has to wait, returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive, or sharable ownership of the mutex or abs_time is reached. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown. </para></description></method>
<method name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="unlock"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The calling thread releases the exclusive ownership of the mutex. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="lock_sharable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method name="lock_shared"><type>void</type><description><para>Same as <computeroutput>lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="try_lock_sharable"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting. If no other thread has exclusive ownership of the mutex this succeeds. Returns: If it can acquire sharable ownership immediately returns true. If it has to wait, returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method name="try_lock_shared"><type>bool</type><description><para>Same as <computeroutput>try_lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="timed_lock_sharable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached. Returns: If acquires sharable ownership, returns true. Otherwise returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method name="try_lock_shared_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_shared_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="unlock_sharable"><type>void</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The calling thread releases the sharable ownership of the mutex. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="unlock_shared"><type>void</type><description><para>Same as <computeroutput>unlock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
</method-group>
<constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a global sharable mutex with a name. If the sharable mutex can't be created throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> </para></description></constructor>
<constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global sharable mutex with a name. If the sharable mutex is created, this call is equivalent to named_sharable_mutex(create_only_t, ...) If the sharable mutex is already created, this call is equivalent to named_sharable_mutex(open_only_t, ... ). </para></description></constructor>
<constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global sharable mutex with a name if that sharable mutex is previously. created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>. </para></description></constructor>
<constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a global sharable mutex with a name. If the sharable mutex can't be created throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname></para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global sharable mutex with a name. If the sharable mutex is created, this call is equivalent to named_sharable_mutex(create_only_t, ...) If the sharable mutex is already created, this call is equivalent to named_sharable_mutex(open_only_t, ... ).</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global sharable mutex with a name if that sharable mutex is previously. created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor>
<method-group name="public static functions">
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named sharable mutex from the system. Returns false on error. Never throws. </para></description></method>
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named sharable mutex from the system. Returns false on error. Never throws. </para></description></method>
</method-group>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/named_upgradable_mutex.hpp">
<para>Describes a named upgradable mutex class for inter-process synchronization </para><namespace name="boost">
<namespace name="interprocess">
<class name="named_upgradable_mutex"><description><para>A upgradable mutex with a global name, so it can be found from different processes. This mutex can't be placed in shared memory, and each process should have it's own named upgradable mutex. </para></description><method-group name="public member functions">
<method name="lock"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive, sharable or upgradable ownership of the mutex, it waits until it can obtain the ownership. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method name="try_lock"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting. If no other thread has exclusive, sharable or upgradable ownership of the mutex this succeeds. Returns: If it can acquire exclusive ownership immediately returns true. If it has to wait, returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive, sharable or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="unlock"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The calling thread releases the exclusive ownership of the mutex. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="lock_sharable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method name="lock_shared"><type>void</type><description><para>Same as <computeroutput>lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="try_lock_sharable"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting. If no other thread has exclusive ownership of the mutex this succeeds. Returns: If it can acquire sharable ownership immediately returns true. If it has to wait, returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method name="try_lock_shared"><type>bool</type><description><para>Same as <computeroutput>try_lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="timed_lock_sharable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached. Returns: If acquires sharable ownership, returns true. Otherwise returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method name="try_lock_shared_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_shared_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock_sharable</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="unlock_sharable"><type>void</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The calling thread releases the sharable ownership of the mutex. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="unlock_shared"><type>void</type><description><para>Same as <computeroutput>unlock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="lock_upgradable"><type>void</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to obtain upgradable ownership of the mutex, and if another thread has exclusive or upgradable ownership of the mutex, waits until it can obtain the ownership. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method name="try_lock_upgradable"><type>bool</type><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire upgradable ownership of the mutex without waiting. If no other thread has exclusive or upgradable ownership of the mutex this succeeds. Returns: If it can acquire upgradable ownership immediately returns true. If it has to wait, returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method name="timed_lock_upgradable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Requires: The calling thread does not own the mutex.</para><para>Effects: The calling thread tries to acquire upgradable ownership of the mutex waiting if necessary until no other thread has exclusive or upgradable ownership of the mutex or abs_time is reached. Returns: If acquires upgradable ownership, returns true. Otherwise returns false. Throws: <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error.</para><para>Note: A program may deadlock if the thread that has ownership calls this function. If the implementation can detect the deadlock, an exception could be thrown </para></description></method>
<method name="unlock_upgradable"><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The calling thread releases the upgradable ownership of the mutex. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="unlock_and_lock_upgradable"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The thread atomically releases exclusive ownership and acquires upgradable ownership. This operation is non-blocking. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="unlock_and_lock_sharable"><type>void</type><description><para>Precondition: The thread must have exclusive ownership of the mutex. Effects: The thread atomically releases exclusive ownership and acquires sharable ownership. This operation is non-blocking. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="unlock_upgradable_and_lock_sharable"><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and acquires sharable ownership. This operation is non-blocking. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="unlock_upgradable_and_lock"><type>void</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and acquires exclusive ownership. This operation will block until all threads with sharable ownership release it. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="try_unlock_upgradable_and_lock"><type>bool</type><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership. This operation will fail if there are threads with sharable ownership, but it will maintain upgradable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="timed_unlock_upgradable_and_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Precondition: The thread must have upgradable ownership of the mutex. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership, waiting if necessary until abs_time. This operation will fail if there are threads with sharable ownership or timeout reaches, but it will maintain upgradable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="try_unlock_sharable_and_lock"><type>bool</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The thread atomically releases sharable ownership and tries to acquire exclusive ownership. This operation will fail if there are threads with sharable or upgradable ownership, but it will maintain sharable ownership. Returns: If acquires exclusive ownership, returns true. Otherwise returns false. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
<method name="try_unlock_sharable_and_lock_upgradable"><type>bool</type><description><para>Precondition: The thread must have sharable ownership of the mutex. Effects: The thread atomically releases sharable ownership and tries to acquire upgradable ownership. This operation will fail if there are threads with sharable or upgradable ownership, but it will maintain sharable ownership. Returns: If acquires upgradable ownership, returns true. Otherwise returns false. Throws: An exception derived from <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> on error. </para></description></method>
</method-group>
<constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a global upgradable mutex with a name. If the upgradable mutex can't be created throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname> </para></description></constructor>
<constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global upgradable mutex with a name. If the upgradable mutex is created, this call is equivalent to named_upgradable_mutex(create_only_t, ...) If the upgradable mutex is already created, this call is equivalent to named_upgradable_mutex(open_only_t, ... ). </para></description></constructor>
<constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Opens a global upgradable mutex with a name if that upgradable mutex is previously. created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>. </para></description></constructor>
<constructor><parameter name="create_only"><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a global upgradable mutex with a name. If the upgradable mutex can't be created throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname></para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name="open_or_create"><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens or creates a global upgradable mutex with a name. If the upgradable mutex is created, this call is equivalent to named_upgradable_mutex(create_only_t, ...) If the upgradable mutex is already created, this call is equivalent to named_upgradable_mutex(open_only_t, ... ).</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<constructor><parameter name="open_only"><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Opens a global upgradable mutex with a name if that upgradable mutex is previously. created. If it is not previously created this function throws <classname alt="boost::interprocess::interprocess_exception">interprocess_exception</classname>.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></constructor>
<destructor><description><para>Destroys *this and indicates that the calling process is finished using the resource. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource. The resource can still be opened again calling the open constructor overload. To erase the resource from the system use remove(). </para></description></destructor>
<method-group name="public static functions">
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const char *</paramtype></parameter><description><para>Erases a named upgradable mutex from the system. Returns false on error. Never throws. </para></description></method>
<method name="remove" specifiers="static"><type>bool</type><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><description><para>Erases a named upgradable mutex from the system. Returns false on error. Never throws.</para><para>Note: This function is only available on operating systems with native wchar_t APIs (e.g. Windows). </para></description></method>
</method-group>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/null_mutex.hpp">
<para>Describes null_mutex classes </para><namespace name="boost">
<namespace name="interprocess">
<class name="null_mutex"><description><para>Implements a mutex that simulates a mutex without doing any operation and simulates a successful operation. </para></description><method-group name="public member functions">
<method name="lock"><type>void</type><purpose>Simulates a mutex lock() operation. Empty function. </purpose></method>
<method name="try_lock"><type>bool</type><description><para>Simulates a mutex try_lock() operation. Equivalent to "return true;" </para></description></method>
<method name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name=""><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Simulates a mutex timed_lock() operation. Equivalent to "return true;" </para></description></method>
<method name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name=""><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name=""><paramtype>const Duration &amp;</paramtype></parameter><description><para>Same as <computeroutput>timed_lock</computeroutput>, but this function is modeled after the standard library interface. </para></description></method>
<method name="unlock"><type>void</type><description><para>Simulates a mutex unlock() operation. Empty function. </para></description></method>
<method name="lock_sharable"><type>void</type><description><para>Simulates a mutex lock_sharable() operation. Empty function. </para></description></method>
<method name="lock_shared"><type>void</type><description><para>Same as <computeroutput>lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="try_lock_sharable"><type>bool</type><description><para>Simulates a mutex try_lock_sharable() operation. Equivalent to "return true;" </para></description></method>
<method name="try_lock_shared"><type>bool</type><description><para>Same as <computeroutput>try_lock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="timed_lock_sharable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name=""><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Simulates a mutex timed_lock_sharable() operation. Equivalent to "return true;" </para></description></method>
<method name="unlock_sharable"><type>void</type><description><para>Simulates a mutex unlock_sharable() operation. Empty function. </para></description></method>
<method name="unlock_shared"><type>void</type><description><para>Same as <computeroutput>unlock_sharable</computeroutput> but with a std-compatible interface </para></description></method>
<method name="lock_upgradable"><type>void</type><description><para>Simulates a mutex lock_upgradable() operation. Empty function. </para></description></method>
<method name="try_lock_upgradable"><type>bool</type><description><para>Simulates a mutex try_lock_upgradable() operation. Equivalent to "return true;" </para></description></method>
<method name="timed_lock_upgradable"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name=""><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Simulates a mutex timed_lock_upgradable() operation. Equivalent to "return true;" </para></description></method>
<method name="unlock_upgradable"><type>void</type><description><para>Simulates a mutex unlock_upgradable() operation. Empty function. </para></description></method>
<method name="unlock_and_lock_upgradable"><type>void</type><description><para>Simulates unlock_and_lock_upgradable(). Empty function. </para></description></method>
<method name="unlock_and_lock_sharable"><type>void</type><description><para>Simulates unlock_and_lock_sharable(). Empty function. </para></description></method>
<method name="unlock_upgradable_and_lock_sharable"><type>void</type><description><para>Simulates unlock_upgradable_and_lock_sharable(). Empty function. </para></description></method>
<method name="unlock_upgradable_and_lock"><type>void</type><description><para>Simulates unlock_upgradable_and_lock(). Empty function. </para></description></method>
<method name="try_unlock_upgradable_and_lock"><type>bool</type><description><para>Simulates try_unlock_upgradable_and_lock(). Equivalent to "return true;" </para></description></method>
<method name="timed_unlock_upgradable_and_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name=""><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Simulates timed_unlock_upgradable_and_lock(). Equivalent to "return true;" </para></description></method>
<method name="try_unlock_sharable_and_lock"><type>bool</type><description><para>Simulates try_unlock_sharable_and_lock(). Equivalent to "return true;" </para></description></method>
<method name="try_unlock_sharable_and_lock_upgradable"><type>bool</type><description><para>Simulates try_unlock_sharable_and_lock_upgradable(). Equivalent to "return true;" </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Constructor. Empty. </para></description></constructor>
<destructor><description><para>Destructor. Empty. </para></description></destructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/scoped_lock.hpp">
<para>Describes the scoped_lock class. </para><namespace name="boost">
<namespace name="interprocess">
<class name="scoped_lock"><template>
      <template-type-parameter name="Mutex"/>
    </template><description><para><classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> is meant to carry out the tasks for locking, unlocking, try-locking and timed-locking (recursive or not) for the Mutex. The Mutex need not supply all of this functionality. If the client of scoped_lock&lt;Mutex&gt; does not use functionality which the Mutex does not supply, no harm is done. Mutex ownership transfer is supported through the syntax of move semantics. Ownership transfer is allowed both by construction and assignment. The <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> does not support copy semantics. A compile time error results if copy construction or copy assignment is attempted. Mutex ownership can also be moved from an <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> and <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> via constructor. In this role, <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> shares the same functionality as a write_lock. </para></description><typedef name="mutex_type"><type>Mutex</type></typedef>
<method-group name="public member functions">
<method name="lock"><type>void</type><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls lock() on the referenced mutex. Postconditions: owns() == true. Notes: The <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> changes from a state of not owning the mutex, to owning the mutex, blocking if necessary. </para></description></method>
<method name="try_lock"><type>*bool</type><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls try_lock() on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt;try_lock(). Notes: The <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> changes from a state of not owning the mutex, to owning the mutex, but only if blocking was not required. If the mutex_type does not support try_lock(), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method>
<method name="timed_lock"><type>*bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls timed_lock(abs_time) on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt; timed_lock(abs_time). Notes: The <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership by the specified time. If the mutex_type does not support timed_lock (), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method>
<method name="try_lock_until"><type>*bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls try_lock_until(abs_time) on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt; timed_lock(abs_time). Notes: The <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership by the specified time. If the mutex_type does not support timed_lock (), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method>
<method name="try_lock_for"><type>*bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls try_lock_until(abs_time) on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt; timed_lock(abs_time). Notes: The <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership by the specified time. If the mutex_type does not support timed_lock (), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method>
<method name="unlock"><type>*void</type><description><para>Effects: If mutex() == 0 or if not locked, throws a lock_exception() exception. Calls unlock() on the referenced mutex. Postconditions: owns() == false. Notes: The <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> changes from a state of owning the mutex, to not owning the mutex. </para></description></method>
<method name="owns" cv="const noexcept"><type>bool</type><description><para>Effects: Returns true if this <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> has acquired the referenced mutex. </para></description></method>
<method name="conversion-operator" cv="const noexcept"><type>unspecified_bool_type</type><description><para>Conversion to bool. Returns owns(). </para></description></method>
<method name="mutex" cv="const noexcept"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. </para></description></method>
<method name="release" cv="noexcept"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. Postconditions: mutex() == 0 and owns() == false. </para></description></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>scoped_lock</classname>&lt; mutex_type &gt; &amp;</paramtype></parameter><description><para>Effects: Swaps state with moved lock. Throws: Nothing. </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Effects: Default constructs a <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname>. Postconditions: owns() == false and mutex() == 0. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><description><para>Effects: m.lock(). Postconditions: owns() == true and mutex() == &amp;m. Notes: The constructor will take ownership of the mutex. If another thread already owns the mutex, this thread will block until the mutex is released. Whether or not this constructor handles recursive locking depends upon the mutex. </para></description></constructor>
<constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>defer_lock_type</classname></paramtype></parameter><description><para>Postconditions: owns() == false, and mutex() == &amp;m. Notes: The constructor will not take ownership of the mutex. There is no effect required on the referenced mutex. </para></description></constructor>
<constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>accept_ownership_type</classname></paramtype></parameter><description><para>Postconditions: owns() == true, and mutex() == &amp;m. Notes: The constructor will suppose that the mutex is already locked. There is no effect required on the referenced mutex. </para></description></constructor>
<constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>try_to_lock_type</classname></paramtype></parameter><description><para>Effects: m.try_lock(). Postconditions: mutex() == &amp;m. owns() == the return value of the m.try_lock() executed within the constructor. Notes: The constructor will take ownership of the mutex if it can do so without waiting. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: m.timed_lock(abs_time). Postconditions: mutex() == &amp;m. owns() == the return value of the m.timed_lock(abs_time) executed within the constructor. Notes: The constructor will take ownership of the mutex if it can do it until abs_time is reached. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor>
<constructor cv="noexcept"><parameter name="scop"><paramtype><classname>scoped_lock</classname> &amp;&amp;</paramtype></parameter><description><para>Postconditions: mutex() == the value scop.mutex() had before the constructor executes. s1.mutex() == 0. owns() == the value of scop.owns() before the constructor executes. scop.owns(). Notes: If the scop <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> owns the mutex, ownership is moved to thisscoped_lock with no blocking. If the scop <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> does not own the mutex, then neither will this <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname>. Only a moved <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname>'s will match this signature. An non-moved <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> can be moved with the expression: "boost::move(lock);". This constructor does not alter the state of the mutex, only potentially who owns it. </para></description></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="T"/>
        </template><parameter name="upgr"><paramtype><classname>upgradable_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If upgr.owns() then calls unlock_upgradable_and_lock() on the referenced mutex. upgr.release() is called. Postconditions: mutex() == the value upgr.mutex() had before the construction. upgr.mutex() == 0. owns() == upgr.owns() before the construction. upgr.owns() == false after the construction. Notes: If upgr is locked, this constructor will lock this <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> while unlocking upgr. If upgr is unlocked, then this <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> will be unlocked as well. Only a moved <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname>'s will match this signature. An non-moved <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> can be moved with the expression: "boost::move(lock);" This constructor may block if other threads hold a <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> on this mutex (<classname alt="boost::interprocess::sharable_lock">sharable_lock</classname>'s can share ownership with an <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname>). </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T"/>
        </template><parameter name="upgr"><paramtype><classname>upgradable_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>try_to_lock_type</classname></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If upgr.owns() then calls try_unlock_upgradable_and_lock() on the referenced mutex: a)if try_unlock_upgradable_and_lock() returns true then mutex() obtains the value from upgr.release() and owns() is set to true. b)if try_unlock_upgradable_and_lock() returns false then upgr is unaffected and this <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> construction as the same effects as a default construction. c)Else upgr.owns() is false. mutex() obtains the value from upgr.release() and owns() is set to false Notes: This construction will not block. It will try to obtain mutex ownership from upgr immediately, while changing the lock type from a "read lock" to a "write lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "write lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="upgr"><paramtype><classname>upgradable_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If upgr.owns() then calls timed_unlock_upgradable_and_lock(abs_time) on the referenced mutex: a)if timed_unlock_upgradable_and_lock(abs_time) returns true then mutex() obtains the value from upgr.release() and owns() is set to true. b)if timed_unlock_upgradable_and_lock(abs_time) returns false then upgr is unaffected and this <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> construction as the same effects as a default construction. c)Else upgr.owns() is false. mutex() obtains the value from upgr.release() and owns() is set to false Notes: This construction will not block. It will try to obtain mutex ownership from upgr immediately, while changing the lock type from a "read lock" to a "write lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "write lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T"/>
        </template><parameter name="shar"><paramtype><classname>sharable_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>try_to_lock_type</classname></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If shar.owns() then calls try_unlock_sharable_and_lock() on the referenced mutex. a)if try_unlock_sharable_and_lock() returns true then mutex() obtains the value from shar.release() and owns() is set to true. b)if try_unlock_sharable_and_lock() returns false then shar is unaffected and this <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> construction has the same effects as a default construction. c)Else shar.owns() is false. mutex() obtains the value from shar.release() and owns() is set to false Notes: This construction will not block. It will try to obtain mutex ownership from shar immediately, while changing the lock type from a "read lock" to a "write lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "write lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </para></description></constructor>
<destructor><description><para>Effects: if (owns()) mp_mutex-&gt;unlock(). Notes: The destructor behavior ensures that the mutex lock is not leaked. </para></description></destructor>
<copy-assignment><type><classname>scoped_lock</classname> &amp;</type><parameter name="scop"><paramtype><classname>scoped_lock</classname> &amp;&amp;</paramtype></parameter><description><para>Effects: If owns() before the call, then unlock() is called on mutex(). *this gets the state of scop and scop gets set to a default constructed state. Notes: With a recursive mutex it is possible that both this and scop own the same mutex before the assignment. In this case, this will own the mutex after the assignment (and scop will not), but the mutex's lock count will be decremented by one. </para></description></copy-assignment>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/sharable_lock.hpp">
<para>Describes the upgradable_lock class that serves to acquire the upgradable lock of a mutex. </para><namespace name="boost">
<namespace name="interprocess">
<class name="sharable_lock"><template>
      <template-type-parameter name="SharableMutex"/>
    </template><description><para><classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> is meant to carry out the tasks for sharable-locking (such as read-locking), unlocking, try-sharable-locking and timed-sharable-locking (recursive or not) for the Mutex. The Mutex need not supply all of this functionality. If the client of sharable_lock&lt;Mutex&gt; does not use functionality which the Mutex does not supply, no harm is done. Mutex ownership can be shared among sharable_locks, and a single <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname>. <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> does not support copy semantics. But <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> supports ownership transfer from an <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname>, <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> and <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> via transfer_lock syntax. </para></description><typedef name="mutex_type"><type>SharableMutex</type></typedef>
<method-group name="public member functions">
<method name="lock"><type>void</type><description><para>Effects: If mutex() == 0 or already locked, throws a lock_exception() exception. Calls lock_sharable() on the referenced mutex. Postconditions: owns() == true. Notes: The <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> changes from a state of not owning the mutex, to owning the mutex, blocking if necessary. </para></description></method>
<method name="try_lock"><type>bool</type><description><para>Effects: If mutex() == 0 or already locked, throws a lock_exception() exception. Calls try_lock_sharable() on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt;try_lock_sharable(). Notes: The <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> changes from a state of not owning the mutex, to owning the mutex, but only if blocking was not required. If the mutex_type does not support try_lock_sharable(), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method>
<method name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: If mutex() == 0 or already locked, throws a lock_exception() exception. Calls timed_lock_sharable(abs_time) on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt;timed_lock_sharable(elps_time). Notes: The <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership within the specified time interval. If the mutex_type does not support timed_lock_sharable(), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method>
<method name="try_lock_until"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: If mutex() == 0 or already locked, throws a lock_exception() exception. Calls try_lock_shared_until(abs_time) on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt;timed_lock_sharable(elps_time). Notes: The <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership within the specified time interval. If the mutex_type does not support timed_lock_sharable(), this function will fail at compile time if instantiated, but otherwise have no effect.</para><para>Note: Similar to timed_lock, but with a std-like interface </para></description></method>
<method name="try_lock_for"><type>bool</type><template>
          <template-type-parameter name="Duration"/>
        </template><parameter name="dur"><paramtype>const Duration &amp;</paramtype></parameter><description><para>Effects: If mutex() == 0 or already locked, throws a lock_exception() exception. Calls try_lock_shared_until(abs_time) on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt;timed_lock_sharable(elps_time). Notes: The <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership within the specified time interval. If the mutex_type does not support timed_lock_sharable(), this function will fail at compile time if instantiated, but otherwise have no effect.</para><para>Note: Similar to timed_lock, but with a std-like interface </para></description></method>
<method name="unlock"><type>void</type><description><para>Effects: If mutex() == 0 or not locked, throws a lock_exception() exception. Calls unlock_sharable() on the referenced mutex. Postconditions: owns() == false. Notes: The <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> changes from a state of owning the mutex, to not owning the mutex. </para></description></method>
<method name="owns" cv="const noexcept"><type>bool</type><description><para>Effects: Returns true if this <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> has acquired the referenced mutex. </para></description></method>
<method name="conversion-operator" cv="const noexcept"><type>unspecified_bool_type</type><description><para>Conversion to bool. Returns owns(). </para></description></method>
<method name="mutex" cv="const noexcept"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. </para></description></method>
<method name="release" cv="noexcept"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. Postconditions: mutex() == 0 and owns() == false. </para></description></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>sharable_lock</classname>&lt; mutex_type &gt; &amp;</paramtype></parameter><description><para>Effects: Swaps state with moved lock. Throws: Nothing. </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Effects: Default constructs a <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname>. Postconditions: owns() == false and mutex() == 0. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><description><para>Effects: m.lock_sharable(). Postconditions: owns() == true and mutex() == &amp;m. Notes: The constructor will take sharable-ownership of the mutex. If another thread already owns the mutex with exclusive ownership (<classname alt="boost::interprocess::scoped_lock">scoped_lock</classname>), this thread will block until the mutex is released. If another thread owns the mutex with sharable or upgradable ownership, then no blocking will occur. Whether or not this constructor handles recursive locking depends upon the mutex. </para></description></constructor>
<constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>defer_lock_type</classname></paramtype></parameter><description><para>Postconditions: owns() == false, and mutex() == &amp;m. Notes: The constructor will not take ownership of the mutex. There is no effect required on the referenced mutex. </para></description></constructor>
<constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>accept_ownership_type</classname></paramtype></parameter><description><para>Postconditions: owns() == true, and mutex() == &amp;m. Notes: The constructor will suppose that the mutex is already sharable locked. There is no effect required on the referenced mutex. </para></description></constructor>
<constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>try_to_lock_type</classname></paramtype></parameter><description><para>Effects: m.try_lock_sharable() Postconditions: mutex() == &amp;m. owns() == the return value of the m.try_lock_sharable() executed within the constructor. Notes: The constructor will take sharable-ownership of the mutex if it can do so without waiting. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock_sharable, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: m.timed_lock_sharable(abs_time) Postconditions: mutex() == &amp;m. owns() == the return value of the m.timed_lock_sharable() executed within the constructor. Notes: The constructor will take sharable-ownership of the mutex if it can do so within the time specified. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support timed_lock_sharable, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor>
<constructor cv="noexcept"><parameter name="upgr"><paramtype><classname>sharable_lock</classname>&lt; mutex_type &gt; &amp;&amp;</paramtype></parameter><description><para>Postconditions: mutex() == upgr.mutex(). owns() == the value of upgr.owns() before the construction. upgr.owns() == false after the construction. Notes: If the upgr <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> owns the mutex, ownership is moved to this <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> with no blocking. If the upgr <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> does not own the mutex, then neither will this <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname>. Only a moved <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname>'s will match this signature. An non-moved <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> can be moved with the expression: "boost::move(lock);". This constructor does not alter the state of the mutex, only potentially who owns it. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T"/>
        </template><parameter name="upgr"><paramtype><classname>upgradable_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If upgr.owns() then calls unlock_upgradable_and_lock_sharable() on the referenced mutex. Postconditions: mutex() == the value upgr.mutex() had before the construction. upgr.mutex() == 0 owns() == the value of upgr.owns() before construction. upgr.owns() == false after the construction. Notes: If upgr is locked, this constructor will lock this <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> while unlocking upgr. Only a moved <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname>'s will match this signature. An non-moved <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> can be moved with the expression: "boost::move(lock);". </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T"/>
        </template><parameter name="scop"><paramtype><classname>scoped_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If scop.owns() then calls unlock_and_lock_sharable() on the referenced mutex. Postconditions: mutex() == the value scop.mutex() had before the construction. scop.mutex() == 0 owns() == scop.owns() before the constructor. After the construction, scop.owns() == false. Notes: If scop is locked, this constructor will transfer the exclusive ownership to a sharable-ownership of this <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname>. Only a moved <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname>'s will match this signature. An non-moved <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> can be moved with the expression: "boost::move(lock);". </para></description></constructor>
<destructor><description><para>Effects: if (owns()) mp_mutex-&gt;unlock_sharable(). Notes: The destructor behavior ensures that the mutex lock is not leaked. </para></description></destructor>
<copy-assignment><type><classname>sharable_lock</classname> &amp;</type><parameter name="upgr"><paramtype><classname>sharable_lock</classname>&lt; mutex_type &gt; &amp;&amp;</paramtype></parameter><description><para>Effects: If owns() before the call, then unlock_sharable() is called on mutex(). *this gets the state of upgr and upgr gets set to a default constructed state. Notes: With a recursive mutex it is possible that both this and upgr own the mutex before the assignment. In this case, this will own the mutex after the assignment (and upgr will not), but the mutex's lock count will be decremented by one. </para></description></copy-assignment>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/sync/upgradable_lock.hpp">
<para>Describes the upgradable_lock class that serves to acquire the upgradable lock of a mutex. </para><namespace name="boost">
<namespace name="interprocess">
<class name="upgradable_lock"><template>
      <template-type-parameter name="UpgradableMutex"/>
    </template><description><para><classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> is meant to carry out the tasks for read-locking, unlocking, try-read-locking and timed-read-locking (recursive or not) for the Mutex. Additionally the <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> can transfer ownership to a <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> using transfer_lock syntax. The Mutex need not supply all of the functionality. If the client of upgradable_lock&lt;Mutex&gt; does not use functionality which the Mutex does not supply, no harm is done. Mutex ownership can be shared among read_locks, and a single <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname>. <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> does not support copy semantics. However <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> supports ownership transfer from a upgradable_locks or scoped_locks via transfer_lock syntax. </para></description><typedef name="mutex_type"><type>UpgradableMutex</type></typedef>
<method-group name="public member functions">
<method name="lock"><type>void</type><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls lock_upgradable() on the referenced mutex. Postconditions: owns() == true. Notes: The <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> changes from a state of not owning the mutex, to owning the mutex, blocking if necessary. </para></description></method>
<method name="try_lock"><type>bool</type><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls try_lock_upgradable() on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt;try_lock_upgradable(). Notes: The <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> changes from a state of not owning the mutex, to owning the mutex, but only if blocking was not required. If the mutex_type does not support try_lock_upgradable(), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method>
<method name="timed_lock"><type>bool</type><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: If mutex() == 0 or if already locked, throws a lock_exception() exception. Calls timed_lock_upgradable(abs_time) on the referenced mutex. Postconditions: owns() == the value returned from mutex()-&gt;timed_lock_upgradable(abs_time). Notes: The <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership within the specified time. If the mutex_type does not support timed_lock_upgradable(abs_time), this function will fail at compile time if instantiated, but otherwise have no effect. </para></description></method>
<method name="unlock"><type>void</type><description><para>Effects: If mutex() == 0 or if not locked, throws a lock_exception() exception. Calls unlock_upgradable() on the referenced mutex. Postconditions: owns() == false. Notes: The <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> changes from a state of owning the mutex, to not owning the mutex. </para></description></method>
<method name="owns" cv="const noexcept"><type>bool</type><description><para>Effects: Returns true if this <classname alt="boost::interprocess::scoped_lock">scoped_lock</classname> has acquired the referenced mutex. </para></description></method>
<method name="conversion-operator" cv="const noexcept"><type>unspecified_bool_type</type><description><para>Conversion to bool. Returns owns(). </para></description></method>
<method name="mutex" cv="const noexcept"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. </para></description></method>
<method name="release" cv="noexcept"><type>mutex_type *</type><description><para>Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference. Postconditions: mutex() == 0 and owns() == false. </para></description></method>
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>upgradable_lock</classname>&lt; mutex_type &gt; &amp;</paramtype></parameter><description><para>Effects: Swaps state with moved lock. Throws: Nothing. </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Effects: Default constructs a <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname>. Postconditions: owns() == false and mutex() == 0. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter></constructor>
<constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>defer_lock_type</classname></paramtype></parameter><description><para>Postconditions: owns() == false, and mutex() == &amp;m. Notes: The constructor will not take ownership of the mutex. There is no effect required on the referenced mutex. </para></description></constructor>
<constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>accept_ownership_type</classname></paramtype></parameter><description><para>Postconditions: owns() == true, and mutex() == &amp;m. Notes: The constructor will suppose that the mutex is already upgradable locked. There is no effect required on the referenced mutex. </para></description></constructor>
<constructor><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name=""><paramtype><classname>try_to_lock_type</classname></paramtype></parameter><description><para>Effects: m.try_lock_upgradable(). Postconditions: mutex() == &amp;m. owns() == the return value of the m.try_lock_upgradable() executed within the constructor. Notes: The constructor will take upgradable-ownership of the mutex if it can do so without waiting. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support try_lock_upgradable, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="TimePoint"/>
        </template><parameter name="m"><paramtype>mutex_type &amp;</paramtype></parameter><parameter name="abs_time"><paramtype>const TimePoint &amp;</paramtype></parameter><description><para>Effects: m.timed_lock_upgradable(abs_time) Postconditions: mutex() == &amp;m. owns() == the return value of the m.timed_lock_upgradable() executed within the constructor. Notes: The constructor will take upgradable-ownership of the mutex if it can do so within the time specified. Whether or not this constructor handles recursive locking depends upon the mutex. If the mutex_type does not support timed_lock_upgradable, this constructor will fail at compile time if instantiated, but otherwise have no effect. </para></description></constructor>
<constructor cv="noexcept"><parameter name="upgr"><paramtype><classname>upgradable_lock</classname>&lt; mutex_type &gt; &amp;&amp;</paramtype></parameter><description><para>Effects: No effects on the underlying mutex. Postconditions: mutex() == the value upgr.mutex() had before the construction. upgr.mutex() == 0. owns() == upgr.owns() before the construction. upgr.owns() == false. Notes: If upgr is locked, this constructor will lock this <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> while unlocking upgr. If upgr is unlocked, then this <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> will be unlocked as well. Only a moved <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname>'s will match this signature. An non-moved <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> can be moved with the expression: "boost::move(lock);". This constructor does not alter the state of the mutex, only potentially who owns it. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T"/>
        </template><parameter name="scop"><paramtype><classname>scoped_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If scop.owns(), m_.unlock_and_lock_upgradable(). Postconditions: mutex() == the value scop.mutex() had before the construction. scop.mutex() == 0. owns() == scop.owns() before the constructor. After the construction, scop.owns() == false. Notes: If scop is locked, this constructor will transfer the exclusive-ownership to an upgradable-ownership of this <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname>. Only a moved <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname>'s will match this signature. An non-moved <classname alt="boost::interprocess::sharable_lock">sharable_lock</classname> can be moved with the expression: "boost::move(lock);". </para></description></constructor>
<constructor><template>
          <template-type-parameter name="T"/>
        </template><parameter name="shar"><paramtype><classname>sharable_lock</classname>&lt; T &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype><classname>try_to_lock_type</classname></paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>Effects: If shar.owns() then calls try_unlock_sharable_and_lock_upgradable() on the referenced mutex. a)if try_unlock_sharable_and_lock_upgradable() returns true then mutex() obtains the value from shar.release() and owns() is set to true. b)if try_unlock_sharable_and_lock_upgradable() returns false then shar is unaffected and this <classname alt="boost::interprocess::upgradable_lock">upgradable_lock</classname> construction has the same effects as a default construction. c)Else shar.owns() is false. mutex() obtains the value from shar.release() and owns() is set to false. Notes: This construction will not block. It will try to obtain mutex ownership from shar immediately, while changing the lock type from a "read lock" to an "upgradable lock". If the "read lock" isn't held in the first place, the mutex merely changes type to an unlocked "upgradable lock". If the "read lock" is held, then mutex transfer occurs only if it can do so in a non-blocking manner. </para></description></constructor>
<destructor><description><para>Effects: if (owns()) m_-&gt;unlock_upgradable(). Notes: The destructor behavior ensures that the mutex lock is not leaked. </para></description></destructor>
<copy-assignment><type><classname>upgradable_lock</classname> &amp;</type><parameter name="upgr"><paramtype><classname>upgradable_lock</classname> &amp;&amp;</paramtype></parameter><description><para>Effects: If owns(), then unlock_upgradable() is called on mutex(). *this gets the state of upgr and upgr gets set to a default constructed state. Notes: With a recursive mutex it is possible that both this and upgr own the mutex before the assignment. In this case, this will own the mutex after the assignment (and upgr will not), but the mutex's upgradable lock count will be decremented by one. </para></description></copy-assignment>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/windows_shared_memory.hpp">
<para>Describes a class representing a native windows shared memory. </para><namespace name="boost">
<namespace name="interprocess">
<class name="windows_shared_memory"><description><para>A class that wraps the native Windows shared memory that is implemented as a file mapping of the paging file. Unlike <classname alt="boost::interprocess::shared_memory_object">shared_memory_object</classname>, <classname alt="boost::interprocess::windows_shared_memory">windows_shared_memory</classname> has no kernel persistence and the shared memory is destroyed when all processes destroy all their <classname alt="boost::interprocess::windows_shared_memory">windows_shared_memory</classname> objects and mapped regions for the same shared memory or the processes end/crash.</para><para>Warning: Windows native shared memory and interprocess portable shared memory (<classname alt="boost::interprocess::shared_memory_object">boost::interprocess::shared_memory_object</classname>) can't communicate between them. </para></description><method-group name="public member functions">
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>windows_shared_memory</classname> &amp;</paramtype></parameter><purpose>Swaps to shared_memory_objects. Does not throw. </purpose></method>
<method name="get_name" cv="const noexcept"><type>const char *</type><purpose>Returns the name of the shared memory. </purpose></method>
<method name="get_mode" cv="const noexcept"><type>mode_t</type><purpose>Returns access mode. </purpose></method>
<method name="get_mapping_handle" cv="const noexcept"><type>mapping_handle_t</type><purpose>Returns the mapping handle. Never throws. </purpose></method>
<method name="get_size" cv="const noexcept"><type>offset_t</type><description><para>Returns the size of the windows shared memory. It will be a 4K rounded size of the "size" passed in the constructor. </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Default constructor. Represents an empty <classname alt="boost::interprocess::windows_shared_memory">windows_shared_memory</classname>. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a new native shared memory with name "name" and at least size "size", with the access mode "mode". If the file previously exists, throws an error. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Tries to create a shared memory object with name "name" and at least size "size", with the access mode "mode". If the file previously exists, it tries to open it with mode "mode". Otherwise throws an error. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const char *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Tries to open a shared memory object with name "name", with the access mode "mode". If the file does not previously exist, it throws an error. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a new native shared memory with name "name" and at least size "size", with the access mode "mode". If the file previously exists, throws an error. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Tries to create a shared memory object with name "name" and at least size "size", with the access mode "mode". If the file previously exists, it tries to open it with mode "mode". Otherwise throws an error. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="name"><paramtype>const wchar_t *</paramtype></parameter><parameter name="mode"><paramtype>mode_t</paramtype></parameter><description><para>Tries to open a shared memory object with name "name", with the access mode "mode". If the file does not previously exist, it throws an error. </para></description></constructor>
<constructor cv="noexcept"><parameter name="moved"><paramtype><classname>windows_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory object to *this. After the call, "moved" does not represent any shared memory object. Does not throw </para></description></constructor>
<copy-assignment cv="noexcept"><type><classname>windows_shared_memory</classname> &amp;</type><parameter name="moved"><paramtype><classname>windows_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory to *this. After the call, "moved" does not represent any shared memory. Does not throw </para></description></copy-assignment>
<destructor><description><para>Destroys *this. All mapped regions are still valid after destruction. When all mapped regions and <classname alt="boost::interprocess::windows_shared_memory">windows_shared_memory</classname> objects referring the shared memory are destroyed, the operating system will destroy the shared memory. </para></description></destructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/xsi_key.hpp">
<para>Describes a class representing a xsi key type. </para><namespace name="boost">
<namespace name="interprocess">
<class name="xsi_key"><description><para>A class that wraps XSI (System V) key_t type. This type calculates key_t from path and id using ftok, sets key to a specified value, or sets key to IPC_PRIVATE using the default constructor. </para></description><method-group name="public member functions">
<method name="get_key" cv="const"><type>key_t</type><purpose>Returns the internal key_t value. </purpose></method>
</method-group>
<constructor><description><para>Default constructor. Represents a private <classname alt="boost::interprocess::xsi_key">xsi_key</classname>. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="key"><paramtype>key_t</paramtype></parameter><purpose>Creates a new XSI key using a specified value. Constructor is explicit to avoid ambiguity with shmid. </purpose></constructor>
<constructor><parameter name="path"><paramtype>const char *</paramtype></parameter><parameter name="id"><paramtype>boost::uint8_t</paramtype></parameter><description><para>Creates a new XSI shared memory with a key obtained from a call to ftok (with path "path" and id "id"), of size "size" and permissions "perm". If the shared memory previously exists, throws an error. </para></description></constructor>
</class>
















































</namespace>
</namespace>
</header>
<header name="boost/interprocess/xsi_shared_memory.hpp">
<para>Describes a class representing a native xsi shared memory. </para><namespace name="boost">
<namespace name="interprocess">
<class name="xsi_shared_memory"><description><para>A class that wraps XSI (System V) shared memory. Unlike <classname alt="boost::interprocess::shared_memory_object">shared_memory_object</classname>, <classname alt="boost::interprocess::xsi_shared_memory">xsi_shared_memory</classname> needs a valid <classname alt="boost::interprocess::xsi_key">xsi_key</classname> to identify a shared memory object.</para><para>Warning: XSI shared memory and interprocess portable shared memory (<classname alt="boost::interprocess::shared_memory_object">boost::interprocess::shared_memory_object</classname>) can't communicate between them. </para></description><method-group name="public member functions">
<method name="swap" cv="noexcept"><type>void</type><parameter name="other"><paramtype><classname>xsi_shared_memory</classname> &amp;</paramtype></parameter><purpose>Swaps two xsi_shared_memorys. Does not throw. </purpose></method>
<method name="get_shmid" cv="const noexcept"><type>int</type><description><para>Returns the shared memory ID that identifies the shared memory </para></description></method>
<method name="get_mapping_handle" cv="const noexcept"><type>mapping_handle_t</type><description><para>Returns the mapping handle. Never throws </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Default constructor. Represents an empty <classname alt="boost::interprocess::xsi_shared_memory">xsi_shared_memory</classname>. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="shmid"><paramtype>int</paramtype></parameter><description><para>Initializes *this with a shmid previously obtained (possibly from another process) This lower-level initializer allows shared memory mapping without having a key. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>create_only_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Creates a new XSI shared memory from 'key', with size "size" and permissions "perm". If the shared memory previously exists, throws an error. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_or_create_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="perm"><paramtype>const <classname>permissions</classname> &amp;</paramtype><default><classname alt="boost::interprocess::permissions">permissions</classname>()</default></parameter><description><para>Opens an existing shared memory with identifier 'key' or creates a new XSI shared memory from identifier 'key', with size "size" and permissions "perm". </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>open_only_t</classname></paramtype></parameter><parameter name="key"><paramtype>const <classname>xsi_key</classname> &amp;</paramtype></parameter><description><para>Tries to open a XSI shared memory with identifier 'key' If the shared memory does not previously exist, it throws an error. </para></description></constructor>
<constructor cv="noexcept"><parameter name="moved"><paramtype><classname>xsi_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory object to *this. After the call, "moved" does not represent any shared memory object. Does not throw </para></description></constructor>
<copy-assignment cv="noexcept"><type><classname>xsi_shared_memory</classname> &amp;</type><parameter name="moved"><paramtype><classname>xsi_shared_memory</classname> &amp;&amp;</paramtype></parameter><description><para>Moves the ownership of "moved"'s shared memory to *this. After the call, "moved" does not represent any shared memory. Does not throw </para></description></copy-assignment>
<destructor><description><para>Destroys *this. The shared memory won't be destroyed, just this connection to it. Use remove() to destroy the shared memory. </para></description></destructor>
<method-group name="public static functions">
<method name="remove" specifiers="static"><type>bool</type><parameter name="shmid"><paramtype>int</paramtype></parameter><description><para>Erases the XSI shared memory object identified by shmid from the system. Returns false on error. Never throws </para></description></method>
</method-group>
</class>
















































</namespace>
</namespace>
</header>
</library-reference>