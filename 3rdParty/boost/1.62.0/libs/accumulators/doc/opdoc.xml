<?xml version="1.0" standalone="yes"?>
<library-reference id="numeric_operators_library_reference"><title>Numeric Operators Library Reference</title><header name="boost/accumulators/numeric/functional.hpp">
<namespace name="boost">
<namespace name="numeric">
<struct name="default_"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="type"><type><classname>default_</classname></type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<data-member name="value" specifiers="static"><type>T const</type></data-member>
<method-group name="public member functions">
<method name="conversion-operator" cv="const"><type>T const &amp;</type></method>
</method-group>
</struct><struct name="one"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="type"><type><classname>one</classname></type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<data-member name="value" specifiers="static"><type>T const</type></data-member>
<method-group name="public member functions">
<method name="conversion-operator" cv="const"><type>T const &amp;</type></method>
</method-group>
</struct><struct name="zero"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="type"><type><classname>zero</classname></type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<data-member name="value" specifiers="static"><type>T const</type></data-member>
<method-group name="public member functions">
<method name="conversion-operator" cv="const"><type>T const &amp;</type></method>
</method-group>
</struct><struct name="one_or_default"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">mpl::if_::type&lt; is_empty&lt; T &gt;, default_&lt; T &gt;, one&lt; T &gt; &gt;</inherit></struct><struct name="zero_or_default"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">mpl::if_::type&lt; is_empty&lt; T &gt;, default_&lt; T &gt;, zero&lt; T &gt; &gt;</inherit></struct><namespace name="functional">
<struct name="left_ref"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
    </template><typedef name="type"><type>Left &amp;</type></typedef>
</struct><struct name="plus_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()+lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left + right </para></returns></method>
</method-group>
</struct><struct name="plus"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::plus_base&lt; Left, Right, void &gt;</inherit></struct><struct name="minus_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()-lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left - right </para></returns></method>
</method-group>
</struct><struct name="minus"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::minus_base&lt; Left, Right, void &gt;</inherit></struct><struct name="multiplies_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()*lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left * right </para></returns></method>
</method-group>
</struct><struct name="multiplies"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::multiplies_base&lt; Left, Right, void &gt;</inherit></struct><struct name="divides_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()/lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left / right </para></returns></method>
</method-group>
</struct><struct name="divides"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::divides_base&lt; Left, Right, void &gt;</inherit></struct><struct name="modulus_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()%lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left % right </para></returns></method>
</method-group>
</struct><struct name="modulus"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::modulus_base&lt; Left, Right, void &gt;</inherit></struct><struct name="greater_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;() &gt; lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left &gt; right </para></returns></method>
</method-group>
</struct><struct name="greater"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::greater_base&lt; Left, Right, void &gt;</inherit></struct><struct name="greater_equal_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;() &gt;=lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left &gt;= right </para></returns></method>
</method-group>
</struct><struct name="greater_equal"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::greater_equal_base&lt; Left, Right, void &gt;</inherit></struct><struct name="less_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()&lt; lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left &lt; right </para></returns></method>
</method-group>
</struct><struct name="less"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::less_base&lt; Left, Right, void &gt;</inherit></struct><struct name="less_equal_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()&lt;=lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left &lt;= right </para></returns></method>
</method-group>
</struct><struct name="less_equal"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::less_equal_base&lt; Left, Right, void &gt;</inherit></struct><struct name="equal_to_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()==lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left == right </para></returns></method>
</method-group>
</struct><struct name="equal_to"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::equal_to_base&lt; Left, Right, void &gt;</inherit></struct><struct name="not_equal_to_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()!=lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left != right </para></returns></method>
</method-group>
</struct><struct name="not_equal_to"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::not_equal_to_base&lt; Left, Right, void &gt;</inherit></struct><struct name="assign_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()=lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left = right </para></returns></method>
</method-group>
</struct><struct name="assign"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::assign_base&lt; Left, Right, void &gt;</inherit></struct><struct name="plus_assign_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()+=lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left += right </para></returns></method>
</method-group>
</struct><struct name="plus_assign"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::plus_assign_base&lt; Left, Right, void &gt;</inherit></struct><struct name="minus_assign_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()-=lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left -= right </para></returns></method>
</method-group>
</struct><struct name="minus_assign"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::minus_assign_base&lt; Left, Right, void &gt;</inherit></struct><struct name="multiplies_assign_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()*=lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left *= right </para></returns></method>
</method-group>
</struct><struct name="multiplies_assign"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::multiplies_assign_base&lt; Left, Right, void &gt;</inherit></struct><struct name="divides_assign_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()/=lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left /= right </para></returns></method>
</method-group>
</struct><struct name="divides_assign"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::divides_assign_base&lt; Left, Right, void &gt;</inherit></struct><struct name="modulus_assign_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::binary_function&lt; Left, Right, typeof(lvalue&lt; Left &gt;()%=lvalue&lt; Right &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter><description><para>
</para></description><returns><para>left %= right </para></returns></method>
</method-group>
</struct><struct name="modulus_assign"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"><default>typename tag&lt;Left&gt;::type</default></template-type-parameter>
      <template-type-parameter name="RightTag"><default>typename tag&lt;Right&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::modulus_assign_base&lt; Left, Right, void &gt;</inherit></struct><struct name="unary_plus_base"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::unary_function&lt; Arg, typeof(+lvalue&lt; Arg &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><description><para>
</para></description><returns><para>+ arg </para></returns></method>
</method-group>
</struct><struct name="unary_plus"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="Tag"><default>typename tag&lt;Arg&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::unary_plus_base&lt; Arg, void &gt;</inherit></struct><struct name="unary_minus_base"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::unary_function&lt; Arg, typeof(-lvalue&lt; Arg &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><description><para>
</para></description><returns><para>- arg </para></returns></method>
</method-group>
</struct><struct name="unary_minus"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="Tag"><default>typename tag&lt;Arg&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::unary_minus_base&lt; Arg, void &gt;</inherit></struct><struct name="complement_base"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::unary_function&lt; Arg, typeof(~lvalue&lt; Arg &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><description><para>
</para></description><returns><para>~ arg </para></returns></method>
</method-group>
</struct><struct name="complement"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="Tag"><default>typename tag&lt;Arg&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::complement_base&lt; Arg, void &gt;</inherit></struct><struct name="logical_not_base"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="EnableIf"><default>void</default></template-type-parameter>
    </template><inherit access="public">std::unary_function&lt; Arg, typeof(!lvalue&lt; Arg &gt;())&gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>result_type</type><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><description><para>
</para></description><returns><para>! arg </para></returns></method>
</method-group>
</struct><struct name="logical_not"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="Tag"><default>typename tag&lt;Arg&gt;::type</default></template-type-parameter>
    </template><inherit access="public">boost::numeric::functional::logical_not_base&lt; Arg, void &gt;</inherit></struct><struct name="min_assign_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"/>
    </template><inherit access="public">std::binary_function&lt; Left, Right, void &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="max_assign_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"/>
    </template><inherit access="public">std::binary_function&lt; Left, Right, void &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="fdiv_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="EnableIf"/>
    </template><inherit access="public">boost::numeric::functional::divides&lt; Left, Right &gt;</inherit></struct><struct-specialization name="fdiv_base"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
    </template><specialization><template-arg>Left</template-arg><template-arg>Right</template-arg><template-arg>typename enable_if&lt; are_integral&lt; Left</template-arg><template-arg>Right &gt; &gt;::type</template-arg></specialization><inherit access="public">boost::numeric::functional::divides&lt; double const, double const  &gt;</inherit></struct-specialization><struct name="promote_base"><template>
      <template-type-parameter name="To"/>
      <template-type-parameter name="From"/>
      <template-type-parameter name="EnableIf"/>
    </template><inherit access="public">std::unary_function&lt; From, To &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>To</type><parameter name="from"><paramtype>From &amp;</paramtype></parameter></method>
</method-group>
</struct><struct-specialization name="promote_base"><template>
      <template-type-parameter name="ToFrom"/>
    </template><specialization><template-arg>ToFrom</template-arg><template-arg>ToFrom</template-arg><template-arg>void</template-arg></specialization><inherit access="public">std::unary_function&lt; ToFrom, ToFrom &gt;</inherit><method-group name="public member functions">
<method name="operator()"><type>ToFrom &amp;</type><parameter name="tofrom"><paramtype>ToFrom &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct name="as_min_base"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="EnableIf"/>
    </template><inherit access="public">std::unary_function&lt; Arg, remove_const&lt; Arg &gt;::type &gt;</inherit><method-group name="public member functions">
<method name="BOOST_STATIC_ASSERT"><type/><parameter name=""><paramtype>std::numeric_limits&lt; typename remove_const&lt; Arg &gt;::type &gt;::is_specialized</paramtype></parameter></method>
<method name="operator()" cv="const"><type>remove_const&lt; Arg &gt;::type</type><parameter name=""><paramtype>Arg &amp;</paramtype></parameter></method>
</method-group>
</struct><struct-specialization name="as_min_base"><template>
      <template-type-parameter name="Arg"/>
    </template><specialization><template-arg>Arg</template-arg><template-arg>typename enable_if&lt; is_floating_point&lt; Arg &gt; &gt;::type</template-arg></specialization><inherit access="public">std::unary_function&lt; Arg, remove_const&lt; Arg &gt;::type &gt;</inherit><method-group name="public member functions">
<method name="BOOST_STATIC_ASSERT"><type/><parameter name=""><paramtype>std::numeric_limits&lt; typename remove_const&lt; Arg &gt;::type &gt;::is_specialized</paramtype></parameter></method>
<method name="operator()" cv="const"><type>remove_const&lt; Arg &gt;::type</type><parameter name=""><paramtype>Arg &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct name="as_max_base"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="EnableIf"/>
    </template><inherit access="public">std::unary_function&lt; Arg, remove_const&lt; Arg &gt;::type &gt;</inherit><method-group name="public member functions">
<method name="BOOST_STATIC_ASSERT"><type/><parameter name=""><paramtype>std::numeric_limits&lt; typename remove_const&lt; Arg &gt;::type &gt;::is_specialized</paramtype></parameter></method>
<method name="operator()" cv="const"><type>remove_const&lt; Arg &gt;::type</type><parameter name=""><paramtype>Arg &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="as_zero_base"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="EnableIf"/>
    </template><inherit access="public">std::unary_function&lt; Arg, remove_const&lt; Arg &gt;::type &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>remove_const&lt; Arg &gt;::type</type><parameter name=""><paramtype>Arg &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="as_one_base"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="EnableIf"/>
    </template><inherit access="public">std::unary_function&lt; Arg, remove_const&lt; Arg &gt;::type &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>remove_const&lt; Arg &gt;::type</type><parameter name=""><paramtype>Arg &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="promote"><template>
      <template-type-parameter name="To"/>
      <template-type-parameter name="From"/>
      <template-type-parameter name="ToTag"/>
      <template-type-parameter name="FromTag"/>
    </template><inherit access="public">boost::numeric::functional::promote_base&lt; To, From, void &gt;</inherit></struct><struct name="min_assign"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"/>
      <template-type-parameter name="RightTag"/>
    </template><inherit access="public">boost::numeric::functional::min_assign_base&lt; Left, Right, void &gt;</inherit></struct><struct name="max_assign"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"/>
      <template-type-parameter name="RightTag"/>
    </template><inherit access="public">boost::numeric::functional::max_assign_base&lt; Left, Right, void &gt;</inherit></struct><struct name="fdiv"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="LeftTag"/>
      <template-type-parameter name="RightTag"/>
    </template><inherit access="public">boost::numeric::functional::fdiv_base&lt; Left, Right, void &gt;</inherit></struct><struct name="as_min"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="Tag"/>
    </template><inherit access="public">boost::numeric::functional::as_min_base&lt; Arg, void &gt;</inherit></struct><struct name="as_max"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="Tag"/>
    </template><inherit access="public">boost::numeric::functional::as_max_base&lt; Arg, void &gt;</inherit></struct><struct name="as_zero"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="Tag"/>
    </template><inherit access="public">boost::numeric::functional::as_zero_base&lt; Arg, void &gt;</inherit></struct><struct name="as_one"><template>
      <template-type-parameter name="Arg"/>
      <template-type-parameter name="Tag"/>
    </template><inherit access="public">boost::numeric::functional::as_one_base&lt; Arg, void &gt;</inherit></struct></namespace>
<namespace name="op">
<struct name="plus"/><struct name="minus"/><struct name="multiplies"/><struct name="divides"/><struct name="modulus"/><struct name="greater"/><struct name="greater_equal"/><struct name="less"/><struct name="less_equal"/><struct name="equal_to"/><struct name="not_equal_to"/><struct name="assign"/><struct name="plus_assign"/><struct name="minus_assign"/><struct name="multiplies_assign"/><struct name="divides_assign"/><struct name="modulus_assign"/><struct name="unary_plus"/><struct name="unary_minus"/><struct name="complement"/><struct name="logical_not"/><struct name="promote"><template>
      <template-type-parameter name="To"/>
    </template></struct><struct name="min_assign"/><struct name="max_assign"/><struct name="fdiv"/><struct name="as_min"/><struct name="as_max"/><struct name="as_zero"/><struct name="as_one"/></namespace>
<function name="promote"><type>lazy_disable_if&lt; is_const&lt; From &gt;, mpl::if_&lt; is_same&lt; To, From &gt;, To &amp;, To &gt; &gt;::type</type><template>
          <template-type-parameter name="To"/>
          <template-type-parameter name="From"/>
        </template><parameter name="from"><paramtype>From &amp;</paramtype></parameter></function>
<function name="promote"><type>mpl::if_&lt; is_same&lt; To const, From const  &gt;, To const &amp;, To const  &gt;::type</type><template>
          <template-type-parameter name="To"/>
          <template-type-parameter name="From"/>
        </template><parameter name="from"><paramtype>From const &amp;</paramtype></parameter></function>
</namespace>
</namespace>
</header>
<header name="boost/accumulators/numeric/functional/complex.hpp">
<namespace name="boost">
<namespace name="numeric">
<namespace name="operators">



<function name="operator*"><type>disable_if&lt; mpl::or_&lt; is_same&lt; T, U &gt;, is_same&lt; std::complex&lt; T &gt;, U &gt; &gt;, std::complex&lt; T &gt; &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="ri"><paramtype>std::complex&lt; T &gt;</paramtype></parameter><parameter name="u"><paramtype>U const &amp;</paramtype></parameter></function>
<function name="operator/"><type>disable_if&lt; mpl::or_&lt; is_same&lt; T, U &gt;, is_same&lt; std::complex&lt; T &gt;, U &gt; &gt;, std::complex&lt; T &gt; &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-type-parameter name="U"/>
        </template><parameter name="ri"><paramtype>std::complex&lt; T &gt;</paramtype></parameter><parameter name="u"><paramtype>U const &amp;</paramtype></parameter></function>









</namespace>


</namespace>
</namespace>
</header>
<header name="boost/accumulators/numeric/functional/valarray.hpp">
<namespace name="boost">
<namespace name="numeric">
<namespace name="functional">
<struct-specialization name="tag"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>std::valarray&lt; T &gt;</template-arg></specialization><typedef name="type"><type>std_valarray_tag</type></typedef>
</struct-specialization><struct-specialization name="min_assign"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
    </template><specialization><template-arg>Left</template-arg><template-arg>Right</template-arg><template-arg>std_valarray_tag</template-arg><template-arg>std_valarray_tag</template-arg></specialization><inherit access="public">std::binary_function&lt; Left, Right, void &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="max_assign"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
    </template><specialization><template-arg>Left</template-arg><template-arg>Right</template-arg><template-arg>std_valarray_tag</template-arg><template-arg>std_valarray_tag</template-arg></specialization><inherit access="public">std::binary_function&lt; Left, Right, void &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="fdiv"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
      <template-type-parameter name="RightTag"/>
    </template><specialization><template-arg>Left</template-arg><template-arg>Right</template-arg><template-arg>std_valarray_tag</template-arg><template-arg>RightTag</template-arg></specialization><inherit access="public">mpl::if_::type&lt; are_integral&lt; Left::value_type, Right &gt;, divides&lt; Left, double const  &gt;, divides&lt; Left, Right &gt; &gt;</inherit></struct-specialization><struct-specialization name="promote"><template>
      <template-type-parameter name="To"/>
      <template-type-parameter name="From"/>
    </template><specialization><template-arg>To</template-arg><template-arg>From</template-arg><template-arg>std_valarray_tag</template-arg><template-arg>std_valarray_tag</template-arg></specialization><inherit access="public">std::unary_function&lt; From, To &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>To</type><parameter name="arr"><paramtype>From &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="promote"><template>
      <template-type-parameter name="ToFrom"/>
    </template><specialization><template-arg>ToFrom</template-arg><template-arg>ToFrom</template-arg><template-arg>std_valarray_tag</template-arg><template-arg>std_valarray_tag</template-arg></specialization><inherit access="public">std::unary_function&lt; ToFrom, ToFrom &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>ToFrom &amp;</type><parameter name="tofrom"><paramtype>ToFrom &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="promote"><template>
      <template-type-parameter name="From"/>
    </template><specialization><template-arg>bool</template-arg><template-arg>From</template-arg><template-arg>void</template-arg><template-arg>std_valarray_tag</template-arg></specialization><inherit access="public">std::unary_function&lt; From, bool &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="arr"><paramtype>From &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="promote"><template>
      <template-type-parameter name="From"/>
    </template><specialization><template-arg>bool const</template-arg><template-arg>From</template-arg><template-arg>void</template-arg><template-arg>std_valarray_tag</template-arg></specialization><inherit access="public">boost::numeric::functional::promote&lt; bool, From, void, std_valarray_tag &gt;</inherit></struct-specialization><struct-specialization name="as_min"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>std_valarray_tag</template-arg></specialization><inherit access="public">std::unary_function&lt; T, remove_const&lt; T &gt;::type &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>remove_const&lt; T &gt;::type</type><parameter name="arr"><paramtype>T &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="as_max"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>std_valarray_tag</template-arg></specialization><inherit access="public">std::unary_function&lt; T, remove_const&lt; T &gt;::type &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>remove_const&lt; T &gt;::type</type><parameter name="arr"><paramtype>T &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="as_zero"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>std_valarray_tag</template-arg></specialization><inherit access="public">std::unary_function&lt; T, remove_const&lt; T &gt;::type &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>remove_const&lt; T &gt;::type</type><parameter name="arr"><paramtype>T &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="as_one"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>std_valarray_tag</template-arg></specialization><inherit access="public">std::unary_function&lt; T, remove_const&lt; T &gt;::type &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>remove_const&lt; T &gt;::type</type><parameter name="arr"><paramtype>T &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization></namespace>
<namespace name="operators">
<function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>std::valarray&lt; Left &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function>
<function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>std::valarray&lt; Left &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function>
<function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>std::valarray&lt; Left &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>std::valarray&lt; Right &gt; const &amp;</paramtype></parameter></function>











</namespace>


</namespace>
</namespace>
</header>
<header name="boost/accumulators/numeric/functional/vector.hpp">
<namespace name="boost">
<namespace name="numeric">
<namespace name="functional">
<struct-specialization name="tag"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Al"/>
    </template><specialization><template-arg>std::vector&lt; T</template-arg><template-arg>Al &gt;</template-arg></specialization><typedef name="type"><type>std_vector_tag</type></typedef>
</struct-specialization><struct-specialization name="min_assign"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
    </template><specialization><template-arg>Left</template-arg><template-arg>Right</template-arg><template-arg>std_vector_tag</template-arg><template-arg>std_vector_tag</template-arg></specialization><inherit access="public">std::binary_function&lt; Left, Right, void &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="max_assign"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
    </template><specialization><template-arg>Left</template-arg><template-arg>Right</template-arg><template-arg>std_vector_tag</template-arg><template-arg>std_vector_tag</template-arg></specialization><inherit access="public">std::binary_function&lt; Left, Right, void &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="fdiv"><template>
      <template-type-parameter name="Left"/>
      <template-type-parameter name="Right"/>
    </template><specialization><template-arg>Left</template-arg><template-arg>Right</template-arg><template-arg>std_vector_tag</template-arg><template-arg>void</template-arg></specialization><inherit access="public">mpl::if_::type&lt; are_integral&lt; Left::value_type, Right &gt;, divides&lt; Left, double const  &gt;, divides&lt; Left, Right &gt; &gt;</inherit></struct-specialization><struct-specialization name="promote"><template>
      <template-type-parameter name="To"/>
      <template-type-parameter name="From"/>
    </template><specialization><template-arg>To</template-arg><template-arg>From</template-arg><template-arg>std_vector_tag</template-arg><template-arg>std_vector_tag</template-arg></specialization><inherit access="public">std::unary_function&lt; From, To &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>To</type><parameter name="arr"><paramtype>From &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="promote"><template>
      <template-type-parameter name="ToFrom"/>
    </template><specialization><template-arg>ToFrom</template-arg><template-arg>ToFrom</template-arg><template-arg>std_vector_tag</template-arg><template-arg>std_vector_tag</template-arg></specialization><inherit access="public">std::unary_function&lt; ToFrom, ToFrom &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>ToFrom &amp;</type><parameter name="tofrom"><paramtype>ToFrom &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="as_min"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>std_vector_tag</template-arg></specialization><inherit access="public">std::unary_function&lt; T, remove_const&lt; T &gt;::type &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>remove_const&lt; T &gt;::type</type><parameter name="arr"><paramtype>T &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="as_max"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>std_vector_tag</template-arg></specialization><inherit access="public">std::unary_function&lt; T, remove_const&lt; T &gt;::type &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>remove_const&lt; T &gt;::type</type><parameter name="arr"><paramtype>T &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="as_zero"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>std_vector_tag</template-arg></specialization><inherit access="public">std::unary_function&lt; T, remove_const&lt; T &gt;::type &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>remove_const&lt; T &gt;::type</type><parameter name="arr"><paramtype>T &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="as_one"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>std_vector_tag</template-arg></specialization><inherit access="public">std::unary_function&lt; T, remove_const&lt; T &gt;::type &gt;</inherit><method-group name="public member functions">
<method name="operator()" cv="const"><type>remove_const&lt; T &gt;::type</type><parameter name="arr"><paramtype>T &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization></namespace>
<namespace name="operators">





<function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>std::vector&lt; Left &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function>
<function name="operator/"><type>std::vector&lt; typename <classname>functional::divides</classname>&lt; Left, Right &gt;::result_type &gt;</type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>std::vector&lt; Left &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>std::vector&lt; Right &gt; const &amp;</paramtype></parameter></function>
<function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>std::vector&lt; Left &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function>
<function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>std::vector&lt; Right &gt; const &amp;</paramtype></parameter></function>
<function name="operator*"><type>std::vector&lt; typename <classname>functional::multiplies</classname>&lt; Left, Right &gt;::result_type &gt;</type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>std::vector&lt; Left &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>std::vector&lt; Right &gt; const &amp;</paramtype></parameter></function>
<function name="operator+"><type>std::vector&lt; typename <classname>functional::plus</classname>&lt; Left, Right &gt;::result_type &gt;</type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>std::vector&lt; Left &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>std::vector&lt; Right &gt; const &amp;</paramtype></parameter></function>
<function name="operator-"><type>std::vector&lt; typename <classname>functional::minus</classname>&lt; Left, Right &gt;::result_type &gt;</type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>std::vector&lt; Left &gt; const &amp;</paramtype></parameter><parameter name="right"><paramtype>std::vector&lt; Right &gt; const &amp;</paramtype></parameter></function>
<function name="operator+="><type>std::vector&lt; Left &gt; &amp;</type><template>
          <template-type-parameter name="Left"/>
        </template><parameter name="left"><paramtype>std::vector&lt; Left &gt; &amp;</paramtype></parameter><parameter name="right"><paramtype>std::vector&lt; Left &gt; const &amp;</paramtype></parameter></function>
<function name="operator-"><type>std::vector&lt; typename <classname>functional::unary_minus</classname>&lt; Arg &gt;::result_type &gt;</type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>std::vector&lt; Arg &gt; const &amp;</paramtype></parameter></function>
</namespace>


</namespace>
</namespace>
</header>
</library-reference>