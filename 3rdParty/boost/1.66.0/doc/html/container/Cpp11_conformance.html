<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>C++11/C++14 Conformance</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../container.html" title="Chapter&#160;9.&#160;Boost.Container">
<link rel="prev" href="extended_functionality.html" title="Extended functionality">
<link rel="next" href="known_issues.html" title="Known Issues">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="extended_functionality.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../container.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="known_issues.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="container.Cpp11_conformance"></a><a class="link" href="Cpp11_conformance.html" title="C++11/C++14 Conformance">C++11/C++14 Conformance</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="Cpp11_conformance.html#container.Cpp11_conformance.move_emplace">Move and Emplace</a></span></dt>
<dt><span class="section"><a href="Cpp11_conformance.html#container.Cpp11_conformance.alloc_traits_move_traits">Stateful
      allocators</a></span></dt>
<dt><span class="section"><a href="Cpp11_conformance.html#container.Cpp11_conformance.scoped_allocator">Scoped
      allocators</a></span></dt>
<dt><span class="section"><a href="Cpp11_conformance.html#container.Cpp11_conformance.insertion_hints">Insertion
      hints in associative containers and preserving insertion ordering for elements
      with equivalent keys</a></span></dt>
<dt><span class="section"><a href="Cpp11_conformance.html#container.Cpp11_conformance.initializer_lists">Initializer
      lists</a></span></dt>
<dt><span class="section"><a href="Cpp11_conformance.html#container.Cpp11_conformance.null_iterators">Null Forward
      Iterators</a></span></dt>
<dt><span class="section"><a href="Cpp11_conformance.html#container.Cpp11_conformance.forward_list"><code class="computeroutput"><span class="identifier">forward_list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code></a></span></dt>
<dt><span class="section"><a href="Cpp11_conformance.html#container.Cpp11_conformance.vector_exception_guarantees"><code class="computeroutput"><span class="identifier">vector</span></code> vs. <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
      exception guarantees</a></span></dt>
<dt><span class="section"><a href="Cpp11_conformance.html#container.Cpp11_conformance.container_const_reference_parameters">Parameter
      taken by const reference that can be changed</a></span></dt>
<dt><span class="section"><a href="Cpp11_conformance.html#container.Cpp11_conformance.Vector_bool"><code class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;</span></code> specialization</a></span></dt>
<dt><span class="section"><a href="Cpp11_conformance.html#container.Cpp11_conformance.non_standard_memset_initialization">Non-standard
      value initialization using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">memset</span></code></a></span></dt>
</dl></div>
<p>
      <span class="bold"><strong>Boost.Container</strong></span> aims for full C++11 conformance
      except reasoned deviations, backporting as much as possible for C++03. Obviously,
      this conformance is a work in progress so this section explains what C++11
      features are implemented and which of them have been backported to C++03 compilers.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.Cpp11_conformance.move_emplace"></a><a class="link" href="Cpp11_conformance.html#container.Cpp11_conformance.move_emplace" title="Move and Emplace">Move and Emplace</a>
</h3></div></div></div>
<p>
        For compilers with rvalue references and for those C++03 types that use
        <a href="http://www.boost.org/libs/move" target="_top">Boost.Move</a> rvalue reference
        emulation <span class="bold"><strong>Boost.Container</strong></span> supports all C++11
        features related to move semantics: containers are movable, requirements
        for <code class="computeroutput"><span class="identifier">value_type</span></code> are those
        specified for C++11 containers.
      </p>
<p>
        For compilers with variadic templates, <span class="bold"><strong>Boost.Container</strong></span>
        supports placement insertion (<code class="computeroutput"><span class="identifier">emplace</span></code>,
        ...) functions from C++11. For those compilers without variadic templates
        support <span class="bold"><strong>Boost.Container</strong></span> uses the preprocessor
        to create a set of overloads up to a finite number of parameters.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.Cpp11_conformance.alloc_traits_move_traits"></a><a class="link" href="Cpp11_conformance.html#container.Cpp11_conformance.alloc_traits_move_traits" title="Stateful allocators">Stateful
      allocators</a>
</h3></div></div></div>
<p>
        C++03 was not stateful-allocator friendly. For compactness of container objects
        and for simplicity, it did not require containers to support allocators with
        state: Allocator objects need not be stored in container objects. It was
        not possible to store an allocator with state, say an allocator that holds
        a pointer to an arena from which to allocate. C++03 allowed implementors
        to suppose two allocators of the same type always compare equal (that means
        that memory allocated by one allocator object could be deallocated by another
        instance of the same type) and allocators were not swapped when the container
        was swapped.
      </p>
<p>
        C++11 further improves stateful allocator support through <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator_traits</span></code></a>.
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator_traits</span></code> is the protocol between
        a container and an allocator, and an allocator writer can customize its behaviour
        (should the container propagate it in move constructor, swap, etc.?) following
        <code class="computeroutput"><span class="identifier">allocator_traits</span></code> requirements.
        <span class="bold"><strong>Boost.Container</strong></span> not only supports this model
        with C++11 but also <span class="bold"><strong>backports it to C++03</strong></span>
        via <code class="computeroutput"><a class="link" href="../boost/container/allocator_traits.html" title="Struct template allocator_traits">boost::container::allocator_traits</a></code>
        including some C++17 changes. This class offers some workarounds for C++03
        compilers to achieve the same allocator guarantees as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator_traits</span></code>.
      </p>
<p>
        In [Boost.Container] containers, if possible, a single allocator is hold
        to construct <code class="computeroutput"><span class="identifier">value_type</span></code>s.
        If the container needs an auxiliary allocator (e.g. an array allocator used
        by <code class="computeroutput"><span class="identifier">deque</span></code> or <code class="computeroutput"><span class="identifier">stable_vector</span></code>), that allocator is also
        stored in the container and initialized from the user-supplied allocator
        when the container is constructed (i.e. it's not constructed on the fly when
        auxiliary memory is needed).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.Cpp11_conformance.scoped_allocator"></a><a class="link" href="Cpp11_conformance.html#container.Cpp11_conformance.scoped_allocator" title="Scoped allocators">Scoped
      allocators</a>
</h3></div></div></div>
<p>
        C++11 improves stateful allocators with the introduction of <a href="http://en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">scoped_allocator_adaptor</span></code></a>
        class template. <code class="computeroutput"><span class="identifier">scoped_allocator_adaptor</span></code>
        is instantiated with one outer allocator and zero or more inner allocators.
      </p>
<p>
        A scoped allocator is a mechanism to automatically propagate the state of
        the allocator to the subobjects of a container in a controlled way. If instantiated
        with only one allocator type, the inner allocator becomes the <code class="computeroutput"><span class="identifier">scoped_allocator_adaptor</span></code> itself, thus using
        the same allocator resource for the container and every element within the
        container and, if the elements themselves are containers, each of their elements
        recursively. If instantiated with more than one allocator, the first allocator
        is the outer allocator for use by the container, the second allocator is
        passed to the constructors of the container's elements, and, if the elements
        themselves are containers, the third allocator is passed to the elements'
        elements, and so on.
      </p>
<p>
        <span class="bold"><strong>Boost.Container</strong></span> implements its own <code class="computeroutput"><a class="link" href="../boost/container/scoped_allocator_adaptor.html" title="Class template scoped_allocator_adaptor">scoped_allocator_adaptor</a></code>
        class and <span class="bold"><strong>backports this feature also to C++03 compilers</strong></span>.
        Due to C++03 limitations, in those compilers the allocator propagation implemented
        by <code class="computeroutput"><span class="identifier">scoped_allocator_adaptor</span><span class="special">::</span><span class="identifier">construct</span></code>
        functions will be based on traits (<code class="computeroutput"><a class="link" href="../boost/container/constructible__idp67492240.html" title="Struct template constructible_with_allocator_suffix">constructible_with_allocator_suffix</a></code>
        and <code class="computeroutput"><a class="link" href="../boost/container/constructible__idp67501632.html" title="Struct template constructible_with_allocator_prefix">constructible_with_allocator_prefix</a></code>)
        proposed in <a href="http://www.open-std.org/jtc1/sc22/WG21/docs/papers/2008/n2554.pdf" target="_top">N2554:
        The Scoped Allocator Model (Rev 2) proposal</a>. In conforming C++11
        compilers or compilers supporting SFINAE expressions (when <code class="computeroutput"><span class="identifier">BOOST_NO_SFINAE_EXPR</span></code> is NOT defined), traits
        are ignored and C++11 rules (<code class="computeroutput"><span class="identifier">is_constructible</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span>
        <span class="identifier">Args</span><span class="special">...,</span>
        <span class="identifier">inner_allocator_type</span><span class="special">&gt;::</span><span class="identifier">value</span></code> and <code class="computeroutput"><span class="identifier">is_constructible</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span>
        <span class="identifier">allocator_arg_t</span><span class="special">,</span>
        <span class="identifier">inner_allocator_type</span><span class="special">,</span>
        <span class="identifier">Args</span><span class="special">...&gt;::</span><span class="identifier">value</span></code>) will be used to detect if the allocator
        must be propagated with suffix or prefix allocator arguments.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.Cpp11_conformance.insertion_hints"></a><a class="link" href="Cpp11_conformance.html#container.Cpp11_conformance.insertion_hints" title="Insertion hints in associative containers and preserving insertion ordering for elements with equivalent keys">Insertion
      hints in associative containers and preserving insertion ordering for elements
      with equivalent keys</a>
</h3></div></div></div>
<p>
        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233" target="_top">LWG
        Issue #233</a> corrected a defect in C++98 and specified how equivalent
        keys were to be inserted in associative containers. <span class="bold"><strong>Boost.Container</strong></span>
        implements the C++11 changes that were specified in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1780.html" target="_top">N1780
        <span class="emphasis"><em>Comments on LWG issue 233: Insertion hints in associative containers</em></span></a>:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><span class="identifier">a_eq</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">t</span><span class="special">)</span></code>:
            If a range containing elements equivalent to t exists in a_eq, t is inserted
            at the end of that range.
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">a_eq</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">p</span><span class="special">,</span><span class="identifier">t</span><span class="special">)</span></code>:
            t is inserted as close as possible to the position just prior to p.
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.Cpp11_conformance.initializer_lists"></a><a class="link" href="Cpp11_conformance.html#container.Cpp11_conformance.initializer_lists" title="Initializer lists">Initializer
      lists</a>
</h3></div></div></div>
<p>
        <span class="bold"><strong>Boost.Container</strong></span> supports initialization,
        assignments and insertions from initializer lists in compilers that implement
        this feature.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.Cpp11_conformance.null_iterators"></a><a class="link" href="Cpp11_conformance.html#container.Cpp11_conformance.null_iterators" title="Null Forward Iterators">Null Forward
      Iterators</a>
</h3></div></div></div>
<p>
        <span class="bold"><strong>Boost.Container</strong></span> implements <a href="http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3644.pdf" target="_top">C++14
        Null Forward Iterators</a>, which means that value-initialized iterators
        may be compared and compare equal to other value-initialized iterators of
        the same type. Value initialized iterators behave as if they refer past the
        end of the same empty sequence (example taken from N3644):
      </p>
<pre class="programlisting"><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">v</span> <span class="special">=</span> <span class="special">{</span> <span class="special">...</span> <span class="special">};</span>
<span class="keyword">auto</span> <span class="identifier">ni</span> <span class="special">=</span> <span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">iterator</span><span class="special">();</span>
<span class="keyword">auto</span> <span class="identifier">nd</span> <span class="special">=</span> <span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;::</span><span class="identifier">iterator</span><span class="special">();</span>
<span class="identifier">ni</span> <span class="special">==</span> <span class="identifier">ni</span><span class="special">;</span> <span class="comment">// True.</span>
<span class="identifier">nd</span> <span class="special">!=</span> <span class="identifier">nd</span><span class="special">;</span> <span class="comment">// False.</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">ni</span><span class="special">;</span> <span class="comment">// ??? (likely false in practice).</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">ni</span><span class="special">;</span>   <span class="comment">// ??? (likely false in practice).</span>
<span class="identifier">ni</span> <span class="special">==</span> <span class="identifier">nd</span><span class="special">;</span> <span class="comment">// Won't compile.</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.Cpp11_conformance.forward_list"></a><a class="link" href="Cpp11_conformance.html#container.Cpp11_conformance.forward_list" title="forward_list&lt;T&gt;"><code class="computeroutput"><span class="identifier">forward_list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code></a>
</h3></div></div></div>
<p>
        <span class="bold"><strong>Boost.Container</strong></span> does not offer C++11 <code class="computeroutput"><span class="identifier">forward_list</span></code> container yet, but it will
        be available in future versions.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.Cpp11_conformance.vector_exception_guarantees"></a><a class="link" href="Cpp11_conformance.html#container.Cpp11_conformance.vector_exception_guarantees" title="vector vs. std::vector exception guarantees"><code class="computeroutput"><span class="identifier">vector</span></code> vs. <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
      exception guarantees</a>
</h3></div></div></div>
<p>
        <code class="computeroutput"><a class="link" href="../boost/container/vector.html" title="Class template vector">vector</a></code> does not support
        the strong exception guarantees given by <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
        in functions like <code class="computeroutput"><span class="identifier">insert</span></code>,
        <code class="computeroutput"><span class="identifier">push_back</span></code>, <code class="computeroutput"><span class="identifier">emplace</span></code>, <code class="computeroutput"><span class="identifier">emplace_back</span></code>,
        <code class="computeroutput"><span class="identifier">resize</span></code>, <code class="computeroutput"><span class="identifier">reserve</span></code>
        or <code class="computeroutput"><span class="identifier">shrink_to_fit</span></code> for either
        copyable or no-throw moveable classes. In C++11 <a href="http://en.cppreference.com/w/cpp/utility/move_if_noexcept" target="_top">move_if_noexcept</a>
        is used to maintain C++03 exception safety guarantees combined with C++11
        move semantics. This strong exception guarantee degrades the insertion performance
        of copyable and throwing-moveable types, degrading moves to copies when such
        types are inserted in the vector using the aforementioned members.
      </p>
<p>
        This strong exception guarantee also precludes the possibility of using some
        type of in-place reallocations that can further improve the insertion performance
        of <code class="computeroutput"><span class="identifier">vector</span></code> See <a class="link" href="extended_functionality.html#container.extended_functionality.extended_allocators" title="Extended allocators">Extended
        Allocators</a> to know more about these optimizations.
      </p>
<p>
        <code class="computeroutput"><a class="link" href="../boost/container/vector.html" title="Class template vector">vector</a></code> always uses
        move constructors/assignments to rearrange elements in the vector and uses
        memory expansion mechanisms if the allocator supports them, while offering
        only basic safety guarantees. It trades off exception guarantees for an improved
        performance.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.Cpp11_conformance.container_const_reference_parameters"></a><a class="link" href="Cpp11_conformance.html#container.Cpp11_conformance.container_const_reference_parameters" title="Parameter taken by const reference that can be changed">Parameter
      taken by const reference that can be changed</a>
</h3></div></div></div>
<p>
        Several container operations use a parameter taken by const reference that
        can be changed during execution of the function. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#526" target="_top">LWG
        Issue 526 (<span class="emphasis"><em>Is it undefined if a function in the standard changes
        in parameters?</em></span>)</a> discusses them:
      </p>
<pre class="programlisting"><span class="comment">//Given std::vector&lt;int&gt; v</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">v</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">v</span><span class="special">[</span><span class="number">2</span><span class="special">]);</span>
<span class="comment">//v[2] can be changed by moving elements of vector</span>

<span class="comment">//Given std::list&lt;int&gt; l:</span>
<span class="identifier">l</span><span class="special">.</span><span class="identifier">remove</span><span class="special">(*</span><span class="identifier">l</span><span class="special">.</span><span class="identifier">begin</span><span class="special">())</span>
<span class="comment">//The operation could delete the first element, and then continue trying to access it.</span>
</pre>
<p>
        The adopted resolution, NAD (Not A Defect), implies that previous operations
        must be well-defined. This requires code to detect a reference to an inserted
        element and an additional copy in that case, impacting performance even when
        references to already inserted objects are not used. Note that equivalent
        functions taking rvalue references or iterator ranges require elements not
        already inserted in the container.
      </p>
<p>
        <span class="bold"><strong>Boost.Container</strong></span> prioritizes performance
        and has not implemented the NAD resolution: in functions that might modify
        the argument, the library requires references to elements not stored in the
        container. Using references to inserted elements yields to undefined behaviour
        (although in debug mode, this precondition violation could be notified via
        BOOST_ASSERT).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.Cpp11_conformance.Vector_bool"></a><a class="link" href="Cpp11_conformance.html#container.Cpp11_conformance.Vector_bool" title="vector&lt;bool&gt; specialization"><code class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;</span></code> specialization</a>
</h3></div></div></div>
<p>
        <code class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;</span></code> specialization
        has been quite problematic, and there have been several unsuccessful tries
        to deprecate or remove it from the standard. <span class="bold"><strong>Boost.Container</strong></span>
        does not implement it as there is a superior <a href="http://www.boost.org/libs/dynamic_bitset/" target="_top">Boost.DynamicBitset</a>
        solution. For issues with <code class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;</span></code>
        see the following papers:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a href="http://howardhinnant.github.io/onvectorbool.html" target="_top">On <code class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;</span></code></a>
          </li>
<li class="listitem">
            <a href="http://www.gotw.ca/publications/N1211.pdf" target="_top">vector&lt;bool&gt;:
            N1211: More Problems, Better Solutions</a>,
          </li>
<li class="listitem">
            <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2160.html" target="_top">N2160:
            Library Issue 96: Fixing vector&lt;bool&gt;</a>,
          </li>
<li class="listitem">
            <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2204.html" target="_top">N2204
            A Specification to deprecate vector&lt;bool&gt;</a>.
          </li>
</ul></div>
<p>
        Quotes:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>But it is a shame that the C++ committee gave this excellent
            data structure the name vector&lt;bool&gt; and that it gives no guidance
            nor encouragement on the critical generic algorithms that need to be
            optimized for this data structure. Consequently, few std::lib implementations
            go to this trouble.</em></span></span>&#8221;</span>
          </li>
<li class="listitem">
            <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>In 1998, admitting that the committee made a mistake
            was controversial. Since then Java has had to deprecate such significant
            portions of their libraries that the idea C++ would be ridiculed for
            deprecating a single minor template specialization seems quaint.</em></span></span>&#8221;</span>
          </li>
<li class="listitem">
            <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em><code class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;</span></code> is not a container and <code class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;::</span><span class="identifier">iterator</span></code> is not a random-access iterator
            (or even a forward or bidirectional iterator either, for that matter).
            This has already broken user code in the field in mysterious ways.</em></span></span>&#8221;</span>
          </li>
<li class="listitem">
            <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em><code class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;</span></code> forces a specific (and potentially
            bad) optimization choice on all users by enshrining it in the standard.
            The optimization is premature; different users have different requirements.
            This too has already hurt users who have been forced to implement workarounds
            to disable the 'optimization' (e.g., by using a vector&lt;char&gt; and
            manually casting to/from bool).</em></span></span>&#8221;</span>
          </li>
</ul></div>
<p>
        So <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">container</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;::</span><span class="identifier">iterator</span></code> returns real <code class="computeroutput"><span class="keyword">bool</span></code>
        references and works as a fully compliant container. If you need a memory
        optimized version of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">container</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;</span></code>,
        please use <a href="http://www.boost.org/libs/dynamic_bitset/" target="_top">Boost.DynamicBitset</a>.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.Cpp11_conformance.non_standard_memset_initialization"></a><a class="link" href="Cpp11_conformance.html#container.Cpp11_conformance.non_standard_memset_initialization" title="Non-standard value initialization using std::memset">Non-standard
      value initialization using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">memset</span></code></a>
</h3></div></div></div>
<p>
        <span class="bold"><strong>Boost.Container</strong></span> uses <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">memset</span></code>
        with a zero value to initialize some types as in most platforms this initialization
        yields to the desired value initialization with improved performance.
      </p>
<p>
        Following the C11 standard, <span class="bold"><strong>Boost.Container</strong></span>
        assumes that <span class="emphasis"><em>for any integer type, the object representation where
        all the bits are zero shall be a representation of the value zero in that
        type</em></span>. Since <code class="computeroutput"><span class="identifier">_Bool</span></code>/<code class="computeroutput"><span class="keyword">wchar_t</span></code>/<code class="computeroutput"><span class="keyword">char16_t</span></code>/<code class="computeroutput"><span class="keyword">char32_t</span></code> are also integer types in C, it considers
        all C++ integral types as initializable via <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">memset</span></code>.
      </p>
<p>
        By default, <span class="bold"><strong>Boost.Container</strong></span> also considers
        floating point types to be initializable using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">memset</span></code>.
        Most platforms are compatible with this initialization, but in case this
        initialization is not desirable the user can <code class="computeroutput"><span class="preprocessor">#define</span>
        <span class="identifier">BOOST_CONTAINER_MEMZEROED_FLOATING_POINT_IS_NOT_ZERO</span></code>
        before including library headers.
      </p>
<p>
        By default, it also considers pointer types (pointer and pointer to function
        types, excluding member object and member function pointers) to be initializable
        using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">memset</span></code>. Most platforms are compatible with
        this initialization, but in case this initialization is not desired the user
        can <code class="computeroutput"><span class="preprocessor">#define</span> <span class="identifier">BOOST_CONTAINER_MEMZEROED_POINTER_IS_NOT_ZERO</span></code>
        before including library headers.
      </p>
<p>
        If neither <code class="computeroutput"><span class="identifier">BOOST_CONTAINER_MEMZEROED_FLOATING_POINT_IS_NOT_ZERO</span></code>
        nor <code class="computeroutput"><span class="identifier">BOOST_CONTAINER_MEMZEROED_POINTER_IS_NOT_ZERO</span></code>
        is defined <span class="bold"><strong>Boost.Container</strong></span> also considers
        POD types to be value initializable via <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">memset</span></code>
        with value zero.
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2009-2015 Ion Gaztanaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="extended_functionality.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../container.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="known_issues.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
