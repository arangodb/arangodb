<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Extended functionality</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../container.html" title="Chapter&#160;9.&#160;Boost.Container">
<link rel="prev" href="non_standard_containers.html" title="Non-standard containers">
<link rel="next" href="Cpp11_conformance.html" title="C++11/C++14 Conformance">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="non_standard_containers.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../container.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="Cpp11_conformance.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="container.extended_functionality"></a><a class="link" href="extended_functionality.html" title="Extended functionality">Extended functionality</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="extended_functionality.html#container.extended_functionality.default_initialialization">Default
      initialization for vector-like containers</a></span></dt>
<dt><span class="section"><a href="extended_functionality.html#container.extended_functionality.ordered_range_insertion">Ordered
      range insertion for associative containers (<span class="emphasis"><em>ordered_unique_range</em></span>,
      <span class="emphasis"><em>ordered_range</em></span>) </a></span></dt>
<dt><span class="section"><a href="extended_functionality.html#container.extended_functionality.configurable_tree_based_associative_containers">Configurable
      tree-based associative ordered containers</a></span></dt>
<dt><span class="section"><a href="extended_functionality.html#container.extended_functionality.constant_time_range_splice">Constant-time
      range splice for <code class="computeroutput"><span class="special">(</span><span class="identifier">s</span><span class="special">)</span><span class="identifier">list</span></code></a></span></dt>
<dt><span class="section"><a href="extended_functionality.html#container.extended_functionality.extended_allocators">Extended
      allocators</a></span></dt>
<dt><span class="section"><a href="extended_functionality.html#container.extended_functionality.polymorphic_memory_resources">Polymorphic
      Memory Resources </a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.extended_functionality.default_initialialization"></a><a class="link" href="extended_functionality.html#container.extended_functionality.default_initialialization" title="Default initialization for vector-like containers">Default
      initialization for vector-like containers</a>
</h3></div></div></div>
<p>
        STL and most other containers value initialize new elements in common operations
        like <code class="computeroutput"><span class="identifier">vector</span><span class="special">::</span><span class="identifier">resize</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">)</span></code> or <code class="computeroutput"><span class="keyword">explicit</span>
        <span class="identifier">vector</span><span class="special">::</span><span class="identifier">vector</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">)</span></code>.
      </p>
<p>
        In some performance-sensitive environments, where vectors are used as a replacement
        for variable-size buffers for file or network operations, <a href="http://en.cppreference.com/w/cpp/language/value_initialization" target="_top">value
        initialization</a> is a cost that is not negligible as elements are going
        to be overwritten by an external source shortly after new elements are added
        to the container.
      </p>
<p>
        <span class="bold"><strong>Boost.Container</strong></span> offers two new members for
        <code class="computeroutput"><span class="identifier">vector</span></code>, <code class="computeroutput"><span class="identifier">static_vector</span></code>
        and <code class="computeroutput"><span class="identifier">stable_vector</span></code>: <code class="computeroutput"><span class="keyword">explicit</span> <span class="identifier">container</span><span class="special">::</span><span class="identifier">container</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">,</span> <span class="identifier">default_init_t</span><span class="special">)</span></code> and <code class="computeroutput"><span class="identifier">container</span><span class="special">::</span><span class="identifier">resize</span><span class="special">(</span><span class="identifier">size_type</span> <span class="identifier">n</span><span class="special">,</span> <span class="identifier">default_init_t</span><span class="special">)</span></code>, where new elements are constructed using
        <a href="http://en.cppreference.com/w/cpp/language/default_initialization" target="_top">default
        initialization</a>.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.extended_functionality.ordered_range_insertion"></a><a class="link" href="extended_functionality.html#container.extended_functionality.ordered_range_insertion" title="Ordered range insertion for associative containers (ordered_unique_range, ordered_range)">Ordered
      range insertion for associative containers (<span class="emphasis"><em>ordered_unique_range</em></span>,
      <span class="emphasis"><em>ordered_range</em></span>) </a>
</h3></div></div></div>
<p>
        When filling associative containers big performance gains can be achieved
        if the input range to be inserted is guaranteed by the user to be ordered
        according to the predicate. This can happen when inserting values from a
        <code class="computeroutput"><span class="identifier">set</span></code> to a <code class="computeroutput"><span class="identifier">multiset</span></code>
        or between different associative container families (<code class="computeroutput"><span class="special">[</span><span class="identifier">multi</span><span class="special">]</span><span class="identifier">set</span><span class="special">/</span><span class="identifier">map</span></code>
        vs. <code class="computeroutput"><span class="identifier">flat_</span><span class="special">[</span><span class="identifier">multi</span><span class="special">]</span><span class="identifier">set</span><span class="special">/</span><span class="identifier">map</span></code>).
      </p>
<p>
        <span class="bold"><strong>Boost.Container</strong></span> has some overloads for constructors
        and insertions taking an <code class="computeroutput"><span class="identifier">ordered_unique_range_t</span></code>
        or an <code class="computeroutput"><span class="identifier">ordered_range_t</span></code> tag
        parameters as the first argument. When an <code class="computeroutput"><span class="identifier">ordered_unique_range_t</span></code>
        overload is used, the user notifies the container that the input range is
        ordered according to the container predicate and has no duplicates. When
        an <code class="computeroutput"><span class="identifier">ordered_range_t</span></code> overload
        is used, the user notifies the container that the input range is ordered
        according to the container predicate but it might have duplicates. With this
        information, the container can avoid multiple predicate calls and improve
        insertion times.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.extended_functionality.configurable_tree_based_associative_containers"></a><a class="link" href="extended_functionality.html#container.extended_functionality.configurable_tree_based_associative_containers" title="Configurable tree-based associative ordered containers">Configurable
      tree-based associative ordered containers</a>
</h3></div></div></div>
<p>
        <code class="computeroutput"><a class="link" href="../boost/container/set.html" title="Class template set">set</a></code>, <code class="computeroutput"><a class="link" href="../boost/container/multiset.html" title="Class template multiset">multiset</a></code>,
        <code class="computeroutput"><a class="link" href="../boost/container/map.html" title="Class template map">map</a></code> and <code class="computeroutput"><a class="link" href="../boost/container/multimap.html" title="Class template multimap">multimap</a></code>
        associative containers are implemented as binary search trees which offer
        the needed complexity and stability guarantees required by the C++ standard
        for associative containers.
      </p>
<p>
        <span class="bold"><strong>Boost.Container</strong></span> offers the possibility to
        configure at compile time some parameters of the binary search tree implementation.
        This configuration is passed as the last template parameter and defined using
        the utility class <code class="computeroutput"><a class="link" href="../boost/container/tree_assoc_options.html" title="Struct template tree_assoc_options">tree_assoc_options</a></code>.
      </p>
<p>
        The following parameters can be configured:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            The underlying <span class="bold"><strong>tree implementation</strong></span> type
            (<code class="computeroutput"><a class="link" href="../boost/container/tree_type.html" title="Struct template tree_type">tree_type</a></code>).
            By default these containers use a red-black tree but the user can use
            other tree types:
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                  <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_top">Red-Black
                  Tree</a>
                </li>
<li class="listitem">
                  <a href="http://en.wikipedia.org/wiki/Avl_trees" target="_top">AVL tree</a>
                </li>
<li class="listitem">
                  <a href="http://en.wikipedia.org/wiki/Scapegoat_tree" target="_top">Scapegoat
                  tree</a>. In this case Insertion and Deletion are amortized
                  O(log n) instead of O(log n).
                </li>
<li class="listitem">
                  <a href="http://en.wikipedia.org/wiki/Splay_tree" target="_top">Splay tree</a>.
                  In this case Searches, Insertions and Deletions are amortized O(log
                  n) instead of O(log n).
                </li>
</ul></div>
          </li>
<li class="listitem">
            Whether the <span class="bold"><strong>size saving</strong></span> mechanisms are
            used to implement the tree nodes (<code class="computeroutput"><a class="link" href="../boost/container/optimize_size.html" title="Struct template optimize_size">optimize_size</a></code>).
            By default this option is activated and is only meaningful to red-black
            and avl trees (in other cases, this option will be ignored). This option
            will try to put rebalancing metadata inside the "parent" pointer
            of the node if the pointer type has enough alignment. Usually, due to
            alignment issues, the metadata uses the size of a pointer yielding to
            four pointer size overhead per node, whereas activating this option usually
            leads to 3 pointer size overhead. Although some mask operations must
            be performed to extract data from this special "parent" pointer,
            in several systems this option also improves performance due to the improved
            cache usage produced by the node size reduction.
          </li>
</ul></div>
<p>
        See the following example to see how <code class="computeroutput"><a class="link" href="../boost/container/tree_assoc_options.html" title="Struct template tree_assoc_options">tree_assoc_options</a></code>
        can be used to customize these containers:
      </p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">container</span><span class="special">/</span><span class="identifier">set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>

<span class="keyword">int</span> <span class="identifier">main</span> <span class="special">()</span>
<span class="special">{</span>
   <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">container</span><span class="special">;</span>

   <span class="comment">//First define several options</span>
   <span class="comment">//</span>

   <span class="comment">//This option specifies an AVL tree based associative container</span>
   <span class="keyword">typedef</span> <span class="identifier">tree_assoc_options</span><span class="special">&lt;</span> <span class="identifier">tree_type</span><span class="special">&lt;</span><span class="identifier">avl_tree</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">AVLTree</span><span class="special">;</span>

   <span class="comment">//This option specifies an AVL tree based associative container</span>
   <span class="comment">//disabling node size optimization.</span>
   <span class="keyword">typedef</span> <span class="identifier">tree_assoc_options</span><span class="special">&lt;</span> <span class="identifier">tree_type</span><span class="special">&lt;</span><span class="identifier">avl_tree</span><span class="special">&gt;</span>
                             <span class="special">,</span> <span class="identifier">optimize_size</span><span class="special">&lt;</span><span class="keyword">false</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">AVLTreeNoSizeOpt</span><span class="special">;</span>

   <span class="comment">//This option specifies an Splay tree based associative container</span>
   <span class="keyword">typedef</span> <span class="identifier">tree_assoc_options</span><span class="special">&lt;</span> <span class="identifier">tree_type</span><span class="special">&lt;</span><span class="identifier">splay_tree</span><span class="special">&gt;</span> <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">SplayTree</span><span class="special">;</span>

   <span class="comment">//Now define new tree-based associative containers</span>
   <span class="comment">//</span>

   <span class="comment">//AVLTree based set container</span>
   <span class="keyword">typedef</span> <span class="identifier">set</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;,</span> <span class="identifier">AVLTree</span><span class="special">&gt;</span> <span class="identifier">AvlSet</span><span class="special">;</span>

   <span class="comment">//AVLTree based set container without size optimization</span>
   <span class="keyword">typedef</span> <span class="identifier">set</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;,</span> <span class="identifier">AVLTreeNoSizeOpt</span><span class="special">&gt;</span> <span class="identifier">AvlSetNoSizeOpt</span><span class="special">;</span>

   <span class="comment">//Splay tree based multiset container</span>
   <span class="keyword">typedef</span> <span class="identifier">multiset</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;,</span> <span class="identifier">SplayTree</span><span class="special">&gt;</span> <span class="identifier">SplayMultiset</span><span class="special">;</span>

   <span class="comment">//Use them</span>
   <span class="comment">//</span>
   <span class="identifier">AvlSet</span> <span class="identifier">avl_set</span><span class="special">;</span>
   <span class="identifier">avl_set</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
   <span class="identifier">assert</span><span class="special">(</span><span class="identifier">avl_set</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="number">0</span><span class="special">)</span> <span class="special">!=</span> <span class="identifier">avl_set</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>

   <span class="identifier">AvlSetNoSizeOpt</span> <span class="identifier">avl_set_no_szopt</span><span class="special">;</span>
   <span class="identifier">avl_set_no_szopt</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="number">1</span><span class="special">);</span>
   <span class="identifier">avl_set_no_szopt</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="number">1</span><span class="special">);</span>
   <span class="identifier">assert</span><span class="special">(</span><span class="identifier">avl_set_no_szopt</span><span class="special">.</span><span class="identifier">count</span><span class="special">(</span><span class="number">1</span><span class="special">)</span> <span class="special">==</span> <span class="number">1</span><span class="special">);</span>

   <span class="identifier">SplayMultiset</span> <span class="identifier">splay_mset</span><span class="special">;</span>
   <span class="identifier">splay_mset</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
   <span class="identifier">splay_mset</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
   <span class="identifier">assert</span><span class="special">(</span><span class="identifier">splay_mset</span><span class="special">.</span><span class="identifier">count</span><span class="special">(</span><span class="number">2</span><span class="special">)</span> <span class="special">==</span> <span class="number">2</span><span class="special">);</span>
   <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.extended_functionality.constant_time_range_splice"></a><a class="link" href="extended_functionality.html#container.extended_functionality.constant_time_range_splice" title="Constant-time range splice for (s)list">Constant-time
      range splice for <code class="computeroutput"><span class="special">(</span><span class="identifier">s</span><span class="special">)</span><span class="identifier">list</span></code></a>
</h3></div></div></div>
<p>
        In the first C++ standard <code class="computeroutput"><span class="identifier">list</span><span class="special">::</span><span class="identifier">size</span><span class="special">()</span></code> was not required to be constant-time, and
        that caused some controversy in the C++ community. Quoting Howard Hinnant's
        <a href="http://howardhinnant.github.io/On_list_size.html" target="_top"><span class="emphasis"><em>On
        List Size</em></span></a> paper:
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          <span class="emphasis"><em>There is a considerable debate on whether <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">size</span><span class="special">()</span></code> should be O(1) or O(N). The usual argument
          notes that it is a tradeoff with:</em></span>
        </p>
<p>
          <code class="computeroutput"><span class="identifier">splice</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span> <span class="identifier">list</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span> <span class="identifier">iterator</span>
          <span class="identifier">first</span><span class="special">,</span>
          <span class="identifier">iterator</span> <span class="identifier">last</span><span class="special">);</span></code>
        </p>
<p>
          <span class="emphasis"><em>If size() is O(1) and this != &amp;x, then this method must perform
          a linear operation so that it can adjust the size member in each list</em></span>
        </p>
</blockquote></div>
<p>
        C++11 definitely required <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code> to be O(1), so range splice became O(N).
        However, Howard Hinnant's paper proposed a new <code class="computeroutput"><span class="identifier">splice</span></code>
        overload so that even O(1) <code class="computeroutput"><span class="identifier">list</span><span class="special">:</span><span class="identifier">size</span><span class="special">()</span></code>
        implementations could achieve O(1) range splice when the range size was known
        to the caller:
      </p>
<div class="blockquote"><blockquote class="blockquote">
<p>
          <code class="computeroutput"><span class="keyword">void</span> <span class="identifier">splice</span><span class="special">(</span><span class="identifier">iterator</span> <span class="identifier">position</span><span class="special">,</span> <span class="identifier">list</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span> <span class="identifier">iterator</span>
          <span class="identifier">first</span><span class="special">,</span>
          <span class="identifier">iterator</span> <span class="identifier">last</span><span class="special">,</span> <span class="identifier">size_type</span>
          <span class="identifier">n</span><span class="special">);</span></code>
        </p>
<p>
          <span class="bold"><strong>Effects</strong></span>: Inserts elements in the range
          [first, last) before position and removes the elements from x.
        </p>
<p>
          <span class="bold"><strong>Requires</strong></span>: [first, last) is a valid range
          in x. The result is undefined if position is an iterator in the range [first,
          last). Invalidates only the iterators and references to the spliced elements.
          n == distance(first, last).
        </p>
<p>
          <span class="bold"><strong>Throws</strong></span>: Nothing.
        </p>
<p>
          <span class="bold"><strong>Complexity</strong></span>: Constant time.
        </p>
</blockquote></div>
<p>
        This new splice signature allows the client to pass the distance of the input
        range in. This information is often available at the call site. If it is
        passed in, then the operation is constant time, even with an O(1) size.
      </p>
<p>
        <span class="bold"><strong>Boost.Container</strong></span> implements this overload
        for <code class="computeroutput"><span class="identifier">list</span></code> and a modified version
        of it for <code class="computeroutput"><span class="identifier">slist</span></code> (as <code class="computeroutput"><span class="identifier">slist</span><span class="special">::</span><span class="identifier">size</span><span class="special">()</span></code>
        is also <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="number">1</span><span class="special">)</span></code>).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.extended_functionality.extended_allocators"></a><a class="link" href="extended_functionality.html#container.extended_functionality.extended_allocators" title="Extended allocators">Extended
      allocators</a>
</h3></div></div></div>
<p>
        Many C++ programmers have ever wondered where does good old realloc fit in
        C++. And that's a good question. Could we improve <code class="computeroutput"><a class="link" href="../boost/container/vector.html" title="Class template vector">vector</a></code>
        performance using memory expansion mechanisms to avoid too many copies? But
        <code class="computeroutput"><a class="link" href="../boost/container/vector.html" title="Class template vector">vector</a></code> is not the only
        container that could benefit from an improved allocator interface: we could
        take advantage of the insertion of multiple elements in <code class="computeroutput"><a class="link" href="../boost/container/list.html" title="Class template list">list</a></code>
        using a burst allocation mechanism that could amortize costs (mutex locks,
        free memory searches...) that can't be amortized when using single node allocation
        strategies.
      </p>
<p>
        These improvements require extending the STL allocator interface and use
        make use of a new general purpose allocator since new and delete don't offer
        expansion and burst capabilities.
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <span class="bold"><strong>Boost.Container</strong></span> containers support an
            extended allocator interface based on an evolution of proposals <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1953.html" target="_top">N1953:
            Upgrading the Interface of Allocators using API Versioning</a>,
            <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2045.html" target="_top">N2045:
            Improving STL allocators</a> and the article <a href="http://www.drivehq.com/web/igaztanaga/allocplus/" target="_top">Applying
            classic memory allocation strategies to C++ containers</a>. The extended
            allocator interface is implemented by <code class="computeroutput"><a class="link" href="../boost/container/allocator.html" title="Class template allocator">allocator</a></code>,
            <code class="computeroutput"><a class="link" href="../boost/container/adaptive_pool.html" title="Class template adaptive_pool">adaptive_pool</a></code>
            and <code class="computeroutput"><a class="link" href="../boost/container/node_allocator.html" title="Class template node_allocator">node_allocator</a></code>
            classes.
          </li>
<li class="listitem">
            Extended allocators use a modified <a href="http://g.oswego.edu/dl/html/malloc.html" target="_top">Doug
            Lea Malloc (DLMalloc)</a> low-level allocator and offers an C API
            to implement memory expansion and burst allocations. DLmalloc is known
            to be very size and speed efficient, and this allocator is used as the
            basis of many malloc implementations, including multithreaded allocators
            built above DLmalloc (See <a href="http://www.malloc.de/en/" target="_top">ptmalloc2,
            ptmalloc3</a> or <a href="http://www.nedprod.com/programs/portable/nedmalloc/" target="_top">nedmalloc</a>).
            This low-level allocator is implemented as a separately compiled library
            and the following extended allocators depend on the library:
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/container/allocator.html" title="Class template allocator">allocator</a></code>: This
            extended allocator offers expansion, shrink-in place and burst allocation
            capabilities implemented as a thin wrapper around the modified DLMalloc.
            It can be used with all containers and it should be the default choice
            when the programmer wants to use extended allocator capabilities.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/container/node_allocator.html" title="Class template node_allocator">node_allocator</a></code>:
            It's a <a href="http://www.boost.org/doc/libs/1_55_0/libs/pool/doc/html/boost_pool/pool/pooling.html#boost_pool.pool.pooling.simple" target="_top">Simple
            Segregated Storage</a> allocator, similar to <span class="bold"><strong>Boost.Pool</strong></span>
            that takes advantage of the modified DLMalloc burst interface. It does
            not return memory to the DLMalloc allocator (and thus, to the system),
            unless explicitly requested. It does offer a very small memory overhead
            so it's suitable for node containers ([boost::container::list list],
            [boost::container::slist slist] [boost::container::set set]...) that
            allocate very small <code class="computeroutput"><span class="identifier">value_type</span></code>s
            and it offers improved node allocation times for single node allocations
            with respecto to <code class="computeroutput"><a class="link" href="../boost/container/allocator.html" title="Class template allocator">allocator</a></code>.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/container/adaptive_pool.html" title="Class template adaptive_pool">adaptive_pool</a></code>:
            It's a low-overhead node allocator that can return memory to the system.
            The overhead can be very low (&lt; 5% for small nodes) and it's nearly
            as fast as <code class="computeroutput"><a class="link" href="../boost/container/node_allocator.html" title="Class template node_allocator">node_allocator</a></code>.
            It's also suitable for node containers.
          </li>
</ul></div>
<p>
        Use them simply specifying the new allocator in the corresponding template
        argument of your favourite container:
      </p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">container</span><span class="special">/</span><span class="identifier">vector</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">container</span><span class="special">/</span><span class="identifier">flat_set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">container</span><span class="special">/</span><span class="identifier">list</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">container</span><span class="special">/</span><span class="identifier">set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="comment">//"allocator" is a general purpose allocator that can reallocate</span>
<span class="comment">//memory, something useful for vector and flat associative containers</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">container</span><span class="special">/</span><span class="identifier">allocator</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="comment">//"adaptive_pool" is a node allocator, specially suited for</span>
<span class="comment">//node-based containers</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">container</span><span class="special">/</span><span class="identifier">adaptive_pool</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">int</span> <span class="identifier">main</span> <span class="special">()</span>
<span class="special">{</span>
   <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">container</span><span class="special">;</span>

   <span class="comment">//A vector that can reallocate memory to implement faster insertions</span>
   <span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">extended_alloc_vector</span><span class="special">;</span>

   <span class="comment">//A flat set that can reallocate memory to implement faster insertions</span>
   <span class="identifier">flat_set</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;,</span> <span class="identifier">allocator</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">extended_alloc_flat_set</span><span class="special">;</span>

   <span class="comment">//A list that can manages nodes to implement faster</span>
   <span class="comment">//range insertions and deletions</span>
   <span class="identifier">list</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">adaptive_pool</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">extended_alloc_list</span><span class="special">;</span>

   <span class="comment">//A set that can recycle nodes to implement faster</span>
   <span class="comment">//range insertions and deletions</span>
   <span class="identifier">set</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">less</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;,</span> <span class="identifier">adaptive_pool</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">extended_alloc_set</span><span class="special">;</span>

   <span class="comment">//Now user them as always</span>
   <span class="identifier">extended_alloc_vector</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
   <span class="identifier">extended_alloc_flat_set</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
   <span class="identifier">extended_alloc_list</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>
   <span class="identifier">extended_alloc_set</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>

   <span class="comment">//...</span>
   <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="container.extended_functionality.polymorphic_memory_resources"></a><a class="link" href="extended_functionality.html#container.extended_functionality.polymorphic_memory_resources" title="Polymorphic Memory Resources">Polymorphic
      Memory Resources </a>
</h3></div></div></div>
<p>
        The document <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4480.html" target="_top">C++
        Extensions for Library Fundamentals (Final draft: N4480)</a> includes
        classes that provide allocator type erasure and runtime polymorphism. As
        Pablo Halpern, the author of the proposal, explains in the paper (<a href="https://isocpp.org/files/papers/N3916.pdf" target="_top">N3916 Polymorphic Memory
        Resources (r2)</a>):
      </p>
<p>
        <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>A significant impediment to effective memory management
        in C++ has been the inability to use allocators in non-generic contexts.
        In large software systems, most of the application program consists of non-generic
        procedural or object-oriented code that is compiled once and linked many
        times.</em></span></span>&#8221;</span>
      </p>
<p>
        <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>Allocators in C++, however, have historically relied solely
        on compile-time polymorphism, and therefore have not been suitable for use
        in vocabulary types, which are passed through interfaces between separately-compiled
        modules, because the allocator type necessarily affects the type of the object
        that uses it. This proposal builds upon the improvements made to allocators
        in C++11 and describes a set of facilities for runtime polymorphic memory
        resources that interoperate with the existing compile-time polymorphic allocators.</em></span></span>&#8221;</span>
      </p>
<p>
        <span class="bold"><strong>Boost.Container</strong></span> implements nearly all classes
        of the proposal under the namespace <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">container</span><span class="special">::</span><span class="identifier">pmr</span></code>.
        There are two groups,
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Header only utilities (these don't require the separately compiled library):
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                  <code class="computeroutput"><a class="link" href="../boost/container/pmr/memory_resource.html" title="Class memory_resource">memory_resource</a></code>.
                </li>
<li class="listitem">
                  <code class="computeroutput"><a class="link" href="../boost/container/pmr/resource_adaptor.html" title="Type definition resource_adaptor">resource_adaptor</a></code>.
                </li>
</ul></div>
          </li>
<li class="listitem">
            Utilities that require the the separately compiled library:
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                  <code class="computeroutput"><a class="link" href="../boost/container/pmr/polymorphic_allocator.html" title="Class template polymorphic_allocator">polymorphic_allocator</a></code>.
                </li>
<li class="listitem">
                  <code class="computeroutput"><a class="link" href="../boost/container/pmr/monotonic_buffer_resource.html" title="Class monotonic_buffer_resource">monotonic_buffer_resource</a></code>.
                </li>
<li class="listitem">
                  <code class="computeroutput"><a class="link" href="../boost/container/pmr/unsynchronized_idp63576512.html" title="Class unsynchronized_pool_resource">unsynchronized_pool_resource</a></code>.
                </li>
<li class="listitem">
                  <code class="computeroutput"><a class="link" href="../boost/container/pmr/synchronized_pool_resource.html" title="Class synchronized_pool_resource">synchronized_pool_resource</a></code>.
                </li>
<li class="listitem">
                  Global resource functions: <code class="computeroutput"><a class="link" href="../boost/container/pmr/get_default_resource.html" title="Function get_default_resource">get_default_resource</a></code>/
                  <code class="computeroutput"><a class="link" href="../boost/container/pmr/set_default_resource.html" title="Function set_default_resource">set_default_resource</a></code>/
                  <code class="computeroutput"><a class="link" href="../boost/container/pmr/new_delete_resource.html" title="Function new_delete_resource">new_delete_resource</a></code>/
                  <code class="computeroutput"><a class="link" href="../boost/container/pmr/null_memory_resource.html" title="Function null_memory_resource">null_memory_resource</a></code>
                </li>
<li class="listitem">
                  Aliases for boost containers using the polymorphic allocator (like
                  <code class="computeroutput"><a class="link" href="../boost_container_header_reference.html#boost.container.pmr.vector">pmr::vector</a></code>,
                  etc.)
                </li>
</ul></div>
          </li>
</ul></div>
<p>
        <span class="bold"><strong>Boost.Container</strong></span>'s polymorphic resource library
        is usable from C++03 containers, and offers some alternative utilities if
        the required C++11 features of the <span class="emphasis"><em>Library Fundamentals</em></span>
        specification are not available.
      </p>
<p>
        Let's review the usage example given in <a href="https://isocpp.org/files/papers/N3916.pdf" target="_top">N3916</a>
        and see how it can be implemented using <span class="bold"><strong>Boost.Container</strong></span>:
        <span class="emphasis"><em>Suppose we are processing a series of shopping lists, where a shopping
        list is a container of strings, and storing them in a collection (a list)
        of shopping lists. Each shopping list being processed uses a bounded amount
        of memory that is needed for a short period of time, while the collection
        of shopping lists uses an unbounded amount of memory and will exist for a
        longer period of time. For efficiency, we can use a more time-efficient memory
        allocator based on a finite buffer for the temporary shopping lists.</em></span>
      </p>
<p>
        Let's see how <code class="computeroutput"><span class="identifier">ShoppingList</span></code>
        can be defined to support an polymorphic memory resource that can allocate
        memory from different underlying mechanisms. The most important details are:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            It should declare that supports an allocator defining an <code class="computeroutput"><span class="identifier">allocator_type</span></code> typedef. This <code class="computeroutput"><span class="identifier">allocator_type</span></code> will be of type <code class="computeroutput"><a class="link" href="../boost/container/pmr/memory_resource.html" title="Class memory_resource">memory_resource *</a></code>,
            which is a base class for polymorphic resources.
          </li>
<li class="listitem">
            It must define constructors that take the the allocator as argument.
            It can be implemented in two ways:
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">ShoppingList</span></code> has
                  constructors taking <code class="computeroutput"><a class="link" href="../boost/container/pmr/memory_resource.html" title="Class memory_resource">memory_resource*</a></code>
                  as the last argument.
                </li>
<li class="listitem">
                  <code class="computeroutput"><span class="identifier">ShoppingList</span></code> has
                  constructors taking <code class="computeroutput"><a class="link" href="../boost/container/allocator_arg_t.html" title="Type definition allocator_arg_t">allocator_arg_t</a></code>
                  as the first argument and <code class="computeroutput"><a class="link" href="../boost/container/pmr/memory_resource.html" title="Class memory_resource">memory_resource*</a></code>
                  as the second argument.
                </li>
</ul></div>
          </li>
</ul></div>
<p>
        <span class="bold"><strong>Note:</strong></span> <span class="emphasis"><em>In C++03 compilers, it is
        required that the programmer specializes as <code class="computeroutput"><span class="keyword">true</span></code>
        <code class="computeroutput"><a class="link" href="../boost/container/constructible__idp67492240.html" title="Struct template constructible_with_allocator_suffix">constructible_with_allocator_suffix</a></code>
        or <code class="computeroutput"><a class="link" href="../boost/container/constructible__idp67501632.html" title="Struct template constructible_with_allocator_prefix">constructible_with_allocator_prefix</a></code>
        as in C++03 there is no way to automatically detect the chosen option at
        compile time. If no specialization is done, <span class="bold"><strong>Boost.Container</strong></span>
        assumes the suffix option</em></span>.
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">//ShoppingList.hpp</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">container</span><span class="special">/</span><span class="identifier">pmr</span><span class="special">/</span><span class="identifier">vector</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">container</span><span class="special">/</span><span class="identifier">pmr</span><span class="special">/</span><span class="identifier">string</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">ShoppingList</span>
<span class="special">{</span>
   <span class="comment">// A vector of strings using polymorphic allocators. Every element</span>
   <span class="comment">// of the vector will use the same allocator as the vector itself.</span>
   <span class="identifier">boost</span><span class="special">::</span><span class="identifier">container</span><span class="special">::</span><span class="identifier">pmr</span><span class="special">::</span><span class="identifier">vector_of</span>
      <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">container</span><span class="special">::</span><span class="identifier">pmr</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">m_strvec</span><span class="special">;</span>
   <span class="comment">//Alternatively in compilers that support template aliases:</span>
   <span class="comment">//    boost::container::pmr::vector&lt;boost::container::pmr::string&gt; m_strvec;</span>
   <span class="keyword">public</span><span class="special">:</span>

   <span class="comment">// This makes uses_allocator&lt;ShoppingList, memory_resource*&gt;::value true</span>
   <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">container</span><span class="special">::</span><span class="identifier">pmr</span><span class="special">::</span><span class="identifier">memory_resource</span><span class="special">*</span> <span class="identifier">allocator_type</span><span class="special">;</span>

   <span class="comment">// If the allocator is not specified, "m_strvec" uses pmr::get_default_resource().</span>
   <span class="keyword">explicit</span> <span class="identifier">ShoppingList</span><span class="special">(</span><span class="identifier">allocator_type</span> <span class="identifier">alloc</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">m_strvec</span><span class="special">(</span><span class="identifier">alloc</span><span class="special">)</span> <span class="special">{}</span>

   <span class="comment">// Copy constructor. As allocator is not specified,</span>
   <span class="comment">// "m_strvec" uses pmr::get_default_resource().</span>
   <span class="identifier">ShoppingList</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">ShoppingList</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">m_strvec</span><span class="special">(</span><span class="identifier">other</span><span class="special">.</span><span class="identifier">m_strvec</span><span class="special">)</span> <span class="special">{}</span>

   <span class="comment">// Copy construct using the given memory_resource.</span>
   <span class="identifier">ShoppingList</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">ShoppingList</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">,</span> <span class="identifier">allocator_type</span> <span class="identifier">a</span><span class="special">)</span>
      <span class="special">:</span> <span class="identifier">m_strvec</span><span class="special">(</span><span class="identifier">other</span><span class="special">.</span><span class="identifier">m_strvec</span><span class="special">,</span> <span class="identifier">a</span><span class="special">)</span> <span class="special">{}</span>

   <span class="identifier">allocator_type</span> <span class="identifier">get_allocator</span><span class="special">()</span> <span class="keyword">const</span>
   <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">m_strvec</span><span class="special">.</span><span class="identifier">get_allocator</span><span class="special">().</span><span class="identifier">resource</span><span class="special">();</span> <span class="special">}</span>

   <span class="keyword">void</span> <span class="identifier">add_item</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span><span class="identifier">item</span><span class="special">)</span>
   <span class="special">{</span> <span class="identifier">m_strvec</span><span class="special">.</span><span class="identifier">emplace_back</span><span class="special">(</span><span class="identifier">item</span><span class="special">);</span> <span class="special">}</span>

   <span class="comment">//...</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        <span class="emphasis"><em>However, this time-efficient allocator is not appropriate for the
        longer lived collection of shopping lists. This example shows how those temporary
        shopping lists, using a time-efficient allocator, can be used to populate
        the long lived collection of shopping lists, using a general purpose allocator,
        something that would be annoyingly difficult without the polymorphic allocators.</em></span>
      </p>
<p>
        In <span class="bold"><strong>Boost.Container</strong></span> for the time-efficient
        allocation we can use <code class="computeroutput"><a class="link" href="../boost/container/pmr/monotonic_buffer_resource.html" title="Class monotonic_buffer_resource">monotonic_buffer_resource</a></code>,
        providing an external buffer that will be used until it's exhausted. In the
        default configuration, when the buffer is exhausted, the default memory resource
        will be used instead.
      </p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="string">"ShoppingList.hpp"</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">container</span><span class="special">/</span><span class="identifier">pmr</span><span class="special">/</span><span class="identifier">list</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">container</span><span class="special">/</span><span class="identifier">pmr</span><span class="special">/</span><span class="identifier">monotonic_buffer_resource</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">void</span> <span class="identifier">processShoppingList</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">ShoppingList</span><span class="special">&amp;)</span>
<span class="special">{</span>  <span class="comment">/**/</span>   <span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span>
<span class="special">{</span>
   <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">container</span><span class="special">;</span>
   <span class="comment">//All memory needed by folder and its contained objects will</span>
   <span class="comment">//be allocated from the default memory resource (usually new/delete) </span>
   <span class="identifier">pmr</span><span class="special">::</span><span class="identifier">list_of</span><span class="special">&lt;</span><span class="identifier">ShoppingList</span><span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">folder</span><span class="special">;</span> <span class="comment">// Default allocator resource</span>
   <span class="comment">//Alternatively in compilers that support template aliases:</span>
   <span class="comment">//    boost::container::pmr::list&lt;ShoppingList&gt; folder;</span>
   <span class="special">{</span>
      <span class="keyword">char</span> <span class="identifier">buffer</span><span class="special">[</span><span class="number">1024</span><span class="special">];</span>
      <span class="identifier">pmr</span><span class="special">::</span><span class="identifier">monotonic_buffer_resource</span> <span class="identifier">buf_rsrc</span><span class="special">(&amp;</span><span class="identifier">buffer</span><span class="special">,</span> <span class="number">1024</span><span class="special">);</span>

      <span class="comment">//All memory needed by temporaryShoppingList will be allocated</span>
      <span class="comment">//from the local buffer (speeds up "processShoppingList")</span>
      <span class="identifier">ShoppingList</span> <span class="identifier">temporaryShoppingList</span><span class="special">(&amp;</span><span class="identifier">buf_rsrc</span><span class="special">);</span>
      <span class="identifier">assert</span><span class="special">(&amp;</span><span class="identifier">buf_rsrc</span> <span class="special">==</span> <span class="identifier">temporaryShoppingList</span><span class="special">.</span><span class="identifier">get_allocator</span><span class="special">());</span>

      <span class="comment">//list nodes, and strings "salt" and "pepper" will be allocated</span>
      <span class="comment">//in the stack thanks to "monotonic_buffer_resource".</span>
      <span class="identifier">temporaryShoppingList</span><span class="special">.</span><span class="identifier">add_item</span><span class="special">(</span><span class="string">"salt"</span><span class="special">);</span>
      <span class="identifier">temporaryShoppingList</span><span class="special">.</span><span class="identifier">add_item</span><span class="special">(</span><span class="string">"pepper"</span><span class="special">);</span>
      <span class="comment">//...</span>

      <span class="comment">//All modifications and additions to "temporaryShoppingList"</span>
      <span class="comment">//will use memory from "buffer" until it's exhausted.</span>
      <span class="identifier">processShoppingList</span><span class="special">(</span><span class="identifier">temporaryShoppingList</span><span class="special">);</span>

      <span class="comment">//Processing done, now insert it in "folder",</span>
      <span class="comment">//which uses the default memory resource</span>
      <span class="identifier">folder</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">temporaryShoppingList</span><span class="special">);</span>
      <span class="identifier">assert</span><span class="special">(</span><span class="identifier">pmr</span><span class="special">::</span><span class="identifier">get_default_resource</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">folder</span><span class="special">.</span><span class="identifier">back</span><span class="special">().</span><span class="identifier">get_allocator</span><span class="special">());</span>
      <span class="comment">//temporaryShoppingList, buf_rsrc, and buffer go out of scope</span>
   <span class="special">}</span>
   <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        <span class="emphasis"><em>Notice that the shopping lists within <code class="computeroutput"><span class="identifier">folder</span></code>
        use the default allocator resource whereas the shopping list <code class="computeroutput"><span class="identifier">temporaryShoppingList</span></code> uses the short-lived
        but very fast <code class="computeroutput"><span class="identifier">buf_rsrc</span></code>. Despite
        using different allocators, you can insert <code class="computeroutput"><span class="identifier">temporaryShoppingList</span></code>
        into folder because they have the same <code class="computeroutput"><span class="identifier">ShoppingList</span></code>
        type. Also, while <code class="computeroutput"><span class="identifier">ShoppingList</span></code>
        uses memory_resource directly, <code class="computeroutput"><a class="link" href="../boost_container_header_reference.html#boost.container.pmr.list">pmr::list</a></code>,
        <code class="computeroutput"><a class="link" href="../boost_container_header_reference.html#boost.container.pmr.vector">pmr::vector</a></code> and
        <code class="computeroutput"><a class="link" href="../boost_container_header_reference.html#boost.container.pmr.string">pmr::string</a></code> all
        use <code class="computeroutput"><a class="link" href="../boost/container/pmr/polymorphic_allocator.html" title="Class template polymorphic_allocator">polymorphic_allocator</a></code>.</em></span>
      </p>
<p>
        <span class="emphasis"><em>The resource passed to the <code class="computeroutput"><span class="identifier">ShoppingList</span></code>
        constructor is propagated to the vector and each string within that <code class="computeroutput"><span class="identifier">ShoppingList</span></code>. Similarly, the resource used
        to construct <code class="computeroutput"><span class="identifier">folder</span></code> is propagated
        to the constructors of the ShoppingLists that are inserted into the list
        (and to the strings within those <code class="computeroutput"><span class="identifier">ShoppingLists</span></code>).
        The <code class="computeroutput"><a class="link" href="../boost/container/pmr/polymorphic_allocator.html" title="Class template polymorphic_allocator">polymorphic_allocator</a></code>
        template is designed to be almost interchangeable with a pointer to <code class="computeroutput"><a class="link" href="../boost/container/pmr/memory_resource.html" title="Class memory_resource">memory_resource</a></code>,
        thus producing a <span class="emphasis"><em>bridge</em></span> between the template-policy
        style of allocator and the polymorphic-base-class style of allocator.</em></span>
      </p>
<p>
        This example actually shows how easy is to use <span class="bold"><strong>Boost.Container</strong></span>
        to write type-erasured allocator-capable classes even in C++03 compilers.
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2009-2015 Ion Gaztanaga<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="non_standard_containers.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../container.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="Cpp11_conformance.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
