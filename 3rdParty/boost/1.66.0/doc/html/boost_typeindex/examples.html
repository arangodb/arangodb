<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Examples</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="The Boost C++ Libraries BoostBook Documentation Subset">
<link rel="up" href="../boost_typeindex.html" title="Chapter&#160;41.&#160;Boost.TypeIndex 4.1">
<link rel="prev" href="how_it_works.html" title="How it works">
<link rel="next" href="../boost_typeindex_header_reference.html" title="Boost.TypeIndex Header Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="how_it_works.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../boost_typeindex.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../boost_typeindex_header_reference.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_typeindex.examples"></a><a class="link" href="examples.html" title="Examples">Examples</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="examples.html#boost_typeindex.examples.getting_human_readable_and_mangl">Getting
      human readable and mangled type names</a></span></dt>
<dt><span class="section"><a href="examples.html#boost_typeindex.examples.storing_information_about_a_type">Storing
      information about a type in container </a></span></dt>
<dt><span class="section"><a href="examples.html#boost_typeindex.examples.getting_through_the_inheritance_">Getting
      through the inheritance to receive a real type name </a></span></dt>
<dt><span class="section"><a href="examples.html#boost_typeindex.examples.using_runtime_cast_where_rtti_is">Using
      runtime_cast where RTTI is unavailable or undesirable </a></span></dt>
<dt><span class="section"><a href="examples.html#boost_typeindex.examples.exact_type_matching_storing_type">Exact
      type matching: storing type with const, volatile and reference qualifiers</a></span></dt>
<dt><span class="section"><a href="examples.html#boost_typeindex.examples.table_of_raw_name_and_pretty_nam">Table
      of raw_name() and pretty_name() outputs with and without RTTI </a></span></dt>
<dt><span class="section"><a href="examples.html#boost_typeindex.examples.c_14_checking_namespace_at_compi">C++14:
      Checking namespace at compile time </a></span></dt>
<dt><span class="section"><a href="examples.html#boost_typeindex.examples.c_14_checking_lexigraphical_orde">C++14:
      Checking lexigraphical order of provided types </a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_typeindex.examples.getting_human_readable_and_mangl"></a><a class="link" href="examples.html#boost_typeindex.examples.getting_human_readable_and_mangl" title="Getting human readable and mangled type names">Getting
      human readable and mangled type names</a>
</h3></div></div></div>
<p>
        The following example shows how short (mangled) and human readable type names
        could be obtained from a type. Works with and without RTTI.
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">foo</span><span class="special">(</span><span class="identifier">T</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\n Short name: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;().</span><span class="identifier">raw_name</span><span class="special">();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\n Readable name: "</span> <span class="special">&lt;&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;().</span><span class="identifier">pretty_name</span><span class="special">();</span>
<span class="special">}</span>

<span class="keyword">struct</span> <span class="identifier">user_defined_type</span><span class="special">{};</span>

<span class="keyword">namespace</span> <span class="identifier">ns1</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">ns2</span> <span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">user_defined_type</span><span class="special">{};</span>
<span class="special">}}</span> <span class="comment">// namespace ns1::ns2</span>

<span class="keyword">namespace</span> <span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">in_anon_type</span><span class="special">{};</span>
<span class="special">}</span> <span class="comment">// anonymous namespace</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">// Call to</span>
    <span class="identifier">foo</span><span class="special">(</span><span class="number">1</span><span class="special">);</span>
    <span class="comment">// will output something like this:</span>
    <span class="comment">//</span>
    <span class="comment">// (RTTI on)                                            (RTTI off)</span>
    <span class="comment">// Short name: i                                        Short name: int]</span>
    <span class="comment">// Readable name: int                                   Readable name: int</span>

    <span class="identifier">user_defined_type</span> <span class="identifier">t</span><span class="special">;</span>
    <span class="identifier">foo</span><span class="special">(</span><span class="identifier">t</span><span class="special">);</span>
    <span class="comment">// Will output:</span>
    <span class="comment">//</span>
    <span class="comment">// (RTTI on)                                            (RTTI off)</span>
    <span class="comment">// Short name: 17user_defined_type                      user_defined_type]</span>
    <span class="comment">// Readable name: user_defined_type                     user_defined_type</span>

    <span class="identifier">ns1</span><span class="special">::</span><span class="identifier">ns2</span><span class="special">::</span><span class="identifier">user_defined_type</span> <span class="identifier">t_in_ns</span><span class="special">;</span>
    <span class="identifier">foo</span><span class="special">(</span><span class="identifier">t_in_ns</span><span class="special">);</span>
    <span class="comment">// Will output:</span>
    <span class="comment">//</span>
    <span class="comment">// (RTTI on)                                            (RTTI off)</span>
    <span class="comment">// Short name: N3ns13ns217user_defined_typeE            ns1::ns2::user_defined_type]</span>
    <span class="comment">// Readable name: ns1::ns2::user_defined_type           ns1::ns2::user_defined_type</span>

    <span class="identifier">in_anon_type</span> <span class="identifier">anon_t</span><span class="special">;</span>
    <span class="identifier">foo</span><span class="special">(</span><span class="identifier">anon_t</span><span class="special">);</span>
    <span class="comment">// Will output:</span>
    <span class="comment">//</span>
    <span class="comment">// (RTTI on)                                            (RTTI off)</span>
    <span class="comment">// Short name: N12_GLOBAL__N_112in_anon_typeE           {anonymous}::in_anon_type]</span>
    <span class="comment">// Readable name: (anonymous namespace)::in_anon_type   {anonymous}::in_anon_type</span>
<span class="special">}</span>
</pre>
<p>
        Short names are very compiler dependant: some compiler will output <code class="computeroutput"><span class="special">.</span><span class="identifier">H</span></code>, others
        <code class="computeroutput"><span class="identifier">i</span></code>.
      </p>
<p>
        Readable names may also differ between compilers: <code class="computeroutput"><span class="keyword">struct</span>
        <span class="identifier">user_defined_type</span></code>, <code class="computeroutput"><span class="identifier">user_defined_type</span></code>.
      </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          With RTTI off different classes with same names in anonymous namespace
          may collapse. See 'RTTI emulation limitations'.
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_typeindex.examples.storing_information_about_a_type"></a><a class="link" href="examples.html#boost_typeindex.examples.storing_information_about_a_type" title="Storing information about a type in container">Storing
      information about a type in container </a>
</h3></div></div></div>
<p>
        The following example shows how an information about a type could be stored.
        Example works with and without RTTI.
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">unordered_set</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">unordered_set</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">type_index</span><span class="special">&gt;</span> <span class="identifier">types</span><span class="special">;</span>

    <span class="comment">// Storing some `boost::type_info`s</span>
    <span class="identifier">types</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;());</span>
    <span class="identifier">types</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="keyword">float</span><span class="special">&gt;());</span>

    <span class="comment">// `types` variable contains two `boost::type_index`es:</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">types</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="number">2</span><span class="special">);</span>

    <span class="comment">// Const, volatile and reference will be striped from the type:</span>
    <span class="keyword">bool</span> <span class="identifier">is_inserted</span> <span class="special">=</span> <span class="identifier">types</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="keyword">int</span><span class="special">&gt;()).</span><span class="identifier">second</span><span class="special">;</span>
    <span class="identifier">assert</span><span class="special">(!</span><span class="identifier">is_inserted</span><span class="special">);</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="identifier">types</span><span class="special">.</span><span class="identifier">erase</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="keyword">float</span><span class="special">&amp;&gt;())</span> <span class="special">==</span> <span class="number">1</span><span class="special">);</span>

    <span class="comment">// We have erased the `float` type, only `int` remains</span>
    <span class="identifier">assert</span><span class="special">(*</span><span class="identifier">types</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;());</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_typeindex.examples.getting_through_the_inheritance_"></a><a class="link" href="examples.html#boost_typeindex.examples.getting_through_the_inheritance_" title="Getting through the inheritance to receive a real type name">Getting
      through the inheritance to receive a real type name </a>
</h3></div></div></div>
<p>
        The following example shows that <code class="computeroutput"><span class="identifier">type_info</span></code>
        is able to store the real type, successfully getting through all the inheritances.
      </p>
<p>
        Example works with and without RTTI."
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">/</span><span class="identifier">runtime_cast</span><span class="special">/</span><span class="identifier">register_runtime_class</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>

<span class="keyword">struct</span> <span class="identifier">A</span> <span class="special">{</span>
    <span class="identifier">BOOST_TYPE_INDEX_REGISTER_CLASS</span>
    <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">A</span><span class="special">(){}</span>
<span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">B</span><span class="special">:</span> <span class="keyword">public</span> <span class="identifier">A</span> <span class="special">{</span> <span class="identifier">BOOST_TYPE_INDEX_REGISTER_CLASS</span> <span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">C</span><span class="special">:</span> <span class="keyword">public</span> <span class="identifier">B</span> <span class="special">{</span> <span class="identifier">BOOST_TYPE_INDEX_REGISTER_CLASS</span> <span class="special">};</span>
<span class="keyword">struct</span> <span class="identifier">D</span><span class="special">:</span> <span class="keyword">public</span> <span class="identifier">C</span> <span class="special">{</span> <span class="identifier">BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS</span><span class="special">(</span><span class="identifier">BOOST_TYPE_INDEX_NO_BASE_CLASS</span><span class="special">)</span> <span class="special">};</span>

<span class="keyword">void</span> <span class="identifier">print_real_type</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">A</span><span class="special">&amp;</span> <span class="identifier">a</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">type_id_runtime</span><span class="special">(</span><span class="identifier">a</span><span class="special">).</span><span class="identifier">pretty_name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">C</span> <span class="identifier">c</span><span class="special">;</span>
    <span class="keyword">const</span> <span class="identifier">A</span><span class="special">&amp;</span> <span class="identifier">c_as_a</span> <span class="special">=</span> <span class="identifier">c</span><span class="special">;</span>
    <span class="identifier">print_real_type</span><span class="special">(</span><span class="identifier">c_as_a</span><span class="special">);</span>    <span class="comment">// Outputs `struct C`</span>
    <span class="identifier">print_real_type</span><span class="special">(</span><span class="identifier">B</span><span class="special">());</span>       <span class="comment">// Outputs `struct B`</span>
</pre>
<p>
        It's also possible to use type_id_runtime with the BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS,
        which adds additional information for runtime_cast to work.
      </p>
<pre class="programlisting">    <span class="identifier">D</span> <span class="identifier">d</span><span class="special">;</span>
    <span class="keyword">const</span> <span class="identifier">A</span><span class="special">&amp;</span> <span class="identifier">d_as_a</span> <span class="special">=</span> <span class="identifier">d</span><span class="special">;</span>
    <span class="identifier">print_real_type</span><span class="special">(</span><span class="identifier">d_as_a</span><span class="special">);</span>    <span class="comment">// Outputs `struct D`</span>

<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_typeindex.examples.using_runtime_cast_where_rtti_is"></a><a class="link" href="examples.html#boost_typeindex.examples.using_runtime_cast_where_rtti_is" title="Using runtime_cast where RTTI is unavailable or undesirable">Using
      runtime_cast where RTTI is unavailable or undesirable </a>
</h3></div></div></div>
<p>
        The following example shows that <code class="computeroutput"><span class="identifier">runtime_cast</span></code>
        is able to find a valid pointer in various class hierarchies regardless of
        inheritance or type relation.
      </p>
<p>
        Example works with and without RTTI."
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">/</span><span class="identifier">runtime_cast</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>

<span class="keyword">struct</span> <span class="identifier">A</span> <span class="special">{</span>
    <span class="identifier">BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS</span><span class="special">(</span><span class="identifier">BOOST_TYPE_INDEX_NO_BASE_CLASS</span><span class="special">)</span>
    <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">A</span><span class="special">()</span>
    <span class="special">{}</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">B</span> <span class="special">{</span>
    <span class="identifier">BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS</span><span class="special">(</span><span class="identifier">BOOST_TYPE_INDEX_NO_BASE_CLASS</span><span class="special">)</span>
    <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">B</span><span class="special">()</span>
    <span class="special">{}</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">C</span> <span class="special">:</span> <span class="identifier">A</span> <span class="special">{</span>
    <span class="identifier">BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS</span><span class="special">((</span><span class="identifier">A</span><span class="special">))</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">D</span> <span class="special">:</span> <span class="identifier">B</span> <span class="special">{</span>
    <span class="identifier">BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS</span><span class="special">((</span><span class="identifier">B</span><span class="special">))</span>
<span class="special">};</span>

<span class="keyword">struct</span> <span class="identifier">E</span> <span class="special">:</span> <span class="identifier">C</span><span class="special">,</span> <span class="identifier">D</span> <span class="special">{</span>
    <span class="identifier">BOOST_TYPE_INDEX_REGISTER_RUNTIME_CLASS</span><span class="special">((</span><span class="identifier">C</span><span class="special">)(</span><span class="identifier">D</span><span class="special">))</span>
<span class="special">};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">C</span> <span class="identifier">c</span><span class="special">;</span>
    <span class="identifier">A</span><span class="special">*</span> <span class="identifier">a</span> <span class="special">=</span> <span class="special">&amp;</span><span class="identifier">c</span><span class="special">;</span>

    <span class="keyword">if</span><span class="special">(</span><span class="identifier">C</span><span class="special">*</span> <span class="identifier">cp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">runtime_cast</span><span class="special">&lt;</span><span class="identifier">C</span><span class="special">*&gt;(</span><span class="identifier">a</span><span class="special">))</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Yes, a points to a C: "</span>
                  <span class="special">&lt;&lt;</span> <span class="identifier">a</span> <span class="special">&lt;&lt;</span> <span class="string">"-&gt;"</span> <span class="special">&lt;&lt;</span> <span class="identifier">cp</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">else</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Error: Expected a to point to a C"</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">if</span><span class="special">(</span><span class="identifier">E</span><span class="special">*</span> <span class="identifier">ce</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">runtime_cast</span><span class="special">&lt;</span><span class="identifier">E</span><span class="special">*&gt;(</span><span class="identifier">a</span><span class="special">))</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Error: Expected a to not points to an E: "</span>
                  <span class="special">&lt;&lt;</span> <span class="identifier">a</span> <span class="special">&lt;&lt;</span> <span class="string">"-&gt;"</span> <span class="special">&lt;&lt;</span> <span class="identifier">ce</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">else</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"But, a does not point to an E"</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">E</span> <span class="identifier">e</span><span class="special">;</span>
    <span class="identifier">C</span><span class="special">*</span> <span class="identifier">cp2</span> <span class="special">=</span> <span class="special">&amp;</span><span class="identifier">e</span><span class="special">;</span>
    <span class="keyword">if</span><span class="special">(</span><span class="identifier">D</span><span class="special">*</span> <span class="identifier">dp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">runtime_cast</span><span class="special">&lt;</span><span class="identifier">D</span><span class="special">*&gt;(</span><span class="identifier">cp2</span><span class="special">))</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Yes, we can cross-cast from a C* to a D* when we actually have an E: "</span>
                  <span class="special">&lt;&lt;</span> <span class="identifier">cp2</span> <span class="special">&lt;&lt;</span> <span class="string">"-&gt;"</span> <span class="special">&lt;&lt;</span> <span class="identifier">dp</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">else</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Error: Expected cp to point to a D"</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
    <span class="special">}</span>
</pre>
<p>
        Alternatively, we can use runtime_pointer_cast so we don't need to specity
        the target as a pointer. This works for smart_ptr types too.
      </p>
<pre class="programlisting">    <span class="identifier">A</span><span class="special">*</span> <span class="identifier">ap</span> <span class="special">=</span> <span class="special">&amp;</span><span class="identifier">e</span><span class="special">;</span>
    <span class="keyword">if</span><span class="special">(</span><span class="identifier">B</span><span class="special">*</span> <span class="identifier">bp</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">runtime_pointer_cast</span><span class="special">&lt;</span><span class="identifier">B</span><span class="special">&gt;(</span><span class="identifier">ap</span><span class="special">))</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Yes, we can cross-cast and up-cast at the same time."</span>
                  <span class="special">&lt;&lt;</span> <span class="identifier">ap</span> <span class="special">&lt;&lt;</span> <span class="string">"-&gt;"</span> <span class="special">&lt;&lt;</span> <span class="identifier">bp</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">else</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Error: Expected ap to point to a B"</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">return</span> <span class="number">0</span><span class="special">;</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_typeindex.examples.exact_type_matching_storing_type"></a><a class="link" href="examples.html#boost_typeindex.examples.exact_type_matching_storing_type" title="Exact type matching: storing type with const, volatile and reference qualifiers">Exact
      type matching: storing type with const, volatile and reference qualifiers</a>
</h3></div></div></div>
<p>
        The following example shows that <code class="computeroutput"><span class="identifier">type_index</span></code>
        (and <code class="computeroutput"><span class="identifier">type_info</span></code>) is able to
        store the exact type, without stripping const, volatile and references. Example
        works with and without RTTI.
      </p>
<p>
        In this example we'll create a class that stores a pointer to function and
        remembers the exact type of the parameter the function accepts. When the
        call to the bound function is made, he actual input parameter type is checked
        against the stored parameter type and an exception is thrown in case of mismatch.
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">stdexcept</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cstdlib</span><span class="special">&gt;</span>

<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">cassert</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">type_erased_unary_function</span> <span class="special">{</span>
    <span class="keyword">void</span><span class="special">*</span>                           <span class="identifier">function_ptr_</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">type_index</span>    <span class="identifier">exact_param_t_</span><span class="special">;</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ParamT</span><span class="special">&gt;</span>
    <span class="identifier">type_erased_unary_function</span><span class="special">(</span><span class="keyword">void</span><span class="special">(*</span><span class="identifier">ptr</span><span class="special">)(</span><span class="identifier">ParamT</span><span class="special">))</span>
        <span class="special">:</span> <span class="identifier">function_ptr_</span><span class="special">(</span><span class="keyword">reinterpret_cast</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">*&gt;(</span><span class="identifier">ptr</span><span class="special">))</span> <span class="comment">// ptr - is a pointer to function returning `void` and accepting parameter of type `ParamT`</span>
        <span class="special">,</span> <span class="identifier">exact_param_t_</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">type_id_with_cvr</span><span class="special">&lt;</span><span class="identifier">ParamT</span><span class="special">&gt;())</span>
    <span class="special">{}</span>

    <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ParamT</span><span class="special">&gt;</span>
    <span class="keyword">void</span> <span class="identifier">call</span><span class="special">(</span><span class="identifier">ParamT</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">if</span> <span class="special">(</span><span class="identifier">exact_param_t_</span> <span class="special">!=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">type_id_with_cvr</span><span class="special">&lt;</span><span class="identifier">ParamT</span><span class="special">&gt;())</span> <span class="special">{</span>
            <span class="keyword">throw</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span><span class="special">(</span><span class="string">"Incorrect `ParamT`"</span><span class="special">);</span>
        <span class="special">}</span>

        <span class="keyword">return</span> <span class="special">(</span><span class="keyword">reinterpret_cast</span><span class="special">&lt;</span><span class="keyword">void</span><span class="special">(*)(</span><span class="identifier">ParamT</span><span class="special">)&gt;(</span><span class="identifier">function_ptr_</span><span class="special">))(</span><span class="identifier">v</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>

<span class="keyword">void</span> <span class="identifier">foo</span><span class="special">(</span><span class="keyword">int</span><span class="special">){}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">type_erased_unary_function</span> <span class="identifier">func</span><span class="special">(&amp;</span><span class="identifier">foo</span><span class="special">);</span>
    <span class="identifier">func</span><span class="special">.</span><span class="identifier">call</span><span class="special">(</span><span class="number">100</span><span class="special">);</span> <span class="comment">// OK, `100` has type `int`</span>

    <span class="keyword">try</span> <span class="special">{</span>
        <span class="keyword">int</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">100</span><span class="special">;</span>

        <span class="comment">// An attempt to convert stored function to a function accepting reference</span>
        <span class="identifier">func</span><span class="special">.</span><span class="identifier">call</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&amp;&gt;(</span><span class="identifier">i</span><span class="special">);</span> <span class="comment">// Will throw, because types `int&amp;` and `int` mismatch</span>

        <span class="identifier">assert</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
    <span class="special">}</span> <span class="keyword">catch</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span><span class="special">&amp;</span> <span class="comment">/*e*/</span><span class="special">)</span> <span class="special">{}</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_typeindex.examples.table_of_raw_name_and_pretty_nam"></a><a class="link" href="examples.html#boost_typeindex.examples.table_of_raw_name_and_pretty_nam" title="Table of raw_name() and pretty_name() outputs with and without RTTI">Table
      of raw_name() and pretty_name() outputs with and without RTTI </a>
</h3></div></div></div>
<p>
        The following example shows how different type names look when we explicitly
        use classes for RTTI and RTT off.
      </p>
<p>
        This example requires RTTI. For a more portable example see 'Getting human
        readable and mangled type names':
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">/</span><span class="identifier">stl_type_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">/</span><span class="identifier">ctti_type_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">print</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">name</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">stl_type_index</span> <span class="identifier">sti</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">stl_type_index</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;();</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">ctti_type_index</span> <span class="identifier">cti</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">ctti_type_index</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;();</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\t["</span> <span class="comment">/* start of the row */</span>
        <span class="special">&lt;&lt;</span> <span class="string">"["</span> <span class="special">&lt;&lt;</span> <span class="identifier">name</span> <span class="special">&lt;&lt;</span> <span class="string">"]"</span>
        <span class="special">&lt;&lt;</span> <span class="string">"[`"</span> <span class="special">&lt;&lt;</span> <span class="identifier">sti</span><span class="special">.</span><span class="identifier">raw_name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"`] "</span>
        <span class="special">&lt;&lt;</span> <span class="string">"[`"</span> <span class="special">&lt;&lt;</span> <span class="identifier">sti</span><span class="special">.</span><span class="identifier">pretty_name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"`] "</span>
        <span class="special">&lt;&lt;</span> <span class="string">"[`"</span> <span class="special">&lt;&lt;</span> <span class="identifier">cti</span><span class="special">.</span><span class="identifier">raw_name</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="string">"`] "</span>
    <span class="special">&lt;&lt;</span> <span class="string">"]\n"</span> <span class="comment">/* end of the row */</span> <span class="special">;</span>
<span class="special">}</span>

<span class="keyword">struct</span> <span class="identifier">user_defined_type</span><span class="special">{};</span>

<span class="keyword">namespace</span> <span class="identifier">ns1</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">ns2</span> <span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">user_defined_type</span><span class="special">{};</span>
<span class="special">}}</span> <span class="comment">// namespace ns1::ns2</span>

<span class="keyword">namespace</span> <span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">in_anon_type</span><span class="special">{};</span>
<span class="special">}</span> <span class="comment">// anonymous namespace</span>

<span class="keyword">namespace</span> <span class="identifier">ns3</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">ns4</span> <span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">in_anon_type</span><span class="special">{};</span>
<span class="special">}}}</span> <span class="comment">// namespace ns3::{anonymous}::ns4</span>


<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T0</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">T1</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">templ</span> <span class="special">{};</span>

<span class="keyword">template</span> <span class="special">&lt;&gt;</span>
<span class="keyword">class</span> <span class="identifier">templ</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="special">{};</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"[table:id Table of names\n"</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"\t[[Type] [RTTI &amp; raw_name] [RTTI &amp; pretty_name] [noRTTI &amp; raw_name]]\n"</span><span class="special">;</span>

    <span class="identifier">print</span><span class="special">&lt;</span><span class="identifier">user_defined_type</span><span class="special">&gt;(</span><span class="string">"User defined type"</span><span class="special">);</span>
    <span class="identifier">print</span><span class="special">&lt;</span><span class="identifier">in_anon_type</span><span class="special">&gt;(</span><span class="string">"In anonymous namespace"</span><span class="special">);</span>
    <span class="identifier">print</span><span class="special">&lt;</span><span class="identifier">ns3</span><span class="special">::</span><span class="identifier">ns4</span><span class="special">::</span><span class="identifier">in_anon_type</span><span class="special">&gt;(</span><span class="string">"In ns3::{anonymous}::ns4 namespace"</span><span class="special">);</span>
    <span class="identifier">print</span><span class="special">&lt;</span><span class="identifier">templ</span><span class="special">&lt;</span><span class="keyword">short</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;(</span><span class="string">"Template class"</span><span class="special">);</span>
    <span class="identifier">print</span><span class="special">&lt;</span><span class="identifier">templ</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="special">&gt;(</span><span class="string">"Template class (full specialization)"</span><span class="special">);</span>
    <span class="identifier">print</span><span class="special">&lt;</span><span class="identifier">templ</span><span class="special">&lt;</span>
        <span class="identifier">templ</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">,</span> <span class="keyword">signed</span> <span class="keyword">char</span><span class="special">&gt;,</span>
        <span class="identifier">templ</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">user_defined_type</span><span class="special">&gt;</span>
    <span class="special">&gt;</span> <span class="special">&gt;(</span><span class="string">"Template class with templae classes"</span><span class="special">);</span>


    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"]\n"</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        Code from the example will produce the following table:
      </p>
<div class="table">
<a name="boost_typeindex.examples.table_of_raw_name_and_pretty_nam.id"></a><p class="title"><b>Table&#160;41.2.&#160;Table of names</b></p>
<div class="table-contents"><table class="table" summary="Table of names">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Type
                </p>
              </th>
<th>
                <p>
                  RTTI &amp; raw_name
                </p>
              </th>
<th>
                <p>
                  RTTI &amp; pretty_name
                </p>
              </th>
<th>
                <p>
                  noRTTI &amp; raw_name
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  User defined type
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="number">17u</span><span class="identifier">ser_defined_type</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">user_defined_type</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">user_defined_type</span><span class="special">]</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  In anonymous namespace
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">N12_GLOBAL__N_112in_anon_typeE</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="special">(</span><span class="identifier">anonymous</span>
                  <span class="keyword">namespace</span><span class="special">)::</span><span class="identifier">in_anon_type</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="special">{</span><span class="identifier">anonymous</span><span class="special">}::</span><span class="identifier">in_anon_type</span><span class="special">]</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  In ns3::{anonymous}::ns4 namespace
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">N3ns312_GLOBAL__N_13ns412in_anon_typeE</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">ns3</span><span class="special">::(</span><span class="identifier">anonymous</span> <span class="keyword">namespace</span><span class="special">)::</span><span class="identifier">ns4</span><span class="special">::</span><span class="identifier">in_anon_type</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">ns3</span><span class="special">::{</span><span class="identifier">anonymous</span><span class="special">}::</span><span class="identifier">ns4</span><span class="special">::</span><span class="identifier">in_anon_type</span><span class="special">]</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Template class
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="number">5</span><span class="identifier">templIsiE</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">templ</span><span class="special">&lt;</span><span class="keyword">short</span><span class="special">,</span>
                  <span class="keyword">int</span><span class="special">&gt;</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">templ</span><span class="special">&lt;</span><span class="keyword">short</span> <span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;]</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Template class (full specialization)
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="number">5</span><span class="identifier">templIiiE</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">templ</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">templ</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;]</span></code>
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Template class with template classes
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="number">5</span><span class="identifier">templIS_IcaES_Ii17user_defined_typeEE</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">templ</span><span class="special">&lt;</span><span class="identifier">templ</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">,</span>
                  <span class="keyword">signed</span> <span class="keyword">char</span><span class="special">&gt;,</span> <span class="identifier">templ</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">user_defined_type</span><span class="special">&gt;</span> <span class="special">&gt;</span></code>
                </p>
              </td>
<td>
                <p>
                  <code class="computeroutput"><span class="identifier">templ</span><span class="special">&lt;</span><span class="identifier">templ</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">,</span>
                  <span class="keyword">signed</span> <span class="keyword">char</span><span class="special">&gt;,</span> <span class="identifier">templ</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">user_defined_type</span><span class="special">&gt;</span> <span class="special">&gt;]</span></code>
                </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
        We have not show the "noRTTI &amp; pretty_name" column in the table
        because it is almost equal to "noRTTI &amp; raw_name" column.
      </p>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          With RTTI off different classes with same names in anonymous namespace
          may collapse. See 'RTTI emulation limitations'.
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_typeindex.examples.c_14_checking_namespace_at_compi"></a><a class="link" href="examples.html#boost_typeindex.examples.c_14_checking_namespace_at_compi" title="C++14: Checking namespace at compile time">C++14:
      Checking namespace at compile time </a>
</h3></div></div></div>
<p>
        The following example shows that <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">ctti_type_index</span></code>
        is usable at compile time on a C++14 compatible compilers.
      </p>
<p>
        In this example we'll create and use a constexpr function that checks namespace
        of the provided type.
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">/</span><span class="identifier">ctti_type_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="comment">// Helper function that returns true if `name` starts with `substr`</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">N</span><span class="special">&gt;</span>
<span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="identifier">starts_with</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">name</span><span class="special">,</span> <span class="keyword">const</span> <span class="keyword">char</span> <span class="special">(&amp;</span><span class="identifier">substr</span><span class="special">)[</span><span class="identifier">N</span><span class="special">])</span> <span class="keyword">noexcept</span><span class="special">;</span>


<span class="comment">// Function that returns true if `T` declared in namespace `ns`</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">N</span><span class="special">&gt;</span>
<span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="identifier">in_namespace</span><span class="special">(</span><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">(&amp;</span><span class="identifier">ns</span><span class="special">)[</span><span class="identifier">N</span><span class="special">])</span> <span class="keyword">noexcept</span> <span class="special">{</span>
    <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">name</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">ctti_type_index</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;().</span><span class="identifier">raw_name</span><span class="special">();</span>

    <span class="comment">// Some compilers add `class ` or `struct ` before the namespace, so we need to skip those words first</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">starts_with</span><span class="special">(</span><span class="identifier">name</span><span class="special">,</span> <span class="string">"class "</span><span class="special">))</span> <span class="special">{</span>
        <span class="identifier">name</span> <span class="special">+=</span> <span class="keyword">sizeof</span><span class="special">(</span><span class="string">"class "</span><span class="special">)</span> <span class="special">-</span> <span class="number">1</span><span class="special">;</span>
    <span class="special">}</span> <span class="keyword">else</span> <span class="keyword">if</span> <span class="special">(</span><span class="identifier">starts_with</span><span class="special">(</span><span class="identifier">name</span><span class="special">,</span> <span class="string">"struct "</span><span class="special">))</span> <span class="special">{</span>
        <span class="identifier">name</span> <span class="special">+=</span> <span class="keyword">sizeof</span><span class="special">(</span><span class="string">"struct "</span><span class="special">)</span> <span class="special">-</span> <span class="number">1</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">return</span> <span class="identifier">starts_with</span><span class="special">(</span><span class="identifier">name</span><span class="special">,</span> <span class="identifier">ns</span><span class="special">)</span> <span class="special">&amp;&amp;</span> <span class="identifier">starts_with</span><span class="special">(</span><span class="identifier">name</span> <span class="special">+</span> <span class="identifier">N</span> <span class="special">-</span> <span class="number">1</span><span class="special">,</span> <span class="string">"::"</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        Now when we have that wonderfull function, we can do static assertions and
        other compile-time validations:
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">my_project</span> <span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">serializer</span> <span class="special">{</span>
        <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">T</span><span class="special">&gt;</span>
        <span class="keyword">void</span> <span class="identifier">serialize</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">)</span> <span class="special">{</span>
            <span class="keyword">static_assert</span><span class="special">(</span>
                <span class="identifier">in_namespace</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="string">"my_project::types"</span><span class="special">)</span> <span class="special">||</span> <span class="identifier">in_namespace</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(</span><span class="string">"my_project::types_ext"</span><span class="special">),</span>
                <span class="string">"Only types from namespaces `my_project::types` and `my_project::types_ext` are allowed to be serialized using `my_project::serializer`"</span>
            <span class="special">);</span>

            <span class="comment">// Actual implementation of the serialization goes below</span>
            <span class="comment">// ...</span>
            <span class="identifier">do_something</span><span class="special">(</span><span class="identifier">value</span><span class="special">);</span>
        <span class="special">}</span>
    <span class="special">};</span>

    <span class="keyword">namespace</span> <span class="identifier">types</span> <span class="special">{</span>
        <span class="keyword">struct</span> <span class="identifier">foo</span><span class="special">{};</span>
        <span class="keyword">struct</span> <span class="identifier">bar</span><span class="special">{};</span>
    <span class="special">}</span>
<span class="special">}</span> <span class="comment">// namespace my_project</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">my_project</span><span class="special">::</span><span class="identifier">serializer</span> <span class="identifier">s</span><span class="special">;</span>
    <span class="identifier">my_project</span><span class="special">::</span><span class="identifier">types</span><span class="special">::</span><span class="identifier">foo</span> <span class="identifier">f</span><span class="special">;</span>
    <span class="identifier">my_project</span><span class="special">::</span><span class="identifier">types</span><span class="special">::</span><span class="identifier">bar</span> <span class="identifier">b</span><span class="special">;</span>

    <span class="identifier">s</span><span class="special">.</span><span class="identifier">serialize</span><span class="special">(</span><span class="identifier">f</span><span class="special">);</span>
    <span class="identifier">s</span><span class="special">.</span><span class="identifier">serialize</span><span class="special">(</span><span class="identifier">b</span><span class="special">);</span>

    <span class="comment">// short sh = 0;</span>
    <span class="comment">// s.serialize(sh); // Fails the static_assert!</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_typeindex.examples.c_14_checking_lexigraphical_orde"></a><a class="link" href="examples.html#boost_typeindex.examples.c_14_checking_lexigraphical_orde" title="C++14: Checking lexigraphical order of provided types">C++14:
      Checking lexigraphical order of provided types </a>
</h3></div></div></div>
<p>
        The following example shows that <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">::</span><span class="identifier">ctti_type_index</span></code>
        is usable at compile time on a C++14 compatible compilers to check order
        of template parameters.
      </p>
<p>
        Consider the situation when we have a function that accepts std::tuple, boost::variant
        or some other class that uses variadic templates:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span><span class="special">...</span> <span class="identifier">T</span><span class="special">&gt;</span> <span class="keyword">class</span> <span class="identifier">types</span><span class="special">{};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span><span class="special">...</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">do_something</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">types</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">...&gt;&amp;</span> <span class="identifier">t</span><span class="special">)</span> <span class="keyword">noexcept</span><span class="special">;</span>
</pre>
<p>
        Such functions may be very usefull, however they may significantly increase
        the size of the resulting program. Each instantionation of such function
        with different templates order consumes space in the resulting program:
      </p>
<pre class="programlisting"><span class="comment">// Types are same, but different order leads to new instantionation of do_something function.</span>
<span class="identifier">types</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">,</span> <span class="keyword">double</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span>
<span class="identifier">types</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="keyword">double</span><span class="special">&gt;</span>
<span class="identifier">types</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">bool</span><span class="special">,</span> <span class="keyword">double</span><span class="special">&gt;</span>
<span class="identifier">types</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">double</span><span class="special">,</span> <span class="keyword">bool</span><span class="special">&gt;</span>
<span class="identifier">types</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="keyword">bool</span><span class="special">&gt;</span>
<span class="identifier">types</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">,</span> <span class="keyword">bool</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span>
</pre>
<p>
        One of the ways to reduce instantinations count is to force the types to
        have some order:
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_index</span><span class="special">/</span><span class="identifier">ctti_type_index</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="comment">// Implementing type trait that returns true if the types are sorted lexographicaly</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span><span class="special">...</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="identifier">is_asc_sorted</span><span class="special">(</span><span class="identifier">types</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">...&gt;)</span> <span class="keyword">noexcept</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">Lhs</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Rhs</span><span class="special">,</span> <span class="keyword">class</span><span class="special">...</span> <span class="identifier">TN</span><span class="special">&gt;</span>
<span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="identifier">is_asc_sorted</span><span class="special">(</span><span class="identifier">types</span><span class="special">&lt;</span><span class="identifier">Lhs</span><span class="special">,</span> <span class="identifier">Rhs</span><span class="special">,</span> <span class="identifier">TN</span><span class="special">...&gt;)</span> <span class="keyword">noexcept</span> <span class="special">{</span>
    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">typeindex</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">ctti_type_index</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="identifier">Lhs</span><span class="special">&gt;()</span> <span class="special">&lt;=</span> <span class="identifier">ctti_type_index</span><span class="special">::</span><span class="identifier">type_id</span><span class="special">&lt;</span><span class="identifier">Rhs</span><span class="special">&gt;()</span>
        <span class="special">&amp;&amp;</span> <span class="identifier">is_asc_sorted</span><span class="special">(</span><span class="identifier">types</span><span class="special">&lt;</span><span class="identifier">Rhs</span><span class="special">,</span> <span class="identifier">TN</span><span class="special">...&gt;());</span>
<span class="special">}</span>


<span class="comment">// Using the newly created `is_asc_sorted` trait:</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span><span class="special">...</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">do_something</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">types</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">...&gt;&amp;</span> <span class="comment">/*value*/</span><span class="special">)</span> <span class="keyword">noexcept</span> <span class="special">{</span>
    <span class="keyword">static_assert</span><span class="special">(</span>
        <span class="identifier">is_asc_sorted</span><span class="special">(</span> <span class="identifier">types</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">...&gt;()</span> <span class="special">),</span>
        <span class="string">"T... for do_something(const types&lt;T...&gt;&amp; t) must be sorted ascending"</span>
    <span class="special">);</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">do_something</span><span class="special">(</span> <span class="identifier">types</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">,</span> <span class="keyword">double</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;()</span> <span class="special">);</span>
    <span class="comment">// do_something( types&lt;bool, int, double&gt;() ); // Fails the static_assert!</span>
<span class="special">}</span>
</pre>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2012-2016 Antony Polukhin<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="how_it_works.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../boost_typeindex.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../boost_typeindex_header_reference.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
