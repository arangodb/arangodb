<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Boost.Hana: Functional</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group-functional.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Functional</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>General purpose function objects. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga835970cb25a0c8dc200f1e5f8943538b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">boost::hana::always</a></td></tr>
<tr class="memdesc:ga835970cb25a0c8dc200f1e5f8943538b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a constant function returning <code>x</code> regardless of the argument(s) it is invoked with.  <a href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">More...</a><br /></td></tr>
<tr class="separator:ga835970cb25a0c8dc200f1e5f8943538b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30027c383676084be151ef3c6cf2829f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">boost::hana::apply</a></td></tr>
<tr class="memdesc:ga30027c383676084be151ef3c6cf2829f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a Callable with the given arguments.  <a href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">More...</a><br /></td></tr>
<tr class="separator:ga30027c383676084be151ef3c6cf2829f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6acc765a35c4dc85f0deab4785831a3d"><td class="memTemplParams" colspan="2">template&lt;std::size_t n&gt; </td></tr>
<tr class="memitem:ga6acc765a35c4dc85f0deab4785831a3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga6acc765a35c4dc85f0deab4785831a3d">boost::hana::arg</a></td></tr>
<tr class="memdesc:ga6acc765a35c4dc85f0deab4785831a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <code>n</code>th passed argument.  <a href="group__group-functional.html#ga6acc765a35c4dc85f0deab4785831a3d">More...</a><br /></td></tr>
<tr class="separator:ga6acc765a35c4dc85f0deab4785831a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ada6b336e9d5bcb101ff0c737acbd0"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></td></tr>
<tr class="memdesc:ga41ada6b336e9d5bcb101ff0c737acbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function capturing the given variables.  <a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">More...</a><br /></td></tr>
<tr class="separator:ga41ada6b336e9d5bcb101ff0c737acbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b16146e53efcdf9ecbb9a7b21f8cd0b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">boost::hana::compose</a></td></tr>
<tr class="memdesc:ga3b16146e53efcdf9ecbb9a7b21f8cd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the composition of two functions or more.  <a href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">More...</a><br /></td></tr>
<tr class="separator:ga3b16146e53efcdf9ecbb9a7b21f8cd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49ea872ade5ac8f6c10052c495302e89"><td class="memTemplParams" colspan="2">template&lt;std::size_t n&gt; </td></tr>
<tr class="memitem:ga49ea872ade5ac8f6c10052c495302e89"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga49ea872ade5ac8f6c10052c495302e89">boost::hana::curry</a></td></tr>
<tr class="memdesc:ga49ea872ade5ac8f6c10052c495302e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Curry a function up to the given number of arguments.  <a href="group__group-functional.html#ga49ea872ade5ac8f6c10052c495302e89">More...</a><br /></td></tr>
<tr class="separator:ga49ea872ade5ac8f6c10052c495302e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a8316acd5efa22c3d1861b62d5df3c2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga3a8316acd5efa22c3d1861b62d5df3c2">boost::hana::demux</a></td></tr>
<tr class="memdesc:ga3a8316acd5efa22c3d1861b62d5df3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function with the results of invoking other functions on its arguments.  <a href="group__group-functional.html#ga3a8316acd5efa22c3d1861b62d5df3c2">More...</a><br /></td></tr>
<tr class="separator:ga3a8316acd5efa22c3d1861b62d5df3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1393f40da2e8da6e0c12fce953e56a6c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">boost::hana::fix</a></td></tr>
<tr class="memdesc:ga1393f40da2e8da6e0c12fce953e56a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a function computing the fixed point of a function.  <a href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">More...</a><br /></td></tr>
<tr class="separator:ga1393f40da2e8da6e0c12fce953e56a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga004f884cdbb85c2efe3383c1db450094"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">boost::hana::flip</a></td></tr>
<tr class="memdesc:ga004f884cdbb85c2efe3383c1db450094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function with its two first arguments reversed.  <a href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">More...</a><br /></td></tr>
<tr class="separator:ga004f884cdbb85c2efe3383c1db450094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef38cf34324c8edbd3597ae71811d00d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">boost::hana::id</a></td></tr>
<tr class="memdesc:gaef38cf34324c8edbd3597ae71811d00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The identity function &ndash; returns its argument unchanged.  <a href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">More...</a><br /></td></tr>
<tr class="separator:gaef38cf34324c8edbd3597ae71811d00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bdafba6dc801f1d2d83731ad9714557"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">boost::hana::infix</a></td></tr>
<tr class="memdesc:ga7bdafba6dc801f1d2d83731ad9714557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an equivalent function that can also be applied in infix notation.  <a href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">More...</a><br /></td></tr>
<tr class="separator:ga7bdafba6dc801f1d2d83731ad9714557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1b8669c022d8675d68e5974451073d1"><td class="memTemplParams" colspan="2">template&lt;std::size_t n&gt; </td></tr>
<tr class="memitem:gad1b8669c022d8675d68e5974451073d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-functional.html#gad1b8669c022d8675d68e5974451073d1">boost::hana::iterate</a></td></tr>
<tr class="memdesc:gad1b8669c022d8675d68e5974451073d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies another function <code>n</code> times to its argument.  <a href="group__group-functional.html#gad1b8669c022d8675d68e5974451073d1">More...</a><br /></td></tr>
<tr class="separator:gad1b8669c022d8675d68e5974451073d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca60c09e1f7a32a2b52baaf6515c279"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#gafca60c09e1f7a32a2b52baaf6515c279">boost::hana::lockstep</a></td></tr>
<tr class="memdesc:gafca60c09e1f7a32a2b52baaf6515c279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function with the result of invoking other functions on its arguments, in lockstep.  <a href="group__group-functional.html#gafca60c09e1f7a32a2b52baaf6515c279">More...</a><br /></td></tr>
<tr class="separator:gafca60c09e1f7a32a2b52baaf6515c279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35c4fc3c5677b9f558150b90e74d3ab1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">boost::hana::on</a></td></tr>
<tr class="memdesc:ga35c4fc3c5677b9f558150b90e74d3ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function with the result of invoking another function on each argument.  <a href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">More...</a><br /></td></tr>
<tr class="separator:ga35c4fc3c5677b9f558150b90e74d3ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83e71bae315e299f9f5f9de77b012139"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga83e71bae315e299f9f5f9de77b012139">boost::hana::overload</a></td></tr>
<tr class="memdesc:ga83e71bae315e299f9f5f9de77b012139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick one of several functions to call based on overload resolution.  <a href="group__group-functional.html#ga83e71bae315e299f9f5f9de77b012139">More...</a><br /></td></tr>
<tr class="separator:ga83e71bae315e299f9f5f9de77b012139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa46de6f618d9f14edb1589b36b6e75ec"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#gaa46de6f618d9f14edb1589b36b6e75ec">boost::hana::overload_linearly</a></td></tr>
<tr class="memdesc:gaa46de6f618d9f14edb1589b36b6e75ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the first function that produces a valid call expression.  <a href="group__group-functional.html#gaa46de6f618d9f14edb1589b36b6e75ec">More...</a><br /></td></tr>
<tr class="separator:gaa46de6f618d9f14edb1589b36b6e75ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778b2daa27882e71d28b6f2b38982ddf"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga778b2daa27882e71d28b6f2b38982ddf">boost::hana::partial</a></td></tr>
<tr class="memdesc:ga778b2daa27882e71d28b6f2b38982ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partially apply a function to some arguments.  <a href="group__group-functional.html#ga778b2daa27882e71d28b6f2b38982ddf">More...</a><br /></td></tr>
<tr class="separator:ga778b2daa27882e71d28b6f2b38982ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefe9fd152cba94be71c2b5b9de689d23"><td class="memItemLeft" align="right" valign="top">constexpr unspecified&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">boost::hana::_</a> {}</td></tr>
<tr class="memdesc:gaefe9fd152cba94be71c2b5b9de689d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create simple functions representing C++ operators inline.  <a href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">More...</a><br /></td></tr>
<tr class="separator:gaefe9fd152cba94be71c2b5b9de689d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e648f0d3fc0209ec024e9d759a5e8f8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-functional.html#ga6e648f0d3fc0209ec024e9d759a5e8f8">boost::hana::reverse_partial</a></td></tr>
<tr class="memdesc:ga6e648f0d3fc0209ec024e9d759a5e8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partially apply a function to some arguments.  <a href="group__group-functional.html#ga6e648f0d3fc0209ec024e9d759a5e8f8">More...</a><br /></td></tr>
<tr class="separator:ga6e648f0d3fc0209ec024e9d759a5e8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga835970cb25a0c8dc200f1e5f8943538b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::always</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="always_8hpp.html">boost/hana/functional/always.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; ...y) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">            <span class="keywordflow">return</span> forwarded(x);</div><div class="line">        };</div><div class="line">    }</div><div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Return a constant function returning <code>x</code> regardless of the argument(s) it is invoked with. </p>
<p>Specifically, <code>always(x)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(x)(y...) == x</div></div><!-- fragment --><p> for any <code>y...</code>. A copy of <code>x</code> is made and it is owned by the <code>always(x)</code> function. When <code>always(x)</code> is called, it will return a reference to the <code>x</code> it owns. This reference is valid as long as <code>always(x)</code> is in scope.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="always_8hpp.html">boost/hana/functional/always.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">hana::always</a>(1)() == 1, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">hana::always</a>(<span class="charliteral">&#39;2&#39;</span>)(1, 2, 3) == <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga30027c383676084be151ef3c6cf2829f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::apply</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="apply_8hpp.html">boost/hana/functional/apply.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> forwarded(f)(forwarded(x)...);</div><div class="line">    }</div></div><!-- fragment -->
<p>Invokes a Callable with the given arguments. </p>
<p>This is equivalent to <a href="http://en.cppreference.com/w/cpp/utility/functional/invoke">std::invoke</a> that will be added in C++17. However, <code>apply</code> is a function object instead of a function, which makes it possible to pass it to higher-order algorithms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A <a href="http://en.cppreference.com/w/cpp/concept/Callable">Callable</a> to be invoked with the given arguments.</td></tr>
    <tr><td class="paramname">x...</td><td>The arguments to call <code>f</code> with. The number of <code>x...</code> must match the arity of <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="apply_8hpp.html">boost/hana/functional/apply.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plus_8hpp.html">boost/hana/plus.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">hana::apply</a>(<a class="code" href="group__group-Monoid.html#gaeb5d4a1e967e319712f9e4791948896c">hana::plus</a>, 1, 2) == 3, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
<p>Referenced by <a class="el" href="namespaceboost_1_1hana_1_1literals.html#a85ac3c47d02722a334181aab540e732c">boost::hana::literals::operator&quot;&quot;_c()</a>, and <a class="el" href="namespaceboost_1_1hana_1_1literals.html#a325859c7db2c3f8e6a4bfab5a81a6dcb">boost::hana::literals::operator&quot;&quot;_s()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6acc765a35c4dc85f0deab4785831a3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::arg</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="arg_8hpp.html">boost/hana/functional/arg.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x1, ..., <span class="keyword">auto</span>&amp;&amp; xm) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> forwarded(xn);</div><div class="line">    }</div></div><!-- fragment -->
<p>Return the <code>n</code>th passed argument. </p>
<p>Specifically, <code>arg&lt;n&gt;(x1, ..., xn, ..., xm)</code> is equivalent to <code>xn</code>. Note that indexing starts at 1, so <code>arg&lt;1&gt;</code> returns the 1st argument, <code>arg&lt;2&gt;</code> the 2nd and so on. Using <code>arg&lt;0&gt;</code> is an error. Passing less than <code>n</code> arguments to <code>arg&lt;n&gt;</code> is also an error.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>An unsigned integer representing the argument to return. <code>n</code> must be positive (meaning nonzero).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1,...,xm</td><td>A variadic pack of arguments from which the <code>n</code>th one is returned.</td></tr>
  </table>
  </dd>
</dl>
<h3>Discussion: could <code>n</code> be dynamic?</h3>
<p>We could have chosen <code>arg</code> to be used like <code>arg(n)(x...)</code> instead of <code>arg&lt;n&gt;(x...)</code>. Provided all the arguments were of the same type, it would then be possible for <code>n</code> to only be known at runtime. However, we would then lose the ability to assert the in-boundedness of <code>n</code> statically.</p>
<h3>Rationale for <code>n</code> being a non-type template parameter</h3>
<p>I claim that the only interesting use case is with a compile-time <code>n</code>, which means that the usage would become <code>arg(int_&lt;n&gt;)(x...)</code>, which is more cumbersome to write than <code>arg&lt;n&gt;(x...)</code>. This is open for discussion. </p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="arg_8hpp.html">boost/hana/functional/arg.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// hana::arg&lt;0&gt;(1, &#39;2&#39;, 3.3); // static assertion (regardless of the number of arguments)</span></div><div class="line">static_assert(hana::arg&lt;1&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3) == 1, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(hana::arg&lt;2&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3) == <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(hana::arg&lt;3&gt;(1, <span class="charliteral">&#39;2&#39;</span>, 3.3) == 3.3, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><span class="comment">// hana::arg&lt;4&gt;(1, &#39;2&#39;, 3.3); // static assertion</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga41ada6b336e9d5bcb101ff0c737acbd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::capture</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="capture_8hpp.html">boost/hana/functional/capture.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; ...variables) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; f) {</div><div class="line">            <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...args) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">                <span class="keywordflow">return</span> forwarded(f)(forwarded(variables)..., forwarded(args)...);</div><div class="line">            };</div><div class="line">        };</div><div class="line">    }</div><div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Create a function capturing the given variables. </p>
<p>Given 0 or more variables, <code>capture</code> creates a closure that can be used to partially apply a function. This is very similar to <code>partial</code>, except that <code>capture</code> allows the partially applied function to be specified later. Specifically, <code>capture(vars...)</code> is a function object taking a function <code>f</code> and returning <code>f</code> partially applied to <code>vars...</code>. In other words, </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>(vars...)(f)(args...) == f(vars..., args...)</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The arity of <code>f</code> must match the total number of arguments passed to it, i.e. <code>sizeof...(vars) + sizeof...(args)</code>.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="capture_8hpp.html">boost/hana/functional/capture.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> <a class="code" href="group__group-Foldable.html#ga650def4b2e98f4273d8b9b7aa5a2fc28">sum</a> = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {</div><div class="line">        <span class="keywordflow">return</span> x + y + z;</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">hana::capture</a>(1, 2, 3)(sum)() == 6);</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">hana::capture</a>(1, 2)(sum)(3) == 6);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga3b16146e53efcdf9ecbb9a7b21f8cd0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::compose</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="compose_8hpp.html">boost/hana/functional/compose.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f1, <span class="keyword">auto</span>&amp;&amp; f2, ..., <span class="keyword">auto</span>&amp;&amp; fn) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; ...xs) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">            <span class="keywordflow">return</span> forwarded(f1)(</div><div class="line">                    forwarded(f2)(</div><div class="line">                     ...</div><div class="line">                      forwarded(fn)(forwarded(x))</div><div class="line">                    ),</div><div class="line">                    forwarded(xs)...</div><div class="line">                );</div><div class="line">        }</div><div class="line">    }</div><div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Return the composition of two functions or more. </p>
<p><code>compose</code> is defined inductively. When given more than two functions, <code>compose(f, g, h...)</code> is equivalent to <code>compose(f, compose(g, h...))</code>. When given two functions, <code>compose(f, g)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(f, g)(x, y...) == f(g(x), y...)</div></div><!-- fragment --><p>If you need composition of the form <code>f(g(x, y...))</code>, use <code>demux</code> instead.</p>
<dl class="section note"><dt>Note</dt><dd><code>compose</code> is an associative operation; <code>compose(f, compose(g, h))</code> is equivalent to <code>compose(compose(f, g), h)</code>.</dd></dl>
<h3>Proof of associativity</h3>
<div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(f, <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(g, h))(x, xs...) == f(<a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(g, h)(x), xs...)</div><div class="line">                                    == f(g(h(x)), xs...)</div><div class="line"></div><div class="line"><a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(<a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(f, g), h)(x, xs...) == <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(f, g)(h(x), xs...)</div><div class="line">                                    == f(g(h(x)), xs...)</div></div><!-- fragment --> <h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="compose_8hpp.html">boost/hana/functional/compose.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> to_char = [](<span class="keywordtype">int</span> x) {</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(x + 48);</div><div class="line">    };</div><div class="line"></div><div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> increment = [](<span class="keyword">auto</span> x) {</div><div class="line">        <span class="keywordflow">return</span> x + 1;</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">hana::compose</a>(to_char, increment)(3) == <span class="charliteral">&#39;4&#39;</span>);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga49ea872ade5ac8f6c10052c495302e89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::curry</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="curry_8hpp.html">boost/hana/functional/curry.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; x1) {</div><div class="line">            <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; x2) {</div><div class="line">                ...</div><div class="line">                    <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; xn) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">                        <span class="keywordflow">return</span> forwarded(f)(</div><div class="line">                            forwarded(x1), forwarded(x2), ..., forwarded(xn)</div><div class="line">                        );</div><div class="line">                    };</div><div class="line">            };</div><div class="line">        };</div><div class="line">    }</div><div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Curry a function up to the given number of arguments. </p>
<p><a href="http://en.wikipedia.org/wiki/Currying">Currying</a> is a technique in which we consider a function taking multiple arguments (or, equivalently, a tuple of arguments), and turn it into a function which takes a single argument and returns a function to handle the remaining arguments. To help visualize, let's denote the type of a function <code>f</code> which takes arguments of types <code>X1, ..., Xn</code> and returns a <code>R</code> as </p><div class="fragment"><div class="line">(X1, ..., Xn) -&gt; R</div></div><!-- fragment --><p>Then, currying is the process of taking <code>f</code> and turning it into an equivalent function (call it <code>g</code>) of type </p><div class="fragment"><div class="line">X1 -&gt; (X2 -&gt; (... -&gt; (Xn -&gt; R)))</div></div><!-- fragment --><p>This gives us the following equivalence, where <code>x1</code>, ..., <code>xn</code> are objects of type <code>X1</code>, ..., <code>Xn</code> respectively: </p><div class="fragment"><div class="line">f(x1, ..., xn) == g(x1)...(xn)</div></div><!-- fragment --><p>Currying can be useful in several situations, especially when working with higher-order functions.</p>
<p>This <code>curry</code> utility is an implementation of currying in C++. Specifically, <code>curry&lt;n&gt;(f)</code> is a function such that </p><div class="fragment"><div class="line">curry&lt;n&gt;(f)(x1)...(xn) == f(x1, ..., xn)</div></div><!-- fragment --><p>Note that the <code>n</code> has to be specified explicitly because the existence of functions with variadic arguments in C++ make it impossible to know when currying should stop.</p>
<p>Unlike usual currying, this implementation also allows a curried function to be called with several arguments at a time. Hence, the following always holds </p><div class="fragment"><div class="line">curry&lt;n&gt;(f)(x1, ..., xk) == <a class="code" href="group__group-functional.html#ga49ea872ade5ac8f6c10052c495302e89">curry</a>&lt;n - k&gt;(f)(x1)...(xk)</div></div><!-- fragment --><p>Of course, this requires <code>k</code> to be less than or equal to <code>n</code>; failure to satisfy this will trigger a static assertion. This syntax is supported because it makes curried functions usable where normal functions are expected.</p>
<p>Another "extension" is that <code>curry&lt;0&gt;(f)</code> is supported: <code>curry&lt;0&gt;(f)</code> is a nullary function; whereas the classical definition for currying seems to leave this case undefined, as nullary functions don't make much sense in purely functional languages.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="curry_8hpp.html">boost/hana/functional/curry.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {</div><div class="line">        <span class="keywordflow">return</span> x + y + z;</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(hana::curry&lt;3&gt;(add)(1)(2)(3) == 1 + 2 + 3);</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(hana::curry&lt;3&gt;(add)(1)(2, 3) == hana::curry&lt;3&gt;(add)(1)(2)(3));</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(hana::curry&lt;3&gt;(add)(1, 2, 3) == hana::curry&lt;3&gt;(add)(1)(2)(3));</div><div class="line"></div><div class="line">    <span class="comment">// curry with a nullary function</span></div><div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> two = []() {</div><div class="line">        <span class="keywordflow">return</span> 2;</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(hana::curry&lt;0&gt;(two)() == two());</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga3a8316acd5efa22c3d1861b62d5df3c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::demux</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="demux_8hpp.html">boost/hana/functional/demux.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...g) {</div><div class="line">            <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">                </div><div class="line">                </div><div class="line">                <span class="keywordflow">return</span> forwarded(f)(forwarded(g)(x...)...);</div><div class="line">            };</div><div class="line">        };</div><div class="line">    }</div><div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Invoke a function with the results of invoking other functions on its arguments. </p>
<p>Specifically, <code>demux(f)(g...)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga3a8316acd5efa22c3d1861b62d5df3c2">demux</a>(f)(g...)(x...) == f(g(x...)...)</div></div><!-- fragment --><p>Each <code>g</code> is called with all the arguments, and then <code>f</code> is called with the result of each <code>g</code>. Hence, the arity of <code>f</code> must match the number of <code>g</code>s.</p>
<p>This is called <code>demux</code> because of a vague similarity between this device and a demultiplexer in signal processing. <code>demux</code> takes what can be seen as a continuation (<code>f</code>), a bunch of functions to split a signal (<code>g...</code>) and zero or more arguments representing the signal (<code>x...</code>). Then, it calls the continuation with the result of splitting the signal with whatever functions where given.</p>
<dl class="section note"><dt>Note</dt><dd>When used with two functions only, <code>demux</code> is associative. In other words (and noting <code>demux(f, g) = demux(f)(g)</code> to ease the notation), it is true that <code>demux(demux(f, g), h) == demux(f, demux(g, h))</code>.</dd></dl>
<h2>Signature </h2>
<p>The signature of <code>demux</code> is </p><p class="formulaDsp">
\[ \mathtt{demux} : (B_1 \times \dotsb \times B_n \to C) \to ((A_1 \times \dotsb \times A_n \to B_1) \times \dotsb \times (A_1 \times \dotsb \times A_n \to B_n)) \to (A_1 \times \dotsb \times A_n \to C) \]
</p>
<p>This can be rewritten more tersely as </p><p class="formulaDsp">
\[ \mathtt{demux} : \left(\prod_{i=1}^n B_i \to C \right) \to \prod_{j=1}^n \left(\prod_{i=1}^n A_i \to B_j \right) \to \left(\prod_{i=1}^n A_i \to C \right) \]
</p>
<h2>Link with normal composition </h2>
<p>The signature of <code>compose</code> is </p><p class="formulaDsp">
\[ \mathtt{compose} : (B \to C) \times (A \to B) \to (A \to C) \]
</p>
<p>A valid observation is that this coincides exactly with the type of <code>demux</code> when used with a single unary function. Actually, both functions are equivalent: </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga3a8316acd5efa22c3d1861b62d5df3c2">demux</a>(f)(g)(x) == <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(f, g)(x)</div></div><!-- fragment --><p>However, let's now consider the curried version of <code>compose</code>, <code>curry&lt;2&gt;(compose)</code>: </p><p class="formulaDsp">
\[ \mathtt{curry_2(compose)} : (B \to C) \to ((A \to B) \to (A \to C)) \]
</p>
<p>For the rest of this explanation, we'll just consider the curried version of <code>compose</code> and so we'll use <code>compose</code> instead of <code>curry&lt;2&gt;(compose)</code> to lighten the notation. With currying, we can now consider <code>compose</code> applied to itself: </p><p class="formulaDsp">
\[ \mathtt{compose(compose, compose)} : (B \to C) \to (A_1 \to A_2 \to B) \to (A_1 \to A_2 \to C) \]
</p>
<p>If we uncurry deeply the above expression, we obtain </p><p class="formulaDsp">
\[ \mathtt{compose(compose, compose)} : (B \to C) \times (A_1 \times A_2 \to B) \to (A_1 \times A_2 \to C) \]
</p>
<p>This signature is exactly the same as that of <code>demux</code> when given a single binary function, and indeed they are equivalent definitions. We can also generalize this further by considering <code>compose(compose(compose, compose), compose)</code>: </p><p class="formulaDsp">
\[ \mathtt{compose(compose(compose, compose), compose)} : (B \to C) \to (A_1 \to A_2 \to A_3 \to B) \to (A_1 \to A_2 \to A_3 \to C) \]
</p>
<p>which uncurries to </p><p class="formulaDsp">
\[ \mathtt{compose(compose(compose, compose), compose)} : (B \to C) \times (A_1 \times A_2 \times A_3 \to B) \to (A_1 \times A_2 \times A_3 \to C) \]
</p>
<p>This signature is exactly the same as that of <code>demux</code> when given a single ternary function. Hence, for a single n-ary function <code>g</code>, <code>demux(f)(g)</code> is equivalent to the n-times composition of <code>compose</code> with itself, applied to <code>g</code> and <code>f</code>: </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga3a8316acd5efa22c3d1861b62d5df3c2">demux</a>(f)(g) == <a class="code" href="group__group-Foldable.html#ga38c6b3f6b1cbadb9b8432a05ff16b7d2">fold_left</a>([<a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>, ..., <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>], <span class="keywordtype">id</span>, <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>)(g, f)</div><div class="line">                      <span class="comment">//  ^^^^^^^^^^^^^^^^^^^^^ n times</span></div></div><!-- fragment --><p>More information on this insight can be seen <a href="http://stackoverflow.com/q/5821089/627587">here</a>. Also, I'm not sure how this insight could be generalized to more than one function <code>g</code>, or if that is even possible.</p>
<h2>Proof of associativity in the binary case </h2>
<p>As explained above, <code>demux</code> is associative when it is used with two functions only. Indeed, given functions <code>f</code>, <code>g</code> and <code>h</code> with suitable signatures, we have </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga3a8316acd5efa22c3d1861b62d5df3c2">demux</a>(f)(<a class="code" href="group__group-functional.html#ga3a8316acd5efa22c3d1861b62d5df3c2">demux</a>(g)(h))(x...) == f(<a class="code" href="group__group-functional.html#ga3a8316acd5efa22c3d1861b62d5df3c2">demux</a>(g)(h)(x...))</div><div class="line">                            == f(g(h(x...)))</div></div><!-- fragment --><p>On the other hand, we have </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga3a8316acd5efa22c3d1861b62d5df3c2">demux</a>(<a class="code" href="group__group-functional.html#ga3a8316acd5efa22c3d1861b62d5df3c2">demux</a>(f)(g))(h)(x...) == <a class="code" href="group__group-functional.html#ga3a8316acd5efa22c3d1861b62d5df3c2">demux</a>(f)(g)(h(x...))</div><div class="line">                            == f(g(h(x...)))</div></div><!-- fragment --><p>and hence <code>demux</code> is associative in the binary case.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="demux_8hpp.html">boost/hana/functional/demux.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="placeholder_8hpp.html">boost/hana/functional/placeholder.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">hana::_</a>;</div><div class="line"></div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> f = <a class="code" href="group__group-functional.html#ga3a8316acd5efa22c3d1861b62d5df3c2">hana::demux</a>(hana::make_tuple)(</div><div class="line">    <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> + <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>,</div><div class="line">    _ - <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>,</div><div class="line">    _ * <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>,</div><div class="line">    _ / <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a></div><div class="line">);</div><div class="line"></div><div class="line">static_assert(</div><div class="line">    f(10, 4) == hana::make_tuple(</div><div class="line">        10 + 4,</div><div class="line">        10 - 4,</div><div class="line">        10 * 4,</div><div class="line">        10 / 4</div><div class="line">    )</div><div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga1393f40da2e8da6e0c12fce953e56a6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::fix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fix_8hpp.html">boost/hana/functional/fix.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">            <span class="keywordflow">return</span> forwarded(f)(<a class="code" href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">fix</a>(f), forwarded(x)...);</div><div class="line">        };</div><div class="line">    }</div><div class="ttc" id="group__group-functional_html_ga1393f40da2e8da6e0c12fce953e56a6c"><div class="ttname"><a href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">boost::hana::fix</a></div><div class="ttdeci">constexpr auto fix</div><div class="ttdoc">Return a function computing the fixed point of a function. </div><div class="ttdef"><b>Definition:</b> fix.hpp:53</div></div>
<div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Return a function computing the fixed point of a function. </p>
<p><code>fix</code> is an implementation of the <a href="http://en.wikipedia.org/wiki/Fixed-point_combinator">Y-combinator</a>, also called the fixed-point combinator. It encodes the idea of recursion, and in fact any recursive function can be written in terms of it.</p>
<p>Specifically, <code>fix(f)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">fix</a>(f)(x...) == f(<a class="code" href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">fix</a>(f), x...)</div></div><!-- fragment --><p>This definition allows <code>f</code> to use its first argument as a continuation to call itself recursively. Indeed, if <code>f</code> calls its first argument with <code>y...</code>, it is equivalent to calling <code>f(fix(f), y...)</code> per the above equation.</p>
<p>Most of the time, it is more convenient and efficient to define recursive functions without using a fixed-point combinator. However, there are some cases where <code>fix</code> provides either more flexibility (e.g. the ability to change the callback inside <code>f</code>) or makes it possible to write functions that couldn't be defined recursively otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function called as <code>f(self, x...)</code>, where <code>x...</code> are the arguments in the <code>fix(f)(x...)</code> expression and <code>self</code> is <code>fix(f)</code>.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fix_8hpp.html">boost/hana/functional/fix.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">BOOST_HANA_CONSTEXPR_STATELESS_LAMBDA <span class="keyword">auto</span> factorial = <a class="code" href="group__group-functional.html#ga1393f40da2e8da6e0c12fce953e56a6c">hana::fix</a>([](<span class="keyword">auto</span> fact, <span class="keyword">auto</span> n) -&gt; <span class="keywordtype">int</span> {</div><div class="line">    <span class="keywordflow">if</span> (n == 0) <span class="keywordflow">return</span> 1;</div><div class="line">    <span class="keywordflow">else</span>        <span class="keywordflow">return</span> n * fact(n - 1);</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(factorial(5) == 120);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga004f884cdbb85c2efe3383c1db450094"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::flip</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="flip_8hpp.html">boost/hana/functional/flip.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; y, <span class="keyword">auto</span>&amp;&amp; ...z) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">            <span class="keywordflow">return</span> forwarded(f)(forwarded(y), forwarded(x), forwarded(z)...);</div><div class="line">        };</div><div class="line">    }</div><div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Invoke a function with its two first arguments reversed. </p>
<p>Specifically, <code>flip(f)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(f)(x, y, z...) == f(y, x, z...)</div></div><!-- fragment --><h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="flip_8hpp.html">boost/hana/functional/flip.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> <a class="code" href="group__group-Group.html#ga2020c526324f361a2b990fe8d1b07c20">minus</a> = [](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z = 0) {</div><div class="line">    <span class="keywordflow">return</span> x - y - z;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-Group.html#ga2020c526324f361a2b990fe8d1b07c20">minus</a>(3, 0) == 3 - 0);</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">hana::flip</a>(minus)(3, 0) == 0 - 3);</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-Group.html#ga2020c526324f361a2b990fe8d1b07c20">minus</a>(3, 0, 1) == 3 - 0 - 1);</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">hana::flip</a>(minus)(3, 0, 1) == 0 - 3 - 1);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaef38cf34324c8edbd3597ae71811d00d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="id_8hpp.html">boost/hana/functional/id.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> forwarded(x);</div><div class="line">    }</div></div><!-- fragment -->
<p>The identity function &ndash; returns its argument unchanged. </p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="id_8hpp.html">boost/hana/functional/id.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">hana::id</a>(1) == 1, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(<a class="code" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d">hana::id</a>(<span class="charliteral">&#39;x&#39;</span>) == <span class="charliteral">&#39;x&#39;</span>, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7bdafba6dc801f1d2d83731ad9714557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::infix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="infix_8hpp.html">boost/hana/functional/infix.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> f) {</div><div class="line">        <span class="keywordflow">return</span> unspecified;</div><div class="line">    }</div></div><!-- fragment -->
<p>Return an equivalent function that can also be applied in infix notation. </p>
<p>Specifically, <code>infix(f)</code> is an object such that: </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f)(x1, ..., xn) == f(x1, ..., xn)</div><div class="line">x ^<a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f)^ y == f(x, y)</div></div><!-- fragment --><p>Hence, the returned function can still be applied using the usual function call syntax, but it also gains the ability to be applied in infix notation. The infix syntax allows a great deal of expressiveness, especially when used in combination with some higher order algorithms. Since <code>operator^</code> is left-associative, <code>x ^infix(f)^ y</code> is actually parsed as <code>(x ^infix(f))^ y</code>. However, for flexibility, the order in which both arguments are applied in infix notation does not matter. Hence, it is always the case that </p><div class="fragment"><div class="line">(x ^ <a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f)) ^ y == x ^ (<a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f) ^ y)</div></div><!-- fragment --><p>However, note that applying more than one argument in infix notation to the same side of the operator will result in a compile-time assertion: </p><div class="fragment"><div class="line">(<a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f) ^ x) ^ y; <span class="comment">// compile-time assertion</span></div><div class="line">y ^ (x ^ <a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f)); <span class="comment">// compile-time assertion</span></div></div><!-- fragment --><p>Additionally, a function created with <code>infix</code> may be partially applied in infix notation. Specifically, </p><div class="fragment"><div class="line">(x ^ <a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f))(y1, ..., yn) == f(x, y1, ..., yn)</div><div class="line">(<a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>(f) ^ y)(x1, ..., xn) == f(x1, ..., xn, y)</div></div><!-- fragment --><h3>Rationales</h3>
<ol type="1">
<li>The <code>^</code> operator was chosen because it is left-associative and has a low enough priority so that most expressions will render the expected behavior.</li>
<li>The operator can't be customimzed because that would require more sophistication in the implementation; I want to keep it as simple as possible. There is also an advantage in having a uniform syntax for infix application. </li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function which gains the ability to be applied in infix notation. The function must be at least binary; a compile-time error will be triggered otherwise.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="infix_8hpp.html">boost/hana/functional/infix.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> divmod = <a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">hana::infix</a>([](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div><div class="line">    <span class="comment">// this could be a more efficient implementation</span></div><div class="line">    <span class="keywordflow">return</span> hana::make_pair(x / y, x % y);</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>((42 ^divmod^ 23) == hana::make_pair(1, 19));</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad1b8669c022d8675d68e5974451073d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::iterate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="iterate_8hpp.html">boost/hana/functional/iterate.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; x) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">            <span class="keywordflow">return</span> f(f( ... f(forwarded(x))));</div><div class="line">        };</div><div class="line">    }</div><div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Applies another function <code>n</code> times to its argument. </p>
<p>Given a function <code>f</code> and an argument <code>x</code>, <code>iterate&lt;n&gt;(f, x)</code> returns the result of applying <code>f</code> <code>n</code> times to its argument. In other words, </p><div class="fragment"><div class="line">iterate&lt;n&gt;(f, x) == f(f( ... f(x)))</div><div class="line">                    ^^^^^^^^^^ n times total</div></div><!-- fragment --><p>If <code>n == 0</code>, <code>iterate&lt;n&gt;(f, x)</code> returns the <code>x</code> argument unchanged and <code>f</code> is never applied. It is important to note that the function passed to <code>iterate&lt;n&gt;</code> must be a unary function. Indeed, since <code>f</code> will be called with the result of the previous <code>f</code> application, it may only take a single argument.</p>
<p>In addition to what's documented above, <code>iterate</code> can also be partially applied to the function argument out-of-the-box. In other words, <code>iterate&lt;n&gt;(f)</code> is a function object applying <code>f</code> <code>n</code> times to the argument it is called with, which means that </p><div class="fragment"><div class="line">iterate&lt;n&gt;(f)(x) == iterate&lt;n&gt;(f, x)</div></div><!-- fragment --><p>This is provided for convenience, and it turns out to be especially useful in conjunction with higher-order algorithms.</p>
<h2>Signature </h2>
<p>Given a function \( f : T \to T \) and <code>x</code> and argument of data type <code>T</code>, the signature is \( \mathtt{iterate_n} : (T \to T) \times T \to T \)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>An unsigned integer representing the number of times that <code>f</code> should be applied to its argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function to apply <code>n</code> times to its argument.</td></tr>
    <tr><td class="paramname">x</td><td>The initial value to call <code>f</code> with.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="iterate_8hpp.html">boost/hana/functional/iterate.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="placeholder_8hpp.html">boost/hana/functional/placeholder.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> next_10 = hana::iterate&lt;10&gt;(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">hana::_</a> + 1);</div><div class="line">static_assert(next_10(3) == 13, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> xs = hana::make_tuple(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</div><div class="line">static_assert(hana::iterate&lt;3&gt;(hana::make_tuple, xs) ==</div><div class="line">              hana::make_tuple(hana::make_tuple(hana::make_tuple(xs))), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gafca60c09e1f7a32a2b52baaf6515c279"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::lockstep</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lockstep_8hpp.html">boost/hana/functional/lockstep.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; ...g) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">            <span class="keywordflow">return</span> forwarded(f)(forwarded(g)(forwarded(x))...);</div><div class="line">        };</div><div class="line">    }</div><div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Invoke a function with the result of invoking other functions on its arguments, in lockstep. </p>
<p>Specifically, <code>lockstep(f)(g1, ..., gN)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#gafca60c09e1f7a32a2b52baaf6515c279">lockstep</a>(f)(g1, ..., gN)(x1, ..., xN) == f(g1(x1), ..., gN(xN))</div></div><!-- fragment --><p>Since each <code>g</code> is invoked on its corresponding argument in lockstep, the number of arguments must match the number of <code>g</code>s.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lockstep_8hpp.html">boost/hana/functional/lockstep.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plus_8hpp.html">boost/hana/plus.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">constexpr <span class="keywordtype">int</span> to_int(<span class="keywordtype">char</span> c) {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(c) - 48;</div><div class="line">}</div><div class="line"></div><div class="line">constexpr <span class="keywordtype">int</span> increment(<span class="keywordtype">int</span> i) {</div><div class="line">    <span class="keywordflow">return</span> i + 1;</div><div class="line">}</div><div class="line"></div><div class="line">static_assert(<a class="code" href="group__group-functional.html#gafca60c09e1f7a32a2b52baaf6515c279">hana::lockstep</a>(<a class="code" href="group__group-Monoid.html#gaeb5d4a1e967e319712f9e4791948896c">hana::plus</a>)(to_int, increment)(<span class="charliteral">&#39;3&#39;</span>, 4) == 3 + 5, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga35c4fc3c5677b9f558150b90e74d3ab1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::on</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="on_8hpp.html">boost/hana/functional/on.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">infix</a>([](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; g) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">            <span class="keywordflow">return</span> forwarded(f)(g(forwarded(x))...);</div><div class="line">        };</div><div class="line">    })</div><div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
<div class="ttc" id="group__group-functional_html_ga7bdafba6dc801f1d2d83731ad9714557"><div class="ttname"><a href="group__group-functional.html#ga7bdafba6dc801f1d2d83731ad9714557">boost::hana::infix</a></div><div class="ttdeci">constexpr auto infix</div><div class="ttdoc">Return an equivalent function that can also be applied in infix notation. </div><div class="ttdef"><b>Definition:</b> infix.hpp:79</div></div>
</div><!-- fragment -->
<p>Invoke a function with the result of invoking another function on each argument. </p>
<p>Specifically, <code>on(f, g)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(f, g)(x...) == f(g(x)...)</div></div><!-- fragment --><p>For convenience, <code>on</code> also supports infix application as provided by <code>infix</code>.</p>
<dl class="section note"><dt>Note</dt><dd><code>on</code> is associative, i.e. <code>on(f, on(g, h))</code> is equivalent to <code>on(on(f, g), h)</code>.</dd></dl>
<h3>Proof of associativity</h3>
<div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(f, <a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(g, h))(xs...) == f(<a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(g, h)(xs)...)</div><div class="line">                       == f(g(h(xs))...)</div><div class="line"></div><div class="line"><a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(<a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(f, g), h)(xs...) == <a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">on</a>(f, g)(h(xs)...)</div><div class="line">                       == f(g(h(xs))...)</div></div><!-- fragment --> <h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="first_8hpp.html">boost/hana/first.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="on_8hpp.html">boost/hana/functional/on.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="less_8hpp.html">boost/hana/less.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="pair_8hpp.html">boost/hana/pair.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plus_8hpp.html">boost/hana/plus.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sort_8hpp.html">boost/hana/sort.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// infix application</span></div><div class="line">constexpr <span class="keyword">auto</span> sorted = <a class="code" href="group__group-Sequence.html#gac000a79eb7b9d44ecc8982c93daa40e5">hana::sort</a>.by(<a class="code" href="group__group-Orderable.html#gad510011602bdb14686f1c4ec145301c9">hana::less</a> ^<a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">hana::on</a>^ <a class="code" href="group__group-Product.html#ga34bbf4281de06dc3540441e8b2bd24f4">hana::first</a>, hana::make_tuple(</div><div class="line">    hana::make_pair(hana::int_c&lt;3&gt;, <span class="charliteral">&#39;x&#39;</span>),</div><div class="line">    hana::make_pair(hana::int_c&lt;1&gt;, hana::type_c&lt;void&gt;),</div><div class="line">    hana::make_pair(hana::int_c&lt;2&gt;, 9876)</div><div class="line">));</div><div class="line"></div><div class="line">static_assert(sorted == hana::make_tuple(</div><div class="line">    hana::make_pair(hana::int_c&lt;1&gt;, hana::type_c&lt;void&gt;),</div><div class="line">    hana::make_pair(hana::int_c&lt;2&gt;, 9876),</div><div class="line">    hana::make_pair(hana::int_c&lt;3&gt;, <span class="charliteral">&#39;x&#39;</span>)</div><div class="line">), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// function call syntax</span></div><div class="line">constexpr <span class="keyword">auto</span> x = hana::make_pair(1, 2);</div><div class="line">constexpr <span class="keyword">auto</span> y = hana::make_pair(10, 20);</div><div class="line">static_assert(<a class="code" href="group__group-functional.html#ga35c4fc3c5677b9f558150b90e74d3ab1">hana::on</a>(<a class="code" href="group__group-Monoid.html#gaeb5d4a1e967e319712f9e4791948896c">hana::plus</a>, hana::first)(x, y) == 1 + 10, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga83e71bae315e299f9f5f9de77b012139"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::overload</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="overload_8hpp.html">boost/hana/functional/overload.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f1, <span class="keyword">auto</span>&amp;&amp; f2, ..., <span class="keyword">auto</span>&amp;&amp; fn) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">            <span class="keywordflow">return</span> forwarded(fk)(forwarded(x)...);</div><div class="line">        };</div><div class="line">    }</div><div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Pick one of several functions to call based on overload resolution. </p>
<p>Specifically, <code>overload(f1, f2, ..., fn)</code> is a function object such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga83e71bae315e299f9f5f9de77b012139">overload</a>(f1, f2, ..., fn)(x...) == fk(x...)</div></div><!-- fragment --><p>where <code>fk</code> is the function of <code>f1, ..., fn</code> that would be called if overload resolution was performed amongst that set of functions only. If more than one function <code>fk</code> would be picked by overload resolution, then the call is ambiguous.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="overload_8hpp.html">boost/hana/functional/overload.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">auto</span> on_string = [](std::string <span class="keyword">const</span>&amp; s) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;matched std::string: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> s;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> on_int = [](<span class="keywordtype">int</span> i) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;matched int: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> i;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> f = <a class="code" href="group__group-functional.html#ga83e71bae315e299f9f5f9de77b012139">hana::overload</a>(on_int, on_string);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// prints &quot;matched int: 1&quot;</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(f(1) == 1);</div><div class="line"></div><div class="line">    <span class="comment">// prints &quot;matched std::string: abcdef&quot;</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(f(<span class="stringliteral">&quot;abcdef&quot;</span>) == std::string{<span class="stringliteral">&quot;abcdef&quot;</span>});</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa46de6f618d9f14edb1589b36b6e75ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::overload_linearly</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="overload__linearly_8hpp.html">boost/hana/functional/overload_linearly.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f1, <span class="keyword">auto</span>&amp;&amp; f2, ..., <span class="keyword">auto</span>&amp;&amp; fn) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...x) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">            <span class="keywordflow">return</span> forwarded(fk)(forwarded(x)...);</div><div class="line">        };</div><div class="line">    }</div><div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Call the first function that produces a valid call expression. </p>
<p>Given functions <code>f1, ..., fn</code>, <code>overload_linearly(f1, ..., fn)</code> is a new function that calls the first <code>fk</code> producing a valid call expression with the given arguments. Specifically, </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#gaa46de6f618d9f14edb1589b36b6e75ec">overload_linearly</a>(f1, ..., fn)(args...) == fk(args...)</div></div><!-- fragment --><p>where <code>fk</code> is the <em>first</em> function such that <code>fk(args...)</code> is a valid expression.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="overload__linearly_8hpp.html">boost/hana/functional/overload_linearly.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">auto</span> f = <a class="code" href="group__group-functional.html#gaa46de6f618d9f14edb1589b36b6e75ec">hana::overload_linearly</a>(</div><div class="line">    [](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i + 1; },</div><div class="line">    [](std::string s) { <span class="keywordflow">return</span> s + <span class="stringliteral">&quot;d&quot;</span>; },</div><div class="line">    [](double) { <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;never called&quot;</span>); }</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(f(1) == 2);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(f(<span class="stringliteral">&quot;abc&quot;</span>) == <span class="stringliteral">&quot;abcd&quot;</span>);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(f(2.2) == static_cast&lt;int&gt;(2.2) + 1);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga778b2daa27882e71d28b6f2b38982ddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::partial</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partial_8hpp.html">boost/hana/functional/partial.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; ...x) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...y) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">            <span class="keywordflow">return</span> forwarded(f)(forwarded(x)..., forwarded(y)...);</div><div class="line">        };</div><div class="line">    }</div><div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Partially apply a function to some arguments. </p>
<p>Given a function <code>f</code> and some arguments, <code>partial</code> returns a new function corresponding to the partially applied function <code>f</code>. This allows providing some arguments to a function and letting the rest of the arguments be provided later. Specifically, <code>partial(f, x...)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga778b2daa27882e71d28b6f2b38982ddf">partial</a>(f, x...)(y...) == f(x..., y...)</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The arity of <code>f</code> must match the total number of arguments passed to it, i.e. <code>sizeof...(x) + sizeof...(y)</code>.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="partial_8hpp.html">boost/hana/functional/partial.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="plus_8hpp.html">boost/hana/plus.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> increment = <a class="code" href="group__group-functional.html#ga778b2daa27882e71d28b6f2b38982ddf">hana::partial</a>(<a class="code" href="group__group-Monoid.html#gaeb5d4a1e967e319712f9e4791948896c">hana::plus</a>, 1);</div><div class="line">static_assert(increment(2) == 3, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaefe9fd152cba94be71c2b5b9de689d23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unspecified boost::hana::_ {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="placeholder_8hpp.html">boost/hana/functional/placeholder.hpp</a>&gt;</code></p>

<p>Create simple functions representing C++ operators inline. </p>
<p>Specifically, <code>_</code> is an object used as a placeholder to build function objects representing calls to C++ operators. It works by overloading the operators between <code>_</code> and any object so that they return a function object which actually calls the corresponding operator on its argument(s). Hence, for any supported operator <code>@</code>: </p><div class="fragment"><div class="line">(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> @ <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>)(x, y) == x @ y</div></div><!-- fragment --><p>Operators may also be partially applied to one argument inline: </p><div class="fragment"><div class="line">(x @ <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>)(y) == x @ y</div><div class="line">(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> @ y)(x) == x @ y</div></div><!-- fragment --><p>When invoked with more arguments than required, functions created with <code>_</code> will discard the superfluous instead of triggering an error: </p><div class="fragment"><div class="line">(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> @ <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>)(x, y, z...) == x @ y</div></div><!-- fragment --><p>This makes functions created with <code>_</code> easier to use in higher-order algorithms, which sometime provide more information than necessary to their callbacks.</p>
<h3>Supported operators</h3>
<ul>
<li>Arithmetic: binary <code>+</code>, binary <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>, unary <code>+</code>, unary <code>-</code></li>
<li>Bitwise: <code>~</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
<li>Comparison: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
<li>Logical: <code>||</code>, <code>&amp;&amp;</code>, <code>!</code></li>
<li>Member access: <code>*</code> (dereference), <code>[]</code> (array subscript)</li>
<li>Other: <code>()</code> (function call)</li>
</ul>
<p>More complex functionality like the ability to compose placeholders into larger function objects inline are not supported. This is on purpose; you should either use C++14 generic lambdas or a library like <a href="http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/index.html">Boost.Phoenix</a> if you need bigger guns. The goal here is to save you a couple of characters in simple situations.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="placeholder_8hpp.html">boost/hana/functional/placeholder.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> <a class="code" href="group__group-Monoid.html#gaeb5d4a1e967e319712f9e4791948896c">plus</a> = <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">hana::_</a> + <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">hana::_</a>;</div><div class="line">static_assert(<a class="code" href="group__group-Monoid.html#gaeb5d4a1e967e319712f9e4791948896c">plus</a>(1, 2) == 1 + 2, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> increment = hana::_ + 1;</div><div class="line">static_assert(increment(1) == 2, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> twice = 2 * <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">hana::_</a>;</div><div class="line">static_assert(twice(1) == 2, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Extra arguments are ignored.</span></div><div class="line">static_assert(twice(1, <span class="stringliteral">&quot;ignored&quot;</span>) == 2, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga6e648f0d3fc0209ec024e9d759a5e8f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::reverse_partial</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reverse__partial_8hpp.html">boost/hana/functional/reverse_partial.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f, <span class="keyword">auto</span>&amp;&amp; ...x) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; ...y) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">            <span class="keywordflow">return</span> forwarded(f)(forwarded(y)..., forwarded(x)...);</div><div class="line">        };</div><div class="line">    }</div><div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Partially apply a function to some arguments. </p>
<p>Given a function <code>f</code> and some arguments, <code>reverse_partial</code> returns a new function corresponding to <code>f</code> whose last arguments are partially applied. Specifically, <code>reverse_partial(f, x...)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga6e648f0d3fc0209ec024e9d759a5e8f8">reverse_partial</a>(f, x...)(y...) == f(y..., x...)</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The arity of <code>f</code> must match the total number of arguments passed to it, i.e. <code>sizeof...(x) + sizeof...(y)</code>.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="div_8hpp.html">boost/hana/div.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="reverse__partial_8hpp.html">boost/hana/functional/reverse_partial.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">constexpr <span class="keyword">auto</span> half = <a class="code" href="group__group-functional.html#ga6e648f0d3fc0209ec024e9d759a5e8f8">hana::reverse_partial</a>(<a class="code" href="group__group-EuclideanRing.html#ga4225a7988ce98903228913dde53762df">hana::div</a>, 2);</div><div class="line">static_assert(half(4) == 2, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">static_assert(half(8) == 4, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
