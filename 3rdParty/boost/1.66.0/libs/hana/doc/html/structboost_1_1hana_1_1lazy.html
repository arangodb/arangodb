<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Boost.Hana: boost::hana::lazy&lt; implementation_defined &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structboost_1_1hana_1_1lazy.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#related">Synopsis of associated functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structboost_1_1hana_1_1lazy-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::hana::lazy&lt; implementation_defined &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__group-datatypes.html">Data types</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;typename implementation_defined&gt;<br />
struct boost::hana::lazy&lt; implementation_defined &gt;</h3>

<p><code><a class="el" href="structboost_1_1hana_1_1lazy.html" title="hana::lazy implements superficial laziness via a monadic interface. ">hana::lazy</a></code> implements superficial laziness via a monadic interface. </p>
<p>It is important to understand that the laziness implemented by <code>lazy</code> is only superficial; only function applications made inside the <code>lazy</code> monad can be made lazy, not all their subexpressions.</p>
<dl class="section note"><dt>Note</dt><dd>The actual representation of <code><a class="el" href="structboost_1_1hana_1_1lazy.html" title="hana::lazy implements superficial laziness via a monadic interface. ">hana::lazy</a></code> is completely implementation-defined. Lazy values may only be created through <code>hana::make_lazy</code>, and they can be stored in variables using <code>auto</code>, but any other assumption about the representation of <code><a class="el" href="structboost_1_1hana_1_1lazy.html" title="hana::lazy implements superficial laziness via a monadic interface. ">hana::lazy</a>&lt;...&gt;</code> should be avoided. In particular, one should not rely on the fact that <code><a class="el" href="structboost_1_1hana_1_1lazy.html" title="hana::lazy implements superficial laziness via a monadic interface. ">hana::lazy</a>&lt;...&gt;</code> can be pattern-matched on, because it may be a dependent type.</dd></dl>
<h2>Modeled concepts </h2>
<ol type="1">
<li><code>Functor</code><br />
Applying a function over a lazy value with <code>transform</code> returns the result of applying the function, as a lazy value. <div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="eval_8hpp.html">boost/hana/eval.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="placeholder_8hpp.html">boost/hana/functional/placeholder.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lazy_8hpp.html">boost/hana/lazy.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transform_8hpp.html">boost/hana/transform.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">hana::_</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    static_assert(hana::eval(<a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">hana::transform</a>(hana::make_lazy(4 / <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>)(1), <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> * 3)) == (4 / 1) * 3, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">hana::transform</a>(hana::make_lazy(4 / <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>)(0), <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a> * 3); <span class="comment">// never evaluated</span></div><div class="line">}</div></div><!-- fragment --></li>
<li><code>Applicative</code><br />
A normal value can be lifted into a lazy value by using <code>lift&lt;<a class="el" href="structboost_1_1hana_1_1lazy__tag.html" title="Tag representing hana::lazy. ">lazy_tag</a>&gt;</code>. A lazy function can be lazily applied to a lazy value by using <code>ap</code>.</li>
<li><code>Monad</code><br />
The <code>lazy</code> monad allows combining lazy computations into larger lazy computations. Note that the <code>|</code> operator can be used in place of the <code>chain</code> function. <div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="chain_8hpp.html">boost/hana/chain.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="eval_8hpp.html">boost/hana/eval.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lazy_8hpp.html">boost/hana/lazy.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">T read_(std::istream&amp; stream) {</div><div class="line">    T x;</div><div class="line">    stream &gt;&gt; x;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;read &quot;</span> &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot; from the stream\n&quot;</span>;</div><div class="line">    <span class="keywordflow">return</span> x;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    std::stringstream ss;</div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="group__group-Searchable.html#ga0d9456ceda38b6ca664998e79d7c45b7">in</a> = 123;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;creating the monadic chain...\n&quot;</span>;</div><div class="line">    <span class="keyword">auto</span> out = hana::make_lazy(read_&lt;int&gt;)(std::ref(ss))</div><div class="line">        | [](<span class="keyword">auto</span> x) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;performing x + 1...\n&quot;</span>;</div><div class="line">            <span class="keywordflow">return</span> hana::make_lazy(x + 1);</div><div class="line">        }</div><div class="line">        | [](<span class="keyword">auto</span> x) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;performing x / 2...\n&quot;</span>;</div><div class="line">            <span class="keywordflow">return</span> hana::make_lazy(x / 2);</div><div class="line">        };</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;putting &quot;</span> &lt;&lt; in &lt;&lt; <span class="stringliteral">&quot; in the stream...\n&quot;</span>;</div><div class="line">    ss &lt;&lt; <a class="code" href="group__group-Searchable.html#ga0d9456ceda38b6ca664998e79d7c45b7">in</a>; <span class="comment">// nothing is evaluated yet</span></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;evaluating the monadic chain...\n&quot;</span>;</div><div class="line">    <span class="keyword">auto</span> eout = hana::eval(out);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;the result of the monadic chain is &quot;</span> &lt;&lt; eout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(eout == (in + 1) / 2);</div><div class="line">}</div></div><!-- fragment --></li>
<li><code>Comonad</code><br />
The <code>lazy</code> comonad allows evaluating a lazy computation to get its result and lazily applying functions taking lazy inputs to lazy values. This <a href="http://ldionne.com/2015/03/16/laziness-as-a-comonad">blog post</a> goes into more details about lazy evaluation and comonads. <div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="eval_8hpp.html">boost/hana/eval.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="extend_8hpp.html">boost/hana/extend.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="extract_8hpp.html">boost/hana/extract.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lazy_8hpp.html">boost/hana/lazy.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    std::stringstream s(<span class="stringliteral">&quot;1 2 3&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> i = hana::make_lazy([&amp;] {</div><div class="line">        <span class="keywordtype">int</span> i;</div><div class="line">        s &gt;&gt; i;</div><div class="line">        <span class="keywordflow">return</span> i;</div><div class="line">    })();</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> i_plus_one = <a class="code" href="group__group-Comonad.html#gaf44692351fd9fe4e76815dfef6ff4478">hana::extend</a>(i, [](<span class="keyword">auto</span> lazy_int) {</div><div class="line">        <span class="keywordflow">return</span> hana::eval(lazy_int) + 1;</div><div class="line">    });</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(<a class="code" href="group__group-Comonad.html#ga307479a91a21b7ab06a2bc746b003dcc">hana::extract</a>(i_plus_one) == 2);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(<a class="code" href="group__group-Comonad.html#ga307479a91a21b7ab06a2bc746b003dcc">hana::extract</a>(i_plus_one) == 3);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(<a class="code" href="group__group-Comonad.html#ga307479a91a21b7ab06a2bc746b003dcc">hana::extract</a>(i_plus_one) == 4);</div><div class="line">}</div></div><!-- fragment --></li>
</ol>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="structboost_1_1hana_1_1lazy.html" title="hana::lazy implements superficial laziness via a monadic interface. ">hana::lazy</a></code> only models a few concepts because providing more functionality would require evaluating the lazy values in most cases. Since this raises some issues such as side effects and memoization, the interface is kept minimal. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Synopsis of associated functions</h2></td></tr>
<tr class="memitem:aae2998c08f1f80ed52a6acf57c4eec6c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1lazy.html#aae2998c08f1f80ed52a6acf57c4eec6c">eval</a></td></tr>
<tr class="memdesc:aae2998c08f1f80ed52a6acf57c4eec6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a lazy value and return it.  <a href="#aae2998c08f1f80ed52a6acf57c4eec6c">More...</a><br /></td></tr>
<tr class="separator:aae2998c08f1f80ed52a6acf57c4eec6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa968ecf473c93821f1726fd9692e97f3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa968ecf473c93821f1726fd9692e97f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1lazy.html#aa968ecf473c93821f1726fd9692e97f3">make&lt; lazy_tag &gt;</a></td></tr>
<tr class="memdesc:aa968ecf473c93821f1726fd9692e97f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lifts a normal value to a lazy one.  <a href="#aa968ecf473c93821f1726fd9692e97f3">More...</a><br /></td></tr>
<tr class="separator:aa968ecf473c93821f1726fd9692e97f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc86ca61b84fc42aabb525787ae61b4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1lazy.html#a7dc86ca61b84fc42aabb525787ae61b4">make_lazy</a> = <a class="el" href="group__group-core.html#ga1d92480f0af1029878e773dafa3e2f60">make</a>&lt;<a class="el" href="structboost_1_1hana_1_1lazy__tag.html">lazy_tag</a>&gt;</td></tr>
<tr class="memdesc:a7dc86ca61b84fc42aabb525787ae61b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <code>make&lt;<a class="el" href="structboost_1_1hana_1_1lazy__tag.html" title="Tag representing hana::lazy. ">lazy_tag</a>&gt;</code>; provided for convenience.  <a href="#a7dc86ca61b84fc42aabb525787ae61b4">More...</a><br /></td></tr>
<tr class="separator:a7dc86ca61b84fc42aabb525787ae61b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a97b267b09ee075f1c531b849969e75e6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a97b267b09ee075f1c531b849969e75e6"></a>
template&lt;typename... T, typename F &gt; </td></tr>
<tr class="memitem:a97b267b09ee075f1c531b849969e75e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structboost_1_1hana_1_1lazy.html#a97b267b09ee075f1c531b849969e75e6">operator|</a> (<a class="el" href="structboost_1_1hana_1_1lazy.html">lazy</a>&lt; T... &gt;, F)</td></tr>
<tr class="memdesc:a97b267b09ee075f1c531b849969e75e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="group__group-Monad.html#ga05fdc2f887cb9967357487a432ace98b" title="Feed a monadic value into a monadic computation.Given a monadic value and a monadic function...">hana::chain</a></code>. <br /></td></tr>
<tr class="separator:a97b267b09ee075f1c531b849969e75e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Associated functions</h2>
<a class="anchor" id="aae2998c08f1f80ed52a6acf57c4eec6c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename implementation_defined &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto eval</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; see_documentation) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Evaluate a lazy value and return it. </p>
<p>Given a lazy expression <code>expr</code>, <code>eval</code> evaluates <code>expr</code> and returns the result as a normal value. However, for convenience, <code>eval</code> can also be used with nullary and unary function objects. Specifically, if <code>expr</code> is not a <code><a class="el" href="structboost_1_1hana_1_1lazy.html" title="hana::lazy implements superficial laziness via a monadic interface. ">hana::lazy</a></code>, it is called with no arguments at all and the result of that call (<code>expr()</code>) is returned. Otherwise, if <code>expr()</code> is ill-formed, then <code>expr(hana::id)</code> is returned instead. If that expression is ill-formed, then a compile-time error is triggered.</p>
<p>The reason for allowing nullary callables in <code>eval</code> is because this allows using nullary lambdas as lazy branches to <code>eval_if</code>, which is convenient. The reason for allowing unary callables and calling them with <code><a class="el" href="group__group-functional.html#gaef38cf34324c8edbd3597ae71811d00d" title="The identity function – returns its argument unchanged. ">hana::id</a></code> is because this allows deferring the compile-time evaluation of selected expressions inside the callable. How this can be achieved is documented by <code><a class="el" href="group__group-Logical.html#gab64636f84de983575aac0208f5fa840c" title="Conditionally execute one of two branches based on a condition.Given a condition and two branches in ...">hana::eval_if</a></code>.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="eval_8hpp.html">boost/hana/eval.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="placeholder_8hpp.html">boost/hana/functional/placeholder.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lazy_8hpp.html">boost/hana/lazy.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">static_assert(hana::eval(hana::make_lazy(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">hana::_</a> + 1)(3)) == 4, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa968ecf473c93821f1726fd9692e97f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename implementation_defined &gt; </div>
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="group__group-core.html#ga1d92480f0af1029878e773dafa3e2f60">make</a>&lt; <a class="el" href="structboost_1_1hana_1_1lazy__tag.html">lazy_tag</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; x) {</div><div class="line">        <span class="keywordflow">return</span> lazy&lt;implementation_defined&gt;{forwarded(x)};</div><div class="line">    }</div></div><!-- fragment -->
<p>Lifts a normal value to a lazy one. </p>
<p><code>make&lt;<a class="el" href="structboost_1_1hana_1_1lazy__tag.html" title="Tag representing hana::lazy. ">lazy_tag</a>&gt;</code> can be used to lift a normal value or a function call into a lazy expression. Precisely, <code>make&lt;<a class="el" href="structboost_1_1hana_1_1lazy__tag.html" title="Tag representing hana::lazy. ">lazy_tag</a>&gt;(x)</code> is a lazy value equal to <code>x</code>, and <code>make&lt;<a class="el" href="structboost_1_1hana_1_1lazy__tag.html" title="Tag representing hana::lazy. ">lazy_tag</a>&gt;(f)(x1, ..., xN)</code> is a lazy function call that is equal to <code>f(x1, ..., xN)</code> when it is <code>eval</code>uated.</p>
<dl class="section note"><dt>Note</dt><dd>It is interesting to note that <code>make&lt;<a class="el" href="structboost_1_1hana_1_1lazy__tag.html" title="Tag representing hana::lazy. ">lazy_tag</a>&gt;(f)(x1, ..., xN)</code> is equivalent to <div class="fragment"><div class="line"><a class="code" href="group__group-Applicative.html#ga6176a32953dbbdee96e3ab3c73e4c890">ap</a>(<a class="code" href="structboost_1_1hana_1_1lazy.html#aa968ecf473c93821f1726fd9692e97f3">make&lt;lazy_tag&gt;</a>(f), lift&lt;lazy_tag&gt;(x1), ..., lift&lt;lazy_tag&gt;(xN))</div></div><!-- fragment --> which in turn is equivalent to <code>make&lt;<a class="el" href="structboost_1_1hana_1_1lazy__tag.html" title="Tag representing hana::lazy. ">lazy_tag</a>&gt;(f(x1, ..., xN))</code>, except for the fact that the inner call to <code>f</code> is evaluated lazily.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bool_8hpp.html">boost/hana/bool.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="eval_8hpp.html">boost/hana/eval.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="if_8hpp.html">boost/hana/if.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lazy_8hpp.html">boost/hana/lazy.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> f = hana::make&lt;hana::lazy_tag&gt;([](<span class="keyword">auto</span> x) {</div><div class="line">        <span class="keywordflow">return</span> 1 / x;</div><div class="line">    });</div><div class="line"></div><div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> g = hana::make_lazy([](<span class="keyword">auto</span> x) {</div><div class="line">        <span class="keywordflow">return</span> x + 1;</div><div class="line">    });</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(hana::eval(<a class="code" href="group__group-Logical.html#gafd655d2222367131e7a63616e93dd080">hana::if_</a>(hana::false_c, f(0), g(0))) == 0 + 1);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a7dc86ca61b84fc42aabb525787ae61b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename implementation_defined &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto make_lazy = <a class="el" href="group__group-core.html#ga1d92480f0af1029878e773dafa3e2f60">make</a>&lt;<a class="el" href="structboost_1_1hana_1_1lazy__tag.html">lazy_tag</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias to <code>make&lt;<a class="el" href="structboost_1_1hana_1_1lazy__tag.html" title="Tag representing hana::lazy. ">lazy_tag</a>&gt;</code>; provided for convenience. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bool_8hpp.html">boost/hana/bool.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="eval_8hpp.html">boost/hana/eval.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="if_8hpp.html">boost/hana/if.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lazy_8hpp.html">boost/hana/lazy.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> f = hana::make&lt;hana::lazy_tag&gt;([](<span class="keyword">auto</span> x) {</div><div class="line">        <span class="keywordflow">return</span> 1 / x;</div><div class="line">    });</div><div class="line"></div><div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> g = hana::make_lazy([](<span class="keyword">auto</span> x) {</div><div class="line">        <span class="keywordflow">return</span> x + 1;</div><div class="line">    });</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(hana::eval(<a class="code" href="group__group-Logical.html#gafd655d2222367131e7a63616e93dd080">hana::if_</a>(hana::false_c, f(0), g(0))) == 0 + 1);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>boost</b></li><li class="navelem"><a class="el" href="namespaceboost_1_1hana.html">hana</a></li><li class="navelem"><a class="el" href="structboost_1_1hana_1_1lazy.html">lazy</a></li>
  </ul>
</div>
</body>
</html>
