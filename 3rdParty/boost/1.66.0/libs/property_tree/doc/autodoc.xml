<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/property_tree/exceptions.hpp">
<namespace name="boost">
<namespace name="property_tree">
<class name="ptree_error"><inherit access="public">runtime_error</inherit><purpose>Base class for all property tree errors. Derives from <computeroutput>std::runtime_error</computeroutput>. Call member function <computeroutput>what</computeroutput> to get human readable message associated with the error. </purpose><method-group name="public member functions">
</method-group>
<constructor><parameter name="what"><paramtype>const std::string &amp;</paramtype><description><para>The message to associate with this error. </para></description></parameter><purpose>Instantiate a <classname alt="boost::property_tree::ptree_error">ptree_error</classname> instance with the given message. </purpose><description><para>
</para></description></constructor>
<destructor/>
</class><class name="ptree_bad_data"><inherit access="public">boost::property_tree::ptree_error</inherit><purpose>Error indicating that translation from given value to the property tree data_type (or vice versa) failed. Derives from <classname alt="boost::property_tree::ptree_error">ptree_error</classname>. </purpose><method-group name="public member functions">
<method name="data" cv="const"><type>T</type><template>
          <template-type-parameter name="T"/>
        </template><purpose>Retrieve the data associated with this error. This is the source value that failed to be translated. You need to explicitly specify its type. </purpose></method>
</method-group>
<constructor><template>
          <template-type-parameter name="T"/>
        </template><parameter name="what"><paramtype>const std::string &amp;</paramtype><description><para>The message to associate with this error. </para></description></parameter><parameter name="data"><paramtype>const T &amp;</paramtype><description><para>The value associated with this error that was the source of the translation failure. </para></description></parameter><purpose>Instantiate a <classname alt="boost::property_tree::ptree_bad_data">ptree_bad_data</classname> instance with the given message and data. </purpose><description><para>
</para></description></constructor>
<destructor/>
</class><class name="ptree_bad_path"><inherit access="public">boost::property_tree::ptree_error</inherit><purpose>Error indicating that specified path does not exist. Derives from <classname alt="boost::property_tree::ptree_error">ptree_error</classname>. </purpose><method-group name="public member functions">
<method name="path" cv="const"><type>T</type><template>
          <template-type-parameter name="T"/>
        </template><purpose>Retrieve the invalid path. You need to explicitly specify the type of path. </purpose></method>
</method-group>
<constructor><template>
          <template-type-parameter name="T"/>
        </template><parameter name="what"><paramtype>const std::string &amp;</paramtype><description><para>The message to associate with this error. </para></description></parameter><parameter name="path"><paramtype>const T &amp;</paramtype><description><para>The path that could not be found in the property_tree. </para></description></parameter><purpose>Instantiate a <classname alt="boost::property_tree::ptree_bad_path">ptree_bad_path</classname> with the given message and path data. </purpose><description><para>
</para></description></constructor>
<destructor/>
</class>






</namespace>
</namespace>
</header>
<header name="boost/property_tree/id_translator.hpp">
<namespace name="boost">
<namespace name="property_tree">
<struct-specialization name="translator_between"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>T</template-arg></specialization><typedef name="type"><type><classname>id_translator</classname>&lt; T &gt;</type></typedef>
</struct-specialization><struct-specialization name="translator_between"><template>
      <template-type-parameter name="Ch"/>
      <template-type-parameter name="Traits"/>
      <template-type-parameter name="Alloc"/>
    </template><specialization><template-arg>std::basic_string&lt; Ch</template-arg><template-arg>Traits</template-arg><template-arg>Alloc &gt;</template-arg><template-arg>std::basic_string&lt; Ch</template-arg><template-arg>Traits</template-arg><template-arg>Alloc &gt;</template-arg></specialization><typedef name="type"><type><classname>id_translator</classname>&lt; std::basic_string&lt; Ch, Traits, Alloc &gt; &gt;</type></typedef>
</struct-specialization>






</namespace>
</namespace>
</header>
<header name="boost/property_tree/info_parser.hpp">
<namespace name="boost">
<namespace name="property_tree">
<namespace name="info_parser">
<function name="read_info"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
          <template-type-parameter name="Ch"/>
        </template><parameter name="stream"><paramtype>std::basic_istream&lt; Ch &gt; &amp;</paramtype></parameter><parameter name="pt"><paramtype>Ptree &amp;</paramtype></parameter><description><para>Read INFO from a the given stream and translate it to a property tree. <note><para>Replaces the existing contents. Strong exception guarantee. </para></note>

</para></description><throws><simpara><classname>info_parser_error</classname> If the stream cannot be read, doesn't contain valid INFO, or a conversion fails. </simpara></throws></function>
<function name="read_info"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
          <template-type-parameter name="Ch"/>
        </template><parameter name="stream"><paramtype>std::basic_istream&lt; Ch &gt; &amp;</paramtype></parameter><parameter name="pt"><paramtype>Ptree &amp;</paramtype></parameter><parameter name="default_ptree"><paramtype>const Ptree &amp;</paramtype><description><para>If parsing fails, pt is set to a copy of this tree. </para></description></parameter><description><para>Read INFO from a the given stream and translate it to a property tree. <note><para>Replaces the existing contents. Strong exception guarantee. </para></note>

</para></description></function>
<function name="read_info"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="filename"><paramtype>const std::string &amp;</paramtype></parameter><parameter name="pt"><paramtype>Ptree &amp;</paramtype></parameter><parameter name="loc"><paramtype>const std::locale &amp;</paramtype><default>std::locale()</default></parameter><description><para>Read INFO from a the given file and translate it to a property tree. The tree's key type must be a string type, i.e. it must have a nested value_type typedef that is a valid parameter for basic_ifstream. <note><para>Replaces the existing contents. Strong exception guarantee. </para></note>

</para></description><throws><simpara><classname>info_parser_error</classname> If the file cannot be read, doesn't contain valid INFO, or a conversion fails. </simpara></throws></function>
<function name="read_info"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="filename"><paramtype>const std::string &amp;</paramtype></parameter><parameter name="pt"><paramtype>Ptree &amp;</paramtype></parameter><parameter name="default_ptree"><paramtype>const Ptree &amp;</paramtype><description><para>If parsing fails, pt is set to a copy of this tree. </para></description></parameter><parameter name="loc"><paramtype>const std::locale &amp;</paramtype><default>std::locale()</default></parameter><description><para>Read INFO from a the given file and translate it to a property tree. The tree's key type must be a string type, i.e. it must have a nested value_type typedef that is a valid parameter for basic_ifstream. <note><para>Replaces the existing contents. Strong exception guarantee. </para></note>

</para></description></function>
<function name="write_info"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
          <template-type-parameter name="Ch"/>
        </template><parameter name="stream"><paramtype>std::basic_ostream&lt; Ch &gt; &amp;</paramtype></parameter><parameter name="pt"><paramtype>const Ptree &amp;</paramtype></parameter><parameter name="settings"><paramtype>const info_writer_settings&lt; Ch &gt; &amp;</paramtype><default>info_writer_settings&lt; Ch &gt;()</default><description><para>The settings to use when writing the INFO data. </para></description></parameter><description><para>Writes a tree to the stream in INFO format. 

</para></description><throws><simpara><classname>info_parser_error</classname> If the stream cannot be written to, or a conversion fails. </simpara></throws></function>
<function name="write_info"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="filename"><paramtype>const std::string &amp;</paramtype></parameter><parameter name="pt"><paramtype>const Ptree &amp;</paramtype></parameter><parameter name="loc"><paramtype>const std::locale &amp;</paramtype><default>std::locale()</default></parameter><parameter name="settings"><paramtype>const info_writer_settings&lt; typename Ptree::key_type::value_type &gt; &amp;</paramtype><default>info_writer_make_settings&lt; typename Ptree::key_type::value_type &gt;()</default><description><para>The settings to use when writing the INFO data. </para></description></parameter><description><para>Writes a tree to the file in INFO format. The tree's key type must be a string type, i.e. it must have a nested value_type typedef that is a valid parameter for basic_ofstream. 

</para></description><throws><simpara><classname>info_parser_error</classname> If the file cannot be written to, or a conversion fails. </simpara></throws></function>
</namespace>







</namespace>
</namespace>
</header>
<header name="boost/property_tree/ini_parser.hpp">
<namespace name="boost">
<namespace name="property_tree">
<namespace name="ini_parser">
<class name="ini_parser_error"><inherit access="public">file_parser_error</inherit><description><para>Indicates an error parsing INI formatted data. </para></description><method-group name="public member functions">
</method-group>
<constructor><parameter name="message"><paramtype>const std::string &amp;</paramtype><description><para>Message describing the parser error. </para></description></parameter><parameter name="filename"><paramtype>const std::string &amp;</paramtype><description><para>The name of the file being parsed containing the error. </para></description></parameter><parameter name="line"><paramtype>unsigned long</paramtype><description><para>The line in the given file where an error was encountered. </para></description></parameter><description><para>Construct an <computeroutput><classname alt="boost::property_tree::ini_parser::ini_parser_error">ini_parser_error</classname></computeroutput> 
</para></description></constructor>
</class><function name="validate_flags"><type>bool</type><parameter name="flags"><paramtype>int</paramtype><description><para>value to check for validity as flags to ini_parser. </para></description></parameter><description><para>Determines whether the <computeroutput>flags</computeroutput> are valid for use with the ini_parser. 

</para></description><returns><para>true if the flags are valid, false otherwise. </para></returns></function>
<function name="read_ini"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="stream"><paramtype>std::basic_istream&lt; typename Ptree::key_type::value_type &gt; &amp;</paramtype><description><para>Stream from which to read in the property tree. </para></description></parameter><parameter name="pt"><paramtype>Ptree &amp;</paramtype><description><para>The property tree to populate. </para></description></parameter><description><para>Read INI from a the given stream and translate it to a property tree. <note><para>Clears existing contents of property tree. In case of error the property tree is not modified. </para></note>


</para></description><throws><simpara><classname>ini_parser_error</classname> If a format violation is found. </simpara></throws></function>
<function name="read_ini"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="filename"><paramtype>const std::string &amp;</paramtype><description><para>Name of file from which to read in the property tree. </para></description></parameter><parameter name="pt"><paramtype>Ptree &amp;</paramtype><description><para>The property tree to populate. </para></description></parameter><parameter name="loc"><paramtype>const std::locale &amp;</paramtype><default>std::locale()</default><description><para>The locale to use when reading in the file contents. </para></description></parameter><description><para>Read INI from a the given file and translate it to a property tree. <note><para>Clears existing contents of property tree. In case of error the property tree unmodified. </para></note>


</para></description><throws><simpara><classname>ini_parser_error</classname> In case of error deserializing the property tree. </simpara></throws></function>
<function name="write_ini"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="stream"><paramtype>std::basic_ostream&lt; typename Ptree::key_type::value_type &gt; &amp;</paramtype><description><para>The stream to which to write the INI representation of the property tree. </para></description></parameter><parameter name="pt"><paramtype>const Ptree &amp;</paramtype><description><para>The property tree to tranlsate to INI and output. </para></description></parameter><parameter name="flags"><paramtype>int</paramtype><default>0</default><description><para>The flags to use when writing the INI file. No flags are currently supported. </para></description></parameter><description><para>Translates the property tree to INI and writes it the given output stream. 


</para></description><requires><para><emphasis>pt</emphasis> cannot have data in its root. </para><para><emphasis>pt</emphasis> cannot have keys both data and children. </para><para><emphasis>pt</emphasis> cannot be deeper than two levels. </para><para>There cannot be duplicate keys on any given level of <emphasis>pt</emphasis>. </para></requires><throws><simpara><classname>ini_parser_error</classname> In case of error translating the property tree to INI or writing to the output stream. </simpara></throws></function>
<function name="write_ini"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="filename"><paramtype>const std::string &amp;</paramtype><description><para>The name of the file to which to write the INI representation of the property tree. </para></description></parameter><parameter name="pt"><paramtype>const Ptree &amp;</paramtype><description><para>The property tree to tranlsate to INI and output. </para></description></parameter><parameter name="flags"><paramtype>int</paramtype><default>0</default><description><para>The flags to use when writing the INI file. The following flags are supported: <itemizedlist>
<listitem><para><computeroutput>skip_ini_validity_check</computeroutput> – Skip check if ptree is a valid ini. The validity check covers the preconditions but takes <computeroutput>O(n log n)</computeroutput> time. </para></listitem>
</itemizedlist>
</para></description></parameter><parameter name="loc"><paramtype>const std::locale &amp;</paramtype><default>std::locale()</default><description><para>The locale to use when writing the file. </para></description></parameter><description><para>Translates the property tree to INI and writes it the given file. 


</para></description><requires><para><emphasis>pt</emphasis> cannot have data in its root. </para><para><emphasis>pt</emphasis> cannot have keys both data and children. </para><para><emphasis>pt</emphasis> cannot be deeper than two levels. </para><para>There cannot be duplicate keys on any given level of <emphasis>pt</emphasis>. </para></requires><throws><simpara><classname>info_parser_error</classname> In case of error translating the property tree to INI or writing to the file. </simpara></throws></function>
</namespace>







</namespace>
</namespace>
</header>
<header name="boost/property_tree/json_parser.hpp">
<namespace name="boost">
<namespace name="property_tree">
<namespace name="json_parser">
<function name="read_json"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="stream"><paramtype>std::basic_istream&lt; typename Ptree::key_type::value_type &gt; &amp;</paramtype><description><para>Stream from which to read in the property tree. </para></description></parameter><parameter name="pt"><paramtype>Ptree &amp;</paramtype><description><para>The property tree to populate. </para></description></parameter><description><para>Read JSON from a the given stream and translate it to a property tree. <note><para>Clears existing contents of property tree. In case of error the property tree unmodified. </para><para>Items of JSON arrays are translated into ptree keys with empty names. Members of objects are translated into named keys. </para><para>JSON data can be a string, a numeric value, or one of literals "null", "true" and "false". During parse, any of the above is copied verbatim into ptree data string. </para></note>


</para></description><throws><simpara><classname>json_parser_error</classname> In case of error deserializing the property tree. </simpara></throws></function>
<function name="read_json"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="filename"><paramtype>const std::string &amp;</paramtype><description><para>Name of file from which to read in the property tree. </para></description></parameter><parameter name="pt"><paramtype>Ptree &amp;</paramtype><description><para>The property tree to populate. </para></description></parameter><parameter name="loc"><paramtype>const std::locale &amp;</paramtype><default>std::locale()</default><description><para>The locale to use when reading in the file contents. </para></description></parameter><description><para>Read JSON from a the given file and translate it to a property tree. <note><para>Clears existing contents of property tree. In case of error the property tree unmodified. </para><para>Items of JSON arrays are translated into ptree keys with empty names. Members of objects are translated into named keys. </para><para>JSON data can be a string, a numeric value, or one of literals "null", "true" and "false". During parse, any of the above is copied verbatim into ptree data string. </para></note>


</para></description><throws><simpara><classname>json_parser_error</classname> In case of error deserializing the property tree. </simpara></throws></function>
<function name="write_json"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="stream"><paramtype>std::basic_ostream&lt; typename Ptree::key_type::value_type &gt; &amp;</paramtype><description><para>The stream to which to write the JSON representation of the property tree. </para></description></parameter><parameter name="pt"><paramtype>const Ptree &amp;</paramtype><description><para>The property tree to tranlsate to JSON and output. </para></description></parameter><parameter name="pretty"><paramtype>bool</paramtype><default>true</default><description><para>Whether to pretty-print. Defaults to true for backward compatibility. </para></description></parameter><description><para>Translates the property tree to JSON and writes it the given output stream. <note><para>Any property tree key containing only unnamed subkeys will be rendered as JSON arrays. </para></note>



</para></description><requires><para><emphasis>pt</emphasis> cannot contain keys that have both subkeys and non-empty data. </para></requires><throws><simpara><classname>json_parser_error</classname> In case of error translating the property tree to JSON or writing to the output stream. </simpara></throws></function>
<function name="write_json"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="filename"><paramtype>const std::string &amp;</paramtype><description><para>The name of the file to which to write the JSON representation of the property tree. </para></description></parameter><parameter name="pt"><paramtype>const Ptree &amp;</paramtype><description><para>The property tree to translate to JSON and output. </para></description></parameter><parameter name="loc"><paramtype>const std::locale &amp;</paramtype><default>std::locale()</default><description><para>The locale to use when writing out to the output file. </para></description></parameter><parameter name="pretty"><paramtype>bool</paramtype><default>true</default><description><para>Whether to pretty-print. Defaults to true and last place for backward compatibility. </para></description></parameter><description><para>Translates the property tree to JSON and writes it the given file. <note><para>Any property tree key containing only unnamed subkeys will be rendered as JSON arrays. </para></note>



</para></description><requires><para><emphasis>pt</emphasis> cannot contain keys that have both subkeys and non-empty data. </para></requires><throws><simpara><classname>json_parser_error</classname> In case of error translating the property tree to JSON or writing to the file. </simpara></throws></function>
</namespace>







</namespace>
</namespace>
</header>
<header name="boost/property_tree/ptree.hpp">
<namespace name="boost">
<namespace name="property_tree">







</namespace>
</namespace>
</header>
<header name="boost/property_tree/ptree_fwd.hpp">
<namespace name="boost">
<namespace name="property_tree">
<class name="basic_ptree"><template>
      <template-type-parameter name="Key"/>
      <template-type-parameter name="Data"/>
      <template-type-parameter name="KeyCompare"><default>std::less&lt;Key&gt;</default></template-type-parameter>
    </template><description><para>Property tree main structure. A property tree is a hierarchical data structure which has one element of type <computeroutput>Data</computeroutput> in each node, as well as an ordered sequence of sub-nodes, which are additionally identified by a non-unique key of type <computeroutput>Key</computeroutput>.</para><para>Key equivalency is defined by <computeroutput>KeyCompare</computeroutput>, a predicate defining a strict weak ordering.</para><para>Property tree defines a Container-like interface to the (key-node) pairs of its direct sub-nodes. The iterators are bidirectional. The sequence of nodes is held in insertion order, not key order. </para></description><method-group name="public member functions">
<method name="swap"><type>void</type><parameter name="rhs"><paramtype>self_type &amp;</paramtype></parameter><description><para>Swap with other tree. Only constant-time and nothrow if the data type's swap is. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para>The number of direct children of this node. </para></description></method>
<method name="max_size" cv="const"><type>size_type</type></method>
<method name="empty" cv="const"><type>bool</type><description><para>Whether there are any direct children. </para></description></method>
<method name="begin"><type>iterator</type></method>
<method name="begin" cv="const"><type>const_iterator</type></method>
<method name="end"><type>iterator</type></method>
<method name="end" cv="const"><type>const_iterator</type></method>
<method name="rbegin"><type>reverse_iterator</type></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type></method>
<method name="rend"><type>reverse_iterator</type></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type></method>
<method name="front"><type>value_type &amp;</type></method>
<method name="front" cv="const"><type>const value_type &amp;</type></method>
<method name="back"><type>value_type &amp;</type></method>
<method name="back" cv="const"><type>const value_type &amp;</type></method>
<method name="insert"><type>iterator</type><parameter name="where"><paramtype>iterator</paramtype></parameter><parameter name="value"><paramtype>const value_type &amp;</paramtype></parameter><description><para>Insert a copy of the given tree with its key just before the given position in this node. This operation invalidates no iterators. 
</para></description><returns><para>An iterator to the newly created child. </para></returns></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="It"/>
        </template><parameter name="where"><paramtype>iterator</paramtype></parameter><parameter name="first"><paramtype>It</paramtype></parameter><parameter name="last"><paramtype>It</paramtype></parameter><description><para>Range insert. Equivalent to: <programlisting language="c++">for(; first != last; ++first) insert(where, *first);
</programlisting> </para></description></method>
<method name="erase"><type>iterator</type><parameter name="where"><paramtype>iterator</paramtype></parameter><description><para>Erase the child pointed at by the iterator. This operation invalidates the given iterator, as well as its equivalent assoc_iterator. 
</para></description><returns><para>A valid iterator pointing to the element after the erased. </para></returns></method>
<method name="erase"><type>iterator</type><parameter name="first"><paramtype>iterator</paramtype></parameter><parameter name="last"><paramtype>iterator</paramtype></parameter><description><para>Range erase. Equivalent to: <programlisting language="c++">while(first != last;) first = erase(first);
</programlisting> </para></description></method>
<method name="push_front"><type>iterator</type><parameter name="value"><paramtype>const value_type &amp;</paramtype></parameter><description><para>Equivalent to insert(begin(), value). </para></description></method>
<method name="push_back"><type>iterator</type><parameter name="value"><paramtype>const value_type &amp;</paramtype></parameter><description><para>Equivalent to insert(end(), value). </para></description></method>
<method name="pop_front"><type>void</type><description><para>Equivalent to erase(begin()). </para></description></method>
<method name="pop_back"><type>void</type><description><para>Equivalent to erase(boost::prior(end())). </para></description></method>
<method name="reverse"><type>void</type><description><para>Reverses the order of direct children in the property tree. </para></description></method>
<method name="sort"><type>void</type><template>
          <template-type-parameter name="Compare"/>
        </template><parameter name="comp"><paramtype>Compare</paramtype></parameter><description><para>Sorts the direct children of this node according to the predicate. The predicate is passed the whole pair of key and child. </para></description></method>
<method name="sort"><type>void</type><description><para>Sorts the direct children of this node according to key order. </para></description></method>
<method name="operator==" cv="const"><type>bool</type><parameter name="rhs"><paramtype>const self_type &amp;</paramtype></parameter><description><para>Two property trees are the same if they have the same data, the keys and order of their children are the same, and the children compare equal, recursively. </para></description></method>
<method name="operator!=" cv="const"><type>bool</type><parameter name="rhs"><paramtype>const self_type &amp;</paramtype></parameter></method>
<method name="ordered_begin"><type>assoc_iterator</type><description><para>Returns an iterator to the first child, in key order. </para></description></method>
<method name="ordered_begin" cv="const"><type>const_assoc_iterator</type><description><para>Returns an iterator to the first child, in key order. </para></description></method>
<method name="not_found"><type>assoc_iterator</type><description><para>Returns the not-found iterator. Equivalent to end() in a real associative container. </para></description></method>
<method name="not_found" cv="const"><type>const_assoc_iterator</type><description><para>Returns the not-found iterator. Equivalent to end() in a real associative container. </para></description></method>
<method name="find"><type>assoc_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para>Find a child with the given key, or not_found() if there is none. There is no guarantee about which child is returned if multiple have the same key. </para></description></method>
<method name="find" cv="const"><type>const_assoc_iterator</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para>Find a child with the given key, or not_found() if there is none. There is no guarantee about which child is returned if multiple have the same key. </para></description></method>
<method name="equal_range"><type>std::pair&lt; assoc_iterator, assoc_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para>Find the range of children that have the given key. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_assoc_iterator, const_assoc_iterator &gt;</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para>Find the range of children that have the given key. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para>Count the number of direct children with the given key. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="key"><paramtype>const key_type &amp;</paramtype></parameter><description><para>Erase all direct children with the given key and return the count. </para></description></method>
<method name="to_iterator"><type>iterator</type><parameter name="it"><paramtype>assoc_iterator</paramtype></parameter><description><para>Get the iterator that points to the same element as the argument. <note><para>A valid assoc_iterator range (a, b) does not imply that (to_iterator(a), to_iterator(b)) is a valid range. </para></note>
</para></description></method>
<method name="to_iterator" cv="const"><type>const_iterator</type><parameter name="it"><paramtype>const_assoc_iterator</paramtype></parameter><description><para>Get the iterator that points to the same element as the argument. <note><para>A valid const_assoc_iterator range (a, b) does not imply that (to_iterator(a), to_iterator(b)) is a valid range. </para></note>
</para></description></method>
<method name="data"><type>data_type &amp;</type><description><para>Reference to the actual data in this node. </para></description></method>
<method name="data" cv="const"><type>const data_type &amp;</type><description><para>Reference to the actual data in this node. </para></description></method>
<method name="clear"><type>void</type><description><para>Clear this tree completely, of both data and children. </para></description></method>
<method name="get_child"><type>self_type &amp;</type><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><description><para>Get the child at the given path, or throw <computeroutput><classname alt="boost::property_tree::ptree_bad_path">ptree_bad_path</classname></computeroutput>. <note><para>Depending on the path, the result at each level may not be completely deterministic, i.e. if the same key appears multiple times, which child is chosen is not specified. This can lead to the path not being resolved even though there is a descendant with this path. Example: <programlisting language="c++">a -&gt; b -&gt; c
  -&gt; b
</programlisting> The path "a.b.c" will succeed if the resolution of "b" chooses the first such node, but fail if it chooses the second. </para></note>
</para></description></method>
<method name="get_child" cv="const"><type>const self_type &amp;</type><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><description><para>Get the child at the given path, or throw <computeroutput><classname alt="boost::property_tree::ptree_bad_path">ptree_bad_path</classname></computeroutput>. </para></description></method>
<method name="get_child"><type>self_type &amp;</type><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><parameter name="default_value"><paramtype>self_type &amp;</paramtype></parameter><description><para>Get the child at the given path, or return <computeroutput>default_value</computeroutput>. </para></description></method>
<method name="get_child" cv="const"><type>const self_type &amp;</type><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><parameter name="default_value"><paramtype>const self_type &amp;</paramtype></parameter><description><para>Get the child at the given path, or return <computeroutput>default_value</computeroutput>. </para></description></method>
<method name="get_child_optional"><type>optional&lt; self_type &amp; &gt;</type><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><description><para>Get the child at the given path, or return boost::null. </para></description></method>
<method name="get_child_optional" cv="const"><type>optional&lt; const self_type &amp; &gt;</type><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><description><para>Get the child at the given path, or return boost::null. </para></description></method>
<method name="put_child"><type>self_type &amp;</type><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><parameter name="value"><paramtype>const self_type &amp;</paramtype></parameter><description><para>Set the node at the given path to the given value. Create any missing parents. If the node at the path already exists, replace it. 
<note><para>Because of the way paths work, it is not generally guaranteed that a node newly created can be accessed using the same path. </para><para>If the path could refer to multiple nodes, it is unspecified which one gets replaced. </para></note>
</para></description><returns><para>A reference to the inserted subtree. </para></returns></method>
<method name="add_child"><type>self_type &amp;</type><parameter name="path"><paramtype>const path_type &amp;</paramtype><description><para>Path to the child. The last fragment must not have an index. </para></description></parameter><parameter name="value"><paramtype>const self_type &amp;</paramtype></parameter><description><para>Add the node at the given path. Create any missing parents. If there already is a node at the path, add another one with the same key. 

<note><para>Because of the way paths work, it is not generally guaranteed that a node newly created can be accessed using the same path. </para></note>
</para></description><returns><para>A reference to the inserted subtree. </para></returns></method>
<method name="get_value" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Type"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="tr"><paramtype>Translator</paramtype></parameter><description><para>Take the value of this node and attempt to translate it to a <computeroutput>Type</computeroutput> object using the supplied translator. 
</para></description><throws><simpara><classname>ptree_bad_data</classname> if the conversion fails. </simpara></throws></method>
<method name="get_value" cv="const"><type>Type</type><template>
          <template-type-parameter name="Type"/>
        </template><description><para>Take the value of this node and attempt to translate it to a <computeroutput>Type</computeroutput> object using the default translator. 
</para></description><throws><simpara><classname>ptree_bad_data</classname> if the conversion fails. </simpara></throws></method>
<method name="get_value" cv="const"><type>Type</type><template>
          <template-type-parameter name="Type"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="default_value"><paramtype>const Type &amp;</paramtype></parameter><parameter name="tr"><paramtype>Translator</paramtype></parameter><description><para>Take the value of this node and attempt to translate it to a <computeroutput>Type</computeroutput> object using the supplied translator. Return <computeroutput>default_value</computeroutput> if this fails. </para></description></method>
<method name="get_value" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Ch"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="default_value"><paramtype>const Ch *</paramtype></parameter><parameter name="tr"><paramtype>Translator</paramtype></parameter><description><para>Make get_value do the right thing for string literals. </para></description></method>
<method name="get_value" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Type"/>
        </template><parameter name="default_value"><paramtype>const Type &amp;</paramtype></parameter><description><para>Take the value of this node and attempt to translate it to a <computeroutput>Type</computeroutput> object using the default translator. Return <computeroutput>default_value</computeroutput> if this fails. </para></description></method>
<method name="get_value" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Ch"/>
        </template><parameter name="default_value"><paramtype>const Ch *</paramtype></parameter><description><para>Make get_value do the right thing for string literals. </para></description></method>
<method name="get_value_optional" cv="const"><type>optional&lt; Type &gt;</type><template>
          <template-type-parameter name="Type"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="tr"><paramtype>Translator</paramtype></parameter><description><para>Take the value of this node and attempt to translate it to a <computeroutput>Type</computeroutput> object using the supplied translator. Return boost::null if this fails. </para></description></method>
<method name="get_value_optional" cv="const"><type>optional&lt; Type &gt;</type><template>
          <template-type-parameter name="Type"/>
        </template><description><para>Take the value of this node and attempt to translate it to a <computeroutput>Type</computeroutput> object using the default translator. Return boost::null if this fails. </para></description></method>
<method name="put_value"><type>void</type><template>
          <template-type-parameter name="Type"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="value"><paramtype>const Type &amp;</paramtype></parameter><parameter name="tr"><paramtype>Translator</paramtype></parameter><description><para>Replace the value at this node with the given value, translated to the tree's data type using the supplied translator. 
</para></description><throws><simpara><classname>ptree_bad_data</classname> if the conversion fails. </simpara></throws></method>
<method name="put_value"><type>void</type><template>
          <template-type-parameter name="Type"/>
        </template><parameter name="value"><paramtype>const Type &amp;</paramtype></parameter><description><para>Replace the value at this node with the given value, translated to the tree's data type using the default translator. 
</para></description><throws><simpara><classname>ptree_bad_data</classname> if the conversion fails. </simpara></throws></method>
<method name="get" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Type"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><parameter name="tr"><paramtype>Translator</paramtype></parameter><description><para>Shorthand for get_child(path).get_value(tr). </para></description></method>
<method name="get" cv="const"><type>Type</type><template>
          <template-type-parameter name="Type"/>
        </template><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><description><para>Shorthand for get_child(path).get_value&lt;Type&gt;(). </para></description></method>
<method name="get" cv="const"><type>Type</type><template>
          <template-type-parameter name="Type"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><parameter name="default_value"><paramtype>const Type &amp;</paramtype></parameter><parameter name="tr"><paramtype>Translator</paramtype></parameter><description><para>Shorthand for get_child(path, empty_ptree()) .get_value(default_value, tr). That is, return the translated value if possible, and the default value if the node doesn't exist or conversion fails. </para></description></method>
<method name="get" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Ch"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><parameter name="default_value"><paramtype>const Ch *</paramtype></parameter><parameter name="tr"><paramtype>Translator</paramtype></parameter><description><para>Make get do the right thing for string literals. </para></description></method>
<method name="get" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Type"/>
        </template><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><parameter name="default_value"><paramtype>const Type &amp;</paramtype></parameter><description><para>Shorthand for get_child(path, empty_ptree()) .get_value(default_value). That is, return the translated value if possible, and the default value if the node doesn't exist or conversion fails. </para></description></method>
<method name="get" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Ch"/>
        </template><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><parameter name="default_value"><paramtype>const Ch *</paramtype></parameter><description><para>Make get do the right thing for string literals. </para></description></method>
<method name="get_optional" cv="const"><type>optional&lt; Type &gt;</type><template>
          <template-type-parameter name="Type"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><parameter name="tr"><paramtype>Translator</paramtype></parameter><description><para>Shorthand for: <programlisting language="c++">if(optional\&lt;self_type&amp;\&gt; node = get_child_optional(path))
  return node-&gt;get_value_optional(tr);
return boost::null;
</programlisting> That is, return the value if it exists and can be converted, or nil. </para></description></method>
<method name="get_optional" cv="const"><type>optional&lt; Type &gt;</type><template>
          <template-type-parameter name="Type"/>
        </template><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><description><para>Shorthand for: <programlisting language="c++">if(optional\&lt;const self_type&amp;\&gt; node = get_child_optional(path))
  return node-&gt;get_value_optional();
return boost::null;
</programlisting> That is, return the value if it exists and can be converted, or nil. </para></description></method>
<method name="put"><type>self_type &amp;</type><template>
          <template-type-parameter name="Type"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><parameter name="value"><paramtype>const Type &amp;</paramtype></parameter><parameter name="tr"><paramtype>Translator</paramtype></parameter><description><para>Set the value of the node at the given path to the supplied value, translated to the tree's data type. If the node doesn't exist, it is created, including all its missing parents. 

</para></description><returns><para>The node that had its value changed. </para></returns><throws><simpara><classname>ptree_bad_data</classname> if the conversion fails. </simpara></throws></method>
<method name="put"><type>self_type &amp;</type><template>
          <template-type-parameter name="Type"/>
        </template><parameter name="path"><paramtype>const path_type &amp;</paramtype></parameter><parameter name="value"><paramtype>const Type &amp;</paramtype></parameter><description><para>Set the value of the node at the given path to the supplied value, translated to the tree's data type. If the node doesn't exist, it is created, including all its missing parents. 

</para></description><returns><para>The node that had its value changed. </para></returns><throws><simpara><classname>ptree_bad_data</classname> if the conversion fails. </simpara></throws></method>
<method name="add"><type>self_type &amp;</type><template>
          <template-type-parameter name="Type"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="path"><paramtype>const path_type &amp;</paramtype><description><para>Path to the child. The last fragment must not have an index. </para></description></parameter><parameter name="value"><paramtype>const Type &amp;</paramtype><description><para>The value to add. </para></description></parameter><parameter name="tr"><paramtype>Translator</paramtype><description><para>The translator to use. </para></description></parameter><description><para>If the node identified by the path does not exist, create it, including all its missing parents. If the node already exists, add a sibling with the same key. Set the newly created node's value to the given paremeter, translated with the supplied translator. 


</para></description><returns><para>The node that was added. </para></returns><throws><simpara><classname>ptree_bad_data</classname> if the conversion fails. </simpara></throws></method>
<method name="add"><type>self_type &amp;</type><template>
          <template-type-parameter name="Type"/>
        </template><parameter name="path"><paramtype>const path_type &amp;</paramtype><description><para>Path to the child. The last fragment must not have an index. </para></description></parameter><parameter name="value"><paramtype>const Type &amp;</paramtype><description><para>The value to add. </para></description></parameter><description><para>If the node identified by the path does not exist, create it, including all its missing parents. If the node already exists, add a sibling with the same key. Set the newly created node's value to the given paremeter, translated with the supplied translator. 


</para></description><returns><para>The node that was added. </para></returns><throws><simpara><classname>ptree_bad_data</classname> if the conversion fails. </simpara></throws></method>
</method-group>
<constructor><description><para>Creates a node with no children and default-constructed data. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="data"><paramtype>const data_type &amp;</paramtype></parameter><description><para>Creates a node with no children and a copy of the given data. </para></description></constructor>
<constructor><parameter name="rhs"><paramtype>const self_type &amp;</paramtype></parameter></constructor>
<destructor/>
<copy-assignment><type>self_type &amp;</type><parameter name="rhs"><paramtype>const self_type &amp;</paramtype></parameter><description><para>Basic guarantee only. </para></description></copy-assignment>
<method-group name="private member functions">
<method name="walk_path" cv="const"><type>self_type *</type><parameter name="p"><paramtype>path_type &amp;</paramtype></parameter></method>
<method name="force_path"><type>self_type &amp;</type><parameter name="p"><paramtype>path_type &amp;</paramtype></parameter></method>
</method-group>
</class><struct name="id_translator"><template>
      <template-type-parameter name="T"/>
    </template><purpose>Simple implementation of the Translator concept. It does no translation. </purpose><method-group name="public member functions">
<method name="get_value"><type>boost::optional&lt; T &gt;</type><parameter name="v"><paramtype>const T &amp;</paramtype></parameter></method>
<method name="put_value"><type>boost::optional&lt; T &gt;</type><parameter name="v"><paramtype>const T &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="path_of"><template>
      <template-type-parameter name="Key"/>
    </template><purpose>If you want to use a custom key type, specialize this struct for it and give it a 'type' typedef that specifies your path type. The path type must conform to the Path concept described in the documentation. This is already specialized for std::basic_string. </purpose></struct><struct name="translator_between"><template>
      <template-type-parameter name="Internal"/>
      <template-type-parameter name="External"/>
    </template><purpose>Specialize this struct to specify a default translator between the data in a tree whose data_type is Internal, and the external data_type specified in a get_value, get, put_value or put operation. This is already specialized for Internal being std::basic_string. </purpose></struct><typedef name="path"><description><para>Implements a path using a std::string as the key. </para></description><type><classname>string_path</classname>&lt; std::string, <classname>id_translator</classname>&lt; std::string &gt; &gt;</type></typedef>
<typedef name="ptree"><description><para>A property tree with std::string for key and data, and default comparison. </para></description><type><classname>basic_ptree</classname>&lt; std::string, std::string &gt;</type></typedef>
<typedef name="iptree"><description><para>A property tree with std::string for key and data, and case-insensitive comparison. </para></description><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="wpath"><description><para>Implements a path using a std::wstring as the key. </para></description><type><classname>string_path</classname>&lt; std::wstring, <classname>id_translator</classname>&lt; std::wstring &gt; &gt;</type></typedef>
<typedef name="wptree"><description><para>A property tree with std::wstring for key and data, and default comparison. <note><para>The type only exists if the platform supports <computeroutput>wchar_t</computeroutput>. </para></note>
</para></description><type><classname>basic_ptree</classname>&lt; std::wstring, std::wstring &gt;</type></typedef>
<typedef name="wiptree"><description><para>A property tree with std::wstring for key and data, and case-insensitive comparison. <note><para>The type only exists if the platform supports <computeroutput>wchar_t</computeroutput>. </para></note>
</para></description><type><emphasis>unspecified</emphasis></type></typedef>






<function name="swap"><type>void</type><template>
          <template-type-parameter name="K"/>
          <template-type-parameter name="D"/>
          <template-type-parameter name="C"/>
        </template><parameter name="pt1"><paramtype><classname>basic_ptree</classname>&lt; K, D, C &gt; &amp;</paramtype></parameter><parameter name="pt2"><paramtype><classname>basic_ptree</classname>&lt; K, D, C &gt; &amp;</paramtype></parameter><description><para>Swap two property tree instances. </para></description></function>
</namespace>
</namespace>
</header>
<header name="boost/property_tree/ptree_serialization.hpp">
<namespace name="boost">
<namespace name="property_tree">



<function name="save"><type>void</type><template>
          <template-type-parameter name="Archive"/>
          <template-type-parameter name="K"/>
          <template-type-parameter name="D"/>
          <template-type-parameter name="C"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype><description><para>The archive to which to save the serialized property tree. This archive should conform to the concept laid out by the Boost.Serialization library. </para></description></parameter><parameter name="t"><paramtype>const <classname>basic_ptree</classname>&lt; K, D, C &gt; &amp;</paramtype><description><para>The property tree to serialize. </para></description></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype><description><para>file_version for the archive. </para></description></parameter><description><para>Serialize the property tree to the given archive. <note><para>In addition to serializing to regular archives, this supports serializing to archives requiring name-value pairs, e.g. XML archives. However, the output format in the XML archive is not guaranteed to be the same as that when using the Boost.PropertyTree library's <computeroutput>boost::property_tree::xml_parser::write_xml</computeroutput>. </para></note>


</para></description><postconditions><para><computeroutput>ar</computeroutput> will contain the serialized form of <computeroutput>t</computeroutput>. </para></postconditions></function>
<function name="load"><type>void</type><template>
          <template-type-parameter name="Archive"/>
          <template-type-parameter name="K"/>
          <template-type-parameter name="D"/>
          <template-type-parameter name="C"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype><description><para>The archive from which to load the serialized property tree. This archive should conform to the concept laid out by the Boost.Serialization library. </para></description></parameter><parameter name="t"><paramtype><classname>basic_ptree</classname>&lt; K, D, C &gt; &amp;</paramtype><description><para>The property tree to de-serialize. </para></description></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype><description><para>file_version for the archive. </para></description></parameter><description><para>De-serialize the property tree to the given archive. <note><para>In addition to de-serializing from regular archives, this supports loading from archives requiring name-value pairs, e.g. XML archives. The format should be that used by boost::property_tree::save. </para></note>


</para></description><postconditions><para><computeroutput>t</computeroutput> will contain the de-serialized data from <computeroutput>ar</computeroutput>. </para></postconditions></function>
<function name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
          <template-type-parameter name="K"/>
          <template-type-parameter name="D"/>
          <template-type-parameter name="C"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype><description><para>The archive from which to load or save the serialized property tree. The type of this archive will determine whether saving or loading is performed. </para></description></parameter><parameter name="t"><paramtype><classname>basic_ptree</classname>&lt; K, D, C &gt; &amp;</paramtype><description><para>The property tree to load or save. </para></description></parameter><parameter name="file_version"><paramtype>const unsigned int</paramtype><description><para>file_version for the archive. </para></description></parameter><description><para>Load or store the property tree using the given archive. 
</para></description></function>

</namespace>
</namespace>
</header>
<header name="boost/property_tree/stream_translator.hpp">
<namespace name="boost">
<namespace name="property_tree">
<struct name="customize_stream"><template>
      <template-type-parameter name="Ch"/>
      <template-type-parameter name="Traits"/>
      <template-type-parameter name="E"/>
      <template-type-parameter name="Enabler"><default>void</default></template-type-parameter>
    </template><method-group name="public static functions">
<method name="insert" specifiers="static"><type>void</type><parameter name="s"><paramtype>std::basic_ostream&lt; Ch, Traits &gt; &amp;</paramtype></parameter><parameter name="e"><paramtype>const E &amp;</paramtype></parameter></method>
<method name="extract" specifiers="static"><type>void</type><parameter name="s"><paramtype>std::basic_istream&lt; Ch, Traits &gt; &amp;</paramtype></parameter><parameter name="e"><paramtype>E &amp;</paramtype></parameter></method>
</method-group>
</struct><struct-specialization name="customize_stream"><template>
      <template-type-parameter name="Ch"/>
      <template-type-parameter name="Traits"/>
    </template><specialization><template-arg>Ch</template-arg><template-arg>Traits</template-arg><template-arg>Ch</template-arg><template-arg>void</template-arg></specialization><method-group name="public static functions">
<method name="insert" specifiers="static"><type>void</type><parameter name="s"><paramtype>std::basic_ostream&lt; Ch, Traits &gt; &amp;</paramtype></parameter><parameter name="e"><paramtype>Ch</paramtype></parameter></method>
<method name="extract" specifiers="static"><type>void</type><parameter name="s"><paramtype>std::basic_istream&lt; Ch, Traits &gt; &amp;</paramtype></parameter><parameter name="e"><paramtype>Ch &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="customize_stream"><template>
      <template-type-parameter name="Ch"/>
      <template-type-parameter name="Traits"/>
      <template-type-parameter name="F"/>
    </template><specialization><template-arg>Ch</template-arg><template-arg>Traits</template-arg><template-arg>F</template-arg><template-arg>typename boost::enable_if&lt; detail::is_inexact&lt; F &gt; &gt;::type</template-arg></specialization><method-group name="public static functions">
<method name="insert" specifiers="static"><type>void</type><parameter name="s"><paramtype>std::basic_ostream&lt; Ch, Traits &gt; &amp;</paramtype></parameter><parameter name="e"><paramtype>const F &amp;</paramtype></parameter></method>
<method name="extract" specifiers="static"><type>void</type><parameter name="s"><paramtype>std::basic_istream&lt; Ch, Traits &gt; &amp;</paramtype></parameter><parameter name="e"><paramtype>F &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="customize_stream"><template>
      <template-type-parameter name="Ch"/>
      <template-type-parameter name="Traits"/>
    </template><specialization><template-arg>Ch</template-arg><template-arg>Traits</template-arg><template-arg>bool</template-arg><template-arg>void</template-arg></specialization><method-group name="public static functions">
<method name="insert" specifiers="static"><type>void</type><parameter name="s"><paramtype>std::basic_ostream&lt; Ch, Traits &gt; &amp;</paramtype></parameter><parameter name="e"><paramtype>bool</paramtype></parameter></method>
<method name="extract" specifiers="static"><type>void</type><parameter name="s"><paramtype>std::basic_istream&lt; Ch, Traits &gt; &amp;</paramtype></parameter><parameter name="e"><paramtype>bool &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="customize_stream"><template>
      <template-type-parameter name="Ch"/>
      <template-type-parameter name="Traits"/>
    </template><specialization><template-arg>Ch</template-arg><template-arg>Traits</template-arg><template-arg>signed char</template-arg><template-arg>void</template-arg></specialization><method-group name="public static functions">
<method name="insert" specifiers="static"><type>void</type><parameter name="s"><paramtype>std::basic_ostream&lt; Ch, Traits &gt; &amp;</paramtype></parameter><parameter name="e"><paramtype>signed char</paramtype></parameter></method>
<method name="extract" specifiers="static"><type>void</type><parameter name="s"><paramtype>std::basic_istream&lt; Ch, Traits &gt; &amp;</paramtype></parameter><parameter name="e"><paramtype>signed char &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="customize_stream"><template>
      <template-type-parameter name="Ch"/>
      <template-type-parameter name="Traits"/>
    </template><specialization><template-arg>Ch</template-arg><template-arg>Traits</template-arg><template-arg>unsigned char</template-arg><template-arg>void</template-arg></specialization><method-group name="public static functions">
<method name="insert" specifiers="static"><type>void</type><parameter name="s"><paramtype>std::basic_ostream&lt; Ch, Traits &gt; &amp;</paramtype></parameter><parameter name="e"><paramtype>unsigned char</paramtype></parameter></method>
<method name="extract" specifiers="static"><type>void</type><parameter name="s"><paramtype>std::basic_istream&lt; Ch, Traits &gt; &amp;</paramtype></parameter><parameter name="e"><paramtype>unsigned char &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><class name="stream_translator"><template>
      <template-type-parameter name="Ch"/>
      <template-type-parameter name="Traits"/>
      <template-type-parameter name="Alloc"/>
      <template-type-parameter name="E"/>
    </template><purpose>Implementation of Translator that uses the stream overloads. </purpose><typedef name="internal_type"><type>std::basic_string&lt; Ch, Traits, Alloc &gt;</type></typedef>
<typedef name="external_type"><type>E</type></typedef>
<method-group name="public member functions">
<method name="get_value"><type>boost::optional&lt; E &gt;</type><parameter name="v"><paramtype>const internal_type &amp;</paramtype></parameter></method>
<method name="put_value"><type>boost::optional&lt; internal_type &gt;</type><parameter name="v"><paramtype>const E &amp;</paramtype></parameter></method>
</method-group>
<constructor specifiers="explicit"><parameter name="loc"><paramtype>std::locale</paramtype><default>std::locale()</default></parameter></constructor>
</class><struct-specialization name="translator_between"><template>
      <template-type-parameter name="Ch"/>
      <template-type-parameter name="Traits"/>
      <template-type-parameter name="Alloc"/>
      <template-type-parameter name="E"/>
    </template><specialization><template-arg>std::basic_string&lt; Ch</template-arg><template-arg>Traits</template-arg><template-arg>Alloc &gt;</template-arg><template-arg>E</template-arg></specialization><typedef name="type"><type><classname>stream_translator</classname>&lt; Ch, Traits, Alloc, E &gt;</type></typedef>
</struct-specialization>






</namespace>
</namespace>
</header>
<header name="boost/property_tree/string_path.hpp">
<namespace name="boost">
<namespace name="property_tree">
<class name="string_path"><template>
      <template-type-parameter name="String"><purpose><para>Any Sequence. If the sequence does not support random- access iteration, concatenation of paths assumes that insertions at the end preserve iterator validity. </para></purpose></template-type-parameter>
      <template-type-parameter name="Translator"><purpose><para>A translator with internal_type == String. </para></purpose></template-type-parameter>
    </template><purpose>Default path class. A path is a sequence of values. Groups of values are separated by the separator value, which defaults to '.' cast to the sequence's value type. The group of values is then passed to the translator to get a key. </purpose><description><para>If instantiated with std::string and <classname alt="boost::property_tree::id_translator">id_translator</classname>&lt;std::string&gt;, it accepts paths of the form "one.two.three.four".</para><para>
</para></description><typedef name="key_type"><type>Translator::external_type</type></typedef>
<typedef name="char_type"><type>String::value_type</type></typedef>
<method-group name="private member functions">
<method name="BOOST_STATIC_ASSERT"><type/><parameter name=""><paramtype>(is_same&lt; String, typename Translator::internal_type &gt;::value)</paramtype></parameter></method>
<method name="cstart" cv="const"><type>s_c_iter</type></method>
</method-group>
<method-group name="public member functions">
<method name="reduce"><type>key_type</type><purpose>Take a single element off the path at the front and return it. </purpose></method>
<method name="empty" cv="const"><type>bool</type><purpose>Test if the path is empty. </purpose></method>
<method name="single" cv="const"><type>bool</type><purpose>Test if the path contains a single element, i.e. no separators. </purpose></method>
<method name="separator" cv="const"><type>char_type</type><purpose>Get the separator used by this path. </purpose></method>
<method name="dump" cv="const"><type>std::string</type></method>
<method name="operator/="><type><classname>string_path</classname> &amp;</type><parameter name="o"><paramtype>const <classname>string_path</classname> &amp;</paramtype></parameter><purpose>Append a second path to this one. </purpose><description><para>
</para></description><requires><para>o's separator is the same as this one's, or o has no separators </para></requires></method>
</method-group>
<constructor specifiers="explicit"><parameter name="separator"><paramtype>char_type</paramtype><default>char_type('.')</default></parameter><purpose>Create an empty path. </purpose></constructor>
<constructor><parameter name="value"><paramtype>const String &amp;</paramtype><description><para>A sequence, possibly with separators, that describes the path, e.g. "one.two.three". </para></description></parameter><parameter name="separator"><paramtype>char_type</paramtype><default>char_type('.')</default><description><para>The separator used in parsing. Defaults to '.'. </para></description></parameter><parameter name="tr"><paramtype>Translator</paramtype><default>Translator()</default><description><para>The translator used by this path to convert the individual parts to keys. </para></description></parameter><purpose>Create a path by parsing the given string. </purpose><description><para>
</para></description></constructor>
<constructor><parameter name="value"><paramtype>const char_type *</paramtype><description><para>A zero-terminated array of values. Only use if zero- termination makes sense for your type, and your sequence supports construction from it. Intended for string literals. </para></description></parameter><parameter name="separator"><paramtype>char_type</paramtype><default>char_type('.')</default><description><para>The separator used in parsing. Defaults to '.'. </para></description></parameter><parameter name="tr"><paramtype>Translator</paramtype><default>Translator()</default><description><para>The translator used by this path to convert the individual parts to keys. </para></description></parameter><purpose>Create a path by parsing the given string. </purpose><description><para>
</para></description></constructor>
<constructor><parameter name="o"><paramtype>const <classname>string_path</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>string_path</classname> &amp;</type><parameter name="o"><paramtype>const <classname>string_path</classname> &amp;</paramtype></parameter></copy-assignment>
</class><struct-specialization name="path_of"><template>
      <template-type-parameter name="Ch"/>
      <template-type-parameter name="Traits"/>
      <template-type-parameter name="Alloc"/>
    </template><specialization><template-arg>std::basic_string&lt; Ch</template-arg><template-arg>Traits</template-arg><template-arg>Alloc &gt;</template-arg></specialization><typedef name="_string"><type>std::basic_string&lt; Ch, Traits, Alloc &gt;</type></typedef>
<typedef name="type"><type><classname>string_path</classname>&lt; _string, <classname>id_translator</classname>&lt; _string &gt; &gt;</type></typedef>
</struct-specialization><function name="operator/"><type><classname>string_path</classname>&lt; String, Translator &gt;</type><template>
          <template-type-parameter name="String"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="p1"><paramtype><classname>string_path</classname>&lt; String, Translator &gt;</paramtype></parameter><parameter name="p2"><paramtype>const <classname>string_path</classname>&lt; String, Translator &gt; &amp;</paramtype></parameter></function>
<function name="operator/"><type><classname>string_path</classname>&lt; String, Translator &gt;</type><template>
          <template-type-parameter name="String"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="p1"><paramtype><classname>string_path</classname>&lt; String, Translator &gt;</paramtype></parameter><parameter name="p2"><paramtype>const typename String::value_type *</paramtype></parameter></function>
<function name="operator/"><type><classname>string_path</classname>&lt; String, Translator &gt;</type><template>
          <template-type-parameter name="String"/>
          <template-type-parameter name="Translator"/>
        </template><parameter name="p1"><paramtype>const typename String::value_type *</paramtype></parameter><parameter name="p2"><paramtype>const <classname>string_path</classname>&lt; String, Translator &gt; &amp;</paramtype></parameter></function>




</namespace>
</namespace>
</header>
<header name="boost/property_tree/xml_parser.hpp">
<namespace name="boost">
<namespace name="property_tree">
<namespace name="xml_parser">
<function name="read_xml"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="stream"><paramtype>std::basic_istream&lt; typename Ptree::key_type::value_type &gt; &amp;</paramtype><description><para>Stream from which to read in the property tree. </para></description></parameter><parameter name="pt"><paramtype>Ptree &amp;</paramtype><description><para>The property tree to populate. </para></description></parameter><parameter name="flags"><paramtype>int</paramtype><default>0</default><description><para>Flags controlling the behaviour of the parser. The following flags are supported: <itemizedlist>
<listitem><para><computeroutput>no_concat_text</computeroutput> – Prevents concatenation of text nodes into datastring of property tree. Puts them in separate <computeroutput>&lt;xmltext&gt;</computeroutput> strings instead. </para></listitem>
<listitem><para><computeroutput>no_comments</computeroutput> – Skip XML comments. </para></listitem>
<listitem><para><computeroutput>trim_whitespace</computeroutput> – Trim leading and trailing whitespace from text, and collapse sequences of whitespace. </para></listitem>
</itemizedlist>
</para></description></parameter><description><para>Reads XML from an input stream and translates it to property tree. <note><para>Clears existing contents of property tree. In case of error the property tree unmodified. </para><para>XML attributes are placed under keys named <computeroutput>&lt;xmlattr&gt;</computeroutput>. </para></note>


</para></description><throws><simpara><classname>xml_parser_error</classname> In case of error deserializing the property tree. </simpara></throws></function>
<function name="read_xml"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="filename"><paramtype>const std::string &amp;</paramtype><description><para>The file from which to read in the property tree. </para></description></parameter><parameter name="pt"><paramtype>Ptree &amp;</paramtype><description><para>The property tree to populate. </para></description></parameter><parameter name="flags"><paramtype>int</paramtype><default>0</default><description><para>Flags controlling the bahviour of the parser. The following flags are supported: <itemizedlist>
<listitem><para><computeroutput>no_concat_text</computeroutput> – Prevents concatenation of text nodes into datastring of property tree. Puts them in separate <computeroutput>&lt;xmltext&gt;</computeroutput> strings instead. </para></listitem>
<listitem><para><computeroutput>no_comments</computeroutput> – Skip XML comments. </para></listitem>
</itemizedlist>
</para></description></parameter><parameter name="loc"><paramtype>const std::locale &amp;</paramtype><default>std::locale()</default><description><para>The locale to use when reading in the file contents. </para></description></parameter><description><para>Reads XML from a file using the given locale and translates it to property tree. <note><para>Clears existing contents of property tree. In case of error the property tree unmodified. </para><para>XML attributes are placed under keys named <computeroutput>&lt;xmlattr&gt;</computeroutput>. </para></note>


</para></description><throws><simpara><classname>xml_parser_error</classname> In case of error deserializing the property tree. </simpara></throws></function>
<function name="write_xml"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="stream"><paramtype>std::basic_ostream&lt; typename Ptree::key_type::value_type &gt; &amp;</paramtype><description><para>The stream to which to write the XML representation of the property tree. </para></description></parameter><parameter name="pt"><paramtype>const Ptree &amp;</paramtype><description><para>The property tree to tranlsate to XML and output. </para></description></parameter><parameter name="settings"><paramtype>const xml_writer_settings&lt; typename Ptree::key_type &gt; &amp;</paramtype><default>xml_writer_settings&lt; typename Ptree::key_type &gt;()</default><description><para>The settings to use when writing out the property tree as XML. </para></description></parameter><description><para>Translates the property tree to XML and writes it the given output stream. 

</para></description><throws><simpara><classname>xml_parser_error</classname> In case of error translating the property tree to XML or writing to the output stream. </simpara></throws></function>
<function name="write_xml"><type>void</type><template>
          <template-type-parameter name="Ptree"/>
        </template><parameter name="filename"><paramtype>const std::string &amp;</paramtype><description><para>The file to which to write the XML representation of the property tree. </para></description></parameter><parameter name="pt"><paramtype>const Ptree &amp;</paramtype><description><para>The property tree to tranlsate to XML and output. </para></description></parameter><parameter name="loc"><paramtype>const std::locale &amp;</paramtype><default>std::locale()</default><description><para>The locale to use when writing the output to file. </para></description></parameter><parameter name="settings"><paramtype>const xml_writer_settings&lt; typename Ptree::key_type &gt; &amp;</paramtype><default>xml_writer_settings&lt; typename Ptree::key_type &gt;()</default><description><para>The settings to use when writing out the property tree as XML. </para></description></parameter><description><para>Translates the property tree to XML and writes it the given file. 

</para></description><throws><simpara><classname>xml_parser_error</classname> In case of error translating the property tree to XML or writing to the output stream. </simpara></throws></function>
</namespace>







</namespace>
</namespace>
</header>
</library-reference>