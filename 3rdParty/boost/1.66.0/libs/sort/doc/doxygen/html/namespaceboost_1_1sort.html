<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Boost.Sort: boost::sort Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Sort
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1sort.html">sort</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">boost::sort Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac3a946e197df6cfc4968c6371ace319b"><td class="memTemplParams" colspan="2">template&lt;class Data_type , class Cast_type &gt; </td></tr>
<tr class="memitem:ac3a946e197df6cfc4968c6371ace319b"><td class="memTemplItemLeft" align="right" valign="top">Cast_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#ac3a946e197df6cfc4968c6371ace319b">float_mem_cast</a> (const Data_type &amp;data)</td></tr>
<tr class="memdesc:ac3a946e197df6cfc4968c6371ace319b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a float to the specified integer type.  <a href="#ac3a946e197df6cfc4968c6371ace319b">More...</a><br /></td></tr>
<tr class="separator:ac3a946e197df6cfc4968c6371ace319b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcfc139de18c5c35c0ff1744c56e211"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter &gt; </td></tr>
<tr class="memitem:acbcfc139de18c5c35c0ff1744c56e211"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#acbcfc139de18c5c35c0ff1744c56e211">float_sort</a> (RandomAccessIter first, RandomAccessIter last)</td></tr>
<tr class="memdesc:acbcfc139de18c5c35c0ff1744c56e211"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>float_sort</code> with casting to the appropriate size.  <a href="#acbcfc139de18c5c35c0ff1744c56e211">More...</a><br /></td></tr>
<tr class="separator:acbcfc139de18c5c35c0ff1744c56e211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65f9ec25686acfbd2a59683cc99be12"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter , class Right_shift &gt; </td></tr>
<tr class="memitem:ad65f9ec25686acfbd2a59683cc99be12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#ad65f9ec25686acfbd2a59683cc99be12">float_sort</a> (RandomAccessIter first, RandomAccessIter last, Right_shift rshift)</td></tr>
<tr class="memdesc:ad65f9ec25686acfbd2a59683cc99be12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating-point sort algorithm using random access iterators with just right-shift functor.  <a href="#ad65f9ec25686acfbd2a59683cc99be12">More...</a><br /></td></tr>
<tr class="separator:ad65f9ec25686acfbd2a59683cc99be12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941746cb1461c5f4971c2cf1efb9301e"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter , class Right_shift , class Compare &gt; </td></tr>
<tr class="memitem:a941746cb1461c5f4971c2cf1efb9301e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#a941746cb1461c5f4971c2cf1efb9301e">float_sort</a> (RandomAccessIter first, RandomAccessIter last, Right_shift rshift, Compare comp)</td></tr>
<tr class="memdesc:a941746cb1461c5f4971c2cf1efb9301e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float sort algorithm using random access iterators with both right-shift and user-defined comparison operator.  <a href="#a941746cb1461c5f4971c2cf1efb9301e">More...</a><br /></td></tr>
<tr class="separator:a941746cb1461c5f4971c2cf1efb9301e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ffbcf932699589fd2b93879f209013"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter &gt; </td></tr>
<tr class="memitem:ae6ffbcf932699589fd2b93879f209013"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#ae6ffbcf932699589fd2b93879f209013">integer_sort</a> (RandomAccessIter first, RandomAccessIter last)</td></tr>
<tr class="memdesc:ae6ffbcf932699589fd2b93879f209013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer sort algorithm using random access iterators. (All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>).  <a href="#ae6ffbcf932699589fd2b93879f209013">More...</a><br /></td></tr>
<tr class="separator:ae6ffbcf932699589fd2b93879f209013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ebb2541be58f9f0fecd8d7c108b817"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter , class Right_shift , class Compare &gt; </td></tr>
<tr class="memitem:aa4ebb2541be58f9f0fecd8d7c108b817"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#aa4ebb2541be58f9f0fecd8d7c108b817">integer_sort</a> (RandomAccessIter first, RandomAccessIter last, Right_shift shift, Compare comp)</td></tr>
<tr class="memdesc:aa4ebb2541be58f9f0fecd8d7c108b817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer sort algorithm using random access iterators with both right-shift and user-defined comparison operator. (All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>).  <a href="#aa4ebb2541be58f9f0fecd8d7c108b817">More...</a><br /></td></tr>
<tr class="separator:aa4ebb2541be58f9f0fecd8d7c108b817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50349854aad811f67a540d9b3aa4d4a"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter , class Right_shift &gt; </td></tr>
<tr class="memitem:ae50349854aad811f67a540d9b3aa4d4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#ae50349854aad811f67a540d9b3aa4d4a">integer_sort</a> (RandomAccessIter first, RandomAccessIter last, Right_shift shift)</td></tr>
<tr class="memdesc:ae50349854aad811f67a540d9b3aa4d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer sort algorithm using random access iterators with just right-shift functor. (All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>).  <a href="#ae50349854aad811f67a540d9b3aa4d4a">More...</a><br /></td></tr>
<tr class="separator:ae50349854aad811f67a540d9b3aa4d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc25fdacd4c948f631f08a3f9aa38eb"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter &gt; </td></tr>
<tr class="memitem:a4bc25fdacd4c948f631f08a3f9aa38eb"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c&lt; std::numeric_limits&lt; typename std::iterator_traits&lt; RandomAccessIter &gt;::value_type &gt;::is_integer, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#a4bc25fdacd4c948f631f08a3f9aa38eb">spreadsort</a> (RandomAccessIter first, RandomAccessIter last)</td></tr>
<tr class="memdesc:a4bc25fdacd4c948f631f08a3f9aa38eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic <code>spreadsort</code> variant detecting integer-type elements so call to <code>integer_sort</code>.  <a href="#a4bc25fdacd4c948f631f08a3f9aa38eb">More...</a><br /></td></tr>
<tr class="separator:a4bc25fdacd4c948f631f08a3f9aa38eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a736da091bd5d3b525818399f1b272"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter &gt; </td></tr>
<tr class="memitem:a94a736da091bd5d3b525818399f1b272"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c&lt; !std::numeric_limits&lt; typename std::iterator_traits&lt; RandomAccessIter &gt;::value_type &gt;::is_integer &amp;&amp;std::numeric_limits&lt; typename std::iterator_traits&lt; RandomAccessIter &gt;::value_type &gt;::is_iec559, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#a94a736da091bd5d3b525818399f1b272">spreadsort</a> (RandomAccessIter first, RandomAccessIter last)</td></tr>
<tr class="memdesc:a94a736da091bd5d3b525818399f1b272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic <code>spreadsort</code> variant detecting float element type so call to <code>float_sort</code>.  <a href="#a94a736da091bd5d3b525818399f1b272">More...</a><br /></td></tr>
<tr class="separator:a94a736da091bd5d3b525818399f1b272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdea66d9b4a7faef5604b3079b525fa"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter &gt; </td></tr>
<tr class="memitem:aafdea66d9b4a7faef5604b3079b525fa"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if_c&lt; is_same&lt; typename std::iterator_traits&lt; RandomAccessIter &gt;::value_type, typename std::string &gt;::value||is_same&lt; typename std::iterator_traits&lt; RandomAccessIter &gt;::value_type, typename std::wstring &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#aafdea66d9b4a7faef5604b3079b525fa">spreadsort</a> (RandomAccessIter first, RandomAccessIter last)</td></tr>
<tr class="memdesc:aafdea66d9b4a7faef5604b3079b525fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic <code>spreadsort</code> variant detecting string element type so call to <code>string_sort</code> for <code>std::strings</code> and <code>std::wstrings</code>.  <a href="#aafdea66d9b4a7faef5604b3079b525fa">More...</a><br /></td></tr>
<tr class="separator:aafdea66d9b4a7faef5604b3079b525fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950a2dbbe75f048a0b343dbf7c532dc0"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter , class Unsigned_char_type &gt; </td></tr>
<tr class="memitem:a950a2dbbe75f048a0b343dbf7c532dc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#a950a2dbbe75f048a0b343dbf7c532dc0">string_sort</a> (RandomAccessIter first, RandomAccessIter last, Unsigned_char_type unused)</td></tr>
<tr class="memdesc:a950a2dbbe75f048a0b343dbf7c532dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">String sort algorithm using random access iterators, allowing character-type overloads.<br />
 (All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>).  <a href="#a950a2dbbe75f048a0b343dbf7c532dc0">More...</a><br /></td></tr>
<tr class="separator:a950a2dbbe75f048a0b343dbf7c532dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acd5fc94521b0a5cb47dc491b6d862f"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter &gt; </td></tr>
<tr class="memitem:a6acd5fc94521b0a5cb47dc491b6d862f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#a6acd5fc94521b0a5cb47dc491b6d862f">string_sort</a> (RandomAccessIter first, RandomAccessIter last)</td></tr>
<tr class="memdesc:a6acd5fc94521b0a5cb47dc491b6d862f"><td class="mdescLeft">&#160;</td><td class="mdescRight">String sort algorithm using random access iterators, wraps using default of unsigned char. (All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>).  <a href="#a6acd5fc94521b0a5cb47dc491b6d862f">More...</a><br /></td></tr>
<tr class="separator:a6acd5fc94521b0a5cb47dc491b6d862f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad4785d90f47d51ff1d2fac8c21bb48"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter , class Compare , class Unsigned_char_type &gt; </td></tr>
<tr class="memitem:a4ad4785d90f47d51ff1d2fac8c21bb48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#a4ad4785d90f47d51ff1d2fac8c21bb48">reverse_string_sort</a> (RandomAccessIter first, RandomAccessIter last, Compare comp, Unsigned_char_type unused)</td></tr>
<tr class="memdesc:a4ad4785d90f47d51ff1d2fac8c21bb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">String sort algorithm using random access iterators, allowing character-type overloads.  <a href="#a4ad4785d90f47d51ff1d2fac8c21bb48">More...</a><br /></td></tr>
<tr class="separator:a4ad4785d90f47d51ff1d2fac8c21bb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4938835fd03aab9c42bd0653e5dbe5"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter , class Compare &gt; </td></tr>
<tr class="memitem:afd4938835fd03aab9c42bd0653e5dbe5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#afd4938835fd03aab9c42bd0653e5dbe5">reverse_string_sort</a> (RandomAccessIter first, RandomAccessIter last, Compare comp)</td></tr>
<tr class="memdesc:afd4938835fd03aab9c42bd0653e5dbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">String sort algorithm using random access iterators, wraps using default of <code>unsigned</code> char.  <a href="#afd4938835fd03aab9c42bd0653e5dbe5">More...</a><br /></td></tr>
<tr class="separator:afd4938835fd03aab9c42bd0653e5dbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5143ec4f58cfe13eca2a0d6b6f6a6680"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter , class Get_char , class Get_length &gt; </td></tr>
<tr class="memitem:a5143ec4f58cfe13eca2a0d6b6f6a6680"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#a5143ec4f58cfe13eca2a0d6b6f6a6680">string_sort</a> (RandomAccessIter first, RandomAccessIter last, Get_char getchar, Get_length length)</td></tr>
<tr class="memdesc:a5143ec4f58cfe13eca2a0d6b6f6a6680"><td class="mdescLeft">&#160;</td><td class="mdescRight">String sort algorithm using random access iterators, wraps using default of <code>unsigned</code> char.  <a href="#a5143ec4f58cfe13eca2a0d6b6f6a6680">More...</a><br /></td></tr>
<tr class="separator:a5143ec4f58cfe13eca2a0d6b6f6a6680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c4c0d7ba9873ecce7c674631dceae2"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter , class Get_char , class Get_length , class Compare &gt; </td></tr>
<tr class="memitem:a82c4c0d7ba9873ecce7c674631dceae2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#a82c4c0d7ba9873ecce7c674631dceae2">string_sort</a> (RandomAccessIter first, RandomAccessIter last, Get_char getchar, Get_length length, Compare comp)</td></tr>
<tr class="memdesc:a82c4c0d7ba9873ecce7c674631dceae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">String sort algorithm using random access iterators, wraps using default of <code>unsigned</code> char.  <a href="#a82c4c0d7ba9873ecce7c674631dceae2">More...</a><br /></td></tr>
<tr class="separator:a82c4c0d7ba9873ecce7c674631dceae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7940f1b2a7746c083a12a4e26077096b"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIter , class Get_char , class Get_length , class Compare &gt; </td></tr>
<tr class="memitem:a7940f1b2a7746c083a12a4e26077096b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1sort.html#a7940f1b2a7746c083a12a4e26077096b">reverse_string_sort</a> (RandomAccessIter first, RandomAccessIter last, Get_char getchar, Get_length length, Compare comp)</td></tr>
<tr class="memdesc:a7940f1b2a7746c083a12a4e26077096b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse String sort algorithm using random access iterators.  <a href="#a7940f1b2a7746c083a12a4e26077096b">More...</a><br /></td></tr>
<tr class="separator:a7940f1b2a7746c083a12a4e26077096b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for spreadsort sort variants for different data types. </p><dl class="section note"><dt>Note</dt><dd>Use hyperlinks (coloured) to get detailed information about functions. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac3a946e197df6cfc4968c6371ace319b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Data_type , class Cast_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Cast_type boost::sort::float_mem_cast </td>
          <td>(</td>
          <td class="paramtype">const Data_type &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts a float to the specified integer type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data_type</td><td>Floating-point IEEE 754/IEC559 type. </td></tr>
    <tr><td class="paramname">Cast_type</td><td>Integer type (same size) to which to cast.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structrightshift.html">rightshift</a> {</div>
<div class="line">  <span class="keywordtype">int</span> operator()(<span class="keyword">const</span> <a class="code" href="struct_d_a_t_a___t_y_p_e.html">DATA_TYPE</a> &amp;x, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> offset)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1sort.html#ac3a946e197df6cfc4968c6371ace319b">float_mem_cast</a>&lt;<a class="code" href="floatfunctorsample_8cpp.html#ae35c40bc2f912c11f0e36ac66cba4489">KEY_TYPE</a>, <a class="code" href="double_8cpp.html#a38779bfd63dd113c9f7602664546a58c">CAST_TYPE</a>&gt;(x.<a class="code" href="struct_d_a_t_a___t_y_p_e.html#aa28561fc8e223d84187ccfaf99953bae">key</a>) &gt;&gt; offset;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="acbcfc139de18c5c35c0ff1744c56e211"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::sort::float_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>float_sort</code> with casting to the appropriate size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data.</td></tr>
  </table>
  </dd>
</dl>
<p>Some performance plots of runtime vs. n and log(range) are provided:<br />
 <a href="../../doc/graph/windows_float_sort.htm">windows_float_sort</a> <br />
 <a href="../../doc/graph/osx_float_sort.htm">osx_float_sort</a></p>
<dl class="section user"><dt>A simple example of sorting some floating-point is:</dt><dd><div class="fragment"><div class="line">vector&lt;float&gt; vec;</div>
<div class="line">vec.push_back(1.0);</div>
<div class="line">vec.push_back(2.3);</div>
<div class="line">vec.push_back(1.3);</div>
<div class="line"><a class="code" href="namespaceboost_1_1sort.html#a4bc25fdacd4c948f631f08a3f9aa38eb">spreadsort</a>(vec.begin(), vec.end());</div>
</div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>The sorted vector contains ascending values "1.0 1.3 2.3".</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad65f9ec25686acfbd2a59683cc99be12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter , class Right_shift &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::sort::float_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Right_shift&#160;</td>
          <td class="paramname"><em>rshift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Floating-point sort algorithm using random access iterators with just right-shift functor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
    <tr><td class="paramname">Right_shift</td><td>Functor for right-shift by parameter <code>shift</code> bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rshift</td><td>Number of bits to right-shift (using functor). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a941746cb1461c5f4971c2cf1efb9301e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter , class Right_shift , class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::sort::float_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Right_shift&#160;</td>
          <td class="paramname"><em>rshift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Float sort algorithm using random access iterators with both right-shift and user-defined comparison operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
    <tr><td class="paramname">Right_shift</td><td>functor for right-shift by parameter <code>shift</code> bits. </td></tr>
    <tr><td class="paramname">Comp</td><td>To provide <code>operator&lt;</code> for user-defined comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rshift</td><td>Number of bits to right-shift (using functor). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>comparison functor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6ffbcf932699589fd2b93879f209013"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::sort::integer_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integer sort algorithm using random access iterators. (All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>). </p>
<p><code>integer_sort</code> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <code>std::sort</code> for large tests (&gt;=100kB).<br />
Worst-case performance is <em> O(N * (lg(range)/s + s)) </em>, so <code>integer_sort</code> is asymptotically faster than pure comparison-based algorithms. <code>s</code> is <code>max_splits</code>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <em> O(N * ((32/11) </em> slow radix-based iterations fast comparison-based iterations).<br />
<br />
Some performance plots of runtime vs. n and log(range) are provided:<br />
 <a href="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</a> <br />
 <a href="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>[<code>first</code>, <code>last</code>) is a valid range. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is mutable. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> supports the <code>operator&gt;&gt;</code>, which returns an integer-type right-shifted a specified number of bits. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The elements in the range [<code>first</code>, <code>last</code>) are sorted in ascending order.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </dd>
<dd>
Invalid arguments cause undefined behaviour. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>spreadsort</code> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The lesser of <em> O(N*log(N)) </em> comparisons and <em> O(N*log(K/S + S)) </em>operations worst-case, where: </dd>
<dd>
* N is <code>last</code> - <code>first</code>, </dd>
<dd>
* K is the log of the range in bits (32 for 32-bit integers using their full range), </dd>
<dd>
* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </dd></dl>

</div>
</div>
<a class="anchor" id="aa4ebb2541be58f9f0fecd8d7c108b817"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter , class Right_shift , class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::sort::integer_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Right_shift&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integer sort algorithm using random access iterators with both right-shift and user-defined comparison operator. (All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>). </p>
<p><code>integer_sort</code> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <code>std::sort</code> for large tests (&gt;=100kB).<br />
Worst-case performance is <em> O(N * (lg(range)/s + s)) </em>, so <code>integer_sort</code> is asymptotically faster than pure comparison-based algorithms. <code>s</code> is <code>max_splits</code>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <em> O(N * ((32/11) </em> slow radix-based iterations fast comparison-based iterations).<br />
<br />
Some performance plots of runtime vs. n and log(range) are provided:<br />
 <a href="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</a> <br />
 <a href="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
    <tr><td class="paramname">Right_shift</td><td>functor for right-shift by parameter <code>shift</code> bits. </td></tr>
    <tr><td class="paramname">Comp</td><td>To provide <code>operator&lt;</code> for user-defined comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>Number of bits to right-shift (using functor). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>comparison functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>[<code>first</code>, <code>last</code>) is a valid range. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is mutable. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> supports the <code>operator&gt;&gt;</code>, which returns an integer-type right-shifted a specified number of bits. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The elements in the range [<code>first</code>, <code>last</code>) are sorted in ascending order.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>void</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </dd>
<dd>
Invalid arguments cause undefined behaviour. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>spreadsort</code> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The lesser of <em> O(N*log(N)) </em> comparisons and <em> O(N*log(K/S + S)) </em>operations worst-case, where: </dd>
<dd>
* N is <code>last</code> - <code>first</code>, </dd>
<dd>
* K is the log of the range in bits (32 for 32-bit integers using their full range), </dd>
<dd>
* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </dd></dl>

</div>
</div>
<a class="anchor" id="ae50349854aad811f67a540d9b3aa4d4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter , class Right_shift &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::sort::integer_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Right_shift&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integer sort algorithm using random access iterators with just right-shift functor. (All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>). </p>
<p><code>integer_sort</code> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <code>std::sort</code> for large tests (&gt;=100kB).<br />
 </p><dl class="section user"><dt>Performance:</dt><dd>Worst-case performance is <em> O(N * (lg(range)/s + s)) </em>, so <code>integer_sort</code> is asymptotically faster than pure comparison-based algorithms. <code>s</code> is <code>max_splits</code>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <em> O(N * ((32/11) </em> slow radix-based iterations fast comparison-based iterations).<br />
<br />
Some performance plots of runtime vs. n and log(range) are provided:<br />
 <a href="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</a><br />
 <a href="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
    <tr><td class="paramname">Right_shift</td><td>functor for right-shift by parameter <code>shift</code> bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>Number of bits to right-shift (using functor).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>[<code>first</code>, <code>last</code>) is a valid range. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is mutable. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> supports the <code>operator&gt;&gt;</code>, which returns an integer-type right-shifted a specified number of bits. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The elements in the range [<code>first</code>, <code>last</code>) are sorted in ascending order.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </dd>
<dd>
Invalid arguments cause undefined behaviour. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>spreadsort</code> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The lesser of <em> O(N*log(N)) </em> comparisons and <em> O(N*log(K/S + S)) </em>operations worst-case, where: </dd>
<dd>
* N is <code>last</code> - <code>first</code>, </dd>
<dd>
* K is the log of the range in bits (32 for 32-bit integers using their full range), </dd>
<dd>
* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </dd></dl>

</div>
</div>
<a class="anchor" id="a4ad4785d90f47d51ff1d2fac8c21bb48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter , class Compare , class Unsigned_char_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::sort::reverse_string_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Unsigned_char_type&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String sort algorithm using random access iterators, allowing character-type overloads. </p>
<p>(All variants fall back to <code>std::sort</code> if the data size is too small, &lt; detail::min_sort_size).</p>
<p><code>integer_sort</code> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <code>std::sort</code> for large tests (&gt;=100kB).<br />
Worst-case performance is <em> O(N * (lg(range)/s + s)) </em>, so <code>integer_sort</code> is asymptotically faster than pure comparison-based algorithms. <code>s</code> is <code>max_splits</code>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <em> O(N * ((32/11) </em> slow radix-based iterations fast comparison-based iterations).<br />
<br />
Some performance plots of runtime vs. n and log(range) are provided:<br />
 <a href="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</a> <br />
 <a href="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
    <tr><td class="paramname">Comp</td><td>To provide <code>operator&lt;</code> for user-defined comparison. </td></tr>
    <tr><td class="paramname">Unsigned_char_type</td><td>Unsigned character type used for string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>comparison functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unused</td><td>Unused ???</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>[<code>first</code>, <code>last</code>) is a valid range. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is mutable. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> supports the <code>operator&gt;&gt;</code>, which returns an integer-type right-shifted a specified number of bits. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The elements in the range [<code>first</code>, <code>last</code>) are sorted in ascending order.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>void</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </dd>
<dd>
Invalid arguments cause undefined behaviour. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>spreadsort</code> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The lesser of <em> O(N*log(N)) </em> comparisons and <em> O(N*log(K/S + S)) </em>operations worst-case, where: </dd>
<dd>
* N is <code>last</code> - <code>first</code>, </dd>
<dd>
* K is the log of the range in bits (32 for 32-bit integers using their full range), </dd>
<dd>
* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </dd></dl>

</div>
</div>
<a class="anchor" id="afd4938835fd03aab9c42bd0653e5dbe5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter , class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::sort::reverse_string_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String sort algorithm using random access iterators, wraps using default of <code>unsigned</code> char. </p>
<p>(All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>).</p>
<p><code>integer_sort</code> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <code>std::sort</code> for large tests (&gt;=100kB).<br />
Worst-case performance is <em> O(N * (lg(range)/s + s)) </em>, so <code>integer_sort</code> is asymptotically faster than pure comparison-based algorithms. <code>s</code> is <code>max_splits</code>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <em> O(N * ((32/11) </em> slow radix-based iterations fast comparison-based iterations).<br />
<br />
Some performance plots of runtime vs. n and log(range) are provided:<br />
 <a href="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</a> <br />
 <a href="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
    <tr><td class="paramname">Comp</td><td>To provide <code>operator&lt;</code> for user-defined comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>Comparison functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>[<code>first</code>, <code>last</code>) is a valid range. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is mutable. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> supports the <code>operator&gt;&gt;</code>, which returns an integer-type right-shifted a specified number of bits. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The elements in the range [<code>first</code>, <code>last</code>) are sorted in ascending order.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>void</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </dd>
<dd>
Invalid arguments cause undefined behaviour. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>spreadsort</code> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The lesser of <em> O(N*log(N)) </em> comparisons and <em> O(N*log(K/S + S)) </em>operations worst-case, where: </dd>
<dd>
* N is <code>last</code> - <code>first</code>, </dd>
<dd>
* K is the log of the range in bits (32 for 32-bit integers using their full range), </dd>
<dd>
* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </dd></dl>

</div>
</div>
<a class="anchor" id="a7940f1b2a7746c083a12a4e26077096b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter , class Get_char , class Get_length , class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::sort::reverse_string_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Get_char&#160;</td>
          <td class="paramname"><em>getchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Get_length&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse String sort algorithm using random access iterators. </p>
<p>(All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>).</p>
<p><code>integer_sort</code> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <code>std::sort</code> for large tests (&gt;=100kB).<br />
Worst-case performance is <em> O(N * (lg(range)/s + s)) </em>, so <code>integer_sort</code> is asymptotically faster than pure comparison-based algorithms. <code>s</code> is <code>max_splits</code>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <em> O(N * ((32/11) </em> slow radix-based iterations fast comparison-based iterations).<br />
<br />
Some performance plots of runtime vs. n and log(range) are provided:<br />
 <a href="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</a> <br />
 <a href="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
    <tr><td class="paramname">Get_char</td><td>???. </td></tr>
    <tr><td class="paramname">Get_length</td><td>??? TODO </td></tr>
    <tr><td class="paramname">Comp</td><td>To provide <code>operator&lt;</code> for user-defined comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>comparison functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getchar</td><td>??? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>???</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>[<code>first</code>, <code>last</code>) is a valid range. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is mutable. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The elements in the range [<code>first</code>, <code>last</code>) are sorted in ascending order.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>void</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </dd>
<dd>
Invalid arguments cause undefined behaviour. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>spreadsort</code> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The lesser of <em> O(N*log(N)) </em> comparisons and <em> O(N*log(K/S + S)) </em>operations worst-case, where: </dd>
<dd>
* N is <code>last</code> - <code>first</code>, </dd>
<dd>
* K is the log of the range in bits (32 for 32-bit integers using their full range), </dd>
<dd>
* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </dd></dl>

</div>
</div>
<a class="anchor" id="a4bc25fdacd4c948f631f08a3f9aa38eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt; std::numeric_limits&lt; typename std::iterator_traits&lt;RandomAccessIter&gt;::value_type &gt;::is_integer, void &gt;::type boost::sort::spreadsort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic <code>spreadsort</code> variant detecting integer-type elements so call to <code>integer_sort</code>. </p>
<p>If the data type provided is an integer, <code>integer_sort</code> is used. </p><dl class="section note"><dt>Note</dt><dd>Sorting other data types requires picking between <code>integer_sort</code>, <code>float_sort</code> and <code>string_sort</code> directly, as <code>spreadsort</code> won't accept types that don't have the appropriate <code>type_traits</code>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>[<code>first</code>, <code>last</code>) is a valid range. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is mutable. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> supports the <code>operator&gt;&gt;</code>, which returns an integer-type right-shifted a specified number of bits. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The elements in the range [<code>first</code>, <code>last</code>) are sorted in ascending order. </dd></dl>

</div>
</div>
<a class="anchor" id="a94a736da091bd5d3b525818399f1b272"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt; !std::numeric_limits&lt; typename std::iterator_traits&lt;RandomAccessIter&gt;::value_type &gt;::is_integer &amp;&amp; std::numeric_limits&lt; typename std::iterator_traits&lt;RandomAccessIter&gt;::value_type &gt;::is_iec559, void &gt;::type boost::sort::spreadsort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic <code>spreadsort</code> variant detecting float element type so call to <code>float_sort</code>. </p>
<p>If the data type provided is a float or castable-float, <code>float_sort</code> is used. </p><dl class="section note"><dt>Note</dt><dd>Sorting other data types requires picking between <code>integer_sort</code>, <code>float_sort</code> and <code>string_sort</code> directly, as <code>spreadsort</code> won't accept types that don't have the appropriate <code>type_traits</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>[<code>first</code>, <code>last</code>) is a valid range. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is mutable. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> supports the <code>operator&gt;&gt;</code>, which returns an integer-type right-shifted a specified number of bits. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The elements in the range [<code>first</code>, <code>last</code>) are sorted in ascending order. </dd></dl>

</div>
</div>
<a class="anchor" id="aafdea66d9b4a7faef5604b3079b525fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if_c&lt; is_same&lt;typename std::iterator_traits&lt;RandomAccessIter&gt;::value_type, typename std::string&gt;::value || is_same&lt;typename std::iterator_traits&lt;RandomAccessIter&gt;::value_type, typename std::wstring&gt;::value, void &gt;::type boost::sort::spreadsort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic <code>spreadsort</code> variant detecting string element type so call to <code>string_sort</code> for <code>std::strings</code> and <code>std::wstrings</code>. </p>
<p>If the data type provided is a string or wstring, <code>string_sort</code> is used. </p><dl class="section note"><dt>Note</dt><dd>Sorting other data types requires picking between <code>integer_sort</code>, <code>float_sort</code> and <code>string_sort</code> directly, as <code>spreadsort</code> won't accept types that don't have the appropriate <code>type_traits</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>[<code>first</code>, <code>last</code>) is a valid range. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is mutable. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> supports the <code>operator&gt;&gt;</code>, which returns an integer-type right-shifted a specified number of bits. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The elements in the range [<code>first</code>, <code>last</code>) are sorted in ascending order. </dd></dl>

</div>
</div>
<a class="anchor" id="a950a2dbbe75f048a0b343dbf7c532dc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter , class Unsigned_char_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::sort::string_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Unsigned_char_type&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String sort algorithm using random access iterators, allowing character-type overloads.<br />
 (All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>). </p>
<p><code>string_sort</code> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <code>std::sort</code> for large tests (&gt;=100kB).<br />
</p><dl class="section user"><dt></dt><dd>Worst-case performance is <em> O(N * (lg(range)/s + s)) </em>, so <code>integer_sort</code> is asymptotically faster than pure comparison-based algorithms. <code>s</code> is <code>max_splits</code>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <em> O(N * ((32/11) </em> slow radix-based iterations fast comparison-based iterations).<br />
<br />
Some performance plots of runtime vs. n and log(range) are provided:<br />
<a href="../../doc/graph/windows_string_sort.htm">windows_string_sort</a><br />
<a href="../../doc/graph/osx_string_sort.htm">osx_string_sort</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
    <tr><td class="paramname">Unsigned_char_type</td><td>Unsigned character type used for string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unused</td><td>Unused ???</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>[<code>first</code>, <code>last</code>) is a valid range. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is mutable. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> supports the <code>operator&gt;&gt;</code>, which returns an integer-type right-shifted a specified number of bits. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The elements in the range [<code>first</code>, <code>last</code>) are sorted in ascending order.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </dd>
<dd>
Invalid arguments cause undefined behaviour. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>spreadsort</code> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The lesser of <em> O(N*log(N)) </em> comparisons and <em> O(N*log(K/S + S)) </em>operations worst-case, where: </dd>
<dd>
* N is <code>last</code> - <code>first</code>, </dd>
<dd>
* K is the log of the range in bits (32 for 32-bit integers using their full range), </dd>
<dd>
* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </dd></dl>

</div>
</div>
<a class="anchor" id="a6acd5fc94521b0a5cb47dc491b6d862f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::sort::string_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String sort algorithm using random access iterators, wraps using default of unsigned char. (All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>). </p>
<p><code>string_sort</code> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <code>std::sort</code> for large tests (&gt;=100kB).<br />
Worst-case performance is <em> O(N * (lg(range)/s + s)) </em>, so <code>integer_sort</code> is asymptotically faster than pure comparison-based algorithms. <code>s</code> is <code>max_splits</code>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <em> O(N * ((32/11) </em> slow radix-based iterations fast comparison-based iterations).<br />
<br />
Some performance plots of runtime vs. n and log(range) are provided:<br />
 <a href="../../doc/graph/windows_string_sort.htm">windows_string_sort</a> <br />
 <a href="../../doc/graph/osx_string_sort.htm">osx_string_sort</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>[<code>first</code>, <code>last</code>) is a valid range. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is mutable. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> supports the <code>operator&gt;&gt;</code>, which returns an integer-type right-shifted a specified number of bits. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The elements in the range [<code>first</code>, <code>last</code>) are sorted in ascending order.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </dd>
<dd>
Invalid arguments cause undefined behaviour. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>spreadsort</code> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The lesser of <em> O(N*log(N)) </em> comparisons and <em> O(N*log(K/S + S)) </em>operations worst-case, where: </dd>
<dd>
* N is <code>last</code> - <code>first</code>, </dd>
<dd>
* K is the log of the range in bits (32 for 32-bit integers using their full range), </dd>
<dd>
* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </dd></dl>

</div>
</div>
<a class="anchor" id="a5143ec4f58cfe13eca2a0d6b6f6a6680"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter , class Get_char , class Get_length &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::sort::string_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Get_char&#160;</td>
          <td class="paramname"><em>getchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Get_length&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String sort algorithm using random access iterators, wraps using default of <code>unsigned</code> char. </p>
<p>(All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>).</p>
<p><code>integer_sort</code> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <code>std::sort</code> for large tests (&gt;=100kB).<br />
Worst-case performance is <em> O(N * (lg(range)/s + s)) </em>, so <code>integer_sort</code> is asymptotically faster than pure comparison-based algorithms. <code>s</code> is <code>max_splits</code>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <em> O(N * ((32/11) </em> slow radix-based iterations fast comparison-based iterations).<br />
<br />
Some performance plots of runtime vs. n and log(range) are provided:<br />
 <a href="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</a> <br />
 <a href="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
    <tr><td class="paramname">Get_char</td><td>Bracket functor equivalent to <code>operator</code>[], taking a number corresponding to the character offset.. </td></tr>
    <tr><td class="paramname">Get_length</td><td>Functor to get the length of the string in characters. TODO Check this and below and other places!!!</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getchar</td><td>Number corresponding to the character offset from bracket functor equivalent to <code>operator</code>[]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Functor to get the length of the string in characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>[<code>first</code>, <code>last</code>) is a valid range. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is mutable. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> supports the <code>operator&gt;&gt;</code>, which returns an integer-type right-shifted a specified number of bits. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The elements in the range [<code>first</code>, <code>last</code>) are sorted in ascending order.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>void</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </dd>
<dd>
Invalid arguments cause undefined behaviour. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>spreadsort</code> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The lesser of <em> O(N*log(N)) </em> comparisons and <em> O(N*log(K/S + S)) </em>operations worst-case, where: </dd>
<dd>
* N is <code>last</code> - <code>first</code>, </dd>
<dd>
* K is the log of the range in bits (32 for 32-bit integers using their full range), </dd>
<dd>
* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </dd></dl>

</div>
</div>
<a class="anchor" id="a82c4c0d7ba9873ecce7c674631dceae2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIter , class Get_char , class Get_length , class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::sort::string_sort </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIter&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Get_char&#160;</td>
          <td class="paramname"><em>getchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Get_length&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String sort algorithm using random access iterators, wraps using default of <code>unsigned</code> char. </p>
<p>(All variants fall back to <code>std::sort</code> if the data size is too small, &lt; <code>detail::min_sort_size</code>).</p>
<p><code>integer_sort</code> is a fast templated in-place hybrid radix/comparison algorithm, which in testing tends to be roughly 50% to 2X faster than <code>std::sort</code> for large tests (&gt;=100kB).<br />
Worst-case performance is <em> O(N * (lg(range)/s + s)) </em>, so <code>integer_sort</code> is asymptotically faster than pure comparison-based algorithms. <code>s</code> is <code>max_splits</code>, which defaults to 11, so its worst-case with default settings for 32-bit integers is <em> O(N * ((32/11) </em> slow radix-based iterations fast comparison-based iterations).<br />
<br />
Some performance plots of runtime vs. n and log(range) are provided:<br />
 <a href="../../doc/graph/windows_integer_sort.htm">windows_integer_sort</a> <br />
 <a href="../../doc/graph/osx_integer_sort.htm">osx_integer_sort</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIter</td><td><a href="http://www.cplusplus.com/reference/iterator/RandomAccessIterator/">Random access iterator</a> </td></tr>
    <tr><td class="paramname">Get_char</td><td>???. </td></tr>
    <tr><td class="paramname">Get_length</td><td>??? TODO </td></tr>
    <tr><td class="paramname">Comp</td><td>To provide <code>operator&lt;</code> for user-defined comparison.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator pointer to first element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator pointing to one beyond the end of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp</td><td>comparison functor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getchar</td><td>??? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>???</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>[<code>first</code>, <code>last</code>) is a valid range. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is mutable. </dd>
<dd>
<code>RandomAccessIter</code> <code>value_type</code> is <a href="http://en.cppreference.com/w/cpp/concept/LessThanComparable">LessThanComparable</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The elements in the range [<code>first</code>, <code>last</code>) are sorted in ascending order.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>void</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>Propagates exceptions if any of the element comparisons, the element swaps (or moves), the right shift, subtraction of right-shifted elements, functors, or any operations on iterators throw.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Throwing an exception may cause data loss. This will also throw if a small vector resize throws, in which case there will be no data loss. </dd>
<dd>
Invalid arguments cause undefined behaviour. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>spreadsort</code> function provides a wrapper that calls the fastest sorting algorithm available for a data type, enabling faster generic-programming.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The lesser of <em> O(N*log(N)) </em> comparisons and <em> O(N*log(K/S + S)) </em>operations worst-case, where: </dd>
<dd>
* N is <code>last</code> - <code>first</code>, </dd>
<dd>
* K is the log of the range in bits (32 for 32-bit integers using their full range), </dd>
<dd>
* S is a constant called max_splits, defaulting to 11 (except for strings where it is the log of the character size). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 9 2015 14:20:24 for Boost.Sort by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
