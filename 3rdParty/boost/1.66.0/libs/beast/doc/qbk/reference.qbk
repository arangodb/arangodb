[/
    Copyright (c) 2013-2016 Vinnie Falco (vinnie dot falco at gmail dot com)

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

[section:boost__beast__basic_flat_buffer basic_flat_buffer]
A linear dynamic buffer. 
[heading Synopsis]Defined in header [include_file boost/beast/core/flat_buffer.hpp]```template<    class Allocator>class basic_flat_buffer```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_flat_buffer.allocator_type [*allocator_type]]]    [      The type of allocator used.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.const_buffers_type [*const_buffers_type]]]    [      The type used to represent the input sequence as a list of buffers.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.mutable_buffers_type [*mutable_buffers_type]]]    [      The type used to represent the output sequence as a list of buffers.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer [*basic_flat_buffer]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.capacity [*capacity]]]    [      Return the maximum sum of input and output sizes that can be held without an allocation.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.commit [*commit]]]    [      Move bytes from the output sequence to the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.consume [*consume]]]    [      Remove bytes from the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.data [*data]]]    [      Get a list of buffers that represent the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.get_allocator [*get_allocator]]]    [      Returns a copy of the associated allocator.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.max_size [*max_size]]]    [      Return the maximum sum of the input and output sequence sizes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.operator_eq_ [*operator=]]]    [      Assignment.       Copy assignment.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.prepare [*prepare]]]    [      Get a list of buffers that represent the output sequence, with the given size.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.shrink_to_fit [*shrink_to_fit]]]    [      Reallocate the buffer to fit the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.size [*size]]]    [      Returns the size of the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer_dtor_ [*~basic_flat_buffer]]]    [      Destructor.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_flat_buffer.swap [*swap]]]    [      Exchange two flat buffers.     ]  ]][heading Description]
Objects of this type meet the requirements of [*DynamicBuffer] and offer additional invariants:


* Buffer sequences returned by [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] and [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] will always be of length one.


* A configurable maximum buffer size may be set upon construction. Attempts to exceed the buffer size will throw `std::length_error`.

Upon construction, a maximum size for the buffer may be specified. If this limit is exceeded, the `std::length_error` exception will be thrown.

[heading Remarks]
This class is designed for use with algorithms that take dynamic buffers as parameters, and are optimized for the case where the input sequence or output sequence is stored in a single contiguous buffer. 


[section:allocator_type basic_flat_buffer::allocator_type][indexterm2 allocator_type..basic_flat_buffer]
The type of allocator used. 
[heading Synopsis]```using allocator_type = Allocator;```[heading Description][endsect][section:basic_flat_buffer basic_flat_buffer::basic_flat_buffer][indexterm2 basic_flat_buffer..basic_flat_buffer]
Constructor. 
`````[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload1 basic_flat_buffer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload1 more...]]``explicit``[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload2 basic_flat_buffer]``(    std::size_t limit);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload2 more...]]``explicit``[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload3 basic_flat_buffer]``(    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload3 more...]]````[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload4 basic_flat_buffer]``(    std::size_t limit,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload4 more...]]````[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload5 basic_flat_buffer]``(    basic_flat_buffer&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload5 more...]]````[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload6 basic_flat_buffer]``(    basic_flat_buffer&& other,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload6 more...]]````[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload7 basic_flat_buffer]``(    basic_flat_buffer const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload7 more...]]````[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload8 basic_flat_buffer]``(    basic_flat_buffer const& other,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload8 more...]]``template<    class OtherAlloc>``[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload9 basic_flat_buffer]``(    basic_flat_buffer< OtherAlloc > const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload9 more...]]``template<    class OtherAlloc>``[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload10 basic_flat_buffer]``(    basic_flat_buffer< OtherAlloc > const& other,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer.overload10 more...]]`````[section:overload1 basic_flat_buffer::basic_flat_buffer (1 of 10 overloads)]
Constructor. 
[heading Synopsis]```basic_flat_buffer();```[heading Description]
Upon construction, capacity will be zero. 
[endsect][section:overload2 basic_flat_buffer::basic_flat_buffer (2 of 10 overloads)]
Constructor. 
[heading Synopsis]```basic_flat_buffer(    std::size_t limit);```[heading Description]
Upon construction, capacity will be zero.

[heading Parameters][table [[Name][Description]]  [[`limit`][    The setting for [link beast.ref.boost__beast__basic_flat_buffer.max_size `max_size`].   ]]]

[endsect][section:overload3 basic_flat_buffer::basic_flat_buffer (3 of 10 overloads)]
Constructor. 
[heading Synopsis]```basic_flat_buffer(    Allocator const& alloc);```[heading Description]
Upon construction, capacity will be zero.

[heading Parameters][table [[Name][Description]]  [[`alloc`][    The allocator to construct with.   ]]]

[endsect][section:overload4 basic_flat_buffer::basic_flat_buffer (4 of 10 overloads)]
Constructor. 
[heading Synopsis]```basic_flat_buffer(    std::size_t limit,    Allocator const& alloc);```[heading Description]
Upon construction, capacity will be zero.

[heading Parameters][table [[Name][Description]]  [[`limit`][    The setting for [link beast.ref.boost__beast__basic_flat_buffer.max_size `max_size`].  ]]  [[`alloc`][    The allocator to use.   ]]]

[endsect][section:overload5 basic_flat_buffer::basic_flat_buffer (5 of 10 overloads)]
Constructor. 
[heading Synopsis]```basic_flat_buffer(    basic_flat_buffer&& other);```[heading Description]
After the move, `*this` will have an empty output sequence.

[heading Parameters][table [[Name][Description]]  [[`other`][    The object to move from. After the move, The object's state will be as if constructed using its current allocator and limit.   ]]]

[endsect][section:overload6 basic_flat_buffer::basic_flat_buffer (6 of 10 overloads)]
Constructor. 
[heading Synopsis]```basic_flat_buffer(    basic_flat_buffer&& other,    Allocator const& alloc);```[heading Description]
After the move, `*this` will have an empty output sequence.

[heading Parameters][table [[Name][Description]]  [[`other`][    The object to move from. After the move, The object's state will be as if constructed using its current allocator and limit.  ]]  [[`alloc`][    The allocator to use.   ]]]

[endsect][section:overload7 basic_flat_buffer::basic_flat_buffer (7 of 10 overloads)]
Constructor. 
[heading Synopsis]```basic_flat_buffer(    basic_flat_buffer const& other);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`other`][    The object to copy from.   ]]]

[endsect][section:overload8 basic_flat_buffer::basic_flat_buffer (8 of 10 overloads)]
Constructor. 
[heading Synopsis]```basic_flat_buffer(    basic_flat_buffer const& other,    Allocator const& alloc);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`other`][    The object to copy from.  ]]  [[`alloc`][    The allocator to use.   ]]]

[endsect][section:overload9 basic_flat_buffer::basic_flat_buffer (9 of 10 overloads)]
Constructor. 
[heading Synopsis]```template<    class OtherAlloc>basic_flat_buffer(    basic_flat_buffer< OtherAlloc > const& other);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`other`][    The object to copy from.   ]]]

[endsect][section:overload10 basic_flat_buffer::basic_flat_buffer (10 of 10 overloads)]
Constructor. 
[heading Synopsis]```template<    class OtherAlloc>basic_flat_buffer(    basic_flat_buffer< OtherAlloc > const& other,    Allocator const& alloc);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`other`][    The object to copy from.  ]]  [[`alloc`][    The allocator to use.   ]]]

[endsect][endsect][section:capacity basic_flat_buffer::capacity][indexterm2 capacity..basic_flat_buffer]
Return the maximum sum of input and output sizes that can be held without an allocation. 
[heading Synopsis]```std::size_tcapacity() const;```[heading Description][endsect][section:commit basic_flat_buffer::commit][indexterm2 commit..basic_flat_buffer]
Move bytes from the output sequence to the input sequence. 
[heading Synopsis]```voidcommit(    std::size_t n);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`n`][    The number of bytes to move. If this is larger than the number of bytes in the output sequences, then the entire output sequences is moved.  ]]]
[heading Remarks]
All previous buffers sequences obtained from calls to [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] or [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] are invalidated. 


[endsect][section:const_buffers_type basic_flat_buffer::const_buffers_type][indexterm2 const_buffers_type..basic_flat_buffer]
The type used to represent the input sequence as a list of buffers. 
[heading Synopsis]```using const_buffers_type = boost::asio::mutable_buffer;```[heading Description][endsect][section:consume basic_flat_buffer::consume][indexterm2 consume..basic_flat_buffer]
Remove bytes from the input sequence. 
[heading Synopsis]```voidconsume(    std::size_t n);```[heading Description]
If `n` is greater than the number of bytes in the input sequence, all bytes in the input sequence are removed.

[heading Remarks]
All previous buffers sequences obtained from calls to [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] or [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] are invalidated. 


[endsect][section:data basic_flat_buffer::data][indexterm2 data..basic_flat_buffer]
Get a list of buffers that represent the input sequence. 
[heading Synopsis]```const_buffers_typedata() const;```[heading Description][endsect][section:get_allocator basic_flat_buffer::get_allocator][indexterm2 get_allocator..basic_flat_buffer]
Returns a copy of the associated allocator. 
[heading Synopsis]```allocator_typeget_allocator() const;```[heading Description][endsect][section:max_size basic_flat_buffer::max_size][indexterm2 max_size..basic_flat_buffer]
Return the maximum sum of the input and output sequence sizes. 
[heading Synopsis]```std::size_tmax_size() const;```[heading Description][endsect][section:mutable_buffers_type basic_flat_buffer::mutable_buffers_type][indexterm2 mutable_buffers_type..basic_flat_buffer]
The type used to represent the output sequence as a list of buffers. 
[heading Synopsis]```using mutable_buffers_type = boost::asio::mutable_buffer;```[heading Description][endsect][section:operator_eq_ basic_flat_buffer::operator=][indexterm2 operator=..basic_flat_buffer]
Assignment. 
```basic_flat_buffer&``[link beast.ref.boost__beast__basic_flat_buffer.operator_eq_.overload1 operator=]``(    basic_flat_buffer&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.operator_eq_.overload1 more...]]``basic_flat_buffer&``[link beast.ref.boost__beast__basic_flat_buffer.operator_eq_.overload2 operator=]``(    basic_flat_buffer const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.operator_eq_.overload2 more...]]`````
Copy assignment. 
```template<    class OtherAlloc>basic_flat_buffer&``[link beast.ref.boost__beast__basic_flat_buffer.operator_eq_.overload3 operator=]``(    basic_flat_buffer< OtherAlloc > const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_flat_buffer.operator_eq_.overload3 more...]]`````[section:overload1 basic_flat_buffer::operator= (1 of 3 overloads)]
Assignment. 
[heading Synopsis]```basic_flat_buffer&operator=(    basic_flat_buffer&& other);```[heading Description]
After the move, `*this` will have an empty output sequence.

[heading Parameters][table [[Name][Description]]  [[`other`][    The object to move from. After the move, the object's state will be as if constructed using its current allocator and limit.   ]]]

[endsect][section:overload2 basic_flat_buffer::operator= (2 of 3 overloads)]
Assignment. 
[heading Synopsis]```basic_flat_buffer&operator=(    basic_flat_buffer const& other);```[heading Description]
After the copy, `*this` will have an empty output sequence.

[heading Parameters][table [[Name][Description]]  [[`other`][    The object to copy from.   ]]]

[endsect][section:overload3 basic_flat_buffer::operator= (3 of 3 overloads)]
Copy assignment. 
[heading Synopsis]```template<    class OtherAlloc>basic_flat_buffer&operator=(    basic_flat_buffer< OtherAlloc > const& other);```[heading Description]
After the copy, `*this` will have an empty output sequence.

[heading Parameters][table [[Name][Description]]  [[`other`][    The object to copy from.   ]]]

[endsect][endsect][section:prepare basic_flat_buffer::prepare][indexterm2 prepare..basic_flat_buffer]
Get a list of buffers that represent the output sequence, with the given size. 
[heading Synopsis]```mutable_buffers_typeprepare(    std::size_t n);```[heading Description]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    if `size() + n` exceeds `max_size()`.  ]]]
[heading Remarks]
All previous buffers sequences obtained from calls to [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] or [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] are invalidated. 


[endsect][section:shrink_to_fit basic_flat_buffer::shrink_to_fit][indexterm2 shrink_to_fit..basic_flat_buffer]
Reallocate the buffer to fit the input sequence. 
[heading Synopsis]```voidshrink_to_fit();```[heading Description]
[heading Remarks]
All previous buffers sequences obtained from calls to [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] or [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] are invalidated. 


[endsect][section:size basic_flat_buffer::size][indexterm2 size..basic_flat_buffer]
Returns the size of the input sequence. 
[heading Synopsis]```std::size_tsize() const;```[heading Description][endsect][section:swap basic_flat_buffer::swap][indexterm2 swap..basic_flat_buffer]
Exchange two flat buffers. 
[heading Synopsis]Defined in header [include_file boost/beast/core/flat_buffer.hpp]```template<    class Alloc>friend voidswap(    basic_flat_buffer< Alloc >& lhs,    basic_flat_buffer< Alloc >& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:basic_flat_buffer_dtor_ basic_flat_buffer::~basic_flat_buffer][indexterm2 ~basic_flat_buffer..basic_flat_buffer]
Destructor. 
[heading Synopsis]```~basic_flat_buffer();```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__basic_multi_buffer basic_multi_buffer]
A [*DynamicBuffer] that uses multiple buffers internally. 
[heading Synopsis]Defined in header [include_file boost/beast/core/multi_buffer.hpp]```template<    class Allocator>class basic_multi_buffer```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_multi_buffer.allocator_type [*allocator_type]]]    [      The type of allocator used.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.const_buffers_type [*const_buffers_type]]]    [      The type used to represent the input sequence as a list of buffers.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.mutable_buffers_type [*mutable_buffers_type]]]    [      The type used to represent the output sequence as a list of buffers.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer [*basic_multi_buffer]]]    [      Constructor.       Move constructor.       Copy constructor.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.capacity [*capacity]]]    [      Returns the maximum sum of the sizes of the input sequence and output sequence the buffer can hold without requiring reallocation.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.commit [*commit]]]    [      Move bytes from the output sequence to the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.consume [*consume]]]    [      Remove bytes from the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.data [*data]]]    [      Get a list of buffers that represents the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.get_allocator [*get_allocator]]]    [      Returns a copy of the associated allocator.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.max_size [*max_size]]]    [      Returns the permitted maximum sum of the sizes of the input and output sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.operator_eq_ [*operator=]]]    [      Move assignment.       Copy assignment.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.prepare [*prepare]]]    [      Get a list of buffers that represents the output sequence, with the given size.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.size [*size]]]    [      Returns the size of the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer_dtor_ [*~basic_multi_buffer]]]    [      Destructor.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_multi_buffer.swap [*swap]]]    [          ]  ]][heading Description]
The implementation uses a sequence of one or more character arrays of varying sizes. Additional character array objects are appended to the sequence to accommodate changes in the size of the character sequence.

[heading Remarks]
Meets the requirements of [*DynamicBuffer].

[heading Template Parameters][table [[Type][Description]]  [[`Allocator`][    The allocator to use for managing memory.   ]]]

[section:allocator_type basic_multi_buffer::allocator_type][indexterm2 allocator_type..basic_multi_buffer]
The type of allocator used. 
[heading Synopsis]```using allocator_type = Allocator;```[heading Description][endsect][section:basic_multi_buffer basic_multi_buffer::basic_multi_buffer][indexterm2 basic_multi_buffer..basic_multi_buffer]
Constructor. 
`````[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload1 basic_multi_buffer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload1 more...]]``explicit``[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload2 basic_multi_buffer]``(    std::size_t limit);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload2 more...]]``explicit``[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload3 basic_multi_buffer]``(    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload3 more...]]````[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload4 basic_multi_buffer]``(    std::size_t limit,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload4 more...]]`````
Move constructor. 
`````[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload5 basic_multi_buffer]``(    basic_multi_buffer&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload5 more...]]````[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload6 basic_multi_buffer]``(    basic_multi_buffer&& other,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload6 more...]]`````
Copy constructor. 
`````[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload7 basic_multi_buffer]``(    basic_multi_buffer const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload7 more...]]````[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload8 basic_multi_buffer]``(    basic_multi_buffer const& other,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload8 more...]]``template<    class OtherAlloc>``[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload9 basic_multi_buffer]``(    basic_multi_buffer< OtherAlloc > const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload9 more...]]``template<    class OtherAlloc>``[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload10 basic_multi_buffer]``(    basic_multi_buffer< OtherAlloc > const& other,    allocator_type const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer.overload10 more...]]`````[section:overload1 basic_multi_buffer::basic_multi_buffer (1 of 10 overloads)]
Constructor. 
[heading Synopsis]```basic_multi_buffer();```[heading Description]
Upon construction, capacity will be zero. 
[endsect][section:overload2 basic_multi_buffer::basic_multi_buffer (2 of 10 overloads)]
Constructor. 
[heading Synopsis]```basic_multi_buffer(    std::size_t limit);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`limit`][    The setting for [link beast.ref.boost__beast__basic_multi_buffer.max_size `max_size`].   ]]]

[endsect][section:overload3 basic_multi_buffer::basic_multi_buffer (3 of 10 overloads)]
Constructor. 
[heading Synopsis]```basic_multi_buffer(    Allocator const& alloc);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`alloc`][    The allocator to use.   ]]]

[endsect][section:overload4 basic_multi_buffer::basic_multi_buffer (4 of 10 overloads)]
Constructor. 
[heading Synopsis]```basic_multi_buffer(    std::size_t limit,    Allocator const& alloc);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`limit`][    The setting for [link beast.ref.boost__beast__basic_multi_buffer.max_size `max_size`].  ]]  [[`alloc`][    The allocator to use.   ]]]

[endsect][section:overload5 basic_multi_buffer::basic_multi_buffer (5 of 10 overloads)]
Move constructor. 
[heading Synopsis]```basic_multi_buffer(    basic_multi_buffer&& other);```[heading Description]
After the move, `*this` will have an empty output sequence.

[heading Parameters][table [[Name][Description]]  [[`other`][    The object to move from. After the move, The object's state will be as if constructed using its current allocator and limit.   ]]]

[endsect][section:overload6 basic_multi_buffer::basic_multi_buffer (6 of 10 overloads)]
Move constructor. 
[heading Synopsis]```basic_multi_buffer(    basic_multi_buffer&& other,    Allocator const& alloc);```[heading Description]
After the move, `*this` will have an empty output sequence.

[heading Parameters][table [[Name][Description]]  [[`other`][    The object to move from. After the move, The object's state will be as if constructed using its current allocator and limit.  ]]  [[`alloc`][    The allocator to use.   ]]]

[endsect][section:overload7 basic_multi_buffer::basic_multi_buffer (7 of 10 overloads)]
Copy constructor. 
[heading Synopsis]```basic_multi_buffer(    basic_multi_buffer const& other);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`other`][    The object to copy from.   ]]]

[endsect][section:overload8 basic_multi_buffer::basic_multi_buffer (8 of 10 overloads)]
Copy constructor. 
[heading Synopsis]```basic_multi_buffer(    basic_multi_buffer const& other,    Allocator const& alloc);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`other`][    The object to copy from.  ]]  [[`alloc`][    The allocator to use.   ]]]

[endsect][section:overload9 basic_multi_buffer::basic_multi_buffer (9 of 10 overloads)]
Copy constructor. 
[heading Synopsis]```template<    class OtherAlloc>basic_multi_buffer(    basic_multi_buffer< OtherAlloc > const& other);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`other`][    The object to copy from.   ]]]

[endsect][section:overload10 basic_multi_buffer::basic_multi_buffer (10 of 10 overloads)]
Copy constructor. 
[heading Synopsis]```template<    class OtherAlloc>basic_multi_buffer(    basic_multi_buffer< OtherAlloc > const& other,    allocator_type const& alloc);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`other`][    The object to copy from.  ]]  [[`alloc`][    The allocator to use.   ]]]

[endsect][endsect][section:capacity basic_multi_buffer::capacity][indexterm2 capacity..basic_multi_buffer]
Returns the maximum sum of the sizes of the input sequence and output sequence the buffer can hold without requiring reallocation. 
[heading Synopsis]```std::size_tcapacity() const;```[heading Description][endsect][section:commit basic_multi_buffer::commit][indexterm2 commit..basic_multi_buffer]
Move bytes from the output sequence to the input sequence. 
[heading Synopsis]```voidcommit(    size_type n);```[heading Description]
[heading Remarks]
Buffers representing the input sequence acquired prior to this call remain valid. 


[endsect][section:const_buffers_type basic_multi_buffer::const_buffers_type][indexterm2 const_buffers_type..basic_multi_buffer]
The type used to represent the input sequence as a list of buffers. 
[heading Synopsis]```using const_buffers_type = ``['implementation-defined]``;```[heading Description][endsect][section:consume basic_multi_buffer::consume][indexterm2 consume..basic_multi_buffer]
Remove bytes from the input sequence. 
[heading Synopsis]```voidconsume(    size_type n);```[heading Description][endsect][section:data basic_multi_buffer::data][indexterm2 data..basic_multi_buffer]
Get a list of buffers that represents the input sequence. 
[heading Synopsis]```const_buffers_typedata() const;```[heading Description]
[heading Remarks]
These buffers remain valid across subsequent calls to `prepare`. 


[endsect][section:get_allocator basic_multi_buffer::get_allocator][indexterm2 get_allocator..basic_multi_buffer]
Returns a copy of the associated allocator. 
[heading Synopsis]```allocator_typeget_allocator() const;```[heading Description][endsect][section:max_size basic_multi_buffer::max_size][indexterm2 max_size..basic_multi_buffer]
Returns the permitted maximum sum of the sizes of the input and output sequence. 
[heading Synopsis]```size_typemax_size() const;```[heading Description][endsect][section:mutable_buffers_type basic_multi_buffer::mutable_buffers_type][indexterm2 mutable_buffers_type..basic_multi_buffer]
The type used to represent the output sequence as a list of buffers. 
[heading Synopsis]```using mutable_buffers_type = ``['implementation-defined]``;```[heading Description][endsect][section:operator_eq_ basic_multi_buffer::operator=][indexterm2 operator=..basic_multi_buffer]
Move assignment. 
```basic_multi_buffer&``[link beast.ref.boost__beast__basic_multi_buffer.operator_eq_.overload1 operator=]``(    basic_multi_buffer&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.operator_eq_.overload1 more...]]`````
Copy assignment. 
```basic_multi_buffer&``[link beast.ref.boost__beast__basic_multi_buffer.operator_eq_.overload2 operator=]``(    basic_multi_buffer const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.operator_eq_.overload2 more...]]``template<    class OtherAlloc>basic_multi_buffer&``[link beast.ref.boost__beast__basic_multi_buffer.operator_eq_.overload3 operator=]``(    basic_multi_buffer< OtherAlloc > const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__basic_multi_buffer.operator_eq_.overload3 more...]]`````[section:overload1 basic_multi_buffer::operator= (1 of 3 overloads)]
Move assignment. 
[heading Synopsis]```basic_multi_buffer&operator=(    basic_multi_buffer&& other);```[heading Description]
After the move, `*this` will have an empty output sequence.

[heading Parameters][table [[Name][Description]]  [[`other`][    The object to move from. After the move, The object's state will be as if constructed using its current allocator and limit.   ]]]

[endsect][section:overload2 basic_multi_buffer::operator= (2 of 3 overloads)]
Copy assignment. 
[heading Synopsis]```basic_multi_buffer&operator=(    basic_multi_buffer const& other);```[heading Description]
After the copy, `*this` will have an empty output sequence.

[heading Parameters][table [[Name][Description]]  [[`other`][    The object to copy from.   ]]]

[endsect][section:overload3 basic_multi_buffer::operator= (3 of 3 overloads)]
Copy assignment. 
[heading Synopsis]```template<    class OtherAlloc>basic_multi_buffer&operator=(    basic_multi_buffer< OtherAlloc > const& other);```[heading Description]
After the copy, `*this` will have an empty output sequence.

[heading Parameters][table [[Name][Description]]  [[`other`][    The object to copy from.   ]]]

[endsect][endsect][section:prepare basic_multi_buffer::prepare][indexterm2 prepare..basic_multi_buffer]
Get a list of buffers that represents the output sequence, with the given size. 
[heading Synopsis]```mutable_buffers_typeprepare(    size_type n);```[heading Description]
[heading Remarks]
Buffers representing the input sequence acquired prior to this call remain valid. 


[endsect][section:size basic_multi_buffer::size][indexterm2 size..basic_multi_buffer]
Returns the size of the input sequence. 
[heading Synopsis]```size_typesize() const;```[heading Description][endsect][section:swap basic_multi_buffer::swap][indexterm2 swap..basic_multi_buffer][heading Synopsis]Defined in header [include_file boost/beast/core/multi_buffer.hpp]```template<    class Alloc>friend voidswap(    basic_multi_buffer< Alloc >& lhs,    basic_multi_buffer< Alloc >& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:basic_multi_buffer_dtor_ basic_multi_buffer::~basic_multi_buffer][indexterm2 ~basic_multi_buffer..basic_multi_buffer]
Destructor. 
[heading Synopsis]```~basic_multi_buffer();```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__basic_string_view basic_string_view][indexterm1 basic_string_view]
The type of basic string view used by the library. 
[heading Synopsis]Defined in header [include_file boost/beast/core/string.hpp]```using basic_string_view = boost::basic_string_view< CharT, Traits >;```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__bind_handler bind_handler][indexterm1 bind_handler]
Bind parameters to a completion handler, creating a new handler. 
[heading Synopsis]Defined in header [include_file boost/beast/core/bind_handler.hpp]```template<    class __Handler__,    class... Args>``['implementation-defined]``bind_handler(    Handler&& handler,    Args&&... args);```[heading Description]
This function creates a new handler which, when invoked, calls the original handler with the list of bound arguments. Any parameters passed in the invocation will be subtituted for placeholders present in the list of bound arguments. Parameters which are not matched to placeholders are silently discarded. The passed handler and arguments are forwarded into the returned handler, which provides the same `io_context` execution guarantees as the original handler.

Unlike `boost::asio::io_context::wrap`, the returned handler can be used in a subsequent call to `boost::asio::io_context::post` instead of `boost::asio::io_context::dispatch`, to ensure that the handler will not be invoked immediately by the calling function.

Example:



  template<class AsyncReadStream, class ReadHandler>
  void
  signal_aborted(AsyncReadStream& stream, ReadHandler&& handler)
  {
      boost::asio::post(
          stream.get_executor(),
          bind_handler(std::forward<ReadHandler>(handler),
              boost::asio::error::operation_aborted, 0));
  }




[heading Parameters][table [[Name][Description]]  [[`handler`][    The handler to wrap.  ]]  [[`args`][    A list of arguments to bind to the handler. The arguments are forwarded into the returned object.   ]]]

Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffered_read_stream buffered_read_stream]
A [*Stream] with attached [*DynamicBuffer] to buffer reads. 
[heading Synopsis]Defined in header [include_file boost/beast/core/buffered_read_stream.hpp]```template<    class ``[link beast.concepts.streams.Stream [*Stream]]``,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>class buffered_read_stream```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffered_read_stream.buffer_type [*buffer_type]]]    [      The type of the internal buffer.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.lowest_layer_type [*lowest_layer_type]]]    [      The type of the lowest layer.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.next_layer_type [*next_layer_type]]]    [      The type of the next layer.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffered_read_stream.async_read_some [*async_read_some]]]    [      Start an asynchronous read.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.async_write_some [*async_write_some]]]    [      Start an asynchronous write.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.buffer [*buffer]]]    [      Access the internal buffer.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.buffered_read_stream [*buffered_read_stream]]]    [      Move constructor.       Construct the wrapping stream.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.capacity [*capacity]]]    [      Set the maximum buffer size.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.get_executor [*get_executor]]]    [      Get the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.lowest_layer [*lowest_layer]]]    [      Get a reference to the lowest layer.       Get a const reference to the lowest layer.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.next_layer [*next_layer]]]    [      Get a reference to the next layer.       Get a const reference to the next layer.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.operator_eq_ [*operator=]]]    [      Move assignment.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.read_some [*read_some]]]    [      Read some data from the stream.     ]  ]  [    [[link beast.ref.boost__beast__buffered_read_stream.write_some [*write_some]]]    [      Write some data to the stream.     ]  ]][heading Description]
This wraps a [*Stream] implementation so that calls to write are passed through to the underlying stream, while calls to read will first consume the input sequence stored in a [*DynamicBuffer] which is part of the object.

The use-case for this class is different than that of the `boost::asio::buffered_readstream`. It is designed to facilitate the use of `boost::asio::read_until`, and to allow buffers acquired during detection of handshakes to be made transparently available to callers. A hypothetical implementation of the buffered version of `boost::asio::ssl::stream::async_handshake` could make use of this wrapper.

Uses:


* Transparently leave untouched input acquired in calls to `boost::asio::read_until` behind for subsequent callers.


* "Preload" a stream with handshake input data acquired from other sources.

Example: 

  // Process the next HTTP header on the stream,
  // leaving excess bytes behind for the next call.
  //
  template<class DynamicBuffer>
  void process_http_message(
      buffered_read_stream<DynamicBuffer>& stream)
  {
      // Read up to and including the end of the HTTP
      // header, leaving the sequence in the stream's
      // buffer. read_until may read past the end of the
      // headers; the return value will include only the
      // part up to the end of the delimiter.
      //
      std::size_t bytes_transferred =
          boost::asio::read_until(
              stream.next_layer(), stream.buffer(), "\r\n\r\n");

      // Use buffers_prefix() to limit the input
      // sequence to only the data up to and including
      // the trailing "\r\n\r\n".
      //
      auto header_buffers = buffers_prefix(
          bytes_transferred, stream.buffer().data());

      ...

      // Discard the portion of the input corresponding
      // to the HTTP headers.
      //
      stream.buffer().consume(bytes_transferred);

      // Everything we read from the stream
      // is part of the content-body.
  }




[heading Template Parameters][table [[Type][Description]]  [[`Stream`][    The type of stream to wrap.  ]]  [[`DynamicBuffer`][    The type of stream buffer to use.   ]]]

[section:async_read_some buffered_read_stream::async_read_some][indexterm2 async_read_some..buffered_read_stream]
Start an asynchronous read. 
[heading Synopsis]```template<    class __MutableBufferSequence__,    class __ReadHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_read_some(    MutableBufferSequence const& buffers,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read data from the stream. The function call always returns immediately.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    The handler to be called when the operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& error,      // result of operation
      std::size_t bytes_transferred // number of bytes transferred
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:async_write_some buffered_read_stream::async_write_some][indexterm2 async_write_some..buffered_read_stream]
Start an asynchronous write. 
[heading Synopsis]```template<    class __ConstBufferSequence__,    class __WriteHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_write_some(    ConstBufferSequence const& buffers,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously write data from the stream. The function call always returns immediately.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    One or more data buffers to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    The handler to be called when the operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& error,      // result of operation
      std::size_t bytes_transferred // number of bytes transferred
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:buffer buffered_read_stream::buffer][indexterm2 buffer..buffered_read_stream]
Access the internal buffer. 
```DynamicBuffer&``[link beast.ref.boost__beast__buffered_read_stream.buffer.overload1 buffer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.buffer.overload1 more...]]``DynamicBuffer const&``[link beast.ref.boost__beast__buffered_read_stream.buffer.overload2 buffer]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.buffer.overload2 more...]]`````[section:overload1 buffered_read_stream::buffer (1 of 2 overloads)]
Access the internal buffer. 
[heading Synopsis]```DynamicBuffer&buffer();```[heading Description]
The internal buffer is returned. It is possible for the caller to break invariants with this function. For example, by causing the internal buffer size to increase beyond the caller defined maximum. 
[endsect][section:overload2 buffered_read_stream::buffer (2 of 2 overloads)]
Access the internal buffer. 
[heading Synopsis]```DynamicBuffer const&buffer() const;```[heading Description][endsect][endsect][section:buffer_type buffered_read_stream::buffer_type][indexterm2 buffer_type..buffered_read_stream]
The type of the internal buffer. 
[heading Synopsis]```using buffer_type = DynamicBuffer;```[heading Description][endsect][section:buffered_read_stream buffered_read_stream::buffered_read_stream][indexterm2 buffered_read_stream..buffered_read_stream]
Move constructor. 
`````[link beast.ref.boost__beast__buffered_read_stream.buffered_read_stream.overload1 buffered_read_stream]``(    buffered_read_stream&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.buffered_read_stream.overload1 more...]]`````
Construct the wrapping stream. 
```template<    class... Args>explicit``[link beast.ref.boost__beast__buffered_read_stream.buffered_read_stream.overload2 buffered_read_stream]``(    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.buffered_read_stream.overload2 more...]]`````[section:overload1 buffered_read_stream::buffered_read_stream (1 of 2 overloads)]
Move constructor. 
[heading Synopsis]```buffered_read_stream(    buffered_read_stream&&);```[heading Description]
[heading Remarks]
The behavior of move assignment on or from streams with active or pending operations is undefined. 


[endsect][section:overload2 buffered_read_stream::buffered_read_stream (2 of 2 overloads)]
Construct the wrapping stream. 
[heading Synopsis]```template<    class... Args>buffered_read_stream(    Args&&... args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`args`][    Parameters forwarded to the `Stream` constructor.   ]]]

[endsect][endsect][section:capacity buffered_read_stream::capacity][indexterm2 capacity..buffered_read_stream]
Set the maximum buffer size. 
[heading Synopsis]```voidcapacity(    std::size_t size);```[heading Description]
This changes the maximum size of the internal buffer used to hold read data. No bytes are discarded by this call. If the buffer size is set to zero, no more data will be buffered.

Thread safety: The caller is responsible for making sure the call is made from the same implicit or explicit strand.

[heading Parameters][table [[Name][Description]]  [[`size`][    The number of bytes in the read buffer.  ]]]
[heading Remarks]
This is a soft limit. If the new maximum size is smaller than the amount of data in the buffer, no bytes are discarded. 


[endsect][section:get_executor buffered_read_stream::get_executor][indexterm2 get_executor..buffered_read_stream]
Get the executor associated with the object. 
[heading Synopsis]`````['implementation-defined]``get_executor();```[heading Description]
This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.

[heading Return Value]
A copy of the executor that stream will use to dispatch handlers.

[heading Remarks]
This function participates in overload resolution only if `NextLayer` has a member function named `get_executor`. 


[endsect][section:lowest_layer buffered_read_stream::lowest_layer][indexterm2 lowest_layer..buffered_read_stream]
Get a reference to the lowest layer. 
```lowest_layer_type&``[link beast.ref.boost__beast__buffered_read_stream.lowest_layer.overload1 lowest_layer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.lowest_layer.overload1 more...]]`````
Get a const reference to the lowest layer. 
```lowest_layer_type const&``[link beast.ref.boost__beast__buffered_read_stream.lowest_layer.overload2 lowest_layer]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.lowest_layer.overload2 more...]]`````[section:overload1 buffered_read_stream::lowest_layer (1 of 2 overloads)]
Get a reference to the lowest layer. 
[heading Synopsis]```lowest_layer_type&lowest_layer();```[heading Description][endsect][section:overload2 buffered_read_stream::lowest_layer (2 of 2 overloads)]
Get a const reference to the lowest layer. 
[heading Synopsis]```lowest_layer_type const&lowest_layer() const;```[heading Description][endsect][endsect][section:lowest_layer_type buffered_read_stream::lowest_layer_type][indexterm2 lowest_layer_type..buffered_read_stream]
The type of the lowest layer. 
[heading Synopsis]```using lowest_layer_type = typename get_lowest_layer< next_layer_type >::type;```
This will contain a nested `type` equal to `T::lowest_layer_type` if it exists, else `type` will be equal to `T`.

[heading Example]


Declaring a wrapper:



  template<class Stream>
  struct stream_wrapper
  {
      using next_layer_type = typename std::remove_reference<Stream>::type;
      using lowest_layer_type = typename get_lowest_layer<stream_type>::type;
  };




Defining a metafunction:



  template<class T>
  using is_stream_wrapper : std::integral_constant<bool,
      ! std::is_same<T, typename get_lowest_layer<T>::type>::value> {};



[heading Description][endsect][section:next_layer buffered_read_stream::next_layer][indexterm2 next_layer..buffered_read_stream]
Get a reference to the next layer. 
```next_layer_type&``[link beast.ref.boost__beast__buffered_read_stream.next_layer.overload1 next_layer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.next_layer.overload1 more...]]`````
Get a const reference to the next layer. 
```next_layer_type const&``[link beast.ref.boost__beast__buffered_read_stream.next_layer.overload2 next_layer]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.next_layer.overload2 more...]]`````[section:overload1 buffered_read_stream::next_layer (1 of 2 overloads)]
Get a reference to the next layer. 
[heading Synopsis]```next_layer_type&next_layer();```[heading Description][endsect][section:overload2 buffered_read_stream::next_layer (2 of 2 overloads)]
Get a const reference to the next layer. 
[heading Synopsis]```next_layer_type const&next_layer() const;```[heading Description][endsect][endsect][section:next_layer_type buffered_read_stream::next_layer_type][indexterm2 next_layer_type..buffered_read_stream]
The type of the next layer. 
[heading Synopsis]```using next_layer_type = typename std::remove_reference< Stream >::type;```[heading Description][endsect][section:operator_eq_ buffered_read_stream::operator=][indexterm2 operator=..buffered_read_stream]
Move assignment. 
[heading Synopsis]```buffered_read_stream&operator=(    buffered_read_stream&&);```[heading Description]
[heading Remarks]
The behavior of move assignment on or from streams with active or pending operations is undefined. 


[endsect][section:read_some buffered_read_stream::read_some][indexterm2 read_some..buffered_read_stream]
Read some data from the stream. 
```template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__buffered_read_stream.read_some.overload1 read_some]``(    MutableBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.read_some.overload1 more...]]``template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__buffered_read_stream.read_some.overload2 read_some]``(    MutableBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.read_some.overload2 more...]]`````[section:overload1 buffered_read_stream::read_some (1 of 2 overloads)]
Read some data from the stream. 
[heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers);```[heading Description]
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    One or more buffers into which the data will be read.  ]]]
[heading Return Value]
The number of bytes read.

[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

[endsect][section:overload2 buffered_read_stream::read_some (2 of 2 overloads)]
Read some data from the stream. 
[heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    One or more buffers into which the data will be read.  ]]  [[`ec`][    Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes read, or 0 on error. 


[endsect][endsect][section:write_some buffered_read_stream::write_some][indexterm2 write_some..buffered_read_stream]
Write some data to the stream. 
```template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__buffered_read_stream.write_some.overload1 write_some]``(    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.write_some.overload1 more...]]``template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__buffered_read_stream.write_some.overload2 write_some]``(    ConstBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffered_read_stream.write_some.overload2 more...]]`````[section:overload1 buffered_read_stream::write_some (1 of 2 overloads)]
Write some data to the stream. 
[heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers);```[heading Description]
This function is used to write data to the stream. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    One or more data buffers to be written to the stream.  ]]]
[heading Return Value]
The number of bytes written.

[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

[endsect][section:overload2 buffered_read_stream::write_some (2 of 2 overloads)]
Write some data to the stream. 
[heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to write data to the stream. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    One or more data buffers to be written to the stream.  ]]  [[`ec`][    Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes written. 


[endsect][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffered_read_stream__read_some_op buffered_read_stream::read_some_op][heading Synopsis]Defined in header [include_file boost/beast/core/buffered_read_stream.hpp]```template<    class Buffers,    class __Handler__>class read_some_op```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers buffers][indexterm1 buffers]
Return an object representing a [*ConstBufferSequence]. 
[heading Synopsis]Defined in header [include_file boost/beast/core/ostream.hpp]```template<    class __ConstBufferSequence__>``['implementation-defined]``buffers(    ConstBufferSequence const& b);```[heading Description]
This function wraps a reference to a buffer sequence and permits the following operation:


* `operator<<` to `std::ostream`. No character translation is performed; unprintable and null characters will be transferred as-is to the output stream.

[heading Example]


  multi_buffer b;
  ...
  std::cout << buffers(b.data()) << std::endl;




[heading Parameters][table [[Name][Description]]  [[`b`][    An object meeting the requirements of ConstBufferSequence to be streamed. The implementation will make a copy of this object. Ownership of the underlying memory is not transferred, the application is still responsible for managing its lifetime.   ]]]

Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_adapter buffers_adapter]
Adapts a [*MutableBufferSequence] into a [*DynamicBuffer]. 
[heading Synopsis]Defined in header [include_file boost/beast/core/buffers_adapter.hpp]```template<    class __MutableBufferSequence__>class buffers_adapter```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_adapter.const_buffers_type [*const_buffers_type]]]    [      The type used to represent the input sequence as a list of buffers.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adapter.mutable_buffers_type [*mutable_buffers_type]]]    [      The type used to represent the output sequence as a list of buffers.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_adapter.buffers_adapter [*buffers_adapter]]]    [      Move constructor.       Copy constructor.       Construct a buffers adapter.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adapter.capacity [*capacity]]]    [      Returns the maximum sum of the sizes of the input sequence and output sequence the buffer can hold without requiring reallocation.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adapter.commit [*commit]]]    [      Move bytes from the output sequence to the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adapter.consume [*consume]]]    [      Remove bytes from the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adapter.data [*data]]]    [      Get a list of buffers that represents the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adapter.max_size [*max_size]]]    [      Returns the largest size output sequence possible.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adapter.operator_eq_ [*operator=]]]    [      Move assignment.       Copy assignment.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adapter.prepare [*prepare]]]    [      Get a list of buffers that represents the output sequence, with the given size.     ]  ]  [    [[link beast.ref.boost__beast__buffers_adapter.size [*size]]]    [      Get the size of the input sequence.     ]  ]][heading Description]
This class wraps a [*MutableBufferSequence] to meet the requirements of [*DynamicBuffer]. Upon construction the input and output sequences are empty. A copy of the mutable buffer sequence object is stored; however, ownership of the underlying memory is not transferred. The caller is responsible for making sure that referenced memory remains valid for the duration of any operations.

The size of the mutable buffer sequence determines the maximum number of bytes which may be prepared and committed.

[heading Template Parameters][table [[Type][Description]]  [[`MutableBufferSequence`][    The type of mutable buffer sequence to wrap.   ]]]

[section:buffers_adapter buffers_adapter::buffers_adapter][indexterm2 buffers_adapter..buffers_adapter]
Move constructor. 
`````[link beast.ref.boost__beast__buffers_adapter.buffers_adapter.overload1 buffers_adapter]``(    buffers_adapter&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_adapter.buffers_adapter.overload1 more...]]`````
Copy constructor. 
`````[link beast.ref.boost__beast__buffers_adapter.buffers_adapter.overload2 buffers_adapter]``(    buffers_adapter const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_adapter.buffers_adapter.overload2 more...]]`````
Construct a buffers adapter. 
```explicit``[link beast.ref.boost__beast__buffers_adapter.buffers_adapter.overload3 buffers_adapter]``(    MutableBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_adapter.buffers_adapter.overload3 more...]]`````[section:overload1 buffers_adapter::buffers_adapter (1 of 3 overloads)]
Move constructor. 
[heading Synopsis]```buffers_adapter(    buffers_adapter&& other);```[heading Description][endsect][section:overload2 buffers_adapter::buffers_adapter (2 of 3 overloads)]
Copy constructor. 
[heading Synopsis]```buffers_adapter(    buffers_adapter const& other);```[heading Description][endsect][section:overload3 buffers_adapter::buffers_adapter (3 of 3 overloads)]
Construct a buffers adapter. 
[heading Synopsis]```buffers_adapter(    MutableBufferSequence const& buffers);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffers`][    The mutable buffer sequence to wrap. A copy of the object will be made, but ownership of the memory is not transferred.   ]]]

[endsect][endsect][section:capacity buffers_adapter::capacity][indexterm2 capacity..buffers_adapter]
Returns the maximum sum of the sizes of the input sequence and output sequence the buffer can hold without requiring reallocation. 
[heading Synopsis]```std::size_tcapacity() const;```[heading Description][endsect][section:commit buffers_adapter::commit][indexterm2 commit..buffers_adapter]
Move bytes from the output sequence to the input sequence. 
[heading Synopsis]```voidcommit(    std::size_t n);```[heading Description]
[heading Remarks]
Buffers representing the input sequence acquired prior to this call remain valid. 


[endsect][section:const_buffers_type buffers_adapter::const_buffers_type][indexterm2 const_buffers_type..buffers_adapter]
The type used to represent the input sequence as a list of buffers. 
[heading Synopsis]```using const_buffers_type = ``['implementation-defined]``;```[heading Description][endsect][section:consume buffers_adapter::consume][indexterm2 consume..buffers_adapter]
Remove bytes from the input sequence. 
[heading Synopsis]```voidconsume(    std::size_t n);```[heading Description][endsect][section:data buffers_adapter::data][indexterm2 data..buffers_adapter]
Get a list of buffers that represents the input sequence. 
[heading Synopsis]```const_buffers_typedata() const;```[heading Description]
[heading Remarks]
These buffers remain valid across subsequent calls to `prepare`. 


[endsect][section:max_size buffers_adapter::max_size][indexterm2 max_size..buffers_adapter]
Returns the largest size output sequence possible. 
[heading Synopsis]```std::size_tmax_size() const;```[heading Description][endsect][section:mutable_buffers_type buffers_adapter::mutable_buffers_type][indexterm2 mutable_buffers_type..buffers_adapter]
The type used to represent the output sequence as a list of buffers. 
[heading Synopsis]```using mutable_buffers_type = ``['implementation-defined]``;```[heading Description][endsect][section:operator_eq_ buffers_adapter::operator=][indexterm2 operator=..buffers_adapter]
Move assignment. 
```buffers_adapter&``[link beast.ref.boost__beast__buffers_adapter.operator_eq_.overload1 operator=]``(    buffers_adapter&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_adapter.operator_eq_.overload1 more...]]`````
Copy assignment. 
```buffers_adapter&``[link beast.ref.boost__beast__buffers_adapter.operator_eq_.overload2 operator=]``(    buffers_adapter const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_adapter.operator_eq_.overload2 more...]]`````[section:overload1 buffers_adapter::operator= (1 of 2 overloads)]
Move assignment. 
[heading Synopsis]```buffers_adapter&operator=(    buffers_adapter&& other);```[heading Description][endsect][section:overload2 buffers_adapter::operator= (2 of 2 overloads)]
Copy assignment. 
[heading Synopsis]```buffers_adapter&operator=(    buffers_adapter const&);```[heading Description][endsect][endsect][section:prepare buffers_adapter::prepare][indexterm2 prepare..buffers_adapter]
Get a list of buffers that represents the output sequence, with the given size. 
[heading Synopsis]```mutable_buffers_typeprepare(    std::size_t n);```[heading Description]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    if the size would exceed the limit imposed by the underlying mutable buffer sequence.  ]]]
[heading Remarks]
Buffers representing the input sequence acquired prior to this call remain valid. 


[endsect][section:size buffers_adapter::size][indexterm2 size..buffers_adapter]
Get the size of the input sequence. 
[heading Synopsis]```std::size_tsize() const;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_cat buffers_cat][indexterm1 buffers_cat]
Concatenate 2 or more buffer sequences. 
[heading Synopsis]Defined in header [include_file boost/beast/core/buffers_cat.hpp]```template<    class... ``[link beast.concepts.BufferSequence [*BufferSequence]]``>buffers_cat_view< BufferSequence...>buffers_cat(    BufferSequence const&... buffers);```[heading Description]
This function returns a constant or mutable buffer sequence which, when iterated, efficiently concatenates the input buffer sequences. Copies of the arguments passed will be made; however, the returned object does not take ownership of the underlying memory. The application is still responsible for managing the lifetime of the referenced memory.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    The list of buffer sequences to concatenate.  ]]]
[heading Return Value]
A new buffer sequence that represents the concatenation of the input buffer sequences. This buffer sequence will be a [*MutableBufferSequence] if each of the passed buffer sequences is also a [*MutableBufferSequence]; otherwise the returned buffer sequence will be a [*ConstBufferSequence].

[heading See Also]
[link beast.ref.boost__beast__buffers_cat_view `buffers_cat_view`] 


Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_cat_view buffers_cat_view]
A buffer sequence representing a concatenation of buffer sequences. 
[heading Synopsis]Defined in header [include_file boost/beast/core/buffers_cat.hpp]```template<    class... Buffers>class buffers_cat_view```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_cat_view.value_type [*value_type]]]    [      The type of buffer returned when dereferencing an iterator.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_cat_view.begin [*begin]]]    [      Required for BufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__buffers_cat_view.buffers_cat_view [*buffers_cat_view]]]    [      Constructor.       Required for BufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__buffers_cat_view.end [*end]]]    [      Required for BufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__buffers_cat_view.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]][heading Description]
[heading See Also]
[link beast.ref.boost__beast__buffers_cat `buffers_cat`] 


[section:begin buffers_cat_view::begin][indexterm2 begin..buffers_cat_view]
Required for [*BufferSequence]. 
[heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:buffers_cat_view buffers_cat_view::buffers_cat_view][indexterm2 buffers_cat_view..buffers_cat_view]
Constructor. 
`````[link beast.ref.boost__beast__buffers_cat_view.buffers_cat_view.overload1 buffers_cat_view]``(    buffers_cat_view&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_cat_view.buffers_cat_view.overload1 more...]]``explicit``[link beast.ref.boost__beast__buffers_cat_view.buffers_cat_view.overload2 buffers_cat_view]``(    Buffers const&... buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_cat_view.buffers_cat_view.overload2 more...]]`````
Required for [*BufferSequence]. 
`````[link beast.ref.boost__beast__buffers_cat_view.buffers_cat_view.overload3 buffers_cat_view]``(    buffers_cat_view const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_cat_view.buffers_cat_view.overload3 more...]]`````[section:overload1 buffers_cat_view::buffers_cat_view (1 of 3 overloads)]
Constructor. 
[heading Synopsis]```buffers_cat_view(    buffers_cat_view&&);```[heading Description][endsect][section:overload2 buffers_cat_view::buffers_cat_view (2 of 3 overloads)]
Constructor. 
[heading Synopsis]```buffers_cat_view(    Buffers const&... buffers);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffers`][    The list of buffer sequences to concatenate. Copies of the arguments will be made; however, the ownership of memory is not transferred.   ]]]

[endsect][section:overload3 buffers_cat_view::buffers_cat_view (3 of 3 overloads)]
Required for [*BufferSequence]. 
[heading Synopsis]```buffers_cat_view(    buffers_cat_view const&);```[heading Description][endsect][endsect][section:end buffers_cat_view::end][indexterm2 end..buffers_cat_view]
Required for [*BufferSequence]. 
[heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:operator_eq_ buffers_cat_view::operator=][indexterm2 operator=..buffers_cat_view]
Assignment. 
```buffers_cat_view&``[link beast.ref.boost__beast__buffers_cat_view.operator_eq_.overload1 operator=]``(    buffers_cat_view&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_cat_view.operator_eq_.overload1 more...]]``buffers_cat_view&``[link beast.ref.boost__beast__buffers_cat_view.operator_eq_.overload2 operator=]``(    buffers_cat_view const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_cat_view.operator_eq_.overload2 more...]]`````[section:overload1 buffers_cat_view::operator= (1 of 2 overloads)]
Assignment. 
[heading Synopsis]```buffers_cat_view&operator=(    buffers_cat_view&&);```[heading Description][endsect][section:overload2 buffers_cat_view::operator= (2 of 2 overloads)]
Assignment. 
[heading Synopsis]```buffers_cat_view&operator=(    buffers_cat_view const&);```[heading Description][endsect][endsect][section:value_type buffers_cat_view::value_type][indexterm2 value_type..buffers_cat_view]
The type of buffer returned when dereferencing an iterator. 
[heading Synopsis]```using value_type = ``['implementation-defined]``;```[heading Description]
If every buffer sequence in the view is a [*MutableBufferSequence], then `value_type` will be `boost::asio::mutable_buffer`. Otherwise, `value_type` will be `boost::asio::const_buffer`. 
[endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_front buffers_front][indexterm1 buffers_front]
Returns the first buffer in a buffer sequence. 
[heading Synopsis]Defined in header [include_file boost/beast/core/buffers_prefix.hpp]```template<    class ``[link beast.concepts.BufferSequence [*BufferSequence]]``>std::conditional< boost::asio::is_mutable_buffer_sequence< BufferSequence >::value, boost::asio::mutable_buffer, boost::asio::const_buffer >::typebuffers_front(    BufferSequence const& buffers);```[heading Description]
This returns the first buffer in the buffer sequence. If the buffer sequence is an empty range, the returned buffer will have a zero buffer size.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    The buffer sequence. If the sequence is mutable, the returned buffer sequence will also be mutable. Otherwise, the returned buffer sequence will be constant.   ]]]

Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_prefix buffers_prefix][indexterm1 buffers_prefix]
Returns a prefix of a constant buffer. 
```boost::asio::const_buffer``[link beast.ref.boost__beast__buffers_prefix.overload1 buffers_prefix]``(    std::size_t size,    boost::asio::const_buffer buffer);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix.overload1 more...]]`````
Returns a prefix of a mutable buffer. 
```boost::asio::mutable_buffer``[link beast.ref.boost__beast__buffers_prefix.overload2 buffers_prefix]``(    std::size_t size,    boost::asio::mutable_buffer buffer);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix.overload2 more...]]`````
Returns a prefix of a buffer sequence. 
```template<    class ``[link beast.concepts.BufferSequence [*BufferSequence]]``>buffers_prefix_view< BufferSequence >``[link beast.ref.boost__beast__buffers_prefix.overload3 buffers_prefix]``(    std::size_t size,    BufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix.overload3 more...]]`````[section:overload1 buffers_prefix (1 of 3 overloads)]
Returns a prefix of a constant buffer. 
[heading Synopsis]Defined in header [include_file boost/beast/core/buffers_prefix.hpp]```boost::asio::const_bufferbuffers_prefix(    std::size_t size,    boost::asio::const_buffer buffer);```[heading Description]
The returned buffer points to the same memory as the passed buffer, but with a size that is equal to or less than the size of the original buffer.

[heading Parameters][table [[Name][Description]]  [[`size`][    The size of the returned buffer.  ]]  [[`buffer`][    The buffer to shorten. The underlying memory is not modified.  ]]]
[heading Return Value]
A new buffer that points to the first `size` bytes of the original buffer. 


Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 buffers_prefix (2 of 3 overloads)]
Returns a prefix of a mutable buffer. 
[heading Synopsis]Defined in header [include_file boost/beast/core/buffers_prefix.hpp]```boost::asio::mutable_bufferbuffers_prefix(    std::size_t size,    boost::asio::mutable_buffer buffer);```[heading Description]
The returned buffer points to the same memory as the passed buffer, but with a size that is equal to or less than the size of the original buffer.

[heading Parameters][table [[Name][Description]]  [[`size`][    The size of the returned buffer.  ]]  [[`buffer`][    The buffer to shorten. The underlying memory is not modified.  ]]]
[heading Return Value]
A new buffer that points to the first `size` bytes of the original buffer. 


Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 buffers_prefix (3 of 3 overloads)]
Returns a prefix of a buffer sequence. 
[heading Synopsis]Defined in header [include_file boost/beast/core/buffers_prefix.hpp]```template<    class ``[link beast.concepts.BufferSequence [*BufferSequence]]``>buffers_prefix_view< BufferSequence >buffers_prefix(    std::size_t size,    BufferSequence const& buffers);```[heading Description]
This function returns a new buffer sequence which when iterated, presents a shorter subset of the original list of buffers starting with the first byte of the original sequence.

[heading Parameters][table [[Name][Description]]  [[`size`][    The maximum number of bytes in the wrapped sequence. If this is larger than the size of passed, buffers, the resulting sequence will represent the entire input sequence.  ]]  [[`buffers`][    An instance of ConstBufferSequence or MutableBufferSequence to adapt. A copy of the sequence will be made, but ownership of the underlying memory is not transferred.   ]]]

Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__buffers_prefix_view buffers_prefix_view]
A buffer sequence adapter that shortens the sequence size. 
[heading Synopsis]Defined in header [include_file boost/beast/core/buffers_prefix.hpp]```template<    class ``[link beast.concepts.BufferSequence [*BufferSequence]]``>class buffers_prefix_view```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_prefix_view.const_iterator [*const_iterator]]]    [      A bidirectional iterator type that may be used to read elements.     ]  ]  [    [[link beast.ref.boost__beast__buffers_prefix_view.value_type [*value_type]]]    [      The type for each element in the list of buffers.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_prefix_view.begin [*begin]]]    [      Get a bidirectional iterator to the first element.     ]  ]  [    [[link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view [*buffers_prefix_view]]]    [      Move constructor.       Copy constructor.       Construct a buffer sequence prefix.       Construct a buffer sequence prefix in-place.     ]  ]  [    [[link beast.ref.boost__beast__buffers_prefix_view.end [*end]]]    [      Get a bidirectional iterator to one past the last element.     ]  ]  [    [[link beast.ref.boost__beast__buffers_prefix_view.operator_eq_ [*operator=]]]    [      Move assignment.       Copy assignment.     ]  ]][heading Description]
The class adapts a buffer sequence to efficiently represent a shorter subset of the original list of buffers starting with the first byte of the original sequence.

[heading Template Parameters][table [[Type][Description]]  [[`BufferSequence`][    The buffer sequence to adapt.   ]]]

[section:begin buffers_prefix_view::begin][indexterm2 begin..buffers_prefix_view]
Get a bidirectional iterator to the first element. 
[heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:buffers_prefix_view buffers_prefix_view::buffers_prefix_view][indexterm2 buffers_prefix_view..buffers_prefix_view]
Move constructor. 
`````[link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload1 buffers_prefix_view]``(    buffers_prefix_view&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload1 more...]]`````
Copy constructor. 
`````[link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload2 buffers_prefix_view]``(    buffers_prefix_view const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload2 more...]]`````
Construct a buffer sequence prefix. 
`````[link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload3 buffers_prefix_view]``(    std::size_t size,    BufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload3 more...]]`````
Construct a buffer sequence prefix in-place. 
```template<    class... Args>``[link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload4 buffers_prefix_view]``(    std::size_t size,    boost::in_place_init_t,    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix_view.buffers_prefix_view.overload4 more...]]`````[section:overload1 buffers_prefix_view::buffers_prefix_view (1 of 4 overloads)]
Move constructor. 
[heading Synopsis]```buffers_prefix_view(    buffers_prefix_view&&);```[heading Description][endsect][section:overload2 buffers_prefix_view::buffers_prefix_view (2 of 4 overloads)]
Copy constructor. 
[heading Synopsis]```buffers_prefix_view(    buffers_prefix_view const&);```[heading Description][endsect][section:overload3 buffers_prefix_view::buffers_prefix_view (3 of 4 overloads)]
Construct a buffer sequence prefix. 
[heading Synopsis]```buffers_prefix_view(    std::size_t size,    BufferSequence const& buffers);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`size`][    The maximum number of bytes in the prefix. If this is larger than the size of passed, buffers, the resulting sequence will represent the entire input sequence.  ]]  [[`buffers`][    The buffer sequence to adapt. A copy of the sequence will be made, but ownership of the underlying memory is not transferred.   ]]]

[endsect][section:overload4 buffers_prefix_view::buffers_prefix_view (4 of 4 overloads)]
Construct a buffer sequence prefix in-place. 
[heading Synopsis]```template<    class... Args>buffers_prefix_view(    std::size_t size,    boost::in_place_init_t,    Args&&... args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`size`][    The maximum number of bytes in the prefix. If this is larger than the size of passed, buffers, the resulting sequence will represent the entire input sequence.  ]]  [[`args`][    Arguments forwarded to the contained buffers constructor.   ]]]

[endsect][endsect][section:const_iterator buffers_prefix_view::const_iterator][indexterm2 const_iterator..buffers_prefix_view]
A bidirectional iterator type that may be used to read elements. 
[heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end buffers_prefix_view::end][indexterm2 end..buffers_prefix_view]
Get a bidirectional iterator to one past the last element. 
[heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:operator_eq_ buffers_prefix_view::operator=][indexterm2 operator=..buffers_prefix_view]
Move assignment. 
```buffers_prefix_view&``[link beast.ref.boost__beast__buffers_prefix_view.operator_eq_.overload1 operator=]``(    buffers_prefix_view&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix_view.operator_eq_.overload1 more...]]`````
Copy assignment. 
```buffers_prefix_view&``[link beast.ref.boost__beast__buffers_prefix_view.operator_eq_.overload2 operator=]``(    buffers_prefix_view const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_prefix_view.operator_eq_.overload2 more...]]`````[section:overload1 buffers_prefix_view::operator= (1 of 2 overloads)]
Move assignment. 
[heading Synopsis]```buffers_prefix_view&operator=(    buffers_prefix_view&&);```[heading Description][endsect][section:overload2 buffers_prefix_view::operator= (2 of 2 overloads)]
Copy assignment. 
[heading Synopsis]```buffers_prefix_view&operator=(    buffers_prefix_view const&);```[heading Description][endsect][endsect][section:value_type buffers_prefix_view::value_type][indexterm2 value_type..buffers_prefix_view]
The type for each element in the list of buffers. 
[heading Synopsis]```using value_type = typename std::conditional< std::is_convertible< typename std::iterator_traits< iter_type >::value_type, boost::asio::mutable_buffer >::value, boost::asio::mutable_buffer, boost::asio::const_buffer >::type;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_suffix buffers_suffix]
Adapter to trim the front of a `BufferSequence`. 
[heading Synopsis]Defined in header [include_file boost/beast/core/buffers_suffix.hpp]```template<    class ``[link beast.concepts.BufferSequence [*BufferSequence]]``>class buffers_suffix```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_suffix.const_iterator [*const_iterator]]]    [      A bidirectional iterator type that may be used to read elements.     ]  ]  [    [[link beast.ref.boost__beast__buffers_suffix.value_type [*value_type]]]    [      The type for each element in the list of buffers.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__buffers_suffix.begin [*begin]]]    [      Get a bidirectional iterator to the first element.     ]  ]  [    [[link beast.ref.boost__beast__buffers_suffix.buffers_suffix [*buffers_suffix]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__buffers_suffix.consume [*consume]]]    [      Remove bytes from the beginning of the sequence.     ]  ]  [    [[link beast.ref.boost__beast__buffers_suffix.end [*end]]]    [      Get a bidirectional iterator to one past the last element.     ]  ]  [    [[link beast.ref.boost__beast__buffers_suffix.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]][heading Description]
This adapter wraps a buffer sequence to create a new sequence which may be incrementally consumed. Bytes consumed are removed from the front of the buffer. The underlying memory is not changed, instead the adapter efficiently iterates through a subset of the buffers wrapped.

The wrapped buffer is not modified, a copy is made instead. Ownership of the underlying memory is not transferred, the application is still responsible for managing its lifetime.

[heading Template Parameters][table [[Type][Description]]  [[`BufferSequence`][    The buffer sequence to wrap.  ]]]
[heading Example]


This function writes the entire contents of a buffer sequence to the specified stream.



  template<class SyncWriteStream, class ConstBufferSequence>
  void send(SyncWriteStream& stream, ConstBufferSequence const& buffers)
  {
      buffers_suffix<ConstBufferSequence> bs{buffers};
      while(boost::asio::buffer_size(bs) > 0)
          bs.consume(stream.write_some(bs));
  }



[section:begin buffers_suffix::begin][indexterm2 begin..buffers_suffix]
Get a bidirectional iterator to the first element. 
[heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:buffers_suffix buffers_suffix::buffers_suffix][indexterm2 buffers_suffix..buffers_suffix]
Constructor. 
`````[link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload1 buffers_suffix]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload1 more...]]````[link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload2 buffers_suffix]``(    buffers_suffix&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload2 more...]]````[link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload3 buffers_suffix]``(    buffers_suffix const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload3 more...]]``explicit``[link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload4 buffers_suffix]``(    BufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload4 more...]]``template<    class... Args>``[link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload5 buffers_suffix]``(    boost::in_place_init_t,    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_suffix.buffers_suffix.overload5 more...]]`````[section:overload1 buffers_suffix::buffers_suffix (1 of 5 overloads)]
Constructor. 
[heading Synopsis]```buffers_suffix();```[heading Description][endsect][section:overload2 buffers_suffix::buffers_suffix (2 of 5 overloads)]
Constructor. 
[heading Synopsis]```buffers_suffix(    buffers_suffix&&);```[heading Description][endsect][section:overload3 buffers_suffix::buffers_suffix (3 of 5 overloads)]
Constructor. 
[heading Synopsis]```buffers_suffix(    buffers_suffix const&);```[heading Description][endsect][section:overload4 buffers_suffix::buffers_suffix (4 of 5 overloads)]
Constructor. 
[heading Synopsis]```buffers_suffix(    BufferSequence const& buffers);```[heading Description]
A copy of the buffer sequence is made. Ownership of the underlying memory is not transferred or copied. 
[endsect][section:overload5 buffers_suffix::buffers_suffix (5 of 5 overloads)]
Constructor. 
[heading Synopsis]```template<    class... Args>buffers_suffix(    boost::in_place_init_t,    Args&&... args);```[heading Description]
This constructs the buffer sequence in-place from a list of arguments.

[heading Parameters][table [[Name][Description]]  [[`args`][    Arguments forwarded to the buffers constructor.   ]]]

[endsect][endsect][section:const_iterator buffers_suffix::const_iterator][indexterm2 const_iterator..buffers_suffix]
A bidirectional iterator type that may be used to read elements. 
[heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:consume buffers_suffix::consume][indexterm2 consume..buffers_suffix]
Remove bytes from the beginning of the sequence. 
[heading Synopsis]```voidconsume(    std::size_t amount);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`amount`][    The number of bytes to remove. If this is larger than the number of bytes remaining, all the bytes remaining are removed.   ]]]

[endsect][section:end buffers_suffix::end][indexterm2 end..buffers_suffix]
Get a bidirectional iterator to one past the last element. 
[heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:operator_eq_ buffers_suffix::operator=][indexterm2 operator=..buffers_suffix]
Assignment. 
```buffers_suffix&``[link beast.ref.boost__beast__buffers_suffix.operator_eq_.overload1 operator=]``(    buffers_suffix&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_suffix.operator_eq_.overload1 more...]]``buffers_suffix&``[link beast.ref.boost__beast__buffers_suffix.operator_eq_.overload2 operator=]``(    buffers_suffix const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__buffers_suffix.operator_eq_.overload2 more...]]`````[section:overload1 buffers_suffix::operator= (1 of 2 overloads)]
Assignment. 
[heading Synopsis]```buffers_suffix&operator=(    buffers_suffix&&);```[heading Description][endsect][section:overload2 buffers_suffix::operator= (2 of 2 overloads)]
Assignment. 
[heading Synopsis]```buffers_suffix&operator=(    buffers_suffix const&);```[heading Description][endsect][endsect][section:value_type buffers_suffix::value_type][indexterm2 value_type..buffers_suffix]
The type for each element in the list of buffers. 
[heading Synopsis]```using value_type = ``['implementation-defined]``;```[heading Description]
If the buffers in the underlying sequence are convertible to `boost::asio::mutable_buffer`, then this type will be `boost::asio::mutable_buffer`, else this type will be `boost::asio::const_buffer`. 
[endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__buffers_to_string buffers_to_string][indexterm1 buffers_to_string]
Return a string representing the contents of a buffer sequence. 
[heading Synopsis]Defined in header [include_file boost/beast/core/buffers_to_string.hpp]```template<    class __ConstBufferSequence__>std::stringbuffers_to_string(    ConstBufferSequence const& buffers);```[heading Description]
This function returns a string representing an entire buffer sequence. Nulls and unprintable characters in the buffer sequence are inserted to the resulting string as-is. No character conversions are performed.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    The buffer sequence to convert  ]]]
[heading Example]


This function writes a buffer sequence converted to a string to `std::cout`.



  template<class ConstBufferSequence>
  void print(ConstBufferSequence const& buffers)
  {
      std::cout << buffers_to_string(buffers) << std::endl;
  }



Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__errc errc][indexterm1 errc]
The set of constants used for cross-platform error codes. 
[heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```enum errc```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__error_category error_category][indexterm1 error_category]
The type of error category used by the library. 
[heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```using error_category = boost::system::error_category;```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__error_code error_code][indexterm1 error_code]
The type of error code used by the library. 
[heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```using error_code = boost::system::error_code;```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__error_condition error_condition][indexterm1 error_condition]
The type of error condition used by the library. 
[heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```using error_condition = boost::system::error_condition;```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__file file]
An implementation of File. 
[heading Synopsis]Defined in header [include_file boost/beast/core/file.hpp]```struct file :    public file_stdio```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file.native_handle_type [*native_handle_type]]]    [      The type of the underlying file handle.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file.close [*close]]]    [      Close the file if open.     ]  ]  [    [[link beast.ref.boost__beast__file.is_open [*is_open]]]    [      Returns true if the file is open.     ]  ]  [    [[link beast.ref.boost__beast__file.native_handle [*native_handle]]]    [      Returns the native handle associated with the file.       Set the native handle associated with the file.     ]  ]  [    [[link beast.ref.boost__beast__file.open [*open]]]    [      Open a file at the given path with the specified mode.     ]  ]  [    [[link beast.ref.boost__beast__file.pos [*pos]]]    [      Return the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file.read [*read]]]    [      Read from the open file.     ]  ]  [    [[link beast.ref.boost__beast__file.seek [*seek]]]    [      Adjust the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file.size [*size]]]    [      Return the size of the open file.     ]  ]  [    [[link beast.ref.boost__beast__file.write [*write]]]    [      Write to the open file.     ]  ]][heading Description]
This alias is set to the best available implementation of [*File] given the platform and build settings. 
[section:close file::close](Inherited from `file_stdio`)[indexterm2 close..file]
Close the file if open. 
[heading Synopsis]```voidclose(    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred.   ]]]

[endsect][section:is_open file::is_open](Inherited from `file_stdio`)[indexterm2 is_open..file]
Returns `true` if the file is open. 
[heading Synopsis]```boolis_open() const;```[heading Description][endsect][section:native_handle file::native_handle][indexterm2 native_handle..file]
Returns the native handle associated with the file. 
```FILE*``[link beast.ref.boost__beast__file.native_handle.overload1 native_handle]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__file.native_handle.overload1 more...]]`````
Set the native handle associated with the file. 
```void``[link beast.ref.boost__beast__file.native_handle.overload2 native_handle]``(    FILE* f);  ``[''''&raquo;''' [link beast.ref.boost__beast__file.native_handle.overload2 more...]]`````[section:overload1 file::native_handle (1 of 2 overloads)](Inherited from `file_stdio`)
Returns the native handle associated with the file. 
[heading Synopsis]```FILE*native_handle() const;```[heading Description][endsect][section:overload2 file::native_handle (2 of 2 overloads)](Inherited from `file_stdio`)
Set the native handle associated with the file. 
[heading Synopsis]```voidnative_handle(    FILE* f);```[heading Description]
If the file is open it is first closed.

[heading Parameters][table [[Name][Description]]  [[`f`][    The native file handle to assign.   ]]]

[endsect][endsect][section:native_handle_type file::native_handle_type](Inherited from `file_stdio`)[indexterm2 native_handle_type..file]
The type of the underlying file handle. 
[heading Synopsis]```using native_handle_type = FILE*;```[heading Description]
This is platform-specific. 
[endsect][section:open file::open](Inherited from `file_stdio`)[indexterm2 open..file]
Open a file at the given path with the specified mode. 
[heading Synopsis]```voidopen(    char const* path,    file_mode mode,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`path`][    The utf-8 encoded path to the file  ]]  [[`mode`][    The file mode to use  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:pos file::pos](Inherited from `file_stdio`)[indexterm2 pos..file]
Return the current position in the open file. 
[heading Synopsis]```std::uint64_tpos(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred  ]]]
[heading Return Value]
The offset in bytes from the beginning of the file 


[endsect][section:read file::read](Inherited from `file_stdio`)[indexterm2 read..file]
Read from the open file. 
[heading Synopsis]```std::size_tread(    void* buffer,    std::size_t n,    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    The buffer for storing the result of the read  ]]  [[`n`][    The number of bytes to read  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:seek file::seek](Inherited from `file_stdio`)[indexterm2 seek..file]
Adjust the current position in the open file. 
[heading Synopsis]```voidseek(    std::uint64_t offset,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`offset`][    The offset in bytes from the beginning of the file  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:size file::size](Inherited from `file_stdio`)[indexterm2 size..file]
Return the size of the open file. 
[heading Synopsis]```std::uint64_tsize(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred  ]]]
[heading Return Value]
The size in bytes 


[endsect][section:write file::write](Inherited from `file_stdio`)[indexterm2 write..file]
Write to the open file. 
[heading Synopsis]```std::size_twrite(    void const* buffer,    std::size_t n,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    The buffer holding the data to write  ]]  [[`n`][    The number of bytes to write  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__file_mode file_mode][indexterm1 file_mode]
File open modes. 
[heading Synopsis]Defined in header [include_file boost/beast/core/file_base.hpp]```enum file_mode```[indexterm2 read..file_mode][indexterm2 scan..file_mode][indexterm2 write..file_mode][indexterm2 write_new..file_mode][indexterm2 write_existing..file_mode][indexterm2 append..file_mode][indexterm2 append_new..file_mode][indexterm2 append_existing..file_mode][heading Values][table [[Name][Description]]  [[[^read]][Random reading. ]]  [[[^scan]][Sequential reading. ]]  [[[^write]][Random writing to a new or truncated file. If the file does not exist, it is created.
If the file exists, it is truncated to zero size upon opening. 
]]  [[[^write_new]][Random writing to new file only. If the file exists, an error is generated. ]]  [[[^write_existing]][Random writing to existing file. If the file does not exist, an error is generated. ]]  [[[^append]][Appending to a new or truncated file. The current file position shall be set to the end of the file prior to each write.If the file does not exist, it is created.
If the file exists, it is truncated to zero size upon opening. 
]]  [[[^append_new]][Appending to a new file only. The current file position shall be set to the end of the file prior to each write.If the file exists, an error is generated. ]]  [[[^append_existing]][Appending to an existing file. The current file position shall be set to the end of the file prior to each write.If the file does not exist, an error is generated. ]]][heading Description]
These modes are used when opening files using instances of the [*File] concept.

[heading See Also]
[link beast.ref.boost__beast__file_stdio `file_stdio`] 


Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__file_posix file_posix]
An implementation of File for POSIX systems. 
[heading Synopsis]Defined in header [include_file boost/beast/core/file_posix.hpp]```class file_posix```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file_posix.native_handle_type [*native_handle_type]]]    [      The type of the underlying file handle.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file_posix.close [*close]]]    [      Close the file if open.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.file_posix [*file_posix]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.is_open [*is_open]]]    [      Returns true if the file is open.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.native_handle [*native_handle]]]    [      Returns the native handle associated with the file.       Set the native handle associated with the file.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.open [*open]]]    [      Open a file at the given path with the specified mode.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.pos [*pos]]]    [      Return the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.read [*read]]]    [      Read from the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.seek [*seek]]]    [      Adjust the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.size [*size]]]    [      Return the size of the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.write [*write]]]    [      Write to the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_posix.file_posix_dtor_ [*~file_posix]]]    [      Destructor.     ]  ]][heading Description]
This class implements a [*File] using POSIX interfaces. 
[section:close file_posix::close][indexterm2 close..file_posix]
Close the file if open. 
[heading Synopsis]```voidclose(    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred.   ]]]

[endsect][section:file_posix file_posix::file_posix][indexterm2 file_posix..file_posix]
Constructor. 
`````[link beast.ref.boost__beast__file_posix.file_posix.overload1 file_posix]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__file_posix.file_posix.overload1 more...]]````[link beast.ref.boost__beast__file_posix.file_posix.overload2 file_posix]``(    file_posix&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__file_posix.file_posix.overload2 more...]]`````[section:overload1 file_posix::file_posix (1 of 2 overloads)]
Constructor. 
[heading Synopsis]```file_posix();```[heading Description]
There is no open file initially. 
[endsect][section:overload2 file_posix::file_posix (2 of 2 overloads)]
Constructor. 
[heading Synopsis]```file_posix(    file_posix&& other);```[heading Description]
The moved-from object behaves as if default constructed. 
[endsect][endsect][section:is_open file_posix::is_open][indexterm2 is_open..file_posix]
Returns `true` if the file is open. 
[heading Synopsis]```boolis_open() const;```[heading Description][endsect][section:native_handle file_posix::native_handle][indexterm2 native_handle..file_posix]
Returns the native handle associated with the file. 
```native_handle_type``[link beast.ref.boost__beast__file_posix.native_handle.overload1 native_handle]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__file_posix.native_handle.overload1 more...]]`````
Set the native handle associated with the file. 
```void``[link beast.ref.boost__beast__file_posix.native_handle.overload2 native_handle]``(    native_handle_type fd);  ``[''''&raquo;''' [link beast.ref.boost__beast__file_posix.native_handle.overload2 more...]]`````[section:overload1 file_posix::native_handle (1 of 2 overloads)]
Returns the native handle associated with the file. 
[heading Synopsis]```native_handle_typenative_handle() const;```[heading Description][endsect][section:overload2 file_posix::native_handle (2 of 2 overloads)]
Set the native handle associated with the file. 
[heading Synopsis]```voidnative_handle(    native_handle_type fd);```[heading Description]
If the file is open it is first closed.

[heading Parameters][table [[Name][Description]]  [[`fd`][    The native file handle to assign.   ]]]

[endsect][endsect][section:native_handle_type file_posix::native_handle_type][indexterm2 native_handle_type..file_posix]
The type of the underlying file handle. 
[heading Synopsis]```using native_handle_type = int;```[heading Description]
This is platform-specific. 
[endsect][section:open file_posix::open][indexterm2 open..file_posix]
Open a file at the given path with the specified mode. 
[heading Synopsis]```voidopen(    char const* path,    file_mode mode,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`path`][    The utf-8 encoded path to the file  ]]  [[`mode`][    The file mode to use  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:operator_eq_ file_posix::operator=][indexterm2 operator=..file_posix]
Assignment. 
[heading Synopsis]```file_posix&operator=(    file_posix&& other);```[heading Description]
The moved-from object behaves as if default constructed. 
[endsect][section:pos file_posix::pos][indexterm2 pos..file_posix]
Return the current position in the open file. 
[heading Synopsis]```std::uint64_tpos(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred  ]]]
[heading Return Value]
The offset in bytes from the beginning of the file 


[endsect][section:read file_posix::read][indexterm2 read..file_posix]
Read from the open file. 
[heading Synopsis]```std::size_tread(    void* buffer,    std::size_t n,    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    The buffer for storing the result of the read  ]]  [[`n`][    The number of bytes to read  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:seek file_posix::seek][indexterm2 seek..file_posix]
Adjust the current position in the open file. 
[heading Synopsis]```voidseek(    std::uint64_t offset,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`offset`][    The offset in bytes from the beginning of the file  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:size file_posix::size][indexterm2 size..file_posix]
Return the size of the open file. 
[heading Synopsis]```std::uint64_tsize(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred  ]]]
[heading Return Value]
The size in bytes 


[endsect][section:write file_posix::write][indexterm2 write..file_posix]
Write to the open file. 
[heading Synopsis]```std::size_twrite(    void const* buffer,    std::size_t n,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    The buffer holding the data to write  ]]  [[`n`][    The number of bytes to write  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:file_posix_dtor_ file_posix::~file_posix][indexterm2 ~file_posix..file_posix]
Destructor. 
[heading Synopsis]```~file_posix();```[heading Description]
If the file is open it is first closed. 
[endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__file_stdio file_stdio]
An implementation of File which uses cstdio. 
[heading Synopsis]Defined in header [include_file boost/beast/core/file_stdio.hpp]```class file_stdio```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file_stdio.native_handle_type [*native_handle_type]]]    [      The type of the underlying file handle.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file_stdio.close [*close]]]    [      Close the file if open.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.file_stdio [*file_stdio]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.is_open [*is_open]]]    [      Returns true if the file is open.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.native_handle [*native_handle]]]    [      Returns the native handle associated with the file.       Set the native handle associated with the file.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.open [*open]]]    [      Open a file at the given path with the specified mode.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.pos [*pos]]]    [      Return the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.read [*read]]]    [      Read from the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.seek [*seek]]]    [      Adjust the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.size [*size]]]    [      Return the size of the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.write [*write]]]    [      Write to the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_stdio.file_stdio_dtor_ [*~file_stdio]]]    [      Destructor.     ]  ]][heading Description]
This class implements a file using the interfaces present in the C++ Standard Library, in `<stdio>`. 
[section:close file_stdio::close][indexterm2 close..file_stdio]
Close the file if open. 
[heading Synopsis]```voidclose(    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred.   ]]]

[endsect][section:file_stdio file_stdio::file_stdio][indexterm2 file_stdio..file_stdio]
Constructor. 
`````[link beast.ref.boost__beast__file_stdio.file_stdio.overload1 file_stdio]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__file_stdio.file_stdio.overload1 more...]]````[link beast.ref.boost__beast__file_stdio.file_stdio.overload2 file_stdio]``(    file_stdio&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__file_stdio.file_stdio.overload2 more...]]`````[section:overload1 file_stdio::file_stdio (1 of 2 overloads)]
Constructor. 
[heading Synopsis]```file_stdio();```[heading Description]
There is no open file initially. 
[endsect][section:overload2 file_stdio::file_stdio (2 of 2 overloads)]
Constructor. 
[heading Synopsis]```file_stdio(    file_stdio&& other);```[heading Description]
The moved-from object behaves as if default constructed. 
[endsect][endsect][section:is_open file_stdio::is_open][indexterm2 is_open..file_stdio]
Returns `true` if the file is open. 
[heading Synopsis]```boolis_open() const;```[heading Description][endsect][section:native_handle file_stdio::native_handle][indexterm2 native_handle..file_stdio]
Returns the native handle associated with the file. 
```FILE*``[link beast.ref.boost__beast__file_stdio.native_handle.overload1 native_handle]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__file_stdio.native_handle.overload1 more...]]`````
Set the native handle associated with the file. 
```void``[link beast.ref.boost__beast__file_stdio.native_handle.overload2 native_handle]``(    FILE* f);  ``[''''&raquo;''' [link beast.ref.boost__beast__file_stdio.native_handle.overload2 more...]]`````[section:overload1 file_stdio::native_handle (1 of 2 overloads)]
Returns the native handle associated with the file. 
[heading Synopsis]```FILE*native_handle() const;```[heading Description][endsect][section:overload2 file_stdio::native_handle (2 of 2 overloads)]
Set the native handle associated with the file. 
[heading Synopsis]```voidnative_handle(    FILE* f);```[heading Description]
If the file is open it is first closed.

[heading Parameters][table [[Name][Description]]  [[`f`][    The native file handle to assign.   ]]]

[endsect][endsect][section:native_handle_type file_stdio::native_handle_type][indexterm2 native_handle_type..file_stdio]
The type of the underlying file handle. 
[heading Synopsis]```using native_handle_type = FILE*;```[heading Description]
This is platform-specific. 
[endsect][section:open file_stdio::open][indexterm2 open..file_stdio]
Open a file at the given path with the specified mode. 
[heading Synopsis]```voidopen(    char const* path,    file_mode mode,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`path`][    The utf-8 encoded path to the file  ]]  [[`mode`][    The file mode to use  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:operator_eq_ file_stdio::operator=][indexterm2 operator=..file_stdio]
Assignment. 
[heading Synopsis]```file_stdio&operator=(    file_stdio&& other);```[heading Description]
The moved-from object behaves as if default constructed. 
[endsect][section:pos file_stdio::pos][indexterm2 pos..file_stdio]
Return the current position in the open file. 
[heading Synopsis]```std::uint64_tpos(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred  ]]]
[heading Return Value]
The offset in bytes from the beginning of the file 


[endsect][section:read file_stdio::read][indexterm2 read..file_stdio]
Read from the open file. 
[heading Synopsis]```std::size_tread(    void* buffer,    std::size_t n,    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    The buffer for storing the result of the read  ]]  [[`n`][    The number of bytes to read  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:seek file_stdio::seek][indexterm2 seek..file_stdio]
Adjust the current position in the open file. 
[heading Synopsis]```voidseek(    std::uint64_t offset,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`offset`][    The offset in bytes from the beginning of the file  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:size file_stdio::size][indexterm2 size..file_stdio]
Return the size of the open file. 
[heading Synopsis]```std::uint64_tsize(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred  ]]]
[heading Return Value]
The size in bytes 


[endsect][section:write file_stdio::write][indexterm2 write..file_stdio]
Write to the open file. 
[heading Synopsis]```std::size_twrite(    void const* buffer,    std::size_t n,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    The buffer holding the data to write  ]]  [[`n`][    The number of bytes to write  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:file_stdio_dtor_ file_stdio::~file_stdio][indexterm2 ~file_stdio..file_stdio]
Destructor. 
[heading Synopsis]```~file_stdio();```[heading Description]
If the file is open it is first closed. 
[endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__file_win32 file_win32]
An implementation of File for Win32. 
[heading Synopsis]Defined in header [include_file boost/beast/core/file_win32.hpp]```class file_win32```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file_win32.native_handle_type [*native_handle_type]]]    [      The type of the underlying file handle.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__file_win32.close [*close]]]    [      Close the file if open.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.file_win32 [*file_win32]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.is_open [*is_open]]]    [      Returns true if the file is open.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.native_handle [*native_handle]]]    [      Returns the native handle associated with the file.       Set the native handle associated with the file.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.open [*open]]]    [      Open a file at the given path with the specified mode.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.pos [*pos]]]    [      Return the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.read [*read]]]    [      Read from the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.seek [*seek]]]    [      Adjust the current position in the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.size [*size]]]    [      Return the size of the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.write [*write]]]    [      Write to the open file.     ]  ]  [    [[link beast.ref.boost__beast__file_win32.file_win32_dtor_ [*~file_win32]]]    [      Destructor.     ]  ]][heading Description]
This class implements a [*File] using Win32 native interfaces. 
[section:close file_win32::close][indexterm2 close..file_win32]
Close the file if open. 
[heading Synopsis]```voidclose(    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred.   ]]]

[endsect][section:file_win32 file_win32::file_win32][indexterm2 file_win32..file_win32]
Constructor. 
`````[link beast.ref.boost__beast__file_win32.file_win32.overload1 file_win32]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__file_win32.file_win32.overload1 more...]]````[link beast.ref.boost__beast__file_win32.file_win32.overload2 file_win32]``(    file_win32&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__file_win32.file_win32.overload2 more...]]`````[section:overload1 file_win32::file_win32 (1 of 2 overloads)]
Constructor. 
[heading Synopsis]```file_win32();```[heading Description]
There is no open file initially. 
[endsect][section:overload2 file_win32::file_win32 (2 of 2 overloads)]
Constructor. 
[heading Synopsis]```file_win32(    file_win32&& other);```[heading Description]
The moved-from object behaves as if default constructed. 
[endsect][endsect][section:is_open file_win32::is_open][indexterm2 is_open..file_win32]
Returns `true` if the file is open. 
[heading Synopsis]```boolis_open() const;```[heading Description][endsect][section:native_handle file_win32::native_handle][indexterm2 native_handle..file_win32]
Returns the native handle associated with the file. 
```native_handle_type``[link beast.ref.boost__beast__file_win32.native_handle.overload1 native_handle]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__file_win32.native_handle.overload1 more...]]`````
Set the native handle associated with the file. 
```void``[link beast.ref.boost__beast__file_win32.native_handle.overload2 native_handle]``(    native_handle_type h);  ``[''''&raquo;''' [link beast.ref.boost__beast__file_win32.native_handle.overload2 more...]]`````[section:overload1 file_win32::native_handle (1 of 2 overloads)]
Returns the native handle associated with the file. 
[heading Synopsis]```native_handle_typenative_handle();```[heading Description][endsect][section:overload2 file_win32::native_handle (2 of 2 overloads)]
Set the native handle associated with the file. 
[heading Synopsis]```voidnative_handle(    native_handle_type h);```[heading Description]
If the file is open it is first closed.

[heading Parameters][table [[Name][Description]]  [[`h`][    The native file handle to assign.   ]]]

[endsect][endsect][section:native_handle_type file_win32::native_handle_type][indexterm2 native_handle_type..file_win32]
The type of the underlying file handle. 
[heading Synopsis]```using native_handle_type = HANDLE;```[heading Description]
This is platform-specific. 
[endsect][section:open file_win32::open][indexterm2 open..file_win32]
Open a file at the given path with the specified mode. 
[heading Synopsis]```voidopen(    char const* path,    file_mode mode,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`path`][    The utf-8 encoded path to the file  ]]  [[`mode`][    The file mode to use  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:operator_eq_ file_win32::operator=][indexterm2 operator=..file_win32]
Assignment. 
[heading Synopsis]```file_win32&operator=(    file_win32&& other);```[heading Description]
The moved-from object behaves as if default constructed. 
[endsect][section:pos file_win32::pos][indexterm2 pos..file_win32]
Return the current position in the open file. 
[heading Synopsis]```std::uint64_tpos(    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred  ]]]
[heading Return Value]
The offset in bytes from the beginning of the file 


[endsect][section:read file_win32::read][indexterm2 read..file_win32]
Read from the open file. 
[heading Synopsis]```std::size_tread(    void* buffer,    std::size_t n,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    The buffer for storing the result of the read  ]]  [[`n`][    The number of bytes to read  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:seek file_win32::seek][indexterm2 seek..file_win32]
Adjust the current position in the open file. 
[heading Synopsis]```voidseek(    std::uint64_t offset,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`offset`][    The offset in bytes from the beginning of the file  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:size file_win32::size][indexterm2 size..file_win32]
Return the size of the open file. 
[heading Synopsis]```std::uint64_tsize(    error_code& ec) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred  ]]]
[heading Return Value]
The size in bytes 


[endsect][section:write file_win32::write][indexterm2 write..file_win32]
Write to the open file. 
[heading Synopsis]```std::size_twrite(    void const* buffer,    std::size_t n,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`buffer`][    The buffer holding the data to write  ]]  [[`n`][    The number of bytes to write  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:file_win32_dtor_ file_win32::~file_win32][indexterm2 ~file_win32..file_win32]
Destructor. 
[heading Synopsis]```~file_win32();```[heading Description]
If the file is open it is first closed. 
[endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__flat_buffer flat_buffer][indexterm1 flat_buffer][heading Synopsis]Defined in header [include_file boost/beast/core/flat_buffer.hpp]```using flat_buffer = basic_flat_buffer< std::allocator< char >>;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_flat_buffer.allocator_type [*allocator_type]]]    [      The type of allocator used.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.const_buffers_type [*const_buffers_type]]]    [      The type used to represent the input sequence as a list of buffers.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.mutable_buffers_type [*mutable_buffers_type]]]    [      The type used to represent the output sequence as a list of buffers.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer [*basic_flat_buffer]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.capacity [*capacity]]]    [      Return the maximum sum of input and output sizes that can be held without an allocation.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.commit [*commit]]]    [      Move bytes from the output sequence to the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.consume [*consume]]]    [      Remove bytes from the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.data [*data]]]    [      Get a list of buffers that represent the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.get_allocator [*get_allocator]]]    [      Returns a copy of the associated allocator.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.max_size [*max_size]]]    [      Return the maximum sum of the input and output sequence sizes.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.operator_eq_ [*operator=]]]    [      Assignment.       Copy assignment.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.prepare [*prepare]]]    [      Get a list of buffers that represent the output sequence, with the given size.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.shrink_to_fit [*shrink_to_fit]]]    [      Reallocate the buffer to fit the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.size [*size]]]    [      Returns the size of the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_flat_buffer.basic_flat_buffer_dtor_ [*~basic_flat_buffer]]]    [      Destructor.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_flat_buffer.swap [*swap]]]    [      Exchange two flat buffers.     ]  ]]
Objects of this type meet the requirements of [*DynamicBuffer] and offer additional invariants:


* Buffer sequences returned by [link beast.ref.boost__beast__basic_flat_buffer.data `basic_flat_buffer::data`] and [link beast.ref.boost__beast__basic_flat_buffer.prepare `basic_flat_buffer::prepare`] will always be of length one.


* A configurable maximum buffer size may be set upon construction. Attempts to exceed the buffer size will throw `std::length_error`.

Upon construction, a maximum size for the buffer may be specified. If this limit is exceeded, the `std::length_error` exception will be thrown.

[heading Remarks]
This class is designed for use with algorithms that take dynamic buffers as parameters, and are optimized for the case where the input sequence or output sequence is stored in a single contiguous buffer. 


Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__flat_static_buffer flat_static_buffer]
A [*DynamicBuffer] with a fixed size internal buffer. 
[heading Synopsis]Defined in header [include_file boost/beast/core/flat_static_buffer.hpp]```template<    std::size_t N>class flat_static_buffer :    public flat_static_buffer_base```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_static_buffer.const_buffers_type [*const_buffers_type]]]    [      The type used to represent the input sequence as a list of buffers.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.mutable_buffers_type [*mutable_buffers_type]]]    [      The type used to represent the output sequence as a list of buffers.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_static_buffer.base [*base]]]    [      Returns the flat_static_buffer_base portion of this object.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.capacity [*capacity]]]    [      Return the maximum sum of input and output sizes that can be held without an allocation.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.commit [*commit]]]    [      Move bytes from the output sequence to the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.consume [*consume]]]    [      Remove bytes from the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.data [*data]]]    [      Get a list of buffers that represent the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.flat_static_buffer [*flat_static_buffer]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.max_size [*max_size]]]    [      Return the maximum sum of the input and output sequence sizes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.prepare [*prepare]]]    [      Get a list of buffers that represent the output sequence, with the given size.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.reset [*reset]]]    [      Set the input and output sequences to size 0.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer.size [*size]]]    [      Return the size of the input sequence.     ]  ]][heading Protected Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_static_buffer.reset [*reset]]]    [      Reset the pointed-to buffer.     ]  ]][heading Description]
Buffer sequences returned by [link beast.ref.boost__beast__flat_static_buffer.data `flat_static_buffer::data`] and [link beast.ref.boost__beast__flat_static_buffer.prepare `flat_static_buffer::prepare`] will always be of length one. This implements a dynamic buffer using no memory allocations.

[heading Template Parameters][table [[Type][Description]]  [[`N`][    The number of bytes in the internal buffer.  ]]]
[heading Remarks]
To reduce the number of template instantiations when passing objects of this type in a deduced context, the signature of the receiving function should use [link beast.ref.boost__beast__flat_static_buffer_base `flat_static_buffer_base`] instead.

[heading See Also]
[link beast.ref.boost__beast__flat_static_buffer_base `flat_static_buffer_base`] 


[section:base flat_static_buffer::base][indexterm2 base..flat_static_buffer]
Returns the [link beast.ref.boost__beast__flat_static_buffer_base `flat_static_buffer_base`] portion of this object. 
```flat_static_buffer_base&``[link beast.ref.boost__beast__flat_static_buffer.base.overload1 base]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_static_buffer.base.overload1 more...]]``flat_static_buffer_base const&``[link beast.ref.boost__beast__flat_static_buffer.base.overload2 base]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_static_buffer.base.overload2 more...]]`````[section:overload1 flat_static_buffer::base (1 of 2 overloads)]
Returns the [link beast.ref.boost__beast__flat_static_buffer_base `flat_static_buffer_base`] portion of this object. 
[heading Synopsis]```flat_static_buffer_base&base();```[heading Description][endsect][section:overload2 flat_static_buffer::base (2 of 2 overloads)]
Returns the [link beast.ref.boost__beast__flat_static_buffer_base `flat_static_buffer_base`] portion of this object. 
[heading Synopsis]```flat_static_buffer_base const&base() const;```[heading Description][endsect][endsect][section:capacity flat_static_buffer::capacity][indexterm2 capacity..flat_static_buffer]
Return the maximum sum of input and output sizes that can be held without an allocation. 
[heading Synopsis]```std::size_t constexprcapacity() const;```[heading Description][endsect][section:commit flat_static_buffer::commit][indexterm2 commit..flat_static_buffer]
Move bytes from the output sequence to the input sequence. 
[heading Synopsis]```voidcommit(    std::size_t n);```[heading Description]
[heading Remarks]
Buffers representing the input sequence acquired prior to this call remain valid. 


[endsect][section:const_buffers_type flat_static_buffer::const_buffers_type][indexterm2 const_buffers_type..flat_static_buffer]
The type used to represent the input sequence as a list of buffers. 
[heading Synopsis]```using const_buffers_type = boost::asio::mutable_buffer;```[heading Description]
This buffer sequence is guaranteed to have length 1. 
[endsect][section:consume flat_static_buffer::consume][indexterm2 consume..flat_static_buffer]
Remove bytes from the input sequence. 
[heading Synopsis]```voidconsume(    std::size_t n);```[heading Description][endsect][section:data flat_static_buffer::data][indexterm2 data..flat_static_buffer]
Get a list of buffers that represent the input sequence. 
[heading Synopsis]```const_buffers_typedata() const;```[heading Description]
[heading Remarks]
These buffers remain valid across subsequent calls to `prepare`. 


[endsect][section:flat_static_buffer flat_static_buffer::flat_static_buffer][indexterm2 flat_static_buffer..flat_static_buffer]
Constructor. 
`````[link beast.ref.boost__beast__flat_static_buffer.flat_static_buffer.overload1 flat_static_buffer]``(    flat_static_buffer const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_static_buffer.flat_static_buffer.overload1 more...]]````[link beast.ref.boost__beast__flat_static_buffer.flat_static_buffer.overload2 flat_static_buffer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__flat_static_buffer.flat_static_buffer.overload2 more...]]`````[section:overload1 flat_static_buffer::flat_static_buffer (1 of 2 overloads)]
Constructor. 
[heading Synopsis]```flat_static_buffer(    flat_static_buffer const&);```[heading Description][endsect][section:overload2 flat_static_buffer::flat_static_buffer (2 of 2 overloads)]
Constructor. 
[heading Synopsis]```flat_static_buffer();```[heading Description][endsect][endsect][section:max_size flat_static_buffer::max_size][indexterm2 max_size..flat_static_buffer]
Return the maximum sum of the input and output sequence sizes. 
[heading Synopsis]```std::size_t constexprmax_size() const;```[heading Description][endsect][section:mutable_buffers_type flat_static_buffer::mutable_buffers_type][indexterm2 mutable_buffers_type..flat_static_buffer]
The type used to represent the output sequence as a list of buffers. 
[heading Synopsis]```using mutable_buffers_type = boost::asio::mutable_buffer;```[heading Description]
This buffer sequence is guaranteed to have length 1. 
[endsect][section:operator_eq_ flat_static_buffer::operator=][indexterm2 operator=..flat_static_buffer]
Assignment. 
[heading Synopsis]```flat_static_buffer&operator=(    flat_static_buffer const&);```[heading Description][endsect][section:prepare flat_static_buffer::prepare][indexterm2 prepare..flat_static_buffer]
Get a list of buffers that represent the output sequence, with the given size. 
[heading Synopsis]```mutable_buffers_typeprepare(    std::size_t n);```[heading Description]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    if the size would exceed the limit imposed by the underlying mutable buffer sequence.  ]]]
[heading Remarks]
Buffers representing the input sequence acquired prior to this call remain valid. 


[endsect][section:reset flat_static_buffer::reset][indexterm2 reset..flat_static_buffer]
Set the input and output sequences to size 0. 
[heading Synopsis]```voidreset();```[heading Description][endsect][section:reset flat_static_buffer::reset][indexterm2 reset..flat_static_buffer]
Reset the pointed-to buffer. 
[heading Synopsis]```voidreset(    void* p,    std::size_t n);```[heading Description]
This function resets the internal state to the buffer provided. All input and output sequences are invalidated. This function allows the derived class to construct its members before initializing the static buffer.

[heading Parameters][table [[Name][Description]]  [[`p`][    A pointer to valid storage of at least `n` bytes.  ]]  [[`n`][    The number of valid bytes pointed to by `p`.   ]]]

[endsect][section:size flat_static_buffer::size][indexterm2 size..flat_static_buffer]
Return the size of the input sequence. 
[heading Synopsis]```std::size_tsize() const;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__flat_static_buffer_base flat_static_buffer_base]
A flat [*DynamicBuffer] with a fixed size internal buffer. 
[heading Synopsis]Defined in header [include_file boost/beast/core/flat_static_buffer.hpp]```class flat_static_buffer_base```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.const_buffers_type [*const_buffers_type]]]    [      The type used to represent the input sequence as a list of buffers.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.mutable_buffers_type [*mutable_buffers_type]]]    [      The type used to represent the output sequence as a list of buffers.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.capacity [*capacity]]]    [      Return the maximum sum of input and output sizes that can be held without an allocation.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.commit [*commit]]]    [      Move bytes from the output sequence to the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.consume [*consume]]]    [      Remove bytes from the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.data [*data]]]    [      Get a list of buffers that represent the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.flat_static_buffer_base [*flat_static_buffer_base]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.max_size [*max_size]]]    [      Return the maximum sum of the input and output sequence sizes.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.prepare [*prepare]]]    [      Get a list of buffers that represent the output sequence, with the given size.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.reset [*reset]]]    [      Set the input and output sequences to size 0.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.size [*size]]]    [      Return the size of the input sequence.     ]  ]][heading Protected Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.flat_static_buffer_base [*flat_static_buffer_base]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__flat_static_buffer_base.reset [*reset]]]    [      Reset the pointed-to buffer.     ]  ]][heading Description]
Buffer sequences returned by [link beast.ref.boost__beast__flat_static_buffer.data `flat_static_buffer::data`] and [link beast.ref.boost__beast__flat_static_buffer.prepare `flat_static_buffer::prepare`] will always be of length one. Ownership of the underlying storage belongs to the derived class.

[heading Remarks]
Variables are usually declared using the template class [link beast.ref.boost__beast__flat_static_buffer `flat_static_buffer`]; however, to reduce the number of instantiations of template functions receiving static stream buffer arguments in a deduced context, the signature of the receiving function should use [link beast.ref.boost__beast__flat_static_buffer_base `flat_static_buffer_base`].

When used with [link beast.ref.boost__beast__flat_static_buffer `flat_static_buffer`] this implements a dynamic buffer using no memory allocations.

[heading See Also]
[link beast.ref.boost__beast__flat_static_buffer `flat_static_buffer`] 


[section:capacity flat_static_buffer_base::capacity][indexterm2 capacity..flat_static_buffer_base]
Return the maximum sum of input and output sizes that can be held without an allocation. 
[heading Synopsis]```std::size_tcapacity() const;```[heading Description][endsect][section:commit flat_static_buffer_base::commit][indexterm2 commit..flat_static_buffer_base]
Move bytes from the output sequence to the input sequence. 
[heading Synopsis]```voidcommit(    std::size_t n);```[heading Description]
[heading Remarks]
Buffers representing the input sequence acquired prior to this call remain valid. 


[endsect][section:const_buffers_type flat_static_buffer_base::const_buffers_type][indexterm2 const_buffers_type..flat_static_buffer_base]
The type used to represent the input sequence as a list of buffers. 
[heading Synopsis]```using const_buffers_type = boost::asio::mutable_buffer;```[heading Description]
This buffer sequence is guaranteed to have length 1. 
[endsect][section:consume flat_static_buffer_base::consume][indexterm2 consume..flat_static_buffer_base]
Remove bytes from the input sequence. 
[heading Synopsis]```voidconsume(    std::size_t n);```[heading Description][endsect][section:data flat_static_buffer_base::data][indexterm2 data..flat_static_buffer_base]
Get a list of buffers that represent the input sequence. 
[heading Synopsis]```const_buffers_typedata() const;```[heading Description]
[heading Remarks]
These buffers remain valid across subsequent calls to `prepare`. 


[endsect][section:flat_static_buffer_base flat_static_buffer_base::flat_static_buffer_base][indexterm2 flat_static_buffer_base..flat_static_buffer_base]
Constructor. 
[heading Synopsis]```flat_static_buffer_base(    void* p,    std::size_t n);```[heading Description]
This creates a dynamic buffer using the provided storage area.

[heading Parameters][table [[Name][Description]]  [[`p`][    A pointer to valid storage of at least `n` bytes.  ]]  [[`n`][    The number of valid bytes pointed to by `p`.   ]]]

[endsect][section:flat_static_buffer_base flat_static_buffer_base::flat_static_buffer_base][indexterm2 flat_static_buffer_base..flat_static_buffer_base]
Constructor. 
[heading Synopsis]```flat_static_buffer_base();```[heading Description]
The buffer will be in an undefined state. It is necessary for the derived class to call [link beast.ref.boost__beast__flat_static_buffer.reset `flat_static_buffer::reset`] with a pointer and size in order to initialize the object. 
[endsect][section:max_size flat_static_buffer_base::max_size][indexterm2 max_size..flat_static_buffer_base]
Return the maximum sum of the input and output sequence sizes. 
[heading Synopsis]```std::size_tmax_size() const;```[heading Description][endsect][section:mutable_buffers_type flat_static_buffer_base::mutable_buffers_type][indexterm2 mutable_buffers_type..flat_static_buffer_base]
The type used to represent the output sequence as a list of buffers. 
[heading Synopsis]```using mutable_buffers_type = boost::asio::mutable_buffer;```[heading Description]
This buffer sequence is guaranteed to have length 1. 
[endsect][section:prepare flat_static_buffer_base::prepare][indexterm2 prepare..flat_static_buffer_base]
Get a list of buffers that represent the output sequence, with the given size. 
[heading Synopsis]```mutable_buffers_typeprepare(    std::size_t n);```[heading Description]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    if the size would exceed the limit imposed by the underlying mutable buffer sequence.  ]]]
[heading Remarks]
Buffers representing the input sequence acquired prior to this call remain valid. 


[endsect][section:reset flat_static_buffer_base::reset][indexterm2 reset..flat_static_buffer_base]
Set the input and output sequences to size 0. 
[heading Synopsis]```voidreset();```[heading Description][endsect][section:reset flat_static_buffer_base::reset][indexterm2 reset..flat_static_buffer_base]
Reset the pointed-to buffer. 
[heading Synopsis]```voidreset(    void* p,    std::size_t n);```[heading Description]
This function resets the internal state to the buffer provided. All input and output sequences are invalidated. This function allows the derived class to construct its members before initializing the static buffer.

[heading Parameters][table [[Name][Description]]  [[`p`][    A pointer to valid storage of at least `n` bytes.  ]]  [[`n`][    The number of valid bytes pointed to by `p`.   ]]]

[endsect][section:size flat_static_buffer_base::size][indexterm2 size..flat_static_buffer_base]
Return the size of the input sequence. 
[heading Synopsis]```std::size_tsize() const;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__generic_category generic_category][indexterm1 generic_category]
A function to return the generic error category used by the library. 
[heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```error_category const&generic_category();```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__get_lowest_layer get_lowest_layer]
Returns `T::lowest_layer_type` if it exists, else `T` 
[heading Synopsis]Defined in header [include_file boost/beast/core/type_traits.hpp]```template<    class T>struct get_lowest_layer```[heading Description]
This will contain a nested `type` equal to `T::lowest_layer_type` if it exists, else `type` will be equal to `T`.

[heading Example]


Declaring a wrapper:



  template<class Stream>
  struct stream_wrapper
  {
      using next_layer_type = typename std::remove_reference<Stream>::type;
      using lowest_layer_type = typename get_lowest_layer<stream_type>::type;
  };




Defining a metafunction:



  template<class T>
  using is_stream_wrapper : std::integral_constant<bool,
      ! std::is_same<T, typename get_lowest_layer<T>::type>::value> {};



Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__handler_ptr handler_ptr]
A smart pointer container with associated completion handler. 
[heading Synopsis]Defined in header [include_file boost/beast/core/handler_ptr.hpp]```template<    class T,    class __Handler__>class handler_ptr```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__handler_ptr.element_type [*element_type]]]    [      The type of element this object stores.     ]  ]  [    [[link beast.ref.boost__beast__handler_ptr.handler_type [*handler_type]]]    [      The type of handler this object stores.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__handler_ptr.get [*get]]]    [      Returns a pointer to the owned object.     ]  ]  [    [[link beast.ref.boost__beast__handler_ptr.handler [*handler]]]    [      Returns a reference to the handler.     ]  ]  [    [[link beast.ref.boost__beast__handler_ptr.handler_ptr [*handler_ptr]]]    [      Move constructor.       Copy constructor.       Construct a new handler_ptr.     ]  ]  [    [[link beast.ref.boost__beast__handler_ptr.invoke [*invoke]]]    [      Invoke the handler in the owned object.     ]  ]  [    [[link beast.ref.boost__beast__handler_ptr.operator_bool [*operator bool]]]    [      Returns true if *this owns an object.     ]  ]  [    [[link beast.ref.boost__beast__handler_ptr.operator_star_ [*operator*]]]    [      Return a reference to the owned object.     ]  ]  [    [[link beast.ref.boost__beast__handler_ptr.operator_arrow_ [*operator->]]]    [      Return a pointer to the owned object.     ]  ]  [    [[link beast.ref.boost__beast__handler_ptr.operator_eq_ [*operator=]]]    [      Copy assignment (disallowed).     ]  ]  [    [[link beast.ref.boost__beast__handler_ptr.release_handler [*release_handler]]]    [      Release ownership of the handler.     ]  ]  [    [[link beast.ref.boost__beast__handler_ptr.handler_ptr_dtor_ [*~handler_ptr]]]    [      Destructs the owned object if no more handler_ptr link to it.     ]  ]][heading Description]
This is a smart pointer that retains shared ownership of an object through a pointer. Memory is managed using the allocation and deallocation functions associated with a completion handler, which is also stored in the object. The managed object is destroyed and its memory deallocated when one of the following happens:


* The function [link beast.ref.boost__beast__handler_ptr.invoke `handler_ptr::invoke`] is called.


* The function [link beast.ref.boost__beast__handler_ptr.release_handler `handler_ptr::release_handler`] is called.


* The last remaining container owning the object is destroyed.

Objects of this type are used in the implementation of composed operations. Typically the composed operation's shared state is managed by the [link beast.ref.boost__beast__handler_ptr `handler_ptr`] and an allocator associated with the final handler is used to create the managed object.

[heading Remarks]
The reference count is stored using a 16 bit unsigned integer. Making more than 2^16 copies of one object results in undefined behavior.

[heading Template Parameters][table [[Type][Description]]  [[`T`][    The type of the owned object.  ]]  [[`Handler`][    The type of the completion handler.   ]]]

[section:element_type handler_ptr::element_type][indexterm2 element_type..handler_ptr]
The type of element this object stores. 
[heading Synopsis]```using element_type = T;```[heading Description][endsect][section:get handler_ptr::get][indexterm2 get..handler_ptr]
Returns a pointer to the owned object. 
[heading Synopsis]```T*get() const;```[heading Description]
If `*this` owns an object, a pointer to the object is returned, else `nullptr` is returned. 
[endsect][section:handler handler_ptr::handler][indexterm2 handler..handler_ptr]
Returns a reference to the handler. 
[heading Synopsis]```handler_type&handler() const;```[heading Description][endsect][section:handler_ptr handler_ptr::handler_ptr][indexterm2 handler_ptr..handler_ptr]
Move constructor. 
`````[link beast.ref.boost__beast__handler_ptr.handler_ptr.overload1 handler_ptr]``(    handler_ptr&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__handler_ptr.handler_ptr.overload1 more...]]`````
Copy constructor. 
`````[link beast.ref.boost__beast__handler_ptr.handler_ptr.overload2 handler_ptr]``(    handler_ptr const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__handler_ptr.handler_ptr.overload2 more...]]`````
Construct a new [link beast.ref.boost__beast__handler_ptr `handler_ptr`]. 
```template<    class... Args>``[link beast.ref.boost__beast__handler_ptr.handler_ptr.overload3 handler_ptr]``(    Handler&& handler,    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__handler_ptr.handler_ptr.overload3 more...]]``template<    class... Args>``[link beast.ref.boost__beast__handler_ptr.handler_ptr.overload4 handler_ptr]``(    Handler const& handler,    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__handler_ptr.handler_ptr.overload4 more...]]`````[section:overload1 handler_ptr::handler_ptr (1 of 4 overloads)]
Move constructor. 
[heading Synopsis]```handler_ptr(    handler_ptr&& other);```[heading Description]
When this call returns, the moved-from container will have no owned object. 
[endsect][section:overload2 handler_ptr::handler_ptr (2 of 4 overloads)]
Copy constructor. 
[heading Synopsis]```handler_ptr(    handler_ptr const& other);```[heading Description][endsect][section:overload3 handler_ptr::handler_ptr (3 of 4 overloads)]
Construct a new [link beast.ref.boost__beast__handler_ptr `handler_ptr`]. 
[heading Synopsis]```template<    class... Args>handler_ptr(    Handler&& handler,    Args&&... args);```[heading Description]
This creates a new [link beast.ref.boost__beast__handler_ptr `handler_ptr`] with an owned object of type `T`. The allocator associated with the handler will be used to allocate memory for the owned object. The constructor for the owned object will be called thusly:



  T(handler, std::forward<Args>(args)...)




[heading Parameters][table [[Name][Description]]  [[`handler`][    The handler to associate with the owned object. The argument will be moved.  ]]  [[`args`][    Optional arguments forwarded to the owned object's constructor.   ]]]

[endsect][section:overload4 handler_ptr::handler_ptr (4 of 4 overloads)]
Construct a new [link beast.ref.boost__beast__handler_ptr `handler_ptr`]. 
[heading Synopsis]```template<    class... Args>handler_ptr(    Handler const& handler,    Args&&... args);```[heading Description]
This creates a new [link beast.ref.boost__beast__handler_ptr `handler_ptr`] with an owned object of type `T`. The allocator associated with the handler will be used to allocate memory for the owned object. The constructor for the owned object will be called thusly:



  T(handler, std::forward<Args>(args)...)




[heading Parameters][table [[Name][Description]]  [[`handler`][    The handler to associate with the owned object. The argument will be copied.  ]]  [[`args`][    Optional arguments forwarded to the owned object's constructor.   ]]]

[endsect][endsect][section:handler_type handler_ptr::handler_type][indexterm2 handler_type..handler_ptr]
The type of handler this object stores. 
[heading Synopsis]```using handler_type = Handler;```[heading Description][endsect][section:invoke handler_ptr::invoke][indexterm2 invoke..handler_ptr]
Invoke the handler in the owned object. 
[heading Synopsis]```template<    class... Args>voidinvoke(    Args&&... args);```[heading Description]
This function invokes the handler in the owned object with a forwarded argument list. Before the invocation, the owned object is destroyed, satisfying the deallocation-before-invocation Asio guarantee. All instances of [link beast.ref.boost__beast__handler_ptr `handler_ptr`] which refer to the same owned object will be reset, including this instance.

[heading Remarks]
Care must be taken when the arguments are themselves stored in the owned object. Such arguments must first be moved to the stack or elsewhere, and then passed, or else undefined behavior will result. 


[endsect][section:operator_bool handler_ptr::operator bool][indexterm2 operator bool..handler_ptr]
Returns `true` if `*this` owns an object. 
[heading Synopsis]```operator bool() const;```[heading Description][endsect][section:operator_star_ handler_ptr::operator*][indexterm2 operator*..handler_ptr]
Return a reference to the owned object. 
[heading Synopsis]```T&operator*() const;```[heading Description][endsect][section:operator_arrow_ handler_ptr::operator->][indexterm2 operator->..handler_ptr]
Return a pointer to the owned object. 
[heading Synopsis]```T*operator->() const;```[heading Description][endsect][section:operator_eq_ handler_ptr::operator=][indexterm2 operator=..handler_ptr]
Copy assignment (disallowed). 
[heading Synopsis]```handler_ptr&operator=(    handler_ptr const&);```[heading Description][endsect][section:release_handler handler_ptr::release_handler][indexterm2 release_handler..handler_ptr]
Release ownership of the handler. 
[heading Synopsis]```handler_typerelease_handler();```[heading Description]
If `*this` owns an object, it is first destroyed.

[heading Return Value]
The released handler. 


[endsect][section:handler_ptr_dtor_ handler_ptr::~handler_ptr][indexterm2 ~handler_ptr..handler_ptr]
Destructs the owned object if no more [link beast.ref.boost__beast__handler_ptr `handler_ptr`] link to it. 
[heading Synopsis]```~handler_ptr();```[heading Description]
If `*this` owns an object and it is the last [link beast.ref.boost__beast__handler_ptr `handler_ptr`] owning it, the object is destroyed and the memory deallocated using the associated deallocator. 
[endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__handler_ptr__P handler_ptr::P][heading Synopsis]Defined in header [include_file boost/beast/core/handler_ptr.hpp]```struct P```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__handler_ptr__P.P [*P]]]    [          ]  ]][heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__handler_ptr__P.handler [*handler]]]    [          ]  ]  [    [[link beast.ref.boost__beast__handler_ptr__P.n [*n]]]    [          ]  ]  [    [[link beast.ref.boost__beast__handler_ptr__P.t [*t]]]    [          ]  ]][heading Description][section:P handler_ptr::P::P][indexterm2 P..handler_ptr::P][heading Synopsis]```template<    class DeducedHandler,    class... Args>P(    DeducedHandler&& handler,    Args&&... args);```[heading Description][endsect][section:handler handler_ptr::P::handler][indexterm2 handler..handler_ptr::P][heading Synopsis]```Handler handler;```[heading Description][endsect][section:n handler_ptr::P::n][indexterm2 n..handler_ptr::P][heading Synopsis]```std::atomic< std::uint16_t > n;```[heading Description][endsect][section:t handler_ptr::P::t][indexterm2 t..handler_ptr::P][heading Synopsis]```T * t;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__has_get_executor has_get_executor]
Determine if `T` has the `get_executor` member function. 
[heading Synopsis]Defined in header [include_file boost/beast/core/type_traits.hpp]```template<    class T>struct has_get_executor :    public std::integral_constant< bool,...>```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` has the member function with the correct signature, else type will be `std::false_type`.

[heading Example]


Use with tag dispatching:



  template<class T>
  void maybe_hello(T& t, std::true_type)
  {
      boost::asio::post(
          t.get_executor(),
          []
          {
              std::cout << "Hello, world!" << std::endl;
          });
  }

  template<class T>
  void maybe_hello(T&, std::false_type)
  {
      // T does not have get_executor
  }

  template<class T>
  void maybe_hello(T& t)
  {
      maybe_hello(t, has_get_executor<T>{});
  }




Use with `static_assert`:



  struct stream
  {
      using executor_type = boost::asio::io_context::executor_type;
      executor_type get_executor() noexcept;
  };

  static_assert(has_get_executor<stream>::value, "Missing get_executor member");



Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__http__async_read http::async_read][indexterm1 http::async_read]
Read a complete message from a stream asynchronously using a parser. 
```template<    class __AsyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived,    class __ReadHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__http__async_read.overload1 async_read]``(    AsyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser,    ReadHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__async_read.overload1 more...]]`````
Read a complete message from a stream asynchronously. 
```template<    class __AsyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class Allocator,    class __ReadHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__http__async_read.overload2 async_read]``(    AsyncReadStream& stream,    DynamicBuffer& buffer,    message< isRequest, Body, basic_fields< Allocator >>& msg,    ReadHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__async_read.overload2 more...]]`````[section:overload1 http::async_read (1 of 2 overloads)]
Read a complete message from a stream asynchronously using a parser. 
[heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __AsyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived,    class __ReadHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_read(    AsyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read a complete message from a stream into a subclass of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* [link beast.ref.boost__beast__http__basic_parser.is_done `http::basic_parser::is_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `async_read_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other reads until this operation completes. The implementation may read additional octets that lie past the end of the message being read. This additional data is stored in the dynamic buffer, which must be retained for subsequent reads.

If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:


* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no octets were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any octets were parsed but the message was incomplete, otherwise:


* A successful result. A subsequent attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream from which the data is to be read. The type must support the AsyncReadStream concept.  ]]  [[`buffer`][    A DynamicBuffer holding additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, any data in the dynamic buffer's input sequence will be given to the parser first.  ]]  [[`parser`][    The parser to use. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& error,        // result of operation,
      std::size_t bytes_transferred   // the number of bytes transferred to the parser
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
[heading Remarks]
The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `true` on the parser passed in. 


Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::async_read (2 of 2 overloads)]
Read a complete message from a stream asynchronously. 
[heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __AsyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class Allocator,    class __ReadHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_read(    AsyncReadStream& stream,    DynamicBuffer& buffer,    message< isRequest, Body, basic_fields< Allocator >>& msg,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read a complete message from a stream using HTTP/1. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The entire message is read.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `async_read_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other reads until this operation completes. The implementation may read additional octets that lie past the end of the message being read. This additional data is stored in the dynamic buffer, which must be retained for subsequent reads.

If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:


* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no octets were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any octets were parsed but the message was incomplete, otherwise:


* A successful result. A subsequent attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream from which the data is to be read. The type must support the AsyncReadStream concept.  ]]  [[`buffer`][    A DynamicBuffer holding additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, any data in the dynamic buffer's input sequence will be given to the parser first.  ]]  [[`msg`][    An object in which to store the message contents. This object should not have previous contents, otherwise the behavior is undefined. The type must be MoveAssignable and MoveConstructible.  ]]]
The object must remain valid at least until the handler is called; ownership is not transferred.

[heading Parameters][table [[Name][Description]]  [[`handler`][    The handler to be called when the operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& error,        // result of operation,
      std::size_t bytes_transferred   // the number of bytes transferred to the parser
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__async_read_header http::async_read_header][indexterm1 http::async_read_header]
Read a header from a stream asynchronously using a parser. 
[heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __AsyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived,    class __ReadHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_read_header(    AsyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read a header from a stream into a subclass of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `async_read_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other reads until this operation completes. The implementation may read additional octets that lie past the end of the message being read. This additional data is stored in the dynamic buffer, which must be retained for subsequent reads.

If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:


* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no octets were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any octets were parsed but the message was incomplete, otherwise:


* A successful result. A subsequent attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream from which the data is to be read. The type must support the AsyncReadStream concept.  ]]  [[`buffer`][    A DynamicBuffer holding additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, any data in the dynamic buffer's input sequence will be given to the parser first.  ]]  [[`parser`][    The parser to use. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& error,        // result of operation,
      std::size_t bytes_transferred   // the number of bytes transferred to the parser
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
[heading Remarks]
The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `false` on the parser passed in. 


Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__async_read_some http::async_read_some][indexterm1 http::async_read_some]
Read part of a message asynchronously from a stream using a parser. 
[heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __AsyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived,    class __ReadHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_read_some(    AsyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read part of a message from a stream into a subclass of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* A call to [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] with a non-empty buffer sequence is successful.


* An error occurs.

This operation is implemented in terms of zero or more calls to the next layer's `async_read_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other reads until this operation completes. The implementation may read additional octets that lie past the end of the object being parsed. This additional data is stored in the stream buffer, which may be used in subsequent calls.

If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:


* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no octets were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any octets were parsed but the message was incomplete, otherwise:


* A successful result. A subsequent attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream from which the data is to be read. The type must support the AsyncReadStream concept.  ]]  [[`buffer`][    A DynamicBuffer holding additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, any data in the dynamic buffer's input sequence will be given to the parser first.  ]]  [[`parser`][    The parser to use. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the number of bytes transferred to the parser
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
The completion handler will receive as a parameter the number of octets processed from the dynamic buffer. The octets should be removed by calling `consume` on the dynamic buffer after the read completes, regardless of any error. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__async_write http::async_write][indexterm1 http::async_write]
Write a complete message to a stream asynchronously using a serializer. 
```template<    class __AsyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``,    class __WriteHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__http__async_write.overload1 async_write]``(    AsyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    WriteHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__async_write.overload1 more...]]`````
Write a complete message to a stream asynchronously. 
```template<    class __AsyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``,    class __WriteHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__http__async_write.overload2 async_write]``(    AsyncWriteStream& stream,    message< isRequest, Body, Fields >& msg,    WriteHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__async_write.overload2 more...]]`````[section:overload1 http::async_write (1 of 2 overloads)]
Write a complete message to a stream asynchronously using a serializer. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __AsyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``,    class __WriteHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_write(    AsyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    WriteHandler&& handler);```[heading Description]
This function is used to write a complete message to a stream asynchronously using a caller-provided HTTP/1 serializer. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] returns `true`


* An error occurs.

This operation is implemented in terms of zero or more calls to the stream's `async_write_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other writes until this operation completes.

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream to which the data is to be written. The type must support the AsyncWriteStream concept.  ]]  [[`sr`][    The serializer to use. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    The handler to be called when the operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the number of bytes written to the stream
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 


Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::async_write (2 of 2 overloads)]
Write a complete message to a stream asynchronously. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __AsyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``,    class __WriteHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_write(    AsyncWriteStream& stream,    message< isRequest, Body, Fields >& msg,    WriteHandler&& handler);```[heading Description]
This function is used to write a complete message to a stream asynchronously using HTTP/1. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The entire message is written.


* An error occurs.

This operation is implemented in terms of zero or more calls to the stream's `async_write_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other writes until this operation completes. The algorithm will use a temporary [link beast.ref.boost__beast__http__serializer `http::serializer`] with an empty chunk decorator to produce buffers.

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream to which the data is to be written. The type must support the AsyncWriteStream concept.  ]]  [[`msg`][    The message to write. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    The handler to be called when the operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the number of bytes written to the stream
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__message `http::message`] 


Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__async_write_header http::async_write_header][indexterm1 http::async_write_header]
Write a header to a stream asynchronously using a serializer. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __AsyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``,    class __WriteHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_write_header(    AsyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    WriteHandler&& handler);```[heading Description]
This function is used to write a header to a stream asynchronously using a caller-provided HTTP/1 serializer. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The function [link beast.ref.boost__beast__http__serializer.is_header_done `http::serializer::is_header_done`] returns `true`


* An error occurs.

This operation is implemented in terms of zero or more calls to the stream's `async_write_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other writes until this operation completes.

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream to which the data is to be written. The type must support the AsyncWriteStream concept.  ]]  [[`sr`][    The serializer to use. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    The handler to be called when the operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the number of bytes written to the stream
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
[heading Remarks]
The implementation will call [link beast.ref.boost__beast__http__serializer.split `http::serializer::split`] with the value `true` on the serializer passed in.

[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 


Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__async_write_some http::async_write_some][indexterm1 http::async_write_some]
Write part of a message to a stream asynchronously using a serializer. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __AsyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``,    class __WriteHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_write_some(    AsyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    WriteHandler&& handler);```[heading Description]
This function is used to write part of a message to a stream asynchronously using a caller-provided HTTP/1 serializer. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* One or more bytes have been transferred.


* The function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] returns `true`


* An error occurs on the stream.

This operation is implemented in terms of zero or more calls to the stream's `async_write_some` function, and is known as a ['composed operation]. The program must ensure that the stream performs no other writes until this operation completes.

The amount of data actually transferred is controlled by the behavior of the underlying stream, subject to the buffer size limit of the serializer obtained or set through a call to [link beast.ref.boost__beast__http__serializer.limit `http::serializer::limit`]. Setting a limit and performing bounded work helps applications set reasonable timeouts. It also allows application-level flow control to function correctly. For example when using a TCP/IP based stream.

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream to which the data is to be written. The type must support the AsyncWriteStream concept.  ]]  [[`sr`][    The serializer to use. The object must remain valid at least until the handler is called; ownership is not transferred.  ]]  [[`handler`][    The handler to be called when the operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& error,        // result of operation
      std::size_t bytes_transferred   // the number of bytes written to the stream
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 


Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_chunk_extensions http::basic_chunk_extensions]
A set of chunk extensions. 
[heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```template<    class Allocator>class basic_chunk_extensions```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.value_type [*value_type]]]    [      The type of value when iterating.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions [*basic_chunk_extensions]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.begin [*begin]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.clear [*clear]]]    [      Clear the chunk extensions.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.end [*end]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.insert [*insert]]]    [      Insert an extension name with an empty value.       Insert an extension value.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.parse [*parse]]]    [      Parse a set of chunk extensions.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.str [*str]]]    [      Return the serialized representation of the chunk extension.     ]  ]][heading Description]
This container stores a set of chunk extensions suited for use with [link beast.ref.boost__beast__http__chunk_header `http::chunk_header`] and [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`]. The container may be iterated to access the extensions in their structured form.

Meets the requirements of ChunkExtensions 
[section:basic_chunk_extensions http::basic_chunk_extensions::basic_chunk_extensions][indexterm2 basic_chunk_extensions..http::basic_chunk_extensions]
Constructor. 
`````[link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload1 basic_chunk_extensions]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload1 more...]]````[link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload2 basic_chunk_extensions]``(    basic_chunk_extensions&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload2 more...]]````[link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload3 basic_chunk_extensions]``(    basic_chunk_extensions const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload3 more...]]``explicit``[link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload4 basic_chunk_extensions]``(    Allocator const& allocator);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions.overload4 more...]]`````[section:overload1 http::basic_chunk_extensions::basic_chunk_extensions (1 of 4 overloads)]
Constructor. 
[heading Synopsis]```basic_chunk_extensions();```[heading Description][endsect][section:overload2 http::basic_chunk_extensions::basic_chunk_extensions (2 of 4 overloads)]
Constructor. 
[heading Synopsis]```basic_chunk_extensions(    basic_chunk_extensions&&);```[heading Description][endsect][section:overload3 http::basic_chunk_extensions::basic_chunk_extensions (3 of 4 overloads)]
Constructor. 
[heading Synopsis]```basic_chunk_extensions(    basic_chunk_extensions const&);```[heading Description][endsect][section:overload4 http::basic_chunk_extensions::basic_chunk_extensions (4 of 4 overloads)]
Constructor. 
[heading Synopsis]```basic_chunk_extensions(    Allocator const& allocator);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`allocator`][    The allocator to use for storing the serialized extension   ]]]

[endsect][endsect][section:begin http::basic_chunk_extensions::begin][indexterm2 begin..http::basic_chunk_extensions][heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:clear http::basic_chunk_extensions::clear][indexterm2 clear..http::basic_chunk_extensions]
Clear the chunk extensions. 
[heading Synopsis]```voidclear();```[heading Description]
This preserves the capacity of the internal string used to hold the serialized representation. 
[endsect][section:end http::basic_chunk_extensions::end][indexterm2 end..http::basic_chunk_extensions][heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:insert http::basic_chunk_extensions::insert][indexterm2 insert..http::basic_chunk_extensions]
Insert an extension name with an empty value. 
```void``[link beast.ref.boost__beast__http__basic_chunk_extensions.insert.overload1 insert]``(    string_view name);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_chunk_extensions.insert.overload1 more...]]`````
Insert an extension value. 
```void``[link beast.ref.boost__beast__http__basic_chunk_extensions.insert.overload2 insert]``(    string_view name,    string_view value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_chunk_extensions.insert.overload2 more...]]`````[section:overload1 http::basic_chunk_extensions::insert (1 of 2 overloads)]
Insert an extension name with an empty value. 
[heading Synopsis]```voidinsert(    string_view name);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`name`][    The name of the extension   ]]]

[endsect][section:overload2 http::basic_chunk_extensions::insert (2 of 2 overloads)]
Insert an extension value. 
[heading Synopsis]```voidinsert(    string_view name,    string_view value);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`name`][    The name of the extension  ]]  [[`value`][    The value to insert. Depending on the contents, the serialized extension may use a quoted string.   ]]]

[endsect][endsect][section:parse http::basic_chunk_extensions::parse][indexterm2 parse..http::basic_chunk_extensions]
Parse a set of chunk extensions. 
[heading Synopsis]```voidparse(    string_view s,    error_code& ec);```[heading Description]
Any previous extensions will be cleared 
[endsect][section:str http::basic_chunk_extensions::str][indexterm2 str..http::basic_chunk_extensions]
Return the serialized representation of the chunk extension. 
[heading Synopsis]```string_viewstr() const;```[heading Description][endsect][section:value_type http::basic_chunk_extensions::value_type][indexterm2 value_type..http::basic_chunk_extensions]
The type of value when iterating. 
[heading Synopsis]```using value_type = std::pair< string_view, string_view >;```[heading Description]
The first element of the pair is the name, and the second element is the value which may be empty. The value is stored in its raw representation, without quotes or escapes. 
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_dynamic_body http::basic_dynamic_body]
A [*Body] using a [*DynamicBuffer]. 
[heading Synopsis]Defined in header [include_file boost/beast/http/basic_dynamic_body.hpp]```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>struct basic_dynamic_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]][heading Description]
This body uses a [*DynamicBuffer] as a memory-based container for holding message payloads. Messages using this body type may be serialized and parsed. 
[section:reader http::basic_dynamic_body::reader][indexterm2 reader..http::basic_dynamic_body]
The algorithm for parsing the body. 
[heading Synopsis]```using reader = ``['implementation-defined]``;```[heading Description]
Meets the requirements of [*BodyReader]. 
[endsect][section:size http::basic_dynamic_body::size][indexterm2 size..http::basic_dynamic_body]
Returns the payload size of the body. 
[heading Synopsis]```staticstd::uint64_tsize(    value_type const& v);```[heading Description]
When this body is used with [link beast.ref.boost__beast__http__message.prepare_payload `http::message::prepare_payload`], the Content-Length will be set to the payload size, and any chunked Transfer-Encoding will be removed. 
[endsect][section:value_type http::basic_dynamic_body::value_type][indexterm2 value_type..http::basic_dynamic_body]
The type of container used for the body. 
[heading Synopsis]```using value_type = DynamicBuffer;```[heading Description]
This determines the type of [link beast.ref.boost__beast__http__message.body `http::message::body`] when this body type is used with a message container. 
[endsect][section:writer http::basic_dynamic_body::writer][indexterm2 writer..http::basic_dynamic_body]
The algorithm for serializing the body. 
[heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description]
Meets the requirements of [*BodyWriter]. 
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_fields http::basic_fields]
A container for storing HTTP header fields. 
[heading Synopsis]Defined in header [include_file boost/beast/http/fields.hpp]```template<    class Allocator>class basic_fields```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.allocator_type [*allocator_type]]]    [      The type of allocator used.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__key_compare [*key_compare]]]    [      A strictly less predicate for comparing keys, using a case-insensitive comparison.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type [*value_type]]]    [      The type of element used to represent a field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.const_iterator [*const_iterator]]]    [      A constant iterator to the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.iterator [*iterator]]]    [      A constant iterator to the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.writer [*writer]]]    [      The algorithm used to serialize the header.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.at [*at]]]    [      Returns the value for a field, or throws an exception.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.basic_fields [*basic_fields]]]    [      Constructor.       Move constructor.       Copy constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.begin [*begin]]]    [      Return a const iterator to the beginning of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.cbegin [*cbegin]]]    [      Return a const iterator to the beginning of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.cend [*cend]]]    [      Return a const iterator to the end of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.clear [*clear]]]    [      Remove all fields from the container.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.count [*count]]]    [      Return the number of fields with the specified name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.end [*end]]]    [      Return a const iterator to the end of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.equal_range [*equal_range]]]    [      Returns a range of iterators to the fields with the specified name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.erase [*erase]]]    [      Remove a field.       Remove all fields with the specified name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.find [*find]]]    [      Returns an iterator to the case-insensitive matching field.       Returns an iterator to the case-insensitive matching field name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_allocator [*get_allocator]]]    [      Return a copy of the allocator associated with the container.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.insert [*insert]]]    [      Insert a field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.key_comp [*key_comp]]]    [      Returns a copy of the key comparison function.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.operator_eq_ [*operator=]]]    [      Move assignment.       Copy assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.operator_lb__rb_ [*operator\[\]]]]    [      Returns the value for a field, or "" if it does not exist.       Returns the value for a case-insensitive matching header, or "" if it does not exist.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set [*set]]]    [      Set a field value, removing any other instances of that field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.swap [*swap]]]    [      Return a buffer sequence representing the trailers.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.basic_fields_dtor_ [*~basic_fields]]]    [      Destructor.     ]  ]][heading Protected Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.get_chunked_impl [*get_chunked_impl]]]    [      Returns the chunked Transfer-Encoding setting.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_keep_alive_impl [*get_keep_alive_impl]]]    [      Returns the keep-alive setting.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_method_impl [*get_method_impl]]]    [      Returns the request-method string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_reason_impl [*get_reason_impl]]]    [      Returns the response reason-phrase string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_target_impl [*get_target_impl]]]    [      Returns the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.has_content_length_impl [*has_content_length_impl]]]    [      Returns true if the Content-Length field is present.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_chunked_impl [*set_chunked_impl]]]    [      Adjusts the chunked Transfer-Encoding value.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_content_length_impl [*set_content_length_impl]]]    [      Sets or clears the Content-Length field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_keep_alive_impl [*set_keep_alive_impl]]]    [      Adjusts the Connection field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_method_impl [*set_method_impl]]]    [      Set or clear the method string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_reason_impl [*set_reason_impl]]]    [      Set or clear the reason string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_target_impl [*set_target_impl]]]    [      Set or clear the target string.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.swap [*swap]]]    [      Swap two field containers.     ]  ]][heading Description]
This container is designed to store the field value pairs that make up the fields and trailers in an HTTP message. Objects of this type are iterable, with each element holding the field name and field value.

Field names are stored as-is, but comparisons are case-insensitive. The container behaves as a `std::multiset`; there will be a separate value for each occurrence of the same field name. When the container is iterated the fields are presented in the order of insertion, with fields having the same name following each other consecutively.

Meets the requirements of [*Fields] 

[heading Template Parameters][table [[Type][Description]]  [[`Allocator`][    The allocator to use. This must meet the requirements of Allocator.   ]]]

[section:allocator_type http::basic_fields::allocator_type][indexterm2 allocator_type..http::basic_fields]
The type of allocator used. 
[heading Synopsis]```using allocator_type = Allocator;```[heading Description][endsect][section:at http::basic_fields::at][indexterm2 at..http::basic_fields]
Returns the value for a field, or throws an exception. 
```string_view const``[link beast.ref.boost__beast__http__basic_fields.at.overload1 at]``(    field name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.at.overload1 more...]]``string_view const``[link beast.ref.boost__beast__http__basic_fields.at.overload2 at]``(    string_view name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.at.overload2 more...]]`````[section:overload1 http::basic_fields::at (1 of 2 overloads)]
Returns the value for a field, or throws an exception. 
[heading Synopsis]```string_view constat(    field name) const;```[heading Description]
If more than one field with the specified name exists, the first field defined by insertion order is returned.

[heading Parameters][table [[Name][Description]]  [[`name`][    The name of the field.  ]]]
[heading Return Value]
The field value.

[heading Exceptions][table [[Type][Thrown On]]  [[`std::out_of_range`][    if the field is not found.   ]]]

[endsect][section:overload2 http::basic_fields::at (2 of 2 overloads)]
Returns the value for a field, or throws an exception. 
[heading Synopsis]```string_view constat(    string_view name) const;```[heading Description]
If more than one field with the specified name exists, the first field defined by insertion order is returned.

[heading Parameters][table [[Name][Description]]  [[`name`][    The name of the field.  ]]]
[heading Return Value]
The field value.

[heading Exceptions][table [[Type][Thrown On]]  [[`std::out_of_range`][    if the field is not found.   ]]]

[endsect][endsect][section:basic_fields http::basic_fields::basic_fields][indexterm2 basic_fields..http::basic_fields]
Constructor. 
`````[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload1 basic_fields]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload1 more...]]``explicit``[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload2 basic_fields]``(    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload2 more...]]`````
Move constructor. 
`````[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload3 basic_fields]``(    basic_fields&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload3 more...]]````[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload4 basic_fields]``(    basic_fields&&,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload4 more...]]`````
Copy constructor. 
`````[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload5 basic_fields]``(    basic_fields const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload5 more...]]````[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload6 basic_fields]``(    basic_fields const&,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload6 more...]]``template<    class OtherAlloc>``[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload7 basic_fields]``(    basic_fields< OtherAlloc > const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload7 more...]]``template<    class OtherAlloc>``[link beast.ref.boost__beast__http__basic_fields.basic_fields.overload8 basic_fields]``(    basic_fields< OtherAlloc > const&,    Allocator const& alloc);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.basic_fields.overload8 more...]]`````[section:overload1 http::basic_fields::basic_fields (1 of 8 overloads)]
Constructor. 
[heading Synopsis]```basic_fields();```[heading Description][endsect][section:overload2 http::basic_fields::basic_fields (2 of 8 overloads)]
Constructor. 
[heading Synopsis]```basic_fields(    Allocator const& alloc);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`alloc`][    The allocator to use.   ]]]

[endsect][section:overload3 http::basic_fields::basic_fields (3 of 8 overloads)]
Move constructor. 
[heading Synopsis]```basic_fields(    basic_fields&&);```[heading Description]
The state of the moved-from object is as if constructed using the same allocator. 
[endsect][section:overload4 http::basic_fields::basic_fields (4 of 8 overloads)]
Move constructor. 
[heading Synopsis]```basic_fields(    basic_fields&&,    Allocator const& alloc);```[heading Description]
The state of the moved-from object is as if constructed using the same allocator.

[heading Parameters][table [[Name][Description]]  [[`alloc`][    The allocator to use.   ]]]

[endsect][section:overload5 http::basic_fields::basic_fields (5 of 8 overloads)]
Copy constructor. 
[heading Synopsis]```basic_fields(    basic_fields const&);```[heading Description][endsect][section:overload6 http::basic_fields::basic_fields (6 of 8 overloads)]
Copy constructor. 
[heading Synopsis]```basic_fields(    basic_fields const&,    Allocator const& alloc);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`alloc`][    The allocator to use.   ]]]

[endsect][section:overload7 http::basic_fields::basic_fields (7 of 8 overloads)]
Copy constructor. 
[heading Synopsis]```template<    class OtherAlloc>basic_fields(    basic_fields< OtherAlloc > const&);```[heading Description][endsect][section:overload8 http::basic_fields::basic_fields (8 of 8 overloads)]
Copy constructor. 
[heading Synopsis]```template<    class OtherAlloc>basic_fields(    basic_fields< OtherAlloc > const&,    Allocator const& alloc);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`alloc`][    The allocator to use.   ]]]

[endsect][endsect][section:begin http::basic_fields::begin][indexterm2 begin..http::basic_fields]
Return a const iterator to the beginning of the field sequence. 
[heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:cbegin http::basic_fields::cbegin][indexterm2 cbegin..http::basic_fields]
Return a const iterator to the beginning of the field sequence. 
[heading Synopsis]```const_iteratorcbegin() const;```[heading Description][endsect][section:cend http::basic_fields::cend][indexterm2 cend..http::basic_fields]
Return a const iterator to the end of the field sequence. 
[heading Synopsis]```const_iteratorcend() const;```[heading Description][endsect][section:clear http::basic_fields::clear][indexterm2 clear..http::basic_fields]
Remove all fields from the container. 
[heading Synopsis]```voidclear();```[heading Description]
All references, pointers, or iterators referring to contained elements are invalidated. All past-the-end iterators are also invalidated.

[heading Postconditions:]


  std::distance(this->begin(), this->end()) == 0





[endsect][section:const_iterator http::basic_fields::const_iterator][indexterm2 const_iterator..http::basic_fields]
A constant iterator to the field sequence. 
[heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:count http::basic_fields::count][indexterm2 count..http::basic_fields]
Return the number of fields with the specified name. 
```std::size_t``[link beast.ref.boost__beast__http__basic_fields.count.overload1 count]``(    field name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.count.overload1 more...]]``std::size_t``[link beast.ref.boost__beast__http__basic_fields.count.overload2 count]``(    string_view name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.count.overload2 more...]]`````[section:overload1 http::basic_fields::count (1 of 2 overloads)]
Return the number of fields with the specified name. 
[heading Synopsis]```std::size_tcount(    field name) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`name`][    The field name.   ]]]

[endsect][section:overload2 http::basic_fields::count (2 of 2 overloads)]
Return the number of fields with the specified name. 
[heading Synopsis]```std::size_tcount(    string_view name) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`name`][    The field name.   ]]]

[endsect][endsect][section:end http::basic_fields::end][indexterm2 end..http::basic_fields]
Return a const iterator to the end of the field sequence. 
[heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:equal_range http::basic_fields::equal_range][indexterm2 equal_range..http::basic_fields]
Returns a range of iterators to the fields with the specified name. 
```std::pair< const_iterator, const_iterator >``[link beast.ref.boost__beast__http__basic_fields.equal_range.overload1 equal_range]``(    field name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.equal_range.overload1 more...]]``std::pair< const_iterator, const_iterator >``[link beast.ref.boost__beast__http__basic_fields.equal_range.overload2 equal_range]``(    string_view name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.equal_range.overload2 more...]]`````[section:overload1 http::basic_fields::equal_range (1 of 2 overloads)]
Returns a range of iterators to the fields with the specified name. 
[heading Synopsis]```std::pair< const_iterator, const_iterator >equal_range(    field name) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`name`][    The field name.  ]]]
[heading Return Value]
A range of iterators to fields with the same name, otherwise an empty range. 


[endsect][section:overload2 http::basic_fields::equal_range (2 of 2 overloads)]
Returns a range of iterators to the fields with the specified name. 
[heading Synopsis]```std::pair< const_iterator, const_iterator >equal_range(    string_view name) const;```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`name`][    The field name.  ]]]
[heading Return Value]
A range of iterators to fields with the same name, otherwise an empty range. 


[endsect][endsect][section:erase http::basic_fields::erase][indexterm2 erase..http::basic_fields]
Remove a field. 
```const_iterator``[link beast.ref.boost__beast__http__basic_fields.erase.overload1 erase]``(    const_iterator pos);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.erase.overload1 more...]]`````
Remove all fields with the specified name. 
```std::size_t``[link beast.ref.boost__beast__http__basic_fields.erase.overload2 erase]``(    field name);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.erase.overload2 more...]]``std::size_t``[link beast.ref.boost__beast__http__basic_fields.erase.overload3 erase]``(    string_view name);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.erase.overload3 more...]]`````[section:overload1 http::basic_fields::erase (1 of 3 overloads)]
Remove a field. 
[heading Synopsis]```const_iteratorerase(    const_iterator pos);```[heading Description]
References and iterators to the erased elements are invalidated. Other references and iterators are not affected.

[heading Parameters][table [[Name][Description]]  [[`pos`][    An iterator to the element to remove.  ]]]
[heading Return Value]
An iterator following the last removed element. If the iterator refers to the last element, the [link beast.ref.boost__beast__http__basic_fields.end `http::basic_fields::end()`] iterator is returned. 


[endsect][section:overload2 http::basic_fields::erase (2 of 3 overloads)]
Remove all fields with the specified name. 
[heading Synopsis]```std::size_terase(    field name);```[heading Description]
All fields with the same field name are erased from the container. References and iterators to the erased elements are invalidated. Other references and iterators are not affected.

[heading Parameters][table [[Name][Description]]  [[`name`][    The field name.  ]]]
[heading Return Value]
The number of fields removed. 


[endsect][section:overload3 http::basic_fields::erase (3 of 3 overloads)]
Remove all fields with the specified name. 
[heading Synopsis]```std::size_terase(    string_view name);```[heading Description]
All fields with the same field name are erased from the container. References and iterators to the erased elements are invalidated. Other references and iterators are not affected.

[heading Parameters][table [[Name][Description]]  [[`name`][    The field name.  ]]]
[heading Return Value]
The number of fields removed. 


[endsect][endsect][section:find http::basic_fields::find][indexterm2 find..http::basic_fields]
Returns an iterator to the case-insensitive matching field. 
```const_iterator``[link beast.ref.boost__beast__http__basic_fields.find.overload1 find]``(    field name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.find.overload1 more...]]`````
Returns an iterator to the case-insensitive matching field name. 
```const_iterator``[link beast.ref.boost__beast__http__basic_fields.find.overload2 find]``(    string_view name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.find.overload2 more...]]`````[section:overload1 http::basic_fields::find (1 of 2 overloads)]
Returns an iterator to the case-insensitive matching field. 
[heading Synopsis]```const_iteratorfind(    field name) const;```[heading Description]
If more than one field with the specified name exists, the first field defined by insertion order is returned.

[heading Parameters][table [[Name][Description]]  [[`name`][    The field name.  ]]]
[heading Return Value]
An iterator to the matching field, or `end()` if no match was found. 


[endsect][section:overload2 http::basic_fields::find (2 of 2 overloads)]
Returns an iterator to the case-insensitive matching field name. 
[heading Synopsis]```const_iteratorfind(    string_view name) const;```[heading Description]
If more than one field with the specified name exists, the first field defined by insertion order is returned.

[heading Parameters][table [[Name][Description]]  [[`name`][    The field name.  ]]]
[heading Return Value]
An iterator to the matching field, or `end()` if no match was found. 


[endsect][endsect][section:get_allocator http::basic_fields::get_allocator][indexterm2 get_allocator..http::basic_fields]
Return a copy of the allocator associated with the container. 
[heading Synopsis]```allocator_typeget_allocator() const;```[heading Description][endsect][section:get_chunked_impl http::basic_fields::get_chunked_impl][indexterm2 get_chunked_impl..http::basic_fields]
Returns the chunked Transfer-Encoding setting. 
[heading Synopsis]```boolget_chunked_impl() const;```[heading Description][endsect][section:get_keep_alive_impl http::basic_fields::get_keep_alive_impl][indexterm2 get_keep_alive_impl..http::basic_fields]
Returns the keep-alive setting. 
[heading Synopsis]```boolget_keep_alive_impl(    unsigned version) const;```[heading Description][endsect][section:get_method_impl http::basic_fields::get_method_impl][indexterm2 get_method_impl..http::basic_fields]
Returns the request-method string. 
[heading Synopsis]```string_viewget_method_impl() const;```[heading Description]
[heading Remarks]
Only called for requests. 


[endsect][section:get_reason_impl http::basic_fields::get_reason_impl][indexterm2 get_reason_impl..http::basic_fields]
Returns the response reason-phrase string. 
[heading Synopsis]```string_viewget_reason_impl() const;```[heading Description]
[heading Remarks]
Only called for responses. 


[endsect][section:get_target_impl http::basic_fields::get_target_impl][indexterm2 get_target_impl..http::basic_fields]
Returns the request-target string. 
[heading Synopsis]```string_viewget_target_impl() const;```[heading Description]
[heading Remarks]
Only called for requests. 


[endsect][section:has_content_length_impl http::basic_fields::has_content_length_impl][indexterm2 has_content_length_impl..http::basic_fields]
Returns `true` if the Content-Length field is present. 
[heading Synopsis]```boolhas_content_length_impl() const;```[heading Description][endsect][section:insert http::basic_fields::insert][indexterm2 insert..http::basic_fields]
Insert a field. 
```void``[link beast.ref.boost__beast__http__basic_fields.insert.overload1 insert]``(    field name,    string_param const& value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.insert.overload1 more...]]``void``[link beast.ref.boost__beast__http__basic_fields.insert.overload2 insert]``(    string_view name,    string_param const& value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.insert.overload2 more...]]``void``[link beast.ref.boost__beast__http__basic_fields.insert.overload3 insert]``(    field name,    string_view name_string,    string_param const& value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.insert.overload3 more...]]`````[section:overload1 http::basic_fields::insert (1 of 3 overloads)]
Insert a field. 
[heading Synopsis]```voidinsert(    field name,    string_param const& value);```[heading Description]
If one or more fields with the same name already exist, the new field will be inserted after the last field with the matching name, in serialization order.

[heading Parameters][table [[Name][Description]]  [[`name`][    The field name.  ]]  [[`value`][    The value of the field, as a [role red string_param]   ]]]

[endsect][section:overload2 http::basic_fields::insert (2 of 3 overloads)]
Insert a field. 
[heading Synopsis]```voidinsert(    string_view name,    string_param const& value);```[heading Description]
If one or more fields with the same name already exist, the new field will be inserted after the last field with the matching name, in serialization order.

[heading Parameters][table [[Name][Description]]  [[`name`][    The field name.  ]]  [[`value`][    The value of the field, as a [role red string_param]   ]]]

[endsect][section:overload3 http::basic_fields::insert (3 of 3 overloads)]
Insert a field. 
[heading Synopsis]```voidinsert(    field name,    string_view name_string,    string_param const& value);```[heading Description]
If one or more fields with the same name already exist, the new field will be inserted after the last field with the matching name, in serialization order.

[heading Parameters][table [[Name][Description]]  [[`name`][    The field name.  ]]  [[`name_string`][    The literal text corresponding to the field name. If `name != field::unknown`, then this value must be equal to `to_string(name)` using a case-insensitive comparison, otherwise the behavior is undefined.  ]]  [[`value`][    The value of the field, as a [role red string_param]   ]]]

[endsect][endsect][section:iterator http::basic_fields::iterator][indexterm2 iterator..http::basic_fields]
A constant iterator to the field sequence. 
[heading Synopsis]```using iterator = const_iterator;```[heading Description][endsect][section:key_comp http::basic_fields::key_comp][indexterm2 key_comp..http::basic_fields]
Returns a copy of the key comparison function. 
[heading Synopsis]```key_comparekey_comp() const;```[heading Description][endsect][section:operator_eq_ http::basic_fields::operator=][indexterm2 operator=..http::basic_fields]
Move assignment. 
```basic_fields&``[link beast.ref.boost__beast__http__basic_fields.operator_eq_.overload1 operator=]``(    basic_fields&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.operator_eq_.overload1 more...]]`````
Copy assignment. 
```basic_fields&``[link beast.ref.boost__beast__http__basic_fields.operator_eq_.overload2 operator=]``(    basic_fields const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.operator_eq_.overload2 more...]]``template<    class OtherAlloc>basic_fields&``[link beast.ref.boost__beast__http__basic_fields.operator_eq_.overload3 operator=]``(    basic_fields< OtherAlloc > const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.operator_eq_.overload3 more...]]`````[section:overload1 http::basic_fields::operator= (1 of 3 overloads)]
Move assignment. 
[heading Synopsis]```basic_fields&operator=(    basic_fields&&);```[heading Description]
The state of the moved-from object is as if constructed using the same allocator. 
[endsect][section:overload2 http::basic_fields::operator= (2 of 3 overloads)]
Copy assignment. 
[heading Synopsis]```basic_fields&operator=(    basic_fields const&);```[heading Description][endsect][section:overload3 http::basic_fields::operator= (3 of 3 overloads)]
Copy assignment. 
[heading Synopsis]```template<    class OtherAlloc>basic_fields&operator=(    basic_fields< OtherAlloc > const&);```[heading Description][endsect][endsect][section:operator_lb__rb_ http::basic_fields::operator\[\]][indexterm2 operator\[\]..http::basic_fields]
Returns the value for a field, or `""` if it does not exist. 
```string_view const``[link beast.ref.boost__beast__http__basic_fields.operator_lb__rb_.overload1 operator[]]``(    field name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.operator_lb__rb_.overload1 more...]]`````
Returns the value for a case-insensitive matching header, or `""` if it does not exist. 
```string_view const``[link beast.ref.boost__beast__http__basic_fields.operator_lb__rb_.overload2 operator[]]``(    string_view name) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.operator_lb__rb_.overload2 more...]]`````[section:overload1 http::basic_fields::operator\[\] (1 of 2 overloads)]
Returns the value for a field, or `""` if it does not exist. 
[heading Synopsis]```string_view constoperator[](    field name) const;```[heading Description]
If more than one field with the specified name exists, the first field defined by insertion order is returned.

[heading Parameters][table [[Name][Description]]  [[`name`][    The name of the field.   ]]]

[endsect][section:overload2 http::basic_fields::operator\[\] (2 of 2 overloads)]
Returns the value for a case-insensitive matching header, or `""` if it does not exist. 
[heading Synopsis]```string_view constoperator[](    string_view name) const;```[heading Description]
If more than one field with the specified name exists, the first field defined by insertion order is returned.

[heading Parameters][table [[Name][Description]]  [[`name`][    The name of the field.   ]]]

[endsect][endsect][section:set http::basic_fields::set][indexterm2 set..http::basic_fields]
Set a field value, removing any other instances of that field. 
```void``[link beast.ref.boost__beast__http__basic_fields.set.overload1 set]``(    field name,    string_param const& value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.set.overload1 more...]]``void``[link beast.ref.boost__beast__http__basic_fields.set.overload2 set]``(    string_view name,    string_param const& value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields.set.overload2 more...]]`````[section:overload1 http::basic_fields::set (1 of 2 overloads)]
Set a field value, removing any other instances of that field. 
[heading Synopsis]```voidset(    field name,    string_param const& value);```[heading Description]
First removes any values with matching field names, then inserts the new field value.

[heading Parameters][table [[Name][Description]]  [[`name`][    The field name.  ]]  [[`value`][    The value of the field, as a [role red string_param]  ]]]
[heading Return Value]
The field value. 


[endsect][section:overload2 http::basic_fields::set (2 of 2 overloads)]
Set a field value, removing any other instances of that field. 
[heading Synopsis]```voidset(    string_view name,    string_param const& value);```[heading Description]
First removes any values with matching field names, then inserts the new field value.

[heading Parameters][table [[Name][Description]]  [[`name`][    The field name.  ]]  [[`value`][    The value of the field, as a [role red string_param]   ]]]

[endsect][endsect][section:set_chunked_impl http::basic_fields::set_chunked_impl][indexterm2 set_chunked_impl..http::basic_fields]
Adjusts the chunked Transfer-Encoding value. 
[heading Synopsis]```voidset_chunked_impl(    bool value);```[heading Description][endsect][section:set_content_length_impl http::basic_fields::set_content_length_impl][indexterm2 set_content_length_impl..http::basic_fields]
Sets or clears the Content-Length field. 
[heading Synopsis]```voidset_content_length_impl(    boost::optional< std::uint64_t > const& value);```[heading Description][endsect][section:set_keep_alive_impl http::basic_fields::set_keep_alive_impl][indexterm2 set_keep_alive_impl..http::basic_fields]
Adjusts the Connection field. 
[heading Synopsis]```voidset_keep_alive_impl(    unsigned version,    bool keep_alive);```[heading Description][endsect][section:set_method_impl http::basic_fields::set_method_impl][indexterm2 set_method_impl..http::basic_fields]
Set or clear the method string. 
[heading Synopsis]```voidset_method_impl(    string_view s);```[heading Description]
[heading Remarks]
Only called for requests. 


[endsect][section:set_reason_impl http::basic_fields::set_reason_impl][indexterm2 set_reason_impl..http::basic_fields]
Set or clear the reason string. 
[heading Synopsis]```voidset_reason_impl(    string_view s);```[heading Description]
[heading Remarks]
Only called for responses. 


[endsect][section:set_target_impl http::basic_fields::set_target_impl][indexterm2 set_target_impl..http::basic_fields]
Set or clear the target string. 
[heading Synopsis]```voidset_target_impl(    string_view s);```[heading Description]
[heading Remarks]
Only called for requests. 


[endsect][section:swap http::basic_fields::swap][indexterm2 swap..http::basic_fields]
Swap two field containers. 
[heading Synopsis]Defined in header [include_file boost/beast/http/fields.hpp]```template<    class Alloc>friend voidswap(    basic_fields< Alloc >& lhs,    basic_fields< Alloc >& rhs);```[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:swap http::basic_fields::swap][indexterm2 swap..http::basic_fields]
Return a buffer sequence representing the trailers. 
[heading Synopsis]```voidswap(    basic_fields& other);```[heading Description]
This function returns a buffer sequence holding the serialized representation of the trailer fields promised in the Accept field. Before calling this function the Accept field must contain the exact trailer fields desired. Each field must also exist.Swap this container with another 
[endsect][section:writer http::basic_fields::writer][indexterm2 writer..http::basic_fields]
The algorithm used to serialize the header. 
[heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description][endsect][section:basic_fields_dtor_ http::basic_fields::~basic_fields][indexterm2 ~basic_fields..http::basic_fields]
Destructor. 
[heading Synopsis]```~basic_fields();```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_fields__key_compare http::basic_fields::key_compare]
A strictly less predicate for comparing keys, using a case-insensitive comparison. 
[heading Synopsis]Defined in header [include_file boost/beast/http/fields.hpp]```struct key_compare :    public iless```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields__key_compare.operator_lp__rp_ [*operator()]]]    [      Returns true if lhs is less than rhs using a strict ordering.           ]  ]][heading Description]
The case-comparison operation is defined only for low-ASCII characters. 
[section:operator_lp__rp_ http::basic_fields::key_compare::operator()][indexterm2 operator()..http::basic_fields::key_compare]
Returns `true` if lhs is less than rhs using a strict ordering. 
```template<    class String>bool``[link beast.ref.boost__beast__http__basic_fields__key_compare.operator_lp__rp_.overload1 operator()]``(    String const& lhs,    value_type const& rhs) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields__key_compare.operator_lp__rp_.overload1 more...]]``template<    class String>bool``[link beast.ref.boost__beast__http__basic_fields__key_compare.operator_lp__rp_.overload2 operator()]``(    value_type const& lhs,    String const& rhs) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields__key_compare.operator_lp__rp_.overload2 more...]]``bool``[link beast.ref.boost__beast__http__basic_fields__key_compare.operator_lp__rp_.overload3 operator()]``(    value_type const& lhs,    value_type const& rhs) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields__key_compare.operator_lp__rp_.overload3 more...]]````````bool``[link beast.ref.boost__beast__http__basic_fields__key_compare.operator_lp__rp_.overload4 operator()]``(    string_view lhs,    string_view rhs) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_fields__key_compare.operator_lp__rp_.overload4 more...]]`````[section:overload1 http::basic_fields::key_compare::operator() (1 of 4 overloads)]
Returns `true` if lhs is less than rhs using a strict ordering. 
[heading Synopsis]```template<    class String>booloperator()(    String const& lhs,    value_type const& rhs) const;```[heading Description][endsect][section:overload2 http::basic_fields::key_compare::operator() (2 of 4 overloads)]
Returns `true` if lhs is less than rhs using a strict ordering. 
[heading Synopsis]```template<    class String>booloperator()(    value_type const& lhs,    String const& rhs) const;```[heading Description][endsect][section:overload3 http::basic_fields::key_compare::operator() (3 of 4 overloads)]
Returns `true` if lhs is less than rhs using a strict ordering. 
[heading Synopsis]```booloperator()(    value_type const& lhs,    value_type const& rhs) const;```[heading Description][endsect][section:overload4 http::basic_fields::key_compare::operator() (4 of 4 overloads)](Inherited from `iless`)[heading Synopsis]```booloperator()(    string_view lhs,    string_view rhs) const;```[heading Description][endsect][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_fields__value_type http::basic_fields::value_type]
The type of element used to represent a field. 
[heading Synopsis]Defined in header [include_file boost/beast/http/fields.hpp]```class value_type```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type.name [*name]]]    [      Returns the field enum, which can be field::unknown.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type.name_string [*name_string]]]    [      Returns the field name as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type.operator_eq_ [*operator=]]]    [      Assignment (deleted)     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type.value [*value]]]    [      Returns the value of the field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type.value_type [*value_type]]]    [      Constructor (deleted)     ]  ]][heading Description][section:name http::basic_fields::value_type::name][indexterm2 name..http::basic_fields::value_type]
Returns the field enum, which can be [link beast.ref.boost__beast__http__field `http::unknown`]. 
[heading Synopsis]```field constname() const;```[heading Description][endsect][section:name_string http::basic_fields::value_type::name_string][indexterm2 name_string..http::basic_fields::value_type]
Returns the field name as a string. 
[heading Synopsis]```string_view constname_string() const;```[heading Description][endsect][section:operator_eq_ http::basic_fields::value_type::operator=][indexterm2 operator=..http::basic_fields::value_type]
Assignment (deleted) 
[heading Synopsis]```value_type&operator=(    value_type const&);```[heading Description][endsect][section:value http::basic_fields::value_type::value][indexterm2 value..http::basic_fields::value_type]
Returns the value of the field. 
[heading Synopsis]```string_view constvalue() const;```[heading Description][endsect][section:value_type http::basic_fields::value_type::value_type][indexterm2 value_type..http::basic_fields::value_type]
Constructor (deleted) 
[heading Synopsis]```value_type(    value_type const&);```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_file_body http::basic_file_body]
A message body represented by a file on the filesystem. 
[heading Synopsis]Defined in header [include_file boost/beast/http/basic_file_body.hpp]```template<    class File>struct basic_file_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__reader [*reader]]]    [      Algorithm for storing buffers when parsing.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type [*value_type]]]    [      The type of the message::body member.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__writer [*writer]]]    [      Algorithm for retrieving buffers when serializing.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body.file_type [*file_type]]]    [      The type of File this body uses.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body.size [*size]]]    [      Returns the size of the body.     ]  ]][heading Description]
Messages with this type have bodies represented by a file on the file system. When parsing a message using this body type, the data is stored in the file pointed to by the path, which must be writable. When serializing, the implementation will read the file and present those octets as the body content. This may be used to serve content from a directory as part of a web service.

[heading Template Parameters][table [[Type][Description]]  [[`File`][    The implementation to use for accessing files. This type must meet the requirements of File.   ]]]

[section:file_type http::basic_file_body::file_type][indexterm2 file_type..http::basic_file_body]
The type of File this body uses. 
[heading Synopsis]```using file_type = File;```[heading Description][endsect][section:size http::basic_file_body::size][indexterm2 size..http::basic_file_body]
Returns the size of the body. 
[heading Synopsis]```staticstd::uint64_tsize(    value_type const& body);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`body`][    The file body to use   ]]]

[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_file_body__reader http::basic_file_body::reader]
Algorithm for storing buffers when parsing. 
[heading Synopsis]Defined in header [include_file boost/beast/http/basic_file_body.hpp]```class reader```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__reader.finish [*finish]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__reader.init [*init]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__reader.put [*put]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__reader.reader [*reader]]]    [          ]  ]][heading Description]
Objects of this type are created during parsing to store incoming buffers representing the body. 
[section:finish http::basic_file_body::reader::finish][indexterm2 finish..http::basic_file_body::reader][heading Synopsis]```voidfinish(    error_code& ec);```[heading Description][endsect][section:init http::basic_file_body::reader::init][indexterm2 init..http::basic_file_body::reader][heading Synopsis]```voidinit(    boost::optional< std::uint64_t > const&,    error_code& ec);```[heading Description][endsect][section:put http::basic_file_body::reader::put][indexterm2 put..http::basic_file_body::reader][heading Synopsis]```template<    class __ConstBufferSequence__>std::size_tput(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description][endsect][section:reader http::basic_file_body::reader::reader][indexterm2 reader..http::basic_file_body::reader][heading Synopsis]```template<    bool isRequest,    class ``[link beast.concepts.Fields [*Fields]]``>reader(    message< isRequest, basic_file_body, Fields >& m);```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_file_body__value_type http::basic_file_body::value_type]
The type of the [link beast.ref.boost__beast__http__message.body `http::message::body`] member. 
[heading Synopsis]Defined in header [include_file boost/beast/http/basic_file_body.hpp]```class value_type```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.close [*close]]]    [      Close the file if open.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.is_open [*is_open]]]    [      Returns true if the file is open.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.open [*open]]]    [      Open a file at the given path with the specified mode.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.operator_eq_ [*operator=]]]    [      Move assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.reset [*reset]]]    [      Set the open file.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.size [*size]]]    [      Returns the size of the file if open.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.value_type [*value_type]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.value_type_dtor_ [*~value_type]]]    [      Destructor.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type.basic_file_body [*basic_file_body]]]    [          ]  ]][heading Description]
Messages declared using `basic_file_body` will have this type for the body member. This rich class interface allow the file to be opened with the file handle maintained directly in the object, which is attached to the message. 
[section:basic_file_body http::basic_file_body::value_type::basic_file_body][indexterm2 basic_file_body..http::basic_file_body::value_type][heading Synopsis]Defined in header [include_file boost/beast/http/basic_file_body.hpp]```friend structbasic_file_body();```[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:close http::basic_file_body::value_type::close][indexterm2 close..http::basic_file_body::value_type]
Close the file if open. 
[heading Synopsis]```voidclose();```[heading Description][endsect][section:is_open http::basic_file_body::value_type::is_open][indexterm2 is_open..http::basic_file_body::value_type]
Returns `true` if the file is open. 
[heading Synopsis]```boolis_open() const;```[heading Description][endsect][section:open http::basic_file_body::value_type::open][indexterm2 open..http::basic_file_body::value_type]
Open a file at the given path with the specified mode. 
[heading Synopsis]```voidopen(    char const* path,    file_mode mode,    error_code& ec);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`path`][    The utf-8 encoded path to the file  ]]  [[`mode`][    The file mode to use  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:operator_eq_ http::basic_file_body::value_type::operator=][indexterm2 operator=..http::basic_file_body::value_type]
Move assignment. 
[heading Synopsis]```value_type&operator=(    value_type&& other);```[heading Description][endsect][section:reset http::basic_file_body::value_type::reset][indexterm2 reset..http::basic_file_body::value_type]
Set the open file. 
[heading Synopsis]```voidreset(    File&& file,    error_code& ec);```[heading Description]
This function is used to set the open file. Any previously set file will be closed.

[heading Parameters][table [[Name][Description]]  [[`file`][    The file to set. The file must be open or else an error occurs  ]]  [[`ec`][    Set to the error, if any occurred   ]]]

[endsect][section:size http::basic_file_body::value_type::size][indexterm2 size..http::basic_file_body::value_type]
Returns the size of the file if open. 
[heading Synopsis]```std::uint64_tsize() const;```[heading Description][endsect][section:value_type http::basic_file_body::value_type::value_type][indexterm2 value_type..http::basic_file_body::value_type]
Constructor. 
`````[link beast.ref.boost__beast__http__basic_file_body__value_type.value_type.overload1 value_type]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_file_body__value_type.value_type.overload1 more...]]````[link beast.ref.boost__beast__http__basic_file_body__value_type.value_type.overload2 value_type]``(    value_type&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_file_body__value_type.value_type.overload2 more...]]`````[section:overload1 http::basic_file_body::value_type::value_type (1 of 2 overloads)]
Constructor. 
[heading Synopsis]```value_type();```[heading Description][endsect][section:overload2 http::basic_file_body::value_type::value_type (2 of 2 overloads)]
Constructor. 
[heading Synopsis]```value_type(    value_type&& other);```[heading Description][endsect][endsect][section:value_type_dtor_ http::basic_file_body::value_type::~value_type][indexterm2 ~value_type..http::basic_file_body::value_type]
Destructor. 
[heading Synopsis]```~value_type();```[heading Description]
If the file is open, it is closed first. 
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_file_body__writer http::basic_file_body::writer]
Algorithm for retrieving buffers when serializing. 
[heading Synopsis]Defined in header [include_file boost/beast/http/basic_file_body.hpp]```class writer```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__writer.const_buffers_type [*const_buffers_type]]]    [          ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__writer.get [*get]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__writer.init [*init]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__writer.writer [*writer]]]    [          ]  ]][heading Description]
Objects of this type are created during serialization to extract the buffers representing the body. 
[section:const_buffers_type http::basic_file_body::writer::const_buffers_type][indexterm2 const_buffers_type..http::basic_file_body::writer][heading Synopsis]```using const_buffers_type = boost::asio::const_buffer;```[heading Description][endsect][section:get http::basic_file_body::writer::get][indexterm2 get..http::basic_file_body::writer][heading Synopsis]```boost::optional< std::pair< const_buffers_type, bool > >get(    error_code& ec);```[heading Description][endsect][section:init http::basic_file_body::writer::init][indexterm2 init..http::basic_file_body::writer][heading Synopsis]```voidinit(    error_code& ec);```[heading Description][endsect][section:writer http::basic_file_body::writer::writer][indexterm2 writer..http::basic_file_body::writer][heading Synopsis]```template<    bool isRequest,    class ``[link beast.concepts.Fields [*Fields]]``>writer(    message< isRequest, basic_file_body, Fields >& m);```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_parser http::basic_parser]
A parser for decoding HTTP/1 wire format messages. 
[heading Synopsis]Defined in header [include_file boost/beast/http/basic_parser.hpp]```template<    bool isRequest,    class Derived>class basic_parser :    private basic_parser_base```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_parser.is_request [*is_request]]]    [      true if this parser parses requests, false for responses.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_parser.base [*base]]]    [      Returns a reference to this object as a basic_parser.       Returns a constant reference to this object as a basic_parser.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.basic_parser [*basic_parser]]]    [      Copy constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.body_limit [*body_limit]]]    [      Set the limit on the payload body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.chunked [*chunked]]]    [      Returns true if the last value for Transfer-Encoding is "chunked".     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.content_length [*content_length]]]    [      Returns the optional value of Content-Length if known.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.eager [*eager]]]    [      Returns true if the eager parse option is set.       Set the eager parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.got_some [*got_some]]]    [      Returns true if the parser has received at least one byte of input.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.header_limit [*header_limit]]]    [      Set a limit on the total size of the header.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.is_done [*is_done]]]    [      Returns true if the message is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.is_header_done [*is_header_done]]]    [      Returns true if a the parser has produced the full header.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.keep_alive [*keep_alive]]]    [      Returns true if the message has keep-alive connection semantics.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.operator_eq_ [*operator=]]]    [      Copy assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.put [*put]]]    [      Write a buffer sequence to the parser.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.put_eof [*put_eof]]]    [      Inform the parser that the end of stream was reached.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.skip [*skip]]]    [      Returns true if the skip parse option is set.       Set the skip parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.upgrade [*upgrade]]]    [      Returns true if the message is an upgrade message.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.basic_parser_dtor_ [*~basic_parser]]]    [      Destructor.     ]  ]][heading Protected Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_parser.basic_parser [*basic_parser]]]    [      Default constructor.       Move constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_parser.operator_eq_ [*operator=]]]    [      Move assignment.     ]  ]][heading Description]
This parser is designed to efficiently parse messages in the HTTP/1 wire format. It allocates no memory when input is presented as a single contiguous buffer, and uses minimal state. It will handle chunked encoding and it understands the semantics of the Connection, Content-Length, and Upgrade fields. The parser is optimized for the case where the input buffer sequence consists of a single contiguous buffer. The [link beast.ref.boost__beast__flat_buffer `flat_buffer`] class is provided, which guarantees that the input sequence of the stream buffer will be represented by exactly one contiguous buffer. To ensure the optimum performance of the parser, use [link beast.ref.boost__beast__flat_buffer `flat_buffer`] with HTTP algorithms such as [link beast.ref.boost__beast__http__read `http::read`], [link beast.ref.boost__beast__http__read_some `http::read_some`], [link beast.ref.boost__beast__http__async_read `http::async_read`], and [link beast.ref.boost__beast__http__async_read_some `http::async_read_some`]. Alternatively, the caller may use custom techniques to ensure that the structured portion of the HTTP message (header or chunk header) is contained in a linear buffer.

The interface uses CRTP (Curiously Recurring Template Pattern). To use this class directly, derive from [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. When bytes are presented, the implementation will make a series of zero or more calls to derived class members functions (termed "callbacks" in this context) matching a specific signature.

Every callback must be provided by the derived class, or else a compilation error will be generated. This exemplar shows the signature and description of the callbacks required in the derived class. For each callback, the function will ensure that `!ec` is `true` if there was no error or set to the appropriate error code if there was one. If an error is set, the value is propagated to the caller of the parser.

[heading Derived Class Requirements]


  template<bool isRequest>
  class derived
      : public basic_parser<isRequest, derived<isRequest>>
  {
  private:
      // The friend declaration is needed,
      // otherwise the callbacks must be made public.
      friend class basic_parser<isRequest, derived>;

      void
      on_request_impl(
          verb method,                // The method verb, verb::unknown if no match
          string_view method_str,     // The method as a string
          string_view target,         // The request-target
          int version,                // The HTTP-version
          error_code& ec);            // The error returned to the caller, if any

      void
      on_response_impl(
          int code,                   // The status-code
          string_view reason,         // The obsolete reason-phrase
          int version,                // The HTTP-version
          error_code& ec);            // The error returned to the caller, if any

      void
      on_field_impl(
          field f,                    // The known-field enumeration constant
          string_view name,           // The field name string.
          string_view value,          // The field value
          error_code& ec);            // The error returned to the caller, if any

      void
      on_header_impl(
          error_code& ec);            // The error returned to the caller, if any

      void
      on_body_init_impl(
          boost::optional<
              std::uint64_t> const&
                  content_length,     // Content length if known, else `boost::none`
          error_code& ec);            // The error returned to the caller, if any

      std::size_t
      on_body_impl(
          string_view s,              // A portion of the body
          error_code& ec);            // The error returned to the caller, if any

      void
      on_chunk_header_impl(
          std::uint64_t size,         // The size of the upcoming chunk,
                                      // or zero for the last chunk
          string_view extension,      // The chunk extensions (may be empty)
          error_code& ec);            // The error returned to the caller, if any

      std::size_t
      on_chunk_body_impl(
          std::uint64_t remain,       // The number of bytes remaining in the chunk,
                                      // including what is being passed here.
                                      // or zero for the last chunk
          string_view body,           // The next piece of the chunk body
          error_code& ec);            // The error returned to the caller, if any

      void
      on_finish_impl(error_code& ec);

  public:
      derived() = default;
  };




[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    A `bool` indicating whether the parser will be presented with request or response message.  ]]  [[`Derived`][    The derived class type. This is part of the Curiously Recurring Template Pattern interface.  ]]]
[heading Remarks]
If the parser encounters a field value with obs-fold longer than 4 kilobytes in length, an error is generated. 


[section:base http::basic_parser::base][indexterm2 base..http::basic_parser]
Returns a reference to this object as a [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. 
```basic_parser&``[link beast.ref.boost__beast__http__basic_parser.base.overload1 base]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.base.overload1 more...]]`````
Returns a constant reference to this object as a [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. 
```basic_parser const&``[link beast.ref.boost__beast__http__basic_parser.base.overload2 base]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.base.overload2 more...]]`````[section:overload1 http::basic_parser::base (1 of 2 overloads)]
Returns a reference to this object as a [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. 
[heading Synopsis]```basic_parser&base();```[heading Description]
This is used to pass a derived class where a base class is expected, to choose a correct function overload when the resolution would be ambiguous. 
[endsect][section:overload2 http::basic_parser::base (2 of 2 overloads)]
Returns a constant reference to this object as a [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. 
[heading Synopsis]```basic_parser const&base() const;```[heading Description]
This is used to pass a derived class where a base class is expected, to choose a correct function overload when the resolution would be ambiguous. 
[endsect][endsect][section:basic_parser http::basic_parser::basic_parser][indexterm2 basic_parser..http::basic_parser]
Default constructor. 
`````[link beast.ref.boost__beast__http__basic_parser.basic_parser.overload1 basic_parser]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.basic_parser.overload1 more...]]`````
Move constructor. 
`````[link beast.ref.boost__beast__http__basic_parser.basic_parser.overload2 basic_parser]``(    basic_parser&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.basic_parser.overload2 more...]]``template<    class OtherDerived>``[link beast.ref.boost__beast__http__basic_parser.basic_parser.overload3 basic_parser]``(    basic_parser< isRequest, OtherDerived >&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.basic_parser.overload3 more...]]`````[section:overload1 http::basic_parser::basic_parser (1 of 3 overloads)]
Default constructor. 
[heading Synopsis]```basic_parser();```[heading Description][endsect][section:overload2 http::basic_parser::basic_parser (2 of 3 overloads)]
Move constructor. 
[heading Synopsis]```basic_parser(    basic_parser&&);```[heading Description][endsect][section:overload3 http::basic_parser::basic_parser (3 of 3 overloads)]
Move constructor. 
[heading Synopsis]```template<    class OtherDerived>basic_parser(    basic_parser< isRequest, OtherDerived >&&);```[heading Description]
[heading Remarks]


After the move, the only valid operation on the moved-from object is destruction. 
[endsect][endsect][section:basic_parser http::basic_parser::basic_parser][indexterm2 basic_parser..http::basic_parser]
Copy constructor. 
[heading Synopsis]```basic_parser(    basic_parser const&);```[heading Description][endsect][section:body_limit http::basic_parser::body_limit][indexterm2 body_limit..http::basic_parser]
Set the limit on the payload body. 
[heading Synopsis]```voidbody_limit(    std::uint64_t v);```[heading Description]
This function sets the maximum allowed size of the payload body, before any encodings except chunked have been removed. Depending on the message semantics, one of these cases will apply:


* The Content-Length is specified and exceeds the limit. In this case the result [link beast.ref.boost__beast__http__error `http::body_limit`] is returned immediately after the header is parsed.


* The Content-Length is unspecified and the chunked encoding is not specified as the last encoding. In this case the end of message is determined by the end of file indicator on the associated stream or input source. If a sufficient number of body payload octets are presented to the parser to exceed the configured limit, the parse fails with the result [link beast.ref.boost__beast__http__error `http::body_limit`]


* The Transfer-Encoding specifies the chunked encoding as the last encoding. In this case, when the number of payload body octets produced by removing the chunked encoding exceeds the configured limit, the parse fails with the result [link beast.ref.boost__beast__http__error `http::body_limit`].

Setting the limit after any body octets have been parsed results in undefined behavior.

The default limit is 1MB for requests and 8MB for responses.

[heading Parameters][table [[Name][Description]]  [[`v`][    The payload body limit to set   ]]]

[endsect][section:chunked http::basic_parser::chunked][indexterm2 chunked..http::basic_parser]
Returns `true` if the last value for Transfer-Encoding is "chunked". 
[heading Synopsis]```boolchunked() const;```[heading Description]
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 


[endsect][section:content_length http::basic_parser::content_length][indexterm2 content_length..http::basic_parser]
Returns the optional value of Content-Length if known. 
[heading Synopsis]```boost::optional< std::uint64_t >content_length() const;```[heading Description]
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 


[endsect][section:eager http::basic_parser::eager][indexterm2 eager..http::basic_parser]
Returns `true` if the eager parse option is set. 
```bool``[link beast.ref.boost__beast__http__basic_parser.eager.overload1 eager]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.eager.overload1 more...]]`````
Set the eager parse option. 
```void``[link beast.ref.boost__beast__http__basic_parser.eager.overload2 eager]``(    bool v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.eager.overload2 more...]]`````[section:overload1 http::basic_parser::eager (1 of 2 overloads)]
Returns `true` if the eager parse option is set. 
[heading Synopsis]```booleager() const;```[heading Description][endsect][section:overload2 http::basic_parser::eager (2 of 2 overloads)]
Set the eager parse option. 
[heading Synopsis]```voideager(    bool v);```[heading Description]
Normally the parser returns after successfully parsing a structured element (header, chunk header, or chunk body) even if there are octets remaining in the input. This is necessary when attempting to parse the header first, or when the caller wants to inspect information which may be invalidated by subsequent parsing, such as a chunk extension. The `eager` option controls whether the parser keeps going after parsing structured element if there are octets remaining in the buffer and no error occurs. This option is automatically set or cleared during certain stream operations to improve performance with no change in functionality.

The default setting is `false`.

[heading Parameters][table [[Name][Description]]  [[`v`][    `true` to set the eager parse option or `false` to disable it.   ]]]

[endsect][endsect][section:got_some http::basic_parser::got_some][indexterm2 got_some..http::basic_parser]
Returns `true` if the parser has received at least one byte of input. 
[heading Synopsis]```boolgot_some() const;```[heading Description][endsect][section:header_limit http::basic_parser::header_limit][indexterm2 header_limit..http::basic_parser]
Set a limit on the total size of the header. 
[heading Synopsis]```voidheader_limit(    std::uint32_t v);```[heading Description]
This function sets the maximum allowed size of the header including all field name, value, and delimiter characters and also including the CRLF sequences in the serialized input. If the end of the header is not found within the limit of the header size, the error [link beast.ref.boost__beast__http__error `http::header_limit`] is returned by [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`].

Setting the limit after any header octets have been parsed results in undefined behavior. 
[endsect][section:is_done http::basic_parser::is_done][indexterm2 is_done..http::basic_parser]
Returns `true` if the message is complete. 
[heading Synopsis]```boolis_done() const;```[heading Description]
The message is complete after the full header is prduced and one of the following is true:


* The skip body option was set.


* The semantics of the message indicate there is no body.


* The semantics of the message indicate a body is expected, and the entire body was parsed. 


[endsect][section:is_header_done http::basic_parser::is_header_done][indexterm2 is_header_done..http::basic_parser]
Returns `true` if a the parser has produced the full header. 
[heading Synopsis]```boolis_header_done() const;```[heading Description][endsect][section:is_request http::basic_parser::is_request][indexterm2 is_request..http::basic_parser]
`true` if this parser parses requests, `false` for responses. 
[heading Synopsis]```using is_request = std::integral_constant< bool, isRequest >;```[heading Description][endsect][section:keep_alive http::basic_parser::keep_alive][indexterm2 keep_alive..http::basic_parser]
Returns `true` if the message has keep-alive connection semantics. 
[heading Synopsis]```boolkeep_alive() const;```[heading Description]
This function always returns `false` if [link beast.ref.boost__beast__http__basic_parser.need_eof `http::basic_parser::need_eof`] would return `false`.

[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 


[endsect][section:need_eof http::basic_parser::need_eof][indexterm2 need_eof..http::basic_parser]
Returns `true` if the message semantics require an end of file. 
[heading Synopsis]```boolneed_eof() const;```[heading Description]
Depending on the contents of the header, the parser may require and end of file notification to know where the end of the body lies. If this function returns `true` it will be necessary to call [link beast.ref.boost__beast__http__basic_parser.put_eof `http::basic_parser::put_eof`] when there will never be additional data from the input. 
[endsect][section:operator_eq_ http::basic_parser::operator=][indexterm2 operator=..http::basic_parser]
Move assignment. 
[heading Synopsis]```basic_parser&operator=(    basic_parser&&);```[heading Description][endsect][section:operator_eq_ http::basic_parser::operator=][indexterm2 operator=..http::basic_parser]
Copy assignment. 
[heading Synopsis]```basic_parser&operator=(    basic_parser const&);```[heading Description][endsect][section:put http::basic_parser::put][indexterm2 put..http::basic_parser]
Write a buffer sequence to the parser. 
[heading Synopsis]```template<    class __ConstBufferSequence__>std::size_tput(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function attempts to incrementally parse the HTTP message data stored in the caller provided buffers. Upon success, a positive return value indicates that the parser made forward progress, consuming that number of bytes.

In some cases there may be an insufficient number of octets in the input buffer in order to make forward progress. This is indicated by the code [link beast.ref.boost__beast__http__error `http::need_more`]. When this happens, the caller should place additional bytes into the buffer sequence and call [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] again.

The error code [link beast.ref.boost__beast__http__error `http::need_more`] is special. When this error is returned, a subsequent call to [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] may succeed if the buffers have been updated. Otherwise, upon error the parser may not be restarted.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    An object meeting the requirements of ConstBufferSequence that represents the next chunk of message data. If the length of this buffer sequence is one, the implementation will not allocate additional memory. The class [link beast.ref.boost__beast__flat_buffer `flat_buffer`] is provided as one way to meet this requirement  ]]  [[`ec`][    Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of octets consumed in the buffer sequence. The caller should remove these octets even if the error is set. 


[endsect][section:put_eof http::basic_parser::put_eof][indexterm2 put_eof..http::basic_parser]
Inform the parser that the end of stream was reached. 
[heading Synopsis]```voidput_eof(    error_code& ec);```[heading Description]
In certain cases, HTTP needs to know where the end of the stream is. For example, sometimes servers send responses without Content-Length and expect the client to consume input (for the body) until EOF. Callbacks and errors will still be processed as usual.

This is typically called when a read from the underlying stream object sets the error code to `boost::asio::error::eof`.

[heading Remarks]
Only valid after parsing a complete header.

[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred.   ]]]

[endsect][section:skip http::basic_parser::skip][indexterm2 skip..http::basic_parser]
Returns `true` if the skip parse option is set. 
```bool``[link beast.ref.boost__beast__http__basic_parser.skip.overload1 skip]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.skip.overload1 more...]]`````
Set the skip parse option. 
```void``[link beast.ref.boost__beast__http__basic_parser.skip.overload2 skip]``(    bool v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__basic_parser.skip.overload2 more...]]`````[section:overload1 http::basic_parser::skip (1 of 2 overloads)]
Returns `true` if the skip parse option is set. 
[heading Synopsis]```boolskip() const;```[heading Description][endsect][section:overload2 http::basic_parser::skip (2 of 2 overloads)]
Set the skip parse option. 
[heading Synopsis]```voidskip(    bool v);```[heading Description]
This option controls whether or not the parser expects to see an HTTP body, regardless of the presence or absence of certain fields such as Content-Length or a chunked Transfer-Encoding. Depending on the request, some responses do not carry a body. For example, a 200 response to a CONNECT request from a tunneling proxy, or a response to a HEAD request. In these cases, callers may use this function inform the parser that no body is expected. The parser will consider the message complete after the header has been received.

[heading Parameters][table [[Name][Description]]  [[`v`][    `true` to set the skip body option or `false` to disable it.  ]]]
[heading Remarks]
This function must called before any bytes are processed. 


[endsect][endsect][section:upgrade http::basic_parser::upgrade][indexterm2 upgrade..http::basic_parser]
Returns `true` if the message is an upgrade message. 
[heading Synopsis]```boolupgrade() const;```[heading Description]
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 


[endsect][section:basic_parser_dtor_ http::basic_parser::~basic_parser][indexterm2 ~basic_parser..http::basic_parser]
Destructor. 
[heading Synopsis]```~basic_parser();```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__basic_string_body http::basic_string_body]
A [*Body] using `std::basic_string` 
[heading Synopsis]Defined in header [include_file boost/beast/http/string_body.hpp]```template<    class CharT,    class Traits = std::char_traits<CharT>,    class Allocator = std::allocator<CharT>>struct basic_string_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_string_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_string_body.value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_string_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_string_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]][heading Description]
This body uses `std::basic_string` as a memory-based container for holding message payloads. Messages using this body type may be serialized and parsed. 
[section:reader http::basic_string_body::reader][indexterm2 reader..http::basic_string_body]
The algorithm for parsing the body. 
[heading Synopsis]```using reader = ``['implementation-defined]``;```[heading Description]
Meets the requirements of [*BodyReader]. 
[endsect][section:size http::basic_string_body::size][indexterm2 size..http::basic_string_body]
Returns the payload size of the body. 
[heading Synopsis]```staticstd::uint64_tsize(    value_type const& body);```[heading Description]
When this body is used with [link beast.ref.boost__beast__http__message.prepare_payload `http::message::prepare_payload`], the Content-Length will be set to the payload size, and any chunked Transfer-Encoding will be removed. 
[endsect][section:value_type http::basic_string_body::value_type][indexterm2 value_type..http::basic_string_body]
The type of container used for the body. 
[heading Synopsis]```using value_type = std::basic_string< CharT, Traits, Allocator >;```[heading Description]
This determines the type of [link beast.ref.boost__beast__http__message.body `http::message::body`] when this body type is used with a message container. 
[endsect][section:writer http::basic_string_body::writer][indexterm2 writer..http::basic_string_body]
The algorithm for serializing the body. 
[heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description]
Meets the requirements of [*BodyWriter]. 
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__buffer_body http::buffer_body]
A [*Body] using a caller provided buffer. 
[heading Synopsis]Defined in header [include_file boost/beast/http/buffer_body.hpp]```struct buffer_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__buffer_body__value_type [*value_type]]]    [      The type of the body member when used in a message.     ]  ]  [    [[link beast.ref.boost__beast__http__buffer_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__buffer_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Description]
Messages using this body type may be serialized and parsed. To use this class, the caller must initialize the members of [link beast.ref.boost__beast__http__buffer_body__value_type `http::buffer_body::value_type`] to appropriate values before each call to read or write during a stream operation. 
[section:reader http::buffer_body::reader][indexterm2 reader..http::buffer_body]
The algorithm for parsing the body. 
[heading Synopsis]```using reader = ``['implementation-defined]``;```[heading Description]
Meets the requirements of [*BodyReader]. 
[endsect][section:writer http::buffer_body::writer][indexterm2 writer..http::buffer_body]
The algorithm for serializing the body. 
[heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description]
Meets the requirements of [*BodyWriter]. 
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__buffer_body__value_type http::buffer_body::value_type]
The type of the body member when used in a message. 
[heading Synopsis]Defined in header [include_file boost/beast/http/buffer_body.hpp]```struct value_type```[heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__buffer_body__value_type.data [*data]]]    [      A pointer to a contiguous area of memory of size octets, else nullptr.     ]  ]  [    [[link beast.ref.boost__beast__http__buffer_body__value_type.more [*more]]]    [      true if this is not the last buffer.     ]  ]  [    [[link beast.ref.boost__beast__http__buffer_body__value_type.size [*size]]]    [      The number of octets in the buffer pointed to by data.     ]  ]][heading Description][section:data http::buffer_body::value_type::data][indexterm2 data..http::buffer_body::value_type]
A pointer to a contiguous area of memory of [link beast.ref.boost__beast__http__buffer_body__value_type.size `http::buffer_body::value_type::size`] octets, else `nullptr`. 
[heading Synopsis]```void * data = nullptr;```[heading Description]
[heading When Serializing]


If this is `nullptr` and `more` is `true`, the error [link beast.ref.boost__beast__http__error `http::need_buffer`] will be returned from [link beast.ref.boost__beast__http__serializer.get `http::serializer::get`] Otherwise, the serializer will use the memory pointed to by `data` having `size` octets of valid storage as the next buffer representing the body.

[heading When Parsing]


If this is `nullptr`, the error [link beast.ref.boost__beast__http__error `http::need_buffer`] will be returned from [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`]. Otherwise, the parser will store body octets into the memory pointed to by `data` having `size` octets of valid storage. After octets are stored, the `data` and `size` members are adjusted: `data` is incremented to point to the next octet after the data written, while `size` is decremented to reflect the remaining space at the memory location pointed to by `data`. 
[endsect][section:more http::buffer_body::value_type::more][indexterm2 more..http::buffer_body::value_type]
`true` if this is not the last buffer. 
[heading Synopsis]```bool more = true;```[heading Description]
[heading When Serializing]


If this is `true` and `data` is `nullptr`, the error [link beast.ref.boost__beast__http__error `http::need_buffer`] will be returned from [link beast.ref.boost__beast__http__serializer.get `http::serializer::get`]

[heading When Parsing]


This field is not used during parsing. 
[endsect][section:size http::buffer_body::value_type::size][indexterm2 size..http::buffer_body::value_type]
The number of octets in the buffer pointed to by [link beast.ref.boost__beast__http__buffer_body__value_type.data `http::buffer_body::value_type::data`]. 
[heading Synopsis]```std::size_t size = 0;```[heading Description]
[heading When Serializing]


If `data` is `nullptr` during serialization, this value is ignored. Otherwise, it represents the number of valid body octets pointed to by `data`.

[heading When Parsing]


The value of this field will be decremented during parsing to indicate the number of remaining free octets in the buffer pointed to by `data`. When it reaches zero, the parser will return [link beast.ref.boost__beast__http__error `http::need_buffer`], indicating to the caller that the values of `data` and `size` should be updated to point to a new memory buffer. 
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__chunk_body http::chunk_body]
A ['chunk]. 
[heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```template<    class __ConstBufferSequence__>class chunk_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_body.const_iterator [*const_iterator]]]    [      Required for ConstBufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_body.value_type [*value_type]]]    [      Required for ConstBufferSequence.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_body.begin [*begin]]]    [      Required for ConstBufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_body.chunk_body [*chunk_body]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_body.end [*end]]]    [      Required for ConstBufferSequence.     ]  ]][heading Description]
This implements a [*ConstBufferSequence] representing a ['chunk]. The serialized format is as follows: 

  chunk           = chunk-size [ chunk-ext ] CRLF chunk-data CRLF
  chunk-size      = 1*HEXDIG
  chunk-ext       = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
  chunk-ext-name  = token
  chunk-ext-val   = token / quoted-string
  chunk-data      = 1*OCTET ; a sequence of chunk-size octets


The chunk extension is optional.

To use this class, pass an instance of it to a stream algorithm as the buffer sequence.

[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 


[section:begin http::chunk_body::begin][indexterm2 begin..http::chunk_body]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:chunk_body http::chunk_body::chunk_body][indexterm2 chunk_body..http::chunk_body]
Constructor. 
```explicit``[link beast.ref.boost__beast__http__chunk_body.chunk_body.overload1 chunk_body]``(    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_body.chunk_body.overload1 more...]]````[link beast.ref.boost__beast__http__chunk_body.chunk_body.overload2 chunk_body]``(    ConstBufferSequence const& buffers,    string_view extensions);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_body.chunk_body.overload2 more...]]``template<    class ChunkExtensions>``[link beast.ref.boost__beast__http__chunk_body.chunk_body.overload3 chunk_body]``(    ConstBufferSequence const& buffers,    ChunkExtensions&& extensions);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_body.chunk_body.overload3 more...]]``template<    class ChunkExtensions,    class Allocator>``[link beast.ref.boost__beast__http__chunk_body.chunk_body.overload4 chunk_body]``(    ConstBufferSequence const& buffers,    ChunkExtensions&& extensions,    Allocator const& allocator);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_body.chunk_body.overload4 more...]]`````[section:overload1 http::chunk_body::chunk_body (1 of 4 overloads)]
Constructor. 
[heading Synopsis]```chunk_body(    ConstBufferSequence const& buffers);```[heading Description]
This constructs buffers representing a complete ['chunk] with no chunk extensions and having the size and contents of the specified buffer sequence.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    A buffer sequence representing the chunk body. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid while this object is in use.  ]]]
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 


[endsect][section:overload2 http::chunk_body::chunk_body (2 of 4 overloads)]
Constructor. 
[heading Synopsis]```chunk_body(    ConstBufferSequence const& buffers,    string_view extensions);```[heading Description]
This constructs buffers representing a complete ['chunk] with the passed chunk extensions and having the size and contents of the specified buffer sequence.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    A buffer sequence representing the chunk body. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid while this object is in use.  ]]  [[`extensions`][    The chunk extensions string. This string must be formatted correctly as per rfc7230, using this BNF syntax: 
``
  chunk-ext       = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
  chunk-ext-name  = token
  chunk-ext-val   = token / quoted-string
``
The data pointed to by this string view must remain valid for the lifetime of any operations performed on the object.  ]]]
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1.1 https://tools.ietf.org/html/rfc7230#section-4.1.1] 


[endsect][section:overload3 http::chunk_body::chunk_body (3 of 4 overloads)]
Constructor. 
[heading Synopsis]```template<    class ChunkExtensions>chunk_body(    ConstBufferSequence const& buffers,    ChunkExtensions&& extensions);```[heading Description]
This constructs buffers representing a complete ['chunk] with the passed chunk extensions and having the size and contents of the specified buffer sequence. The default allocator is used to provide storage for the extensions object.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    A buffer sequence representing the chunk body. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid while this object is in use.  ]]  [[`extensions`][    The chunk extensions object. The expression `extensions.str()` must be valid, and the return type must be convertible to [link beast.ref.boost__beast__string_view `string_view`]. This object will be copied or moved as needed to ensure that the chunk header object retains ownership of the buffers provided by the chunk extensions object.  ]]]
[heading Remarks]
This function participates in overload resolution only if [*ChunkExtensions] meets the requirements stated above.

[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 


[endsect][section:overload4 http::chunk_body::chunk_body (4 of 4 overloads)]
Constructor. 
[heading Synopsis]```template<    class ChunkExtensions,    class Allocator>chunk_body(    ConstBufferSequence const& buffers,    ChunkExtensions&& extensions,    Allocator const& allocator);```[heading Description]
This constructs buffers representing a complete ['chunk] with the passed chunk extensions and having the size and contents of the specified buffer sequence. The specified allocator is used to provide storage for the extensions object.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    A buffer sequence representing the chunk body. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid while this object is in use.  ]]  [[`extensions`][    The chunk extensions object. The expression `extensions.str()` must be valid, and the return type must be convertible to [link beast.ref.boost__beast__string_view `string_view`]. This object will be copied or moved as needed to ensure that the chunk header object retains ownership of the buffers provided by the chunk extensions object.  ]]  [[`allocator`][    The allocator to provide storage for the moved or copied extensions object.  ]]]
[heading Remarks]
This function participates in overload resolution only if [*ChunkExtensions] meets the requirements stated above.

[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 


[endsect][endsect][section:const_iterator http::chunk_body::const_iterator][indexterm2 const_iterator..http::chunk_body]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end http::chunk_body::end][indexterm2 end..http::chunk_body]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:value_type http::chunk_body::value_type][indexterm2 value_type..http::chunk_body]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```using value_type = ``['implementation-defined]``;```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__chunk_crlf http::chunk_crlf]
A chunked encoding crlf. 
[heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```struct chunk_crlf```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_crlf.const_iterator [*const_iterator]]]    [      Required for ConstBufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_crlf.value_type [*value_type]]]    [      Required for ConstBufferSequence.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_crlf.begin [*begin]]]    [      Required for ConstBufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_crlf.chunk_crlf [*chunk_crlf]]]    [      Constructor.       Required for ConstBufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_crlf.end [*end]]]    [      Required for ConstBufferSequence.     ]  ]][heading Description]
This implements a [*ConstBufferSequence] holding the CRLF (`"\\r\\n"`) used as a delimiter in a ['chunk].

To use this class, pass an instance of it to a stream algorithm as the buffer sequence: 

  // writes "\r\n"
  boost::asio::write(stream, chunk_crlf{});




[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 


[section:begin http::chunk_crlf::begin][indexterm2 begin..http::chunk_crlf]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:chunk_crlf http::chunk_crlf::chunk_crlf][indexterm2 chunk_crlf..http::chunk_crlf]
Constructor. 
`````[link beast.ref.boost__beast__http__chunk_crlf.chunk_crlf.overload1 chunk_crlf]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_crlf.chunk_crlf.overload1 more...]]`````
Required for [*ConstBufferSequence]. 
`````[link beast.ref.boost__beast__http__chunk_crlf.chunk_crlf.overload2 chunk_crlf]``(    chunk_crlf const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_crlf.chunk_crlf.overload2 more...]]`````[section:overload1 http::chunk_crlf::chunk_crlf (1 of 2 overloads)]
Constructor. 
[heading Synopsis]```chunk_crlf();```[heading Description][endsect][section:overload2 http::chunk_crlf::chunk_crlf (2 of 2 overloads)]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```chunk_crlf(    chunk_crlf const&);```[heading Description][endsect][endsect][section:const_iterator http::chunk_crlf::const_iterator][indexterm2 const_iterator..http::chunk_crlf]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```using const_iterator = value_type const*;```[heading Description][endsect][section:end http::chunk_crlf::end][indexterm2 end..http::chunk_crlf]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:value_type http::chunk_crlf::value_type][indexterm2 value_type..http::chunk_crlf]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```using value_type = ``['implementation-defined]``;```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__chunk_extensions http::chunk_extensions][indexterm1 http::chunk_extensions]
A set of chunk extensions. 
[heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```using chunk_extensions = basic_chunk_extensions< std::allocator< char >>;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.value_type [*value_type]]]    [      The type of value when iterating.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.basic_chunk_extensions [*basic_chunk_extensions]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.begin [*begin]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.clear [*clear]]]    [      Clear the chunk extensions.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.end [*end]]]    [          ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.insert [*insert]]]    [      Insert an extension name with an empty value.       Insert an extension value.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.parse [*parse]]]    [      Parse a set of chunk extensions.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_chunk_extensions.str [*str]]]    [      Return the serialized representation of the chunk extension.     ]  ]]
This container stores a set of chunk extensions suited for use with [link beast.ref.boost__beast__http__chunk_header `http::chunk_header`] and [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`]. The container may be iterated to access the extensions in their structured form.

Meets the requirements of ChunkExtensions 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__chunk_header http::chunk_header]
A ['chunk] header. 
[heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```class chunk_header```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_header.const_iterator [*const_iterator]]]    [      Required for ConstBufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_header.value_type [*value_type]]]    [      Required for ConstBufferSequence.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_header.begin [*begin]]]    [      Required for ConstBufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_header.chunk_header [*chunk_header]]]    [      Constructor.       Required for ConstBufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_header.end [*end]]]    [      Required for ConstBufferSequence.     ]  ]][heading Description]
This implements a [*ConstBufferSequence] representing the header of a ['chunk]. The serialized format is as follows: 

  chunk-header    = 1*HEXDIG chunk-ext CRLF       
  chunk-ext       = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
  chunk-ext-name  = token
  chunk-ext-val   = token / quoted-string


The chunk extension is optional. After the header and chunk body have been serialized, it is the callers responsibility to also serialize the final CRLF (`"\\r\\n"`).

This class allows the caller to emit piecewise chunk bodies, by first serializing the chunk header using this class and then serializing the chunk body in a series of one or more calls to a stream write operation.

To use this class, pass an instance of it to a stream algorithm as the buffer sequence: 

  // writes "400;x\r\n"
  boost::asio::write(stream, chunk_header{1024, "x"});




[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 


[section:begin http::chunk_header::begin][indexterm2 begin..http::chunk_header]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:chunk_header http::chunk_header::chunk_header][indexterm2 chunk_header..http::chunk_header]
Constructor. 
```explicit``[link beast.ref.boost__beast__http__chunk_header.chunk_header.overload1 chunk_header]``(    std::size_t size);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_header.chunk_header.overload1 more...]]````[link beast.ref.boost__beast__http__chunk_header.chunk_header.overload2 chunk_header]``(    std::size_t size,    string_view extensions);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_header.chunk_header.overload2 more...]]``template<    class ChunkExtensions>``[link beast.ref.boost__beast__http__chunk_header.chunk_header.overload3 chunk_header]``(    std::size_t size,    ChunkExtensions&& extensions);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_header.chunk_header.overload3 more...]]``template<    class ChunkExtensions,    class Allocator>``[link beast.ref.boost__beast__http__chunk_header.chunk_header.overload4 chunk_header]``(    std::size_t size,    ChunkExtensions&& extensions,    Allocator const& allocator);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_header.chunk_header.overload4 more...]]`````
Required for [*ConstBufferSequence]. 
`````[link beast.ref.boost__beast__http__chunk_header.chunk_header.overload5 chunk_header]``(    chunk_header const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_header.chunk_header.overload5 more...]]`````[section:overload1 http::chunk_header::chunk_header (1 of 5 overloads)]
Constructor. 
[heading Synopsis]```chunk_header(    std::size_t size);```[heading Description]
This constructs a buffer sequence representing a ['chunked-body] size and terminating CRLF (`"\\r\\n"`) with no chunk extensions.

[heading Parameters][table [[Name][Description]]  [[`size`][    The size of the chunk body that follows. The value must be greater than zero.  ]]]
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 


[endsect][section:overload2 http::chunk_header::chunk_header (2 of 5 overloads)]
Constructor. 
[heading Synopsis]```chunk_header(    std::size_t size,    string_view extensions);```[heading Description]
This constructs a buffer sequence representing a ['chunked-body] size and terminating CRLF (`"\\r\\n"`) with provided chunk extensions.

[heading Parameters][table [[Name][Description]]  [[`size`][    The size of the chunk body that follows. The value must be greater than zero.  ]]  [[`extensions`][    The chunk extensions string. This string must be formatted correctly as per rfc7230, using this BNF syntax: 
``
  chunk-ext       = *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
  chunk-ext-name  = token
  chunk-ext-val   = token / quoted-string
``
The data pointed to by this string view must remain valid for the lifetime of any operations performed on the object.  ]]]
[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1.1 https://tools.ietf.org/html/rfc7230#section-4.1.1] 


[endsect][section:overload3 http::chunk_header::chunk_header (3 of 5 overloads)]
Constructor. 
[heading Synopsis]```template<    class ChunkExtensions>chunk_header(    std::size_t size,    ChunkExtensions&& extensions);```[heading Description]
This constructs a buffer sequence representing a ['chunked-body] size and terminating CRLF (`"\\r\\n"`) with provided chunk extensions. The default allocator is used to provide storage for the extensions object.

[heading Parameters][table [[Name][Description]]  [[`size`][    The size of the chunk body that follows. The value must be greater than zero.  ]]  [[`extensions`][    The chunk extensions object. The expression `extensions.str()` must be valid, and the return type must be convertible to [link beast.ref.boost__beast__string_view `string_view`]. This object will be copied or moved as needed to ensure that the chunk header object retains ownership of the buffers provided by the chunk extensions object.  ]]]
[heading Remarks]
This function participates in overload resolution only if [*ChunkExtensions] meets the requirements stated above.

[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 


[endsect][section:overload4 http::chunk_header::chunk_header (4 of 5 overloads)]
Constructor. 
[heading Synopsis]```template<    class ChunkExtensions,    class Allocator>chunk_header(    std::size_t size,    ChunkExtensions&& extensions,    Allocator const& allocator);```[heading Description]
This constructs a buffer sequence representing a ['chunked-body] size and terminating CRLF (`"\\r\\n"`) with provided chunk extensions. The specified allocator is used to provide storage for the extensions object.

[heading Parameters][table [[Name][Description]]  [[`size`][    The size of the chunk body that follows. The value be greater than zero.  ]]  [[`extensions`][    The chunk extensions object. The expression `extensions.str()` must be valid, and the return type must be convertible to [link beast.ref.boost__beast__string_view `string_view`]. This object will be copied or moved as needed to ensure that the chunk header object retains ownership of the buffers provided by the chunk extensions object.  ]]  [[`allocator`][    The allocator to provide storage for the moved or copied extensions object.  ]]]
[heading Remarks]
This function participates in overload resolution only if [*ChunkExtensions] meets the requirements stated above.

[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-4.1 https://tools.ietf.org/html/rfc7230#section-4.1] 


[endsect][section:overload5 http::chunk_header::chunk_header (5 of 5 overloads)]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```chunk_header(    chunk_header const&);```[heading Description][endsect][endsect][section:const_iterator http::chunk_header::const_iterator][indexterm2 const_iterator..http::chunk_header]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end http::chunk_header::end][indexterm2 end..http::chunk_header]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:value_type http::chunk_header::value_type][indexterm2 value_type..http::chunk_header]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```using value_type = ``['implementation-defined]``;```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__chunk_last http::chunk_last]
A chunked-encoding last chunk. 
[heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```template<    class Trailer = chunk_crlf>class chunk_last```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_last.const_iterator [*const_iterator]]]    [      Required for ConstBufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_last.value_type [*value_type]]]    [      Required for ConstBufferSequence.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__chunk_last.begin [*begin]]]    [      Required for ConstBufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_last.chunk_last [*chunk_last]]]    [      Constructor.       Required for ConstBufferSequence.     ]  ]  [    [[link beast.ref.boost__beast__http__chunk_last.end [*end]]]    [      Required for ConstBufferSequence.     ]  ]][heading Description][section:begin http::chunk_last::begin][indexterm2 begin..http::chunk_last]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:chunk_last http::chunk_last::chunk_last][indexterm2 chunk_last..http::chunk_last]
Constructor. 
`````[link beast.ref.boost__beast__http__chunk_last.chunk_last.overload1 chunk_last]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_last.chunk_last.overload1 more...]]``explicit``[link beast.ref.boost__beast__http__chunk_last.chunk_last.overload2 chunk_last]``(    Trailer const& trailer);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_last.chunk_last.overload2 more...]]``template<    class Allocator>``[link beast.ref.boost__beast__http__chunk_last.chunk_last.overload3 chunk_last]``(    Trailer const& trailer,    Allocator const& allocator);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_last.chunk_last.overload3 more...]]`````
Required for [*ConstBufferSequence]. 
`````[link beast.ref.boost__beast__http__chunk_last.chunk_last.overload4 chunk_last]``(    chunk_last const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__chunk_last.chunk_last.overload4 more...]]`````[section:overload1 http::chunk_last::chunk_last (1 of 4 overloads)]
Constructor. 
[heading Synopsis]```chunk_last();```[heading Description]
The last chunk will have an empty trailer 
[endsect][section:overload2 http::chunk_last::chunk_last (2 of 4 overloads)]
Constructor. 
[heading Synopsis]```chunk_last(    Trailer const& trailer);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`trailer`][    The trailer to use. This may be a type meeting the requirements of either Fields or ConstBufferSequence. If it is a ConstBufferSequence, the trailer must be formatted correctly as per rfc7230 including a CRLF on its own line to denote the end of the trailer.   ]]]

[endsect][section:overload3 http::chunk_last::chunk_last (3 of 4 overloads)]
Constructor. 
[heading Synopsis]```template<    class Allocator>chunk_last(    Trailer const& trailer,    Allocator const& allocator);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`trailer`][    The trailer to use. This type must meet the requirements of Fields.  ]]  [[`allocator`][    The allocator to use for storing temporary data associated with the serialized trailer buffers.   ]]]

[endsect][section:overload4 http::chunk_last::chunk_last (4 of 4 overloads)]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```chunk_last(    chunk_last const&);```[heading Description][endsect][endsect][section:const_iterator http::chunk_last::const_iterator][indexterm2 const_iterator..http::chunk_last]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end http::chunk_last::end][indexterm2 end..http::chunk_last]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:value_type http::chunk_last::value_type][indexterm2 value_type..http::chunk_last]
Required for [*ConstBufferSequence]. 
[heading Synopsis]```using value_type = ``['implementation-defined]``;```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__dynamic_body http::dynamic_body][indexterm1 http::dynamic_body]
A dynamic message body represented by a [link beast.ref.boost__beast__multi_buffer `multi_buffer`]. 
[heading Synopsis]Defined in header [include_file boost/beast/http/dynamic_body.hpp]```using dynamic_body = basic_dynamic_body< multi_buffer >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_dynamic_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]]
This body uses a [*DynamicBuffer] as a memory-based container for holding message payloads. Messages using this body type may be serialized and parsed. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__empty_body http::empty_body]
An empty [*Body]. 
[heading Synopsis]Defined in header [include_file boost/beast/http/empty_body.hpp]```struct empty_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__empty_body__value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__empty_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__empty_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__empty_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]][heading Description]
This body is used to represent messages which do not have a message body. If this body is used with a parser, and the parser encounters octets corresponding to a message body, the parser will fail with the error [link beast.ref.boost__beast__http__error `http::unexpected_body`].

The Content-Length of this body is always 0. 
[section:reader http::empty_body::reader][indexterm2 reader..http::empty_body]
The algorithm for parsing the body. 
[heading Synopsis]```using reader = ``['implementation-defined]``;```[heading Description]
Meets the requirements of [*BodyReader]. 
[endsect][section:size http::empty_body::size][indexterm2 size..http::empty_body]
Returns the payload size of the body. 
[heading Synopsis]```staticstd::uint64_tsize(    value_type);```[heading Description]
When this body is used with [link beast.ref.boost__beast__http__message.prepare_payload `http::message::prepare_payload`], the Content-Length will be set to the payload size, and any chunked Transfer-Encoding will be removed. 
[endsect][section:writer http::empty_body::writer][indexterm2 writer..http::empty_body]
The algorithm for serializing the body. 
[heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description]
Meets the requirements of [*BodyWriter]. 
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__empty_body__value_type http::empty_body::value_type]
The type of container used for the body. 
[heading Synopsis]Defined in header [include_file boost/beast/http/empty_body.hpp]```struct value_type```[heading Description]
This determines the type of [link beast.ref.boost__beast__http__message.body `http::message::body`] when this body type is used with a message container. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__error http::error][indexterm1 http::error]
Error codes returned from HTTP algorithms and operations. 
[heading Synopsis]Defined in header [include_file boost/beast/http/error.hpp]```enum error```[indexterm2 end_of_stream..http::error][indexterm2 partial_message..http::error][indexterm2 need_more..http::error][indexterm2 unexpected_body..http::error][indexterm2 need_buffer..http::error][indexterm2 end_of_chunk..http::error][indexterm2 buffer_overflow..http::error][indexterm2 header_limit..http::error][indexterm2 body_limit..http::error][indexterm2 bad_alloc..http::error][indexterm2 bad_line_ending..http::error][indexterm2 bad_method..http::error][indexterm2 bad_target..http::error][indexterm2 bad_version..http::error][indexterm2 bad_status..http::error][indexterm2 bad_reason..http::error][indexterm2 bad_field..http::error][indexterm2 bad_value..http::error][indexterm2 bad_content_length..http::error][indexterm2 bad_transfer_encoding..http::error][indexterm2 bad_chunk..http::error][indexterm2 bad_chunk_extension..http::error][indexterm2 bad_obs_fold..http::error][heading Values][table [[Name][Description]]  [[[^end_of_stream]][The end of the stream was reached. This error is returned under the following conditions:When attempting to read HTTP data from a stream and the stream read returns the error boost::asio::error::eof before any new octets have been received.
When sending a complete HTTP message at once and the semantics of the message are that the connection should be closed to indicate the end of the message. 
]]  [[[^partial_message]][The incoming message is incomplete. This happens when the end of stream is reached during parsing and some octets have been received, but not the entire message. ]]  [[[^need_more]][Additional buffers are required. This error is returned during parsing when additional octets are needed. The caller should append more data to the existing buffer and retry the parse operaetion. ]]  [[[^unexpected_body]][An unexpected body was encountered during parsing. This error is returned when attempting to parse body octets into a message container which has the empty_body body type.empty_body 
]]  [[[^need_buffer]][Additional buffers are required. This error is returned under the following conditions:During serialization when using buffer_body. The caller should update the body to point to a new buffer or indicate that there are no more octets in the body.
During parsing when using buffer_body. The caller should update the body to point to a new storage area to receive additional body octets. 
]]  [[[^end_of_chunk]][The end of a chunk was reached. ]]  [[[^buffer_overflow]][Buffer maximum exceeded. This error is returned when reading HTTP content into a dynamic buffer, and the operation would exceed the maximum size of the buffer. ]]  [[[^header_limit]][Header limit exceeded. The parser detected an incoming message header which exceeded a configured limit. ]]  [[[^body_limit]][Body limit exceeded. The parser detected an incoming message body which exceeded a configured limit. ]]  [[[^bad_alloc]][A memory allocation failed. When basic_fields throws std::bad_alloc, it is converted into this error by parser. ]]  [[[^bad_line_ending]][The line ending was malformed. ]]  [[[^bad_method]][The method is invalid. ]]  [[[^bad_target]][The request-target is invalid. ]]  [[[^bad_version]][The HTTP-version is invalid. ]]  [[[^bad_status]][The status-code is invalid. ]]  [[[^bad_reason]][The reason-phrase is invalid. ]]  [[[^bad_field]][The field name is invalid. ]]  [[[^bad_value]][The field value is invalid. ]]  [[[^bad_content_length]][The Content-Length is invalid. ]]  [[[^bad_transfer_encoding]][The Transfer-Encoding is invalid. ]]  [[[^bad_chunk]][The chunk syntax is invalid. ]]  [[[^bad_chunk_extension]][The chunk extension is invalid. ]]  [[[^bad_obs_fold]][An obs-fold exceeded an internal limit. ]]][heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__ext_list http::ext_list]
A list of extensions in a comma separated HTTP field value. 
[heading Synopsis]Defined in header [include_file boost/beast/http/rfc7230.hpp]```class ext_list```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__ext_list.const_iterator [*const_iterator]]]    [      A constant iterator to the list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.value_type [*value_type]]]    [      The type of each element in the list.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__ext_list.begin [*begin]]]    [      Return a const iterator to the beginning of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.cbegin [*cbegin]]]    [      Return a const iterator to the beginning of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.cend [*cend]]]    [      Return a const iterator to the end of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.end [*end]]]    [      Return a const iterator to the end of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.exists [*exists]]]    [      Return true if a token is present in the list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.ext_list [*ext_list]]]    [      Construct a list.     ]  ]  [    [[link beast.ref.boost__beast__http__ext_list.find [*find]]]    [      Find a token in the list.     ]  ]][heading Description]
This container allows iteration of the extensions in an HTTP field value. The extension list is a comma separated list of token parameter list pairs.

If a parsing error is encountered while iterating the string, the behavior of the container will be as if a string containing only characters up to but excluding the first invalid character was used to construct the list.

[heading BNF]


  ext-list    = *( "," OWS ) ext *( OWS "," [ OWS ext ] )
  ext         = token param-list
  param-list  = *( OWS ";" OWS param )
  param       = token OWS [ "=" OWS ( token / quoted-string ) ]




To use this class, construct with the string to be parsed and then use [link beast.ref.boost__beast__http__ext_list.begin `http::ext_list::begin`] and [link beast.ref.boost__beast__http__ext_list.end `http::ext_list::end`], or range-for to iterate each item:

[heading Example]


  for(auto const& ext : ext_list{"none, 7z;level=9, zip;no_context_takeover;bits=15"})
  {
      std::cout << ext.first << "\n";
      for(auto const& param : ext.second)
      {
          std::cout << ";" << param.first;
          if(! param.second.empty())
              std::cout << "=" << param.second;
          std::cout << "\n";
      }
  }





[section:begin http::ext_list::begin][indexterm2 begin..http::ext_list]
Return a const iterator to the beginning of the list. 
[heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:cbegin http::ext_list::cbegin][indexterm2 cbegin..http::ext_list]
Return a const iterator to the beginning of the list. 
[heading Synopsis]```const_iteratorcbegin() const;```[heading Description][endsect][section:cend http::ext_list::cend][indexterm2 cend..http::ext_list]
Return a const iterator to the end of the list. 
[heading Synopsis]```const_iteratorcend() const;```[heading Description][endsect][section:const_iterator http::ext_list::const_iterator][indexterm2 const_iterator..http::ext_list]
A constant iterator to the list. 
[heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end http::ext_list::end][indexterm2 end..http::ext_list]
Return a const iterator to the end of the list. 
[heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:exists http::ext_list::exists][indexterm2 exists..http::ext_list]
Return `true` if a token is present in the list. 
[heading Synopsis]```template<    class T>boolexists(    T const& s);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`s`][    The token to find. A case-insensitive comparison is used.   ]]]

[endsect][section:ext_list http::ext_list::ext_list][indexterm2 ext_list..http::ext_list]
Construct a list. 
[heading Synopsis]```ext_list(    string_view s);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`s`][    A string containing the list contents. The string must remain valid for the lifetime of the container.   ]]]

[endsect][section:find http::ext_list::find][indexterm2 find..http::ext_list]
Find a token in the list. 
[heading Synopsis]```template<    class T>const_iteratorfind(    T const& s);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`s`][    The token to find. A case-insensitive comparison is used.  ]]]
[heading Return Value]
An iterator to the matching token, or `end()` if no token exists. 


[endsect][section:value_type http::ext_list::value_type][indexterm2 value_type..http::ext_list]
The type of each element in the list. 
[heading Synopsis]```using value_type = std::pair< string_view, param_list >;```[heading Description]
The first element of the pair is the extension token, and the second element of the pair is an iterable container holding the extension's name/value parameters. 
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__field http::field][indexterm1 http::field][heading Synopsis]Defined in header [include_file boost/beast/http/field.hpp]```enum field```[indexterm2 unknown..http::field][indexterm2 a_im..http::field][indexterm2 accept..http::field][indexterm2 accept_additions..http::field][indexterm2 accept_charset..http::field][indexterm2 accept_datetime..http::field][indexterm2 accept_encoding..http::field][indexterm2 accept_features..http::field][indexterm2 accept_language..http::field][indexterm2 accept_patch..http::field][indexterm2 accept_post..http::field][indexterm2 accept_ranges..http::field][indexterm2 access_control..http::field][indexterm2 access_control_allow_credentials..http::field][indexterm2 access_control_allow_headers..http::field][indexterm2 access_control_allow_methods..http::field][indexterm2 access_control_allow_origin..http::field][indexterm2 access_control_max_age..http::field][indexterm2 access_control_request_headers..http::field][indexterm2 access_control_request_method..http::field][indexterm2 age..http::field][indexterm2 allow..http::field][indexterm2 alpn..http::field][indexterm2 also_control..http::field][indexterm2 alt_svc..http::field][indexterm2 alt_used..http::field][indexterm2 alternate_recipient..http::field][indexterm2 alternates..http::field][indexterm2 apparently_to..http::field][indexterm2 apply_to_redirect_ref..http::field][indexterm2 approved..http::field][indexterm2 archive..http::field][indexterm2 archived_at..http::field][indexterm2 article_names..http::field][indexterm2 article_updates..http::field][indexterm2 authentication_control..http::field][indexterm2 authentication_info..http::field][indexterm2 authentication_results..http::field][indexterm2 authorization..http::field][indexterm2 auto_submitted..http::field][indexterm2 autoforwarded..http::field][indexterm2 autosubmitted..http::field][indexterm2 base..http::field][indexterm2 bcc..http::field][indexterm2 body..http::field][indexterm2 c_ext..http::field][indexterm2 c_man..http::field][indexterm2 c_opt..http::field][indexterm2 c_pep..http::field][indexterm2 c_pep_info..http::field][indexterm2 cache_control..http::field][indexterm2 caldav_timezones..http::field][indexterm2 cancel_key..http::field][indexterm2 cancel_lock..http::field][indexterm2 cc..http::field][indexterm2 close..http::field][indexterm2 comments..http::field][indexterm2 compliance..http::field][indexterm2 connection..http::field][indexterm2 content_alternative..http::field][indexterm2 content_base..http::field][indexterm2 content_description..http::field][indexterm2 content_disposition..http::field][indexterm2 content_duration..http::field][indexterm2 content_encoding..http::field][indexterm2 content_features..http::field][indexterm2 content_id..http::field][indexterm2 content_identifier..http::field][indexterm2 content_language..http::field][indexterm2 content_length..http::field][indexterm2 content_location..http::field][indexterm2 content_md5..http::field][indexterm2 content_range..http::field][indexterm2 content_return..http::field][indexterm2 content_script_type..http::field][indexterm2 content_style_type..http::field][indexterm2 content_transfer_encoding..http::field][indexterm2 content_type..http::field][indexterm2 content_version..http::field][indexterm2 control..http::field][indexterm2 conversion..http::field][indexterm2 conversion_with_loss..http::field][indexterm2 cookie..http::field][indexterm2 cookie2..http::field][indexterm2 cost..http::field][indexterm2 dasl..http::field][indexterm2 date..http::field][indexterm2 date_received..http::field][indexterm2 dav..http::field][indexterm2 default_style..http::field][indexterm2 deferred_delivery..http::field][indexterm2 delivery_date..http::field][indexterm2 delta_base..http::field][indexterm2 depth..http::field][indexterm2 derived_from..http::field][indexterm2 destination..http::field][indexterm2 differential_id..http::field][indexterm2 digest..http::field][indexterm2 discarded_x400_ipms_extensions..http::field][indexterm2 discarded_x400_mts_extensions..http::field][indexterm2 disclose_recipients..http::field][indexterm2 disposition_notification_options..http::field][indexterm2 disposition_notification_to..http::field][indexterm2 distribution..http::field][indexterm2 dkim_signature..http::field][indexterm2 dl_expansion_history..http::field][indexterm2 downgraded_bcc..http::field][indexterm2 downgraded_cc..http::field][indexterm2 downgraded_disposition_notification_to..http::field][indexterm2 downgraded_final_recipient..http::field][indexterm2 downgraded_from..http::field][indexterm2 downgraded_in_reply_to..http::field][indexterm2 downgraded_mail_from..http::field][indexterm2 downgraded_message_id..http::field][indexterm2 downgraded_original_recipient..http::field][indexterm2 downgraded_rcpt_to..http::field][indexterm2 downgraded_references..http::field][indexterm2 downgraded_reply_to..http::field][indexterm2 downgraded_resent_bcc..http::field][indexterm2 downgraded_resent_cc..http::field][indexterm2 downgraded_resent_from..http::field][indexterm2 downgraded_resent_reply_to..http::field][indexterm2 downgraded_resent_sender..http::field][indexterm2 downgraded_resent_to..http::field][indexterm2 downgraded_return_path..http::field][indexterm2 downgraded_sender..http::field][indexterm2 downgraded_to..http::field][indexterm2 ediint_features..http::field][indexterm2 eesst_version..http::field][indexterm2 encoding..http::field][indexterm2 encrypted..http::field][indexterm2 errors_to..http::field][indexterm2 etag..http::field][indexterm2 expect..http::field][indexterm2 expires..http::field][indexterm2 expiry_date..http::field][indexterm2 ext..http::field][indexterm2 followup_to..http::field][indexterm2 forwarded..http::field][indexterm2 from..http::field][indexterm2 generate_delivery_report..http::field][indexterm2 getprofile..http::field][indexterm2 hobareg..http::field][indexterm2 host..http::field][indexterm2 http2_settings..http::field][indexterm2 if_..http::field][indexterm2 if_match..http::field][indexterm2 if_modified_since..http::field][indexterm2 if_none_match..http::field][indexterm2 if_range..http::field][indexterm2 if_schedule_tag_match..http::field][indexterm2 if_unmodified_since..http::field][indexterm2 im..http::field][indexterm2 importance..http::field][indexterm2 in_reply_to..http::field][indexterm2 incomplete_copy..http::field][indexterm2 injection_date..http::field][indexterm2 injection_info..http::field][indexterm2 jabber_id..http::field][indexterm2 keep_alive..http::field][indexterm2 keywords..http::field][indexterm2 label..http::field][indexterm2 language..http::field][indexterm2 last_modified..http::field][indexterm2 latest_delivery_time..http::field][indexterm2 lines..http::field][indexterm2 link..http::field][indexterm2 list_archive..http::field][indexterm2 list_help..http::field][indexterm2 list_id..http::field][indexterm2 list_owner..http::field][indexterm2 list_post..http::field][indexterm2 list_subscribe..http::field][indexterm2 list_unsubscribe..http::field][indexterm2 list_unsubscribe_post..http::field][indexterm2 location..http::field][indexterm2 lock_token..http::field][indexterm2 man..http::field][indexterm2 max_forwards..http::field][indexterm2 memento_datetime..http::field][indexterm2 message_context..http::field][indexterm2 message_id..http::field][indexterm2 message_type..http::field][indexterm2 meter..http::field][indexterm2 method_check..http::field][indexterm2 method_check_expires..http::field][indexterm2 mime_version..http::field][indexterm2 mmhs_acp127_message_identifier..http::field][indexterm2 mmhs_authorizing_users..http::field][indexterm2 mmhs_codress_message_indicator..http::field][indexterm2 mmhs_copy_precedence..http::field][indexterm2 mmhs_exempted_address..http::field][indexterm2 mmhs_extended_authorisation_info..http::field][indexterm2 mmhs_handling_instructions..http::field][indexterm2 mmhs_message_instructions..http::field][indexterm2 mmhs_message_type..http::field][indexterm2 mmhs_originator_plad..http::field][indexterm2 mmhs_originator_reference..http::field][indexterm2 mmhs_other_recipients_indicator_cc..http::field][indexterm2 mmhs_other_recipients_indicator_to..http::field][indexterm2 mmhs_primary_precedence..http::field][indexterm2 mmhs_subject_indicator_codes..http::field][indexterm2 mt_priority..http::field][indexterm2 negotiate..http::field][indexterm2 newsgroups..http::field][indexterm2 nntp_posting_date..http::field][indexterm2 nntp_posting_host..http::field][indexterm2 non_compliance..http::field][indexterm2 obsoletes..http::field][indexterm2 opt..http::field][indexterm2 optional..http::field][indexterm2 optional_www_authenticate..http::field][indexterm2 ordering_type..http::field][indexterm2 organization..http::field][indexterm2 origin..http::field][indexterm2 original_encoded_information_types..http::field][indexterm2 original_from..http::field][indexterm2 original_message_id..http::field][indexterm2 original_recipient..http::field][indexterm2 original_sender..http::field][indexterm2 original_subject..http::field][indexterm2 originator_return_address..http::field][indexterm2 overwrite..http::field][indexterm2 p3p..http::field][indexterm2 path..http::field][indexterm2 pep..http::field][indexterm2 pep_info..http::field][indexterm2 pics_label..http::field][indexterm2 position..http::field][indexterm2 posting_version..http::field][indexterm2 pragma..http::field][indexterm2 prefer..http::field][indexterm2 preference_applied..http::field][indexterm2 prevent_nondelivery_report..http::field][indexterm2 priority..http::field][indexterm2 privicon..http::field][indexterm2 profileobject..http::field][indexterm2 protocol..http::field][indexterm2 protocol_info..http::field][indexterm2 protocol_query..http::field][indexterm2 protocol_request..http::field][indexterm2 proxy_authenticate..http::field][indexterm2 proxy_authentication_info..http::field][indexterm2 proxy_authorization..http::field][indexterm2 proxy_connection..http::field][indexterm2 proxy_features..http::field][indexterm2 proxy_instruction..http::field][indexterm2 public_..http::field][indexterm2 public_key_pins..http::field][indexterm2 public_key_pins_report_only..http::field][indexterm2 range..http::field][indexterm2 received..http::field][indexterm2 received_spf..http::field][indexterm2 redirect_ref..http::field][indexterm2 references..http::field][indexterm2 referer..http::field][indexterm2 referer_root..http::field][indexterm2 relay_version..http::field][indexterm2 reply_by..http::field][indexterm2 reply_to..http::field][indexterm2 require_recipient_valid_since..http::field][indexterm2 resent_bcc..http::field][indexterm2 resent_cc..http::field][indexterm2 resent_date..http::field][indexterm2 resent_from..http::field][indexterm2 resent_message_id..http::field][indexterm2 resent_reply_to..http::field][indexterm2 resent_sender..http::field][indexterm2 resent_to..http::field][indexterm2 resolution_hint..http::field][indexterm2 resolver_location..http::field][indexterm2 retry_after..http::field][indexterm2 return_path..http::field][indexterm2 safe..http::field][indexterm2 schedule_reply..http::field][indexterm2 schedule_tag..http::field][indexterm2 sec_websocket_accept..http::field][indexterm2 sec_websocket_extensions..http::field][indexterm2 sec_websocket_key..http::field][indexterm2 sec_websocket_protocol..http::field][indexterm2 sec_websocket_version..http::field][indexterm2 security_scheme..http::field][indexterm2 see_also..http::field][indexterm2 sender..http::field][indexterm2 sensitivity..http::field][indexterm2 server..http::field][indexterm2 set_cookie..http::field][indexterm2 set_cookie2..http::field][indexterm2 setprofile..http::field][indexterm2 sio_label..http::field][indexterm2 sio_label_history..http::field][indexterm2 slug..http::field][indexterm2 soapaction..http::field][indexterm2 solicitation..http::field][indexterm2 status_uri..http::field][indexterm2 strict_transport_security..http::field][indexterm2 subject..http::field][indexterm2 subok..http::field][indexterm2 subst..http::field][indexterm2 summary..http::field][indexterm2 supersedes..http::field][indexterm2 surrogate_capability..http::field][indexterm2 surrogate_control..http::field][indexterm2 tcn..http::field][indexterm2 te..http::field][indexterm2 timeout..http::field][indexterm2 title..http::field][indexterm2 to..http::field][indexterm2 topic..http::field][indexterm2 trailer..http::field][indexterm2 transfer_encoding..http::field][indexterm2 ttl..http::field][indexterm2 ua_color..http::field][indexterm2 ua_media..http::field][indexterm2 ua_pixels..http::field][indexterm2 ua_resolution..http::field][indexterm2 ua_windowpixels..http::field][indexterm2 upgrade..http::field][indexterm2 urgency..http::field][indexterm2 uri..http::field][indexterm2 user_agent..http::field][indexterm2 variant_vary..http::field][indexterm2 vary..http::field][indexterm2 vbr_info..http::field][indexterm2 version..http::field][indexterm2 via..http::field][indexterm2 want_digest..http::field][indexterm2 warning..http::field][indexterm2 www_authenticate..http::field][indexterm2 x_archived_at..http::field][indexterm2 x_device_accept..http::field][indexterm2 x_device_accept_charset..http::field][indexterm2 x_device_accept_encoding..http::field][indexterm2 x_device_accept_language..http::field][indexterm2 x_device_user_agent..http::field][indexterm2 x_frame_options..http::field][indexterm2 x_mittente..http::field][indexterm2 x_pgp_sig..http::field][indexterm2 x_ricevuta..http::field][indexterm2 x_riferimento_message_id..http::field][indexterm2 x_tiporicevuta..http::field][indexterm2 x_trasporto..http::field][indexterm2 x_verificasicurezza..http::field][indexterm2 x400_content_identifier..http::field][indexterm2 x400_content_return..http::field][indexterm2 x400_content_type..http::field][indexterm2 x400_mts_identifier..http::field][indexterm2 x400_originator..http::field][indexterm2 x400_received..http::field][indexterm2 x400_recipients..http::field][indexterm2 x400_trace..http::field][indexterm2 xref..http::field][heading Values][table [[Name][Description]]  [[[^unknown]][]]  [[[^a_im]][]]  [[[^accept]][]]  [[[^accept_additions]][]]  [[[^accept_charset]][]]  [[[^accept_datetime]][]]  [[[^accept_encoding]][]]  [[[^accept_features]][]]  [[[^accept_language]][]]  [[[^accept_patch]][]]  [[[^accept_post]][]]  [[[^accept_ranges]][]]  [[[^access_control]][]]  [[[^access_control_allow_credentials]][]]  [[[^access_control_allow_headers]][]]  [[[^access_control_allow_methods]][]]  [[[^access_control_allow_origin]][]]  [[[^access_control_max_age]][]]  [[[^access_control_request_headers]][]]  [[[^access_control_request_method]][]]  [[[^age]][]]  [[[^allow]][]]  [[[^alpn]][]]  [[[^also_control]][]]  [[[^alt_svc]][]]  [[[^alt_used]][]]  [[[^alternate_recipient]][]]  [[[^alternates]][]]  [[[^apparently_to]][]]  [[[^apply_to_redirect_ref]][]]  [[[^approved]][]]  [[[^archive]][]]  [[[^archived_at]][]]  [[[^article_names]][]]  [[[^article_updates]][]]  [[[^authentication_control]][]]  [[[^authentication_info]][]]  [[[^authentication_results]][]]  [[[^authorization]][]]  [[[^auto_submitted]][]]  [[[^autoforwarded]][]]  [[[^autosubmitted]][]]  [[[^base]][]]  [[[^bcc]][]]  [[[^body]][]]  [[[^c_ext]][]]  [[[^c_man]][]]  [[[^c_opt]][]]  [[[^c_pep]][]]  [[[^c_pep_info]][]]  [[[^cache_control]][]]  [[[^caldav_timezones]][]]  [[[^cancel_key]][]]  [[[^cancel_lock]][]]  [[[^cc]][]]  [[[^close]][]]  [[[^comments]][]]  [[[^compliance]][]]  [[[^connection]][]]  [[[^content_alternative]][]]  [[[^content_base]][]]  [[[^content_description]][]]  [[[^content_disposition]][]]  [[[^content_duration]][]]  [[[^content_encoding]][]]  [[[^content_features]][]]  [[[^content_id]][]]  [[[^content_identifier]][]]  [[[^content_language]][]]  [[[^content_length]][]]  [[[^content_location]][]]  [[[^content_md5]][]]  [[[^content_range]][]]  [[[^content_return]][]]  [[[^content_script_type]][]]  [[[^content_style_type]][]]  [[[^content_transfer_encoding]][]]  [[[^content_type]][]]  [[[^content_version]][]]  [[[^control]][]]  [[[^conversion]][]]  [[[^conversion_with_loss]][]]  [[[^cookie]][]]  [[[^cookie2]][]]  [[[^cost]][]]  [[[^dasl]][]]  [[[^date]][]]  [[[^date_received]][]]  [[[^dav]][]]  [[[^default_style]][]]  [[[^deferred_delivery]][]]  [[[^delivery_date]][]]  [[[^delta_base]][]]  [[[^depth]][]]  [[[^derived_from]][]]  [[[^destination]][]]  [[[^differential_id]][]]  [[[^digest]][]]  [[[^discarded_x400_ipms_extensions]][]]  [[[^discarded_x400_mts_extensions]][]]  [[[^disclose_recipients]][]]  [[[^disposition_notification_options]][]]  [[[^disposition_notification_to]][]]  [[[^distribution]][]]  [[[^dkim_signature]][]]  [[[^dl_expansion_history]][]]  [[[^downgraded_bcc]][]]  [[[^downgraded_cc]][]]  [[[^downgraded_disposition_notification_to]][]]  [[[^downgraded_final_recipient]][]]  [[[^downgraded_from]][]]  [[[^downgraded_in_reply_to]][]]  [[[^downgraded_mail_from]][]]  [[[^downgraded_message_id]][]]  [[[^downgraded_original_recipient]][]]  [[[^downgraded_rcpt_to]][]]  [[[^downgraded_references]][]]  [[[^downgraded_reply_to]][]]  [[[^downgraded_resent_bcc]][]]  [[[^downgraded_resent_cc]][]]  [[[^downgraded_resent_from]][]]  [[[^downgraded_resent_reply_to]][]]  [[[^downgraded_resent_sender]][]]  [[[^downgraded_resent_to]][]]  [[[^downgraded_return_path]][]]  [[[^downgraded_sender]][]]  [[[^downgraded_to]][]]  [[[^ediint_features]][]]  [[[^eesst_version]][]]  [[[^encoding]][]]  [[[^encrypted]][]]  [[[^errors_to]][]]  [[[^etag]][]]  [[[^expect]][]]  [[[^expires]][]]  [[[^expiry_date]][]]  [[[^ext]][]]  [[[^followup_to]][]]  [[[^forwarded]][]]  [[[^from]][]]  [[[^generate_delivery_report]][]]  [[[^getprofile]][]]  [[[^hobareg]][]]  [[[^host]][]]  [[[^http2_settings]][]]  [[[^if_]][]]  [[[^if_match]][]]  [[[^if_modified_since]][]]  [[[^if_none_match]][]]  [[[^if_range]][]]  [[[^if_schedule_tag_match]][]]  [[[^if_unmodified_since]][]]  [[[^im]][]]  [[[^importance]][]]  [[[^in_reply_to]][]]  [[[^incomplete_copy]][]]  [[[^injection_date]][]]  [[[^injection_info]][]]  [[[^jabber_id]][]]  [[[^keep_alive]][]]  [[[^keywords]][]]  [[[^label]][]]  [[[^language]][]]  [[[^last_modified]][]]  [[[^latest_delivery_time]][]]  [[[^lines]][]]  [[[^link]][]]  [[[^list_archive]][]]  [[[^list_help]][]]  [[[^list_id]][]]  [[[^list_owner]][]]  [[[^list_post]][]]  [[[^list_subscribe]][]]  [[[^list_unsubscribe]][]]  [[[^list_unsubscribe_post]][]]  [[[^location]][]]  [[[^lock_token]][]]  [[[^man]][]]  [[[^max_forwards]][]]  [[[^memento_datetime]][]]  [[[^message_context]][]]  [[[^message_id]][]]  [[[^message_type]][]]  [[[^meter]][]]  [[[^method_check]][]]  [[[^method_check_expires]][]]  [[[^mime_version]][]]  [[[^mmhs_acp127_message_identifier]][]]  [[[^mmhs_authorizing_users]][]]  [[[^mmhs_codress_message_indicator]][]]  [[[^mmhs_copy_precedence]][]]  [[[^mmhs_exempted_address]][]]  [[[^mmhs_extended_authorisation_info]][]]  [[[^mmhs_handling_instructions]][]]  [[[^mmhs_message_instructions]][]]  [[[^mmhs_message_type]][]]  [[[^mmhs_originator_plad]][]]  [[[^mmhs_originator_reference]][]]  [[[^mmhs_other_recipients_indicator_cc]][]]  [[[^mmhs_other_recipients_indicator_to]][]]  [[[^mmhs_primary_precedence]][]]  [[[^mmhs_subject_indicator_codes]][]]  [[[^mt_priority]][]]  [[[^negotiate]][]]  [[[^newsgroups]][]]  [[[^nntp_posting_date]][]]  [[[^nntp_posting_host]][]]  [[[^non_compliance]][]]  [[[^obsoletes]][]]  [[[^opt]][]]  [[[^optional]][]]  [[[^optional_www_authenticate]][]]  [[[^ordering_type]][]]  [[[^organization]][]]  [[[^origin]][]]  [[[^original_encoded_information_types]][]]  [[[^original_from]][]]  [[[^original_message_id]][]]  [[[^original_recipient]][]]  [[[^original_sender]][]]  [[[^original_subject]][]]  [[[^originator_return_address]][]]  [[[^overwrite]][]]  [[[^p3p]][]]  [[[^path]][]]  [[[^pep]][]]  [[[^pep_info]][]]  [[[^pics_label]][]]  [[[^position]][]]  [[[^posting_version]][]]  [[[^pragma]][]]  [[[^prefer]][]]  [[[^preference_applied]][]]  [[[^prevent_nondelivery_report]][]]  [[[^priority]][]]  [[[^privicon]][]]  [[[^profileobject]][]]  [[[^protocol]][]]  [[[^protocol_info]][]]  [[[^protocol_query]][]]  [[[^protocol_request]][]]  [[[^proxy_authenticate]][]]  [[[^proxy_authentication_info]][]]  [[[^proxy_authorization]][]]  [[[^proxy_connection]][]]  [[[^proxy_features]][]]  [[[^proxy_instruction]][]]  [[[^public_]][]]  [[[^public_key_pins]][]]  [[[^public_key_pins_report_only]][]]  [[[^range]][]]  [[[^received]][]]  [[[^received_spf]][]]  [[[^redirect_ref]][]]  [[[^references]][]]  [[[^referer]][]]  [[[^referer_root]][]]  [[[^relay_version]][]]  [[[^reply_by]][]]  [[[^reply_to]][]]  [[[^require_recipient_valid_since]][]]  [[[^resent_bcc]][]]  [[[^resent_cc]][]]  [[[^resent_date]][]]  [[[^resent_from]][]]  [[[^resent_message_id]][]]  [[[^resent_reply_to]][]]  [[[^resent_sender]][]]  [[[^resent_to]][]]  [[[^resolution_hint]][]]  [[[^resolver_location]][]]  [[[^retry_after]][]]  [[[^return_path]][]]  [[[^safe]][]]  [[[^schedule_reply]][]]  [[[^schedule_tag]][]]  [[[^sec_websocket_accept]][]]  [[[^sec_websocket_extensions]][]]  [[[^sec_websocket_key]][]]  [[[^sec_websocket_protocol]][]]  [[[^sec_websocket_version]][]]  [[[^security_scheme]][]]  [[[^see_also]][]]  [[[^sender]][]]  [[[^sensitivity]][]]  [[[^server]][]]  [[[^set_cookie]][]]  [[[^set_cookie2]][]]  [[[^setprofile]][]]  [[[^sio_label]][]]  [[[^sio_label_history]][]]  [[[^slug]][]]  [[[^soapaction]][]]  [[[^solicitation]][]]  [[[^status_uri]][]]  [[[^strict_transport_security]][]]  [[[^subject]][]]  [[[^subok]][]]  [[[^subst]][]]  [[[^summary]][]]  [[[^supersedes]][]]  [[[^surrogate_capability]][]]  [[[^surrogate_control]][]]  [[[^tcn]][]]  [[[^te]][]]  [[[^timeout]][]]  [[[^title]][]]  [[[^to]][]]  [[[^topic]][]]  [[[^trailer]][]]  [[[^transfer_encoding]][]]  [[[^ttl]][]]  [[[^ua_color]][]]  [[[^ua_media]][]]  [[[^ua_pixels]][]]  [[[^ua_resolution]][]]  [[[^ua_windowpixels]][]]  [[[^upgrade]][]]  [[[^urgency]][]]  [[[^uri]][]]  [[[^user_agent]][]]  [[[^variant_vary]][]]  [[[^vary]][]]  [[[^vbr_info]][]]  [[[^version]][]]  [[[^via]][]]  [[[^want_digest]][]]  [[[^warning]][]]  [[[^www_authenticate]][]]  [[[^x_archived_at]][]]  [[[^x_device_accept]][]]  [[[^x_device_accept_charset]][]]  [[[^x_device_accept_encoding]][]]  [[[^x_device_accept_language]][]]  [[[^x_device_user_agent]][]]  [[[^x_frame_options]][]]  [[[^x_mittente]][]]  [[[^x_pgp_sig]][]]  [[[^x_ricevuta]][]]  [[[^x_riferimento_message_id]][]]  [[[^x_tiporicevuta]][]]  [[[^x_trasporto]][]]  [[[^x_verificasicurezza]][]]  [[[^x400_content_identifier]][]]  [[[^x400_content_return]][]]  [[[^x400_content_type]][]]  [[[^x400_mts_identifier]][]]  [[[^x400_originator]][]]  [[[^x400_received]][]]  [[[^x400_recipients]][]]  [[[^x400_trace]][]]  [[[^xref]][]]][heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__fields http::fields][indexterm1 http::fields]
A typical HTTP header fields container. 
[heading Synopsis]Defined in header [include_file boost/beast/http/fields.hpp]```using fields = basic_fields< std::allocator< char >>;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.allocator_type [*allocator_type]]]    [      The type of allocator used.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__key_compare [*key_compare]]]    [      A strictly less predicate for comparing keys, using a case-insensitive comparison.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields__value_type [*value_type]]]    [      The type of element used to represent a field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.const_iterator [*const_iterator]]]    [      A constant iterator to the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.iterator [*iterator]]]    [      A constant iterator to the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.writer [*writer]]]    [      The algorithm used to serialize the header.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.at [*at]]]    [      Returns the value for a field, or throws an exception.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.basic_fields [*basic_fields]]]    [      Constructor.       Move constructor.       Copy constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.begin [*begin]]]    [      Return a const iterator to the beginning of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.cbegin [*cbegin]]]    [      Return a const iterator to the beginning of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.cend [*cend]]]    [      Return a const iterator to the end of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.clear [*clear]]]    [      Remove all fields from the container.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.count [*count]]]    [      Return the number of fields with the specified name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.end [*end]]]    [      Return a const iterator to the end of the field sequence.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.equal_range [*equal_range]]]    [      Returns a range of iterators to the fields with the specified name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.erase [*erase]]]    [      Remove a field.       Remove all fields with the specified name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.find [*find]]]    [      Returns an iterator to the case-insensitive matching field.       Returns an iterator to the case-insensitive matching field name.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_allocator [*get_allocator]]]    [      Return a copy of the allocator associated with the container.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.insert [*insert]]]    [      Insert a field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.key_comp [*key_comp]]]    [      Returns a copy of the key comparison function.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.operator_eq_ [*operator=]]]    [      Move assignment.       Copy assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.operator_lb__rb_ [*operator\[\]]]]    [      Returns the value for a field, or "" if it does not exist.       Returns the value for a case-insensitive matching header, or "" if it does not exist.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set [*set]]]    [      Set a field value, removing any other instances of that field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.swap [*swap]]]    [      Return a buffer sequence representing the trailers.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.basic_fields_dtor_ [*~basic_fields]]]    [      Destructor.     ]  ]][heading Protected Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.get_chunked_impl [*get_chunked_impl]]]    [      Returns the chunked Transfer-Encoding setting.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_keep_alive_impl [*get_keep_alive_impl]]]    [      Returns the keep-alive setting.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_method_impl [*get_method_impl]]]    [      Returns the request-method string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_reason_impl [*get_reason_impl]]]    [      Returns the response reason-phrase string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.get_target_impl [*get_target_impl]]]    [      Returns the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.has_content_length_impl [*has_content_length_impl]]]    [      Returns true if the Content-Length field is present.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_chunked_impl [*set_chunked_impl]]]    [      Adjusts the chunked Transfer-Encoding value.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_content_length_impl [*set_content_length_impl]]]    [      Sets or clears the Content-Length field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_keep_alive_impl [*set_keep_alive_impl]]]    [      Adjusts the Connection field.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_method_impl [*set_method_impl]]]    [      Set or clear the method string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_reason_impl [*set_reason_impl]]]    [      Set or clear the reason string.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_fields.set_target_impl [*set_target_impl]]]    [      Set or clear the target string.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_fields.swap [*swap]]]    [      Swap two field containers.     ]  ]]
This container is designed to store the field value pairs that make up the fields and trailers in an HTTP message. Objects of this type are iterable, with each element holding the field name and field value.

Field names are stored as-is, but comparisons are case-insensitive. The container behaves as a `std::multiset`; there will be a separate value for each occurrence of the same field name. When the container is iterated the fields are presented in the order of insertion, with fields having the same name following each other consecutively.

Meets the requirements of [*Fields] 

[heading Template Parameters][table [[Type][Description]]  [[`Allocator`][    The allocator to use. This must meet the requirements of Allocator.   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__file_body http::file_body][indexterm1 http::file_body]
A message body represented by a file on the filesystem. 
[heading Synopsis]Defined in header [include_file boost/beast/http/file_body.hpp]```using file_body = basic_file_body< file >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body__reader [*reader]]]    [      Algorithm for storing buffers when parsing.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__value_type [*value_type]]]    [      The type of the message::body member.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body__writer [*writer]]]    [      Algorithm for retrieving buffers when serializing.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_file_body.file_type [*file_type]]]    [      The type of File this body uses.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_file_body.size [*size]]]    [      Returns the size of the body.     ]  ]]
Messages with this type have bodies represented by a file on the file system. When parsing a message using this body type, the data is stored in the file pointed to by the path, which must be writable. When serializing, the implementation will read the file and present those octets as the body content. This may be used to serve content from a directory as part of a web service.

[heading Template Parameters][table [[Type][Description]]  [[`File`][    The implementation to use for accessing files. This type must meet the requirements of File.   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__header http::header]
A container for an HTTP request or response header. 
[heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```template<    bool isRequest,    class Fields = fields>struct header :    public Fields```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__header.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.header [*header]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__header.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__header.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]][heading Description]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].

Newly constructed header objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].

A `header` includes the start-line and header-fields. 
[section:fields_type http::header::fields_type][indexterm2 fields_type..http::header]
The type representing the fields. 
[heading Synopsis]```using fields_type = Fields;```[heading Description][endsect][section:header http::header::header][indexterm2 header..http::header]
Constructor. 
`````[link beast.ref.boost__beast__http__header.header.overload1 header]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.header.overload1 more...]]````[link beast.ref.boost__beast__http__header.header.overload2 header]``(    header&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.header.overload2 more...]]````[link beast.ref.boost__beast__http__header.header.overload3 header]``(    header const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.header.overload3 more...]]``template<    class... Args>explicit``[link beast.ref.boost__beast__http__header.header.overload4 header]``(    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.header.overload4 more...]]`````[section:overload1 http::header::header (1 of 4 overloads)]
Constructor. 
[heading Synopsis]```header();```[heading Description][endsect][section:overload2 http::header::header (2 of 4 overloads)]
Constructor. 
[heading Synopsis]```header(    header&&);```[heading Description][endsect][section:overload3 http::header::header (3 of 4 overloads)]
Constructor. 
[heading Synopsis]```header(    header const&);```[heading Description][endsect][section:overload4 http::header::header (4 of 4 overloads)]
Constructor. 
[heading Synopsis]```template<    class... Args>header(    Args&&... args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`args`][    Arguments forwarded to the `Fields` base class constructor.  ]]]
[heading Remarks]
This constructor participates in overload resolution if and only if the first parameter is not convertible to [link beast.ref.boost__beast__http__header `http::header`], [link beast.ref.boost__beast__http__verb `http::verb`], or [link beast.ref.boost__beast__http__status `http::status`]. 


[endsect][endsect][section:is_request http::header::is_request][indexterm2 is_request..http::header]
Indicates if the header is a request or response. 
[heading Synopsis]```using is_request = std::integral_constant< bool, isRequest >;```[heading Description][endsect][section:method http::header::method][indexterm2 method..http::header]
Return the request-method verb. 
```verb``[link beast.ref.boost__beast__http__header.method.overload1 method]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.method.overload1 more...]]`````
Set the request-method. 
```void``[link beast.ref.boost__beast__http__header.method.overload2 method]``(    verb v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.method.overload2 more...]]`````[section:overload1 http::header::method (1 of 2 overloads)]
Return the request-method verb. 
[heading Synopsis]```verbmethod() const;```[heading Description]
If the request-method is not one of the recognized verbs, [link beast.ref.boost__beast__http__field `http::unknown`] is returned. Callers may use [link beast.ref.boost__beast__http__header.method_string `http::header::method_string`] to retrieve the exact text.

[heading Remarks]
This function is only available when `isRequest == true`.

[heading See Also]
[link beast.ref.boost__beast__http__header.method_string `http::header::method_string`] 


[endsect][section:overload2 http::header::method (2 of 2 overloads)]
Set the request-method. 
[heading Synopsis]```voidmethod(    verb v);```[heading Description]
This function will set the method for requests to a known verb.

[heading Parameters][table [[Name][Description]]  [[`v`][    The request method verb to set. This may not be [role red verb::unknown].  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::invalid_argument`][    when `v == verb::unknown`.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 


[endsect][endsect][section:method_string http::header::method_string][indexterm2 method_string..http::header]
Return the request-method as a string. 
```string_view``[link beast.ref.boost__beast__http__header.method_string.overload1 method_string]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.method_string.overload1 more...]]``void``[link beast.ref.boost__beast__http__header.method_string.overload2 method_string]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.method_string.overload2 more...]]`````[section:overload1 http::header::method_string (1 of 2 overloads)]
Return the request-method as a string. 
[heading Synopsis]```string_viewmethod_string() const;```[heading Description]
[heading Remarks]
This function is only available when `isRequest == true`.

[heading See Also]
[link beast.ref.boost__beast__http__header.method `http::header::method`] 


[endsect][section:overload2 http::header::method_string (2 of 2 overloads)]
Set the request-method. 
[heading Synopsis]```voidmethod_string(    string_view s);```[heading Description]
This function will set the request-method a known verb if the string matches, otherwise it will store a copy of the passed string.

[heading Parameters][table [[Name][Description]]  [[`s`][    A string representing the request-method.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 


[endsect][endsect][section:operator_eq_ http::header::operator=][indexterm2 operator=..http::header]
Assignment. 
```header&``[link beast.ref.boost__beast__http__header.operator_eq_.overload1 operator=]``(    header&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.operator_eq_.overload1 more...]]``header&``[link beast.ref.boost__beast__http__header.operator_eq_.overload2 operator=]``(    header const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.operator_eq_.overload2 more...]]`````[section:overload1 http::header::operator= (1 of 2 overloads)]
Assignment. 
[heading Synopsis]```header&operator=(    header&&);```[heading Description][endsect][section:overload2 http::header::operator= (2 of 2 overloads)]
Assignment. 
[heading Synopsis]```header&operator=(    header const&);```[heading Description][endsect][endsect][section:reason http::header::reason][indexterm2 reason..http::header]
Return the response reason-phrase. 
```string_view``[link beast.ref.boost__beast__http__header.reason.overload1 reason]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.reason.overload1 more...]]`````
Set the response reason-phrase (deprecated) 
```void``[link beast.ref.boost__beast__http__header.reason.overload2 reason]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.reason.overload2 more...]]`````[section:overload1 http::header::reason (1 of 2 overloads)]
Return the response reason-phrase. 
[heading Synopsis]```string_viewreason() const;```[heading Description]
The reason-phrase is obsolete as of rfc7230.

[heading Remarks]
This function is only available when `isRequest == false`. 


[endsect][section:overload2 http::header::reason (2 of 2 overloads)]
Set the response reason-phrase (deprecated) 
[heading Synopsis]```voidreason(    string_view s);```[heading Description]
This function sets a custom reason-phrase to a copy of the string passed in. Normally it is not necessary to set the reason phrase on an outgoing response object; the implementation will automatically use the standard reason text for the corresponding status code.

To clear a previously set custom phrase, pass an empty string. This will restore the default standard reason text based on the status code used when serializing.

The reason-phrase is obsolete as of rfc7230.

[heading Parameters][table [[Name][Description]]  [[`s`][    The string to use for the reason-phrase.  ]]]
[heading Remarks]
This function is only available when `isRequest == false`. 


[endsect][endsect][section:result http::header::result][indexterm2 result..http::header]
The response status-code result. 
```status``[link beast.ref.boost__beast__http__header.result.overload1 result]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.result.overload1 more...]]`````
Set the response status-code. 
```void``[link beast.ref.boost__beast__http__header.result.overload2 result]``(    status v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.result.overload2 more...]]`````
Set the response status-code as an integer. 
```void``[link beast.ref.boost__beast__http__header.result.overload3 result]``(    unsigned v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.result.overload3 more...]]`````[section:overload1 http::header::result (1 of 3 overloads)]
The response status-code result. 
[heading Synopsis]```statusresult() const;```[heading Description]
If the actual status code is not a known code, this function returns [link beast.ref.boost__beast__http__field `http::unknown`]. Use [link beast.ref.boost__beast__http__header.result_int `http::header::result_int`] to return the raw status code as a number.

[heading Remarks]
This member is only available when `isRequest == false`. 


[endsect][section:overload2 http::header::result (2 of 3 overloads)]
Set the response status-code. 
[heading Synopsis]```voidresult(    status v);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`v`][    The code to set.  ]]]
[heading Remarks]
This member is only available when `isRequest == false`. 


[endsect][section:overload3 http::header::result (3 of 3 overloads)]
Set the response status-code as an integer. 
[heading Synopsis]```voidresult(    unsigned v);```[heading Description]
This sets the status code to the exact number passed in. If the number does not correspond to one of the known status codes, the function [link beast.ref.boost__beast__http__header.result `http::header::result`] will return [link beast.ref.boost__beast__http__field `http::unknown`]. Use [link beast.ref.boost__beast__http__header.result_int `http::header::result_int`] to obtain the original raw status-code.

[heading Parameters][table [[Name][Description]]  [[`v`][    The status-code integer to set.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::invalid_argument`][    if `v > 999`.   ]]]

[endsect][endsect][section:result_int http::header::result_int][indexterm2 result_int..http::header]
The response status-code expressed as an integer. 
[heading Synopsis]```unsignedresult_int() const;```[heading Description]
This returns the raw status code as an integer, even when that code is not in the list of known status codes.

[heading Remarks]
This member is only available when `isRequest == false`. 


[endsect][section:target http::header::target][indexterm2 target..http::header]
Returns the request-target string. 
```string_view``[link beast.ref.boost__beast__http__header.target.overload1 target]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.target.overload1 more...]]`````
Set the request-target string. 
```void``[link beast.ref.boost__beast__http__header.target.overload2 target]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.target.overload2 more...]]`````[section:overload1 http::header::target (1 of 2 overloads)]
Returns the request-target string. 
[heading Synopsis]```string_viewtarget() const;```[heading Description]
The request target string returned is the same string which was received from the network or stored. In particular, it will contain url-encoded characters and should follow the syntax rules for URIs used with HTTP.

[heading Remarks]
This function is only available when `isRequest == true`. 


[endsect][section:overload2 http::header::target (2 of 2 overloads)]
Set the request-target string. 
[heading Synopsis]```voidtarget(    string_view s);```[heading Description]
It is the caller's responsibility to ensure that the request target string follows the syntax rules for URIs used with HTTP. In particular, reserved or special characters must be url-encoded. The implementation does not perform syntax checking on the passed string.

[heading Parameters][table [[Name][Description]]  [[`s`][    A string representing the request-target.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 


[endsect][endsect][section:version http::header::version][indexterm2 version..http::header]
Return the HTTP-version. 
```unsigned``[link beast.ref.boost__beast__http__header.version.overload1 version]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.version.overload1 more...]]`````
Set the HTTP-version. 
```void``[link beast.ref.boost__beast__http__header.version.overload2 version]``(    unsigned value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__header.version.overload2 more...]]`````[section:overload1 http::header::version (1 of 2 overloads)]
Return the HTTP-version. 
[heading Synopsis]```unsignedversion() const;```[heading Description]
This holds both the major and minor version numbers, using these formulas: 

  unsigned major = version / 10;
  unsigned minor = version % 10;




Newly constructed headers will use HTTP/1.1 by default. 
[endsect][section:overload2 http::header::version (2 of 2 overloads)]
Set the HTTP-version. 
[heading Synopsis]```voidversion(    unsigned value);```[heading Description]
This holds both the major and minor version numbers, using these formulas: 

  unsigned major = version / 10;
  unsigned minor = version % 10;




Newly constructed headers will use HTTP/1.1 by default.

[heading Parameters][table [[Name][Description]]  [[`value`][    The version number to use   ]]]

[endsect][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__int_to_status http::int_to_status][indexterm1 http::int_to_status]
Converts the integer to a known status-code. 
[heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```statusint_to_status(    unsigned v);```[heading Description]
If the integer does not match a known status code, [link beast.ref.boost__beast__http__field `http::unknown`] is returned. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__is_body http::is_body]
Determine if `T` meets the requirements of [*Body]. 
[heading Synopsis]Defined in header [include_file boost/beast/http/type_traits.hpp]```template<    class T>struct is_body :    public std::integral_constant< bool,...>```[heading Description]
This metafunction is equivalent to `std::true_type` if `T` has a nested type named `value_type`.

[heading Template Parameters][table [[Type][Description]]  [[`T`][    The body type to test.  ]]]
[heading Example]


  template<bool isRequest, class Body, class Fields>
  void check_body(message<isRequest, Body, Fields> const&)
  {
      static_assert(is_body<Body>::value,
          "Body requirements not met");
  }





Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__is_body_reader http::is_body_reader]
Determine if a [*Body] type has a reader. 
[heading Synopsis]Defined in header [include_file boost/beast/http/type_traits.hpp]```template<    class T>struct is_body_reader :    public std::integral_constant< bool,...>```[heading Description]
This metafunction is equivalent to `std::true_type` if:


* `T` has a nested type named `reader`


* The nested type meets the requirements of [*BodyReader].

[heading Template Parameters][table [[Type][Description]]  [[`T`][    The body type to test.  ]]]
[heading Example]


  template<bool isRequest, class Body, class Fields>
  void check_can_parse(message<isRequest, Body, Fields>&)
  {
      static_assert(is_body_reader<Body>::value,
          "Cannot parse Body, no reader");
  }





Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__is_body_writer http::is_body_writer]
Determine if a [*Body] type has a reader. 
[heading Synopsis]Defined in header [include_file boost/beast/http/type_traits.hpp]```template<    class T>struct is_body_writer :    public std::integral_constant< bool,...>```[heading Description]
This metafunction is equivalent to `std::true_type` if:


* `T` has a nested type named `reader`


* The nested type meets the requirements of [*BodyWriter].

[heading Template Parameters][table [[Type][Description]]  [[`T`][    The body type to test.  ]]]
[heading Example]


  template<bool isRequest, class Body, class Fields>
  void check_can_serialize(message<isRequest, Body, Fields> const&)
  {
      static_assert(is_body_writer<Body>::value,
          "Cannot serialize Body, no reader");
  }





Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__is_fields http::is_fields]
Determine if `T` meets the requirements of [*Fields]. 
[heading Synopsis]Defined in header [include_file boost/beast/http/type_traits.hpp]```template<    class T>struct is_fields :    public std::integral_constant< bool,...>```[heading Description]
[heading Template Parameters][table [[Type][Description]]  [[`T`][    The body type to test.  ]]]
[heading Example]


Use with `static_assert`:



  template<bool isRequest, class Body, class Fields>
  void f(message<isRequest, Body, Fields> const&)
  {
      static_assert(is_fields<Fields>::value,
          "Fields requirements not met");
  ...




Use with `std::enable_if` (SFINAE):



  template<bool isRequest, class Body, class Fields>
  typename std::enable_if<is_fields<Fields>::value>::type
  f(message<isRequest, Body, Fields> const&);



Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__make_chunk http::make_chunk][indexterm1 http::make_chunk]
Returns a [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`]. 
[heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```template<    class __ConstBufferSequence__,    class... Args>automake_chunk(    ConstBufferSequence const& buffers,    Args&&... args);```[heading Description]
This functions constructs and returns a complete [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`] for a chunk body represented by the specified buffer sequence.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    The buffers representing the chunk body.  ]]  [[`args`][    Optional arguments passed to the [role red chunk_body] constructor.  ]]]
[heading Remarks]
This function is provided as a notational convenience to omit specification of the class template arguments. 


Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__make_chunk_last http::make_chunk_last][indexterm1 http::make_chunk_last]
Returns a [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`]. 
```chunk_last< chunk_crlf >``[link beast.ref.boost__beast__http__make_chunk_last.overload1 make_chunk_last]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__make_chunk_last.overload1 more...]]``template<    class Trailer,    class... Args>chunk_last< Trailer >``[link beast.ref.boost__beast__http__make_chunk_last.overload2 make_chunk_last]``(    Trailer const& trailer,    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__make_chunk_last.overload2 more...]]`````[section:overload1 http::make_chunk_last (1 of 2 overloads)]
Returns a [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`]. 
[heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```chunk_last< chunk_crlf >make_chunk_last();```[heading Description]
[heading Remarks]
This function is provided as a notational convenience to omit specification of the class template arguments. 


Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::make_chunk_last (2 of 2 overloads)]
Returns a [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`]. 
[heading Synopsis]Defined in header [include_file boost/beast/http/chunk_encode.hpp]```template<    class Trailer,    class... Args>chunk_last< Trailer >make_chunk_last(    Trailer const& trailer,    Args&&... args);```[heading Description]
This function construct and returns a complete [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`] for a last chunk containing the specified trailers.

[heading Parameters][table [[Name][Description]]  [[`trailer`][    A ConstBufferSequence or   ]]]
[heading Remarks]
This function is provided as a notational convenience to omit specification of the class template arguments.

[heading Parameters][table [[Name][Description]]  [[`args`][    Optional arguments passed to the [role red chunk_last] constructor.   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__message http::message]
A container for a complete HTTP message. 
[heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```template<    bool isRequest,    class Body,    class Fields = fields>struct message :    public http::header< isRequest, Fields >```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.body_type [*body_type]]]    [      The type providing the body traits.     ]  ]  [    [[link beast.ref.boost__beast__http__message.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__message.header_type [*header_type]]]    [      The base class used to hold the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.base [*base]]]    [      Returns the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.body [*body]]]    [      Returns the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.chunked [*chunked]]]    [      Returns true if the chunked Transfer-Encoding is specified.       Set or clear the chunked Transfer-Encoding.     ]  ]  [    [[link beast.ref.boost__beast__http__message.content_length [*content_length]]]    [      Set or clear the Content-Length field.     ]  ]  [    [[link beast.ref.boost__beast__http__message.has_content_length [*has_content_length]]]    [      Returns true if the Content-Length field is present.     ]  ]  [    [[link beast.ref.boost__beast__http__message.keep_alive [*keep_alive]]]    [      Returns true if the message semantics indicate keep-alive.       Set the keep-alive message semantic option.     ]  ]  [    [[link beast.ref.boost__beast__http__message.message [*message]]]    [      Constructor.       Construct a message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__message.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__message.payload_size [*payload_size]]]    [      Returns the payload size of the body in octets if possible.     ]  ]  [    [[link beast.ref.boost__beast__http__message.prepare_payload [*prepare_payload]]]    [      Prepare the message payload fields for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__message.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]][heading Description]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].

A message can be a request or response, depending on the `isRequest` template argument value. Requests and responses have different types; functions may be overloaded based on the type if desired.

The `Body` template argument type determines the model used to read or write the content body of the message.

Newly constructed messages objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].

[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    `true` if this represents a request, or `false` if this represents a response. Some class data members are conditionally present depending on this value.  ]]  [[`Body`][    A type meeting the requirements of Body.  ]]  [[`Fields`][    The type of container used to hold the field value pairs.   ]]]

[section:base http::message::base][indexterm2 base..http::message]
Returns the header portion of the message. 
```header_type const&``[link beast.ref.boost__beast__http__message.base.overload1 base]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.base.overload1 more...]]``header_type&``[link beast.ref.boost__beast__http__message.base.overload2 base]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.base.overload2 more...]]`````[section:overload1 http::message::base (1 of 2 overloads)]
Returns the header portion of the message. 
[heading Synopsis]```header_type const&base() const;```[heading Description][endsect][section:overload2 http::message::base (2 of 2 overloads)]
Returns the header portion of the message. 
[heading Synopsis]```header_type&base();```[heading Description][endsect][endsect][section:body http::message::body][indexterm2 body..http::message]
Returns the body. 
```body_type::value_type&``[link beast.ref.boost__beast__http__message.body.overload1 body]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.body.overload1 more...]]``body_type::value_type&&``[link beast.ref.boost__beast__http__message.body.overload2 body]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.body.overload2 more...]]``body_type::value_type const&``[link beast.ref.boost__beast__http__message.body.overload3 body]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.body.overload3 more...]]`````[section:overload1 http::message::body (1 of 3 overloads)]
Returns the body. 
[heading Synopsis]```body_type::value_type&body();```[heading Description][endsect][section:overload2 http::message::body (2 of 3 overloads)]
Returns the body. 
[heading Synopsis]```body_type::value_type&&body();```[heading Description][endsect][section:overload3 http::message::body (3 of 3 overloads)]
Returns the body. 
[heading Synopsis]```body_type::value_type const&body() const;```[heading Description][endsect][endsect][section:body_type http::message::body_type][indexterm2 body_type..http::message]
The type providing the body traits. 
[heading Synopsis]```using body_type = Body;```[heading Description]
The [link beast.ref.boost__beast__http__message.body `http::message::body`] member will be of type `body_type::value_type`. 
[endsect][section:chunked http::message::chunked][indexterm2 chunked..http::message]
Returns `true` if the chunked Transfer-Encoding is specified. 
```bool``[link beast.ref.boost__beast__http__message.chunked.overload1 chunked]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.chunked.overload1 more...]]`````
Set or clear the chunked Transfer-Encoding. 
```void``[link beast.ref.boost__beast__http__message.chunked.overload2 chunked]``(    bool value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.chunked.overload2 more...]]`````[section:overload1 http::message::chunked (1 of 2 overloads)]
Returns `true` if the chunked Transfer-Encoding is specified. 
[heading Synopsis]```boolchunked() const;```[heading Description][endsect][section:overload2 http::message::chunked (2 of 2 overloads)]
Set or clear the chunked Transfer-Encoding. 
[heading Synopsis]```voidchunked(    bool value);```[heading Description]
This function will set or removed the "chunked" transfer encoding as the last item in the list of encodings in the field.

If the result of removing the chunked token results in an empty string, the field is erased.

The Content-Length field is erased unconditionally. 
[endsect][endsect][section:content_length http::message::content_length][indexterm2 content_length..http::message]
Set or clear the Content-Length field. 
[heading Synopsis]```voidcontent_length(    boost::optional< std::uint64_t > const& value);```[heading Description]
This function adjusts the Content-Length field as follows:


* If `value` specifies a value, the Content-Length field is set to the value. Otherwise


* The Content-Length field is erased.

If "chunked" token appears as the last item in the Transfer-Encoding field it is unconditionally removed.

[heading Parameters][table [[Name][Description]]  [[`value`][    The value to set for Content-Length.   ]]]

[endsect][section:fields_type http::message::fields_type](Inherited from `http::header`)[indexterm2 fields_type..http::message]
The type representing the fields. 
[heading Synopsis]```using fields_type = Fields;```[heading Description][endsect][section:has_content_length http::message::has_content_length][indexterm2 has_content_length..http::message]
Returns `true` if the Content-Length field is present. 
[heading Synopsis]```boolhas_content_length() const;```[heading Description]
This function inspects the fields and returns `true` if the Content-Length field is present. The properties of the body are not checked, this only looks for the field. 
[endsect][section:header_type http::message::header_type][indexterm2 header_type..http::message]
The base class used to hold the header portion of the message. 
[heading Synopsis]```using header_type = header< isRequest, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__header.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.header [*header]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__header.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__header.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].

Newly constructed header objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].

A `header` includes the start-line and header-fields. 
[heading Description][endsect][section:is_request http::message::is_request](Inherited from `http::header`)[indexterm2 is_request..http::message]
Indicates if the header is a request or response. 
[heading Synopsis]```using is_request = std::integral_constant< bool, isRequest >;```[heading Description][endsect][section:keep_alive http::message::keep_alive][indexterm2 keep_alive..http::message]
Returns `true` if the message semantics indicate keep-alive. 
```bool``[link beast.ref.boost__beast__http__message.keep_alive.overload1 keep_alive]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.keep_alive.overload1 more...]]`````
Set the keep-alive message semantic option. 
```void``[link beast.ref.boost__beast__http__message.keep_alive.overload2 keep_alive]``(    bool value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.keep_alive.overload2 more...]]`````[section:overload1 http::message::keep_alive (1 of 2 overloads)]
Returns `true` if the message semantics indicate keep-alive. 
[heading Synopsis]```boolkeep_alive() const;```[heading Description]
The value depends on the version in the message, which must be set to the final value before this function is called or else the return value is unreliable. 
[endsect][section:overload2 http::message::keep_alive (2 of 2 overloads)]
Set the keep-alive message semantic option. 
[heading Synopsis]```voidkeep_alive(    bool value);```[heading Description]
This function adjusts the Connection field to indicate whether or not the connection should be kept open after the corresponding response. The result depends on the version set on the message, which must be set to the final value before making this call.

[heading Parameters][table [[Name][Description]]  [[`value`][    `true` if the connection should persist.   ]]]

[endsect][endsect][section:message http::message::message][indexterm2 message..http::message]
Constructor. 
`````[link beast.ref.boost__beast__http__message.message.overload1 message]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload1 more...]]````[link beast.ref.boost__beast__http__message.message.overload2 message]``(    message&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload2 more...]]````[link beast.ref.boost__beast__http__message.message.overload3 message]``(    message const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload3 more...]]``template<    class... BodyArgs>explicit``[link beast.ref.boost__beast__http__message.message.overload4 message]``(    header_type&& h,    BodyArgs&&... body_args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload4 more...]]``template<    class... BodyArgs>explicit``[link beast.ref.boost__beast__http__message.message.overload5 message]``(    header_type const& h,    BodyArgs&&... body_args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload5 more...]]````[link beast.ref.boost__beast__http__message.message.overload6 message]``(    verb method,    string_view target,    unsigned version);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload6 more...]]``template<    class BodyArg>``[link beast.ref.boost__beast__http__message.message.overload7 message]``(    verb method,    string_view target,    unsigned version,    BodyArg&& body_arg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload7 more...]]``template<    class BodyArg,    class FieldsArg>``[link beast.ref.boost__beast__http__message.message.overload8 message]``(    verb method,    string_view target,    unsigned version,    BodyArg&& body_arg,    FieldsArg&& fields_arg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload8 more...]]````[link beast.ref.boost__beast__http__message.message.overload9 message]``(    status result,    unsigned version);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload9 more...]]``template<    class BodyArg>``[link beast.ref.boost__beast__http__message.message.overload10 message]``(    status result,    unsigned version,    BodyArg&& body_arg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload10 more...]]``template<    class BodyArg,    class FieldsArg>``[link beast.ref.boost__beast__http__message.message.overload11 message]``(    status result,    unsigned version,    BodyArg&& body_arg,    FieldsArg&& fields_arg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload11 more...]]``explicit``[link beast.ref.boost__beast__http__message.message.overload12 message]``(    std::piecewise_construct_t);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload12 more...]]`````
Construct a message. 
```template<    class... BodyArgs>``[link beast.ref.boost__beast__http__message.message.overload13 message]``(    std::piecewise_construct_t,    std::tuple< BodyArgs...> body_args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload13 more...]]``template<    class... BodyArgs,    class... FieldsArgs>``[link beast.ref.boost__beast__http__message.message.overload14 message]``(    std::piecewise_construct_t,    std::tuple< BodyArgs...> body_args,    std::tuple< FieldsArgs...> fields_args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.message.overload14 more...]]`````[section:overload1 http::message::message (1 of 14 overloads)]
Constructor. 
[heading Synopsis]```message();```[heading Description][endsect][section:overload2 http::message::message (2 of 14 overloads)]
Constructor. 
[heading Synopsis]```message(    message&&);```[heading Description][endsect][section:overload3 http::message::message (3 of 14 overloads)]
Constructor. 
[heading Synopsis]```message(    message const&);```[heading Description][endsect][section:overload4 http::message::message (4 of 14 overloads)]
Constructor. 
[heading Synopsis]```template<    class... BodyArgs>message(    header_type&& h,    BodyArgs&&... body_args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`h`][    The header to move construct from.  ]]  [[`body_args`][    Optional arguments forwarded to the `body` constructor.   ]]]

[endsect][section:overload5 http::message::message (5 of 14 overloads)]
Constructor. 
[heading Synopsis]```template<    class... BodyArgs>message(    header_type const& h,    BodyArgs&&... body_args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`h`][    The header to copy construct from.  ]]  [[`body_args`][    Optional arguments forwarded to the `body` constructor.   ]]]

[endsect][section:overload6 http::message::message (6 of 14 overloads)]
Constructor. 
[heading Synopsis]```message(    verb method,    string_view target,    unsigned version);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`method`][    The request-method to use  ]]  [[`target`][    The request-target.  ]]  [[`version`][    The HTTP-version  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 


[endsect][section:overload7 http::message::message (7 of 14 overloads)]
Constructor. 
[heading Synopsis]```template<    class BodyArg>message(    verb method,    string_view target,    unsigned version,    BodyArg&& body_arg);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`method`][    The request-method to use  ]]  [[`target`][    The request-target.  ]]  [[`version`][    The HTTP-version  ]]  [[`body_arg`][    An argument forwarded to the `body` constructor.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 


[endsect][section:overload8 http::message::message (8 of 14 overloads)]
Constructor. 
[heading Synopsis]```template<    class BodyArg,    class FieldsArg>message(    verb method,    string_view target,    unsigned version,    BodyArg&& body_arg,    FieldsArg&& fields_arg);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`method`][    The request-method to use  ]]  [[`target`][    The request-target.  ]]  [[`version`][    The HTTP-version  ]]  [[`body_arg`][    An argument forwarded to the `body` constructor.  ]]  [[`fields_arg`][    An argument forwarded to the `Fields` constructor.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 


[endsect][section:overload9 http::message::message (9 of 14 overloads)]
Constructor. 
[heading Synopsis]```message(    status result,    unsigned version);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`result`][    The status-code for the response  ]]  [[`version`][    The HTTP-version  ]]]
[heading Remarks]
This member is only available when `isRequest == false`. 


[endsect][section:overload10 http::message::message (10 of 14 overloads)]
Constructor. 
[heading Synopsis]```template<    class BodyArg>message(    status result,    unsigned version,    BodyArg&& body_arg);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`result`][    The status-code for the response  ]]  [[`version`][    The HTTP-version  ]]  [[`body_arg`][    An argument forwarded to the `body` constructor.  ]]]
[heading Remarks]
This member is only available when `isRequest == false`. 


[endsect][section:overload11 http::message::message (11 of 14 overloads)]
Constructor. 
[heading Synopsis]```template<    class BodyArg,    class FieldsArg>message(    status result,    unsigned version,    BodyArg&& body_arg,    FieldsArg&& fields_arg);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`result`][    The status-code for the response  ]]  [[`version`][    The HTTP-version  ]]  [[`body_arg`][    An argument forwarded to the `body` constructor.  ]]  [[`fields_arg`][    An argument forwarded to the `Fields` base class constructor.  ]]]
[heading Remarks]
This member is only available when `isRequest == false`. 


[endsect][section:overload12 http::message::message (12 of 14 overloads)]
Constructor. 
[heading Synopsis]```message(    std::piecewise_construct_t);```[heading Description]
The header and body are default-constructed. 
[endsect][section:overload13 http::message::message (13 of 14 overloads)]
Construct a message. 
[heading Synopsis]```template<    class... BodyArgs>message(    std::piecewise_construct_t,    std::tuple< BodyArgs...> body_args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`body_args`][    A tuple forwarded as a parameter pack to the body constructor.   ]]]

[endsect][section:overload14 http::message::message (14 of 14 overloads)]
Construct a message. 
[heading Synopsis]```template<    class... BodyArgs,    class... FieldsArgs>message(    std::piecewise_construct_t,    std::tuple< BodyArgs...> body_args,    std::tuple< FieldsArgs...> fields_args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`body_args`][    A tuple forwarded as a parameter pack to the body constructor.  ]]  [[`fields_args`][    A tuple forwarded as a parameter pack to the `Fields` constructor.   ]]]

[endsect][endsect][section:method http::message::method][indexterm2 method..http::message]
Return the request-method verb. 
```verb``[link beast.ref.boost__beast__http__message.method.overload1 method]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.method.overload1 more...]]`````
Set the request-method. 
```void``[link beast.ref.boost__beast__http__message.method.overload2 method]``(    verb v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.method.overload2 more...]]`````[section:overload1 http::message::method (1 of 2 overloads)](Inherited from `http::header`)
Return the request-method verb. 
[heading Synopsis]```verbmethod() const;```[heading Description]
If the request-method is not one of the recognized verbs, [link beast.ref.boost__beast__http__field `http::unknown`] is returned. Callers may use [link beast.ref.boost__beast__http__header.method_string `http::header::method_string`] to retrieve the exact text.

[heading Remarks]
This function is only available when `isRequest == true`.

[heading See Also]
[link beast.ref.boost__beast__http__header.method_string `http::header::method_string`] 


[endsect][section:overload2 http::message::method (2 of 2 overloads)](Inherited from `http::header`)
Set the request-method. 
[heading Synopsis]```voidmethod(    verb v);```[heading Description]
This function will set the method for requests to a known verb.

[heading Parameters][table [[Name][Description]]  [[`v`][    The request method verb to set. This may not be [role red verb::unknown].  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::invalid_argument`][    when `v == verb::unknown`.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 


[endsect][endsect][section:method_string http::message::method_string][indexterm2 method_string..http::message]
Return the request-method as a string. 
```string_view``[link beast.ref.boost__beast__http__message.method_string.overload1 method_string]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.method_string.overload1 more...]]``void``[link beast.ref.boost__beast__http__message.method_string.overload2 method_string]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.method_string.overload2 more...]]`````[section:overload1 http::message::method_string (1 of 2 overloads)](Inherited from `http::header`)
Return the request-method as a string. 
[heading Synopsis]```string_viewmethod_string() const;```[heading Description]
[heading Remarks]
This function is only available when `isRequest == true`.

[heading See Also]
[link beast.ref.boost__beast__http__header.method `http::header::method`] 


[endsect][section:overload2 http::message::method_string (2 of 2 overloads)](Inherited from `http::header`)
Set the request-method. 
[heading Synopsis]```voidmethod_string(    string_view s);```[heading Description]
This function will set the request-method a known verb if the string matches, otherwise it will store a copy of the passed string.

[heading Parameters][table [[Name][Description]]  [[`s`][    A string representing the request-method.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 


[endsect][endsect][section:need_eof http::message::need_eof][indexterm2 need_eof..http::message]
Returns `true` if the message semantics require an end of file. 
[heading Synopsis]```boolneed_eof() const;```[heading Description]
For HTTP requests, this function returns the logical NOT of a call to [link beast.ref.boost__beast__http__message.keep_alive `http::message::keep_alive`].

For HTTP responses, this function returns the logical NOT of a call to [link beast.ref.boost__beast__http__message.keep_alive `http::message::keep_alive`] if any of the following are true:


* [link beast.ref.boost__beast__http__message.has_content_length `http::message::has_content_length`] would return `true`


* [link beast.ref.boost__beast__http__message.chunked `http::message::chunked`] would return `true`


* [link beast.ref.boost__beast__http__header.result `http::header::result`] returns [link beast.ref.boost__beast__http__status `http::no_content`]


* [link beast.ref.boost__beast__http__header.result `http::header::result`] returns [link beast.ref.boost__beast__http__status `http::not_modified`]


* [link beast.ref.boost__beast__http__header.result `http::header::result`] returns any informational status class (100 to 199)

Otherwise, the function returns `true`.

[heading See Also]
[@https://tools.ietf.org/html/rfc7230#section-3.3 https://tools.ietf.org/html/rfc7230#section-3.3] 


[endsect][section:operator_eq_ http::message::operator=][indexterm2 operator=..http::message]
Assignment. 
```message&``[link beast.ref.boost__beast__http__message.operator_eq_.overload1 operator=]``(    message&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.operator_eq_.overload1 more...]]``message&``[link beast.ref.boost__beast__http__message.operator_eq_.overload2 operator=]``(    message const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.operator_eq_.overload2 more...]]`````[section:overload1 http::message::operator= (1 of 2 overloads)]
Assignment. 
[heading Synopsis]```message&operator=(    message&&);```[heading Description][endsect][section:overload2 http::message::operator= (2 of 2 overloads)]
Assignment. 
[heading Synopsis]```message&operator=(    message const&);```[heading Description][endsect][endsect][section:payload_size http::message::payload_size][indexterm2 payload_size..http::message]
Returns the payload size of the body in octets if possible. 
[heading Synopsis]```boost::optional< std::uint64_t >payload_size() const;```[heading Description]
This function invokes the [*Body] algorithm to measure the number of octets in the serialized body container. If there is no body, this will return zero. Otherwise, if the body exists but is not known ahead of time, `boost::none` is returned (usually indicating that a chunked Transfer-Encoding will be used).

[heading Remarks]
The value of the Content-Length field in the message is not inspected. 


[endsect][section:prepare_payload http::message::prepare_payload][indexterm2 prepare_payload..http::message]
Prepare the message payload fields for the body. 
[heading Synopsis]```voidprepare_payload();```[heading Description]
This function will adjust the Content-Length and Transfer-Encoding field values based on the properties of the body.

[heading Example]


  request<string_body> req{verb::post, "/"};
  req.set(field::user_agent, "Beast");
  req.body() = "Hello, world!";
  req.prepare_payload();





[endsect][section:reason http::message::reason][indexterm2 reason..http::message]
Return the response reason-phrase. 
```string_view``[link beast.ref.boost__beast__http__message.reason.overload1 reason]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.reason.overload1 more...]]`````
Set the response reason-phrase (deprecated) 
```void``[link beast.ref.boost__beast__http__message.reason.overload2 reason]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.reason.overload2 more...]]`````[section:overload1 http::message::reason (1 of 2 overloads)](Inherited from `http::header`)
Return the response reason-phrase. 
[heading Synopsis]```string_viewreason() const;```[heading Description]
The reason-phrase is obsolete as of rfc7230.

[heading Remarks]
This function is only available when `isRequest == false`. 


[endsect][section:overload2 http::message::reason (2 of 2 overloads)](Inherited from `http::header`)
Set the response reason-phrase (deprecated) 
[heading Synopsis]```voidreason(    string_view s);```[heading Description]
This function sets a custom reason-phrase to a copy of the string passed in. Normally it is not necessary to set the reason phrase on an outgoing response object; the implementation will automatically use the standard reason text for the corresponding status code.

To clear a previously set custom phrase, pass an empty string. This will restore the default standard reason text based on the status code used when serializing.

The reason-phrase is obsolete as of rfc7230.

[heading Parameters][table [[Name][Description]]  [[`s`][    The string to use for the reason-phrase.  ]]]
[heading Remarks]
This function is only available when `isRequest == false`. 


[endsect][endsect][section:result http::message::result][indexterm2 result..http::message]
The response status-code result. 
```status``[link beast.ref.boost__beast__http__message.result.overload1 result]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.result.overload1 more...]]`````
Set the response status-code. 
```void``[link beast.ref.boost__beast__http__message.result.overload2 result]``(    status v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.result.overload2 more...]]`````
Set the response status-code as an integer. 
```void``[link beast.ref.boost__beast__http__message.result.overload3 result]``(    unsigned v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.result.overload3 more...]]`````[section:overload1 http::message::result (1 of 3 overloads)](Inherited from `http::header`)
The response status-code result. 
[heading Synopsis]```statusresult() const;```[heading Description]
If the actual status code is not a known code, this function returns [link beast.ref.boost__beast__http__field `http::unknown`]. Use [link beast.ref.boost__beast__http__header.result_int `http::header::result_int`] to return the raw status code as a number.

[heading Remarks]
This member is only available when `isRequest == false`. 


[endsect][section:overload2 http::message::result (2 of 3 overloads)](Inherited from `http::header`)
Set the response status-code. 
[heading Synopsis]```voidresult(    status v);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`v`][    The code to set.  ]]]
[heading Remarks]
This member is only available when `isRequest == false`. 


[endsect][section:overload3 http::message::result (3 of 3 overloads)](Inherited from `http::header`)
Set the response status-code as an integer. 
[heading Synopsis]```voidresult(    unsigned v);```[heading Description]
This sets the status code to the exact number passed in. If the number does not correspond to one of the known status codes, the function [link beast.ref.boost__beast__http__header.result `http::header::result`] will return [link beast.ref.boost__beast__http__field `http::unknown`]. Use [link beast.ref.boost__beast__http__header.result_int `http::header::result_int`] to obtain the original raw status-code.

[heading Parameters][table [[Name][Description]]  [[`v`][    The status-code integer to set.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::invalid_argument`][    if `v > 999`.   ]]]

[endsect][endsect][section:result_int http::message::result_int](Inherited from `http::header`)[indexterm2 result_int..http::message]
The response status-code expressed as an integer. 
[heading Synopsis]```unsignedresult_int() const;```[heading Description]
This returns the raw status code as an integer, even when that code is not in the list of known status codes.

[heading Remarks]
This member is only available when `isRequest == false`. 


[endsect][section:target http::message::target][indexterm2 target..http::message]
Returns the request-target string. 
```string_view``[link beast.ref.boost__beast__http__message.target.overload1 target]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.target.overload1 more...]]`````
Set the request-target string. 
```void``[link beast.ref.boost__beast__http__message.target.overload2 target]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.target.overload2 more...]]`````[section:overload1 http::message::target (1 of 2 overloads)](Inherited from `http::header`)
Returns the request-target string. 
[heading Synopsis]```string_viewtarget() const;```[heading Description]
The request target string returned is the same string which was received from the network or stored. In particular, it will contain url-encoded characters and should follow the syntax rules for URIs used with HTTP.

[heading Remarks]
This function is only available when `isRequest == true`. 


[endsect][section:overload2 http::message::target (2 of 2 overloads)](Inherited from `http::header`)
Set the request-target string. 
[heading Synopsis]```voidtarget(    string_view s);```[heading Description]
It is the caller's responsibility to ensure that the request target string follows the syntax rules for URIs used with HTTP. In particular, reserved or special characters must be url-encoded. The implementation does not perform syntax checking on the passed string.

[heading Parameters][table [[Name][Description]]  [[`s`][    A string representing the request-target.  ]]]
[heading Remarks]
This function is only available when `isRequest == true`. 


[endsect][endsect][section:version http::message::version][indexterm2 version..http::message]
Return the HTTP-version. 
```unsigned``[link beast.ref.boost__beast__http__message.version.overload1 version]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.version.overload1 more...]]`````
Set the HTTP-version. 
```void``[link beast.ref.boost__beast__http__message.version.overload2 version]``(    unsigned value);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__message.version.overload2 more...]]`````[section:overload1 http::message::version (1 of 2 overloads)](Inherited from `http::header`)
Return the HTTP-version. 
[heading Synopsis]```unsignedversion() const;```[heading Description]
This holds both the major and minor version numbers, using these formulas: 

  unsigned major = version / 10;
  unsigned minor = version % 10;




Newly constructed headers will use HTTP/1.1 by default. 
[endsect][section:overload2 http::message::version (2 of 2 overloads)](Inherited from `http::header`)
Set the HTTP-version. 
[heading Synopsis]```voidversion(    unsigned value);```[heading Description]
This holds both the major and minor version numbers, using these formulas: 

  unsigned major = version / 10;
  unsigned minor = version % 10;




Newly constructed headers will use HTTP/1.1 by default.

[heading Parameters][table [[Name][Description]]  [[`value`][    The version number to use   ]]]

[endsect][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__obsolete_reason http::obsolete_reason][indexterm1 http::obsolete_reason]
Returns the obsolete reason-phrase text for a status code. 
[heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```string_viewobsolete_reason(    status v);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`v`][    The status code to use.   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__operator_lt__lt_ http::operator<<][indexterm1 http::operator<<]
Write the text for a field name to an output stream. 
```std::ostream&``[link beast.ref.boost__beast__http__operator_lt__lt_.overload1 operator<<]``(    std::ostream& os,    field f);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__operator_lt__lt_.overload1 more...]]`````
Outputs the standard reason phrase of a status code to a stream. 
```std::ostream&``[link beast.ref.boost__beast__http__operator_lt__lt_.overload2 operator<<]``(    std::ostream&,    status);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__operator_lt__lt_.overload2 more...]]`````
Write the text for a request method verb to an output stream. 
```std::ostream&``[link beast.ref.boost__beast__http__operator_lt__lt_.overload3 operator<<]``(    std::ostream& os,    verb v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__operator_lt__lt_.overload3 more...]]`````
Serialize an HTTP/1 header to a `std::ostream`. 
```template<    bool isRequest,    class ``[link beast.concepts.Fields [*Fields]]``>std::ostream&``[link beast.ref.boost__beast__http__operator_lt__lt_.overload4 operator<<]``(    std::ostream& os,    header< isRequest, Fields > const& msg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__operator_lt__lt_.overload4 more...]]`````
Serialize an HTTP/1 message to a `std::ostream`. 
```template<    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::ostream&``[link beast.ref.boost__beast__http__operator_lt__lt_.overload5 operator<<]``(    std::ostream& os,    message< isRequest, Body, Fields > const& msg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__operator_lt__lt_.overload5 more...]]`````[section:overload1 http::operator<< (1 of 5 overloads)]
Write the text for a field name to an output stream. 
[heading Synopsis]Defined in header [include_file boost/beast/http/field.hpp]```std::ostream&operator<<(    std::ostream& os,    field f);```[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::operator<< (2 of 5 overloads)]
Outputs the standard reason phrase of a status code to a stream. 
[heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```std::ostream&operator<<(    std::ostream&,    status);```[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:overload3 http::operator<< (3 of 5 overloads)]
Write the text for a request method verb to an output stream. 
[heading Synopsis]Defined in header [include_file boost/beast/http/verb.hpp]```std::ostream&operator<<(    std::ostream& os,    verb v);```[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:overload4 http::operator<< (4 of 5 overloads)]
Serialize an HTTP/1 header to a `std::ostream`. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    bool isRequest,    class ``[link beast.concepts.Fields [*Fields]]``>std::ostream&operator<<(    std::ostream& os,    header< isRequest, Fields > const& msg);```[heading Description]
The function converts the header to its HTTP/1 serialized representation and stores the result in the output stream.

[heading Parameters][table [[Name][Description]]  [[`os`][    The output stream to write to.  ]]  [[`msg`][    The message fields to write.   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][section:overload5 http::operator<< (5 of 5 overloads)]
Serialize an HTTP/1 message to a `std::ostream`. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::ostream&operator<<(    std::ostream& os,    message< isRequest, Body, Fields > const& msg);```[heading Description]
The function converts the message to its HTTP/1 serialized representation and stores the result in the output stream.

The implementation will automatically perform chunk encoding if the contents of the message indicate that chunk encoding is required.

[heading Parameters][table [[Name][Description]]  [[`os`][    The output stream to write to.  ]]  [[`msg`][    The message to write.   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__opt_token_list http::opt_token_list][indexterm1 http::opt_token_list]
A list of tokens in a comma separated HTTP field value. 
[heading Synopsis]Defined in header [include_file boost/beast/http/rfc7230.hpp]```using opt_token_list = detail::basic_parsed_list< detail::opt_token_list_policy >;```Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__param_list http::param_list]
A list of parameters in an HTTP extension field value. 
[heading Synopsis]Defined in header [include_file boost/beast/http/rfc7230.hpp]```class param_list```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__param_list.const_iterator [*const_iterator]]]    [      A constant iterator to the list.     ]  ]  [    [[link beast.ref.boost__beast__http__param_list.value_type [*value_type]]]    [      The type of each element in the list.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__param_list.begin [*begin]]]    [      Return a const iterator to the beginning of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__param_list.cbegin [*cbegin]]]    [      Return a const iterator to the beginning of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__param_list.cend [*cend]]]    [      Return a const iterator to the end of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__param_list.end [*end]]]    [      Return a const iterator to the end of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__param_list.param_list [*param_list]]]    [      Default constructor.       Construct a list.     ]  ]][heading Description]
This container allows iteration of the parameter list in an HTTP extension. The parameter list is a series of name/value pairs with each pair starting with a semicolon. The value is optional.

If a parsing error is encountered while iterating the string, the behavior of the container will be as if a string containing only characters up to but excluding the first invalid character was used to construct the list.

[heading BNF]


  param-list  = *( OWS ";" OWS param )
  param       = token OWS [ "=" OWS ( token / quoted-string ) ]




To use this class, construct with the string to be parsed and then use [link beast.ref.boost__beast__http__param_list.begin `http::param_list::begin`] and [link beast.ref.boost__beast__http__param_list.end `http::param_list::end`], or range-for to iterate each item:

[heading Example]


  for(auto const& param : param_list{";level=9;no_context_takeover;bits=15"})
  {
      std::cout << ";" << param.first;
      if(! param.second.empty())
          std::cout << "=" << param.second;
      std::cout << "\n";
  }





[section:begin http::param_list::begin][indexterm2 begin..http::param_list]
Return a const iterator to the beginning of the list. 
[heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:cbegin http::param_list::cbegin][indexterm2 cbegin..http::param_list]
Return a const iterator to the beginning of the list. 
[heading Synopsis]```const_iteratorcbegin() const;```[heading Description][endsect][section:cend http::param_list::cend][indexterm2 cend..http::param_list]
Return a const iterator to the end of the list. 
[heading Synopsis]```const_iteratorcend() const;```[heading Description][endsect][section:const_iterator http::param_list::const_iterator][indexterm2 const_iterator..http::param_list]
A constant iterator to the list. 
[heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end http::param_list::end][indexterm2 end..http::param_list]
Return a const iterator to the end of the list. 
[heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:param_list http::param_list::param_list][indexterm2 param_list..http::param_list]
Default constructor. 
`````[link beast.ref.boost__beast__http__param_list.param_list.overload1 param_list]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__param_list.param_list.overload1 more...]]`````
Construct a list. 
```explicit``[link beast.ref.boost__beast__http__param_list.param_list.overload2 param_list]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__param_list.param_list.overload2 more...]]`````[section:overload1 http::param_list::param_list (1 of 2 overloads)]
Default constructor. 
[heading Synopsis]```param_list();```[heading Description][endsect][section:overload2 http::param_list::param_list (2 of 2 overloads)]
Construct a list. 
[heading Synopsis]```param_list(    string_view s);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`s`][    A string containing the list contents. The string must remain valid for the lifetime of the container.   ]]]

[endsect][endsect][section:value_type http::param_list::value_type][indexterm2 value_type..http::param_list]
The type of each element in the list. 
[heading Synopsis]```using value_type = std::pair< string_view, string_view >;```[heading Description]
The first string in the pair is the name of the parameter, and the second string in the pair is its value (which may be empty). 
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__parser http::parser]
An HTTP/1 parser for producing a message. 
[heading Synopsis]Defined in header [include_file boost/beast/http/parser.hpp]```template<    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class Allocator = std::allocator<char>>class parser :    public http::basic_parser< isRequest, parser< isRequest, Body, Allocator > >```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__parser.is_request [*is_request]]]    [      true if this parser parses requests, false for responses.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.value_type [*value_type]]]    [      The type of message returned by the parser.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__parser.base [*base]]]    [      Returns a reference to this object as a basic_parser.       Returns a constant reference to this object as a basic_parser.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.body_limit [*body_limit]]]    [      Set the limit on the payload body.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.chunked [*chunked]]]    [      Returns true if the last value for Transfer-Encoding is "chunked".     ]  ]  [    [[link beast.ref.boost__beast__http__parser.content_length [*content_length]]]    [      Returns the optional value of Content-Length if known.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.eager [*eager]]]    [      Returns true if the eager parse option is set.       Set the eager parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.get [*get]]]    [      Returns the parsed message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.got_some [*got_some]]]    [      Returns true if the parser has received at least one byte of input.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.header_limit [*header_limit]]]    [      Set a limit on the total size of the header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.is_done [*is_done]]]    [      Returns true if the message is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.is_header_done [*is_header_done]]]    [      Returns true if a the parser has produced the full header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.keep_alive [*keep_alive]]]    [      Returns true if the message has keep-alive connection semantics.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.on_chunk_body [*on_chunk_body]]]    [      Set a callback to be invoked on chunk body data.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.on_chunk_header [*on_chunk_header]]]    [      Set a callback to be invoked on each chunk header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.parser [*parser]]]    [      Constructor.       Construct a parser from another parser, changing the Body type.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.put [*put]]]    [      Write a buffer sequence to the parser.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.put_eof [*put_eof]]]    [      Inform the parser that the end of stream was reached.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.release [*release]]]    [      Returns ownership of the parsed message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.skip [*skip]]]    [      Returns true if the skip parse option is set.       Set the skip parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.upgrade [*upgrade]]]    [      Returns true if the message is an upgrade message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.parser_dtor_ [*~parser]]]    [      Destructor.     ]  ]][heading Description]
This class uses the basic HTTP/1 wire format parser to convert a series of octets into a [link beast.ref.boost__beast__http__message `http::message`] using the [link beast.ref.boost__beast__http__basic_fields `http::basic_fields`] container to represent the fields.

[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    Indicates whether a request or response will be parsed.  ]]  [[`Body`][    The type used to represent the body. This must meet the requirements of Body.  ]]  [[`Allocator`][    The type of allocator used with the [role red basic_fields] container.  ]]]
[heading Remarks]
A new instance of the parser is required for each message. 


[section:base http::parser::base][indexterm2 base..http::parser]
Returns a reference to this object as a [link beast.ref.boost__beast__http__basic_parser.basic_parser `http::basic_parser::basic_parser`]. 
```basic_parser&``[link beast.ref.boost__beast__http__parser.base.overload1 base]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.base.overload1 more...]]`````
Returns a constant reference to this object as a [link beast.ref.boost__beast__http__basic_parser.basic_parser `http::basic_parser::basic_parser`]. 
```basic_parser const&``[link beast.ref.boost__beast__http__parser.base.overload2 base]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.base.overload2 more...]]`````[section:overload1 http::parser::base (1 of 2 overloads)](Inherited from `http::basic_parser`)
Returns a reference to this object as a [link beast.ref.boost__beast__http__basic_parser.basic_parser `http::basic_parser::basic_parser`]. 
[heading Synopsis]```basic_parser&base();```[heading Description]
This is used to pass a derived class where a base class is expected, to choose a correct function overload when the resolution would be ambiguous. 
[endsect][section:overload2 http::parser::base (2 of 2 overloads)](Inherited from `http::basic_parser`)
Returns a constant reference to this object as a [link beast.ref.boost__beast__http__basic_parser.basic_parser `http::basic_parser::basic_parser`]. 
[heading Synopsis]```basic_parser const&base() const;```[heading Description]
This is used to pass a derived class where a base class is expected, to choose a correct function overload when the resolution would be ambiguous. 
[endsect][endsect][section:body_limit http::parser::body_limit](Inherited from `http::basic_parser`)[indexterm2 body_limit..http::parser]
Set the limit on the payload body. 
[heading Synopsis]```voidbody_limit(    std::uint64_t v);```[heading Description]
This function sets the maximum allowed size of the payload body, before any encodings except chunked have been removed. Depending on the message semantics, one of these cases will apply:


* The Content-Length is specified and exceeds the limit. In this case the result error::body\_limit is returned immediately after the header is parsed.


* The Content-Length is unspecified and the chunked encoding is not specified as the last encoding. In this case the end of message is determined by the end of file indicator on the associated stream or input source. If a sufficient number of body payload octets are presented to the parser to exceed the configured limit, the parse fails with the result error::body\_limit


* The Transfer-Encoding specifies the chunked encoding as the last encoding. In this case, when the number of payload body octets produced by removing the chunked encoding exceeds the configured limit, the parse fails with the result error::body\_limit.

Setting the limit after any body octets have been parsed results in undefined behavior.

The default limit is 1MB for requests and 8MB for responses.

[heading Parameters][table [[Name][Description]]  [[`v`][    The payload body limit to set   ]]]

[endsect][section:chunked http::parser::chunked](Inherited from `http::basic_parser`)[indexterm2 chunked..http::parser]
Returns `true` if the last value for Transfer-Encoding is "chunked". 
[heading Synopsis]```boolchunked() const;```[heading Description]
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 


[endsect][section:content_length http::parser::content_length](Inherited from `http::basic_parser`)[indexterm2 content_length..http::parser]
Returns the optional value of Content-Length if known. 
[heading Synopsis]```boost::optional< std::uint64_t >content_length() const;```[heading Description]
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 


[endsect][section:eager http::parser::eager][indexterm2 eager..http::parser]
Returns `true` if the eager parse option is set. 
```bool``[link beast.ref.boost__beast__http__parser.eager.overload1 eager]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.eager.overload1 more...]]`````
Set the eager parse option. 
```void``[link beast.ref.boost__beast__http__parser.eager.overload2 eager]``(    bool v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.eager.overload2 more...]]`````[section:overload1 http::parser::eager (1 of 2 overloads)](Inherited from `http::basic_parser`)
Returns `true` if the eager parse option is set. 
[heading Synopsis]```booleager() const;```[heading Description][endsect][section:overload2 http::parser::eager (2 of 2 overloads)](Inherited from `http::basic_parser`)
Set the eager parse option. 
[heading Synopsis]```voideager(    bool v);```[heading Description]
Normally the parser returns after successfully parsing a structured element (header, chunk header, or chunk body) even if there are octets remaining in the input. This is necessary when attempting to parse the header first, or when the caller wants to inspect information which may be invalidated by subsequent parsing, such as a chunk extension. The `eager` option controls whether the parser keeps going after parsing structured element if there are octets remaining in the buffer and no error occurs. This option is automatically set or cleared during certain stream operations to improve performance with no change in functionality.

The default setting is `false`.

[heading Parameters][table [[Name][Description]]  [[`v`][    `true` to set the eager parse option or `false` to disable it.   ]]]

[endsect][endsect][section:get http::parser::get][indexterm2 get..http::parser]
Returns the parsed message. 
```value_type const&``[link beast.ref.boost__beast__http__parser.get.overload1 get]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.get.overload1 more...]]``value_type&``[link beast.ref.boost__beast__http__parser.get.overload2 get]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.get.overload2 more...]]`````[section:overload1 http::parser::get (1 of 2 overloads)]
Returns the parsed message. 
[heading Synopsis]```value_type const&get() const;```[heading Description]
Depending on the parser's progress, parts of this object may be incomplete. 
[endsect][section:overload2 http::parser::get (2 of 2 overloads)]
Returns the parsed message. 
[heading Synopsis]```value_type&get();```[heading Description]
Depending on the parser's progress, parts of this object may be incomplete. 
[endsect][endsect][section:got_some http::parser::got_some](Inherited from `http::basic_parser`)[indexterm2 got_some..http::parser]
Returns `true` if the parser has received at least one byte of input. 
[heading Synopsis]```boolgot_some() const;```[heading Description][endsect][section:header_limit http::parser::header_limit](Inherited from `http::basic_parser`)[indexterm2 header_limit..http::parser]
Set a limit on the total size of the header. 
[heading Synopsis]```voidheader_limit(    std::uint32_t v);```[heading Description]
This function sets the maximum allowed size of the header including all field name, value, and delimiter characters and also including the CRLF sequences in the serialized input. If the end of the header is not found within the limit of the header size, the error error::header\_limit is returned by [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`].

Setting the limit after any header octets have been parsed results in undefined behavior. 
[endsect][section:is_done http::parser::is_done](Inherited from `http::basic_parser`)[indexterm2 is_done..http::parser]
Returns `true` if the message is complete. 
[heading Synopsis]```boolis_done() const;```[heading Description]
The message is complete after the full header is prduced and one of the following is true:


* The skip body option was set.


* The semantics of the message indicate there is no body.


* The semantics of the message indicate a body is expected, and the entire body was parsed. 


[endsect][section:is_header_done http::parser::is_header_done](Inherited from `http::basic_parser`)[indexterm2 is_header_done..http::parser]
Returns `true` if a the parser has produced the full header. 
[heading Synopsis]```boolis_header_done() const;```[heading Description][endsect][section:is_request http::parser::is_request](Inherited from `http::basic_parser`)[indexterm2 is_request..http::parser]
`true` if this parser parses requests, `false` for responses. 
[heading Synopsis]```using is_request = std::integral_constant< bool, isRequest >;```[heading Description][endsect][section:keep_alive http::parser::keep_alive](Inherited from `http::basic_parser`)[indexterm2 keep_alive..http::parser]
Returns `true` if the message has keep-alive connection semantics. 
[heading Synopsis]```boolkeep_alive() const;```[heading Description]
This function always returns `false` if [link beast.ref.boost__beast__http__basic_parser.need_eof `http::basic_parser::need_eof`] would return `false`.

[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 


[endsect][section:need_eof http::parser::need_eof](Inherited from `http::basic_parser`)[indexterm2 need_eof..http::parser]
Returns `true` if the message semantics require an end of file. 
[heading Synopsis]```boolneed_eof() const;```[heading Description]
Depending on the contents of the header, the parser may require and end of file notification to know where the end of the body lies. If this function returns `true` it will be necessary to call [link beast.ref.boost__beast__http__basic_parser.put_eof `http::basic_parser::put_eof`] when there will never be additional data from the input. 
[endsect][section:on_chunk_body http::parser::on_chunk_body][indexterm2 on_chunk_body..http::parser]
Set a callback to be invoked on chunk body data. 
[heading Synopsis]```template<    class Callback>voidon_chunk_body(    Callback& cb);```[heading Description]
The provided function object will be invoked one or more times to provide buffers corresponding to the chunk body for the current chunk. The callback receives the number of octets remaining in this chunk body including the octets in the buffer provided.

The callback must return the number of octets actually consumed. Any octets not consumed will be presented again in a subsequent invocation of the callback. The implementation type-erases the callback without requiring a dynamic allocation. For this reason, the callback object is passed by a non-constant reference.

[heading Example]


  auto callback =
      [](std::uint64_t remain, string_view body, error_code& ec)
      {
          //...
      };
  parser.on_chunk_body(callback);




[heading Parameters][table [[Name][Description]]  [[`cb`][    The function to set, which must be invocable with this equivalent signature: 
``
  std::size_t
  on_chunk_header(
      std::uint64_t remain,       // Octets remaining in this chunk, includes `body`
      string_view body,           // A buffer holding some or all of the remainder of the chunk body
      error_code& ec);            // May be set by the callback to indicate an error
``
  ]]]

[endsect][section:on_chunk_header http::parser::on_chunk_header][indexterm2 on_chunk_header..http::parser]
Set a callback to be invoked on each chunk header. 
[heading Synopsis]```template<    class Callback>voidon_chunk_header(    Callback& cb);```[heading Description]
The callback will be invoked once for every chunk in the message payload, as well as once for the last chunk. The invocation happens after the chunk header is available but before any body octets have been parsed.

The extensions are provided in raw, validated form, use [link beast.ref.boost__beast__http__basic_chunk_extensions.parse `http::basic_chunk_extensions::parse`] to parse the extensions into a structured container for easier access. The implementation type-erases the callback without requiring a dynamic allocation. For this reason, the callback object is passed by a non-constant reference.

[heading Example]


  auto callback =
      [](std::uint64_t size, string_view extensions, error_code& ec)
      {
          //...
      };
  parser.on_chunk_header(callback);




[heading Parameters][table [[Name][Description]]  [[`cb`][    The function to set, which must be invocable with this equivalent signature: 
``
  void
  on_chunk_header(
      std::uint64_t size,         // Size of the chunk, zero for the last chunk
      string_view extensions,     // The chunk-extensions in raw form
      error_code& ec);            // May be set by the callback to indicate an error
``
  ]]]

[endsect][section:operator_eq_ http::parser::operator=][indexterm2 operator=..http::parser]
Assignment. 
[heading Synopsis]```parser&operator=(    parser const&);```[heading Description][endsect][section:parser http::parser::parser][indexterm2 parser..http::parser]
Constructor. 
`````[link beast.ref.boost__beast__http__parser.parser.overload1 parser]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.parser.overload1 more...]]````[link beast.ref.boost__beast__http__parser.parser.overload2 parser]``(    parser const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.parser.overload2 more...]]````[link beast.ref.boost__beast__http__parser.parser.overload3 parser]``(    parser&& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.parser.overload3 more...]]``template<    class... Args>explicit``[link beast.ref.boost__beast__http__parser.parser.overload4 parser]``(    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.parser.overload4 more...]]`````
Construct a parser from another parser, changing the Body type. 
```template<    class OtherBody,    class... Args>explicit``[link beast.ref.boost__beast__http__parser.parser.overload5 parser]``(    parser< isRequest, OtherBody, Allocator >&& parser,    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.parser.overload5 more...]]`````[section:overload1 http::parser::parser (1 of 5 overloads)]
Constructor. 
[heading Synopsis]```parser();```[heading Description][endsect][section:overload2 http::parser::parser (2 of 5 overloads)]
Constructor. 
[heading Synopsis]```parser(    parser const&);```[heading Description][endsect][section:overload3 http::parser::parser (3 of 5 overloads)]
Constructor. 
[heading Synopsis]```parser(    parser&& other);```[heading Description]
After the move, the only valid operation on the moved-from object is destruction. 
[endsect][section:overload4 http::parser::parser (4 of 5 overloads)]
Constructor. 
[heading Synopsis]```template<    class... Args>parser(    Args&&... args);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`args`][    Optional arguments forwarded to the [role red http::header] constructor.  ]]]
[heading Remarks]
This function participates in overload resolution only if the first argument is not a [link beast.ref.boost__beast__http__parser `http::parser`]. 


[endsect][section:overload5 http::parser::parser (5 of 5 overloads)]
Construct a parser from another parser, changing the Body type. 
[heading Synopsis]```template<    class OtherBody,    class... Args>parser(    parser< isRequest, OtherBody, Allocator >&& parser,    Args&&... args);```[heading Description]
This constructs a new parser by move constructing the header from another parser with a different body type. The constructed-from parser must not have any parsed body octets or initialized [*BodyReader], otherwise an exception is generated.

[heading Example]


  // Deferred body type commitment
  request_parser<empty_body> req0;
  ...
  request_parser<string_body> req{std::move(req0)};




If an exception is thrown, the state of the constructed-from parser is undefined.

[heading Parameters][table [[Name][Description]]  [[`parser`][    The other parser to construct from. After this call returns, the constructed-from parser may only be destroyed.  ]]  [[`args`][    Optional arguments forwarded to the message constructor.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::invalid_argument`][    Thrown when the constructed-from parser has already initialized a body reader.  ]]]
[heading Remarks]
This function participates in overload resolution only if the other parser uses a different body type. 


[endsect][endsect][section:put http::parser::put](Inherited from `http::basic_parser`)[indexterm2 put..http::parser]
Write a buffer sequence to the parser. 
[heading Synopsis]```template<    class __ConstBufferSequence__>std::size_tput(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function attempts to incrementally parse the HTTP message data stored in the caller provided buffers. Upon success, a positive return value indicates that the parser made forward progress, consuming that number of bytes.

In some cases there may be an insufficient number of octets in the input buffer in order to make forward progress. This is indicated by the code error::need\_more. When this happens, the caller should place additional bytes into the buffer sequence and call [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] again.

The error code error::need\_more is special. When this error is returned, a subsequent call to [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] may succeed if the buffers have been updated. Otherwise, upon error the parser may not be restarted.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    An object meeting the requirements of ConstBufferSequence that represents the next chunk of message data. If the length of this buffer sequence is one, the implementation will not allocate additional memory. The class beast::flat\_buffer is provided as one way to meet this requirement  ]]  [[`ec`][    Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of octets consumed in the buffer sequence. The caller should remove these octets even if the error is set. 


[endsect][section:put_eof http::parser::put_eof](Inherited from `http::basic_parser`)[indexterm2 put_eof..http::parser]
Inform the parser that the end of stream was reached. 
[heading Synopsis]```voidput_eof(    error_code& ec);```[heading Description]
In certain cases, HTTP needs to know where the end of the stream is. For example, sometimes servers send responses without Content-Length and expect the client to consume input (for the body) until EOF. Callbacks and errors will still be processed as usual.

This is typically called when a read from the underlying stream object sets the error code to `boost::asio::error::eof`.

[heading Remarks]
Only valid after parsing a complete header.

[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred.   ]]]

[endsect][section:release http::parser::release][indexterm2 release..http::parser]
Returns ownership of the parsed message. 
[heading Synopsis]```value_typerelease();```[heading Description]
Ownership is transferred to the caller. Depending on the parser's progress, parts of this object may be incomplete.

[heading Requires]


[link beast.ref.boost__beast__http__parser.value_type `http::parser::value_type`] is [*MoveConstructible] 
[endsect][section:skip http::parser::skip][indexterm2 skip..http::parser]
Returns `true` if the skip parse option is set. 
```bool``[link beast.ref.boost__beast__http__parser.skip.overload1 skip]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.skip.overload1 more...]]`````
Set the skip parse option. 
```void``[link beast.ref.boost__beast__http__parser.skip.overload2 skip]``(    bool v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__parser.skip.overload2 more...]]`````[section:overload1 http::parser::skip (1 of 2 overloads)](Inherited from `http::basic_parser`)
Returns `true` if the skip parse option is set. 
[heading Synopsis]```boolskip() const;```[heading Description][endsect][section:overload2 http::parser::skip (2 of 2 overloads)](Inherited from `http::basic_parser`)
Set the skip parse option. 
[heading Synopsis]```voidskip(    bool v);```[heading Description]
This option controls whether or not the parser expects to see an HTTP body, regardless of the presence or absence of certain fields such as Content-Length or a chunked Transfer-Encoding. Depending on the request, some responses do not carry a body. For example, a 200 response to a CONNECT request from a tunneling proxy, or a response to a HEAD request. In these cases, callers may use this function inform the parser that no body is expected. The parser will consider the message complete after the header has been received.

[heading Parameters][table [[Name][Description]]  [[`v`][    `true` to set the skip body option or `false` to disable it.  ]]]
[heading Remarks]
This function must called before any bytes are processed. 


[endsect][endsect][section:upgrade http::parser::upgrade](Inherited from `http::basic_parser`)[indexterm2 upgrade..http::parser]
Returns `true` if the message is an upgrade message. 
[heading Synopsis]```boolupgrade() const;```[heading Description]
[heading Remarks]
The return value is undefined unless [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] would return `true`. 


[endsect][section:value_type http::parser::value_type][indexterm2 value_type..http::parser]
The type of message returned by the parser. 
[heading Synopsis]```using value_type = message< isRequest, Body, basic_fields< Allocator >>;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.body_type [*body_type]]]    [      The type providing the body traits.     ]  ]  [    [[link beast.ref.boost__beast__http__message.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__message.header_type [*header_type]]]    [      The base class used to hold the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.base [*base]]]    [      Returns the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.body [*body]]]    [      Returns the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.chunked [*chunked]]]    [      Returns true if the chunked Transfer-Encoding is specified.       Set or clear the chunked Transfer-Encoding.     ]  ]  [    [[link beast.ref.boost__beast__http__message.content_length [*content_length]]]    [      Set or clear the Content-Length field.     ]  ]  [    [[link beast.ref.boost__beast__http__message.has_content_length [*has_content_length]]]    [      Returns true if the Content-Length field is present.     ]  ]  [    [[link beast.ref.boost__beast__http__message.keep_alive [*keep_alive]]]    [      Returns true if the message semantics indicate keep-alive.       Set the keep-alive message semantic option.     ]  ]  [    [[link beast.ref.boost__beast__http__message.message [*message]]]    [      Constructor.       Construct a message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__message.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__message.payload_size [*payload_size]]]    [      Returns the payload size of the body in octets if possible.     ]  ]  [    [[link beast.ref.boost__beast__http__message.prepare_payload [*prepare_payload]]]    [      Prepare the message payload fields for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__message.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].

A message can be a request or response, depending on the `isRequest` template argument value. Requests and responses have different types; functions may be overloaded based on the type if desired.

The `Body` template argument type determines the model used to read or write the content body of the message.

Newly constructed messages objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].

[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    `true` if this represents a request, or `false` if this represents a response. Some class data members are conditionally present depending on this value.  ]]  [[`Body`][    A type meeting the requirements of Body.  ]]  [[`Fields`][    The type of container used to hold the field value pairs.   ]]]

[heading Description][endsect][section:parser_dtor_ http::parser::~parser][indexterm2 ~parser..http::parser]
Destructor. 
[heading Synopsis]```~parser();```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__read http::read][indexterm1 http::read]
Read a complete message from a stream using a parser. 
```template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived>std::size_t``[link beast.ref.boost__beast__http__read.overload1 read]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read.overload1 more...]]``template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived>std::size_t``[link beast.ref.boost__beast__http__read.overload2 read]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read.overload2 more...]]`````
Read a complete message from a stream. 
```template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class Allocator>std::size_t``[link beast.ref.boost__beast__http__read.overload3 read]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    message< isRequest, Body, basic_fields< Allocator >>& msg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read.overload3 more...]]``template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class Allocator>std::size_t``[link beast.ref.boost__beast__http__read.overload4 read]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    message< isRequest, Body, basic_fields< Allocator >>& msg,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read.overload4 more...]]`````[section:overload1 http::read (1 of 4 overloads)]
Read a complete message from a stream using a parser. 
[heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived>std::size_tread(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser);```[heading Description]
This function is used to read a complete message from a stream into a subclass of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The call will block until one of the following conditions is true:


* [link beast.ref.boost__beast__http__basic_parser.is_done `http::basic_parser::is_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional octets that lie past the end of the message being read. This additional data is stored in the dynamic buffer, which must be retained for subsequent reads.

If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:


* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no octets were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any octets were parsed but the message was incomplete, otherwise:


* A successful result. A subsequent attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream from which the data is to be read. The type must support the SyncReadStream concept.  ]]  [[`buffer`][    A DynamicBuffer holding additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, any data in the dynamic buffer's input sequence will be given to the parser first.  ]]  [[`parser`][    The parser to use.  ]]]
[heading Return Value]
The number of bytes transferred to the parser.

[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.  ]]]
[heading Remarks]
The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `true` on the parser passed in. 


Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::read (2 of 4 overloads)]
Read a complete message from a stream using a parser. 
[heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived>std::size_tread(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser,    error_code& ec);```[heading Description]
This function is used to read a complete message from a stream into a subclass of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The call will block until one of the following conditions is true:


* [link beast.ref.boost__beast__http__basic_parser.is_done `http::basic_parser::is_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional octets that lie past the end of the message being read. This additional data is stored in the dynamic buffer, which must be retained for subsequent reads.

If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:


* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no octets were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any octets were parsed but the message was incomplete, otherwise:


* A successful result. A subsequent attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream from which the data is to be read. The type must support the SyncReadStream concept.  ]]  [[`buffer`][    A DynamicBuffer holding additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, any data in the dynamic buffer's input sequence will be given to the parser first.  ]]  [[`parser`][    The parser to use.  ]]  [[`ec`][    Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes transferred to the parser.

[heading Remarks]
The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `true` on the parser passed in. 


Convenience header [include_file boost/beast/http.hpp][endsect][section:overload3 http::read (3 of 4 overloads)]
Read a complete message from a stream. 
[heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class Allocator>std::size_tread(    SyncReadStream& stream,    DynamicBuffer& buffer,    message< isRequest, Body, basic_fields< Allocator >>& msg);```[heading Description]
This function is used to read a complete message from a stream using HTTP/1. The call will block until one of the following conditions is true:


* The entire message is read.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional octets that lie past the end of the message being read. This additional data is stored in the dynamic buffer, which must be retained for subsequent reads.

If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:


* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no octets were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any octets were parsed but the message was incomplete, otherwise:


* A successful result. A subsequent attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream from which the data is to be read. The type must support the SyncReadStream concept.  ]]  [[`buffer`][    A DynamicBuffer holding additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, any data in the dynamic buffer's input sequence will be given to the parser first.  ]]  [[`msg`][    An object in which to store the message contents. This object should not have previous contents, otherwise the behavior is undefined. The type must be MoveAssignable and MoveConstructible.  ]]]
[heading Return Value]
The number of bytes transferred to the parser.

[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][section:overload4 http::read (4 of 4 overloads)]
Read a complete message from a stream. 
[heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class Allocator>std::size_tread(    SyncReadStream& stream,    DynamicBuffer& buffer,    message< isRequest, Body, basic_fields< Allocator >>& msg,    error_code& ec);```[heading Description]
This function is used to read a complete message from a stream using HTTP/1. The call will block until one of the following conditions is true:


* The entire message is read.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional octets that lie past the end of the message being read. This additional data is stored in the dynamic buffer, which must be retained for subsequent reads.

If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:


* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no octets were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any octets were parsed but the message was incomplete, otherwise:


* A successful result. A subsequent attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream from which the data is to be read. The type must support the SyncReadStream concept.  ]]  [[`buffer`][    A DynamicBuffer holding additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, any data in the dynamic buffer's input sequence will be given to the parser first.  ]]  [[`msg`][    An object in which to store the message contents. This object should not have previous contents, otherwise the behavior is undefined. The type must be MoveAssignable and MoveConstructible.  ]]  [[`ec`][    Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes transferred to the parser. 


Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__read_header http::read_header][indexterm1 http::read_header]
Read a header from a stream using a parser. 
```template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived>std::size_t``[link beast.ref.boost__beast__http__read_header.overload1 read_header]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read_header.overload1 more...]]``template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived>std::size_t``[link beast.ref.boost__beast__http__read_header.overload2 read_header]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read_header.overload2 more...]]`````[section:overload1 http::read_header (1 of 2 overloads)]
Read a header from a stream using a parser. 
[heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived>std::size_tread_header(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser);```[heading Description]
This function is used to read a header from a stream into a subclass of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The call will block until one of the following conditions is true:


* [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional octets that lie past the end of the message being read. This additional data is stored in the dynamic buffer, which must be retained for subsequent reads.

If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:


* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no octets were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any octets were parsed but the message was incomplete, otherwise:


* A successful result. A subsequent attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream from which the data is to be read. The type must support the SyncReadStream concept.  ]]  [[`buffer`][    A DynamicBuffer holding additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, any data in the dynamic buffer's input sequence will be given to the parser first.  ]]  [[`parser`][    The parser to use.  ]]]
[heading Return Value]
The number of bytes transferred to the parser.

[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.  ]]]
[heading Remarks]
The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `false` on the parser passed in. 


Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::read_header (2 of 2 overloads)]
Read a header from a stream using a parser. 
[heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived>std::size_tread_header(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser,    error_code& ec);```[heading Description]
This function is used to read a header from a stream into a subclass of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The call will block until one of the following conditions is true:


* [link beast.ref.boost__beast__http__basic_parser.is_header_done `http::basic_parser::is_header_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional octets that lie past the end of the message being read. This additional data is stored in the dynamic buffer, which must be retained for subsequent reads.

If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:


* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no octets were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any octets were parsed but the message was incomplete, otherwise:


* A successful result. A subsequent attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream from which the data is to be read. The type must support the SyncReadStream concept.  ]]  [[`buffer`][    A DynamicBuffer holding additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, any data in the dynamic buffer's input sequence will be given to the parser first.  ]]  [[`parser`][    The parser to use.  ]]  [[`ec`][    Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes transferred to the parser.

[heading Remarks]
The implementation will call [link beast.ref.boost__beast__http__basic_parser.eager `http::basic_parser::eager`] with the value `false` on the parser passed in. 


Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__read_some http::read_some][indexterm1 http::read_some]
Read part of a message from a stream using a parser. 
```template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived>std::size_t``[link beast.ref.boost__beast__http__read_some.overload1 read_some]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read_some.overload1 more...]]``template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived>std::size_t``[link beast.ref.boost__beast__http__read_some.overload2 read_some]``(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__read_some.overload2 more...]]`````[section:overload1 http::read_some (1 of 2 overloads)]
Read part of a message from a stream using a parser. 
[heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived>std::size_tread_some(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser);```[heading Description]
This function is used to read part of a message from a stream into a subclass of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The call will block until one of the following conditions is true:


* A call to [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] with a non-empty buffer sequence is successful.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional octets that lie past the end of the message being read. This additional data is stored in the dynamic buffer, which must be retained for subsequent reads.

If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:


* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no octets were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any octets were parsed but the message was incomplete, otherwise:


* A successful result. A subsequent attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream from which the data is to be read. The type must support the SyncReadStream concept.  ]]  [[`buffer`][    A DynamicBuffer holding additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, any data in the dynamic buffer's input sequence will be given to the parser first.  ]]  [[`parser`][    The parser to use.  ]]]
[heading Return Value]
The number of bytes transferred to the parser.

[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::read_some (2 of 2 overloads)]
Read part of a message from a stream using a parser. 
[heading Synopsis]Defined in header [include_file boost/beast/http/read.hpp]```template<    class __SyncReadStream__,    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    bool isRequest,    class Derived>std::size_tread_some(    SyncReadStream& stream,    DynamicBuffer& buffer,    basic_parser< isRequest, Derived >& parser,    error_code& ec);```[heading Description]
This function is used to read part of a message from a stream into a subclass of [link beast.ref.boost__beast__http__basic_parser `http::basic_parser`]. The call will block until one of the following conditions is true:


* A call to [link beast.ref.boost__beast__http__basic_parser.put `http::basic_parser::put`] with a non-empty buffer sequence is successful.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `read_some` function. The implementation may read additional octets that lie past the end of the message being read. This additional data is stored in the dynamic buffer, which must be retained for subsequent reads.

If the stream returns the error `boost::asio::error::eof` indicating the end of file during a read, the error returned from this function will be:


* [link beast.ref.boost__beast__http__error `http::end_of_stream`] if no octets were parsed, or


* [link beast.ref.boost__beast__http__error `http::partial_message`] if any octets were parsed but the message was incomplete, otherwise:


* A successful result. A subsequent attempt to read will return [link beast.ref.boost__beast__http__error `http::end_of_stream`]

The function returns the number of bytes processed from the dynamic buffer. The caller should remove these bytes by calling `consume` on the dynamic buffer, regardless of any error.

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream from which the data is to be read. The type must support the SyncReadStream concept.  ]]  [[`buffer`][    A DynamicBuffer holding additional bytes read by the implementation from the stream. This is both an input and an output parameter; on entry, any data in the dynamic buffer's input sequence will be given to the parser first.  ]]  [[`parser`][    The parser to use.  ]]  [[`ec`][    Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes transferred to the parser. 


Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__request http::request][indexterm1 http::request]
A typical HTTP request. 
[heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```using request = message< true, Body, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.body_type [*body_type]]]    [      The type providing the body traits.     ]  ]  [    [[link beast.ref.boost__beast__http__message.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__message.header_type [*header_type]]]    [      The base class used to hold the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.base [*base]]]    [      Returns the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.body [*body]]]    [      Returns the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.chunked [*chunked]]]    [      Returns true if the chunked Transfer-Encoding is specified.       Set or clear the chunked Transfer-Encoding.     ]  ]  [    [[link beast.ref.boost__beast__http__message.content_length [*content_length]]]    [      Set or clear the Content-Length field.     ]  ]  [    [[link beast.ref.boost__beast__http__message.has_content_length [*has_content_length]]]    [      Returns true if the Content-Length field is present.     ]  ]  [    [[link beast.ref.boost__beast__http__message.keep_alive [*keep_alive]]]    [      Returns true if the message semantics indicate keep-alive.       Set the keep-alive message semantic option.     ]  ]  [    [[link beast.ref.boost__beast__http__message.message [*message]]]    [      Constructor.       Construct a message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__message.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__message.payload_size [*payload_size]]]    [      Returns the payload size of the body in octets if possible.     ]  ]  [    [[link beast.ref.boost__beast__http__message.prepare_payload [*prepare_payload]]]    [      Prepare the message payload fields for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__message.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].

A message can be a request or response, depending on the `isRequest` template argument value. Requests and responses have different types; functions may be overloaded based on the type if desired.

The `Body` template argument type determines the model used to read or write the content body of the message.

Newly constructed messages objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].

[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    `true` if this represents a request, or `false` if this represents a response. Some class data members are conditionally present depending on this value.  ]]  [[`Body`][    A type meeting the requirements of Body.  ]]  [[`Fields`][    The type of container used to hold the field value pairs.   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__request_header http::request_header][indexterm1 http::request_header]
A typical HTTP request header. 
[heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```using request_header = header< true, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__header.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.header [*header]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__header.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__header.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].

Newly constructed header objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].

A `header` includes the start-line and header-fields. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__request_parser http::request_parser][indexterm1 http::request_parser]
An HTTP/1 parser for producing a request message. 
[heading Synopsis]Defined in header [include_file boost/beast/http/parser.hpp]```using request_parser = parser< true, Body, Allocator >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__parser.is_request [*is_request]]]    [      true if this parser parses requests, false for responses.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.value_type [*value_type]]]    [      The type of message returned by the parser.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__parser.base [*base]]]    [      Returns a reference to this object as a basic_parser.       Returns a constant reference to this object as a basic_parser.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.body_limit [*body_limit]]]    [      Set the limit on the payload body.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.chunked [*chunked]]]    [      Returns true if the last value for Transfer-Encoding is "chunked".     ]  ]  [    [[link beast.ref.boost__beast__http__parser.content_length [*content_length]]]    [      Returns the optional value of Content-Length if known.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.eager [*eager]]]    [      Returns true if the eager parse option is set.       Set the eager parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.get [*get]]]    [      Returns the parsed message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.got_some [*got_some]]]    [      Returns true if the parser has received at least one byte of input.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.header_limit [*header_limit]]]    [      Set a limit on the total size of the header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.is_done [*is_done]]]    [      Returns true if the message is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.is_header_done [*is_header_done]]]    [      Returns true if a the parser has produced the full header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.keep_alive [*keep_alive]]]    [      Returns true if the message has keep-alive connection semantics.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.on_chunk_body [*on_chunk_body]]]    [      Set a callback to be invoked on chunk body data.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.on_chunk_header [*on_chunk_header]]]    [      Set a callback to be invoked on each chunk header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.parser [*parser]]]    [      Constructor.       Construct a parser from another parser, changing the Body type.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.put [*put]]]    [      Write a buffer sequence to the parser.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.put_eof [*put_eof]]]    [      Inform the parser that the end of stream was reached.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.release [*release]]]    [      Returns ownership of the parsed message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.skip [*skip]]]    [      Returns true if the skip parse option is set.       Set the skip parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.upgrade [*upgrade]]]    [      Returns true if the message is an upgrade message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.parser_dtor_ [*~parser]]]    [      Destructor.     ]  ]]
This class uses the basic HTTP/1 wire format parser to convert a series of octets into a [link beast.ref.boost__beast__http__message `http::message`] using the [link beast.ref.boost__beast__http__basic_fields `http::basic_fields`] container to represent the fields.

[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    Indicates whether a request or response will be parsed.  ]]  [[`Body`][    The type used to represent the body. This must meet the requirements of Body.  ]]  [[`Allocator`][    The type of allocator used with the [role red basic_fields] container.  ]]]
[heading Remarks]
A new instance of the parser is required for each message. 


Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__request_serializer http::request_serializer][indexterm1 http::request_serializer]
A serializer for HTTP/1 requests. 
[heading Synopsis]Defined in header [include_file boost/beast/http/serializer.hpp]```using request_serializer = serializer< true, Body, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__serializer.value_type [*value_type]]]    [      The type of message this serializer uses.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__serializer.consume [*consume]]]    [      Consume buffer octets in the serialization.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.get [*get]]]    [      Returns the message being serialized.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.is_done [*is_done]]]    [      Return true if serialization is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.is_header_done [*is_header_done]]]    [      Return true if serialization of the header is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.limit [*limit]]]    [      Returns the serialized buffer size limit.       Set the serialized buffer size limit.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.next [*next]]]    [      Returns the next set of buffers in the serialization.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.reader_impl [*reader_impl]]]    [      Provides low-level access to the associated BodyWriter.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.serializer [*serializer]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.split [*split]]]    [      Returns true if we will pause after writing the complete header.       Set whether the header and body are written separately.     ]  ]]
An object of this type is used to serialize a complete HTTP message into a sequence of octets. To use this class, construct an instance with the message to be serialized. The implementation will automatically perform chunk encoding if the contents of the message indicate that chunk encoding is required.

Chunked output produced by the serializer never contains chunk extensions or trailers, and the location of chunk boundaries is not specified. If callers require chunk extensions, trailers, or control over the exact contents of each chunk they should use the serializer to write just the message header, and then assume control over serializing the chunked payload by using the chunk buffer sequence types [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`], [link beast.ref.boost__beast__http__chunk_crlf `http::chunk_crlf`], [link beast.ref.boost__beast__http__chunk_header `http::chunk_header`], and [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`].

[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    `true` if the message is a request.  ]]  [[`Body`][    The body type of the message.  ]]  [[`Fields`][    The type of fields in the message.   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__response http::response][indexterm1 http::response]
A typical HTTP response. 
[heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```using response = message< false, Body, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.body_type [*body_type]]]    [      The type providing the body traits.     ]  ]  [    [[link beast.ref.boost__beast__http__message.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__message.header_type [*header_type]]]    [      The base class used to hold the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__message.base [*base]]]    [      Returns the header portion of the message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.body [*body]]]    [      Returns the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.chunked [*chunked]]]    [      Returns true if the chunked Transfer-Encoding is specified.       Set or clear the chunked Transfer-Encoding.     ]  ]  [    [[link beast.ref.boost__beast__http__message.content_length [*content_length]]]    [      Set or clear the Content-Length field.     ]  ]  [    [[link beast.ref.boost__beast__http__message.has_content_length [*has_content_length]]]    [      Returns true if the Content-Length field is present.     ]  ]  [    [[link beast.ref.boost__beast__http__message.keep_alive [*keep_alive]]]    [      Returns true if the message semantics indicate keep-alive.       Set the keep-alive message semantic option.     ]  ]  [    [[link beast.ref.boost__beast__http__message.message [*message]]]    [      Constructor.       Construct a message.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__message.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__message.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__message.payload_size [*payload_size]]]    [      Returns the payload size of the body in octets if possible.     ]  ]  [    [[link beast.ref.boost__beast__http__message.prepare_payload [*prepare_payload]]]    [      Prepare the message payload fields for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__message.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__message.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__message.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__message.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].

A message can be a request or response, depending on the `isRequest` template argument value. Requests and responses have different types; functions may be overloaded based on the type if desired.

The `Body` template argument type determines the model used to read or write the content body of the message.

Newly constructed messages objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].

[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    `true` if this represents a request, or `false` if this represents a response. Some class data members are conditionally present depending on this value.  ]]  [[`Body`][    A type meeting the requirements of Body.  ]]  [[`Fields`][    The type of container used to hold the field value pairs.   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__response_header http::response_header][indexterm1 http::response_header]
A typical HTTP response header. 
[heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```using response_header = header< false, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.fields_type [*fields_type]]]    [      The type representing the fields.     ]  ]  [    [[link beast.ref.boost__beast__http__header.is_request [*is_request]]]    [      Indicates if the header is a request or response.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__header.header [*header]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method [*method]]]    [      Return the request-method verb.       Set the request-method.     ]  ]  [    [[link beast.ref.boost__beast__http__header.method_string [*method_string]]]    [      Return the request-method as a string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__header.reason [*reason]]]    [      Return the response reason-phrase.       Set the response reason-phrase (deprecated)     ]  ]  [    [[link beast.ref.boost__beast__http__header.result [*result]]]    [      The response status-code result.       Set the response status-code.       Set the response status-code as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.result_int [*result_int]]]    [      The response status-code expressed as an integer.     ]  ]  [    [[link beast.ref.boost__beast__http__header.target [*target]]]    [      Returns the request-target string.       Set the request-target string.     ]  ]  [    [[link beast.ref.boost__beast__http__header.version [*version]]]    [      Return the HTTP-version.       Set the HTTP-version.     ]  ]]
This container is derived from the `Fields` template type. To understand all of the members of this class it is necessary to view the declaration for the `Fields` type. When using the default fields container, those declarations are in [link beast.ref.boost__beast__http__fields `http::fields`].

Newly constructed header objects have version set to HTTP/1.1. Newly constructed response objects also have result code set to [link beast.ref.boost__beast__http__status `http::ok`].

A `header` includes the start-line and header-fields. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__response_parser http::response_parser][indexterm1 http::response_parser]
An HTTP/1 parser for producing a response message. 
[heading Synopsis]Defined in header [include_file boost/beast/http/parser.hpp]```using response_parser = parser< false, Body, Allocator >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__parser.is_request [*is_request]]]    [      true if this parser parses requests, false for responses.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.value_type [*value_type]]]    [      The type of message returned by the parser.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__parser.base [*base]]]    [      Returns a reference to this object as a basic_parser.       Returns a constant reference to this object as a basic_parser.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.body_limit [*body_limit]]]    [      Set the limit on the payload body.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.chunked [*chunked]]]    [      Returns true if the last value for Transfer-Encoding is "chunked".     ]  ]  [    [[link beast.ref.boost__beast__http__parser.content_length [*content_length]]]    [      Returns the optional value of Content-Length if known.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.eager [*eager]]]    [      Returns true if the eager parse option is set.       Set the eager parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.get [*get]]]    [      Returns the parsed message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.got_some [*got_some]]]    [      Returns true if the parser has received at least one byte of input.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.header_limit [*header_limit]]]    [      Set a limit on the total size of the header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.is_done [*is_done]]]    [      Returns true if the message is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.is_header_done [*is_header_done]]]    [      Returns true if a the parser has produced the full header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.keep_alive [*keep_alive]]]    [      Returns true if the message has keep-alive connection semantics.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.need_eof [*need_eof]]]    [      Returns true if the message semantics require an end of file.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.on_chunk_body [*on_chunk_body]]]    [      Set a callback to be invoked on chunk body data.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.on_chunk_header [*on_chunk_header]]]    [      Set a callback to be invoked on each chunk header.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.parser [*parser]]]    [      Constructor.       Construct a parser from another parser, changing the Body type.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.put [*put]]]    [      Write a buffer sequence to the parser.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.put_eof [*put_eof]]]    [      Inform the parser that the end of stream was reached.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.release [*release]]]    [      Returns ownership of the parsed message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.skip [*skip]]]    [      Returns true if the skip parse option is set.       Set the skip parse option.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.upgrade [*upgrade]]]    [      Returns true if the message is an upgrade message.     ]  ]  [    [[link beast.ref.boost__beast__http__parser.parser_dtor_ [*~parser]]]    [      Destructor.     ]  ]]
This class uses the basic HTTP/1 wire format parser to convert a series of octets into a [link beast.ref.boost__beast__http__message `http::message`] using the [link beast.ref.boost__beast__http__basic_fields `http::basic_fields`] container to represent the fields.

[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    Indicates whether a request or response will be parsed.  ]]  [[`Body`][    The type used to represent the body. This must meet the requirements of Body.  ]]  [[`Allocator`][    The type of allocator used with the [role red basic_fields] container.  ]]]
[heading Remarks]
A new instance of the parser is required for each message. 


Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__response_serializer http::response_serializer][indexterm1 http::response_serializer]
A serializer for HTTP/1 responses. 
[heading Synopsis]Defined in header [include_file boost/beast/http/serializer.hpp]```using response_serializer = serializer< false, Body, Fields >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__serializer.value_type [*value_type]]]    [      The type of message this serializer uses.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__serializer.consume [*consume]]]    [      Consume buffer octets in the serialization.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.get [*get]]]    [      Returns the message being serialized.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.is_done [*is_done]]]    [      Return true if serialization is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.is_header_done [*is_header_done]]]    [      Return true if serialization of the header is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.limit [*limit]]]    [      Returns the serialized buffer size limit.       Set the serialized buffer size limit.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.next [*next]]]    [      Returns the next set of buffers in the serialization.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.reader_impl [*reader_impl]]]    [      Provides low-level access to the associated BodyWriter.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.serializer [*serializer]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.split [*split]]]    [      Returns true if we will pause after writing the complete header.       Set whether the header and body are written separately.     ]  ]]
An object of this type is used to serialize a complete HTTP message into a sequence of octets. To use this class, construct an instance with the message to be serialized. The implementation will automatically perform chunk encoding if the contents of the message indicate that chunk encoding is required.

Chunked output produced by the serializer never contains chunk extensions or trailers, and the location of chunk boundaries is not specified. If callers require chunk extensions, trailers, or control over the exact contents of each chunk they should use the serializer to write just the message header, and then assume control over serializing the chunked payload by using the chunk buffer sequence types [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`], [link beast.ref.boost__beast__http__chunk_crlf `http::chunk_crlf`], [link beast.ref.boost__beast__http__chunk_header `http::chunk_header`], and [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`].

[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    `true` if the message is a request.  ]]  [[`Body`][    The body type of the message.  ]]  [[`Fields`][    The type of fields in the message.   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__serializer http::serializer]
Provides buffer oriented HTTP message serialization functionality. 
[heading Synopsis]Defined in header [include_file boost/beast/http/serializer.hpp]```template<    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]`` = fields>class serializer```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__serializer.value_type [*value_type]]]    [      The type of message this serializer uses.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__serializer.consume [*consume]]]    [      Consume buffer octets in the serialization.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.get [*get]]]    [      Returns the message being serialized.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.is_done [*is_done]]]    [      Return true if serialization is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.is_header_done [*is_header_done]]]    [      Return true if serialization of the header is complete.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.limit [*limit]]]    [      Returns the serialized buffer size limit.       Set the serialized buffer size limit.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.next [*next]]]    [      Returns the next set of buffers in the serialization.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.reader_impl [*reader_impl]]]    [      Provides low-level access to the associated BodyWriter.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.serializer [*serializer]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__http__serializer.split [*split]]]    [      Returns true if we will pause after writing the complete header.       Set whether the header and body are written separately.     ]  ]][heading Description]
An object of this type is used to serialize a complete HTTP message into a sequence of octets. To use this class, construct an instance with the message to be serialized. The implementation will automatically perform chunk encoding if the contents of the message indicate that chunk encoding is required.

Chunked output produced by the serializer never contains chunk extensions or trailers, and the location of chunk boundaries is not specified. If callers require chunk extensions, trailers, or control over the exact contents of each chunk they should use the serializer to write just the message header, and then assume control over serializing the chunked payload by using the chunk buffer sequence types [link beast.ref.boost__beast__http__chunk_body `http::chunk_body`], [link beast.ref.boost__beast__http__chunk_crlf `http::chunk_crlf`], [link beast.ref.boost__beast__http__chunk_header `http::chunk_header`], and [link beast.ref.boost__beast__http__chunk_last `http::chunk_last`].

[heading Template Parameters][table [[Type][Description]]  [[`isRequest`][    `true` if the message is a request.  ]]  [[`Body`][    The body type of the message.  ]]  [[`Fields`][    The type of fields in the message.   ]]]

[section:consume http::serializer::consume][indexterm2 consume..http::serializer]
Consume buffer octets in the serialization. 
[heading Synopsis]```voidconsume(    std::size_t n);```[heading Description]
This function should be called after one or more octets contained in the buffers provided in the prior call to [link beast.ref.boost__beast__http__serializer.next `http::serializer::next`] have been used.

After a call to [link beast.ref.boost__beast__http__serializer.consume `http::serializer::consume`], callers should check the return value of [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] to determine if the entire message has been serialized.

[heading Parameters][table [[Name][Description]]  [[`n`][    The number of octets to consume. This number must be greater than zero and no greater than the number of octets in the buffers provided in the prior call to [link beast.ref.boost__beast__http__serializer.next `next`].   ]]]

[endsect][section:get http::serializer::get][indexterm2 get..http::serializer]
Returns the message being serialized. 
[heading Synopsis]```value_type&get();```[heading Description][endsect][section:is_done http::serializer::is_done][indexterm2 is_done..http::serializer]
Return `true` if serialization is complete. 
[heading Synopsis]```boolis_done();```[heading Description]
The operation is complete when all octets corresponding to the serialized representation of the message have been successfully retrieved. 
[endsect][section:is_header_done http::serializer::is_header_done][indexterm2 is_header_done..http::serializer]
Return `true` if serialization of the header is complete. 
[heading Synopsis]```boolis_header_done();```[heading Description]
This function indicates whether or not all buffers containing serialized header octets have been retrieved. 
[endsect][section:limit http::serializer::limit][indexterm2 limit..http::serializer]
Returns the serialized buffer size limit. 
```std::size_t``[link beast.ref.boost__beast__http__serializer.limit.overload1 limit]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.limit.overload1 more...]]`````
Set the serialized buffer size limit. 
```void``[link beast.ref.boost__beast__http__serializer.limit.overload2 limit]``(    std::size_t limit);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.limit.overload2 more...]]`````[section:overload1 http::serializer::limit (1 of 2 overloads)]
Returns the serialized buffer size limit. 
[heading Synopsis]```std::size_tlimit();```[heading Description][endsect][section:overload2 http::serializer::limit (2 of 2 overloads)]
Set the serialized buffer size limit. 
[heading Synopsis]```voidlimit(    std::size_t limit);```[heading Description]
This function adjusts the limit on the maximum size of the buffers passed to the visitor. The new size limit takes effect in the following call to [link beast.ref.boost__beast__http__serializer.next `http::serializer::next`].

The default is no buffer size limit.

[heading Parameters][table [[Name][Description]]  [[`limit`][    The new buffer size limit. If this number is zero, the size limit is removed.   ]]]

[endsect][endsect][section:next http::serializer::next][indexterm2 next..http::serializer]
Returns the next set of buffers in the serialization. 
[heading Synopsis]```template<    class Visit>voidnext(    error_code& ec,    Visit&& visit);```[heading Description]
This function will attempt to call the `visit` function object with a [*ConstBufferSequence] of unspecified type representing the next set of buffers in the serialization of the message represented by this object.

If there are no more buffers in the serialization, the visit function will not be called. In this case, no error will be indicated, and the function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] will return `true`.

[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to the error, if any occurred.  ]]  [[`visit`][    The function to call. The equivalent function signature of this object must be: 
``
  template<class ConstBufferSequence>
  void visit(error_code&, ConstBufferSequence const&);
``
The function is not copied, if no error occurs it will be invoked before the call to [link beast.ref.boost__beast__http__serializer.next `next`] returns.   ]]]

[endsect][section:operator_eq_ http::serializer::operator=][indexterm2 operator=..http::serializer]
Assignment. 
[heading Synopsis]```serializer&operator=(    serializer const&);```[heading Description][endsect][section:reader_impl http::serializer::reader_impl][indexterm2 reader_impl..http::serializer]
Provides low-level access to the associated [*BodyWriter]. 
[heading Synopsis]```writer&reader_impl();```[heading Description]
This function provides access to the instance of the writer associated with the body and created by the serializer upon construction. The behavior of accessing this object is defined by the specification of the particular writer and its associated body.

[heading Return Value]
A reference to the writer. 


[endsect][section:serializer http::serializer::serializer][indexterm2 serializer..http::serializer]
Constructor. 
`````[link beast.ref.boost__beast__http__serializer.serializer.overload1 serializer]``(    serializer&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.serializer.overload1 more...]]````[link beast.ref.boost__beast__http__serializer.serializer.overload2 serializer]``(    serializer const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.serializer.overload2 more...]]``explicit``[link beast.ref.boost__beast__http__serializer.serializer.overload3 serializer]``(    value_type& msg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.serializer.overload3 more...]]`````[section:overload1 http::serializer::serializer (1 of 3 overloads)]
Constructor. 
[heading Synopsis]```serializer(    serializer&&);```[heading Description][endsect][section:overload2 http::serializer::serializer (2 of 3 overloads)]
Constructor. 
[heading Synopsis]```serializer(    serializer const&);```[heading Description][endsect][section:overload3 http::serializer::serializer (3 of 3 overloads)]
Constructor. 
[heading Synopsis]```serializer(    value_type& msg);```[heading Description]
The implementation guarantees that the message passed on construction will not be accessed until the first call to [link beast.ref.boost__beast__http__serializer.next `http::serializer::next`]. This allows the message to be lazily created. For example, if the header is filled in before serialization.

[heading Parameters][table [[Name][Description]]  [[`msg`][    A reference to the message to serialize, which must remain valid for the lifetime of the serializer. Depending on the type of Body used, this may or may not be a `const` reference.  ]]]
[heading Remarks]
This function participates in overload resolution only if Body::writer is constructible from a `const` message reference. 


[endsect][endsect][section:split http::serializer::split][indexterm2 split..http::serializer]
Returns `true` if we will pause after writing the complete header. 
```bool``[link beast.ref.boost__beast__http__serializer.split.overload1 split]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.split.overload1 more...]]`````
Set whether the header and body are written separately. 
```void``[link beast.ref.boost__beast__http__serializer.split.overload2 split]``(    bool v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__serializer.split.overload2 more...]]`````[section:overload1 http::serializer::split (1 of 2 overloads)]
Returns `true` if we will pause after writing the complete header. 
[heading Synopsis]```boolsplit();```[heading Description][endsect][section:overload2 http::serializer::split (2 of 2 overloads)]
Set whether the header and body are written separately. 
[heading Synopsis]```voidsplit(    bool v);```[heading Description]
When the split feature is enabled, the implementation will write only the octets corresponding to the serialized header first. If the header has already been written, this function will have no effect on output. 
[endsect][endsect][section:value_type http::serializer::value_type][indexterm2 value_type..http::serializer]
The type of message this serializer uses. 
[heading Synopsis]```using value_type = ``['implementation-defined]``;```[heading Description]
This may be const or non-const depending on the implementation of the corresponding [*BodyWriter]. 
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__span_body http::span_body]
A [*Body] using [link beast.ref.boost__beast__span `span`]. 
[heading Synopsis]Defined in header [include_file boost/beast/http/span_body.hpp]```template<    class T>struct span_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__span_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__span_body.value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__span_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__span_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]][heading Description]
This body uses [link beast.ref.boost__beast__span `span`] as a memory-based container for holding message payloads. The container represents a non-owning reference to a continguous area of memory. Messages using this body type may be serialized and parsed.

Unlike [link beast.ref.boost__beast__http__buffer_body `http::buffer_body`], only one buffer may be provided during a parse or serialize operation. 
[section:reader http::span_body::reader][indexterm2 reader..http::span_body]
The algorithm for parsing the body. 
[heading Synopsis]```using reader = ``['implementation-defined]``;```[heading Description]
Meets the requirements of [*BodyReader]. 
[endsect][section:size http::span_body::size][indexterm2 size..http::span_body]
Returns the payload size of the body. 
[heading Synopsis]```staticstd::uint64_tsize(    value_type const& body);```[heading Description]
When this body is used with [link beast.ref.boost__beast__http__message.prepare_payload `http::message::prepare_payload`], the Content-Length will be set to the payload size, and any chunked Transfer-Encoding will be removed. 
[endsect][section:value_type http::span_body::value_type][indexterm2 value_type..http::span_body]
The type of container used for the body. 
[heading Synopsis]```using value_type = span< T >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__span.const_iterator [*const_iterator]]]    [      The const iterator used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.const_pointer [*const_pointer]]]    [      The const pointer used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.const_reference [*const_reference]]]    [      The const reference used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.element_type [*element_type]]]    [      The type of value, including cv qualifiers.     ]  ]  [    [[link beast.ref.boost__beast__span.index_type [*index_type]]]    [      The type of integer used to index the span.     ]  ]  [    [[link beast.ref.boost__beast__span.iterator [*iterator]]]    [      The iterator used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.pointer [*pointer]]]    [      A pointer to a span element.     ]  ]  [    [[link beast.ref.boost__beast__span.reference [*reference]]]    [      A reference to a span element.     ]  ]  [    [[link beast.ref.boost__beast__span.value_type [*value_type]]]    [      The type of value of each span element.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__span.begin [*begin]]]    [      Returns an iterator to the beginning of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.cbegin [*cbegin]]]    [      Returns an iterator to the beginning of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.cend [*cend]]]    [      Returns an iterator to one past the end of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.data [*data]]]    [      Returns a pointer to the beginning of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.empty [*empty]]]    [      Returns true if the span is empty.     ]  ]  [    [[link beast.ref.boost__beast__span.end [*end]]]    [      Returns an iterator to one past the end of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__span.size [*size]]]    [      Returns the number of elements in the span.     ]  ]  [    [[link beast.ref.boost__beast__span.span [*span]]]    [      Constructor.     ]  ]]
This class implements a non-owning reference to a storage area of a certain size and having an underlying integral type with size of 1.

[heading Template Parameters][table [[Type][Description]]  [[`T`][    The type pointed to by span iterators   ]]]

[heading Description]
This determines the type of [link beast.ref.boost__beast__http__message.body `http::message::body`] when this body type is used with a message container. 
[endsect][section:writer http::span_body::writer][indexterm2 writer..http::span_body]
The algorithm for serializing the body. 
[heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description]
Meets the requirements of [*BodyWriter]. 
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__status http::status][indexterm1 http::status][heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```enum status```[indexterm2 unknown..http::status][indexterm2 continue_..http::status][indexterm2 switching_protocols..http::status][indexterm2 processing..http::status][indexterm2 ok..http::status][indexterm2 created..http::status][indexterm2 accepted..http::status][indexterm2 non_authoritative_information..http::status][indexterm2 no_content..http::status][indexterm2 reset_content..http::status][indexterm2 partial_content..http::status][indexterm2 multi_status..http::status][indexterm2 already_reported..http::status][indexterm2 im_used..http::status][indexterm2 multiple_choices..http::status][indexterm2 moved_permanently..http::status][indexterm2 found..http::status][indexterm2 see_other..http::status][indexterm2 not_modified..http::status][indexterm2 use_proxy..http::status][indexterm2 temporary_redirect..http::status][indexterm2 permanent_redirect..http::status][indexterm2 bad_request..http::status][indexterm2 unauthorized..http::status][indexterm2 payment_required..http::status][indexterm2 forbidden..http::status][indexterm2 not_found..http::status][indexterm2 method_not_allowed..http::status][indexterm2 not_acceptable..http::status][indexterm2 proxy_authentication_required..http::status][indexterm2 request_timeout..http::status][indexterm2 conflict..http::status][indexterm2 gone..http::status][indexterm2 length_required..http::status][indexterm2 precondition_failed..http::status][indexterm2 payload_too_large..http::status][indexterm2 uri_too_long..http::status][indexterm2 unsupported_media_type..http::status][indexterm2 range_not_satisfiable..http::status][indexterm2 expectation_failed..http::status][indexterm2 misdirected_request..http::status][indexterm2 unprocessable_entity..http::status][indexterm2 locked..http::status][indexterm2 failed_dependency..http::status][indexterm2 upgrade_required..http::status][indexterm2 precondition_required..http::status][indexterm2 too_many_requests..http::status][indexterm2 request_header_fields_too_large..http::status][indexterm2 connection_closed_without_response..http::status][indexterm2 unavailable_for_legal_reasons..http::status][indexterm2 client_closed_request..http::status][indexterm2 internal_server_error..http::status][indexterm2 not_implemented..http::status][indexterm2 bad_gateway..http::status][indexterm2 service_unavailable..http::status][indexterm2 gateway_timeout..http::status][indexterm2 http_version_not_supported..http::status][indexterm2 variant_also_negotiates..http::status][indexterm2 insufficient_storage..http::status][indexterm2 loop_detected..http::status][indexterm2 not_extended..http::status][indexterm2 network_authentication_required..http::status][indexterm2 network_connect_timeout_error..http::status][heading Values][table [[Name][Description]]  [[[^unknown]][An unknown status-code. This value indicates that the value for the status code is not in the list of commonly recognized status codes. Callers interested in the exactly value should use the interface which provides the raw integer. ]]  [[[^continue_]][]]  [[[^switching_protocols]][]]  [[[^processing]][]]  [[[^ok]][]]  [[[^created]][]]  [[[^accepted]][]]  [[[^non_authoritative_information]][]]  [[[^no_content]][]]  [[[^reset_content]][]]  [[[^partial_content]][]]  [[[^multi_status]][]]  [[[^already_reported]][]]  [[[^im_used]][]]  [[[^multiple_choices]][]]  [[[^moved_permanently]][]]  [[[^found]][]]  [[[^see_other]][]]  [[[^not_modified]][]]  [[[^use_proxy]][]]  [[[^temporary_redirect]][]]  [[[^permanent_redirect]][]]  [[[^bad_request]][]]  [[[^unauthorized]][]]  [[[^payment_required]][]]  [[[^forbidden]][]]  [[[^not_found]][]]  [[[^method_not_allowed]][]]  [[[^not_acceptable]][]]  [[[^proxy_authentication_required]][]]  [[[^request_timeout]][]]  [[[^conflict]][]]  [[[^gone]][]]  [[[^length_required]][]]  [[[^precondition_failed]][]]  [[[^payload_too_large]][]]  [[[^uri_too_long]][]]  [[[^unsupported_media_type]][]]  [[[^range_not_satisfiable]][]]  [[[^expectation_failed]][]]  [[[^misdirected_request]][]]  [[[^unprocessable_entity]][]]  [[[^locked]][]]  [[[^failed_dependency]][]]  [[[^upgrade_required]][]]  [[[^precondition_required]][]]  [[[^too_many_requests]][]]  [[[^request_header_fields_too_large]][]]  [[[^connection_closed_without_response]][]]  [[[^unavailable_for_legal_reasons]][]]  [[[^client_closed_request]][]]  [[[^internal_server_error]][]]  [[[^not_implemented]][]]  [[[^bad_gateway]][]]  [[[^service_unavailable]][]]  [[[^gateway_timeout]][]]  [[[^http_version_not_supported]][]]  [[[^variant_also_negotiates]][]]  [[[^insufficient_storage]][]]  [[[^loop_detected]][]]  [[[^not_extended]][]]  [[[^network_authentication_required]][]]  [[[^network_connect_timeout_error]][]]][heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__status_class http::status_class][indexterm1 http::status_class]
Represents the class of a status-code. 
[heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```enum status_class```[indexterm2 unknown..http::status_class][indexterm2 informational..http::status_class][indexterm2 successful..http::status_class][indexterm2 redirection..http::status_class][indexterm2 client_error..http::status_class][indexterm2 server_error..http::status_class][heading Values][table [[Name][Description]]  [[[^unknown]][Unknown status-class. ]]  [[[^informational]][The request was received, continuing processing. ]]  [[[^successful]][The request was successfully received, understood, and accepted. ]]  [[[^redirection]][Further action needs to be taken in order to complete the request. ]]  [[[^client_error]][The request contains bad syntax or cannot be fulfilled. ]]  [[[^server_error]][The server failed to fulfill an apparently valid request. ]]][heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__string_body http::string_body][indexterm1 http::string_body]
A [*Body] using `std::string` 
[heading Synopsis]Defined in header [include_file boost/beast/http/string_body.hpp]```using string_body = basic_string_body< char >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_string_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_string_body.value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__basic_string_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__basic_string_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]]
This body uses `std::basic_string` as a memory-based container for holding message payloads. Messages using this body type may be serialized and parsed. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__string_to_field http::string_to_field][indexterm1 http::string_to_field]
Attempt to convert a string to a field enum. 
[heading Synopsis]Defined in header [include_file boost/beast/http/field.hpp]```fieldstring_to_field(    string_view s);```[heading Description]
The string comparison is case-insensitive.

[heading Return Value]
The corresponding field, or [link beast.ref.boost__beast__http__field `http::unknown`] if no known field matches. 


Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__string_to_verb http::string_to_verb][indexterm1 http::string_to_verb]
Converts a string to the request method verb. 
[heading Synopsis]Defined in header [include_file boost/beast/http/verb.hpp]```verbstring_to_verb(    string_view s);```[heading Description]
If the string does not match a known request method, [link beast.ref.boost__beast__http__field `http::unknown`] is returned. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__swap http::swap][indexterm1 http::swap]
Swap two header objects. 
```template<    bool isRequest,    class ``[link beast.concepts.Fields [*Fields]]``>void``[link beast.ref.boost__beast__http__swap.overload1 swap]``(    header< isRequest, Fields >& m1,    header< isRequest, Fields >& m2);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__swap.overload1 more...]]`````
Swap two message objects. 
```template<    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>void``[link beast.ref.boost__beast__http__swap.overload2 swap]``(    message< isRequest, Body, Fields >& m1,    message< isRequest, Body, Fields >& m2);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__swap.overload2 more...]]`````[section:overload1 http::swap (1 of 2 overloads)]
Swap two header objects. 
[heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```template<    bool isRequest,    class ``[link beast.concepts.Fields [*Fields]]``>voidswap(    header< isRequest, Fields >& m1,    header< isRequest, Fields >& m2);```[heading Description]
[heading Requirements]
`Fields` is [*Swappable]. 


Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::swap (2 of 2 overloads)]
Swap two message objects. 
[heading Synopsis]Defined in header [include_file boost/beast/http/message.hpp]```template<    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>voidswap(    message< isRequest, Body, Fields >& m1,    message< isRequest, Body, Fields >& m2);```[heading Description]
[heading Requirements:]
`Body::value_type` and `Fields` are [*Swappable]. 


Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__to_status_class http::to_status_class][indexterm1 http::to_status_class]
Convert an integer to a status\_class. 
```status_class``[link beast.ref.boost__beast__http__to_status_class.overload1 to_status_class]``(    unsigned v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__to_status_class.overload1 more...]]`````
Convert a status\_code to a status\_class. 
```status_class``[link beast.ref.boost__beast__http__to_status_class.overload2 to_status_class]``(    status v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__to_status_class.overload2 more...]]`````[section:overload1 http::to_status_class (1 of 2 overloads)]
Convert an integer to a status\_class. 
[heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```status_classto_status_class(    unsigned v);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`v`][    The integer representing a status code.  ]]]
[heading Return Value]
The status class. If the integer does not match a known status class, [link beast.ref.boost__beast__http__field `http::unknown`] is returned. 


Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::to_status_class (2 of 2 overloads)]
Convert a status\_code to a status\_class. 
[heading Synopsis]Defined in header [include_file boost/beast/http/status.hpp]```status_classto_status_class(    status v);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`v`][    The status code to convert.  ]]]
[heading Return Value]
The status class. 


Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__to_string http::to_string][indexterm1 http::to_string]
Convert a field enum to a string. 
```string_view``[link beast.ref.boost__beast__http__to_string.overload1 to_string]``(    field f);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__to_string.overload1 more...]]`````
Returns the text representation of a request method verb. 
```string_view``[link beast.ref.boost__beast__http__to_string.overload2 to_string]``(    verb v);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__to_string.overload2 more...]]`````[section:overload1 http::to_string (1 of 2 overloads)]
Convert a field enum to a string. 
[heading Synopsis]Defined in header [include_file boost/beast/http/field.hpp]```string_viewto_string(    field f);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`f`][    The field to convert   ]]]

Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::to_string (2 of 2 overloads)]
Returns the text representation of a request method verb. 
[heading Synopsis]Defined in header [include_file boost/beast/http/verb.hpp]```string_viewto_string(    verb v);```[heading Description]Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__token_list http::token_list]
A list of tokens in a comma separated HTTP field value. 
[heading Synopsis]Defined in header [include_file boost/beast/http/rfc7230.hpp]```class token_list```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__token_list.const_iterator [*const_iterator]]]    [      A constant iterator to the list.     ]  ]  [    [[link beast.ref.boost__beast__http__token_list.value_type [*value_type]]]    [      The type of each element in the token list.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__token_list.begin [*begin]]]    [      Return a const iterator to the beginning of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__token_list.cbegin [*cbegin]]]    [      Return a const iterator to the beginning of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__token_list.cend [*cend]]]    [      Return a const iterator to the end of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__token_list.end [*end]]]    [      Return a const iterator to the end of the list.     ]  ]  [    [[link beast.ref.boost__beast__http__token_list.exists [*exists]]]    [      Return true if a token is present in the list.     ]  ]  [    [[link beast.ref.boost__beast__http__token_list.token_list [*token_list]]]    [      Construct a list.     ]  ]][heading Description]
This container allows iteration of a list of items in a header field value. The input is a comma separated list of tokens.

If a parsing error is encountered while iterating the string, the behavior of the container will be as if a string containing only characters up to but excluding the first invalid character was used to construct the list.

[heading BNF]


  token-list  = *( "," OWS ) token *( OWS "," [ OWS token ] )




To use this class, construct with the string to be parsed and then use [link beast.ref.boost__beast__http__token_list.begin `http::token_list::begin`] and [link beast.ref.boost__beast__http__token_list.end `http::token_list::end`], or range-for to iterate each item:

[heading Example]


  for(auto const& token : token_list{"apple, pear, banana"})
      std::cout << token << "\n";





[section:begin http::token_list::begin][indexterm2 begin..http::token_list]
Return a const iterator to the beginning of the list. 
[heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:cbegin http::token_list::cbegin][indexterm2 cbegin..http::token_list]
Return a const iterator to the beginning of the list. 
[heading Synopsis]```const_iteratorcbegin() const;```[heading Description][endsect][section:cend http::token_list::cend][indexterm2 cend..http::token_list]
Return a const iterator to the end of the list. 
[heading Synopsis]```const_iteratorcend() const;```[heading Description][endsect][section:const_iterator http::token_list::const_iterator][indexterm2 const_iterator..http::token_list]
A constant iterator to the list. 
[heading Synopsis]```using const_iterator = ``['implementation-defined]``;```[heading Description][endsect][section:end http::token_list::end][indexterm2 end..http::token_list]
Return a const iterator to the end of the list. 
[heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:exists http::token_list::exists][indexterm2 exists..http::token_list]
Return `true` if a token is present in the list. 
[heading Synopsis]```template<    class T>boolexists(    T const& s);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`s`][    The token to find. A case-insensitive comparison is used.   ]]]

[endsect][section:token_list http::token_list::token_list][indexterm2 token_list..http::token_list]
Construct a list. 
[heading Synopsis]```token_list(    string_view s);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`s`][    A string containing the list contents. The string must remain valid for the lifetime of the container.   ]]]

[endsect][section:value_type http::token_list::value_type][indexterm2 value_type..http::token_list]
The type of each element in the token list. 
[heading Synopsis]```using value_type = string_view;```[heading Description][endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__validate_list http::validate_list][indexterm1 http::validate_list]
Returns `true` if a parsed list is parsed without errors. 
[heading Synopsis]Defined in header [include_file boost/beast/http/rfc7230.hpp]```template<    class Policy>boolvalidate_list(    detail::basic_parsed_list< Policy > const& list);```[heading Description]
This function iterates a single pass through a parsed list and returns `true` if there were no parsing errors, else returns `false`. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__vector_body http::vector_body]
A [*Body] using `std::vector` 
[heading Synopsis]Defined in header [include_file boost/beast/http/vector_body.hpp]```template<    class T,    class Allocator = std::allocator<T>>struct vector_body```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__vector_body.reader [*reader]]]    [      The algorithm for parsing the body.     ]  ]  [    [[link beast.ref.boost__beast__http__vector_body.value_type [*value_type]]]    [      The type of container used for the body.     ]  ]  [    [[link beast.ref.boost__beast__http__vector_body.writer [*writer]]]    [      The algorithm for serializing the body.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__http__vector_body.size [*size]]]    [      Returns the payload size of the body.     ]  ]][heading Description]
This body uses `std::vector` as a memory-based container for holding message payloads. Messages using this body type may be serialized and parsed. 
[section:reader http::vector_body::reader][indexterm2 reader..http::vector_body]
The algorithm for parsing the body. 
[heading Synopsis]```using reader = ``['implementation-defined]``;```[heading Description]
Meets the requirements of [*BodyReader]. 
[endsect][section:size http::vector_body::size][indexterm2 size..http::vector_body]
Returns the payload size of the body. 
[heading Synopsis]```staticstd::uint64_tsize(    value_type const& body);```[heading Description]
When this body is used with [link beast.ref.boost__beast__http__message.prepare_payload `http::message::prepare_payload`], the Content-Length will be set to the payload size, and any chunked Transfer-Encoding will be removed. 
[endsect][section:value_type http::vector_body::value_type][indexterm2 value_type..http::vector_body]
The type of container used for the body. 
[heading Synopsis]```using value_type = std::vector< T, Allocator >;```[heading Description]
This determines the type of [link beast.ref.boost__beast__http__message.body `http::message::body`] when this body type is used with a message container. 
[endsect][section:writer http::vector_body::writer][indexterm2 writer..http::vector_body]
The algorithm for serializing the body. 
[heading Synopsis]```using writer = ``['implementation-defined]``;```[heading Description]
Meets the requirements of [*BodyWriter]. 
[endsect]Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__verb http::verb][indexterm1 http::verb]
HTTP request method verbs. 
[heading Synopsis]Defined in header [include_file boost/beast/http/verb.hpp]```enum verb```[indexterm2 unknown..http::verb][indexterm2 delete_..http::verb][indexterm2 get..http::verb][indexterm2 head..http::verb][indexterm2 post..http::verb][indexterm2 put..http::verb][indexterm2 connect..http::verb][indexterm2 options..http::verb][indexterm2 trace..http::verb][indexterm2 copy..http::verb][indexterm2 lock..http::verb][indexterm2 mkcol..http::verb][indexterm2 move..http::verb][indexterm2 propfind..http::verb][indexterm2 proppatch..http::verb][indexterm2 search..http::verb][indexterm2 unlock..http::verb][indexterm2 bind..http::verb][indexterm2 rebind..http::verb][indexterm2 unbind..http::verb][indexterm2 acl..http::verb][indexterm2 report..http::verb][indexterm2 mkactivity..http::verb][indexterm2 checkout..http::verb][indexterm2 merge..http::verb][indexterm2 msearch..http::verb][indexterm2 notify..http::verb][indexterm2 subscribe..http::verb][indexterm2 unsubscribe..http::verb][indexterm2 patch..http::verb][indexterm2 purge..http::verb][indexterm2 mkcalendar..http::verb][indexterm2 link..http::verb][indexterm2 unlink..http::verb][heading Values][table [[Name][Description]]  [[[^unknown]][An unknown method. This value indicates that the request method string is not one of the recognized verbs. Callers interested in the method should use an interface which returns the original string. ]]  [[[^delete_]][The DELETE method deletes the specified resource. ]]  [[[^get]][The GET method requests a representation of the specified resource. Requests using GET should only retrieve data and should have no other effect. ]]  [[[^head]][The HEAD method asks for a response identical to that of a GET request, but without the response body. This is useful for retrieving meta-information written in response headers, without having to transport the entire content. ]]  [[[^post]][The POST method requests that the server accept the entity enclosed in the request as a new subordinate of the web resource identified by the URI. The data POSTed might be, for example, an annotation for existing resources; a message for a bulletin board, newsgroup, mailing list, or comment thread; a block of data that is the result of submitting a web form to a data-handling process; or an item to add to a database ]]  [[[^put]][The PUT method requests that the enclosed entity be stored under the supplied URI. If the URI refers to an already existing resource, it is modified; if the URI does not point to an existing resource, then the server can create the resource with that URI. ]]  [[[^connect]][The CONNECT method converts the request connection to a transparent TCP/IP tunnel. This is usually to facilitate SSL-encrypted communication (HTTPS) through an unencrypted HTTP proxy. ]]  [[[^options]][The OPTIONS method returns the HTTP methods that the server supports for the specified URL. This can be used to check the functionality of a web server by requesting '*' instead of a specific resource. ]]  [[[^trace]][The TRACE method echoes the received request so that a client can see what (if any) changes or additions have been made by intermediate servers. ]]  [[[^copy]][]]  [[[^lock]][]]  [[[^mkcol]][]]  [[[^move]][]]  [[[^propfind]][]]  [[[^proppatch]][]]  [[[^search]][]]  [[[^unlock]][]]  [[[^bind]][]]  [[[^rebind]][]]  [[[^unbind]][]]  [[[^acl]][]]  [[[^report]][]]  [[[^mkactivity]][]]  [[[^checkout]][]]  [[[^merge]][]]  [[[^msearch]][]]  [[[^notify]][]]  [[[^subscribe]][]]  [[[^unsubscribe]][]]  [[[^patch]][]]  [[[^purge]][]]  [[[^mkcalendar]][]]  [[[^link]][]]  [[[^unlink]][]]][heading Description]
Each verb corresponds to a particular method string used in HTTP request messages. 
Convenience header [include_file boost/beast/http.hpp][endsect][section:boost__beast__http__write http::write][indexterm1 http::write]
Write a complete message to a stream using a serializer. 
```template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_t``[link beast.ref.boost__beast__http__write.overload1 write]``(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write.overload1 more...]]``template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_t``[link beast.ref.boost__beast__http__write.overload2 write]``(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write.overload2 more...]]`````
Write a complete message to a stream. 
```template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_t``[link beast.ref.boost__beast__http__write.overload3 write]``(    SyncWriteStream& stream,    message< isRequest, Body, Fields > const& msg);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write.overload3 more...]]``template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_t``[link beast.ref.boost__beast__http__write.overload4 write]``(    SyncWriteStream& stream,    message< isRequest, Body, Fields > const& msg,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write.overload4 more...]]`````[section:overload1 http::write (1 of 4 overloads)]
Write a complete message to a stream using a serializer. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_twrite(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr);```[heading Description]
This function is used to write a complete message to a stream using a caller-provided HTTP/1 serializer. The call will block until one of the following conditions is true:


* The function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream to which the data is to be written. The type must support the SyncWriteStream concept.  ]]  [[`sr`][    The serializer to use.  ]]]
[heading Return Value]
The number of bytes written to the stream.

[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 


Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::write (2 of 4 overloads)]
Write a complete message to a stream using a serializer. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_twrite(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    error_code& ec);```[heading Description]
This function is used to write a complete message to a stream using a caller-provided HTTP/1 serializer. The call will block until one of the following conditions is true:


* The function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream to which the data is to be written. The type must support the SyncWriteStream concept.  ]]  [[`sr`][    The serializer to use.  ]]  [[`ec`][    Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes written to the stream.

[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 


Convenience header [include_file boost/beast/http.hpp][endsect][section:overload3 http::write (3 of 4 overloads)]
Write a complete message to a stream. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_twrite(    SyncWriteStream& stream,    message< isRequest, Body, Fields > const& msg);```[heading Description]
This function is used to write a complete message to a stream using HTTP/1. The call will block until one of the following conditions is true:


* The entire message is written.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function. The algorithm will use a temporary [link beast.ref.boost__beast__http__serializer `http::serializer`] with an empty chunk decorator to produce buffers.

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream to which the data is to be written. The type must support the SyncWriteStream concept.  ]]  [[`msg`][    The message to write.  ]]]
[heading Return Value]
The number of bytes written to the stream.

[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__message `http::message`] 


Convenience header [include_file boost/beast/http.hpp][endsect][section:overload4 http::write (4 of 4 overloads)]
Write a complete message to a stream. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_twrite(    SyncWriteStream& stream,    message< isRequest, Body, Fields > const& msg,    error_code& ec);```[heading Description]
This function is used to write a complete message to a stream using HTTP/1. The call will block until one of the following conditions is true:


* The entire message is written.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function. The algorithm will use a temporary [link beast.ref.boost__beast__http__serializer `http::serializer`] with an empty chunk decorator to produce buffers.

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream to which the data is to be written. The type must support the SyncWriteStream concept.  ]]  [[`msg`][    The message to write.  ]]  [[`ec`][    Set to the error, if any occurred.  ]]]
[heading Return Value]
The number of bytes written to the stream.

[heading See Also]
[link beast.ref.boost__beast__http__message `http::message`] 


Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__write_header http::write_header][indexterm1 http::write_header]
Write a header to a stream using a serializer. 
```template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_t``[link beast.ref.boost__beast__http__write_header.overload1 write_header]``(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write_header.overload1 more...]]``template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_t``[link beast.ref.boost__beast__http__write_header.overload2 write_header]``(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write_header.overload2 more...]]`````[section:overload1 http::write_header (1 of 2 overloads)]
Write a header to a stream using a serializer. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_twrite_header(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr);```[heading Description]
This function is used to write a header to a stream using a caller-provided HTTP/1 serializer. The call will block until one of the following conditions is true:


* The function [link beast.ref.boost__beast__http__serializer.is_header_done `http::serializer::is_header_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream to which the data is to be written. The type must support the SyncWriteStream concept.  ]]  [[`sr`][    The serializer to use.  ]]]
[heading Return Value]
The number of bytes written to the stream.

[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.  ]]]
[heading Remarks]
The implementation will call [link beast.ref.boost__beast__http__serializer.split `http::serializer::split`] with the value `true` on the serializer passed in.

[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 


Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::write_header (2 of 2 overloads)]
Write a header to a stream using a serializer. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_twrite_header(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    error_code& ec);```[heading Description]
This function is used to write a header to a stream using a caller-provided HTTP/1 serializer. The call will block until one of the following conditions is true:


* The function [link beast.ref.boost__beast__http__serializer.is_header_done `http::serializer::is_header_done`] returns `true`


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream to which the data is to be written. The type must support the SyncWriteStream concept.  ]]  [[`sr`][    The serializer to use.  ]]  [[`ec`][    Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes written to the stream.

[heading Remarks]
The implementation will call [link beast.ref.boost__beast__http__serializer.split `http::serializer::split`] with the value `true` on the serializer passed in.

[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 


Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__http__write_some http::write_some][indexterm1 http::write_some]
Write part of a message to a stream using a serializer. 
```template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_t``[link beast.ref.boost__beast__http__write_some.overload1 write_some]``(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write_some.overload1 more...]]``template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_t``[link beast.ref.boost__beast__http__write_some.overload2 write_some]``(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__http__write_some.overload2 more...]]`````[section:overload1 http::write_some (1 of 2 overloads)]
Write part of a message to a stream using a serializer. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_twrite_some(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr);```[heading Description]
This function is used to write part of a message to a stream using a caller-provided HTTP/1 serializer. The call will block until one of the following conditions is true:


* One or more bytes have been transferred.


* The function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] returns `true`


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.

The amount of data actually transferred is controlled by the behavior of the underlying stream, subject to the buffer size limit of the serializer obtained or set through a call to [link beast.ref.boost__beast__http__serializer.limit `http::serializer::limit`]. Setting a limit and performing bounded work helps applications set reasonable timeouts. It also allows application-level flow control to function correctly. For example when using a TCP/IP based stream.

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream to which the data is to be written. The type must support the SyncWriteStream concept.  ]]  [[`sr`][    The serializer to use.  ]]]
[heading Return Value]
The number of bytes written to the stream.

[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.  ]]]
[heading See Also]
[link beast.ref.boost__beast__http__serializer `http::serializer`] 


Convenience header [include_file boost/beast/http.hpp][endsect][section:overload2 http::write_some (2 of 2 overloads)]
Write part of a message to a stream using a serializer. 
[heading Synopsis]Defined in header [include_file boost/beast/http/write.hpp]```template<    class __SyncWriteStream__,    bool isRequest,    class ``[link beast.concepts.Body [*Body]]``,    class ``[link beast.concepts.Fields [*Fields]]``>std::size_twrite_some(    SyncWriteStream& stream,    serializer< isRequest, Body, Fields >& sr,    error_code& ec);```[heading Description]
This function is used to write part of a message to a stream using a caller-provided HTTP/1 serializer. The call will block until one of the following conditions is true:


* One or more bytes have been transferred.


* The function [link beast.ref.boost__beast__http__serializer.is_done `http::serializer::is_done`] returns `true`


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.

The amount of data actually transferred is controlled by the behavior of the underlying stream, subject to the buffer size limit of the serializer obtained or set through a call to [link beast.ref.boost__beast__http__serializer.limit `http::serializer::limit`]. Setting a limit and performing bounded work helps applications set reasonable timeouts. It also allows application-level flow control to function correctly. For example when using a TCP/IP based stream.

[heading Parameters][table [[Name][Description]]  [[`stream`][    The stream to which the data is to be written. The type must support the SyncWriteStream concept.  ]]  [[`sr`][    The serializer to use.  ]]  [[`ec`][    Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes written to the stream.

[heading See Also]
[link beast.ref.boost__beast__http__async_write_some `http::async_write_some`], [link beast.ref.boost__beast__http__serializer `http::serializer`] 


Convenience header [include_file boost/beast/http.hpp][endsect][endsect][section:boost__beast__iequal iequal]
A case-insensitive equality predicate for strings. 
[heading Synopsis]Defined in header [include_file boost/beast/core/string.hpp]```struct iequal```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__iequal.operator_lp__rp_ [*operator()]]]    [          ]  ]][heading Description]
The case-comparison operation is defined only for low-ASCII characters. 
[section:operator_lp__rp_ iequal::operator()][indexterm2 operator()..iequal][heading Synopsis]```booloperator()(    string_view lhs,    string_view rhs) const;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__iequals iequals][indexterm1 iequals]
Returns `true` if two strings are equal, using a case-insensitive comparison. 
[heading Synopsis]Defined in header [include_file boost/beast/core/string.hpp]```booliequals(    beast::string_view lhs,    beast::string_view rhs);```[heading Description]
The case-comparison operation is defined only for low-ASCII characters.

[heading Parameters][table [[Name][Description]]  [[`lhs`][    The string on the left side of the equality  ]]  [[`rhs`][    The string on the right side of the equality   ]]]

Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__iless iless]
A case-insensitive less predicate for strings. 
[heading Synopsis]Defined in header [include_file boost/beast/core/string.hpp]```struct iless```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__iless.operator_lp__rp_ [*operator()]]]    [          ]  ]][heading Description]
The case-comparison operation is defined only for low-ASCII characters. 
[section:operator_lp__rp_ iless::operator()][indexterm2 operator()..iless][heading Synopsis]```booloperator()(    string_view lhs,    string_view rhs) const;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_async_read_stream is_async_read_stream]
Determine if `T` meets the requirements of [*AsyncReadStream]. 
[heading Synopsis]Defined in header [include_file boost/beast/core/type_traits.hpp]```template<    class T>struct is_async_read_stream :    public std::integral_constant< bool,...>```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.

[heading Example]


Use with `static_assert`:



  template<class AsyncReadStream>
  void f(AsyncReadStream& stream)
  {
      static_assert(is_async_read_stream<AsyncReadStream>::value,
          "AsyncReadStream requirements not met");
  ...




Use with `std::enable_if` (SFINAE):



  template<class AsyncReadStream>
  typename std::enable_if<is_async_read_stream<AsyncReadStream>::value>::type
  f(AsyncReadStream& stream);



Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_async_stream is_async_stream]
Determine if `T` meets the requirements of [*AsyncStream]. 
[heading Synopsis]Defined in header [include_file boost/beast/core/type_traits.hpp]```template<    class T>struct is_async_stream :    public std::integral_constant< bool,...>```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.

[heading Example]


Use with `static_assert`:



  template<class AsyncStream>
  void f(AsyncStream& stream)
  {
      static_assert(is_async_stream<AsyncStream>::value,
          "AsyncStream requirements not met");
  ...




Use with `std::enable_if` (SFINAE):



  template<class AsyncStream>
  typename std::enable_if<is_async_stream<AsyncStream>::value>::type
  f(AsyncStream& stream);



Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_async_write_stream is_async_write_stream]
Determine if `T` meets the requirements of [*AsyncWriteStream]. 
[heading Synopsis]Defined in header [include_file boost/beast/core/type_traits.hpp]```template<    class T>struct is_async_write_stream :    public std::integral_constant< bool,...>```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.

[heading Example]


Use with `static_assert`:



  template<class AsyncWriteStream>
  void f(AsyncWriteStream& stream)
  {
      static_assert(is_async_write_stream<AsyncWriteStream>::value,
          "AsyncWriteStream requirements not met");
  ...




Use with `std::enable_if` (SFINAE):



  template<class AsyncWriteStream>
  typename std::enable_if<is_async_write_stream<AsyncWriteStream>::value>::type
  f(AsyncWriteStream& stream);



Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_completion_handler is_completion_handler][indexterm1 is_completion_handler]
Determine if `T` meets the requirements of [*CompletionHandler]. 
[heading Synopsis]Defined in header [include_file boost/beast/core/type_traits.hpp]```using is_completion_handler = std::integral_constant< bool,...>;```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_file is_file]
Determine if `T` meets the requirements of [*File]. 
[heading Synopsis]Defined in header [include_file boost/beast/core/type_traits.hpp]```template<    class T>struct is_file :    public std::integral_constant< bool,...>```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.

[heading Example]


Use with `static_assert`:



  template<class File>
  void f(File& file)
  {
      static_assert(is_file<File>::value,
          "File requirements not met");
  ...




Use with `std::enable_if` (SFINAE):



  template<class File>
  typename std::enable_if<is_file<File>::value>::type
  f(File& file);



Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_sync_read_stream is_sync_read_stream]
Determine if `T` meets the requirements of [*SyncReadStream]. 
[heading Synopsis]Defined in header [include_file boost/beast/core/type_traits.hpp]```template<    class T>struct is_sync_read_stream :    public std::integral_constant< bool,...>```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.

[heading Example]


Use with `static_assert`:



  template<class SyncReadStream>
  void f(SyncReadStream& stream)
  {
      static_assert(is_sync_read_stream<SyncReadStream>::value,
          "SyncReadStream requirements not met");
  ...




Use with `std::enable_if` (SFINAE):



  template<class SyncReadStream>
  typename std::enable_if<is_sync_read_stream<SyncReadStream>::value>::type
  f(SyncReadStream& stream);



Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_sync_stream is_sync_stream]
Determine if `T` meets the requirements of [*SyncStream]. 
[heading Synopsis]Defined in header [include_file boost/beast/core/type_traits.hpp]```template<    class T>struct is_sync_stream :    public std::integral_constant< bool,...>```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.

[heading Example]


Use with `static_assert`:



  template<class SyncStream>
  void f(SyncStream& stream)
  {
      static_assert(is_sync_stream<SyncStream>::value,
          "SyncStream requirements not met");
  ...




Use with `std::enable_if` (SFINAE):



  template<class SyncStream>
  typename std::enable_if<is_sync_stream<SyncStream>::value>::type
  f(SyncStream& stream);



Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__is_sync_write_stream is_sync_write_stream]
Determine if `T` meets the requirements of [*SyncWriteStream]. 
[heading Synopsis]Defined in header [include_file boost/beast/core/type_traits.hpp]```template<    class T>struct is_sync_write_stream :    public std::integral_constant< bool,...>```[heading Description]
Metafunctions are used to perform compile time checking of template types. This type will be `std::true_type` if `T` meets the requirements, else the type will be `std::false_type`.

[heading Example]


Use with `static_assert`:



  template<class SyncReadStream>
  void f(SyncReadStream& stream)
  {
      static_assert(is_sync_read_stream<SyncReadStream>::value,
          "SyncReadStream requirements not met");
  ...




Use with `std::enable_if` (SFINAE):



  template<class SyncReadStream>
  typename std::enable_if<is_sync_read_stream<SyncReadStream>::value>::type
  f(SyncReadStream& stream);



Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__multi_buffer multi_buffer][indexterm1 multi_buffer]
A typical multi buffer. 
[heading Synopsis]Defined in header [include_file boost/beast/core/multi_buffer.hpp]```using multi_buffer = basic_multi_buffer< std::allocator< char >>;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_multi_buffer.allocator_type [*allocator_type]]]    [      The type of allocator used.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.const_buffers_type [*const_buffers_type]]]    [      The type used to represent the input sequence as a list of buffers.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.mutable_buffers_type [*mutable_buffers_type]]]    [      The type used to represent the output sequence as a list of buffers.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer [*basic_multi_buffer]]]    [      Constructor.       Move constructor.       Copy constructor.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.capacity [*capacity]]]    [      Returns the maximum sum of the sizes of the input sequence and output sequence the buffer can hold without requiring reallocation.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.commit [*commit]]]    [      Move bytes from the output sequence to the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.consume [*consume]]]    [      Remove bytes from the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.data [*data]]]    [      Get a list of buffers that represents the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.get_allocator [*get_allocator]]]    [      Returns a copy of the associated allocator.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.max_size [*max_size]]]    [      Returns the permitted maximum sum of the sizes of the input and output sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.operator_eq_ [*operator=]]]    [      Move assignment.       Copy assignment.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.prepare [*prepare]]]    [      Get a list of buffers that represents the output sequence, with the given size.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.size [*size]]]    [      Returns the size of the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__basic_multi_buffer.basic_multi_buffer_dtor_ [*~basic_multi_buffer]]]    [      Destructor.     ]  ]][heading Friends][table [[Name][Description]]  [    [[link beast.ref.boost__beast__basic_multi_buffer.swap [*swap]]]    [          ]  ]]
The implementation uses a sequence of one or more character arrays of varying sizes. Additional character array objects are appended to the sequence to accommodate changes in the size of the character sequence.

[heading Remarks]
Meets the requirements of [*DynamicBuffer].

[heading Template Parameters][table [[Type][Description]]  [[`Allocator`][    The allocator to use for managing memory.   ]]]

Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__operator_not__eq_ operator!=][indexterm1 operator!=]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_not__eq_.overload1 operator!=]``(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_not__eq_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_not__eq_.overload2 operator!=]``(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_not__eq_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_not__eq_.overload3 operator!=]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_not__eq_.overload3 more...]]`````[section:overload1 operator!= (1 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>booloperator!=(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator!= (2 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator!=(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator!= (3 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator!=(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__operator_plus_ operator+][indexterm1 operator+]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>void``[link beast.ref.boost__beast__operator_plus_.overload1 operator+]``(    static_string< N, CharT, Traits >const& lhs,    static_string< M, CharT, Traits >const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_plus_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>void``[link beast.ref.boost__beast__operator_plus_.overload2 operator+]``(    CharT const* lhs,    static_string< N, CharT, Traits >const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_plus_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>void``[link beast.ref.boost__beast__operator_plus_.overload3 operator+]``(    CharT lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_plus_.overload3 more...]]``template<    std::size_t N,    class CharT,    class Traits>void``[link beast.ref.boost__beast__operator_plus_.overload4 operator+]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_plus_.overload4 more...]]``template<    std::size_t N,    class CharT,    class Traits>void``[link beast.ref.boost__beast__operator_plus_.overload5 operator+]``(    static_string< N, CharT, Traits > const& lhs,    CharT rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_plus_.overload5 more...]]`````[section:overload1 operator+ (1 of 5 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>voidoperator+(    static_string< N, CharT, Traits >const& lhs,    static_string< M, CharT, Traits >const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator+ (2 of 5 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>voidoperator+(    CharT const* lhs,    static_string< N, CharT, Traits >const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator+ (3 of 5 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>voidoperator+(    CharT lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload4 operator+ (4 of 5 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>voidoperator+(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload5 operator+ (5 of 5 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>voidoperator+(    static_string< N, CharT, Traits > const& lhs,    CharT rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__operator_lt_ operator<][indexterm1 operator<]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_lt_.overload1 operator<]``(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_lt_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_lt_.overload2 operator<]``(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_lt_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_lt_.overload3 operator<]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_lt_.overload3 more...]]`````[section:overload1 operator< (1 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>booloperator<(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator< (2 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator<(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator< (3 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator<(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__operator_lt__lt_ operator<<][indexterm1 operator<<][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>std::basic_ostream< CharT, Traits >&operator<<(    std::basic_ostream< CharT, Traits >& os,    static_string< N, CharT, Traits > const& str);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__operator_lt__eq_ operator<=][indexterm1 operator<=]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_lt__eq_.overload1 operator<=]``(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_lt__eq_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_lt__eq_.overload2 operator<=]``(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_lt__eq_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_lt__eq_.overload3 operator<=]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_lt__eq_.overload3 more...]]`````[section:overload1 operator<= (1 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>booloperator<=(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator<= (2 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator<=(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator<= (3 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator<=(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__operator_eq__eq_ operator==][indexterm1 operator==]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_eq__eq_.overload1 operator==]``(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_eq__eq_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_eq__eq_.overload2 operator==]``(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_eq__eq_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_eq__eq_.overload3 operator==]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_eq__eq_.overload3 more...]]`````[section:overload1 operator== (1 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>booloperator==(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator== (2 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator==(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator== (3 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator==(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__operator_gt_ operator>][indexterm1 operator>]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_gt_.overload1 operator>]``(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_gt_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_gt_.overload2 operator>]``(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_gt_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_gt_.overload3 operator>]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_gt_.overload3 more...]]`````[section:overload1 operator> (1 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>booloperator>(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator> (2 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator>(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator> (3 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator>(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__operator_gt__eq_ operator>=][indexterm1 operator>=]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_gt__eq_.overload1 operator>=]``(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_gt__eq_.overload1 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_gt__eq_.overload2 operator>=]``(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_gt__eq_.overload2 more...]]``template<    std::size_t N,    class CharT,    class Traits>bool``[link beast.ref.boost__beast__operator_gt__eq_.overload3 operator>=]``(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__operator_gt__eq_.overload3 more...]]`````[section:overload1 operator>= (1 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>booloperator>=(    static_string< N, CharT, Traits > const& lhs,    static_string< M, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 operator>= (2 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator>=(    CharT const* lhs,    static_string< N, CharT, Traits > const& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload3 operator>= (3 of 3 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>booloperator>=(    static_string< N, CharT, Traits > const& lhs,    CharT const* rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__ostream ostream][indexterm1 ostream]
Return an output stream that formats values into a [*DynamicBuffer]. 
[heading Synopsis]Defined in header [include_file boost/beast/core/ostream.hpp]```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>``['implementation-defined]``ostream(    DynamicBuffer& buffer);```[heading Description]
This function wraps the caller provided [*DynamicBuffer] into a `std::ostream` derived class, to allow `operator<<` stream style formatting operations.

[heading Example]


  ostream(buffer) << "Hello, world!" << std::endl;




[heading Remarks]
Calling members of the underlying buffer before the output stream is destroyed results in undefined behavior.

[heading Parameters][table [[Name][Description]]  [[`buffer`][    An object meeting the requirements of DynamicBuffer into which the formatted output will be placed.  ]]]
[heading Return Value]
An object derived from `std::ostream` which redirects output The wrapped dynamic buffer is not modified, a copy is made instead. Ownership of the underlying memory is not transferred, the application is still responsible for managing its lifetime. The caller is responsible for ensuring the dynamic buffer is not destroyed for the lifetime of the output stream. 


Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__read_size read_size][indexterm1 read_size]
Returns a natural read size. 
[heading Synopsis]Defined in header [include_file boost/beast/core/read_size.hpp]```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>std::size_tread_size(    DynamicBuffer& buffer,    std::size_t max_size);```[heading Description]
This function inspects the capacity, size, and maximum size of the dynamic buffer. Then it computes a natural read size given the passed-in upper limit. It favors a read size that does not require a reallocation, subject to a reasonable minimum to avoid tiny reads.

[heading Parameters][table [[Name][Description]]  [[`buffer`][    The dynamic buffer to inspect.  ]]  [[`max_size`][    An upper limit on the returned value.  ]]]
[heading Remarks]
If the buffer is already at its maximum size, zero is returned. 


Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__read_size_or_throw read_size_or_throw][indexterm1 read_size_or_throw]
Returns a natural read size or throw if the buffer is full. 
[heading Synopsis]Defined in header [include_file boost/beast/core/read_size.hpp]```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>std::size_tread_size_or_throw(    DynamicBuffer& buffer,    std::size_t max_size);```[heading Description]
This function inspects the capacity, size, and maximum size of the dynamic buffer. Then it computes a natural read size given the passed-in upper limit. It favors a read size that does not require a reallocation, subject to a reasonable minimum to avoid tiny reads.

[heading Parameters][table [[Name][Description]]  [[`buffer`][    The dynamic buffer to inspect.  ]]  [[`max_size`][    An upper limit on the returned value.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    if `max_size > 0` and the buffer is full.   ]]]

Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__span span]
A range of bytes expressed as a ContiguousContainer. 
[heading Synopsis]Defined in header [include_file boost/beast/core/span.hpp]```template<    class T>class span```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__span.const_iterator [*const_iterator]]]    [      The const iterator used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.const_pointer [*const_pointer]]]    [      The const pointer used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.const_reference [*const_reference]]]    [      The const reference used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.element_type [*element_type]]]    [      The type of value, including cv qualifiers.     ]  ]  [    [[link beast.ref.boost__beast__span.index_type [*index_type]]]    [      The type of integer used to index the span.     ]  ]  [    [[link beast.ref.boost__beast__span.iterator [*iterator]]]    [      The iterator used by the container.     ]  ]  [    [[link beast.ref.boost__beast__span.pointer [*pointer]]]    [      A pointer to a span element.     ]  ]  [    [[link beast.ref.boost__beast__span.reference [*reference]]]    [      A reference to a span element.     ]  ]  [    [[link beast.ref.boost__beast__span.value_type [*value_type]]]    [      The type of value of each span element.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__span.begin [*begin]]]    [      Returns an iterator to the beginning of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.cbegin [*cbegin]]]    [      Returns an iterator to the beginning of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.cend [*cend]]]    [      Returns an iterator to one past the end of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.data [*data]]]    [      Returns a pointer to the beginning of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.empty [*empty]]]    [      Returns true if the span is empty.     ]  ]  [    [[link beast.ref.boost__beast__span.end [*end]]]    [      Returns an iterator to one past the end of the span.     ]  ]  [    [[link beast.ref.boost__beast__span.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__span.size [*size]]]    [      Returns the number of elements in the span.     ]  ]  [    [[link beast.ref.boost__beast__span.span [*span]]]    [      Constructor.     ]  ]][heading Description]
This class implements a non-owning reference to a storage area of a certain size and having an underlying integral type with size of 1.

[heading Template Parameters][table [[Type][Description]]  [[`T`][    The type pointed to by span iterators   ]]]

[section:begin span::begin][indexterm2 begin..span]
Returns an iterator to the beginning of the span. 
[heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][section:cbegin span::cbegin][indexterm2 cbegin..span]
Returns an iterator to the beginning of the span. 
[heading Synopsis]```const_iteratorcbegin() const;```[heading Description][endsect][section:cend span::cend][indexterm2 cend..span]
Returns an iterator to one past the end of the span. 
[heading Synopsis]```const_iteratorcend() const;```[heading Description][endsect][section:const_iterator span::const_iterator][indexterm2 const_iterator..span]
The const iterator used by the container. 
[heading Synopsis]```using const_iterator = const_pointer;```[heading Description][endsect][section:const_pointer span::const_pointer][indexterm2 const_pointer..span]
The const pointer used by the container. 
[heading Synopsis]```using const_pointer = T const*;```[heading Description][endsect][section:const_reference span::const_reference][indexterm2 const_reference..span]
The const reference used by the container. 
[heading Synopsis]```using const_reference = T const&;```[heading Description][endsect][section:data span::data][indexterm2 data..span]
Returns a pointer to the beginning of the span. 
[heading Synopsis]```T*data() const;```[heading Description][endsect][section:element_type span::element_type][indexterm2 element_type..span]
The type of value, including cv qualifiers. 
[heading Synopsis]```using element_type = T;```[heading Description][endsect][section:empty span::empty][indexterm2 empty..span]
Returns `true` if the span is empty. 
[heading Synopsis]```boolempty() const;```[heading Description][endsect][section:end span::end][indexterm2 end..span]
Returns an iterator to one past the end of the span. 
[heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][section:index_type span::index_type][indexterm2 index_type..span]
The type of integer used to index the span. 
[heading Synopsis]```using index_type = std::ptrdiff_t;```[heading Description][endsect][section:iterator span::iterator][indexterm2 iterator..span]
The iterator used by the container. 
[heading Synopsis]```using iterator = pointer;```[heading Description][endsect][section:operator_eq_ span::operator=][indexterm2 operator=..span]
Assignment. 
```span&``[link beast.ref.boost__beast__span.operator_eq_.overload1 operator=]``(    span const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__span.operator_eq_.overload1 more...]]``template<    class ContiguousContainer>span&``[link beast.ref.boost__beast__span.operator_eq_.overload2 operator=]``(    ContiguousContainer&& container);  ``[''''&raquo;''' [link beast.ref.boost__beast__span.operator_eq_.overload2 more...]]`````[section:overload1 span::operator= (1 of 2 overloads)]
Assignment. 
[heading Synopsis]```span&operator=(    span const&);```[heading Description][endsect][section:overload2 span::operator= (2 of 2 overloads)]
Assignment. 
[heading Synopsis]```template<    class ContiguousContainer>span&operator=(    ContiguousContainer&& container);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`container`][    The container to assign from   ]]]

[endsect][endsect][section:pointer span::pointer][indexterm2 pointer..span]
A pointer to a span element. 
[heading Synopsis]```using pointer = T*;```[heading Description][endsect][section:reference span::reference][indexterm2 reference..span]
A reference to a span element. 
[heading Synopsis]```using reference = T&;```[heading Description][endsect][section:size span::size][indexterm2 size..span]
Returns the number of elements in the span. 
[heading Synopsis]```std::size_tsize() const;```[heading Description][endsect][section:span span::span][indexterm2 span..span]
Constructor. 
`````[link beast.ref.boost__beast__span.span.overload1 span]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__span.span.overload1 more...]]````[link beast.ref.boost__beast__span.span.overload2 span]``(    span const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__span.span.overload2 more...]]````[link beast.ref.boost__beast__span.span.overload3 span]``(    T* data,    std::size_t size);  ``[''''&raquo;''' [link beast.ref.boost__beast__span.span.overload3 more...]]``template<    class ContiguousContainer>explicit``[link beast.ref.boost__beast__span.span.overload4 span]``(    ContiguousContainer&& container);  ``[''''&raquo;''' [link beast.ref.boost__beast__span.span.overload4 more...]]`````[section:overload1 span::span (1 of 4 overloads)]
Constructor. 
[heading Synopsis]```span();```[heading Description][endsect][section:overload2 span::span (2 of 4 overloads)]
Constructor. 
[heading Synopsis]```span(    span const&);```[heading Description][endsect][section:overload3 span::span (3 of 4 overloads)]
Constructor. 
[heading Synopsis]```span(    T* data,    std::size_t size);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`data`][    A pointer to the beginning of the range of elements  ]]  [[`size`][    The number of elements pointed to by `data`   ]]]

[endsect][section:overload4 span::span (4 of 4 overloads)]
Constructor. 
[heading Synopsis]```template<    class ContiguousContainer>span(    ContiguousContainer&& container);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`container`][    The container to construct from   ]]]

[endsect][endsect][section:value_type span::value_type][indexterm2 value_type..span]
The type of value of each span element. 
[heading Synopsis]```using value_type = typename std::remove_const< T >::type;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__static_buffer static_buffer]
A circular [*DynamicBuffer] with a fixed size internal buffer. 
[heading Synopsis]Defined in header [include_file boost/beast/core/static_buffer.hpp]```template<    std::size_t N>class static_buffer :    public static_buffer_base```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_buffer.const_buffers_type [*const_buffers_type]]]    [      The type used to represent the input sequence as a list of buffers.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.mutable_buffers_type [*mutable_buffers_type]]]    [      The type used to represent the output sequence as a list of buffers.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_buffer.base [*base]]]    [      Returns the static_buffer_base portion of this object.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.capacity [*capacity]]]    [      Return the maximum sum of input and output sizes that can be held without an allocation.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.commit [*commit]]]    [      Move bytes from the output sequence to the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.consume [*consume]]]    [      Remove bytes from the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.data [*data]]]    [      Get a list of buffers that represent the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.max_size [*max_size]]]    [      Return the maximum sum of the input and output sequence sizes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.prepare [*prepare]]]    [      Get a list of buffers that represent the output sequence, with the given size.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.size [*size]]]    [      Return the size of the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer.static_buffer [*static_buffer]]]    [      Constructor.     ]  ]][heading Protected Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_buffer.reset [*reset]]]    [      Reset the pointed-to buffer.     ]  ]][heading Description]
This implements a circular dynamic buffer. Calls to [link beast.ref.boost__beast__static_buffer.prepare `static_buffer::prepare`] never require moving memory. The buffer sequences returned may be up to length two. Ownership of the underlying storage belongs to the derived class.

[heading Template Parameters][table [[Type][Description]]  [[`N`][    The number of bytes in the internal buffer.  ]]]
[heading Remarks]
To reduce the number of template instantiations when passing objects of this type in a deduced context, the signature of the receiving function should use [link beast.ref.boost__beast__static_buffer_base `static_buffer_base`] instead.

[heading See Also]
[link beast.ref.boost__beast__static_buffer_base `static_buffer_base`] 


[section:base static_buffer::base][indexterm2 base..static_buffer]
Returns the [link beast.ref.boost__beast__static_buffer_base `static_buffer_base`] portion of this object. 
```static_buffer_base&``[link beast.ref.boost__beast__static_buffer.base.overload1 base]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_buffer.base.overload1 more...]]``static_buffer_base const&``[link beast.ref.boost__beast__static_buffer.base.overload2 base]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_buffer.base.overload2 more...]]`````[section:overload1 static_buffer::base (1 of 2 overloads)]
Returns the [link beast.ref.boost__beast__static_buffer_base `static_buffer_base`] portion of this object. 
[heading Synopsis]```static_buffer_base&base();```[heading Description][endsect][section:overload2 static_buffer::base (2 of 2 overloads)]
Returns the [link beast.ref.boost__beast__static_buffer_base `static_buffer_base`] portion of this object. 
[heading Synopsis]```static_buffer_base const&base() const;```[heading Description][endsect][endsect][section:capacity static_buffer::capacity][indexterm2 capacity..static_buffer]
Return the maximum sum of input and output sizes that can be held without an allocation. 
[heading Synopsis]```std::size_t constexprcapacity() const;```[heading Description][endsect][section:commit static_buffer::commit][indexterm2 commit..static_buffer]
Move bytes from the output sequence to the input sequence. 
[heading Synopsis]```voidcommit(    std::size_t size);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`size`][    The nubmer of bytes to commit. If this is greater than the size of the output sequence, the entire output sequence is committed.   ]]]

[endsect][section:const_buffers_type static_buffer::const_buffers_type][indexterm2 const_buffers_type..static_buffer]
The type used to represent the input sequence as a list of buffers. 
[heading Synopsis]```using const_buffers_type = std::array< boost::asio::mutable_buffer, 2 >;```[heading Description][endsect][section:consume static_buffer::consume][indexterm2 consume..static_buffer]
Remove bytes from the input sequence. 
[heading Synopsis]```voidconsume(    std::size_t size);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`size`][    The number of bytes to consume. If this is greater than the size of the input sequence, the entire input sequence is consumed.   ]]]

[endsect][section:data static_buffer::data][indexterm2 data..static_buffer]
Get a list of buffers that represent the input sequence. 
[heading Synopsis]```const_buffers_typedata() const;```[heading Description][endsect][section:max_size static_buffer::max_size][indexterm2 max_size..static_buffer]
Return the maximum sum of the input and output sequence sizes. 
[heading Synopsis]```std::size_t constexprmax_size() const;```[heading Description][endsect][section:mutable_buffers_type static_buffer::mutable_buffers_type][indexterm2 mutable_buffers_type..static_buffer]
The type used to represent the output sequence as a list of buffers. 
[heading Synopsis]```using mutable_buffers_type = std::array< boost::asio::mutable_buffer, 2 >;```[heading Description][endsect][section:operator_eq_ static_buffer::operator=][indexterm2 operator=..static_buffer]
Assignment. 
[heading Synopsis]```static_buffer&operator=(    static_buffer const&);```[heading Description][endsect][section:prepare static_buffer::prepare][indexterm2 prepare..static_buffer]
Get a list of buffers that represent the output sequence, with the given size. 
[heading Synopsis]```mutable_buffers_typeprepare(    std::size_t size);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`size`][    The number of bytes to request.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    if the size would exceed the capacity.   ]]]

[endsect][section:reset static_buffer::reset][indexterm2 reset..static_buffer]
Reset the pointed-to buffer. 
[heading Synopsis]```voidreset(    void* p,    std::size_t size);```[heading Description]
This function resets the internal state to the buffer provided. All input and output sequences are invalidated. This function allows the derived class to construct its members before initializing the static buffer.

[heading Parameters][table [[Name][Description]]  [[`p`][    A pointer to valid storage of at least `n` bytes.  ]]  [[`size`][    The number of valid bytes pointed to by `p`.   ]]]

[endsect][section:size static_buffer::size][indexterm2 size..static_buffer]
Return the size of the input sequence. 
[heading Synopsis]```std::size_tsize() const;```[heading Description][endsect][section:static_buffer static_buffer::static_buffer][indexterm2 static_buffer..static_buffer]
Constructor. 
`````[link beast.ref.boost__beast__static_buffer.static_buffer.overload1 static_buffer]``(    static_buffer const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_buffer.static_buffer.overload1 more...]]````[link beast.ref.boost__beast__static_buffer.static_buffer.overload2 static_buffer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_buffer.static_buffer.overload2 more...]]`````[section:overload1 static_buffer::static_buffer (1 of 2 overloads)]
Constructor. 
[heading Synopsis]```static_buffer(    static_buffer const&);```[heading Description][endsect][section:overload2 static_buffer::static_buffer (2 of 2 overloads)]
Constructor. 
[heading Synopsis]```static_buffer();```[heading Description][endsect][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__static_buffer_base static_buffer_base]
A circular [*DynamicBuffer] with a fixed size internal buffer. 
[heading Synopsis]Defined in header [include_file boost/beast/core/static_buffer.hpp]```class static_buffer_base```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_buffer_base.const_buffers_type [*const_buffers_type]]]    [      The type used to represent the input sequence as a list of buffers.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.mutable_buffers_type [*mutable_buffers_type]]]    [      The type used to represent the output sequence as a list of buffers.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_buffer_base.capacity [*capacity]]]    [      Return the maximum sum of input and output sizes that can be held without an allocation.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.commit [*commit]]]    [      Move bytes from the output sequence to the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.consume [*consume]]]    [      Remove bytes from the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.data [*data]]]    [      Get a list of buffers that represent the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.max_size [*max_size]]]    [      Return the maximum sum of the input and output sequence sizes.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.prepare [*prepare]]]    [      Get a list of buffers that represent the output sequence, with the given size.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.size [*size]]]    [      Return the size of the input sequence.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.static_buffer_base [*static_buffer_base]]]    [      Constructor.     ]  ]][heading Protected Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_buffer_base.reset [*reset]]]    [      Reset the pointed-to buffer.     ]  ]  [    [[link beast.ref.boost__beast__static_buffer_base.static_buffer_base [*static_buffer_base]]]    [      Constructor.     ]  ]][heading Description]
This implements a circular dynamic buffer. Calls to [link beast.ref.boost__beast__static_buffer.prepare `static_buffer::prepare`] never require moving memory. The buffer sequences returned may be up to length two. Ownership of the underlying storage belongs to the derived class.

[heading Remarks]
Variables are usually declared using the template class [link beast.ref.boost__beast__static_buffer `static_buffer`]; however, to reduce the number of instantiations of template functions receiving static stream buffer arguments in a deduced context, the signature of the receiving function should use [link beast.ref.boost__beast__static_buffer_base `static_buffer_base`].

When used with [link beast.ref.boost__beast__static_buffer `static_buffer`] this implements a dynamic buffer using no memory allocations.

[heading See Also]
[link beast.ref.boost__beast__static_buffer `static_buffer`] 


[section:capacity static_buffer_base::capacity][indexterm2 capacity..static_buffer_base]
Return the maximum sum of input and output sizes that can be held without an allocation. 
[heading Synopsis]```std::size_tcapacity() const;```[heading Description][endsect][section:commit static_buffer_base::commit][indexterm2 commit..static_buffer_base]
Move bytes from the output sequence to the input sequence. 
[heading Synopsis]```voidcommit(    std::size_t size);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`size`][    The nubmer of bytes to commit. If this is greater than the size of the output sequence, the entire output sequence is committed.   ]]]

[endsect][section:const_buffers_type static_buffer_base::const_buffers_type][indexterm2 const_buffers_type..static_buffer_base]
The type used to represent the input sequence as a list of buffers. 
[heading Synopsis]```using const_buffers_type = std::array< boost::asio::mutable_buffer, 2 >;```[heading Description][endsect][section:consume static_buffer_base::consume][indexterm2 consume..static_buffer_base]
Remove bytes from the input sequence. 
[heading Synopsis]```voidconsume(    std::size_t size);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`size`][    The number of bytes to consume. If this is greater than the size of the input sequence, the entire input sequence is consumed.   ]]]

[endsect][section:data static_buffer_base::data][indexterm2 data..static_buffer_base]
Get a list of buffers that represent the input sequence. 
[heading Synopsis]```const_buffers_typedata() const;```[heading Description][endsect][section:max_size static_buffer_base::max_size][indexterm2 max_size..static_buffer_base]
Return the maximum sum of the input and output sequence sizes. 
[heading Synopsis]```std::size_tmax_size() const;```[heading Description][endsect][section:mutable_buffers_type static_buffer_base::mutable_buffers_type][indexterm2 mutable_buffers_type..static_buffer_base]
The type used to represent the output sequence as a list of buffers. 
[heading Synopsis]```using mutable_buffers_type = std::array< boost::asio::mutable_buffer, 2 >;```[heading Description][endsect][section:prepare static_buffer_base::prepare][indexterm2 prepare..static_buffer_base]
Get a list of buffers that represent the output sequence, with the given size. 
[heading Synopsis]```mutable_buffers_typeprepare(    std::size_t size);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`size`][    The number of bytes to request.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`std::length_error`][    if the size would exceed the capacity.   ]]]

[endsect][section:reset static_buffer_base::reset][indexterm2 reset..static_buffer_base]
Reset the pointed-to buffer. 
[heading Synopsis]```voidreset(    void* p,    std::size_t size);```[heading Description]
This function resets the internal state to the buffer provided. All input and output sequences are invalidated. This function allows the derived class to construct its members before initializing the static buffer.

[heading Parameters][table [[Name][Description]]  [[`p`][    A pointer to valid storage of at least `n` bytes.  ]]  [[`size`][    The number of valid bytes pointed to by `p`.   ]]]

[endsect][section:size static_buffer_base::size][indexterm2 size..static_buffer_base]
Return the size of the input sequence. 
[heading Synopsis]```std::size_tsize() const;```[heading Description][endsect][section:static_buffer_base static_buffer_base::static_buffer_base][indexterm2 static_buffer_base..static_buffer_base]
Constructor. 
[heading Synopsis]```static_buffer_base(    void* p,    std::size_t size);```[heading Description]
This creates a dynamic buffer using the provided storage area.

[heading Parameters][table [[Name][Description]]  [[`p`][    A pointer to valid storage of at least `n` bytes.  ]]  [[`size`][    The number of valid bytes pointed to by `p`.   ]]]

[endsect][section:static_buffer_base static_buffer_base::static_buffer_base][indexterm2 static_buffer_base..static_buffer_base]
Constructor. 
[heading Synopsis]```static_buffer_base();```[heading Description]
The buffer will be in an undefined state. It is necessary for the derived class to call [link beast.ref.boost__beast__static_buffer.reset `static_buffer::reset`] in order to initialize the object. 
[endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__static_string static_string]
A modifiable string with a fixed-size storage area. 
[heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT = char,    class Traits = std::char_traits<CharT>>class static_string```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.const_iterator [*const_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_pointer [*const_pointer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_reference [*const_reference]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_reverse_iterator [*const_reverse_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.difference_type [*difference_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.iterator [*iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.pointer [*pointer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.reference [*reference]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.reverse_iterator [*reverse_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.size_type [*size_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.string_view_type [*string_view_type]]]    [      The type of string_view returned by the interface.     ]  ]  [    [[link beast.ref.boost__beast__static_string.traits_type [*traits_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.value_type [*value_type]]]    [          ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.append [*append]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.assign [*assign]]]    [      Assign count copies of ch.       Assign from another static_string       Assign count characterss starting at npos from other.       Assign the first count characters of s, including nulls.       Assign a null terminated string.       Assign from an iterator range of characters.       Assign from any object convertible to string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.at [*at]]]    [      Access specified character with bounds checking.     ]  ]  [    [[link beast.ref.boost__beast__static_string.back [*back]]]    [      Accesses the last character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.begin [*begin]]]    [      Returns an iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.c_str [*c_str]]]    [      Returns a non-modifiable standard C character array version of the string.     ]  ]  [    [[link beast.ref.boost__beast__static_string.capacity [*capacity]]]    [      Returns the number of characters that can be held in currently allocated storage.     ]  ]  [    [[link beast.ref.boost__beast__static_string.cbegin [*cbegin]]]    [      Returns an iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.cend [*cend]]]    [      Returns an iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.clear [*clear]]]    [      Clears the contents.     ]  ]  [    [[link beast.ref.boost__beast__static_string.compare [*compare]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.copy [*copy]]]    [      Copy a substring (pos, pos+count) to character string pointed to by dest.     ]  ]  [    [[link beast.ref.boost__beast__static_string.crbegin [*crbegin]]]    [      Returns a reverse iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.crend [*crend]]]    [      Returns a reverse iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.data [*data]]]    [      Returns a pointer to the first character of a string.     ]  ]  [    [[link beast.ref.boost__beast__static_string.empty [*empty]]]    [      Returns true if the string is empty.     ]  ]  [    [[link beast.ref.boost__beast__static_string.end [*end]]]    [      Returns an iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.erase [*erase]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.front [*front]]]    [      Accesses the first character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.insert [*insert]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.length [*length]]]    [      Returns the number of characters, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.max_size [*max_size]]]    [      Returns the maximum number of characters that can be stored, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_string_view_type [*operator string_view_type]]]    [      Convert a static string to a string_view_type     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_plus__eq_ [*operator+=]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_eq_ [*operator=]]]    [      Copy assignment.       Assign from null-terminated string.       Assign from single character.       Assign from initializer list.       Assign from string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_lb__rb_ [*operator\[\]]]]    [      Access specified character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.pop_back [*pop_back]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.push_back [*push_back]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.rbegin [*rbegin]]]    [      Returns a reverse iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.rend [*rend]]]    [      Returns a reverse iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.reserve [*reserve]]]    [      Reserves storage.     ]  ]  [    [[link beast.ref.boost__beast__static_string.resize [*resize]]]    [      Changes the number of characters stored.     ]  ]  [    [[link beast.ref.boost__beast__static_string.shrink_to_fit [*shrink_to_fit]]]    [      Reduces memory usage by freeing unused memory.     ]  ]  [    [[link beast.ref.boost__beast__static_string.size [*size]]]    [      Returns the number of characters, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.static_string [*static_string]]]    [      Default constructor (empty string).       Construct with count copies of character ch.       Construct with a substring (pos, other.size()) of other.       Construct with a substring (pos, count) of other.       Construct with the first count characters of s, including nulls.       Construct from a null terminated string.       Construct from a range of characters.       Copy constructor.       Construct from an initializer list.       Construct from a string_view       Construct from any object convertible to string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.substr [*substr]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.swap [*swap]]]    [      Exchange the contents of this string with another.     ]  ]][heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.max_size_n [*max_size_n]]]    [      Maximum size of the string excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.npos [*npos]]]    [      A special index.     ]  ]][heading Description]
These objects behave like `std::string` except that the storage is not dynamically allocated but rather fixed in size.

These strings offer performance advantages when a protocol imposes a natural small upper limit on the size of a value.

[heading Remarks]
The stored string is always null-terminated.

[heading See Also]
[link beast.ref.boost__beast__to_static_string `to_static_string`] 


[section:append static_string::append][indexterm2 append..static_string]```static_string&``[link beast.ref.boost__beast__static_string.append.overload1 append]``(    size_type count,    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload1 more...]]``template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.append.overload2 append]``(    static_string< M, CharT, Traits > const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload2 more...]]``template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.append.overload3 append]``(    static_string< M, CharT, Traits > const& str,    size_type pos,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload3 more...]]``static_string&``[link beast.ref.boost__beast__static_string.append.overload4 append]``(    CharT const* s,    size_type count);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload4 more...]]``static_string&``[link beast.ref.boost__beast__static_string.append.overload5 append]``(    CharT const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload5 more...]]``template<    class InputIt>static_string&``[link beast.ref.boost__beast__static_string.append.overload6 append]``(    InputIt first,    InputIt last);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload6 more...]]``static_string&``[link beast.ref.boost__beast__static_string.append.overload7 append]``(    std::initializer_list< CharT > init);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload7 more...]]``static_string&``[link beast.ref.boost__beast__static_string.append.overload8 append]``(    string_view_type sv);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload8 more...]]``template<    class T>std::enable_if< std::is_convertible< T const &, string_view_type >::value &&!std::is_convertible< T const &, CharT const * >::value, static_string & >::type``[link beast.ref.boost__beast__static_string.append.overload9 append]``(    T const& t,    size_type pos,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.append.overload9 more...]]`````[section:overload1 static_string::append (1 of 9 overloads)][heading Synopsis]```static_string&append(    size_type count,    CharT ch);```[heading Description][endsect][section:overload2 static_string::append (2 of 9 overloads)][heading Synopsis]```template<    std::size_t M>static_string&append(    static_string< M, CharT, Traits > const& str);```[heading Description][endsect][section:overload3 static_string::append (3 of 9 overloads)][heading Synopsis]```template<    std::size_t M>static_string&append(    static_string< M, CharT, Traits > const& str,    size_type pos,    size_type count = npos);```[heading Description][endsect][section:overload4 static_string::append (4 of 9 overloads)][heading Synopsis]```static_string&append(    CharT const* s,    size_type count);```[heading Description][endsect][section:overload5 static_string::append (5 of 9 overloads)][heading Synopsis]```static_string&append(    CharT const* s);```[heading Description][endsect][section:overload6 static_string::append (6 of 9 overloads)][heading Synopsis]```template<    class InputIt>static_string&append(    InputIt first,    InputIt last);```[heading Description][endsect][section:overload7 static_string::append (7 of 9 overloads)][heading Synopsis]```static_string&append(    std::initializer_list< CharT > init);```[heading Description][endsect][section:overload8 static_string::append (8 of 9 overloads)][heading Synopsis]```static_string&append(    string_view_type sv);```[heading Description][endsect][section:overload9 static_string::append (9 of 9 overloads)][heading Synopsis]```template<    class T>std::enable_if< std::is_convertible< T const &, string_view_type >::value &&!std::is_convertible< T const &, CharT const * >::value, static_string & >::typeappend(    T const& t,    size_type pos,    size_type count = npos);```[heading Description][endsect][endsect][section:assign static_string::assign][indexterm2 assign..static_string]
Assign `count` copies of `ch`. 
```static_string&``[link beast.ref.boost__beast__static_string.assign.overload1 assign]``(    size_type count,    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload1 more...]]`````
Assign from another `static_string` 
```static_string&``[link beast.ref.boost__beast__static_string.assign.overload2 assign]``(    static_string const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload2 more...]]``template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.assign.overload3 assign]``(    static_string< M, CharT, Traits > const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload3 more...]]`````
Assign `count` characterss starting at `npos` from `other`. 
```template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.assign.overload4 assign]``(    static_string< M, CharT, Traits > const& str,    size_type pos,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload4 more...]]`````
Assign the first `count` characters of `s`, including nulls. 
```static_string&``[link beast.ref.boost__beast__static_string.assign.overload5 assign]``(    CharT const* s,    size_type count);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload5 more...]]`````
Assign a null terminated string. 
```static_string&``[link beast.ref.boost__beast__static_string.assign.overload6 assign]``(    CharT const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload6 more...]]`````
Assign from an iterator range of characters. 
```template<    class InputIt>static_string&``[link beast.ref.boost__beast__static_string.assign.overload7 assign]``(    InputIt first,    InputIt last);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload7 more...]]``static_string&``[link beast.ref.boost__beast__static_string.assign.overload8 assign]``(    std::initializer_list< CharT > init);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload8 more...]]``static_string&``[link beast.ref.boost__beast__static_string.assign.overload9 assign]``(    string_view_type str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload9 more...]]`````
Assign from any object convertible to `string_view_type`. 
```template<    class T>static_string&``[link beast.ref.boost__beast__static_string.assign.overload10 assign]``(    T const& t,    size_type pos,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.assign.overload10 more...]]`````[section:overload1 static_string::assign (1 of 10 overloads)]
Assign `count` copies of `ch`. 
[heading Synopsis]```static_string&assign(    size_type count,    CharT ch);```[heading Description][endsect][section:overload2 static_string::assign (2 of 10 overloads)]
Assign from another `static_string` 
[heading Synopsis]```static_string&assign(    static_string const& str);```[heading Description][endsect][section:overload3 static_string::assign (3 of 10 overloads)]
Assign from another `static_string` 
[heading Synopsis]```template<    std::size_t M>static_string&assign(    static_string< M, CharT, Traits > const& str);```[heading Description][endsect][section:overload4 static_string::assign (4 of 10 overloads)]
Assign `count` characterss starting at `npos` from `other`. 
[heading Synopsis]```template<    std::size_t M>static_string&assign(    static_string< M, CharT, Traits > const& str,    size_type pos,    size_type count = npos);```[heading Description][endsect][section:overload5 static_string::assign (5 of 10 overloads)]
Assign the first `count` characters of `s`, including nulls. 
[heading Synopsis]```static_string&assign(    CharT const* s,    size_type count);```[heading Description][endsect][section:overload6 static_string::assign (6 of 10 overloads)]
Assign a null terminated string. 
[heading Synopsis]```static_string&assign(    CharT const* s);```[heading Description][endsect][section:overload7 static_string::assign (7 of 10 overloads)]
Assign from an iterator range of characters. 
[heading Synopsis]```template<    class InputIt>static_string&assign(    InputIt first,    InputIt last);```[heading Description][endsect][section:overload8 static_string::assign (8 of 10 overloads)]
Assign from initializer list. 
[heading Synopsis]```static_string&assign(    std::initializer_list< CharT > init);```[heading Description][endsect][section:overload9 static_string::assign (9 of 10 overloads)]
Assign from `string_view_type`. 
[heading Synopsis]```static_string&assign(    string_view_type str);```[heading Description][endsect][section:overload10 static_string::assign (10 of 10 overloads)]
Assign from any object convertible to `string_view_type`. 
[heading Synopsis]```template<    class T>static_string&assign(    T const& t,    size_type pos,    size_type count = npos);```[heading Description]
The range (pos, n) is extracted from the value obtained by converting `t` to `string_view_type`, and used to assign the string. 
[endsect][endsect][section:at static_string::at][indexterm2 at..static_string]
Access specified character with bounds checking. 
```reference``[link beast.ref.boost__beast__static_string.at.overload1 at]``(    size_type pos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.at.overload1 more...]]``const_reference``[link beast.ref.boost__beast__static_string.at.overload2 at]``(    size_type pos) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.at.overload2 more...]]`````[section:overload1 static_string::at (1 of 2 overloads)]
Access specified character with bounds checking. 
[heading Synopsis]```referenceat(    size_type pos);```[heading Description][endsect][section:overload2 static_string::at (2 of 2 overloads)]
Access specified character with bounds checking. 
[heading Synopsis]```const_referenceat(    size_type pos) const;```[heading Description][endsect][endsect][section:back static_string::back][indexterm2 back..static_string]
Accesses the last character. 
```CharT&``[link beast.ref.boost__beast__static_string.back.overload1 back]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.back.overload1 more...]]``CharT const&``[link beast.ref.boost__beast__static_string.back.overload2 back]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.back.overload2 more...]]`````[section:overload1 static_string::back (1 of 2 overloads)]
Accesses the last character. 
[heading Synopsis]```CharT&back();```[heading Description][endsect][section:overload2 static_string::back (2 of 2 overloads)]
Accesses the last character. 
[heading Synopsis]```CharT const&back() const;```[heading Description][endsect][endsect][section:begin static_string::begin][indexterm2 begin..static_string]
Returns an iterator to the beginning. 
```iterator``[link beast.ref.boost__beast__static_string.begin.overload1 begin]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.begin.overload1 more...]]``const_iterator``[link beast.ref.boost__beast__static_string.begin.overload2 begin]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.begin.overload2 more...]]`````[section:overload1 static_string::begin (1 of 2 overloads)]
Returns an iterator to the beginning. 
[heading Synopsis]```iteratorbegin();```[heading Description][endsect][section:overload2 static_string::begin (2 of 2 overloads)]
Returns an iterator to the beginning. 
[heading Synopsis]```const_iteratorbegin() const;```[heading Description][endsect][endsect][section:c_str static_string::c_str][indexterm2 c_str..static_string]
Returns a non-modifiable standard C character array version of the string. 
[heading Synopsis]```CharT const*c_str() const;```[heading Description][endsect][section:capacity static_string::capacity][indexterm2 capacity..static_string]
Returns the number of characters that can be held in currently allocated storage. 
[heading Synopsis]```size_type constexprcapacity() const;```[heading Description][endsect][section:cbegin static_string::cbegin][indexterm2 cbegin..static_string]
Returns an iterator to the beginning. 
[heading Synopsis]```const_iteratorcbegin() const;```[heading Description][endsect][section:cend static_string::cend][indexterm2 cend..static_string]
Returns an iterator to the end. 
[heading Synopsis]```const_iteratorcend() const;```[heading Description][endsect][section:clear static_string::clear][indexterm2 clear..static_string]
Clears the contents. 
[heading Synopsis]```voidclear();```[heading Description][endsect][section:compare static_string::compare][indexterm2 compare..static_string]```template<    std::size_t M>int``[link beast.ref.boost__beast__static_string.compare.overload1 compare]``(    static_string< M, CharT, Traits > const& str) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload1 more...]]``template<    std::size_t M>int``[link beast.ref.boost__beast__static_string.compare.overload2 compare]``(    size_type pos1,    size_type count1,    static_string< M, CharT, Traits > const& str) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload2 more...]]``template<    std::size_t M>int``[link beast.ref.boost__beast__static_string.compare.overload3 compare]``(    size_type pos1,    size_type count1,    static_string< M, CharT, Traits > const& str,    size_type pos2,    size_type count2 = npos) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload3 more...]]``int``[link beast.ref.boost__beast__static_string.compare.overload4 compare]``(    CharT const* s) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload4 more...]]``int``[link beast.ref.boost__beast__static_string.compare.overload5 compare]``(    size_type pos1,    size_type count1,    CharT const* s) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload5 more...]]``int``[link beast.ref.boost__beast__static_string.compare.overload6 compare]``(    size_type pos1,    size_type count1,    CharT const* s,    size_type count2) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload6 more...]]``int``[link beast.ref.boost__beast__static_string.compare.overload7 compare]``(    string_view_type str) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload7 more...]]``int``[link beast.ref.boost__beast__static_string.compare.overload8 compare]``(    size_type pos1,    size_type count1,    string_view_type str) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload8 more...]]``template<    class T>int``[link beast.ref.boost__beast__static_string.compare.overload9 compare]``(    size_type pos1,    size_type count1,    T const& t,    size_type pos2,    size_type count2 = npos) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.compare.overload9 more...]]`````[section:overload1 static_string::compare (1 of 9 overloads)][heading Synopsis]```template<    std::size_t M>intcompare(    static_string< M, CharT, Traits > const& str) const;```[heading Description][endsect][section:overload2 static_string::compare (2 of 9 overloads)][heading Synopsis]```template<    std::size_t M>intcompare(    size_type pos1,    size_type count1,    static_string< M, CharT, Traits > const& str) const;```[heading Description][endsect][section:overload3 static_string::compare (3 of 9 overloads)][heading Synopsis]```template<    std::size_t M>intcompare(    size_type pos1,    size_type count1,    static_string< M, CharT, Traits > const& str,    size_type pos2,    size_type count2 = npos) const;```[heading Description][endsect][section:overload4 static_string::compare (4 of 9 overloads)][heading Synopsis]```intcompare(    CharT const* s) const;```[heading Description][endsect][section:overload5 static_string::compare (5 of 9 overloads)][heading Synopsis]```intcompare(    size_type pos1,    size_type count1,    CharT const* s) const;```[heading Description][endsect][section:overload6 static_string::compare (6 of 9 overloads)][heading Synopsis]```intcompare(    size_type pos1,    size_type count1,    CharT const* s,    size_type count2) const;```[heading Description][endsect][section:overload7 static_string::compare (7 of 9 overloads)][heading Synopsis]```intcompare(    string_view_type str) const;```[heading Description][endsect][section:overload8 static_string::compare (8 of 9 overloads)][heading Synopsis]```intcompare(    size_type pos1,    size_type count1,    string_view_type str) const;```[heading Description][endsect][section:overload9 static_string::compare (9 of 9 overloads)][heading Synopsis]```template<    class T>intcompare(    size_type pos1,    size_type count1,    T const& t,    size_type pos2,    size_type count2 = npos) const;```[heading Description][endsect][endsect][section:const_iterator static_string::const_iterator][indexterm2 const_iterator..static_string][heading Synopsis]```using const_iterator = value_type const*;```[heading Description][endsect][section:const_pointer static_string::const_pointer][indexterm2 const_pointer..static_string][heading Synopsis]```using const_pointer = value_type const*;```[heading Description][endsect][section:const_reference static_string::const_reference][indexterm2 const_reference..static_string][heading Synopsis]```using const_reference = value_type const&;```[heading Description][endsect][section:const_reverse_iterator static_string::const_reverse_iterator][indexterm2 const_reverse_iterator..static_string][heading Synopsis]```using const_reverse_iterator = std::reverse_iterator< const_iterator >;```[heading Description][endsect][section:copy static_string::copy][indexterm2 copy..static_string]
Copy a substring (pos, pos+count) to character string pointed to by `dest`. 
[heading Synopsis]```size_typecopy(    CharT* dest,    size_type count,    size_type pos = 0) const;```[heading Description][endsect][section:crbegin static_string::crbegin][indexterm2 crbegin..static_string]
Returns a reverse iterator to the beginning. 
[heading Synopsis]```const_reverse_iteratorcrbegin() const;```[heading Description][endsect][section:crend static_string::crend][indexterm2 crend..static_string]
Returns a reverse iterator to the end. 
[heading Synopsis]```const_reverse_iteratorcrend() const;```[heading Description][endsect][section:data static_string::data][indexterm2 data..static_string]
Returns a pointer to the first character of a string. 
```CharT*``[link beast.ref.boost__beast__static_string.data.overload1 data]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.data.overload1 more...]]``CharT const*``[link beast.ref.boost__beast__static_string.data.overload2 data]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.data.overload2 more...]]`````[section:overload1 static_string::data (1 of 2 overloads)]
Returns a pointer to the first character of a string. 
[heading Synopsis]```CharT*data();```[heading Description][endsect][section:overload2 static_string::data (2 of 2 overloads)]
Returns a pointer to the first character of a string. 
[heading Synopsis]```CharT const*data() const;```[heading Description][endsect][endsect][section:difference_type static_string::difference_type][indexterm2 difference_type..static_string][heading Synopsis]```using difference_type = std::ptrdiff_t;```[heading Description][endsect][section:empty static_string::empty][indexterm2 empty..static_string]
Returns `true` if the string is empty. 
[heading Synopsis]```boolempty() const;```[heading Description][endsect][section:end static_string::end][indexterm2 end..static_string]
Returns an iterator to the end. 
```iterator``[link beast.ref.boost__beast__static_string.end.overload1 end]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.end.overload1 more...]]``const_iterator``[link beast.ref.boost__beast__static_string.end.overload2 end]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.end.overload2 more...]]`````[section:overload1 static_string::end (1 of 2 overloads)]
Returns an iterator to the end. 
[heading Synopsis]```iteratorend();```[heading Description][endsect][section:overload2 static_string::end (2 of 2 overloads)]
Returns an iterator to the end. 
[heading Synopsis]```const_iteratorend() const;```[heading Description][endsect][endsect][section:erase static_string::erase][indexterm2 erase..static_string]```static_string&``[link beast.ref.boost__beast__static_string.erase.overload1 erase]``(    size_type index = 0,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.erase.overload1 more...]]``iterator``[link beast.ref.boost__beast__static_string.erase.overload2 erase]``(    const_iterator pos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.erase.overload2 more...]]``iterator``[link beast.ref.boost__beast__static_string.erase.overload3 erase]``(    const_iterator first,    const_iterator last);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.erase.overload3 more...]]`````[section:overload1 static_string::erase (1 of 3 overloads)][heading Synopsis]```static_string&erase(    size_type index = 0,    size_type count = npos);```[heading Description][endsect][section:overload2 static_string::erase (2 of 3 overloads)][heading Synopsis]```iteratorerase(    const_iterator pos);```[heading Description][endsect][section:overload3 static_string::erase (3 of 3 overloads)][heading Synopsis]```iteratorerase(    const_iterator first,    const_iterator last);```[heading Description][endsect][endsect][section:front static_string::front][indexterm2 front..static_string]
Accesses the first character. 
```CharT&``[link beast.ref.boost__beast__static_string.front.overload1 front]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.front.overload1 more...]]``CharT const&``[link beast.ref.boost__beast__static_string.front.overload2 front]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.front.overload2 more...]]`````[section:overload1 static_string::front (1 of 2 overloads)]
Accesses the first character. 
[heading Synopsis]```CharT&front();```[heading Description][endsect][section:overload2 static_string::front (2 of 2 overloads)]
Accesses the first character. 
[heading Synopsis]```CharT const&front() const;```[heading Description][endsect][endsect][section:insert static_string::insert][indexterm2 insert..static_string]```static_string&``[link beast.ref.boost__beast__static_string.insert.overload1 insert]``(    size_type index,    size_type count,    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload1 more...]]``static_string&``[link beast.ref.boost__beast__static_string.insert.overload2 insert]``(    size_type index,    CharT const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload2 more...]]``static_string&``[link beast.ref.boost__beast__static_string.insert.overload3 insert]``(    size_type index,    CharT const* s,    size_type count);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload3 more...]]``template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.insert.overload4 insert]``(    size_type index,    static_string< M, CharT, Traits > const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload4 more...]]``template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.insert.overload5 insert]``(    size_type index,    static_string< M, CharT, Traits > const& str,    size_type index_str,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload5 more...]]``iterator``[link beast.ref.boost__beast__static_string.insert.overload6 insert]``(    const_iterator pos,    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload6 more...]]``iterator``[link beast.ref.boost__beast__static_string.insert.overload7 insert]``(    const_iterator pos,    size_type count,    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload7 more...]]``template<    class InputIt>iterator``[link beast.ref.boost__beast__static_string.insert.overload8 insert]``(    const_iterator pos,    InputIt first,    InputIt last);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload8 more...]]``iterator``[link beast.ref.boost__beast__static_string.insert.overload9 insert]``(    const_iterator pos,    std::initializer_list< CharT > init);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload9 more...]]``static_string&``[link beast.ref.boost__beast__static_string.insert.overload10 insert]``(    size_type index,    string_view_type str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload10 more...]]``template<    class T>static_string&``[link beast.ref.boost__beast__static_string.insert.overload11 insert]``(    size_type index,    T const& t,    size_type index_str,    size_type count = npos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.insert.overload11 more...]]`````[section:overload1 static_string::insert (1 of 11 overloads)][heading Synopsis]```static_string&insert(    size_type index,    size_type count,    CharT ch);```[heading Description][endsect][section:overload2 static_string::insert (2 of 11 overloads)][heading Synopsis]```static_string&insert(    size_type index,    CharT const* s);```[heading Description][endsect][section:overload3 static_string::insert (3 of 11 overloads)][heading Synopsis]```static_string&insert(    size_type index,    CharT const* s,    size_type count);```[heading Description][endsect][section:overload4 static_string::insert (4 of 11 overloads)][heading Synopsis]```template<    std::size_t M>static_string&insert(    size_type index,    static_string< M, CharT, Traits > const& str);```[heading Description][endsect][section:overload5 static_string::insert (5 of 11 overloads)][heading Synopsis]```template<    std::size_t M>static_string&insert(    size_type index,    static_string< M, CharT, Traits > const& str,    size_type index_str,    size_type count = npos);```[heading Description][endsect][section:overload6 static_string::insert (6 of 11 overloads)][heading Synopsis]```iteratorinsert(    const_iterator pos,    CharT ch);```[heading Description][endsect][section:overload7 static_string::insert (7 of 11 overloads)][heading Synopsis]```iteratorinsert(    const_iterator pos,    size_type count,    CharT ch);```[heading Description][endsect][section:overload8 static_string::insert (8 of 11 overloads)][heading Synopsis]```template<    class InputIt>iteratorinsert(    const_iterator pos,    InputIt first,    InputIt last);```[heading Description][endsect][section:overload9 static_string::insert (9 of 11 overloads)][heading Synopsis]```iteratorinsert(    const_iterator pos,    std::initializer_list< CharT > init);```[heading Description][endsect][section:overload10 static_string::insert (10 of 11 overloads)][heading Synopsis]```static_string&insert(    size_type index,    string_view_type str);```[heading Description][endsect][section:overload11 static_string::insert (11 of 11 overloads)][heading Synopsis]```template<    class T>static_string&insert(    size_type index,    T const& t,    size_type index_str,    size_type count = npos);```[heading Description][endsect][endsect][section:iterator static_string::iterator][indexterm2 iterator..static_string][heading Synopsis]```using iterator = value_type*;```[heading Description][endsect][section:length static_string::length][indexterm2 length..static_string]
Returns the number of characters, excluding the null terminator. 
[heading Synopsis]```size_typelength() const;```[heading Description][endsect][section:max_size static_string::max_size][indexterm2 max_size..static_string]
Returns the maximum number of characters that can be stored, excluding the null terminator. 
[heading Synopsis]```size_type constexprmax_size() const;```[heading Description][endsect][section:max_size_n static_string::max_size_n][indexterm2 max_size_n..static_string]
Maximum size of the string excluding the null terminator. 
[heading Synopsis]```staticstd::size_t constexpr max_size_n = N;```[heading Description][endsect][section:npos static_string::npos][indexterm2 npos..static_string]
A special index. 
[heading Synopsis]```staticconstexpr size_type npos = size_type(-1);```[heading Description][endsect][section:operator_string_view_type static_string::operator string_view_type][indexterm2 operator string_view_type..static_string]
Convert a static string to a `string_view_type` 
[heading Synopsis]```operator string_view_type() const;```[heading Description][endsect][section:operator_plus__eq_ static_string::operator+=][indexterm2 operator+=..static_string]```template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.operator_plus__eq_.overload1 operator+=]``(    static_string< M, CharT, Traits > const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_plus__eq_.overload1 more...]]``static_string&``[link beast.ref.boost__beast__static_string.operator_plus__eq_.overload2 operator+=]``(    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_plus__eq_.overload2 more...]]``static_string&``[link beast.ref.boost__beast__static_string.operator_plus__eq_.overload3 operator+=]``(    CharT const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_plus__eq_.overload3 more...]]``static_string&``[link beast.ref.boost__beast__static_string.operator_plus__eq_.overload4 operator+=]``(    std::initializer_list< CharT > init);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_plus__eq_.overload4 more...]]``static_string&``[link beast.ref.boost__beast__static_string.operator_plus__eq_.overload5 operator+=]``(    string_view_type const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_plus__eq_.overload5 more...]]`````[section:overload1 static_string::operator+= (1 of 5 overloads)][heading Synopsis]```template<    std::size_t M>static_string&operator+=(    static_string< M, CharT, Traits > const& str);```[heading Description][endsect][section:overload2 static_string::operator+= (2 of 5 overloads)][heading Synopsis]```static_string&operator+=(    CharT ch);```[heading Description][endsect][section:overload3 static_string::operator+= (3 of 5 overloads)][heading Synopsis]```static_string&operator+=(    CharT const* s);```[heading Description][endsect][section:overload4 static_string::operator+= (4 of 5 overloads)][heading Synopsis]```static_string&operator+=(    std::initializer_list< CharT > init);```[heading Description][endsect][section:overload5 static_string::operator+= (5 of 5 overloads)][heading Synopsis]```static_string&operator+=(    string_view_type const& str);```[heading Description][endsect][endsect][section:operator_eq_ static_string::operator=][indexterm2 operator=..static_string]
Copy assignment. 
```static_string&``[link beast.ref.boost__beast__static_string.operator_eq_.overload1 operator=]``(    static_string const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_eq_.overload1 more...]]``template<    std::size_t M>static_string&``[link beast.ref.boost__beast__static_string.operator_eq_.overload2 operator=]``(    static_string< M, CharT, Traits > const& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_eq_.overload2 more...]]`````
Assign from null-terminated string. 
```static_string&``[link beast.ref.boost__beast__static_string.operator_eq_.overload3 operator=]``(    CharT const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_eq_.overload3 more...]]`````
Assign from single character. 
```static_string&``[link beast.ref.boost__beast__static_string.operator_eq_.overload4 operator=]``(    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_eq_.overload4 more...]]`````
Assign from initializer list. 
```static_string&``[link beast.ref.boost__beast__static_string.operator_eq_.overload5 operator=]``(    std::initializer_list< CharT > init);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_eq_.overload5 more...]]`````
Assign from `string_view_type`. 
```static_string&``[link beast.ref.boost__beast__static_string.operator_eq_.overload6 operator=]``(    string_view_type sv);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_eq_.overload6 more...]]`````[section:overload1 static_string::operator= (1 of 6 overloads)]
Copy assignment. 
[heading Synopsis]```static_string&operator=(    static_string const& str);```[heading Description][endsect][section:overload2 static_string::operator= (2 of 6 overloads)]
Copy assignment. 
[heading Synopsis]```template<    std::size_t M>static_string&operator=(    static_string< M, CharT, Traits > const& str);```[heading Description][endsect][section:overload3 static_string::operator= (3 of 6 overloads)]
Assign from null-terminated string. 
[heading Synopsis]```static_string&operator=(    CharT const* s);```[heading Description][endsect][section:overload4 static_string::operator= (4 of 6 overloads)]
Assign from single character. 
[heading Synopsis]```static_string&operator=(    CharT ch);```[heading Description][endsect][section:overload5 static_string::operator= (5 of 6 overloads)]
Assign from initializer list. 
[heading Synopsis]```static_string&operator=(    std::initializer_list< CharT > init);```[heading Description][endsect][section:overload6 static_string::operator= (6 of 6 overloads)]
Assign from `string_view_type`. 
[heading Synopsis]```static_string&operator=(    string_view_type sv);```[heading Description][endsect][endsect][section:operator_lb__rb_ static_string::operator\[\]][indexterm2 operator\[\]..static_string]
Access specified character. 
```reference``[link beast.ref.boost__beast__static_string.operator_lb__rb_.overload1 operator[]]``(    size_type pos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_lb__rb_.overload1 more...]]``const_reference``[link beast.ref.boost__beast__static_string.operator_lb__rb_.overload2 operator[]]``(    size_type pos) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.operator_lb__rb_.overload2 more...]]`````[section:overload1 static_string::operator\[\] (1 of 2 overloads)]
Access specified character. 
[heading Synopsis]```referenceoperator[](    size_type pos);```[heading Description][endsect][section:overload2 static_string::operator\[\] (2 of 2 overloads)]
Access specified character. 
[heading Synopsis]```const_referenceoperator[](    size_type pos) const;```[heading Description][endsect][endsect][section:pointer static_string::pointer][indexterm2 pointer..static_string][heading Synopsis]```using pointer = value_type*;```[heading Description][endsect][section:pop_back static_string::pop_back][indexterm2 pop_back..static_string][heading Synopsis]```voidpop_back();```[heading Description][endsect][section:push_back static_string::push_back][indexterm2 push_back..static_string][heading Synopsis]```voidpush_back(    CharT ch);```[heading Description][endsect][section:rbegin static_string::rbegin][indexterm2 rbegin..static_string]
Returns a reverse iterator to the beginning. 
```reverse_iterator``[link beast.ref.boost__beast__static_string.rbegin.overload1 rbegin]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.rbegin.overload1 more...]]``const_reverse_iterator``[link beast.ref.boost__beast__static_string.rbegin.overload2 rbegin]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.rbegin.overload2 more...]]`````[section:overload1 static_string::rbegin (1 of 2 overloads)]
Returns a reverse iterator to the beginning. 
[heading Synopsis]```reverse_iteratorrbegin();```[heading Description][endsect][section:overload2 static_string::rbegin (2 of 2 overloads)]
Returns a reverse iterator to the beginning. 
[heading Synopsis]```const_reverse_iteratorrbegin() const;```[heading Description][endsect][endsect][section:reference static_string::reference][indexterm2 reference..static_string][heading Synopsis]```using reference = value_type&;```[heading Description][endsect][section:rend static_string::rend][indexterm2 rend..static_string]
Returns a reverse iterator to the end. 
```reverse_iterator``[link beast.ref.boost__beast__static_string.rend.overload1 rend]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.rend.overload1 more...]]``const_reverse_iterator``[link beast.ref.boost__beast__static_string.rend.overload2 rend]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.rend.overload2 more...]]`````[section:overload1 static_string::rend (1 of 2 overloads)]
Returns a reverse iterator to the end. 
[heading Synopsis]```reverse_iteratorrend();```[heading Description][endsect][section:overload2 static_string::rend (2 of 2 overloads)]
Returns a reverse iterator to the end. 
[heading Synopsis]```const_reverse_iteratorrend() const;```[heading Description][endsect][endsect][section:reserve static_string::reserve][indexterm2 reserve..static_string]
Reserves storage. 
[heading Synopsis]```voidreserve(    std::size_t n);```[heading Description]
This actually just throws an exception if `n > N`, otherwise does nothing since the storage is fixed. 
[endsect][section:resize static_string::resize][indexterm2 resize..static_string]
Changes the number of characters stored. 
```void``[link beast.ref.boost__beast__static_string.resize.overload1 resize]``(    std::size_t n);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.resize.overload1 more...]]``void``[link beast.ref.boost__beast__static_string.resize.overload2 resize]``(    std::size_t n,    CharT c);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.resize.overload2 more...]]`````[section:overload1 static_string::resize (1 of 2 overloads)]
Changes the number of characters stored. 
[heading Synopsis]```voidresize(    std::size_t n);```[heading Description]
If the resulting string is larger, the new characters are uninitialized. 
[endsect][section:overload2 static_string::resize (2 of 2 overloads)]
Changes the number of characters stored. 
[heading Synopsis]```voidresize(    std::size_t n,    CharT c);```[heading Description]
If the resulting string is larger, the new characters are initialized to the value of `c`. 
[endsect][endsect][section:reverse_iterator static_string::reverse_iterator][indexterm2 reverse_iterator..static_string][heading Synopsis]```using reverse_iterator = std::reverse_iterator< iterator >;```[heading Description][endsect][section:shrink_to_fit static_string::shrink_to_fit][indexterm2 shrink_to_fit..static_string]
Reduces memory usage by freeing unused memory. 
[heading Synopsis]```voidshrink_to_fit();```[heading Description]
This actually does nothing, since the storage is fixed. 
[endsect][section:size static_string::size][indexterm2 size..static_string]
Returns the number of characters, excluding the null terminator. 
[heading Synopsis]```size_typesize() const;```[heading Description][endsect][section:size_type static_string::size_type][indexterm2 size_type..static_string][heading Synopsis]```using size_type = std::size_t;```[heading Description][endsect][section:static_string static_string::static_string][indexterm2 static_string..static_string]
Default constructor (empty string). 
`````[link beast.ref.boost__beast__static_string.static_string.overload1 static_string]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload1 more...]]`````
Construct with count copies of character `ch`. 
`````[link beast.ref.boost__beast__static_string.static_string.overload2 static_string]``(    size_type count,    CharT ch);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload2 more...]]`````
Construct with a substring (pos, other.size()) of `other`. 
```template<    std::size_t M>``[link beast.ref.boost__beast__static_string.static_string.overload3 static_string]``(    static_string< M, CharT, Traits > const& other,    size_type pos);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload3 more...]]`````
Construct with a substring (pos, count) of `other`. 
```template<    std::size_t M>``[link beast.ref.boost__beast__static_string.static_string.overload4 static_string]``(    static_string< M, CharT, Traits > const& other,    size_type pos,    size_type count);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload4 more...]]`````
Construct with the first `count` characters of `s`, including nulls. 
`````[link beast.ref.boost__beast__static_string.static_string.overload5 static_string]``(    CharT const* s,    size_type count);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload5 more...]]`````
Construct from a null terminated string. 
`````[link beast.ref.boost__beast__static_string.static_string.overload6 static_string]``(    CharT const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload6 more...]]`````
Construct from a range of characters. 
```template<    class InputIt>``[link beast.ref.boost__beast__static_string.static_string.overload7 static_string]``(    InputIt first,    InputIt last);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload7 more...]]`````
Copy constructor. 
`````[link beast.ref.boost__beast__static_string.static_string.overload8 static_string]``(    static_string const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload8 more...]]``template<    std::size_t M>``[link beast.ref.boost__beast__static_string.static_string.overload9 static_string]``(    static_string< M, CharT, Traits > const& other);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload9 more...]]`````
Construct from an initializer list. 
`````[link beast.ref.boost__beast__static_string.static_string.overload10 static_string]``(    std::initializer_list< CharT > init);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload10 more...]]`````
Construct from a `string_view` 
```explicit``[link beast.ref.boost__beast__static_string.static_string.overload11 static_string]``(    string_view_type sv);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload11 more...]]`````
Construct from any object convertible to `string_view_type`. 
```template<    class T>``[link beast.ref.boost__beast__static_string.static_string.overload12 static_string]``(    T const& t,    size_type pos,    size_type n);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.static_string.overload12 more...]]`````[section:overload1 static_string::static_string (1 of 12 overloads)]
Default constructor (empty string). 
[heading Synopsis]```static_string();```[heading Description][endsect][section:overload2 static_string::static_string (2 of 12 overloads)]
Construct with count copies of character `ch`. 
[heading Synopsis]```static_string(    size_type count,    CharT ch);```[heading Description]
The behavior is undefined if `count >= npos` 
[endsect][section:overload3 static_string::static_string (3 of 12 overloads)]
Construct with a substring (pos, other.size()) of `other`. 
[heading Synopsis]```template<    std::size_t M>static_string(    static_string< M, CharT, Traits > const& other,    size_type pos);```[heading Description][endsect][section:overload4 static_string::static_string (4 of 12 overloads)]
Construct with a substring (pos, count) of `other`. 
[heading Synopsis]```template<    std::size_t M>static_string(    static_string< M, CharT, Traits > const& other,    size_type pos,    size_type count);```[heading Description][endsect][section:overload5 static_string::static_string (5 of 12 overloads)]
Construct with the first `count` characters of `s`, including nulls. 
[heading Synopsis]```static_string(    CharT const* s,    size_type count);```[heading Description][endsect][section:overload6 static_string::static_string (6 of 12 overloads)]
Construct from a null terminated string. 
[heading Synopsis]```static_string(    CharT const* s);```[heading Description][endsect][section:overload7 static_string::static_string (7 of 12 overloads)]
Construct from a range of characters. 
[heading Synopsis]```template<    class InputIt>static_string(    InputIt first,    InputIt last);```[heading Description][endsect][section:overload8 static_string::static_string (8 of 12 overloads)]
Copy constructor. 
[heading Synopsis]```static_string(    static_string const& other);```[heading Description][endsect][section:overload9 static_string::static_string (9 of 12 overloads)]
Copy constructor. 
[heading Synopsis]```template<    std::size_t M>static_string(    static_string< M, CharT, Traits > const& other);```[heading Description][endsect][section:overload10 static_string::static_string (10 of 12 overloads)]
Construct from an initializer list. 
[heading Synopsis]```static_string(    std::initializer_list< CharT > init);```[heading Description][endsect][section:overload11 static_string::static_string (11 of 12 overloads)]
Construct from a `string_view` 
[heading Synopsis]```static_string(    string_view_type sv);```[heading Description][endsect][section:overload12 static_string::static_string (12 of 12 overloads)]
Construct from any object convertible to `string_view_type`. 
[heading Synopsis]```template<    class T>static_string(    T const& t,    size_type pos,    size_type n);```[heading Description]
The range (pos, n) is extracted from the value obtained by converting `t` to `string_view_type`, and used to construct the string. 
[endsect][endsect][section:string_view_type static_string::string_view_type][indexterm2 string_view_type..static_string]
The type of `string_view` returned by the interface. 
[heading Synopsis]```using string_view_type = basic_string_view< CharT, Traits >;```[heading Description][endsect][section:substr static_string::substr][indexterm2 substr..static_string][heading Synopsis]```string_view_typesubstr(    size_type pos = 0,    size_type count = npos) const;```[heading Description][endsect][section:swap static_string::swap][indexterm2 swap..static_string]
Exchange the contents of this string with another. 
```void``[link beast.ref.boost__beast__static_string.swap.overload1 swap]``(    static_string& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.swap.overload1 more...]]``template<    std::size_t M>void``[link beast.ref.boost__beast__static_string.swap.overload2 swap]``(    static_string< M, CharT, Traits >& str);  ``[''''&raquo;''' [link beast.ref.boost__beast__static_string.swap.overload2 more...]]`````[section:overload1 static_string::swap (1 of 2 overloads)]
Exchange the contents of this string with another. 
[heading Synopsis]```voidswap(    static_string& str);```[heading Description][endsect][section:overload2 static_string::swap (2 of 2 overloads)]
Exchange the contents of this string with another. 
[heading Synopsis]```template<    std::size_t M>voidswap(    static_string< M, CharT, Traits >& str);```[heading Description][endsect][endsect][section:traits_type static_string::traits_type][indexterm2 traits_type..static_string][heading Synopsis]```using traits_type = Traits;```[heading Description][endsect][section:value_type static_string::value_type][indexterm2 value_type..static_string][heading Synopsis]```using value_type = typename Traits::char_type;```[heading Description][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__string_param string_param]
A function parameter which efficiently converts to string. 
[heading Synopsis]Defined in header [include_file boost/beast/core/string_param.hpp]```class string_param```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__string_param.operator_string_view_const [*operator string_view const]]]    [      Implicit conversion to string_view.     ]  ]  [    [[link beast.ref.boost__beast__string_param.operator_eq_ [*operator=]]]    [      Copy assignment (disallowed)     ]  ]  [    [[link beast.ref.boost__beast__string_param.str [*str]]]    [      Returns the contained string.     ]  ]  [    [[link beast.ref.boost__beast__string_param.string_param [*string_param]]]    [      Copy constructor (disallowed)       Constructor.     ]  ]][heading Description]
This is used as a function parameter type to allow callers notational convenience: objects other than strings may be passed in contexts where a string is expected. The conversion to string is made using `operator<<` to a non-dynamically allocated static buffer if possible, else to a `std::string` on overflow.

To use it, modify your function signature to accept `string_param` and then extract the string inside the function: 

  void print(string_param s)
  {
      std::cout << s.str();
  }



[section:operator_string_view_const string_param::operator string_view const][indexterm2 operator string_view const..string_param]
Implicit conversion to [link beast.ref.boost__beast__string_view `string_view`]. 
[heading Synopsis]```operator string_view const() const;```[heading Description][endsect][section:operator_eq_ string_param::operator=][indexterm2 operator=..string_param]
Copy assignment (disallowed) 
[heading Synopsis]```string_param&operator=(    string_param const&);```[heading Description][endsect][section:str string_param::str][indexterm2 str..string_param]
Returns the contained string. 
[heading Synopsis]```string_viewstr() const;```[heading Description][endsect][section:string_param string_param::string_param][indexterm2 string_param..string_param]
Copy constructor (disallowed) 
`````[link beast.ref.boost__beast__string_param.string_param.overload1 string_param]``(    string_param const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__string_param.string_param.overload1 more...]]`````
Constructor. 
```template<    class... Args>``[link beast.ref.boost__beast__string_param.string_param.overload2 string_param]``(    Args const&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__string_param.string_param.overload2 more...]]`````[section:overload1 string_param::string_param (1 of 2 overloads)]
Copy constructor (disallowed) 
[heading Synopsis]```string_param(    string_param const&);```[heading Description][endsect][section:overload2 string_param::string_param (2 of 2 overloads)]
Constructor. 
[heading Synopsis]```template<    class... Args>string_param(    Args const&... args);```[heading Description]
This function constructs a string as if by concatenating the result of streaming each argument in order into an output stream. It is used as a notational convenience at call sites which expect a parameter with the semantics of a [link beast.ref.boost__beast__string_view `string_view`].

The implementation uses a small, internal static buffer to avoid memory allocations especially for the case where the list of arguments to be converted consists of a single integral type.

[heading Parameters][table [[Name][Description]]  [[`args`][    One or more arguments to convert   ]]]

[endsect][endsect]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__string_view string_view][indexterm1 string_view]
The type of string view used by the library. 
[heading Synopsis]Defined in header [include_file boost/beast/core/string.hpp]```using string_view = boost::string_view;```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__swap swap][indexterm1 swap]```template<    std::size_t N,    class CharT,    class Traits>void``[link beast.ref.boost__beast__swap.overload1 swap]``(    static_string< N, CharT, Traits >& lhs,    static_string< N, CharT, Traits >& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__swap.overload1 more...]]``template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>void``[link beast.ref.boost__beast__swap.overload2 swap]``(    static_string< N, CharT, Traits >& lhs,    static_string< M, CharT, Traits >& rhs);  ``[''''&raquo;''' [link beast.ref.boost__beast__swap.overload2 more...]]`````[section:overload1 swap (1 of 2 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    class CharT,    class Traits>voidswap(    static_string< N, CharT, Traits >& lhs,    static_string< N, CharT, Traits >& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:overload2 swap (2 of 2 overloads)][heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    std::size_t N,    std::size_t M,    class CharT,    class Traits>voidswap(    static_string< N, CharT, Traits >& lhs,    static_string< M, CharT, Traits >& rhs);```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][endsect][section:boost__beast__system_category system_category][indexterm1 system_category]
A function to return the system error category used by the library. 
[heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```error_category const&system_category();```[heading Description]Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__system_error system_error][indexterm1 system_error]
The type of system error thrown by the library. 
[heading Synopsis]Defined in header [include_file boost/beast/core/error.hpp]```using system_error = boost::system::system_error;```Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__to_static_string to_static_string][indexterm1 to_static_string]
Returns a static string representing an integer as a decimal. 
[heading Synopsis]Defined in header [include_file boost/beast/core/static_string.hpp]```template<    class Integer>static_string< detail::max_digits(sizeof(Integer))>to_static_string(    Integer x);```[heading Description]
[heading Parameters][table [[Name][Description]]  [[`x`][    The signed or unsigned integer to convert. This must be an integral type.  ]]]
[heading Return Value]
A [link beast.ref.boost__beast__static_string `static_string`] with an implementation defined maximum size large enough to hold the longest possible decimal representation of any integer of the given type. 


Convenience header [include_file boost/beast/core.hpp][endsect][section:boost__beast__websocket__async_teardown websocket::async_teardown][indexterm1 websocket::async_teardown]
Start tearing down a `boost::asio::ssl::stream`. 
```template<    class ``[link beast.concepts.streams.AsyncStream [*AsyncStream]]``,    class TeardownHandler>void``[link beast.ref.boost__beast__websocket__async_teardown.overload1 async_teardown]``(    role_type role,    boost::asio::ssl::stream< AsyncStream >& stream,    TeardownHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__async_teardown.overload1 more...]]`````
Start tearing down a connection. 
```template<    class Socket,    class TeardownHandler>void``[link beast.ref.boost__beast__websocket__async_teardown.overload2 async_teardown]``(    role_type role,    Socket& socket,    TeardownHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__async_teardown.overload2 more...]]`````
Start tearing down a `boost::asio::ip::tcp::socket`. 
```template<    class TeardownHandler>void``[link beast.ref.boost__beast__websocket__async_teardown.overload3 async_teardown]``(    role_type role,    boost::asio::ip::tcp::socket& socket,    TeardownHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__async_teardown.overload3 more...]]`````[section:overload1 websocket::async_teardown (1 of 3 overloads)]
Start tearing down a `boost::asio::ssl::stream`. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/ssl.hpp]```template<    class ``[link beast.concepts.streams.AsyncStream [*AsyncStream]]``,    class TeardownHandler>voidasync_teardown(    role_type role,    boost::asio::ssl::stream< AsyncStream >& stream,    TeardownHandler&& handler);```[heading Description]
This begins tearing down a connection asynchronously. The implementation will call the overload of this function based on the `Stream` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`, callers are responsible for providing a suitable overload of this function.

[heading Parameters][table [[Name][Description]]  [[`role`][    The role of the local endpoint  ]]  [[`stream`][    The stream to tear down.  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& error // result of operation
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using boost::asio::io\_context::post().   ]]]

Convenience header [include_file boost/beast/websocket.hpp][endsect][section:overload2 websocket::async_teardown (2 of 3 overloads)]
Start tearing down a connection. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/teardown.hpp]```template<    class Socket,    class TeardownHandler>voidasync_teardown(    role_type role,    Socket& socket,    TeardownHandler&& handler);```[heading Description]
This begins tearing down a connection asynchronously. The implementation will call the overload of this function based on the `Socket` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`, callers are responsible for providing a suitable overload of this function.

[heading Parameters][table [[Name][Description]]  [[`role`][    The role of the local endpoint  ]]  [[`socket`][    The socket to tear down.  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& error // result of operation
  );
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using boost::asio::io\_context::post().   ]]]

Convenience header [include_file boost/beast/websocket.hpp][endsect][section:overload3 websocket::async_teardown (3 of 3 overloads)]
Start tearing down a `boost::asio::ip::tcp::socket`. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/teardown.hpp]```template<    class TeardownHandler>voidasync_teardown(    role_type role,    boost::asio::ip::tcp::socket& socket,    TeardownHandler&& handler);```[heading Description]
This begins tearing down a connection asynchronously. The implementation will call the overload of this function based on the `Stream` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`, callers are responsible for providing a suitable overload of this function.

[heading Parameters][table [[Name][Description]]  [[`role`][    The role of the local endpoint  ]]  [[`socket`][    The socket to tear down.  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& error // result of operation
  );
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using boost::asio::io\_context::post().   ]]]

Convenience header [include_file boost/beast/websocket.hpp][endsect][endsect][section:boost__beast__websocket__close_code websocket::close_code][indexterm1 websocket::close_code]
Close status codes. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/rfc6455.hpp]```enum close_code```[indexterm2 normal..websocket::close_code][indexterm2 going_away..websocket::close_code][indexterm2 protocol_error..websocket::close_code][indexterm2 unknown_data..websocket::close_code][indexterm2 bad_payload..websocket::close_code][indexterm2 policy_error..websocket::close_code][indexterm2 too_big..websocket::close_code][indexterm2 needs_extension..websocket::close_code][indexterm2 internal_error..websocket::close_code][indexterm2 service_restart..websocket::close_code][indexterm2 try_again_later..websocket::close_code][indexterm2 none..websocket::close_code][indexterm2 reserved1..websocket::close_code][indexterm2 no_status..websocket::close_code][indexterm2 abnormal..websocket::close_code][indexterm2 reserved2..websocket::close_code][indexterm2 reserved3..websocket::close_code][heading Values][table [[Name][Description]]  [[[^normal]][Normal closure; the connection successfully completed whatever purpose for which it was created. ]]  [[[^going_away]][The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection. ]]  [[[^protocol_error]][The endpoint is terminating the connection due to a protocol error. ]]  [[[^unknown_data]][The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data). ]]  [[[^bad_payload]][The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message). ]]  [[[^policy_error]][The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable. ]]  [[[^too_big]][The endpoint is terminating the connection because a data frame was received that is too large. ]]  [[[^needs_extension]][The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't. ]]  [[[^internal_error]][The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request. ]]  [[[^service_restart]][The server is terminating the connection because it is restarting. ]]  [[[^try_again_later]][The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients. ]]  [[[^none]][Used internally to mean "no error". This code is reserved and may not be sent. ]]  [[[^reserved1]][Reserved for future use by the WebSocket standard. This code is reserved and may not be sent. ]]  [[[^no_status]][No status code was provided even though one was expected. This code is reserved and may not be sent. ]]  [[[^abnormal]][Connection was closed without receiving a close frame. This code is reserved and may not be sent. ]]  [[[^reserved2]][Reserved for future use by the WebSocket standard. This code is reserved and may not be sent. ]]  [[[^reserved3]][Reserved for future use by the WebSocket standard. This code is reserved and may not be sent. ]]][heading Description]
These codes accompany close frames.

[heading See Also]
[@https://tools.ietf.org/html/rfc6455#section-7.4.1 RFC 6455 7.4.1 Defined Status Codes] 


Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__close_reason websocket::close_reason]
Description of the close reason. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/rfc6455.hpp]```struct close_reason```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__close_reason.close_reason [*close_reason]]]    [      Default constructor.       Construct from a code.       Construct from a reason string. code is close_code::normal.       Construct from a reason string literal. code is close_code::normal.       Construct from a close code and reason string.     ]  ]  [    [[link beast.ref.boost__beast__websocket__close_reason.operator_bool [*operator bool]]]    [      Returns true if a code was specified.     ]  ]][heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__close_reason.code [*code]]]    [      The close code.     ]  ]  [    [[link beast.ref.boost__beast__websocket__close_reason.reason [*reason]]]    [      The optional utf8-encoded reason string.     ]  ]][heading Description]
This object stores the close code (if any) and the optional utf-8 encoded implementation defined reason string. 
[section:close_reason websocket::close_reason::close_reason][indexterm2 close_reason..websocket::close_reason]
Default constructor. 
`````[link beast.ref.boost__beast__websocket__close_reason.close_reason.overload1 close_reason]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__close_reason.close_reason.overload1 more...]]`````
Construct from a code. 
`````[link beast.ref.boost__beast__websocket__close_reason.close_reason.overload2 close_reason]``(    std::uint16_t code_);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__close_reason.close_reason.overload2 more...]]`````
Construct from a reason string. code is close\_code::normal. 
`````[link beast.ref.boost__beast__websocket__close_reason.close_reason.overload3 close_reason]``(    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__close_reason.close_reason.overload3 more...]]`````
Construct from a reason string literal. code is close\_code::normal. 
`````[link beast.ref.boost__beast__websocket__close_reason.close_reason.overload4 close_reason]``(    char const* s);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__close_reason.close_reason.overload4 more...]]`````
Construct from a close code and reason string. 
`````[link beast.ref.boost__beast__websocket__close_reason.close_reason.overload5 close_reason]``(    close_code code_,    string_view s);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__close_reason.close_reason.overload5 more...]]`````[section:overload1 websocket::close_reason::close_reason (1 of 5 overloads)]
Default constructor. 
[heading Synopsis]```close_reason();```[heading Description]
The code will be none. Default constructed objects will explicitly convert to bool as `false`. 
[endsect][section:overload2 websocket::close_reason::close_reason (2 of 5 overloads)]
Construct from a code. 
[heading Synopsis]```close_reason(    std::uint16_t code_);```[heading Description][endsect][section:overload3 websocket::close_reason::close_reason (3 of 5 overloads)]
Construct from a reason string. code is close\_code::normal. 
[heading Synopsis]```close_reason(    string_view s);```[heading Description][endsect][section:overload4 websocket::close_reason::close_reason (4 of 5 overloads)]
Construct from a reason string literal. code is close\_code::normal. 
[heading Synopsis]```close_reason(    char const* s);```[heading Description][endsect][section:overload5 websocket::close_reason::close_reason (5 of 5 overloads)]
Construct from a close code and reason string. 
[heading Synopsis]```close_reason(    close_code code_,    string_view s);```[heading Description][endsect][endsect][section:code websocket::close_reason::code][indexterm2 code..websocket::close_reason]
The close code. 
[heading Synopsis]```std::uint16_t code = close_code::none;```[heading Description][endsect][section:operator_bool websocket::close_reason::operator bool][indexterm2 operator bool..websocket::close_reason]
Returns `true` if a code was specified. 
[heading Synopsis]```operator bool() const;```[heading Description][endsect][section:reason websocket::close_reason::reason][indexterm2 reason..websocket::close_reason]
The optional utf8-encoded reason string. 
[heading Synopsis]```reason_string reason;```[heading Description][endsect]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__error websocket::error][indexterm1 websocket::error]
Error codes returned from [link beast.ref.boost__beast__websocket__stream `websocket::stream`] operations. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/error.hpp]```enum error```[indexterm2 closed..websocket::error][indexterm2 failed..websocket::error][indexterm2 handshake_failed..websocket::error][indexterm2 buffer_overflow..websocket::error][indexterm2 partial_deflate_block..websocket::error][heading Values][table [[Name][Description]]  [[[^closed]][Both sides performed a WebSocket close. ]]  [[[^failed]][WebSocket connection failed, protocol violation. ]]  [[[^handshake_failed]][Upgrade handshake failed. ]]  [[[^buffer_overflow]][buffer overflow ]]  [[[^partial_deflate_block]][partial deflate block ]]][heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__frame_type websocket::frame_type][indexterm1 websocket::frame_type]
The type of received control frame. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```enum frame_type```[indexterm2 close..websocket::frame_type][indexterm2 ping..websocket::frame_type][indexterm2 pong..websocket::frame_type][heading Values][table [[Name][Description]]  [[[^close]][A close frame was received. ]]  [[[^ping]][A ping frame was received. ]]  [[[^pong]][A pong frame was received. ]]][heading Description]
Values of this type are passed to the control frame callback set using [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`]. 
Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__is_upgrade websocket::is_upgrade][indexterm1 websocket::is_upgrade]
Returns `true` if the specified HTTP request is a WebSocket Upgrade. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/rfc6455.hpp]```template<    class Allocator>boolis_upgrade(    beast::http::header< true, http::basic_fields< Allocator >> const& req);```[heading Description]
This function returns `true` when the passed HTTP Request indicates a WebSocket Upgrade. It does not validate the contents of the fields: it just trivially accepts requests which could only possibly be a valid or invalid WebSocket Upgrade message.

Callers who wish to manually read HTTP requests in their server implementation can use this function to determine if the request should be routed to an instance of [link beast.ref.boost__beast__websocket__stream `websocket::stream`].

[heading Example]


  void handle_connection(boost::asio::ip::tcp::socket& sock)
  {
      boost::beast::flat_buffer buffer;
      boost::beast::http::request<boost::beast::http::string_body> req;
      boost::beast::http::read(sock, buffer, req);
      if(boost::beast::websocket::is_upgrade(req))
      {
          boost::beast::websocket::stream<decltype(sock)> ws{std::move(sock)};
          ws.accept(req);
      }
  }




[heading Parameters][table [[Name][Description]]  [[`req`][    The HTTP Request object to check.  ]]]
[heading Return Value]
`true` if the request is a WebSocket Upgrade. 


Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__permessage_deflate websocket::permessage_deflate]
permessage-deflate extension options. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/option.hpp]```struct permessage_deflate```[heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.client_enable [*client_enable]]]    [      true to offer the extension in the client role     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.client_max_window_bits [*client_max_window_bits]]]    [      Maximum client window bits to offer.     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.client_no_context_takeover [*client_no_context_takeover]]]    [      true if client_no_context_takeover desired     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.compLevel [*compLevel]]]    [      Deflate compression level 0..9.     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.memLevel [*memLevel]]]    [      Deflate memory level, 1..9.     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.server_enable [*server_enable]]]    [      true to offer the extension in the server role     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.server_max_window_bits [*server_max_window_bits]]]    [      Maximum server window bits to offer.     ]  ]  [    [[link beast.ref.boost__beast__websocket__permessage_deflate.server_no_context_takeover [*server_no_context_takeover]]]    [      true if server_no_context_takeover desired     ]  ]][heading Description]
These settings control the permessage-deflate extension, which allows messages to be compressed.

[heading Remarks]
Objects of this type are used with [link beast.ref.boost__beast__websocket__stream.set_option `websocket::stream::set_option`]. 


[section:client_enable websocket::permessage_deflate::client_enable][indexterm2 client_enable..websocket::permessage_deflate]
`true` to offer the extension in the client role 
[heading Synopsis]```bool client_enable = false;```[heading Description][endsect][section:client_max_window_bits websocket::permessage_deflate::client_max_window_bits][indexterm2 client_max_window_bits..websocket::permessage_deflate]
Maximum client window bits to offer. 
[heading Synopsis]```int client_max_window_bits = 15;```[heading Description]
[heading Remarks]
Due to a bug in ZLib, this value must be greater than 8. 


[endsect][section:client_no_context_takeover websocket::permessage_deflate::client_no_context_takeover][indexterm2 client_no_context_takeover..websocket::permessage_deflate]
`true` if client\_no\_context\_takeover desired 
[heading Synopsis]```bool client_no_context_takeover = false;```[heading Description][endsect][section:compLevel websocket::permessage_deflate::compLevel][indexterm2 compLevel..websocket::permessage_deflate]
Deflate compression level 0..9. 
[heading Synopsis]```int compLevel = 8;```[heading Description][endsect][section:memLevel websocket::permessage_deflate::memLevel][indexterm2 memLevel..websocket::permessage_deflate]
Deflate memory level, 1..9. 
[heading Synopsis]```int memLevel = 4;```[heading Description][endsect][section:server_enable websocket::permessage_deflate::server_enable][indexterm2 server_enable..websocket::permessage_deflate]
`true` to offer the extension in the server role 
[heading Synopsis]```bool server_enable = false;```[heading Description][endsect][section:server_max_window_bits websocket::permessage_deflate::server_max_window_bits][indexterm2 server_max_window_bits..websocket::permessage_deflate]
Maximum server window bits to offer. 
[heading Synopsis]```int server_max_window_bits = 15;```[heading Description]
[heading Remarks]
Due to a bug in ZLib, this value must be greater than 8. 


[endsect][section:server_no_context_takeover websocket::permessage_deflate::server_no_context_takeover][indexterm2 server_no_context_takeover..websocket::permessage_deflate]
`true` if server\_no\_context\_takeover desired 
[heading Synopsis]```bool server_no_context_takeover = false;```[heading Description][endsect]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__ping_data websocket::ping_data][indexterm1 websocket::ping_data]
The type representing the payload of ping and pong messages. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/rfc6455.hpp]```using ping_data = static_string< 125, char >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.const_iterator [*const_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_pointer [*const_pointer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_reference [*const_reference]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_reverse_iterator [*const_reverse_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.difference_type [*difference_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.iterator [*iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.pointer [*pointer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.reference [*reference]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.reverse_iterator [*reverse_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.size_type [*size_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.string_view_type [*string_view_type]]]    [      The type of string_view returned by the interface.     ]  ]  [    [[link beast.ref.boost__beast__static_string.traits_type [*traits_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.value_type [*value_type]]]    [          ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.append [*append]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.assign [*assign]]]    [      Assign count copies of ch.       Assign from another static_string       Assign count characterss starting at npos from other.       Assign the first count characters of s, including nulls.       Assign a null terminated string.       Assign from an iterator range of characters.       Assign from any object convertible to string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.at [*at]]]    [      Access specified character with bounds checking.     ]  ]  [    [[link beast.ref.boost__beast__static_string.back [*back]]]    [      Accesses the last character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.begin [*begin]]]    [      Returns an iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.c_str [*c_str]]]    [      Returns a non-modifiable standard C character array version of the string.     ]  ]  [    [[link beast.ref.boost__beast__static_string.capacity [*capacity]]]    [      Returns the number of characters that can be held in currently allocated storage.     ]  ]  [    [[link beast.ref.boost__beast__static_string.cbegin [*cbegin]]]    [      Returns an iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.cend [*cend]]]    [      Returns an iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.clear [*clear]]]    [      Clears the contents.     ]  ]  [    [[link beast.ref.boost__beast__static_string.compare [*compare]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.copy [*copy]]]    [      Copy a substring (pos, pos+count) to character string pointed to by dest.     ]  ]  [    [[link beast.ref.boost__beast__static_string.crbegin [*crbegin]]]    [      Returns a reverse iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.crend [*crend]]]    [      Returns a reverse iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.data [*data]]]    [      Returns a pointer to the first character of a string.     ]  ]  [    [[link beast.ref.boost__beast__static_string.empty [*empty]]]    [      Returns true if the string is empty.     ]  ]  [    [[link beast.ref.boost__beast__static_string.end [*end]]]    [      Returns an iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.erase [*erase]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.front [*front]]]    [      Accesses the first character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.insert [*insert]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.length [*length]]]    [      Returns the number of characters, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.max_size [*max_size]]]    [      Returns the maximum number of characters that can be stored, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_string_view_type [*operator string_view_type]]]    [      Convert a static string to a string_view_type     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_plus__eq_ [*operator+=]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_eq_ [*operator=]]]    [      Copy assignment.       Assign from null-terminated string.       Assign from single character.       Assign from initializer list.       Assign from string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_lb__rb_ [*operator\[\]]]]    [      Access specified character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.pop_back [*pop_back]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.push_back [*push_back]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.rbegin [*rbegin]]]    [      Returns a reverse iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.rend [*rend]]]    [      Returns a reverse iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.reserve [*reserve]]]    [      Reserves storage.     ]  ]  [    [[link beast.ref.boost__beast__static_string.resize [*resize]]]    [      Changes the number of characters stored.     ]  ]  [    [[link beast.ref.boost__beast__static_string.shrink_to_fit [*shrink_to_fit]]]    [      Reduces memory usage by freeing unused memory.     ]  ]  [    [[link beast.ref.boost__beast__static_string.size [*size]]]    [      Returns the number of characters, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.static_string [*static_string]]]    [      Default constructor (empty string).       Construct with count copies of character ch.       Construct with a substring (pos, other.size()) of other.       Construct with a substring (pos, count) of other.       Construct with the first count characters of s, including nulls.       Construct from a null terminated string.       Construct from a range of characters.       Copy constructor.       Construct from an initializer list.       Construct from a string_view       Construct from any object convertible to string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.substr [*substr]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.swap [*swap]]]    [      Exchange the contents of this string with another.     ]  ]][heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.max_size_n [*max_size_n]]]    [      Maximum size of the string excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.npos [*npos]]]    [      A special index.     ]  ]]
These objects behave like `std::string` except that the storage is not dynamically allocated but rather fixed in size.

These strings offer performance advantages when a protocol imposes a natural small upper limit on the size of a value.

[heading Remarks]
The stored string is always null-terminated.

[heading See Also]
[link beast.ref.boost__beast__to_static_string `to_static_string`] 


Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__reason_string websocket::reason_string][indexterm1 websocket::reason_string]
The type representing the reason string in a close frame. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/rfc6455.hpp]```using reason_string = static_string< 123, char >;```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.const_iterator [*const_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_pointer [*const_pointer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_reference [*const_reference]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.const_reverse_iterator [*const_reverse_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.difference_type [*difference_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.iterator [*iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.pointer [*pointer]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.reference [*reference]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.reverse_iterator [*reverse_iterator]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.size_type [*size_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.string_view_type [*string_view_type]]]    [      The type of string_view returned by the interface.     ]  ]  [    [[link beast.ref.boost__beast__static_string.traits_type [*traits_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.value_type [*value_type]]]    [          ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.append [*append]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.assign [*assign]]]    [      Assign count copies of ch.       Assign from another static_string       Assign count characterss starting at npos from other.       Assign the first count characters of s, including nulls.       Assign a null terminated string.       Assign from an iterator range of characters.       Assign from any object convertible to string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.at [*at]]]    [      Access specified character with bounds checking.     ]  ]  [    [[link beast.ref.boost__beast__static_string.back [*back]]]    [      Accesses the last character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.begin [*begin]]]    [      Returns an iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.c_str [*c_str]]]    [      Returns a non-modifiable standard C character array version of the string.     ]  ]  [    [[link beast.ref.boost__beast__static_string.capacity [*capacity]]]    [      Returns the number of characters that can be held in currently allocated storage.     ]  ]  [    [[link beast.ref.boost__beast__static_string.cbegin [*cbegin]]]    [      Returns an iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.cend [*cend]]]    [      Returns an iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.clear [*clear]]]    [      Clears the contents.     ]  ]  [    [[link beast.ref.boost__beast__static_string.compare [*compare]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.copy [*copy]]]    [      Copy a substring (pos, pos+count) to character string pointed to by dest.     ]  ]  [    [[link beast.ref.boost__beast__static_string.crbegin [*crbegin]]]    [      Returns a reverse iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.crend [*crend]]]    [      Returns a reverse iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.data [*data]]]    [      Returns a pointer to the first character of a string.     ]  ]  [    [[link beast.ref.boost__beast__static_string.empty [*empty]]]    [      Returns true if the string is empty.     ]  ]  [    [[link beast.ref.boost__beast__static_string.end [*end]]]    [      Returns an iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.erase [*erase]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.front [*front]]]    [      Accesses the first character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.insert [*insert]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.length [*length]]]    [      Returns the number of characters, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.max_size [*max_size]]]    [      Returns the maximum number of characters that can be stored, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_string_view_type [*operator string_view_type]]]    [      Convert a static string to a string_view_type     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_plus__eq_ [*operator+=]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_eq_ [*operator=]]]    [      Copy assignment.       Assign from null-terminated string.       Assign from single character.       Assign from initializer list.       Assign from string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.operator_lb__rb_ [*operator\[\]]]]    [      Access specified character.     ]  ]  [    [[link beast.ref.boost__beast__static_string.pop_back [*pop_back]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.push_back [*push_back]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.rbegin [*rbegin]]]    [      Returns a reverse iterator to the beginning.     ]  ]  [    [[link beast.ref.boost__beast__static_string.rend [*rend]]]    [      Returns a reverse iterator to the end.     ]  ]  [    [[link beast.ref.boost__beast__static_string.reserve [*reserve]]]    [      Reserves storage.     ]  ]  [    [[link beast.ref.boost__beast__static_string.resize [*resize]]]    [      Changes the number of characters stored.     ]  ]  [    [[link beast.ref.boost__beast__static_string.shrink_to_fit [*shrink_to_fit]]]    [      Reduces memory usage by freeing unused memory.     ]  ]  [    [[link beast.ref.boost__beast__static_string.size [*size]]]    [      Returns the number of characters, excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.static_string [*static_string]]]    [      Default constructor (empty string).       Construct with count copies of character ch.       Construct with a substring (pos, other.size()) of other.       Construct with a substring (pos, count) of other.       Construct with the first count characters of s, including nulls.       Construct from a null terminated string.       Construct from a range of characters.       Copy constructor.       Construct from an initializer list.       Construct from a string_view       Construct from any object convertible to string_view_type.     ]  ]  [    [[link beast.ref.boost__beast__static_string.substr [*substr]]]    [          ]  ]  [    [[link beast.ref.boost__beast__static_string.swap [*swap]]]    [      Exchange the contents of this string with another.     ]  ]][heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__static_string.max_size_n [*max_size_n]]]    [      Maximum size of the string excluding the null terminator.     ]  ]  [    [[link beast.ref.boost__beast__static_string.npos [*npos]]]    [      A special index.     ]  ]]
These objects behave like `std::string` except that the storage is not dynamically allocated but rather fixed in size.

These strings offer performance advantages when a protocol imposes a natural small upper limit on the size of a value.

[heading Remarks]
The stored string is always null-terminated.

[heading See Also]
[link beast.ref.boost__beast__to_static_string `to_static_string`] 


Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__request_type websocket::request_type][indexterm1 websocket::request_type]
The type of object holding HTTP Upgrade requests. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```using request_type = http::request< http::empty_body >;```Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__response_type websocket::response_type][indexterm1 websocket::response_type]
The type of object holding HTTP Upgrade responses. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```using response_type = http::response< http::string_body >;```Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__role_type websocket::role_type][indexterm1 websocket::role_type]
The role of the websocket stream endpoint. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/role.hpp]```enum role_type```[indexterm2 client..websocket::role_type][indexterm2 server..websocket::role_type][heading Values][table [[Name][Description]]  [[[^client]][The stream is operating as a client. ]]  [[[^server]][The stream is operating as a server. ]]][heading Description]
Whether the endpoint is a client or server affects the behavior of the ['Close the WebSocket Connection] operation described in rfc6455 section 7.1.1. The shutdown behavior depends on the type of the next layer template parameter used to construct the [link beast.ref.boost__beast__websocket__stream `websocket::stream`]. Other next layer types including user-defined types may implement different role-based behavior when performing the close operation.

The default implementation for [link beast.ref.boost__beast__websocket__stream `websocket::stream`] when the next layer type is a `boost::asio::ip::tcp::socket` behaves as follows:


* In the client role, a TCP/IP shutdown is sent after reading all remaining data on the connection.


* In the server role, a TCP/IP shutdown is sent before reading all remaining data on the connection.

When the next layer type is a `boost::asio::ssl::stream`, the connection is closed by performing the SSL closing handshake corresponding to the role type, client or server.

[heading See Also]
[@https://tools.ietf.org/html/rfc6455#section-7.1.1 https://tools.ietf.org/html/rfc6455#section-7.1.1] 


Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream websocket::stream]
Provides message-oriented functionality using WebSocket. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    class NextLayer>class stream```[heading Types][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__stream.executor_type [*executor_type]]]    [      The type of the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.lowest_layer_type [*lowest_layer_type]]]    [      The type of the lowest layer.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.next_layer_type [*next_layer_type]]]    [      The type of the next layer.     ]  ]][heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__stream.accept [*accept]]]    [      Read and respond to a WebSocket HTTP Upgrade request.       Respond to a WebSocket HTTP Upgrade request.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.accept_ex [*accept_ex]]]    [      Read and respond to a WebSocket HTTP Upgrade request.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_accept [*async_accept]]]    [      Start reading and responding to a WebSocket HTTP Upgrade request.       Start responding to a WebSocket HTTP Upgrade request.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_accept_ex [*async_accept_ex]]]    [      Start reading and responding to a WebSocket HTTP Upgrade request.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_close [*async_close]]]    [      Start an asynchronous operation to send a WebSocket close frame.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_handshake [*async_handshake]]]    [      Start an asynchronous operation to send an upgrade request and receive the response.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_handshake_ex [*async_handshake_ex]]]    [      Start an asynchronous operation to send an upgrade request and receive the response.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_ping [*async_ping]]]    [      Start an asynchronous operation to send a WebSocket ping frame.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_pong [*async_pong]]]    [      Start an asynchronous operation to send a WebSocket pong frame.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_read [*async_read]]]    [      Read a message asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_read_some [*async_read_some]]]    [      Read part of a message asynchronously.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_write [*async_write]]]    [      Start an asynchronous operation to write a message to the stream.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.async_write_some [*async_write_some]]]    [      Start an asynchronous operation to send a message frame on the stream.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.auto_fragment [*auto_fragment]]]    [      Set the automatic fragmentation option.       Returns true if the automatic fragmentation option is set.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.binary [*binary]]]    [      Set the binary message option.       Returns true if the binary message option is set.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.close [*close]]]    [      Send a WebSocket close frame.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.control_callback [*control_callback]]]    [      Set a callback to be invoked on each incoming control frame.       Reset the control frame callback.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.get_executor [*get_executor]]]    [      Get the executor associated with the object.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.get_option [*get_option]]]    [      Get the permessage-deflate extension options.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.got_binary [*got_binary]]]    [      Returns true if the latest message data indicates binary.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.got_text [*got_text]]]    [      Returns true if the latest message data indicates text.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.handshake [*handshake]]]    [      Send an HTTP WebSocket Upgrade request and receive the response.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.handshake_ex [*handshake_ex]]]    [      Send an HTTP WebSocket Upgrade request and receive the response.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.is_message_done [*is_message_done]]]    [      Returns true if the last completed read finished the current message.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.is_open [*is_open]]]    [      Returns true if the stream is open.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.lowest_layer [*lowest_layer]]]    [      Get a reference to the lowest layer.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.next_layer [*next_layer]]]    [      Get a reference to the next layer.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.operator_eq_ [*operator=]]]    [      Assignment.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.ping [*ping]]]    [      Send a WebSocket ping frame.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.pong [*pong]]]    [      Send a WebSocket pong frame.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.read [*read]]]    [      Read a message.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.read_message_max [*read_message_max]]]    [      Set the maximum incoming message size option.       Returns the maximum incoming message size setting.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.read_size_hint [*read_size_hint]]]    [      Returns a suggested maximum buffer size for the next call to read.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.read_some [*read_some]]]    [      Read part of a message.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.reason [*reason]]]    [      Returns the close reason received from the peer.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.set_option [*set_option]]]    [      Set the permessage-deflate extension options.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.stream [*stream]]]    [      Constructor.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.text [*text]]]    [      Set the text message option.       Returns true if the text message option is set.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.write [*write]]]    [      Write a message to the stream.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.write_buffer_size [*write_buffer_size]]]    [      Set the write buffer size option.       Returns the size of the write buffer.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.write_some [*write_some]]]    [      Write partial message data on the stream.     ]  ]  [    [[link beast.ref.boost__beast__websocket__stream.stream_dtor_ [*~stream]]]    [      Destructor.     ]  ]][heading Description]
The [link beast.ref.boost__beast__websocket__stream `websocket::stream`] class template provides asynchronous and blocking message-oriented functionality necessary for clients and servers to utilize the WebSocket protocol.

For asynchronous operations, the application must ensure that they are are all performed within the same implicit or explicit strand.

[heading Thread Safety]
['Distinct] ['objects:] Safe.['Shared] ['objects:] Unsafe. The application must also ensure that all asynchronous operations are performed within the same implicit or explicit strand.

[heading Example]


To use the [link beast.ref.boost__beast__websocket__stream `websocket::stream`] template with an `ip::tcp::socket`, you would write:



  websocket::stream<ip::tcp::socket> ws{io_context};


Alternatively, you can write: 

  ip::tcp::socket sock{io_context};
  websocket::stream<ip::tcp::socket&> ws{sock};




[heading Template Parameters][table [[Type][Description]]  [[`NextLayer`][    The type representing the next layer, to which data will be read and written during operations. For synchronous operations, the type must support the SyncStream concept. For asynchronous operations, the type must support the AsyncStream concept.  ]]]
[heading Remarks]
A stream object must not be moved or destroyed while there are pending asynchronous operations associated with it.

[heading Concepts]
[*AsyncStream], [*DynamicBuffer], [*SyncStream] 


[section:accept websocket::stream::accept][indexterm2 accept..websocket::stream]
Read and respond to a WebSocket HTTP Upgrade request. 
```void``[link beast.ref.boost__beast__websocket__stream.accept.overload1 accept]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept.overload1 more...]]``void``[link beast.ref.boost__beast__websocket__stream.accept.overload2 accept]``(    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept.overload2 more...]]``template<    class __ConstBufferSequence__>void``[link beast.ref.boost__beast__websocket__stream.accept.overload3 accept]``(    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept.overload3 more...]]``template<    class __ConstBufferSequence__>void``[link beast.ref.boost__beast__websocket__stream.accept.overload4 accept]``(    ConstBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept.overload4 more...]]`````
Respond to a WebSocket HTTP Upgrade request. 
```template<    class ``[link beast.concepts.Body [*Body]]``,    class Allocator>void``[link beast.ref.boost__beast__websocket__stream.accept.overload5 accept]``(    http::request< Body, http::basic_fields< Allocator >> const& req);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept.overload5 more...]]``template<    class ``[link beast.concepts.Body [*Body]]``,    class Allocator>void``[link beast.ref.boost__beast__websocket__stream.accept.overload6 accept]``(    http::request< Body, http::basic_fields< Allocator >> const& req,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept.overload6 more...]]`````[section:overload1 websocket::stream::accept (1 of 6 overloads)]
Read and respond to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```voidaccept();```[heading Description]
This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:


* The request is received and the response finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.

The implementation uses fixed size internal storage to receive the request. If the request is too large, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of [link beast.ref.boost__beast__http__read `http::read`] or [link beast.ref.boost__beast__http__async_read `http::async_read`], then call [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`] with the request.

[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

[endsect][section:overload2 websocket::stream::accept (2 of 6 overloads)]
Read and respond to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```voidaccept(    error_code& ec);```[heading Description]
This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:


* The request is received and the response finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.

The implementation uses fixed size internal storage to receive the request. If the request is too large, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of [link beast.ref.boost__beast__http__read `http::read`] or [link beast.ref.boost__beast__http__async_read `http::async_read`], then call [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`] with the request.

[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to indicate what error occurred, if any.   ]]]

[endsect][section:overload3 websocket::stream::accept (3 of 6 overloads)]
Read and respond to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class __ConstBufferSequence__>voidaccept(    ConstBufferSequence const& buffers);```[heading Description]
This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:


* The request is received and the response finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.

The implementation uses fixed size internal storage to receive the request. If the request is too large, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of [link beast.ref.boost__beast__http__read `http::read`] or [link beast.ref.boost__beast__http__async_read `http::async_read`], then call [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`] with the request.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    Caller provided data that has already been received on the stream. The implementation will copy the caller provided data before the function returns.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

[endsect][section:overload4 websocket::stream::accept (4 of 6 overloads)]
Read and respond to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class __ConstBufferSequence__>voidaccept(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:


* The request is received and the response finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.

The implementation uses fixed size internal storage to receive the request. If the request is too large, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of [link beast.ref.boost__beast__http__read `http::read`] or [link beast.ref.boost__beast__http__async_read `http::async_read`], then call [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`] with the request.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    Caller provided data that has already been received on the stream. The implementation will copy the caller provided data before the function returns.  ]]  [[`ec`][    Set to indicate what error occurred, if any.   ]]]

[endsect][section:overload5 websocket::stream::accept (5 of 6 overloads)]
Respond to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class ``[link beast.concepts.Body [*Body]]``,    class Allocator>voidaccept(    http::request< Body, http::basic_fields< Allocator >> const& req);```[heading Description]
This function is used to synchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade. The call blocks until one of the following conditions is true:


* The response finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.

[heading Parameters][table [[Name][Description]]  [[`req`][    An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

[endsect][section:overload6 websocket::stream::accept (6 of 6 overloads)]
Respond to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class ``[link beast.concepts.Body [*Body]]``,    class Allocator>voidaccept(    http::request< Body, http::basic_fields< Allocator >> const& req,    error_code& ec);```[heading Description]
This function is used to synchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade. The call blocks until one of the following conditions is true:


* The response finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.

[heading Parameters][table [[Name][Description]]  [[`req`][    An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.  ]]  [[`ec`][    Set to indicate what error occurred, if any.   ]]]

[endsect][endsect][section:accept_ex websocket::stream::accept_ex][indexterm2 accept_ex..websocket::stream]
Read and respond to a WebSocket HTTP Upgrade request. 
```template<    class ResponseDecorator>void``[link beast.ref.boost__beast__websocket__stream.accept_ex.overload1 accept_ex]``(    ResponseDecorator const& decorator);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept_ex.overload1 more...]]``template<    class ResponseDecorator>void``[link beast.ref.boost__beast__websocket__stream.accept_ex.overload2 accept_ex]``(    ResponseDecorator const& decorator,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept_ex.overload2 more...]]``template<    class __ConstBufferSequence__,    class ResponseDecorator>void``[link beast.ref.boost__beast__websocket__stream.accept_ex.overload3 accept_ex]``(    ConstBufferSequence const& buffers,    ResponseDecorator const& decorator);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept_ex.overload3 more...]]``template<    class __ConstBufferSequence__,    class ResponseDecorator>void``[link beast.ref.boost__beast__websocket__stream.accept_ex.overload4 accept_ex]``(    ConstBufferSequence const& buffers,    ResponseDecorator const& decorator,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept_ex.overload4 more...]]``template<    class ``[link beast.concepts.Body [*Body]]``,    class Allocator,    class ResponseDecorator>void``[link beast.ref.boost__beast__websocket__stream.accept_ex.overload5 accept_ex]``(    http::request< Body, http::basic_fields< Allocator >> const& req,    ResponseDecorator const& decorator);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept_ex.overload5 more...]]``template<    class ``[link beast.concepts.Body [*Body]]``,    class Allocator,    class ResponseDecorator>void``[link beast.ref.boost__beast__websocket__stream.accept_ex.overload6 accept_ex]``(    http::request< Body, http::basic_fields< Allocator >> const& req,    ResponseDecorator const& decorator,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.accept_ex.overload6 more...]]`````[section:overload1 websocket::stream::accept_ex (1 of 6 overloads)]
Read and respond to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class ResponseDecorator>voidaccept_ex(    ResponseDecorator const& decorator);```[heading Description]
This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:


* The request is received and the response finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.

The implementation uses fixed size internal storage to receive the request. If the request is too large, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of [link beast.ref.boost__beast__http__read `http::read`] or [link beast.ref.boost__beast__http__async_read `http::async_read`], then call [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`] with the request.

[heading Parameters][table [[Name][Description]]  [[`decorator`][    A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      response_type& res
  ); 
``
  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

[endsect][section:overload2 websocket::stream::accept_ex (2 of 6 overloads)]
Read and respond to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class ResponseDecorator>voidaccept_ex(    ResponseDecorator const& decorator,    error_code& ec);```[heading Description]
This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:


* The request is received and the response finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.

The implementation uses fixed size internal storage to receive the request. If the request is too large, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of [link beast.ref.boost__beast__http__read `http::read`] or [link beast.ref.boost__beast__http__async_read `http::async_read`], then call [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`] with the request.

[heading Parameters][table [[Name][Description]]  [[`decorator`][    A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      response_type& res
  ); 
``
  ]]  [[`ec`][    Set to indicate what error occurred, if any.   ]]]

[endsect][section:overload3 websocket::stream::accept_ex (3 of 6 overloads)]
Read and respond to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class __ConstBufferSequence__,    class ResponseDecorator>voidaccept_ex(    ConstBufferSequence const& buffers,    ResponseDecorator const& decorator);```[heading Description]
This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:


* The request is received and the response finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.

The implementation uses fixed size internal storage to receive the request. If the request is too large, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of [link beast.ref.boost__beast__http__read `http::read`] or [link beast.ref.boost__beast__http__async_read `http::async_read`], then call [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`] with the request.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    Caller provided data that has already been received on the stream. The implementation will copy the caller provided data before the function returns.  ]]  [[`decorator`][    A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      response_type& res
  ); 
``
  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

[endsect][section:overload4 websocket::stream::accept_ex (4 of 6 overloads)]
Read and respond to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class __ConstBufferSequence__,    class ResponseDecorator>voidaccept_ex(    ConstBufferSequence const& buffers,    ResponseDecorator const& decorator,    error_code& ec);```[heading Description]
This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:


* The request is received and the response finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.

The implementation uses fixed size internal storage to receive the request. If the request is too large, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of [link beast.ref.boost__beast__http__read `http::read`] or [link beast.ref.boost__beast__http__async_read `http::async_read`], then call [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`] with the request.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    Caller provided data that has already been received on the stream. The implementation will copy the caller provided data before the function returns.  ]]  [[`decorator`][    A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      response_type& res
  ); 
``
  ]]  [[`ec`][    Set to indicate what error occurred, if any.   ]]]

[endsect][section:overload5 websocket::stream::accept_ex (5 of 6 overloads)]
Respond to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class ``[link beast.concepts.Body [*Body]]``,    class Allocator,    class ResponseDecorator>voidaccept_ex(    http::request< Body, http::basic_fields< Allocator >> const& req,    ResponseDecorator const& decorator);```[heading Description]
This function is used to synchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade. The call blocks until one of the following conditions is true:


* The response finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.

[heading Parameters][table [[Name][Description]]  [[`req`][    An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.  ]]  [[`decorator`][    A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      response_type& res
  ); 
``
  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

[endsect][section:overload6 websocket::stream::accept_ex (6 of 6 overloads)]
Respond to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class ``[link beast.concepts.Body [*Body]]``,    class Allocator,    class ResponseDecorator>voidaccept_ex(    http::request< Body, http::basic_fields< Allocator >> const& req,    ResponseDecorator const& decorator,    error_code& ec);```[heading Description]
This function is used to synchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade. The call blocks until one of the following conditions is true:


* The response finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.

[heading Parameters][table [[Name][Description]]  [[`req`][    An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.  ]]  [[`decorator`][    A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      response_type& res
  ); 
``
  ]]  [[`ec`][    Set to indicate what error occurred, if any.   ]]]

[endsect][endsect][section:async_accept websocket::stream::async_accept][indexterm2 async_accept..websocket::stream]
Start reading and responding to a WebSocket HTTP Upgrade request. 
```template<    class AcceptHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__websocket__stream.async_accept.overload1 async_accept]``(    AcceptHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_accept.overload1 more...]]``template<    class __ConstBufferSequence__,    class AcceptHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__websocket__stream.async_accept.overload2 async_accept]``(    ConstBufferSequence const& buffers,    AcceptHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_accept.overload2 more...]]`````
Start responding to a WebSocket HTTP Upgrade request. 
```template<    class ``[link beast.concepts.Body [*Body]]``,    class Allocator,    class AcceptHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__websocket__stream.async_accept.overload3 async_accept]``(    http::request< Body, http::basic_fields< Allocator >> const& req,    AcceptHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_accept.overload3 more...]]`````[section:overload1 websocket::stream::async_accept (1 of 3 overloads)]
Start reading and responding to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class AcceptHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_accept(    AcceptHandler&& handler);```[heading Description]
This function is used to asynchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The request is received and the response finishes sending.


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `async_read_some` and `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other asynchronous operations until this operation completes.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.

The implementation uses fixed size internal storage to receive the request. If the request is too large, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of [link beast.ref.boost__beast__http__read `http::read`] or [link beast.ref.boost__beast__http__async_read `http::async_read`], then call [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`] with the request.

[heading Parameters][table [[Name][Description]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& ec    // Result of operation
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:overload2 websocket::stream::async_accept (2 of 3 overloads)]
Start reading and responding to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class __ConstBufferSequence__,    class AcceptHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_accept(    ConstBufferSequence const& buffers,    AcceptHandler&& handler);```[heading Description]
This function is used to asynchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The request is received and the response finishes sending.


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `async_read_some` and `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other asynchronous operations until this operation completes.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.

The implementation uses fixed size internal storage to receive the request. If the request is too large, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of [link beast.ref.boost__beast__http__read `http::read`] or [link beast.ref.boost__beast__http__async_read `http::async_read`], then call [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`] with the request.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    Caller provided data that has already been received on the stream. This may be used for implementations allowing multiple protocols on the same stream. The buffered data will first be applied to the handshake, and then to received WebSocket frames. The implementation will copy the caller provided data before the function returns.  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& ec    // Result of operation
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:overload3 websocket::stream::async_accept (3 of 3 overloads)]
Start responding to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class ``[link beast.concepts.Body [*Body]]``,    class Allocator,    class AcceptHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_accept(    http::request< Body, http::basic_fields< Allocator >> const& req,    AcceptHandler&& handler);```[heading Description]
This function is used to asynchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade request. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The response finishes sending.


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other operations until this operation completes.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.

[heading Parameters][table [[Name][Description]]  [[`req`][    An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& ec    // Result of operation
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][endsect][section:async_accept_ex websocket::stream::async_accept_ex][indexterm2 async_accept_ex..websocket::stream]
Start reading and responding to a WebSocket HTTP Upgrade request. 
```template<    class ResponseDecorator,    class AcceptHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__websocket__stream.async_accept_ex.overload1 async_accept_ex]``(    ResponseDecorator const& decorator,    AcceptHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_accept_ex.overload1 more...]]``template<    class __ConstBufferSequence__,    class ResponseDecorator,    class AcceptHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__websocket__stream.async_accept_ex.overload2 async_accept_ex]``(    ConstBufferSequence const& buffers,    ResponseDecorator const& decorator,    AcceptHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_accept_ex.overload2 more...]]``template<    class ``[link beast.concepts.Body [*Body]]``,    class Allocator,    class ResponseDecorator,    class AcceptHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__websocket__stream.async_accept_ex.overload3 async_accept_ex]``(    http::request< Body, http::basic_fields< Allocator >> const& req,    ResponseDecorator const& decorator,    AcceptHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_accept_ex.overload3 more...]]`````[section:overload1 websocket::stream::async_accept_ex (1 of 3 overloads)]
Start reading and responding to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class ResponseDecorator,    class AcceptHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_accept_ex(    ResponseDecorator const& decorator,    AcceptHandler&& handler);```[heading Description]
This function is used to asynchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The request is received and the response finishes sending.


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `async_read_some` and `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other asynchronous operations until this operation completes.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.

The implementation uses fixed size internal storage to receive the request. If the request is too large, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of [link beast.ref.boost__beast__http__read `http::read`] or [link beast.ref.boost__beast__http__async_read `http::async_read`], then call [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`] with the request.

[heading Parameters][table [[Name][Description]]  [[`decorator`][    A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      response_type& res
  ); 
``
  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& ec    // Result of operation
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:overload2 websocket::stream::async_accept_ex (2 of 3 overloads)]
Start reading and responding to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class __ConstBufferSequence__,    class ResponseDecorator,    class AcceptHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_accept_ex(    ConstBufferSequence const& buffers,    ResponseDecorator const& decorator,    AcceptHandler&& handler);```[heading Description]
This function is used to asynchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The request is received and the response finishes sending.


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `async_read_some` and `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other asynchronous operations until this operation completes.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.

The implementation uses fixed size internal storage to receive the request. If the request is too large, the error [link beast.ref.boost__beast__websocket__error `websocket::buffer_overflow`] will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of [link beast.ref.boost__beast__http__read `http::read`] or [link beast.ref.boost__beast__http__async_read `http::async_read`], then call [link beast.ref.boost__beast__websocket__stream.accept `websocket::stream::accept`] or [link beast.ref.boost__beast__websocket__stream.async_accept `websocket::stream::async_accept`] with the request.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    Caller provided data that has already been received on the stream. This may be used for implementations allowing multiple protocols on the same stream. The buffered data will first be applied to the handshake, and then to received WebSocket frames. The implementation will copy the caller provided data before the function returns.  ]]  [[`decorator`][    A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      response_type& res
  ); 
``
  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& ec    // Result of operation
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:overload3 websocket::stream::async_accept_ex (3 of 3 overloads)]
Start responding to a WebSocket HTTP Upgrade request. 
[heading Synopsis]```template<    class ``[link beast.concepts.Body [*Body]]``,    class Allocator,    class ResponseDecorator,    class AcceptHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_accept_ex(    http::request< Body, http::basic_fields< Allocator >> const& req,    ResponseDecorator const& decorator,    AcceptHandler&& handler);```[heading Description]
This function is used to asynchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade request. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The response finishes sending.


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other operations until this operation completes.

If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.

[heading Parameters][table [[Name][Description]]  [[`req`][    An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.  ]]  [[`decorator`][    A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      response_type& res
  ); 
``
  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& ec    // Result of operation
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][endsect][section:async_close websocket::stream::async_close][indexterm2 async_close..websocket::stream]
Start an asynchronous operation to send a WebSocket close frame. 
[heading Synopsis]```template<    class CloseHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_close(    close_reason const& cr,    CloseHandler&& handler);```[heading Description]
This function is used to asynchronously send a close frame on the stream. This function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The close frame finishes sending.


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as [link beast.ref.boost__beast__websocket__stream.async_ping `websocket::stream::async_ping`], [link beast.ref.boost__beast__websocket__stream.async_write `websocket::stream::async_write`], [link beast.ref.boost__beast__websocket__stream.async_write_some `websocket::stream::async_write_some`], or [link beast.ref.boost__beast__websocket__stream.async_close `websocket::stream::async_close`]) until this operation completes.

If the close reason specifies a close code other than beast::websocket::close\_code::none, the close frame is sent with the close code and optional reason string. Otherwise, the close frame is sent with no payload.

Callers should not attempt to write WebSocket data after initiating the close. Instead, callers should continue reading until an error occurs. A read returning [link beast.ref.boost__beast__websocket__error `websocket::closed`] indicates a successful connection closure.

[heading Parameters][table [[Name][Description]]  [[`cr`][    The reason for the close.  ]]  [[`handler`][    The handler to be called when the close operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
  void handler(
      error_code const& ec     // Result of operation
  );
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:async_handshake websocket::stream::async_handshake][indexterm2 async_handshake..websocket::stream]
Start an asynchronous operation to send an upgrade request and receive the response. 
```template<    class HandshakeHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__websocket__stream.async_handshake.overload1 async_handshake]``(    string_view host,    string_view target,    HandshakeHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_handshake.overload1 more...]]``template<    class HandshakeHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__websocket__stream.async_handshake.overload2 async_handshake]``(    response_type& res,    string_view host,    string_view target,    HandshakeHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_handshake.overload2 more...]]`````[section:overload1 websocket::stream::async_handshake (1 of 2 overloads)]
Start an asynchronous operation to send an upgrade request and receive the response. 
[heading Synopsis]```template<    class HandshakeHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_handshake(    string_view host,    string_view target,    HandshakeHandler&& handler);```[heading Description]
This function is used to asynchronously send the HTTP WebSocket upgrade request and receive the HTTP WebSocket Upgrade response. This function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The request is sent and the response is received.


* An error occurs on the stream

This operation is implemented in terms of one or more calls to the next layer's `async_read_some` and `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other operations until this operation completes.

The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").

[heading Parameters][table [[Name][Description]]  [[`host`][    The name of the remote host, required by the HTTP protocol. Copies may be made as needed.  ]]  [[`target`][    The Request Target, which may not be empty, required by the HTTP protocol. Copies of this parameter may be made as needed.  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& ec    // Result of operation
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:overload2 websocket::stream::async_handshake (2 of 2 overloads)]
Start an asynchronous operation to send an upgrade request and receive the response. 
[heading Synopsis]```template<    class HandshakeHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_handshake(    response_type& res,    string_view host,    string_view target,    HandshakeHandler&& handler);```[heading Description]
This function is used to asynchronously send the HTTP WebSocket upgrade request and receive the HTTP WebSocket Upgrade response. This function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The request is sent and the response is received.


* An error occurs on the stream

This operation is implemented in terms of one or more calls to the next layer's `async_read_some` and `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other operations until this operation completes.

The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").

[heading Parameters][table [[Name][Description]]  [[`res`][    The HTTP Upgrade response returned by the remote endpoint. The caller must ensure this object is valid for at least until the completion handler is invoked.  ]]  [[`host`][    The name of the remote host, required by the HTTP protocol. Copies may be made as needed.  ]]  [[`target`][    The Request Target, which may not be empty, required by the HTTP protocol. Copies of this parameter may be made as needed.  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& ec     // Result of operation
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][endsect][section:async_handshake_ex websocket::stream::async_handshake_ex][indexterm2 async_handshake_ex..websocket::stream]
Start an asynchronous operation to send an upgrade request and receive the response. 
```template<    class RequestDecorator,    class HandshakeHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__websocket__stream.async_handshake_ex.overload1 async_handshake_ex]``(    string_view host,    string_view target,    RequestDecorator const& decorator,    HandshakeHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_handshake_ex.overload1 more...]]``template<    class RequestDecorator,    class HandshakeHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__websocket__stream.async_handshake_ex.overload2 async_handshake_ex]``(    response_type& res,    string_view host,    string_view target,    RequestDecorator const& decorator,    HandshakeHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_handshake_ex.overload2 more...]]`````[section:overload1 websocket::stream::async_handshake_ex (1 of 2 overloads)]
Start an asynchronous operation to send an upgrade request and receive the response. 
[heading Synopsis]```template<    class RequestDecorator,    class HandshakeHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_handshake_ex(    string_view host,    string_view target,    RequestDecorator const& decorator,    HandshakeHandler&& handler);```[heading Description]
This function is used to asynchronously send the HTTP WebSocket upgrade request and receive the HTTP WebSocket Upgrade response. This function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The request is sent and the response is received.


* An error occurs on the stream

This operation is implemented in terms of one or more calls to the next layer's `async_read_some` and `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other operations until this operation completes.

The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").

[heading Parameters][table [[Name][Description]]  [[`host`][    The name of the remote host, required by the HTTP protocol. Copies may be made as needed.  ]]  [[`target`][    The Request Target, which may not be empty, required by the HTTP protocol. Copies of this parameter may be made as needed.  ]]  [[`decorator`][    A function object which will be called to modify the HTTP request object generated by the implementation. This could be used to set the User-Agent field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      request_type& req
  ); 
``
  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& ec     // Result of operation
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:overload2 websocket::stream::async_handshake_ex (2 of 2 overloads)]
Start an asynchronous operation to send an upgrade request and receive the response. 
[heading Synopsis]```template<    class RequestDecorator,    class HandshakeHandler>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_handshake_ex(    response_type& res,    string_view host,    string_view target,    RequestDecorator const& decorator,    HandshakeHandler&& handler);```[heading Description]
This function is used to asynchronously send the HTTP WebSocket upgrade request and receive the HTTP WebSocket Upgrade response. This function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The request is sent and the response is received.


* An error occurs on the stream

This operation is implemented in terms of one or more calls to the next layer's `async_read_some` and `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other operations until this operation completes.

The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").

[heading Parameters][table [[Name][Description]]  [[`res`][    The HTTP Upgrade response returned by the remote endpoint. The caller must ensure this object is valid for at least until the completion handler is invoked.  ]]  [[`host`][    The name of the remote host, required by the HTTP protocol. Copies may be made as needed.  ]]  [[`target`][    The Request Target, which may not be empty, required by the HTTP protocol. Copies of this parameter may be made as needed.  ]]  [[`decorator`][    A function object which will be called to modify the HTTP request object generated by the implementation. This could be used to set the User-Agent field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      request_type& req
  ); 
``
  ]]  [[`handler`][    The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& ec     // Result of operation
  ); 
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][endsect][section:async_ping websocket::stream::async_ping][indexterm2 async_ping..websocket::stream]
Start an asynchronous operation to send a WebSocket ping frame. 
[heading Synopsis]```template<    class __WriteHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_ping(    ping_data const& payload,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously send a ping frame to the stream. The function call always returns immediately. The asynchronous operation will continue until one of the following is true:


* The entire ping frame is sent.


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other writes until this operation completes.

If a close frame is sent or received before the ping frame is sent, the completion handler will be called with the error set to `boost::asio::error::operation_aborted`.

[heading Parameters][table [[Name][Description]]  [[`payload`][    The payload of the ping message, which may be empty.  ]]  [[`handler`][    The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
  void handler(
      error_code const& ec     // Result of operation
  );
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:async_pong websocket::stream::async_pong][indexterm2 async_pong..websocket::stream]
Start an asynchronous operation to send a WebSocket pong frame. 
[heading Synopsis]```template<    class __WriteHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_pong(    ping_data const& payload,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously send a pong frame to the stream. The function call always returns immediately. The asynchronous operation will continue until one of the following is true:


* The entire pong frame is sent.


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other writes until this operation completes.

The WebSocket protocol allows pong frames to be sent from either end at any time. It is not necessary to first receive a ping in order to send a pong. The remote peer may use the receipt of a pong frame as an indication that the connection is not dead.

If a close frame is sent or received before the pong frame is sent, the completion handler will be called with the error set to `boost::asio::error::operation_aborted`.

[heading Parameters][table [[Name][Description]]  [[`payload`][    The payload of the pong message, which may be empty.  ]]  [[`handler`][    The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
  void handler(
      error_code const& ec     // Result of operation
  );
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:async_read websocket::stream::async_read][indexterm2 async_read..websocket::stream]
Read a message asynchronously. 
[heading Synopsis]```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    class __ReadHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_read(    DynamicBuffer& buffer,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read a complete message from the stream. The function call always returns immediately. The asynchronous operation will continue until one of the following is true:


* A complete message is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `async_read_some` and `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other reads until this operation completes.

Received message data, if any, is appended to the input area of the buffer. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message.

While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:


* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

Because of the need to handle control frames, asynchronous read operations can cause writes to take place. These writes are managed transparently; callers can still have one active asynchronous read and asynchronous write operation pending simultaneously (a user initiated call to [link beast.ref.boost__beast__websocket__stream.async_close `websocket::stream::async_close`] counts as a write).

[heading Parameters][table [[Name][Description]]  [[`buffer`][    A dynamic buffer to hold the message data after any masking or decompression has been applied. This object must remain valid until the handler is called.  ]]  [[`handler`][    The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
  void handler(
      error_code const& ec,       // Result of operation
      std::size_t bytes_written   // Number of bytes appended to buffer
  );
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:async_read_some websocket::stream::async_read_some][indexterm2 async_read_some..websocket::stream]
Read part of a message asynchronously. 
```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    class __ReadHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__websocket__stream.async_read_some.overload1 async_read_some]``(    DynamicBuffer& buffer,    std::size_t limit,    ReadHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_read_some.overload1 more...]]``template<    class __MutableBufferSequence__,    class __ReadHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]````[link beast.ref.boost__beast__websocket__stream.async_read_some.overload2 async_read_some]``(    MutableBufferSequence const& buffers,    ReadHandler&& handler);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.async_read_some.overload2 more...]]`````[section:overload1 websocket::stream::async_read_some (1 of 2 overloads)]
Read part of a message asynchronously. 
[heading Synopsis]```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``,    class __ReadHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_read_some(    DynamicBuffer& buffer,    std::size_t limit,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read part of a message from the stream. The function call always returns immediately. The asynchronous operation will continue until one of the following is true:


* Some or all of the message is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `async_read_some` and `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other reads until this operation completes.

Received message data, if any, is appended to the input area of the buffer. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message. The function [link beast.ref.boost__beast__websocket__stream.is_message_done `websocket::stream::is_message_done`] may be called to determine if the message received by the last read operation is complete.

While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:


* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

Because of the need to handle control frames, asynchronous read operations can cause writes to take place. These writes are managed transparently; callers can still have one active asynchronous read and asynchronous write operation pending simultaneously (a user initiated call to [link beast.ref.boost__beast__websocket__stream.async_close `websocket::stream::async_close`] counts as a write).

[heading Parameters][table [[Name][Description]]  [[`buffer`][    A dynamic buffer to hold the message data after any masking or decompression has been applied. This object must remain valid until the handler is called.  ]]  [[`limit`][    An upper limit on the number of bytes this function will append into the buffer. If this value is zero, then a reasonable size will be chosen automatically.  ]]  [[`handler`][    The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
  void handler(
      error_code const& ec,       // Result of operation
      std::size_t bytes_written   // Number of bytes appended to buffer
  );
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:overload2 websocket::stream::async_read_some (2 of 2 overloads)]
Read part of a message asynchronously. 
[heading Synopsis]```template<    class __MutableBufferSequence__,    class __ReadHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_read_some(    MutableBufferSequence const& buffers,    ReadHandler&& handler);```[heading Description]
This function is used to asynchronously read part of a message from the stream. The function call always returns immediately. The asynchronous operation will continue until one of the following is true:


* Some or all of the message is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `async_read_some` and `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other reads until this operation completes.

Received message data, if any, is written to the buffer sequence. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message. The function [link beast.ref.boost__beast__websocket__stream.is_message_done `websocket::stream::is_message_done`] may be called to determine if the message received by the last read operation is complete.

While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:


* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

Because of the need to handle control frames, asynchronous read operations can cause writes to take place. These writes are managed transparently; callers can still have one active asynchronous read and asynchronous write operation pending simultaneously (a user initiated call to [link beast.ref.boost__beast__websocket__stream.async_close `websocket::stream::async_close`] counts as a write).

[heading Parameters][table [[Name][Description]]  [[`buffers`][    The buffer sequence into which message data will be placed after any masking or decompresison has been applied. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by the buffer sequence remains valid until the completion handler is called.  ]]  [[`handler`][    The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
  void handler(
      error_code const& ec,       // Result of operation
      std::size_t bytes_written   // Number of bytes written to the buffer sequence
  );
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][endsect][section:async_write websocket::stream::async_write][indexterm2 async_write..websocket::stream]
Start an asynchronous operation to write a message to the stream. 
[heading Synopsis]```template<    class __ConstBufferSequence__,    class __WriteHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_write(    ConstBufferSequence const& buffers,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously write a message to the stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The entire message is sent.


* An error occurs.

This operation is implemented in terms of one or more calls to the next layer's `async_write_some` functions, and is known as a ['composed operation]. The program must ensure that the stream performs no other write operations (such as [link beast.ref.boost__beast__websocket__stream.async_write `websocket::stream::async_write`], [link beast.ref.boost__beast__websocket__stream.async_write_some `websocket::stream::async_write_some`], or [link beast.ref.boost__beast__websocket__stream.async_close `websocket::stream::async_close`]).

The current setting of the [link beast.ref.boost__beast__websocket__stream.binary `websocket::stream::binary`] option controls whether the message opcode is set to text or binary. If the [link beast.ref.boost__beast__websocket__stream.auto_fragment `websocket::stream::auto_fragment`] option is set, the message will be split into one or more frames as necessary. The actual payload contents sent may be transformed as per the WebSocket protocol settings.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    The buffers containing the entire message payload. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by buffers remains valid until the completion handler is called.  ]]  [[`handler`][    The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: 
``
  void handler(
      error_code const& ec,           // Result of operation
      std::size_t bytes_transferred   // Number of bytes written from the
                                      // buffers. If an error occurred,
                                      // this will be less than the sum
                                      // of the buffer sizes.
  );
``
Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using `boost::asio::io_context::post`.   ]]]

[endsect][section:async_write_some websocket::stream::async_write_some][indexterm2 async_write_some..websocket::stream]
Start an asynchronous operation to send a message frame on the stream. 
[heading Synopsis]```template<    class __ConstBufferSequence__,    class __WriteHandler__>``[@http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function ['void-or-deduced]]``async_write_some(    bool fin,    ConstBufferSequence const& buffers,    WriteHandler&& handler);```[heading Description]
This function is used to asynchronously write a message frame on the stream. This function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:


* The entire frame is sent.


* An error occurs.

This operation is implemented in terms of one or more calls to the next layer's `async_write_some` functions, and is known as a ['composed operation]. The actual payload sent may be transformed as per the WebSocket protocol settings. The program must ensure that the stream performs no other write operations (such as [link beast.ref.boost__beast__websocket__stream.async_write `websocket::stream::async_write`], [link beast.ref.boost__beast__websocket__stream.async_write_some `websocket::stream::async_write_some`], or [link beast.ref.boost__beast__websocket__stream.async_close `websocket::stream::async_close`]).

If this is the beginning of a new message, the message opcode will be set to text or binary as per the current setting of the [link beast.ref.boost__beast__websocket__stream.binary `websocket::stream::binary`] option. The actual payload sent may be transformed as per the WebSocket protocol settings.

[heading Parameters][table [[Name][Description]]  [[`fin`][    `true` if this is the last part of the message.  ]]  [[`buffers`][    A object meeting the requirements of ConstBufferSequence which holds the payload data before any masking or compression. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.  ]]  [[`handler`][    The handler to be called when the write completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: 
``
   void handler(
      error_code const& ec,           // Result of operation
      std::size_t bytes_transferred   // Number of bytes written from the
                                      // buffers. If an error occurred,
                                      // this will be less than the sum
                                      // of the buffer sizes.
  ); 
``
  ]]]

[endsect][section:auto_fragment websocket::stream::auto_fragment][indexterm2 auto_fragment..websocket::stream]
Set the automatic fragmentation option. 
```void``[link beast.ref.boost__beast__websocket__stream.auto_fragment.overload1 auto_fragment]``(    bool value);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.auto_fragment.overload1 more...]]`````
Returns `true` if the automatic fragmentation option is set. 
```bool``[link beast.ref.boost__beast__websocket__stream.auto_fragment.overload2 auto_fragment]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.auto_fragment.overload2 more...]]`````[section:overload1 websocket::stream::auto_fragment (1 of 2 overloads)]
Set the automatic fragmentation option. 
[heading Synopsis]```voidauto_fragment(    bool value);```[heading Description]
Determines if outgoing message payloads are broken up into multiple pieces.

When the automatic fragmentation size is turned on, outgoing message payloads are broken up into multiple frames no larger than the write buffer size.

The default setting is to fragment messages.

[heading Parameters][table [[Name][Description]]  [[`value`][    A `bool` indicating if auto fragmentation should be on.  ]]]
[heading Example]
Setting the automatic fragmentation option: 

  ws.auto_fragment(true);





[endsect][section:overload2 websocket::stream::auto_fragment (2 of 2 overloads)]
Returns `true` if the automatic fragmentation option is set. 
[heading Synopsis]```boolauto_fragment() const;```[heading Description][endsect][endsect][section:binary websocket::stream::binary][indexterm2 binary..websocket::stream]
Set the binary message option. 
```void``[link beast.ref.boost__beast__websocket__stream.binary.overload1 binary]``(    bool value);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.binary.overload1 more...]]`````
Returns `true` if the binary message option is set. 
```bool``[link beast.ref.boost__beast__websocket__stream.binary.overload2 binary]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.binary.overload2 more...]]`````[section:overload1 websocket::stream::binary (1 of 2 overloads)]
Set the binary message option. 
[heading Synopsis]```voidbinary(    bool value);```[heading Description]
This controls whether or not outgoing message opcodes are set to binary or text. The setting is only applied at the start when a caller begins a new message. Changing the opcode after a message is started will only take effect after the current message being sent is complete.

The default setting is to send text messages.

[heading Parameters][table [[Name][Description]]  [[`value`][    `true` if outgoing messages should indicate binary, or `false` if they should indicate text.  ]]]
[heading Example]
Setting the message type to binary. 

  ws.binary(true);





[endsect][section:overload2 websocket::stream::binary (2 of 2 overloads)]
Returns `true` if the binary message option is set. 
[heading Synopsis]```boolbinary() const;```[heading Description][endsect][endsect][section:close websocket::stream::close][indexterm2 close..websocket::stream]
Send a WebSocket close frame. 
```void``[link beast.ref.boost__beast__websocket__stream.close.overload1 close]``(    close_reason const& cr);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.close.overload1 more...]]``void``[link beast.ref.boost__beast__websocket__stream.close.overload2 close]``(    close_reason const& cr,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.close.overload2 more...]]`````[section:overload1 websocket::stream::close (1 of 2 overloads)]
Send a WebSocket close frame. 
[heading Synopsis]```voidclose(    close_reason const& cr);```[heading Description]
This function is used to synchronously send a close frame on the stream. The call blocks until one of the following is true:


* The close frame finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `write_some` functions.

If the close reason specifies a close code other than beast::websocket::close\_code::none, the close frame is sent with the close code and optional reason string. Otherwise, the close frame is sent with no payload.

Callers should not attempt to write WebSocket data after initiating the close. Instead, callers should continue reading until an error occurs. A read returning [link beast.ref.boost__beast__websocket__error `websocket::closed`] indicates a successful connection closure.

[heading Parameters][table [[Name][Description]]  [[`cr`][    The reason for the close.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

[endsect][section:overload2 websocket::stream::close (2 of 2 overloads)]
Send a WebSocket close frame. 
[heading Synopsis]```voidclose(    close_reason const& cr,    error_code& ec);```[heading Description]
This function is used to synchronously send a close frame on the stream. The call blocks until one of the following is true:


* The close frame finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `write_some` functions.

If the close reason specifies a close code other than beast::websocket::close\_code::none, the close frame is sent with the close code and optional reason string. Otherwise, the close frame is sent with no payload.

Callers should not attempt to write WebSocket data after initiating the close. Instead, callers should continue reading until an error occurs. A read returning [link beast.ref.boost__beast__websocket__error `websocket::closed`] indicates a successful connection closure.

[heading Parameters][table [[Name][Description]]  [[`cr`][    The reason for the close.  ]]  [[`ec`][    Set to indicate what error occurred, if any.   ]]]

[endsect][endsect][section:control_callback websocket::stream::control_callback][indexterm2 control_callback..websocket::stream]
Set a callback to be invoked on each incoming control frame. 
```template<    class Callback>void``[link beast.ref.boost__beast__websocket__stream.control_callback.overload1 control_callback]``(    Callback& cb);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.control_callback.overload1 more...]]`````
Reset the control frame callback. 
```void``[link beast.ref.boost__beast__websocket__stream.control_callback.overload2 control_callback]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.control_callback.overload2 more...]]`````[section:overload1 websocket::stream::control_callback (1 of 2 overloads)]
Set a callback to be invoked on each incoming control frame. 
[heading Synopsis]```template<    class Callback>voidcontrol_callback(    Callback& cb);```[heading Description]
Sets the callback to be invoked whenever a ping, pong, or close control frame is received during a call to one of the following functions:


* [link beast.ref.boost__beast__websocket__stream.read `websocket::stream::read`] 
* [link beast.ref.boost__beast__websocket__stream.read_some `websocket::stream::read_some`] 
* [link beast.ref.boost__beast__websocket__stream.async_read `websocket::stream::async_read`] 
* [link beast.ref.boost__beast__websocket__stream.async_read_some `websocket::stream::async_read_some`]

Unlike completion handlers, the callback will be invoked for each control frame during a call to any synchronous or asynchronous read function. The operation is passive, with no associated error code, and triggered by reads.

For close frames, the close reason code may be obtained by calling the function [link beast.ref.boost__beast__websocket__stream.reason `websocket::stream::reason`].

[heading Parameters][table [[Name][Description]]  [[`cb`][    The function object to call, which must be invocable with this equivalent signature: 
``
  void
  callback(
      frame_type kind,       // The type of frame
      string_view payload    // The payload in the frame
  );
``
The implementation type-erases the callback without requiring a dynamic allocation. For this reason, the callback object is passed by a non-constant reference. If the read operation which receives the control frame is an asynchronous operation, the callback will be invoked using the same method as that used to invoke the final handler.  ]]]
[heading Remarks]
It is not necessary to send a close frame upon receipt of a close frame. The implementation does this automatically. Attempting to send a close frame after a close frame is received will result in undefined behavior. 


[endsect][section:overload2 websocket::stream::control_callback (2 of 2 overloads)]
Reset the control frame callback. 
[heading Synopsis]```voidcontrol_callback();```[heading Description]
This function removes any previously set control frame callback. 
[endsect][endsect][section:executor_type websocket::stream::executor_type][indexterm2 executor_type..websocket::stream]
The type of the executor associated with the object. 
[heading Synopsis]```using executor_type = typename next_layer_type::executor_type;```[heading Description][endsect][section:get_executor websocket::stream::get_executor][indexterm2 get_executor..websocket::stream]
Get the executor associated with the object. 
[heading Synopsis]```executor_typeget_executor();```[heading Description]
This function may be used to obtain the executor object that the stream uses to dispatch handlers for asynchronous operations.

[heading Return Value]
A copy of the executor that stream will use to dispatch handlers. 


[endsect][section:get_option websocket::stream::get_option][indexterm2 get_option..websocket::stream]
Get the permessage-deflate extension options. 
[heading Synopsis]```voidget_option(    permessage_deflate& o);```[heading Description][endsect][section:got_binary websocket::stream::got_binary][indexterm2 got_binary..websocket::stream]
Returns `true` if the latest message data indicates binary. 
[heading Synopsis]```boolgot_binary() const;```[heading Description]
This function informs the caller of whether the last received message frame represents a message with the binary opcode.

If there is no last message frame, the return value is undefined. 
[endsect][section:got_text websocket::stream::got_text][indexterm2 got_text..websocket::stream]
Returns `true` if the latest message data indicates text. 
[heading Synopsis]```boolgot_text() const;```[heading Description]
This function informs the caller of whether the last received message frame represents a message with the text opcode.

If there is no last message frame, the return value is undefined. 
[endsect][section:handshake websocket::stream::handshake][indexterm2 handshake..websocket::stream]
Send an HTTP WebSocket Upgrade request and receive the response. 
```void``[link beast.ref.boost__beast__websocket__stream.handshake.overload1 handshake]``(    string_view host,    string_view target);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.handshake.overload1 more...]]``void``[link beast.ref.boost__beast__websocket__stream.handshake.overload2 handshake]``(    response_type& res,    string_view host,    string_view target);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.handshake.overload2 more...]]``void``[link beast.ref.boost__beast__websocket__stream.handshake.overload3 handshake]``(    string_view host,    string_view target,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.handshake.overload3 more...]]``void``[link beast.ref.boost__beast__websocket__stream.handshake.overload4 handshake]``(    response_type& res,    string_view host,    string_view target,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.handshake.overload4 more...]]`````[section:overload1 websocket::stream::handshake (1 of 4 overloads)]
Send an HTTP WebSocket Upgrade request and receive the response. 
[heading Synopsis]```voidhandshake(    string_view host,    string_view target);```[heading Description]
This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:


* The request is sent and the response is received.


* An error occurs on the stream

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").

[heading Parameters][table [[Name][Description]]  [[`host`][    The name of the remote host, required by the HTTP protocol.  ]]  [[`target`][    The Request Target, which may not be empty, required by the HTTP protocol.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.  ]]]
[heading Example]


  websocket::stream<ip::tcp::socket> ws{io_context};
  ...
  try
  {
      ws.handshake("localhost", "/");
  }
  catch(...)
  {
      // An error occurred.
  }





[endsect][section:overload2 websocket::stream::handshake (2 of 4 overloads)]
Send an HTTP WebSocket Upgrade request and receive the response. 
[heading Synopsis]```voidhandshake(    response_type& res,    string_view host,    string_view target);```[heading Description]
This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:


* The request is sent and the response is received.


* An error occurs on the stream

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").

[heading Parameters][table [[Name][Description]]  [[`res`][    The HTTP Upgrade response returned by the remote endpoint.  ]]  [[`host`][    The name of the remote host, required by the HTTP protocol.  ]]  [[`target`][    The Request Target, which may not be empty, required by the HTTP protocol.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.  ]]]
[heading Example]


  websocket::stream<ip::tcp::socket> ws{io_context};
  ...
  try
  {
      response_type res;
      ws.handshake(res, "localhost", "/");
  }
  catch(...)
  {
      // An error occurred.
  }





[endsect][section:overload3 websocket::stream::handshake (3 of 4 overloads)]
Send an HTTP WebSocket Upgrade request and receive the response. 
[heading Synopsis]```voidhandshake(    string_view host,    string_view target,    error_code& ec);```[heading Description]
This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:


* The request is sent and the response is received.


* An error occurs on the stream

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").

[heading Parameters][table [[Name][Description]]  [[`host`][    The name of the remote host, required by the HTTP protocol.  ]]  [[`target`][    The Request Target, which may not be empty, required by the HTTP protocol.  ]]  [[`ec`][    Set to indicate what error occurred, if any.  ]]]
[heading Example]


  websocket::stream<ip::tcp::socket> ws{io_context};
  ...
  error_code ec;
  ws.handshake(host, target, ec);
  if(ec)
  {
      // An error occurred.
  }





[endsect][section:overload4 websocket::stream::handshake (4 of 4 overloads)]
Send an HTTP WebSocket Upgrade request and receive the response. 
[heading Synopsis]```voidhandshake(    response_type& res,    string_view host,    string_view target,    error_code& ec);```[heading Description]
This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:


* The request is sent and the response is received.


* An error occurs on the stream

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").

[heading Parameters][table [[Name][Description]]  [[`res`][    The HTTP Upgrade response returned by the remote endpoint. If `ec` is set, the returned value is undefined.  ]]  [[`host`][    The name of the remote host, required by the HTTP protocol.  ]]  [[`target`][    The Request Target, which may not be empty, required by the HTTP protocol.  ]]  [[`ec`][    Set to indicate what error occurred, if any.  ]]]
[heading Example]


  websocket::stream<ip::tcp::socket> ws{io_context};
  ...
  error_code ec;
  response_type res;
  ws.handshake(res, host, target, ec);
  if(ec)
  {
      // An error occurred.
  }





[endsect][endsect][section:handshake_ex websocket::stream::handshake_ex][indexterm2 handshake_ex..websocket::stream]
Send an HTTP WebSocket Upgrade request and receive the response. 
```template<    class RequestDecorator>void``[link beast.ref.boost__beast__websocket__stream.handshake_ex.overload1 handshake_ex]``(    string_view host,    string_view target,    RequestDecorator const& decorator);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.handshake_ex.overload1 more...]]``template<    class RequestDecorator>void``[link beast.ref.boost__beast__websocket__stream.handshake_ex.overload2 handshake_ex]``(    response_type& res,    string_view host,    string_view target,    RequestDecorator const& decorator);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.handshake_ex.overload2 more...]]``template<    class RequestDecorator>void``[link beast.ref.boost__beast__websocket__stream.handshake_ex.overload3 handshake_ex]``(    string_view host,    string_view target,    RequestDecorator const& decorator,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.handshake_ex.overload3 more...]]``template<    class RequestDecorator>void``[link beast.ref.boost__beast__websocket__stream.handshake_ex.overload4 handshake_ex]``(    response_type& res,    string_view host,    string_view target,    RequestDecorator const& decorator,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.handshake_ex.overload4 more...]]`````[section:overload1 websocket::stream::handshake_ex (1 of 4 overloads)]
Send an HTTP WebSocket Upgrade request and receive the response. 
[heading Synopsis]```template<    class RequestDecorator>voidhandshake_ex(    string_view host,    string_view target,    RequestDecorator const& decorator);```[heading Description]
This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:


* The request is sent and the response is received.


* An error occurs on the stream

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").

[heading Parameters][table [[Name][Description]]  [[`host`][    The name of the remote host, required by the HTTP protocol.  ]]  [[`target`][    The Request Target, which may not be empty, required by the HTTP protocol.  ]]  [[`decorator`][    A function object which will be called to modify the HTTP request object generated by the implementation. This could be used to set the User-Agent field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      request_type& req
  ); 
``
  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.  ]]]
[heading Example]


  websocket::stream<ip::tcp::socket> ws{io_context};
  ...
  try
  {
      ws.handshake("localhost", "/",
          [](request_type& req)
          {
              req.set(field::user_agent, "Beast");
          });
  }
  catch(...)
  {
      // An error occurred.
  }





[endsect][section:overload2 websocket::stream::handshake_ex (2 of 4 overloads)]
Send an HTTP WebSocket Upgrade request and receive the response. 
[heading Synopsis]```template<    class RequestDecorator>voidhandshake_ex(    response_type& res,    string_view host,    string_view target,    RequestDecorator const& decorator);```[heading Description]
This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:


* The request is sent and the response is received.


* An error occurs on the stream

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").

[heading Parameters][table [[Name][Description]]  [[`res`][    The HTTP Upgrade response returned by the remote endpoint.  ]]  [[`host`][    The name of the remote host, required by the HTTP protocol.  ]]  [[`target`][    The Request Target, which may not be empty, required by the HTTP protocol.  ]]  [[`decorator`][    A function object which will be called to modify the HTTP request object generated by the implementation. This could be used to set the User-Agent field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      request_type& req
  ); 
``
  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.  ]]]
[heading Example]


  websocket::stream<ip::tcp::socket> ws{io_context};
  ...
  try
  {
      response_type res;
      ws.handshake(res, "localhost", "/",
          [](request_type& req)
          {
              req.set(field::user_agent, "Beast");
          });
  }
  catch(...)
  {
      // An error occurred.
  }





[endsect][section:overload3 websocket::stream::handshake_ex (3 of 4 overloads)]
Send an HTTP WebSocket Upgrade request and receive the response. 
[heading Synopsis]```template<    class RequestDecorator>voidhandshake_ex(    string_view host,    string_view target,    RequestDecorator const& decorator,    error_code& ec);```[heading Description]
This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:


* The request is sent and the response is received.


* An error occurs on the stream

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").

[heading Parameters][table [[Name][Description]]  [[`host`][    The name of the remote host, required by the HTTP protocol.  ]]  [[`target`][    The Request Target, which may not be empty, required by the HTTP protocol.  ]]  [[`decorator`][    A function object which will be called to modify the HTTP request object generated by the implementation. This could be used to set the User-Agent field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      request_type& req
  ); 
``
  ]]  [[`ec`][    Set to indicate what error occurred, if any.  ]]]
[heading Example]


  websocket::stream<ip::tcp::socket> ws{io_context};
  ...
  error_code ec;
  ws.handshake("localhost", "/",
      [](request_type& req)
      {
          req.set(field::user_agent, "Beast");
      },
      ec);
  if(ec)
  {
      // An error occurred.
  }





[endsect][section:overload4 websocket::stream::handshake_ex (4 of 4 overloads)]
Send an HTTP WebSocket Upgrade request and receive the response. 
[heading Synopsis]```template<    class RequestDecorator>voidhandshake_ex(    response_type& res,    string_view host,    string_view target,    RequestDecorator const& decorator,    error_code& ec);```[heading Description]
This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:


* The request is sent and the response is received.


* An error occurs on the stream

This function is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").

[heading Parameters][table [[Name][Description]]  [[`res`][    The HTTP Upgrade response returned by the remote endpoint.  ]]  [[`host`][    The name of the remote host, required by the HTTP protocol.  ]]  [[`target`][    The Request Target, which may not be empty, required by the HTTP protocol.  ]]  [[`decorator`][    A function object which will be called to modify the HTTP request object generated by the implementation. This could be used to set the User-Agent field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: 
``
   void decorator(
      request_type& req
  ); 
``
  ]]  [[`ec`][    Set to indicate what error occurred, if any.  ]]]
[heading Example]


  websocket::stream<ip::tcp::socket> ws{io_context};
  ...
  error_code ec;
  response_type res;
  ws.handshake(res, "localhost", "/",
      [](request_type& req)
      {
          req.set(field::user_agent, "Beast");
      },
      ec);
  if(ec)
  {
      // An error occurred.
  }





[endsect][endsect][section:is_message_done websocket::stream::is_message_done][indexterm2 is_message_done..websocket::stream]
Returns `true` if the last completed read finished the current message. 
[heading Synopsis]```boolis_message_done() const;```[heading Description][endsect][section:is_open websocket::stream::is_open][indexterm2 is_open..websocket::stream]
Returns `true` if the stream is open. 
[heading Synopsis]```boolis_open() const;```[heading Description]
The stream is open after a successful handshake, and when no error has occurred. 
[endsect][section:lowest_layer websocket::stream::lowest_layer][indexterm2 lowest_layer..websocket::stream]
Get a reference to the lowest layer. 
```lowest_layer_type&``[link beast.ref.boost__beast__websocket__stream.lowest_layer.overload1 lowest_layer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.lowest_layer.overload1 more...]]``lowest_layer_type const&``[link beast.ref.boost__beast__websocket__stream.lowest_layer.overload2 lowest_layer]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.lowest_layer.overload2 more...]]`````[section:overload1 websocket::stream::lowest_layer (1 of 2 overloads)]
Get a reference to the lowest layer. 
[heading Synopsis]```lowest_layer_type&lowest_layer();```[heading Description]
This function returns a reference to the lowest layer in a stack of stream layers.

[heading Return Value]
A reference to the lowest layer in the stack of stream layers. 


[endsect][section:overload2 websocket::stream::lowest_layer (2 of 2 overloads)]
Get a reference to the lowest layer. 
[heading Synopsis]```lowest_layer_type const&lowest_layer() const;```[heading Description]
This function returns a reference to the lowest layer in a stack of stream layers.

[heading Return Value]
A reference to the lowest layer in the stack of stream layers. Ownership is not transferred to the caller. 


[endsect][endsect][section:lowest_layer_type websocket::stream::lowest_layer_type][indexterm2 lowest_layer_type..websocket::stream]
The type of the lowest layer. 
[heading Synopsis]```using lowest_layer_type = typename get_lowest_layer< next_layer_type >::type;```
This will contain a nested `type` equal to `T::lowest_layer_type` if it exists, else `type` will be equal to `T`.

[heading Example]


Declaring a wrapper:



  template<class Stream>
  struct stream_wrapper
  {
      using next_layer_type = typename std::remove_reference<Stream>::type;
      using lowest_layer_type = typename get_lowest_layer<stream_type>::type;
  };




Defining a metafunction:



  template<class T>
  using is_stream_wrapper : std::integral_constant<bool,
      ! std::is_same<T, typename get_lowest_layer<T>::type>::value> {};



[heading Description][endsect][section:next_layer websocket::stream::next_layer][indexterm2 next_layer..websocket::stream]
Get a reference to the next layer. 
```next_layer_type&``[link beast.ref.boost__beast__websocket__stream.next_layer.overload1 next_layer]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.next_layer.overload1 more...]]``next_layer_type const&``[link beast.ref.boost__beast__websocket__stream.next_layer.overload2 next_layer]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.next_layer.overload2 more...]]`````[section:overload1 websocket::stream::next_layer (1 of 2 overloads)]
Get a reference to the next layer. 
[heading Synopsis]```next_layer_type&next_layer();```[heading Description]
This function returns a reference to the next layer in a stack of stream layers.

[heading Return Value]
A reference to the next layer in the stack of stream layers. 


[endsect][section:overload2 websocket::stream::next_layer (2 of 2 overloads)]
Get a reference to the next layer. 
[heading Synopsis]```next_layer_type const&next_layer() const;```[heading Description]
This function returns a reference to the next layer in a stack of stream layers.

[heading Return Value]
A reference to the next layer in the stack of stream layers. 


[endsect][endsect][section:next_layer_type websocket::stream::next_layer_type][indexterm2 next_layer_type..websocket::stream]
The type of the next layer. 
[heading Synopsis]```using next_layer_type = typename std::remove_reference< NextLayer >::type;```[heading Description][endsect][section:operator_eq_ websocket::stream::operator=][indexterm2 operator=..websocket::stream]
Assignment. 
[heading Synopsis]```stream&operator=(    stream&&);```[heading Description]
If `NextLayer` is move assignable, this function will move-assign a new stream from the existing stream.

[heading Remarks]
The behavior of move assignment on or from streams with active or pending operations is undefined. 


[endsect][section:ping websocket::stream::ping][indexterm2 ping..websocket::stream]
Send a WebSocket ping frame. 
```void``[link beast.ref.boost__beast__websocket__stream.ping.overload1 ping]``(    ping_data const& payload);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.ping.overload1 more...]]``void``[link beast.ref.boost__beast__websocket__stream.ping.overload2 ping]``(    ping_data const& payload,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.ping.overload2 more...]]`````[section:overload1 websocket::stream::ping (1 of 2 overloads)]
Send a WebSocket ping frame. 
[heading Synopsis]```voidping(    ping_data const& payload);```[heading Description]
This function is used to synchronously send a ping frame on the stream. The call blocks until one of the following is true:


* The ping frame finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `write_some` functions.

[heading Parameters][table [[Name][Description]]  [[`payload`][    The payload of the ping message, which may be empty.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

[endsect][section:overload2 websocket::stream::ping (2 of 2 overloads)]
Send a WebSocket ping frame. 
[heading Synopsis]```voidping(    ping_data const& payload,    error_code& ec);```[heading Description]
This function is used to synchronously send a ping frame on the stream. The call blocks until one of the following is true:


* The ping frame finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `write_some` functions.

[heading Parameters][table [[Name][Description]]  [[`payload`][    The payload of the ping message, which may be empty.  ]]  [[`ec`][    Set to indicate what error occurred, if any.   ]]]

[endsect][endsect][section:pong websocket::stream::pong][indexterm2 pong..websocket::stream]
Send a WebSocket pong frame. 
```void``[link beast.ref.boost__beast__websocket__stream.pong.overload1 pong]``(    ping_data const& payload);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.pong.overload1 more...]]``void``[link beast.ref.boost__beast__websocket__stream.pong.overload2 pong]``(    ping_data const& payload,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.pong.overload2 more...]]`````[section:overload1 websocket::stream::pong (1 of 2 overloads)]
Send a WebSocket pong frame. 
[heading Synopsis]```voidpong(    ping_data const& payload);```[heading Description]
This function is used to synchronously send a pong frame on the stream. The call blocks until one of the following is true:


* The pong frame finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `write_some` functions.

The WebSocket protocol allows pong frames to be sent from either end at any time. It is not necessary to first receive a ping in order to send a pong. The remote peer may use the receipt of a pong frame as an indication that the connection is not dead.

[heading Parameters][table [[Name][Description]]  [[`payload`][    The payload of the pong message, which may be empty.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

[endsect][section:overload2 websocket::stream::pong (2 of 2 overloads)]
Send a WebSocket pong frame. 
[heading Synopsis]```voidpong(    ping_data const& payload,    error_code& ec);```[heading Description]
This function is used to synchronously send a pong frame on the stream. The call blocks until one of the following is true:


* The pong frame finishes sending.


* An error occurs on the stream.

This function is implemented in terms of one or more calls to the next layer's `write_some` functions.

The WebSocket protocol allows pong frames to be sent from either end at any time. It is not necessary to first receive a ping in order to send a pong. The remote peer may use the receipt of a pong frame as an indication that the connection is not dead.

[heading Parameters][table [[Name][Description]]  [[`payload`][    The payload of the pong message, which may be empty.  ]]  [[`ec`][    Set to indicate what error occurred, if any.   ]]]

[endsect][endsect][section:read websocket::stream::read][indexterm2 read..websocket::stream]
Read a message. 
```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>std::size_t``[link beast.ref.boost__beast__websocket__stream.read.overload1 read]``(    DynamicBuffer& buffer);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read.overload1 more...]]``template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>std::size_t``[link beast.ref.boost__beast__websocket__stream.read.overload2 read]``(    DynamicBuffer& buffer,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read.overload2 more...]]`````[section:overload1 websocket::stream::read (1 of 2 overloads)]
Read a message. 
[heading Synopsis]```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>std::size_tread(    DynamicBuffer& buffer);```[heading Description]
This function is used to synchronously read a complete message from the stream. The call blocks until one of the following is true:


* A complete message is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

Received message data, if any, is appended to the input area of the buffer. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message.

While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:


* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

[heading Return Value]
The number of message payload bytes appended to the buffer.

[heading Parameters][table [[Name][Description]]  [[`buffer`][    A dynamic buffer to hold the message data after any masking or decompression has been applied.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown to indicate an error. The corresponding error code may be retrieved from the exception object for inspection.   ]]]

[endsect][section:overload2 websocket::stream::read (2 of 2 overloads)]
Read a message. 
[heading Synopsis]```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>std::size_tread(    DynamicBuffer& buffer,    error_code& ec);```[heading Description]
This function is used to synchronously read a complete message from the stream. The call blocks until one of the following is true:


* A complete message is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

Received message data, if any, is appended to the input area of the buffer. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message.

While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:


* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

[heading Return Value]
The number of message payload bytes appended to the buffer.

[heading Parameters][table [[Name][Description]]  [[`buffer`][    A dynamic buffer to hold the message data after any masking or decompression has been applied.  ]]  [[`ec`][    Set to indicate what error occurred, if any.   ]]]

[endsect][endsect][section:read_message_max websocket::stream::read_message_max][indexterm2 read_message_max..websocket::stream]
Set the maximum incoming message size option. 
```void``[link beast.ref.boost__beast__websocket__stream.read_message_max.overload1 read_message_max]``(    std::size_t amount);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_message_max.overload1 more...]]`````
Returns the maximum incoming message size setting. 
```std::size_t``[link beast.ref.boost__beast__websocket__stream.read_message_max.overload2 read_message_max]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_message_max.overload2 more...]]`````[section:overload1 websocket::stream::read_message_max (1 of 2 overloads)]
Set the maximum incoming message size option. 
[heading Synopsis]```voidread_message_max(    std::size_t amount);```[heading Description]
Sets the largest permissible incoming message size. Message frame fields indicating a size that would bring the total message size over this limit will cause a protocol failure.

The default setting is 16 megabytes. A value of zero indicates a limit of the maximum value of a `std::uint64_t`.

[heading Example]
Setting the maximum read message size. 

  ws.read_message_max(65536);




[heading Parameters][table [[Name][Description]]  [[`amount`][    The limit on the size of incoming messages.   ]]]

[endsect][section:overload2 websocket::stream::read_message_max (2 of 2 overloads)]
Returns the maximum incoming message size setting. 
[heading Synopsis]```std::size_tread_message_max() const;```[heading Description][endsect][endsect][section:read_size_hint websocket::stream::read_size_hint][indexterm2 read_size_hint..websocket::stream]
Returns a suggested maximum buffer size for the next call to read. 
```std::size_t``[link beast.ref.boost__beast__websocket__stream.read_size_hint.overload1 read_size_hint]``(    std::size_t initial_size = +tcp_frame_size) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_size_hint.overload1 more...]]``template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>std::size_t``[link beast.ref.boost__beast__websocket__stream.read_size_hint.overload2 read_size_hint]``(    DynamicBuffer& buffer) const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_size_hint.overload2 more...]]`````[section:overload1 websocket::stream::read_size_hint (1 of 2 overloads)]
Returns a suggested maximum buffer size for the next call to read. 
[heading Synopsis]```std::size_tread_size_hint(    std::size_t initial_size = +tcp_frame_size) const;```[heading Description]
This function returns a reasonable upper limit on the number of bytes for the size of the buffer passed in the next call to read. The number is determined by the state of the current frame and whether or not the permessage-deflate extension is enabled.

[heading Parameters][table [[Name][Description]]  [[`initial_size`][    A non-zero size representing the caller's desired buffer size for when there is no information which may be used to calculate a more specific value. For example, when reading the first frame header of a message.   ]]]

[endsect][section:overload2 websocket::stream::read_size_hint (2 of 2 overloads)]
Returns a suggested maximum buffer size for the next call to read. 
[heading Synopsis]```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>std::size_tread_size_hint(    DynamicBuffer& buffer) const;```[heading Description]
This function returns a reasonable upper limit on the number of bytes for the size of the buffer passed in the next call to read. The number is determined by the state of the current frame and whether or not the permessage-deflate extension is enabled.

[heading Parameters][table [[Name][Description]]  [[`buffer`][    The buffer which will be used for reading. The implementation will query the buffer to obtain the optimum size of a subsequent call to `buffer.prepare` based on the state of the current frame, if any.   ]]]

[endsect][endsect][section:read_some websocket::stream::read_some][indexterm2 read_some..websocket::stream]
Read part of a message. 
```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>std::size_t``[link beast.ref.boost__beast__websocket__stream.read_some.overload1 read_some]``(    DynamicBuffer& buffer,    std::size_t limit);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_some.overload1 more...]]``template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>std::size_t``[link beast.ref.boost__beast__websocket__stream.read_some.overload2 read_some]``(    DynamicBuffer& buffer,    std::size_t limit,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_some.overload2 more...]]``template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__websocket__stream.read_some.overload3 read_some]``(    MutableBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_some.overload3 more...]]``template<    class __MutableBufferSequence__>std::size_t``[link beast.ref.boost__beast__websocket__stream.read_some.overload4 read_some]``(    MutableBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.read_some.overload4 more...]]`````[section:overload1 websocket::stream::read_some (1 of 4 overloads)]
Read part of a message. 
[heading Synopsis]```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>std::size_tread_some(    DynamicBuffer& buffer,    std::size_t limit);```[heading Description]
This function is used to synchronously read some message data from the stream. The call blocks until one of the following is true:


* Some or all of the message is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

Received message data, if any, is appended to the input area of the buffer. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message. The function [link beast.ref.boost__beast__websocket__stream.is_message_done `websocket::stream::is_message_done`] may be called to determine if the message received by the last read operation is complete.

While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:


* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

[heading Return Value]
The number of message payload bytes appended to the buffer.

[heading Parameters][table [[Name][Description]]  [[`buffer`][    A dynamic buffer to hold the message data after any masking or decompression has been applied.  ]]  [[`limit`][    An upper limit on the number of bytes this function will append into the buffer. If this value is zero, then a reasonable size will be chosen automatically.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown to indicate an error. The corresponding error code may be retrieved from the exception object for inspection.   ]]]

[endsect][section:overload2 websocket::stream::read_some (2 of 4 overloads)]
Read part of a message. 
[heading Synopsis]```template<    class ``[link beast.concepts.DynamicBuffer [*DynamicBuffer]]``>std::size_tread_some(    DynamicBuffer& buffer,    std::size_t limit,    error_code& ec);```[heading Description]
This function is used to synchronously read some message data from the stream. The call blocks until one of the following is true:


* Some or all of the message is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

Received message data, if any, is appended to the input area of the buffer. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message. The function [link beast.ref.boost__beast__websocket__stream.is_message_done `websocket::stream::is_message_done`] may be called to determine if the message received by the last read operation is complete.

While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:


* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

[heading Return Value]
The number of message payload bytes appended to the buffer.

[heading Parameters][table [[Name][Description]]  [[`buffer`][    A dynamic buffer to hold the message data after any masking or decompression has been applied.  ]]  [[`limit`][    An upper limit on the number of bytes this function will append into the buffer. If this value is zero, then a reasonable size will be chosen automatically.  ]]  [[`ec`][    Set to indicate what error occurred, if any.   ]]]

[endsect][section:overload3 websocket::stream::read_some (3 of 4 overloads)]
Read part of a message. 
[heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers);```[heading Description]
This function is used to synchronously read some message data from the stream. The call blocks until one of the following is true:


* Some or all of the message is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

Received message data, if any, is written to the buffer sequence. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message. The function [link beast.ref.boost__beast__websocket__stream.is_message_done `websocket::stream::is_message_done`] may be called to determine if the message received by the last read operation is complete.

While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:


* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

[heading Return Value]
The number of message payload bytes written to the buffer sequence.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    A buffer sequence to hold the message data after any masking or decompression has been applied.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown to indicate an error. The corresponding error code may be retrieved from the exception object for inspection.   ]]]

[endsect][section:overload4 websocket::stream::read_some (4 of 4 overloads)]
Read part of a message. 
[heading Synopsis]```template<    class __MutableBufferSequence__>std::size_tread_some(    MutableBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to synchronously read some message data from the stream. The call blocks until one of the following is true:


* Some or all of the message is received.


* A close frame is received. In this case the error indicated by the function will be [link beast.ref.boost__beast__websocket__error `websocket::closed`].


* An error occurs on the stream.

This operation is implemented in terms of one or more calls to the next layer's `read_some` and `write_some` functions.

Received message data, if any, is written to the buffer sequence. The functions [link beast.ref.boost__beast__websocket__stream.got_binary `websocket::stream::got_binary`] and [link beast.ref.boost__beast__websocket__stream.got_text `websocket::stream::got_text`] may be used to query the stream and determine the type of the last received message. The function [link beast.ref.boost__beast__websocket__stream.is_message_done `websocket::stream::is_message_done`] may be called to determine if the message received by the last read operation is complete.

While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:


* The [link beast.ref.boost__beast__websocket__stream.control_callback `websocket::stream::control_callback`] will be invoked for each control frame.


* For each received ping frame, a pong frame will be automatically sent.


* If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error [link beast.ref.boost__beast__websocket__error `websocket::closed`] will be indicated.

[heading Return Value]
The number of message payload bytes written to the buffer sequence.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    A buffer sequence to hold the message data after any masking or decompression has been applied.  ]]  [[`ec`][    Set to indicate what error occurred, if any.   ]]]

[endsect][endsect][section:reason websocket::stream::reason][indexterm2 reason..websocket::stream]
Returns the close reason received from the peer. 
[heading Synopsis]```close_reason const&reason() const;```[heading Description]
This is only valid after a read completes with [link beast.ref.boost__beast__websocket__error `websocket::closed`]. 
[endsect][section:set_option websocket::stream::set_option][indexterm2 set_option..websocket::stream]
Set the permessage-deflate extension options. 
[heading Synopsis]```voidset_option(    permessage_deflate const& o);```[heading Description][endsect][section:stream websocket::stream::stream][indexterm2 stream..websocket::stream]
Constructor. 
`````[link beast.ref.boost__beast__websocket__stream.stream.overload1 stream]``(    stream&&);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.stream.overload1 more...]]``template<    class... Args>explicit``[link beast.ref.boost__beast__websocket__stream.stream.overload2 stream]``(    Args&&... args);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.stream.overload2 more...]]`````[section:overload1 websocket::stream::stream (1 of 2 overloads)]
Constructor. 
[heading Synopsis]```stream(    stream&&);```[heading Description]
If `NextLayer` is move constructible, this function will move-construct a new stream from the existing stream.

[heading Remarks]
The behavior of move assignment on or from streams with active or pending operations is undefined. 


[endsect][section:overload2 websocket::stream::stream (2 of 2 overloads)]
Constructor. 
[heading Synopsis]```template<    class... Args>stream(    Args&&... args);```[heading Description]
This constructor creates a websocket stream and initializes the next layer object.

[heading Exceptions][table [[Type][Thrown On]]  [[`Any`][    exceptions thrown by the NextLayer constructor.  ]]]
[heading Parameters][table [[Name][Description]]  [[`args`][    The arguments to be passed to initialize the next layer object. The arguments are forwarded to the next layer's constructor.   ]]]

[endsect][endsect][section:text websocket::stream::text][indexterm2 text..websocket::stream]
Set the text message option. 
```void``[link beast.ref.boost__beast__websocket__stream.text.overload1 text]``(    bool value);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.text.overload1 more...]]`````
Returns `true` if the text message option is set. 
```bool``[link beast.ref.boost__beast__websocket__stream.text.overload2 text]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.text.overload2 more...]]`````[section:overload1 websocket::stream::text (1 of 2 overloads)]
Set the text message option. 
[heading Synopsis]```voidtext(    bool value);```[heading Description]
This controls whether or not outgoing message opcodes are set to binary or text. The setting is only applied at the start when a caller begins a new message. Changing the opcode after a message is started will only take effect after the current message being sent is complete.

The default setting is to send text messages.

[heading Parameters][table [[Name][Description]]  [[`value`][    `true` if outgoing messages should indicate text, or `false` if they should indicate binary.  ]]]
[heading Example]
Setting the message type to text. 

  ws.text(true);





[endsect][section:overload2 websocket::stream::text (2 of 2 overloads)]
Returns `true` if the text message option is set. 
[heading Synopsis]```booltext() const;```[heading Description][endsect][endsect][section:write websocket::stream::write][indexterm2 write..websocket::stream]
Write a message to the stream. 
```template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__websocket__stream.write.overload1 write]``(    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.write.overload1 more...]]``template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__websocket__stream.write.overload2 write]``(    ConstBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.write.overload2 more...]]`````[section:overload1 websocket::stream::write (1 of 2 overloads)]
Write a message to the stream. 
[heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite(    ConstBufferSequence const& buffers);```[heading Description]
This function is used to synchronously write a message to the stream. The call blocks until one of the following conditions is met:


* The entire message is sent.


* An error occurs.

This operation is implemented in terms of one or more calls to the next layer's `write_some` function.

The current setting of the [link beast.ref.boost__beast__websocket__stream.binary `websocket::stream::binary`] option controls whether the message opcode is set to text or binary. If the [link beast.ref.boost__beast__websocket__stream.auto_fragment `websocket::stream::auto_fragment`] option is set, the message will be split into one or more frames as necessary. The actual payload contents sent may be transformed as per the WebSocket protocol settings.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    The buffers containing the entire message payload. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by buffers remains valid until the completion handler is called.  ]]]
[heading Return Value]
The number of bytes written from the buffers. If an error occurred, this will be less than the sum of the buffer sizes.

[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.  ]]]
[heading Remarks]
This function always sends an entire message. To send a message in fragments, use [link beast.ref.boost__beast__websocket__stream.write_some `websocket::stream::write_some`]. 


[endsect][section:overload2 websocket::stream::write (2 of 2 overloads)]
Write a message to the stream. 
[heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite(    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to synchronously write a message to the stream. The call blocks until one of the following conditions is met:


* The entire message is sent.


* An error occurs.

This operation is implemented in terms of one or more calls to the next layer's `write_some` function.

The current setting of the [link beast.ref.boost__beast__websocket__stream.binary `websocket::stream::binary`] option controls whether the message opcode is set to text or binary. If the [link beast.ref.boost__beast__websocket__stream.auto_fragment `websocket::stream::auto_fragment`] option is set, the message will be split into one or more frames as necessary. The actual payload contents sent may be transformed as per the WebSocket protocol settings.

[heading Parameters][table [[Name][Description]]  [[`buffers`][    The buffers containing the entire message payload. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by buffers remains valid until the completion handler is called.  ]]]
[heading Return Value]
The number of bytes written from the buffers. If an error occurred, this will be less than the sum of the buffer sizes.

[heading Parameters][table [[Name][Description]]  [[`ec`][    Set to indicate what error occurred, if any.  ]]]
[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.  ]]]
[heading Remarks]
This function always sends an entire message. To send a message in fragments, use [link beast.ref.boost__beast__websocket__stream.write_some `websocket::stream::write_some`]. 


[endsect][endsect][section:write_buffer_size websocket::stream::write_buffer_size][indexterm2 write_buffer_size..websocket::stream]
Set the write buffer size option. 
```void``[link beast.ref.boost__beast__websocket__stream.write_buffer_size.overload1 write_buffer_size]``(    std::size_t amount);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.write_buffer_size.overload1 more...]]`````
Returns the size of the write buffer. 
```std::size_t``[link beast.ref.boost__beast__websocket__stream.write_buffer_size.overload2 write_buffer_size]``() const;  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.write_buffer_size.overload2 more...]]`````[section:overload1 websocket::stream::write_buffer_size (1 of 2 overloads)]
Set the write buffer size option. 
[heading Synopsis]```voidwrite_buffer_size(    std::size_t amount);```[heading Description]
Sets the size of the write buffer used by the implementation to send frames. The write buffer is needed when masking payload data in the client role, compressing frames, or auto-fragmenting message data.

Lowering the size of the buffer can decrease the memory requirements for each connection, while increasing the size of the buffer can reduce the number of calls made to the next layer to write data.

The default setting is 4096. The minimum value is 8.

The write buffer size can only be changed when the stream is not open. Undefined behavior results if the option is modified after a successful WebSocket handshake.

[heading Example]
Setting the write buffer size. 

  ws.write_buffer_size(8192);




[heading Parameters][table [[Name][Description]]  [[`amount`][    The size of the write buffer in bytes.   ]]]

[endsect][section:overload2 websocket::stream::write_buffer_size (2 of 2 overloads)]
Returns the size of the write buffer. 
[heading Synopsis]```std::size_twrite_buffer_size() const;```[heading Description][endsect][endsect][section:write_some websocket::stream::write_some][indexterm2 write_some..websocket::stream]
Write partial message data on the stream. 
```template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__websocket__stream.write_some.overload1 write_some]``(    bool fin,    ConstBufferSequence const& buffers);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.write_some.overload1 more...]]``template<    class __ConstBufferSequence__>std::size_t``[link beast.ref.boost__beast__websocket__stream.write_some.overload2 write_some]``(    bool fin,    ConstBufferSequence const& buffers,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream.write_some.overload2 more...]]`````[section:overload1 websocket::stream::write_some (1 of 2 overloads)]
Write partial message data on the stream. 
[heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    bool fin,    ConstBufferSequence const& buffers);```[heading Description]
This function is used to write some or all of a message's payload to the stream. The call will block until one of the following conditions is true:


* A frame is sent.


* Message data is transferred to the write buffer.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.

If this is the beginning of a new message, the message opcode will be set to text or binary as per the current setting of the [link beast.ref.boost__beast__websocket__stream.binary `websocket::stream::binary`] option. The actual payload sent may be transformed as per the WebSocket protocol settings.

[heading Parameters][table [[Name][Description]]  [[`fin`][    `true` if this is the last part of the message.  ]]  [[`buffers`][    The input buffer sequence holding the data to write.  ]]]
[heading Return Value]
The number of bytes written from the buffers. If an error occurred, this will be less than the sum of the buffer sizes.

[heading Exceptions][table [[Type][Thrown On]]  [[`system_error`][    Thrown on failure.   ]]]

[endsect][section:overload2 websocket::stream::write_some (2 of 2 overloads)]
Write partial message data on the stream. 
[heading Synopsis]```template<    class __ConstBufferSequence__>std::size_twrite_some(    bool fin,    ConstBufferSequence const& buffers,    error_code& ec);```[heading Description]
This function is used to write some or all of a message's payload to the stream. The call will block until one of the following conditions is true:


* A frame is sent.


* Message data is transferred to the write buffer.


* An error occurs.

This operation is implemented in terms of one or more calls to the stream's `write_some` function.

If this is the beginning of a new message, the message opcode will be set to text or binary as per the current setting of the [link beast.ref.boost__beast__websocket__stream.binary `websocket::stream::binary`] option. The actual payload sent may be transformed as per the WebSocket protocol settings.

[heading Parameters][table [[Name][Description]]  [[`fin`][    `true` if this is the last part of the message.  ]]  [[`buffers`][    The input buffer sequence holding the data to write.  ]]  [[`ec`][    Set to indicate what error occurred, if any.  ]]]
[heading Return Value]
The number of bytes written from the buffers. If an error occurred, this will be less than the sum of the buffer sizes.

The number of bytes consumed in the input buffers. 


[endsect][endsect][section:stream_dtor_ websocket::stream::~stream][indexterm2 ~stream..websocket::stream]
Destructor. 
[heading Synopsis]```~stream();```[heading Description]
Destroys the stream and all associated resources.

[heading Remarks]
A stream object must not be destroyed while there are pending asynchronous operations associated with it. 


[endsect]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__accept_op websocket::stream::accept_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    class,    class>class accept_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__close_op websocket::stream::close_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    class>class close_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__fail_op websocket::stream::fail_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    class>class fail_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__handshake_op websocket::stream::handshake_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    class>class handshake_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__op websocket::stream::op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```struct op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__ping_op websocket::stream::ping_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    class>class ping_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__pmd_t websocket::stream::pmd_t][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```struct pmd_t```[heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__stream__pmd_t.rd_set [*rd_set]]]    [          ]  ]  [    [[link beast.ref.boost__beast__websocket__stream__pmd_t.zi [*zi]]]    [          ]  ]  [    [[link beast.ref.boost__beast__websocket__stream__pmd_t.zo [*zo]]]    [          ]  ]][heading Description][section:rd_set websocket::stream::pmd_t::rd_set][indexterm2 rd_set..websocket::stream::pmd_t][heading Synopsis]```bool rd_set = false;```[heading Description][endsect][section:zi websocket::stream::pmd_t::zi][indexterm2 zi..websocket::stream::pmd_t][heading Synopsis]```zlib::inflate_stream zi;```[heading Description][endsect][section:zo websocket::stream::pmd_t::zo][indexterm2 zo..websocket::stream::pmd_t][heading Synopsis]```zlib::deflate_stream zo;```[heading Description][endsect]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__read_fh_op websocket::stream::read_fh_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    class>class read_fh_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__read_op websocket::stream::read_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    class,    class>class read_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__read_some_op websocket::stream::read_some_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    class,    class>class read_some_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__response_op websocket::stream::response_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    class>class response_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__token websocket::stream::token][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```class token```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__websocket__stream__token.operator_bool [*operator bool]]]    [          ]  ]  [    [[link beast.ref.boost__beast__websocket__stream__token.operator_not__eq_ [*operator!=]]]    [          ]  ]  [    [[link beast.ref.boost__beast__websocket__stream__token.operator_eq__eq_ [*operator==]]]    [          ]  ]  [    [[link beast.ref.boost__beast__websocket__stream__token.reset [*reset]]]    [          ]  ]  [    [[link beast.ref.boost__beast__websocket__stream__token.token [*token]]]    [          ]  ]  [    [[link beast.ref.boost__beast__websocket__stream__token.unique [*unique]]]    [          ]  ]][heading Description][section:operator_bool websocket::stream::token::operator bool][indexterm2 operator bool..websocket::stream::token][heading Synopsis]```operator bool() const;```[heading Description][endsect][section:operator_not__eq_ websocket::stream::token::operator!=][indexterm2 operator!=..websocket::stream::token][heading Synopsis]```booloperator!=(    token const& t);```[heading Description][endsect][section:operator_eq__eq_ websocket::stream::token::operator==][indexterm2 operator==..websocket::stream::token][heading Synopsis]```booloperator==(    token const& t);```[heading Description][endsect][section:reset websocket::stream::token::reset][indexterm2 reset..websocket::stream::token][heading Synopsis]```voidreset();```[heading Description][endsect][section:token websocket::stream::token::token][indexterm2 token..websocket::stream::token]`````[link beast.ref.boost__beast__websocket__stream__token.token.overload1 token]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream__token.token.overload1 more...]]````[link beast.ref.boost__beast__websocket__stream__token.token.overload2 token]``(    token const&);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream__token.token.overload2 more...]]``explicit``[link beast.ref.boost__beast__websocket__stream__token.token.overload3 token]``(    unsigned char id);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__stream__token.token.overload3 more...]]`````[section:overload1 websocket::stream::token::token (1 of 3 overloads)][heading Synopsis]```token();```[heading Description][endsect][section:overload2 websocket::stream::token::token (2 of 3 overloads)][heading Synopsis]```token(    token const&);```[heading Description][endsect][section:overload3 websocket::stream::token::token (3 of 3 overloads)][heading Synopsis]```token(    unsigned char id);```[heading Description][endsect][endsect][section:unique websocket::stream::token::unique][indexterm2 unique..websocket::stream::token][heading Synopsis]```tokenunique();```[heading Description][endsect]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__write_op websocket::stream::write_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    class,    class>class write_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__stream__write_some_op websocket::stream::write_some_op][heading Synopsis]Defined in header [include_file boost/beast/websocket/stream.hpp]```template<    class,    class>class write_some_op```[heading Description]Convenience header [include_file boost/beast/websocket.hpp][endsect][section:boost__beast__websocket__teardown websocket::teardown][indexterm1 websocket::teardown]
Tear down a `boost::asio::ssl::stream`. 
```template<    class ``[link beast.concepts.streams.SyncStream [*SyncStream]]``>void``[link beast.ref.boost__beast__websocket__teardown.overload1 teardown]``(    role_type role,    boost::asio::ssl::stream< SyncStream >& stream,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__teardown.overload1 more...]]`````
Tear down a connection. 
```template<    class Socket>void``[link beast.ref.boost__beast__websocket__teardown.overload2 teardown]``(    role_type role,    Socket& socket,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__teardown.overload2 more...]]`````
Tear down a `boost::asio::ip::tcp::socket`. 
```void``[link beast.ref.boost__beast__websocket__teardown.overload3 teardown]``(    role_type role,    boost::asio::ip::tcp::socket& socket,    error_code& ec);  ``[''''&raquo;''' [link beast.ref.boost__beast__websocket__teardown.overload3 more...]]`````[section:overload1 websocket::teardown (1 of 3 overloads)]
Tear down a `boost::asio::ssl::stream`. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/ssl.hpp]```template<    class ``[link beast.concepts.streams.SyncStream [*SyncStream]]``>voidteardown(    role_type role,    boost::asio::ssl::stream< SyncStream >& stream,    error_code& ec);```[heading Description]
This tears down a connection. The implementation will call the overload of this function based on the `Stream` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`, callers are responsible for providing a suitable overload of this function.

[heading Parameters][table [[Name][Description]]  [[`role`][    The role of the local endpoint  ]]  [[`stream`][    The stream to tear down.  ]]  [[`ec`][    Set to the error if any occurred.   ]]]

Convenience header [include_file boost/beast/websocket.hpp][endsect][section:overload2 websocket::teardown (2 of 3 overloads)]
Tear down a connection. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/teardown.hpp]```template<    class Socket>voidteardown(    role_type role,    Socket& socket,    error_code& ec);```[heading Description]
This tears down a connection. The implementation will call the overload of this function based on the `Socket` parameter used to consruct the socket. When `Socket` is a user defined type, and not a `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`, callers are responsible for providing a suitable overload of this function.

[heading Parameters][table [[Name][Description]]  [[`role`][    The role of the local endpoint  ]]  [[`socket`][    The socket to tear down.  ]]  [[`ec`][    Set to the error if any occurred.   ]]]

Convenience header [include_file boost/beast/websocket.hpp][endsect][section:overload3 websocket::teardown (3 of 3 overloads)]
Tear down a `boost::asio::ip::tcp::socket`. 
[heading Synopsis]Defined in header [include_file boost/beast/websocket/teardown.hpp]```voidteardown(    role_type role,    boost::asio::ip::tcp::socket& socket,    error_code& ec);```[heading Description]
This tears down a connection. The implementation will call the overload of this function based on the `Stream` parameter used to consruct the socket. When `Stream` is a user defined type, and not a `boost::asio::ip::tcp::socket` or any `boost::asio::ssl::stream`, callers are responsible for providing a suitable overload of this function.

[heading Parameters][table [[Name][Description]]  [[`role`][    The role of the local endpoint  ]]  [[`socket`][    The socket to tear down.  ]]  [[`ec`][    Set to the error if any occurred.   ]]]

Convenience header [include_file boost/beast/websocket.hpp][endsect][endsect][section:boost__beast__zlib__Byte zlib::Byte][indexterm1 zlib::Byte][heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```using Byte = unsigned char;```Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__Flush zlib::Flush][indexterm1 zlib::Flush]
Flush option. 
[heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```enum Flush```[indexterm2 none..zlib::Flush][indexterm2 block..zlib::Flush][indexterm2 partial..zlib::Flush][indexterm2 sync..zlib::Flush][indexterm2 full..zlib::Flush][indexterm2 finish..zlib::Flush][indexterm2 trees..zlib::Flush][heading Values][table [[Name][Description]]  [[[^none]][]]  [[[^block]][]]  [[[^partial]][]]  [[[^sync]][]]  [[[^full]][]]  [[[^finish]][]]  [[[^trees]][]]][heading Description]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__Strategy zlib::Strategy][indexterm1 zlib::Strategy]
Compression strategy. 
[heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```enum Strategy```[indexterm2 normal..zlib::Strategy][indexterm2 filtered..zlib::Strategy][indexterm2 huffman..zlib::Strategy][indexterm2 rle..zlib::Strategy][indexterm2 fixed..zlib::Strategy][heading Values][table [[Name][Description]]  [[[^normal]][Default strategy. This is suitable for general purpose compression, and works well in the majority of cases. ]]  [[[^filtered]][Filtered strategy. This strategy should be used when the data be compressed is produced by a filter or predictor. ]]  [[[^huffman]][Huffman-only strategy. This strategy only performs Huffman encoding, without doing any string matching. ]]  [[[^rle]][Run Length Encoding strategy. This strategy limits match distances to one, making it equivalent to run length encoding. This can give better performance for things like PNG image data. ]]  [[[^fixed]][Fixed table strategy. This strategy prevents the use of dynamic Huffman codes, allowing for a simpler decoder for special applications. ]]][heading Description]
These are used when compressing streams. 
Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__compression zlib::compression][indexterm1 zlib::compression][heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```enum compression```[indexterm2 none..zlib::compression][indexterm2 none..zlib::compression][indexterm2 best_speed..zlib::compression][indexterm2 best_size..zlib::compression][indexterm2 default_size..zlib::compression][heading Values][table [[Name][Description]]  [[[^none]][]]  [[[^none]][]]  [[[^best_speed]][]]  [[[^best_size]][]]  [[[^default_size]][]]][heading Description]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__deflate_stream zlib::deflate_stream]
Raw deflate compressor. 
[heading Synopsis]Defined in header [include_file boost/beast/zlib/deflate_stream.hpp]```class deflate_stream :    private deflate_stream```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.clear [*clear]]]    [      Clear the stream.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.deflate_stream [*deflate_stream]]]    [      Construct a default deflate stream.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.params [*params]]]    [      Update the compression level and strategy.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.pending [*pending]]]    [      Return bits pending in the output.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.prime [*prime]]]    [      Insert bits into the compressed output stream.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.reset [*reset]]]    [      Reset the stream and compression settings.       Reset the stream without deallocating memory.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.tune [*tune]]]    [      Fine tune internal compression parameters.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.upper_bound [*upper_bound]]]    [      Returns the upper limit on the size of a compressed block.     ]  ]  [    [[link beast.ref.boost__beast__zlib__deflate_stream.write [*write]]]    [      Compress input and write output.     ]  ]][heading Description]
This is a port of zlib's "deflate" functionality to C++. 
[section:clear zlib::deflate_stream::clear][indexterm2 clear..zlib::deflate_stream]
Clear the stream. 
[heading Synopsis]```voidclear();```[heading Description]
This function resets the stream and frees all dynamically allocated internal buffers. The compression settings are left unchanged.

[heading Remarks]
Any unprocessed input or pending output from previous calls are discarded. 


[endsect][section:deflate_stream zlib::deflate_stream::deflate_stream][indexterm2 deflate_stream..zlib::deflate_stream]
Construct a default deflate stream. 
[heading Synopsis]```deflate_stream();```[heading Description]
Upon construction, the stream settings will be set to these default values:


* `level = 6`


* `windowBits = 15`


* `memLevel = 8`


* `strategy = Strategy::normal`

Although the stream is ready to be used immediately after construction, any required internal buffers are not dynamically allocated until needed. 
[endsect][section:params zlib::deflate_stream::params][indexterm2 params..zlib::deflate_stream]
Update the compression level and strategy. 
[heading Synopsis]```voidparams(    z_params& zs,    int level,    Strategy strategy,    error_code& ec);```[heading Description]
This function dynamically updates the compression level and compression strategy. The interpretation of level and strategy is as in [link beast.ref.boost__beast__zlib__deflate_stream.reset `zlib::deflate_stream::reset`]. This can be used to switch between compression and straight copy of the input data, or to switch to a different kind of input data requiring a different strategy. If the compression level is changed, the input available so far is compressed with the old level (and may be flushed); the new level will take effect only at the next call of [link beast.ref.boost__beast__zlib__deflate_stream.write `zlib::deflate_stream::write`].

Before the call of `params`, the stream state must be set as for a call of [link beast.ref.boost__beast__zlib__deflate_stream.write `zlib::deflate_stream::write`], since the currently available input may have to be compressed and flushed. In particular, `zs.avail_out` must be non-zero.

[heading Return Value]
`Z_OK` if success, `Z_STREAM_ERROR` if the source stream state was inconsistent or if a parameter was invalid, `error::need_buffers` if `zs.avail_out` was zero. 


[endsect][section:pending zlib::deflate_stream::pending][indexterm2 pending..zlib::deflate_stream]
Return bits pending in the output. 
[heading Synopsis]```voidpending(    unsigned* value,    int* bits);```[heading Description]
This function returns the number of bytes and bits of output that have been generated, but not yet provided in the available output. The bytes not provided would be due to the available output space having being consumed. The number of bits of output not provided are between 0 and 7, where they await more bits to join them in order to fill out a full byte. If pending or bits are `nullptr`, then those values are not set.

[heading Return Value]
`Z_OK` if success, or `Z_STREAM_ERROR` if the source stream state was inconsistent. 


[endsect][section:prime zlib::deflate_stream::prime][indexterm2 prime..zlib::deflate_stream]
Insert bits into the compressed output stream. 
[heading Synopsis]```voidprime(    int bits,    int value,    error_code& ec);```[heading Description]
This function inserts bits in the deflate output stream. The intent is that this function is used to start off the deflate output with the bits leftover from a previous deflate stream when appending to it. As such, this function can only be used for raw deflate, and must be used before the first `write` call after an initialization. `bits` must be less than or equal to 16, and that many of the least significant bits of `value` will be inserted in the output.

[heading Return Value]
`error::need_buffers` if there was not enough room in the internal buffer to insert the bits. 


[endsect][section:reset zlib::deflate_stream::reset][indexterm2 reset..zlib::deflate_stream]
Reset the stream and compression settings. 
```void``[link beast.ref.boost__beast__zlib__deflate_stream.reset.overload1 reset]``(    int level,    int windowBits,    int memLevel,    Strategy strategy);  ``[''''&raquo;''' [link beast.ref.boost__beast__zlib__deflate_stream.reset.overload1 more...]]`````
Reset the stream without deallocating memory. 
```void``[link beast.ref.boost__beast__zlib__deflate_stream.reset.overload2 reset]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__zlib__deflate_stream.reset.overload2 more...]]`````[section:overload1 zlib::deflate_stream::reset (1 of 2 overloads)]
Reset the stream and compression settings. 
[heading Synopsis]```voidreset(    int level,    int windowBits,    int memLevel,    Strategy strategy);```[heading Description]
This function initializes the stream to the specified compression settings.

Although the stream is ready to be used immediately after a reset, any required internal buffers are not dynamically allocated until needed.

[heading Remarks]
Any unprocessed input or pending output from previous calls are discarded. 


[endsect][section:overload2 zlib::deflate_stream::reset (2 of 2 overloads)]
Reset the stream without deallocating memory. 
[heading Synopsis]```voidreset();```[heading Description]
This function performs the equivalent of calling `clear` followed by `reset` with the same compression settings, without deallocating the internal buffers.

[heading Remarks]
Any unprocessed input or pending output from previous calls are discarded. 


[endsect][endsect][section:tune zlib::deflate_stream::tune][indexterm2 tune..zlib::deflate_stream]
Fine tune internal compression parameters. 
[heading Synopsis]```voidtune(    int good_length,    int max_lazy,    int nice_length,    int max_chain);```[heading Description]
Compression parameters should only be tuned by someone who understands the algorithm used by zlib's deflate for searching for the best matching string, and even then only by the most fanatic optimizer trying to squeeze out the last compressed bit for their specific input data. Read the deflate.c source code (ZLib) for the meaning of the max\_lazy, good\_length, nice\_length, and max\_chain parameters. 
[endsect][section:upper_bound zlib::deflate_stream::upper_bound][indexterm2 upper_bound..zlib::deflate_stream]
Returns the upper limit on the size of a compressed block. 
[heading Synopsis]```std::size_tupper_bound(    std::size_t sourceLen) const;```[heading Description]
This function makes a conservative estimate of the maximum number of bytes needed to store the result of compressing a block of data based on the current compression level and strategy.

[heading Parameters][table [[Name][Description]]  [[`sourceLen`][    The size of the uncompressed data.  ]]]
[heading Return Value]
The maximum number of resulting compressed bytes. 


[endsect][section:write zlib::deflate_stream::write][indexterm2 write..zlib::deflate_stream]
Compress input and write output. 
[heading Synopsis]```voidwrite(    z_params& zs,    Flush flush,    error_code& ec);```[heading Description]
This function compresses as much data as possible, and stops when the input buffer becomes empty or the output buffer becomes full. It may introduce some output latency (reading input without producing any output) except when forced to flush.

In each call, one or both of these actions are performed:


* Compress more input starting at `zs.next_in` and update `zs.next_in` and `zs.avail_in` accordingly. If not all input can be processed (because there is not enough room in the output buffer), `zs.next_in` and `zs.avail_in` are updated and processing will resume at this point for the next call.


* Provide more output starting at `zs.next_out` and update `zs.next_out` and `zs.avail_out` accordingly. This action is forced if the parameter flush is not `Flush::none`. Forcing flush frequently degrades the compression ratio, so this parameter should be set only when necessary (in interactive applications). Some output may be provided even if flush is not set.

Before the call, the application must ensure that at least one of the actions is possible, by providing more input and/or consuming more output, and updating `zs.avail_in` or `zs.avail_out` accordingly; `zs.avail_out` should never be zero before the call. The application can consume the compressed output when it wants, for example when the output buffer is full (`zs.avail_out == 0`), or after each call of `write`. If `write` returns no error with zero `zs.avail_out`, it must be called again after making room in the output buffer because there might be more output pending.

Normally the parameter flush is set to `Flush::none`, which allows deflate to decide how much data to accumulate before producing output, in order to maximize compression.

If the parameter flush is set to `Flush::sync`, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. In particular `zs.avail_in` is zero after the call if enough output space has been provided before the call. Flushing may degrade compression for some compression algorithms and so it should be used only when necessary. This completes the current deflate block and follows it with an empty stored block that is three bits plus filler bits to the next byte, followed by the four bytes `{ 0x00, 0x00 0xff 0xff }`.

If flush is set to `Flush::partial`, all pending output is flushed to the output buffer, but the output is not aligned to a byte boundary. All of the input data so far will be available to the decompressor, as for Z\_SYNC\_FLUSH. This completes the current deflate block and follows it with an empty fixed codes block that is 10 bits long. This assures that enough bytes are output in order for the decompressor to finish the block before the empty fixed code block.

If flush is set to `Flush::block`, a deflate block is completed and emitted, as for `Flush::sync`, but the output is not aligned on a byte boundary, and up to seven bits of the current block are held to be written as the next byte after the next deflate block is completed. In this case, the decompressor may not be provided enough bits at this point in order to complete decompression of the data provided so far to the compressor. It may need to wait for the next block to be emitted. This is for advanced applications that need to control the emission of deflate blocks.

If flush is set to `Flush::full`, all output is flushed as with `Flush::sync`, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using `Flush::full` too often can seriously degrade compression.

If `write` returns with `zs.avail_out == 0`, this function must be called again with the same value of the flush parameter and more output space (updated `zs.avail_out`), until the flush is complete (`write` returns with non-zero `zs.avail_out`). In the case of a `Flush::full`or `Flush::sync`, make sure that `zs.avail_out` is greater than six to avoid repeated flush markers due to `zs.avail_out == 0` on return.

If the parameter flush is set to `Flush::finish`, pending input is processed, pending output is flushed and deflate returns the error `error::end_of_stream` if there was enough output space; if deflate returns with no error, this function must be called again with `Flush::finish` and more output space (updated `zs.avail_out`) but no more input data, until it returns the error `error::end_of_stream` or another error. After `write` has returned the `error::end_of_stream` error, the only possible operations on the stream are to reset or destroy.

`Flush::finish` can be used immediately after initialization if all the compression is to be done in a single step. In this case, `zs.avail_out` must be at least value returned by `upper_bound` (see below). Then `write` is guaranteed to return the `error::end_of_stream` error. If not enough output space is provided, deflate will not return `error::end_of_stream`, and it must be called again as described above.

`write` returns no error if some progress has been made (more input processed or more output produced), `error::end_of_stream` if all input has been consumed and all output has been produced (only when flush is set to `Flush::finish`), `error::stream_error` if the stream state was inconsistent (for example if `zs.next_in` or `zs.next_out` was `nullptr`), `error::need_buffers` if no progress is possible (for example `zs.avail_in` or `zs.avail_out` was zero). Note that `error::need_buffers` is not fatal, and `write` can be called again with more input and more output space to continue compressing. 
[endsect]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__deflate_upper_bound zlib::deflate_upper_bound][indexterm1 zlib::deflate_upper_bound]
Returns the upper limit on the size of a compressed block. 
[heading Synopsis]Defined in header [include_file boost/beast/zlib/deflate_stream.hpp]```std::size_tdeflate_upper_bound(    std::size_t bytes);```[heading Description]
This function makes a conservative estimate of the maximum number of bytes needed to store the result of compressing a block of data.

[heading Parameters][table [[Name][Description]]  [[`bytes`][    The size of the uncompressed data.  ]]]
[heading Return Value]
The maximum number of resulting compressed bytes. 


Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__error zlib::error][indexterm1 zlib::error]
Error codes returned by the codec. 
[heading Synopsis]Defined in header [include_file boost/beast/zlib/error.hpp]```enum error```[indexterm2 need_buffers..zlib::error][indexterm2 end_of_stream..zlib::error][indexterm2 stream_error..zlib::error][indexterm2 invalid_block_type..zlib::error][indexterm2 invalid_stored_length..zlib::error][indexterm2 too_many_symbols..zlib::error][indexterm2 invalid_code_lenths..zlib::error][indexterm2 invalid_bit_length_repeat..zlib::error][indexterm2 missing_eob..zlib::error][indexterm2 invalid_literal_length..zlib::error][indexterm2 invalid_distance_code..zlib::error][indexterm2 invalid_distance..zlib::error][indexterm2 over_subscribed_length..zlib::error][indexterm2 incomplete_length_set..zlib::error][indexterm2 general..zlib::error][heading Values][table [[Name][Description]]  [[[^need_buffers]][Additional buffers are required. This error indicates that one or both of the buffers provided buffers do not have sufficient available bytes to make forward progress.This does not always indicate a failure condition.This is the same as Z_BUF_ERROR returned by ZLib. 
]]  [[[^end_of_stream]][End of stream reached. This is the same as Z_STREAM_END returned by ZLib. 
]]  [[[^stream_error]][Invalid stream or parameters. This error is returned when invalid parameters are passed, or the operation being performed is not consistent with the state of the stream. For example, attempting to write data when the end of stream is already reached.This is the same as Z_STREAM_ERROR returned by ZLib. 
]]  [[[^invalid_block_type]][Invalid block type. ]]  [[[^invalid_stored_length]][Invalid stored block length. ]]  [[[^too_many_symbols]][Too many length or distance symbols. ]]  [[[^invalid_code_lenths]][Invalid code lengths. ]]  [[[^invalid_bit_length_repeat]][Invalid bit length repeat. ]]  [[[^missing_eob]][Missing end of block code. ]]  [[[^invalid_literal_length]][Invalid literal/length code. ]]  [[[^invalid_distance_code]][Invalid distance code. ]]  [[[^invalid_distance]][Invalid distance too far back. ]]  [[[^over_subscribed_length]][Over-subscribed length code. ]]  [[[^incomplete_length_set]][Incomplete length set. ]]  [[[^general]][general error ]]][heading Description]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__inflate_stream zlib::inflate_stream]
Raw deflate stream decompressor. 
[heading Synopsis]Defined in header [include_file boost/beast/zlib/inflate_stream.hpp]```class inflate_stream :    private inflate_stream```[heading Member Functions][table [[Name][Description]]  [    [[link beast.ref.boost__beast__zlib__inflate_stream.clear [*clear]]]    [      Put the stream in a newly constructed state.     ]  ]  [    [[link beast.ref.boost__beast__zlib__inflate_stream.inflate_stream [*inflate_stream]]]    [      Construct a raw deflate decompression stream.     ]  ]  [    [[link beast.ref.boost__beast__zlib__inflate_stream.reset [*reset]]]    [      Reset the stream.     ]  ]  [    [[link beast.ref.boost__beast__zlib__inflate_stream.write [*write]]]    [      Decompress input and produce output.     ]  ]][heading Description]
This implements a raw deflate stream decompressor. The deflate protocol is a compression protocol described in "DEFLATE Compressed Data Format Specification version 1.3" located here: [@https://tools.ietf.org/html/rfc1951 https://tools.ietf.org/html/rfc1951]

The implementation is a refactored port to C++ of ZLib's "inflate". A more detailed description of ZLib is at [@http://zlib.net/ http://zlib.net/].

Compression can be done in a single step if the buffers are large enough (for example if an input file is memory mapped), or can be done by repeated calls of the compression function. In the latter case, the application must provide more input and/or consume the output (providing more output space) before each call. 
[section:clear zlib::inflate_stream::clear][indexterm2 clear..zlib::inflate_stream]
Put the stream in a newly constructed state. 
[heading Synopsis]```voidclear();```[heading Description]
All dynamically allocated memory is de-allocated. 
[endsect][section:inflate_stream zlib::inflate_stream::inflate_stream][indexterm2 inflate_stream..zlib::inflate_stream]
Construct a raw deflate decompression stream. 
[heading Synopsis]```inflate_stream();```[heading Description]
The window size is set to the default of 15 bits. 
[endsect][section:reset zlib::inflate_stream::reset][indexterm2 reset..zlib::inflate_stream]
Reset the stream. 
```void``[link beast.ref.boost__beast__zlib__inflate_stream.reset.overload1 reset]``();  ``[''''&raquo;''' [link beast.ref.boost__beast__zlib__inflate_stream.reset.overload1 more...]]``void``[link beast.ref.boost__beast__zlib__inflate_stream.reset.overload2 reset]``(    int windowBits);  ``[''''&raquo;''' [link beast.ref.boost__beast__zlib__inflate_stream.reset.overload2 more...]]`````[section:overload1 zlib::inflate_stream::reset (1 of 2 overloads)]
Reset the stream. 
[heading Synopsis]```voidreset();```[heading Description]
This puts the stream in a newly constructed state with the previously specified window size, but without de-allocating any dynamically created structures. 
[endsect][section:overload2 zlib::inflate_stream::reset (2 of 2 overloads)]
Reset the stream. 
[heading Synopsis]```voidreset(    int windowBits);```[heading Description]
This puts the stream in a newly constructed state with the specified window size, but without de-allocating any dynamically created structures. 
[endsect][endsect][section:write zlib::inflate_stream::write][indexterm2 write..zlib::inflate_stream]
Decompress input and produce output. 
[heading Synopsis]```voidwrite(    z_params& zs,    Flush flush,    error_code& ec);```[heading Description]
This function decompresses as much data as possible, and stops when the input buffer becomes empty or the output buffer becomes full. It may introduce some output latency (reading input without producing any output) except when forced to flush.

One or both of the following actions are performed:


* Decompress more input starting at `zs.next_in` and update `zs.next_in` and `zs.avail_in` accordingly. If not all input can be processed (because there is not enough room in the output buffer), `zs.next_in` is updated and processing will resume at this point for the next call.


* Provide more output starting at `zs.next_out` and update `zs.next_out` and `zs.avail_out` accordingly. `write` provides as much output as possible, until there is no more input data or no more space in the output buffer (see below about the flush parameter).

Before the call, the application should ensure that at least one of the actions is possible, by providing more input and/or consuming more output, and updating the values in `zs` accordingly. The application can consume the uncompressed output when it wants, for example when the output buffer is full (`zs.avail_out == 0`), or after each call. If `write` returns no error and with zero `zs.avail_out`, it must be called again after making room in the output buffer because there might be more output pending.

The flush parameter may be `Flush::none`, `Flush::sync`, `Flush::finish`, `Flush::block`, or `Flush::trees`. `Flush::sync` requests to flush as much output as possible to the output buffer. `Flush::block` requests to stop if and when it gets to the next deflate block boundary. When decoding the zlib or gzip format, this will cause `write` to return immediately after the header and before the first block. When doing a raw inflate, `write` will go ahead and process the first block, and will return when it gets to the end of that block, or when it runs out of data.

The `Flush::block` option assists in appending to or combining deflate streams. Also to assist in this, on return `write` will set `zs.data_type` to the number of unused bits in the last byte taken from `zs.next_in`, plus 64 if `write` is currently decoding the last block in the deflate stream, plus 128 if `write` returned immediately after decoding an end-of-block code or decoding the complete header up to just before the first byte of the deflate stream. The end-of-block will not be indicated until all of the uncompressed data from that block has been written to `zs.next_out`. The number of unused bits may in general be greater than seven, except when bit 7 of `zs.data_type` is set, in which case the number of unused bits will be less than eight. `zs.data_type` is set as noted here every time `write` returns for all flush options, and so can be used to determine the amount of currently consumed input in bits.

The `Flush::trees` option behaves as `Flush::block` does, but it also returns when the end of each deflate block header is reached, before any actual data in that block is decoded. This allows the caller to determine the length of the deflate block header for later use in random access within a deflate block. 256 is added to the value of `zs.data_type` when `write` returns immediately after reaching the end of the deflate block header.

`write` should normally be called until it returns `error::end_of_stream` or another error. However if all decompression is to be performed in a single step (a single call of `write`), the parameter flush should be set to `Flush::finish`. In this case all pending input is processed and all pending output is flushed; `zs.avail_out` must be large enough to hold all of the uncompressed data for the operation to complete. (The size of the uncompressed data may have been saved by the compressor for this purpose.) The use of `Flush::finish` is not required to perform an inflation in one step. However it may be used to inform inflate that a faster approach can be used for the single call. `Flush::finish` also informs inflate to not maintain a sliding window if the stream completes, which reduces inflate's memory footprint. If the stream does not complete, either because not all of the stream is provided or not enough output space is provided, then a sliding window will be allocated and `write` can be called again to continue the operation as if `Flush::none` had been used.

In this implementation, `write` always flushes as much output as possible to the output buffer, and always uses the faster approach on the first call. So the effects of the flush parameter in this implementation are on the return value of `write` as noted below, when `write` returns early when `Flush::block` or `Flush::trees` is used, and when `write` avoids the allocation of memory for a sliding window when `Flush::finsih` is used.

If a preset dictionary is needed after this call, `write` sets `zs.adler` to the Adler-32 checksum of the dictionary chosen by the compressor and returns `error::need_dictionary`; otherwise it sets `zs.adler` to the Adler-32 checksum of all output produced so far (that is, `zs.total_out bytes`) and returns no error, `error::end_of_stream`, or an error code as described below. At the end of the stream, `write` checks that its computed adler32 checksum is equal to that saved by the compressor and returns `error::end_of_stream` only if the checksum is correct.

This function returns no error if some progress has been made (more input processed or more output produced), `error::end_of_stream` if the end of the compressed data has been reached and all uncompressed output has been produced, `error::need_dictionary` if a preset dictionary is needed at this point, `error::invalid_data` if the input data was corrupted (input stream not conforming to the zlib format or incorrect check value), `error::stream_error` if the stream structure was inconsistent (for example if `zs.next_in` or `zs.next_out` was null), `error::need_buffers` if no progress is possible or if there was not enough room in the output buffer when `Flush::finish` is used. Note that `error::need_buffers` is not fatal, and `write` can be called again with more input and more output space to continue decompressing. 
[endsect]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__kind zlib::kind][indexterm1 zlib::kind][heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```enum kind```[indexterm2 binary..zlib::kind][indexterm2 text..zlib::kind][indexterm2 unknown..zlib::kind][heading Values][table [[Name][Description]]  [[[^binary]][]]  [[[^text]][]]  [[[^unknown]][]]][heading Description]Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__uInt zlib::uInt][indexterm1 zlib::uInt][heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```using uInt = unsigned int;```Convenience header [include_file boost/beast/zlib.hpp][endsect][section:boost__beast__zlib__z_params zlib::z_params]
Deflate codec parameters. 
[heading Synopsis]Defined in header [include_file boost/beast/zlib/zlib.hpp]```struct z_params```[heading Data Members][table [[Name][Description]]  [    [[link beast.ref.boost__beast__zlib__z_params.avail_in [*avail_in]]]    [      The number of bytes of input available at next_in.     ]  ]  [    [[link beast.ref.boost__beast__zlib__z_params.avail_out [*avail_out]]]    [      The remaining bytes of space at next_out.     ]  ]  [    [[link beast.ref.boost__beast__zlib__z_params.data_type [*data_type]]]    [          ]  ]  [    [[link beast.ref.boost__beast__zlib__z_params.next_in [*next_in]]]    [      A pointer to the next input byte.     ]  ]  [    [[link beast.ref.boost__beast__zlib__z_params.next_out [*next_out]]]    [      A pointer to the next output byte.     ]  ]  [    [[link beast.ref.boost__beast__zlib__z_params.total_in [*total_in]]]    [      The total number of input bytes read so far.     ]  ]  [    [[link beast.ref.boost__beast__zlib__z_params.total_out [*total_out]]]    [      The total number of bytes output so far.     ]  ]][heading Description]
Objects of this type are filled in by callers and provided to the deflate codec to define the input and output areas for the next compress or decompress operation.

The application must update next\_in and avail\_in when avail\_in has dropped to zero. It must update next\_out and avail\_out when avail\_out has dropped to zero. The application must initialize zalloc, zfree and opaque before calling the init function. All other fields are set by the compression library and must not be updated by the application.

The fields total\_in and total\_out can be used for statistics or progress reports. After compression, total\_in holds the total size of the uncompressed data and may be saved for use in the decompressor (particularly if the decompressor wants to decompress everything in a single step). 
[section:avail_in zlib::z_params::avail_in][indexterm2 avail_in..zlib::z_params]
The number of bytes of input available at `next_in`. 
[heading Synopsis]```std::size_t avail_in;```[heading Description]
If there is no more input, this should be set to zero. 
[endsect][section:avail_out zlib::z_params::avail_out][indexterm2 avail_out..zlib::z_params]
The remaining bytes of space at `next_out`. 
[heading Synopsis]```std::size_t avail_out;```[heading Description][endsect][section:data_type zlib::z_params::data_type][indexterm2 data_type..zlib::z_params][heading Synopsis]```int data_type = unknown;```[heading Description][endsect][section:next_in zlib::z_params::next_in][indexterm2 next_in..zlib::z_params]
A pointer to the next input byte. 
[heading Synopsis]```void const * next_in;```[heading Description]
If there is no more input, this may be set to `nullptr`. 
[endsect][section:next_out zlib::z_params::next_out][indexterm2 next_out..zlib::z_params]
A pointer to the next output byte. 
[heading Synopsis]```void * next_out;```[heading Description][endsect][section:total_in zlib::z_params::total_in][indexterm2 total_in..zlib::z_params]
The total number of input bytes read so far. 
[heading Synopsis]```std::size_t total_in = 0;```[heading Description][endsect][section:total_out zlib::z_params::total_out][indexterm2 total_out..zlib::z_params]
The total number of bytes output so far. 
[heading Synopsis]```std::size_t total_out = 0;```[heading Description][endsect]Convenience header [include_file boost/beast/zlib.hpp][endsect]