<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>websocket::stream::async_read_some (2 of 2 overloads)</title>
<link rel="stylesheet" href="../../../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../../../index.html" title="Chapter&#160;1.&#160;Boost.Beast">
<link rel="up" href="../async_read_some.html" title="websocket::stream::async_read_some">
<link rel="prev" href="overload1.html" title="websocket::stream::async_read_some (1 of 2 overloads)">
<link rel="next" href="../async_write.html" title="websocket::stream::async_write">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="overload1.html"><img src="../../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../async_read_some.html"><img src="../../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../../index.html"><img src="../../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../async_write.html"><img src="../../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h6 class="title">
<a name="beast.ref.boost__beast__websocket__stream.async_read_some.overload2"></a><a class="link" href="overload2.html" title="websocket::stream::async_read_some (2 of 2 overloads)">websocket::stream::async_read_some
          (2 of 2 overloads)</a>
</h6></div></div></div>
<p>
            Read part of a message asynchronously.
          </p>
<h7><a name="beast.ref.boost__beast__websocket__stream.async_read_some.overload2.h0"></a>
            <span class="phrase"><a name="beast.ref.boost__beast__websocket__stream.async_read_some.overload2.synopsis"></a></span><a class="link" href="overload2.html#beast.ref.boost__beast__websocket__stream.async_read_some.overload2.synopsis">Synopsis</a>
          </h7><pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span>
    <span class="keyword">class</span> <a href="../../../../../../../../doc/html/boost_asio/reference/MutableBufferSequence.html" target="_top"><span class="bold"><strong>MutableBufferSequence</strong></span></a><span class="special">,</span>
    <span class="keyword">class</span> <a href="../../../../../../../../doc/html/boost_asio/reference/ReadHandler.html" target="_top"><span class="bold"><strong>ReadHandler</strong></span></a><span class="special">&gt;</span>
<a href="http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/reference/asynchronous_operations.html#boost_asio.reference.asynchronous_operations.return_type_of_an_initiating_function" target="_top"><span class="emphasis"><em>void-or-deduced</em></span></a>
<span class="identifier">async_read_some</span><span class="special">(</span>
    <span class="identifier">MutableBufferSequence</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">buffers</span><span class="special">,</span>
    <span class="identifier">ReadHandler</span><span class="special">&amp;&amp;</span> <span class="identifier">handler</span><span class="special">);</span>
</pre>
<h7><a name="beast.ref.boost__beast__websocket__stream.async_read_some.overload2.h1"></a>
            <span class="phrase"><a name="beast.ref.boost__beast__websocket__stream.async_read_some.overload2.description"></a></span><a class="link" href="overload2.html#beast.ref.boost__beast__websocket__stream.async_read_some.overload2.description">Description</a>
          </h7><p>
            This function is used to asynchronously read part of a message from the
            stream. The function call always returns immediately. The asynchronous
            operation will continue until one of the following is true:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                Some or all of the message is received.
              </li>
<li class="listitem">
                A close frame is received. In this case the error indicated by the
                function will be <a class="link" href="../../boost__beast__websocket__error.html" title="websocket::error"><code class="computeroutput"><span class="identifier">websocket</span><span class="special">::</span><span class="identifier">closed</span></code></a>.
              </li>
<li class="listitem">
                An error occurs on the stream.
              </li>
</ul></div>
<p>
            This operation is implemented in terms of one or more calls to the next
            layer's <code class="computeroutput"><span class="identifier">async_read_some</span></code>
            and <code class="computeroutput"><span class="identifier">async_write_some</span></code>
            functions, and is known as a <span class="emphasis"><em>composed operation</em></span>.
            The program must ensure that the stream performs no other reads until
            this operation completes.
          </p>
<p>
            Received message data, if any, is written to the buffer sequence. The
            functions <a class="link" href="../got_binary.html" title="websocket::stream::got_binary"><code class="computeroutput"><span class="identifier">websocket</span><span class="special">::</span><span class="identifier">stream</span><span class="special">::</span><span class="identifier">got_binary</span></code></a> and <a class="link" href="../got_text.html" title="websocket::stream::got_text"><code class="computeroutput"><span class="identifier">websocket</span><span class="special">::</span><span class="identifier">stream</span><span class="special">::</span><span class="identifier">got_text</span></code></a> may be used to query
            the stream and determine the type of the last received message. The function
            <a class="link" href="../is_message_done.html" title="websocket::stream::is_message_done"><code class="computeroutput"><span class="identifier">websocket</span><span class="special">::</span><span class="identifier">stream</span><span class="special">::</span><span class="identifier">is_message_done</span></code></a> may be called
            to determine if the message received by the last read operation is complete.
          </p>
<p>
            While this operation is active, the implementation will read incoming
            control frames and handle them automatically as follows:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
                The <a class="link" href="../control_callback.html" title="websocket::stream::control_callback"><code class="computeroutput"><span class="identifier">websocket</span><span class="special">::</span><span class="identifier">stream</span><span class="special">::</span><span class="identifier">control_callback</span></code></a> will be
                invoked for each control frame.
              </li>
<li class="listitem">
                For each received ping frame, a pong frame will be automatically
                sent.
              </li>
<li class="listitem">
                If a close frame is received, the WebSocket close procedure is performed.
                In this case, when the function returns, the error <a class="link" href="../../boost__beast__websocket__error.html" title="websocket::error"><code class="computeroutput"><span class="identifier">websocket</span><span class="special">::</span><span class="identifier">closed</span></code></a> will be indicated.
              </li>
</ul></div>
<p>
            Because of the need to handle control frames, asynchronous read operations
            can cause writes to take place. These writes are managed transparently;
            callers can still have one active asynchronous read and asynchronous
            write operation pending simultaneously (a user initiated call to <a class="link" href="../async_close.html" title="websocket::stream::async_close"><code class="computeroutput"><span class="identifier">websocket</span><span class="special">::</span><span class="identifier">stream</span><span class="special">::</span><span class="identifier">async_close</span></code></a> counts as a write).
          </p>
<h7><a name="beast.ref.boost__beast__websocket__stream.async_read_some.overload2.h2"></a>
            <span class="phrase"><a name="beast.ref.boost__beast__websocket__stream.async_read_some.overload2.parameters"></a></span><a class="link" href="overload2.html#beast.ref.boost__beast__websocket__stream.async_read_some.overload2.parameters">Parameters</a>
          </h7><div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      Name
                    </p>
                  </th>
<th>
                    <p>
                      Description
                    </p>
                  </th>
</tr></thead>
<tbody>
<tr>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">buffers</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      The buffer sequence into which message data will be placed
                      after any masking or decompresison has been applied. The implementation
                      will make copies of this object as needed, but ownership of
                      the underlying memory is not transferred. The caller is responsible
                      for ensuring that the memory locations pointed to by the buffer
                      sequence remains valid until the completion handler is called.
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">handler</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      The handler to be called when the read operation completes.
                      Copies will be made of the handler as required. The equivalent
                      function signature of the handler must be:
                    </p>
<pre xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" class="table-programlisting"><span class="keyword">void</span> <span class="identifier">handler</span><span class="special">(</span>
    <span class="identifier">error_code</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">ec</span><span class="special">,</span>       <span class="comment">// Result of operation</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">bytes_written</span>   <span class="comment">// Number of bytes written to the buffer sequence</span>
<span class="special">);</span>
</pre>
                    <p>
                      Regardless of whether the asynchronous operation completes
                      immediately or not, the handler will not be invoked from within
                      this function. Invocation of the handler will be performed
                      in a manner equivalent to using <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">asio</span><span class="special">::</span><span class="identifier">io_context</span><span class="special">::</span><span class="identifier">post</span></code>.
                    </p>
                  </td>
</tr>
</tbody>
</table></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016, 2017 Vinnie Falco<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="overload1.html"><img src="../../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../async_read_some.html"><img src="../../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../../../index.html"><img src="../../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../async_write.html"><img src="../../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
