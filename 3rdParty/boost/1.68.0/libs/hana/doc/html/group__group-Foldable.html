<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Boost.Hana: Foldable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.5.0</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group-Foldable.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Foldable<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The <code>Foldable</code> concept represents data structures that can be reduced to a single value. </p>
<p>Generally speaking, folding refers to the concept of summarizing a complex structure as a single value, by successively applying a binary operation which reduces two elements of the structure to a single value. Folds come in many flavors; left folds, right folds, folds with and without an initial reduction state, and their monadic variants. This concept is able to express all of these fold variants.</p>
<p>Another way of seeing <code>Foldable</code> is as data structures supporting internal iteration with the ability to accumulate a result. By internal iteration, we mean that the <em>loop control</em> is in the hand of the structure, not the caller. Hence, it is the structure who decides when the iteration stops, which is normally when the whole structure has been consumed. Since C++ is an eager language, this requires <code>Foldable</code> structures to be finite, or otherwise one would need to loop indefinitely to consume the whole structure.</p>
<dl class="section note"><dt>Note</dt><dd>While the fact that <code>Foldable</code> only works for finite structures may seem overly restrictive in comparison to the Haskell definition of <code>Foldable</code>, a finer grained separation of the concepts should mitigate the issue. For iterating over possibly infinite data structures, see the <code>Iterable</code> concept. For searching a possibly infinite data structure, see the <code>Searchable</code> concept.</dd></dl>
<h2>Minimal complete definition </h2>
<p><code>fold_left</code> or <code>unpack</code></p>
<p>However, please note that a minimal complete definition provided through <code>unpack</code> will be much more compile-time efficient than one provided through <code>fold_left</code>.</p>
<h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1map.html" title="Basic associative container requiring unique, Comparable and Hashable keys. ">hana::map</a></code>, <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code>, <code><a class="el" href="structboost_1_1hana_1_1pair.html" title="Generic container for two elements. ">hana::pair</a></code>, <code><a class="el" href="structboost_1_1hana_1_1set.html" title="Basic unordered container requiring unique, Comparable and Hashable keys. ">hana::set</a></code>, <code><a class="el" href="structboost_1_1hana_1_1range.html" title="Compile-time half-open interval of hana::integral_constants. ">hana::range</a></code>, <code><a class="el" href="structboost_1_1hana_1_1tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">hana::tuple</a></code></p>
<p><a class="anchor" id="Foldable-lin"></a></p><h2>The linearization of a <code>Foldable</code> </h2>
<p>Intuitively, for a <code>Foldable</code> structure <code>xs</code>, the <em>linearization</em> of <code>xs</code> is the sequence of all the elements in <code>xs</code> as if they had been put in a list: </p><div class="fragment"><div class="line">linearization(xs) = [x1, x2, ..., xn]</div></div><!-- fragment --><p>Note that it is always possible to produce such a linearization for a finite <code>Foldable</code> by setting </p><div class="fragment"><div class="line">linearization(xs) = <a class="code" href="group__group-Foldable.html#ga38c6b3f6b1cbadb9b8432a05ff16b7d2">fold_left</a>(xs, [], <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(<a class="code" href="group__group-MonadPlus.html#ga69afbfd4e91125e3e52fcb409135ca7c">prepend</a>))</div></div><!-- fragment --><p> for an appropriate definition of <code>[]</code> and <code>prepend</code>. The notion of linearization is useful for expressing various properties of <code>Foldable</code> structures, and is used across the documentation. Also note that <code>Iterable</code>s define an <a class="el" href="group__group-Iterable.html#Iterable-lin">extended version</a> of this allowing for infinite structures.</p>
<h2>Compile-time Foldables </h2>
<p>A compile-time <code>Foldable</code> is a <code>Foldable</code> whose total length is known at compile-time. In other words, it is a <code>Foldable</code> whose <code>length</code> method returns a <code>Constant</code> of an unsigned integral type. When folding a compile-time <code>Foldable</code>, the folding can be unrolled, because the final number of steps of the algorithm is known at compile-time.</p>
<p>Additionally, the <code>unpack</code> method is only available to compile-time <code>Foldable</code>s. This is because the return <em>type</em> of <code>unpack</code> depends on the number of objects in the structure. Being able to resolve <code>unpack</code>'s return type at compile-time hence requires the length of the structure to be known at compile-time too.</p>
<p><b>In the current version of the library, only compile-time <code>Foldable</code>s are supported.</b> While it would be possible in theory to support runtime <code>Foldable</code>s too, doing so efficiently requires more research.</p>
<h2>Provided conversion to <code>Sequence</code>s </h2>
<p>Given a tag <code>S</code> which is a <code>Sequence</code>, an object whose tag is a model of the <code>Foldable</code> concept can be converted to an object of tag <code>S</code>. In other words, a <code>Foldable</code> can be converted to a <code>Sequence</code> <code>S</code>, by simply taking the linearization of the <code>Foldable</code> and creating the sequence with that. More specifically, given a <code>Foldable</code> <code>xs</code> with a linearization of <code>[x1, ..., xn]</code> and a <code>Sequence</code> tag <code>S</code>, <code>to&lt;S&gt;(xs)</code> is equivalent to <code>make&lt;S&gt;(x1, ..., xn)</code>. </p><div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="core_2to_8hpp.html">boost/hana/core/to.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="range_8hpp.html">boost/hana/range.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    static_assert(hana::to&lt;hana::tuple_tag&gt;(hana::just(1)) == hana::make_tuple(1), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(hana::to&lt;hana::tuple_tag&gt;(hana::nothing) == hana::make_tuple());</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        hana::to&lt;hana::tuple_tag&gt;(hana::make_range(hana::int_c&lt;3&gt;, hana::int_c&lt;6&gt;))</div><div class="line">            ==</div><div class="line">        hana::tuple_c&lt;int, 3, 4, 5&gt;</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --><h2>Free model for builtin arrays </h2>
<p>Builtin arrays whose size is known can be folded as-if they were homogeneous tuples. However, note that builtin arrays can't be made more than <code>Foldable</code> (e.g. <code>Iterable</code>) because they can't be empty and they also can't be returned from functions.</p>
<p><a class="anchor" id="monadic-folds"></a></p><h2>Primer on monadic folds </h2>
<p>A monadic fold is a fold in which subsequent calls to the binary function are chained with the monadic <code>chain</code> operator of the corresponding Monad. This allows a structure to be folded in a custom monadic context. For example, performing a monadic fold with the <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code> monad would require the binary function to return the result as a <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code>, and the fold would abort and return <code>nothing</code> whenever one of the accumulation step would fail (i.e. return <code>nothing</code>). If, however, all the reduction steps succeed, then <code>just</code> the result would be returned. Different monads will of course result in different effects. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3159cfa41be18a396926741b0a3fdefd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#ga3159cfa41be18a396926741b0a3fdefd">boost::hana::count</a></td></tr>
<tr class="memdesc:ga3159cfa41be18a396926741b0a3fdefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the structure that compare equal to a given value.Given a Foldable structure <code>xs</code> and a value <code>value</code>, <code>count</code> returns an unsigned integral, or a Constant thereof, representing the number of elements of <code>xs</code> that compare equal to <code>value</code>. For this method to be well-defined, all the elements of the structure must be Comparable with the given value.  <a href="group__group-Foldable.html#ga3159cfa41be18a396926741b0a3fdefd">More...</a><br /></td></tr>
<tr class="separator:ga3159cfa41be18a396926741b0a3fdefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d71be65d5b98e7d035a3e5c607e1b4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#ga39d71be65d5b98e7d035a3e5c607e1b4">boost::hana::count_if</a></td></tr>
<tr class="memdesc:ga39d71be65d5b98e7d035a3e5c607e1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in the structure for which the <code>predicate</code> is satisfied.Specifically, returns an object of an unsigned integral type, or a <code>Constant</code> holding such an object, which represents the number of elements in the structure satisfying the given <code>predicate</code>.  <a href="group__group-Foldable.html#ga39d71be65d5b98e7d035a3e5c607e1b4">More...</a><br /></td></tr>
<tr class="separator:ga39d71be65d5b98e7d035a3e5c607e1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0fde17f3b947a0678a1c0c01232f2cc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#gaa0fde17f3b947a0678a1c0c01232f2cc">boost::hana::fold</a> = fold_left</td></tr>
<tr class="memdesc:gaa0fde17f3b947a0678a1c0c01232f2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>fold_left</code>; provided for convenience.<code>fold</code> is equivalent to <code>fold_left</code>. However, it is not tag-dispatched on its own because it is just an alias to <code>fold_left</code>. Also note that <code>fold</code> can be called with or without an initial state, just like <code>fold_left</code>:  <a href="group__group-Foldable.html#gaa0fde17f3b947a0678a1c0c01232f2cc">More...</a><br /></td></tr>
<tr class="separator:gaa0fde17f3b947a0678a1c0c01232f2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c6b3f6b1cbadb9b8432a05ff16b7d2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#ga38c6b3f6b1cbadb9b8432a05ff16b7d2">boost::hana::fold_left</a></td></tr>
<tr class="memdesc:ga38c6b3f6b1cbadb9b8432a05ff16b7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-fold of a structure using a binary operation and an optional initial reduction state.<code>fold_left</code> is a left-associative fold using a binary operation. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and an optional initial state, <code>fold_left</code> applies <code>f</code> as follows.  <a href="group__group-Foldable.html#ga38c6b3f6b1cbadb9b8432a05ff16b7d2">More...</a><br /></td></tr>
<tr class="separator:ga38c6b3f6b1cbadb9b8432a05ff16b7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77d43badebd59b046cf93598733649b4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#ga77d43badebd59b046cf93598733649b4">boost::hana::fold_right</a></td></tr>
<tr class="memdesc:ga77d43badebd59b046cf93598733649b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-fold of a structure using a binary operation and an optional initial reduction state.<code>fold_right</code> is a right-associative fold using a binary operation. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and an optional initial state, <code>fold_right</code> applies <code>f</code> as follows.  <a href="group__group-Foldable.html#ga77d43badebd59b046cf93598733649b4">More...</a><br /></td></tr>
<tr class="separator:ga77d43badebd59b046cf93598733649b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2af382f7e644ce3707710bbad313e9c2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#ga2af382f7e644ce3707710bbad313e9c2">boost::hana::for_each</a></td></tr>
<tr class="memdesc:ga2af382f7e644ce3707710bbad313e9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an action on each element of a foldable, discarding the result each time.Iteration is done from left to right, i.e. in the same order as when using <code>fold_left</code>. If the structure is not finite, this method will not terminate.  <a href="group__group-Foldable.html#ga2af382f7e644ce3707710bbad313e9c2">More...</a><br /></td></tr>
<tr class="separator:ga2af382f7e644ce3707710bbad313e9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19fcf61d8d1179903952c0f564c538aa"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#ga19fcf61d8d1179903952c0f564c538aa">boost::hana::fuse</a></td></tr>
<tr class="memdesc:ga19fcf61d8d1179903952c0f564c538aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a function taking multiple arguments into a function that can be called with a compile-time <code>Foldable</code>.  <a href="group__group-Foldable.html#ga19fcf61d8d1179903952c0f564c538aa">More...</a><br /></td></tr>
<tr class="separator:ga19fcf61d8d1179903952c0f564c538aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0f8f717245620dc28cd7d7fa44d7475"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">boost::hana::length</a></td></tr>
<tr class="memdesc:gaf0f8f717245620dc28cd7d7fa44d7475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in a foldable structure.Given a <code>Foldable</code> <code>xs</code>, <code>length(xs)</code> must return an object of an unsigned integral type, or an <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="The IntegralConstant concept represents compile-time integral values. ">IntegralConstant</a></code> holding such an object, which represents the number of elements in the structure.  <a href="group__group-Foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">More...</a><br /></td></tr>
<tr class="separator:gaf0f8f717245620dc28cd7d7fa44d7475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3861a91607203b63a12708e18a4eac5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#gaf3861a91607203b63a12708e18a4eac5">boost::hana::maximum</a></td></tr>
<tr class="memdesc:gaf3861a91607203b63a12708e18a4eac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>.Given a non-empty structure and an optional binary predicate (<code>less</code> by default), <code>maximum</code> returns the greatest element of the structure, i.e. an element which is greater than or equal to every other element in the structure, according to the predicate.  <a href="group__group-Foldable.html#gaf3861a91607203b63a12708e18a4eac5">More...</a><br /></td></tr>
<tr class="separator:gaf3861a91607203b63a12708e18a4eac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga347429451fdb15f9f7a7fc0de293be1a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#ga347429451fdb15f9f7a7fc0de293be1a">boost::hana::minimum</a></td></tr>
<tr class="memdesc:ga347429451fdb15f9f7a7fc0de293be1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>.Given a non-empty structure and an optional binary predicate (<code>less</code> by default), <code>minimum</code> returns the least element of the structure, i.e. an element which is less than or equal to every other element in the structure, according to the predicate.  <a href="group__group-Foldable.html#ga347429451fdb15f9f7a7fc0de293be1a">More...</a><br /></td></tr>
<tr class="separator:ga347429451fdb15f9f7a7fc0de293be1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14edbff755244aa02b57a6383dcebc6"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gac14edbff755244aa02b57a6383dcebc6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#gac14edbff755244aa02b57a6383dcebc6">boost::hana::monadic_fold_left</a></td></tr>
<tr class="memdesc:gac14edbff755244aa02b57a6383dcebc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monadic left-fold of a structure with a binary operation and an optional initial reduction state.  <a href="group__group-Foldable.html#gac14edbff755244aa02b57a6383dcebc6">More...</a><br /></td></tr>
<tr class="separator:gac14edbff755244aa02b57a6383dcebc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa058d91f3e1294f0d3c71bedf33e2360"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:gaa058d91f3e1294f0d3c71bedf33e2360"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#gaa058d91f3e1294f0d3c71bedf33e2360">boost::hana::monadic_fold_right</a></td></tr>
<tr class="memdesc:gaa058d91f3e1294f0d3c71bedf33e2360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monadic right-fold of a structure with a binary operation and an optional initial reduction state.  <a href="group__group-Foldable.html#gaa058d91f3e1294f0d3c71bedf33e2360">More...</a><br /></td></tr>
<tr class="separator:gaa058d91f3e1294f0d3c71bedf33e2360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17fe9c1982c882807f3358b4138c5744"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#ga17fe9c1982c882807f3358b4138c5744">boost::hana::product</a> = see documentation</td></tr>
<tr class="memdesc:ga17fe9c1982c882807f3358b4138c5744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of the numbers of a structure.More generally, <code>product</code> will take any foldable structure containing objects forming a Ring and reduce them using the Ring's binary operation. The initial state for folding is the identity of the Ring's operation. It is sometimes necessary to specify the Ring to use; this is possible by using <code>product&lt;R&gt;</code>. If no Ring is specified, the structure will use the Ring formed by the elements it contains (if it knows it), or <code><a class="el" href="structboost_1_1hana_1_1integral__constant__tag.html" title="Tag representing hana::integral_constant. ">integral_constant_tag</a>&lt;int&gt;</code> otherwise. Hence,.  <a href="group__group-Foldable.html#ga17fe9c1982c882807f3358b4138c5744">More...</a><br /></td></tr>
<tr class="separator:ga17fe9c1982c882807f3358b4138c5744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947602718a53bd7fcd5c20477694cdcd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#ga947602718a53bd7fcd5c20477694cdcd">boost::hana::reverse_fold</a></td></tr>
<tr class="memdesc:ga947602718a53bd7fcd5c20477694cdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>reverse_fold</code> in Boost.Fusion and Boost.MPL.This method has the same semantics as <code>reverse_fold</code> in Boost.Fusion and Boost.MPL, with the extension that an initial state is not required. This method is equivalent to <code>fold_right</code>, except that the accumulating function must take its arguments in reverse order, to match the order used in Fusion. In other words,.  <a href="group__group-Foldable.html#ga947602718a53bd7fcd5c20477694cdcd">More...</a><br /></td></tr>
<tr class="separator:ga947602718a53bd7fcd5c20477694cdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ec3ac9a6f5014db943f61ebc9e1e36e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#ga8ec3ac9a6f5014db943f61ebc9e1e36e">boost::hana::size</a> = hana::length</td></tr>
<tr class="memdesc:ga8ec3ac9a6f5014db943f61ebc9e1e36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>length</code>; provided for consistency with the standard library.This method is an alias to <code>length</code> provided for convenience and consistency with the standard library. As an alias, <code>size</code> is not tag-dispatched on its own and <code>length</code> should be customized instead.  <a href="group__group-Foldable.html#ga8ec3ac9a6f5014db943f61ebc9e1e36e">More...</a><br /></td></tr>
<tr class="separator:ga8ec3ac9a6f5014db943f61ebc9e1e36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga650def4b2e98f4273d8b9b7aa5a2fc28"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#ga650def4b2e98f4273d8b9b7aa5a2fc28">boost::hana::sum</a> = see documentation</td></tr>
<tr class="memdesc:ga650def4b2e98f4273d8b9b7aa5a2fc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sum of the numbers of a structure.More generally, <code>sum</code> will take any foldable structure containing objects forming a Monoid and reduce them using the Monoid's binary operation. The initial state for folding is the identity of the Monoid. It is sometimes necessary to specify the Monoid to use; this is possible by using <code>sum&lt;M&gt;</code>. If no Monoid is specified, the structure will use the Monoid formed by the elements it contains (if it knows it), or <code><a class="el" href="structboost_1_1hana_1_1integral__constant__tag.html" title="Tag representing hana::integral_constant. ">integral_constant_tag</a>&lt;int&gt;</code> otherwise. Hence,.  <a href="group__group-Foldable.html#ga650def4b2e98f4273d8b9b7aa5a2fc28">More...</a><br /></td></tr>
<tr class="separator:ga650def4b2e98f4273d8b9b7aa5a2fc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b0c23944364ce61136e10b978ae2170"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Foldable.html#ga7b0c23944364ce61136e10b978ae2170">boost::hana::unpack</a></td></tr>
<tr class="memdesc:ga7b0c23944364ce61136e10b978ae2170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function with the elements of a Foldable as arguments.Given a function and a foldable structure whose length can be known at compile-time, <code>unpack</code> invokes the function with the contents of that structure. In other words, <code>unpack(xs, f)</code> is equivalent to <code>f(x...)</code>, where <code>x...</code> are the elements of the structure. The length of the structure must be known at compile-time, because the version of <code>f</code>'s <code>operator()</code> that will be compiled depends on the number of arguments it is called with, which has to be known at compile-time.  <a href="group__group-Foldable.html#ga7b0c23944364ce61136e10b978ae2170">More...</a><br /></td></tr>
<tr class="separator:ga7b0c23944364ce61136e10b978ae2170"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga3159cfa41be18a396926741b0a3fdefd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2count_8hpp.html">boost/hana/fwd/count.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div><div class="ttc" id="group__group-Constant_html_ga1687520692a6b0c49e3a69de2980f388"><div class="ttname"><a href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">boost::hana::value</a></div><div class="ttdeci">constexpr auto value</div><div class="ttdoc">Return the compile-time value associated to a constant.This function returns the value associated to ...</div><div class="ttdef"><b>Definition:</b> value.hpp:54</div></div>
</div><!-- fragment -->
<p>Return the number of elements in the structure that compare equal to a given value.Given a Foldable structure <code>xs</code> and a value <code>value</code>, <code>count</code> returns an unsigned integral, or a Constant thereof, representing the number of elements of <code>xs</code> that compare equal to <code>value</code>. For this method to be well-defined, all the elements of the structure must be Comparable with the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure whose elements are counted.</td></tr>
    <tr><td class="paramname">value</td><td>A value compared with each element in the structure. Elements that compare equal to this value are counted, others are not.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="count_8hpp.html">boost/hana/count.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    constexpr <span class="keyword">auto</span> ints = hana::tuple_c&lt;int, 1, 2, 3, 2, 2, 4, 2&gt;;</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#ga3159cfa41be18a396926741b0a3fdefd">hana::count</a>(ints, hana::int_c&lt;2&gt;) == hana::size_c&lt;4&gt;);</div><div class="line">    static_assert(<a class="code" href="group__group-Foldable.html#ga3159cfa41be18a396926741b0a3fdefd">hana::count</a>(ints, 2) == 4, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">    constexpr <span class="keyword">auto</span> types = hana::tuple_t&lt;int, char, long, short, char, double&gt;;</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#ga3159cfa41be18a396926741b0a3fdefd">hana::count</a>(types, hana::type_c&lt;char&gt;) == hana::size_c&lt;2&gt;);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga39d71be65d5b98e7d035a3e5c607e1b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::count_if</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2count__if_8hpp.html">boost/hana/fwd/count_if.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Return the number of elements in the structure for which the <code>predicate</code> is satisfied.Specifically, returns an object of an unsigned integral type, or a <code>Constant</code> holding such an object, which represents the number of elements in the structure satisfying the given <code>predicate</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure whose elements are counted.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code>, where <code>x</code> is an element of the structure, and returning a <code>Logical</code> representing whether <code>x</code> should be counted.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="count__if_8hpp.html">boost/hana/count_if.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ext_2std_2integral__constant_8hpp.html">boost/hana/ext/std/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mod_8hpp.html">boost/hana/mod.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="not__equal_8hpp.html">boost/hana/not_equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"><span class="keyword">using namespace </span>hana::literals;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">auto</span> is_odd = [](<span class="keyword">auto</span> x) {</div><div class="line">    <span class="keywordflow">return</span> x % 2_c != 0_c;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    constexpr <span class="keyword">auto</span> ints = hana::tuple_c&lt;int, 1, 2, 3&gt;;</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#ga39d71be65d5b98e7d035a3e5c607e1b4">hana::count_if</a>(ints, is_odd) == hana::size_c&lt;2&gt;);</div><div class="line"></div><div class="line">    constexpr <span class="keyword">auto</span> types = hana::tuple_t&lt;int, char, long, short, char, double&gt;;</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#ga39d71be65d5b98e7d035a3e5c607e1b4">hana::count_if</a>(types, hana::trait&lt;std::is_floating_point&gt;) == hana::size_c&lt;1&gt;);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#ga39d71be65d5b98e7d035a3e5c607e1b4">hana::count_if</a>(types, <a class="code" href="group__group-Comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">hana::equal</a>.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(hana::type_c&lt;char&gt;)) == hana::size_c&lt;2&gt;);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#ga39d71be65d5b98e7d035a3e5c607e1b4">hana::count_if</a>(types, <a class="code" href="group__group-Comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">hana::equal</a>.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(hana::type_c&lt;void&gt;)) == hana::size_c&lt;0&gt;);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa0fde17f3b947a0678a1c0c01232f2cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::fold = fold_left</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2fold_8hpp.html">boost/hana/fwd/fold.hpp</a>&gt;</code></p>

<p>Equivalent to <code>fold_left</code>; provided for convenience.<code>fold</code> is equivalent to <code>fold_left</code>. However, it is not tag-dispatched on its own because it is just an alias to <code>fold_left</code>. Also note that <code>fold</code> can be called with or without an initial state, just like <code>fold_left</code>: </p>
<div class="fragment"><div class="line"><a class="code" href="group__group-Foldable.html#gaa0fde17f3b947a0678a1c0c01232f2cc">fold</a>(xs, state, f) == <a class="code" href="group__group-Foldable.html#ga38c6b3f6b1cbadb9b8432a05ff16b7d2">fold_left</a>(xs, state, f)</div><div class="line"><a class="code" href="group__group-Foldable.html#gaa0fde17f3b947a0678a1c0c01232f2cc">fold</a>(xs, f) == <a class="code" href="group__group-Foldable.html#ga38c6b3f6b1cbadb9b8432a05ff16b7d2">fold_left</a>(xs, f)</div></div><!-- fragment --><h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fold_8hpp.html">boost/hana/fold.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div><div class="line">    std::ostringstream ss;</div><div class="line">    ss &lt;&lt; x;</div><div class="line">    <span class="keywordflow">return</span> ss.str();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">auto</span> f = [=](std::string s, <span class="keyword">auto</span> element) {</div><div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + s + <span class="stringliteral">&quot;, &quot;</span> + to_string(element) + <span class="stringliteral">&quot;)&quot;</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// with an initial state</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Foldable.html#gaa0fde17f3b947a0678a1c0c01232f2cc">hana::fold</a>(hana::make_tuple(2, <span class="charliteral">&#39;3&#39;</span>, 4, 5.0), <span class="stringliteral">&quot;1&quot;</span>, f)</div><div class="line">            ==</div><div class="line">        <span class="stringliteral">&quot;f(f(f(f(1, 2), 3), 4), 5)&quot;</span></div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">// without initial state</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Foldable.html#gaa0fde17f3b947a0678a1c0c01232f2cc">hana::fold</a>(hana::make_tuple(<span class="stringliteral">&quot;1&quot;</span>, 2, <span class="charliteral">&#39;3&#39;</span>, 4, 5.0), f)</div><div class="line">            ==</div><div class="line">        <span class="stringliteral">&quot;f(f(f(f(1, 2), 3), 4), 5)&quot;</span></div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga38c6b3f6b1cbadb9b8432a05ff16b7d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::fold_left</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2fold__left_8hpp.html">boost/hana/fwd/fold_left.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; state], <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Left-fold of a structure using a binary operation and an optional initial reduction state.<code>fold_left</code> is a left-associative fold using a binary operation. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and an optional initial state, <code>fold_left</code> applies <code>f</code> as follows. </p>
<div class="fragment"><div class="line">f(... f(f(f(x1, x2), x3), x4) ..., xn) <span class="comment">// without state</span></div><div class="line">f(... f(f(f(f(state, x1), x2), x3), x4) ..., xn) <span class="comment">// with state</span></div></div><!-- fragment --><p>When the structure is empty, two things may arise. If an initial state was provided, it is returned as-is. Otherwise, if the no-state version of the function was used, an error is triggered. When the stucture contains a single element and the no-state version of the function was used, that single element is returned as is.</p>
<h2>Signature </h2>
<p>Given a <code>Foldable</code> <code>F</code> and an optional initial state of tag <code>S</code>, the signatures for <code>fold_left</code> are </p><p class="formulaDsp">
\[ \mathtt{fold\_left} : F(T) \times S \times (S \times T \to S) \to S \]
</p>
<p>for the variant with an initial state, and </p><p class="formulaDsp">
\[ \mathtt{fold\_left} : F(T) \times (T \times T \to T) \to T \]
</p>
<p>for the variant without an initial state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. For left folds without an initial state, the function is called as <code>f(x1, x2)</code>, where <code>x1</code> and <code>x2</code> are elements of the structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fold__left_8hpp.html">boost/hana/fold_left.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div><div class="line">    std::ostringstream ss;</div><div class="line">    ss &lt;&lt; x;</div><div class="line">    <span class="keywordflow">return</span> ss.str();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">auto</span> f = [=](std::string s, <span class="keyword">auto</span> element) {</div><div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + s + <span class="stringliteral">&quot;, &quot;</span> + to_string(element) + <span class="stringliteral">&quot;)&quot;</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// with an initial state</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Foldable.html#ga38c6b3f6b1cbadb9b8432a05ff16b7d2">hana::fold_left</a>(hana::make_tuple(2, <span class="charliteral">&#39;3&#39;</span>, 4, 5.0), <span class="stringliteral">&quot;1&quot;</span>, f)</div><div class="line">            ==</div><div class="line">        <span class="stringliteral">&quot;f(f(f(f(1, 2), 3), 4), 5)&quot;</span></div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">// without initial state</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Foldable.html#ga38c6b3f6b1cbadb9b8432a05ff16b7d2">hana::fold_left</a>(hana::make_tuple(<span class="stringliteral">&quot;1&quot;</span>, 2, <span class="charliteral">&#39;3&#39;</span>, 4, 5.0), f)</div><div class="line">            ==</div><div class="line">        <span class="stringliteral">&quot;f(f(f(f(1, 2), 3), 4), 5)&quot;</span></div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga77d43badebd59b046cf93598733649b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::fold_right</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2fold__right_8hpp.html">boost/hana/fwd/fold_right.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; state], <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Right-fold of a structure using a binary operation and an optional initial reduction state.<code>fold_right</code> is a right-associative fold using a binary operation. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and an optional initial state, <code>fold_right</code> applies <code>f</code> as follows. </p>
<div class="fragment"><div class="line">f(x1, f(x2, f(x3, f(x4, ... f(xn-1, xn) ... )))) <span class="comment">// without state</span></div><div class="line">f(x1, f(x2, f(x3, f(x4, ... f(xn, state) ... )))) <span class="comment">// with state</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>It is worth noting that the order in which the binary function should expect its arguments is reversed from <code>fold_left</code>.</dd></dl>
<p>When the structure is empty, two things may arise. If an initial state was provided, it is returned as-is. Otherwise, if the no-state version of the function was used, an error is triggered. When the stucture contains a single element and the no-state version of the function was used, that single element is returned as is.</p>
<h2>Signature </h2>
<p>Given a <code>Foldable</code> <code>F</code> and an optional initial state of tag <code>S</code>, the signatures for <code>fold_right</code> are </p><p class="formulaDsp">
\[ \mathtt{fold\_right} : F(T) \times S \times (T \times S \to S) \to S \]
</p>
<p>for the variant with an initial state, and </p><p class="formulaDsp">
\[ \mathtt{fold\_right} : F(T) \times (T \times T \to T) \to T \]
</p>
<p>for the variant without an initial state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(x, state)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. For right folds without an initial state, the function is called as <code>f(x1, x2)</code>, where <code>x1</code> and <code>x2</code> are elements of the structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fold__right_8hpp.html">boost/hana/fold_right.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div><div class="line">    std::ostringstream ss;</div><div class="line">    ss &lt;&lt; x;</div><div class="line">    <span class="keywordflow">return</span> ss.str();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">auto</span> f = [=](<span class="keyword">auto</span> element, std::string s) {</div><div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + to_string(element) + <span class="stringliteral">&quot;, &quot;</span> + s + <span class="stringliteral">&quot;)&quot;</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// with an initial state</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Foldable.html#ga77d43badebd59b046cf93598733649b4">hana::fold_right</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0, 4), <span class="stringliteral">&quot;5&quot;</span>, f)</div><div class="line">            ==</div><div class="line">        <span class="stringliteral">&quot;f(1, f(2, f(3, f(4, 5))))&quot;</span></div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">// without initial state</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Foldable.html#ga77d43badebd59b046cf93598733649b4">hana::fold_right</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0, 4, <span class="stringliteral">&quot;5&quot;</span>), f)</div><div class="line">            ==</div><div class="line">        <span class="stringliteral">&quot;f(1, f(2, f(3, f(4, 5))))&quot;</span></div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga2af382f7e644ce3707710bbad313e9c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::for_each</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2for__each_8hpp.html">boost/hana/fwd/for_each.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; <span class="keywordtype">void</span> {</div><div class="line">        tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Perform an action on each element of a foldable, discarding the result each time.Iteration is done from left to right, i.e. in the same order as when using <code>fold_left</code>. If the structure is not finite, this method will not terminate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to iterate over.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> for each element <code>x</code> of the structure. The result of <code>f(x)</code>, whatever it is, is ignored.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="for__each_8hpp.html">boost/hana/for_each.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    std::stringstream ss;</div><div class="line">    <a class="code" href="group__group-Foldable.html#ga2af382f7e644ce3707710bbad313e9c2">hana::for_each</a>(hana::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>, <span class="stringliteral">&quot;234&quot;</span>, 5.5), [&amp;](<span class="keyword">auto</span> x) {</div><div class="line">        ss &lt;&lt; x &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div><div class="line">    });</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(ss.str() == <span class="stringliteral">&quot;0 1 234 5.5 &quot;</span>);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga19fcf61d8d1179903952c0f564c538aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::fuse</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2fuse_8hpp.html">boost/hana/fwd/fuse.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; f) {</div><div class="line">        <span class="keywordflow">return</span> [perfect-<a class="code" href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">capture</a>](<span class="keyword">auto</span>&amp;&amp; xs) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="group__group-Foldable.html#ga7b0c23944364ce61136e10b978ae2170">unpack</a>(forwarded(xs), forwarded(f));</div><div class="line">        };</div><div class="line">    }</div><div class="ttc" id="group__group-Foldable_html_ga7b0c23944364ce61136e10b978ae2170"><div class="ttname"><a href="group__group-Foldable.html#ga7b0c23944364ce61136e10b978ae2170">boost::hana::unpack</a></div><div class="ttdeci">constexpr auto unpack</div><div class="ttdoc">Invoke a function with the elements of a Foldable as arguments.Given a function and a foldable struct...</div><div class="ttdef"><b>Definition:</b> unpack.hpp:79</div></div>
<div class="ttc" id="group__group-functional_html_ga41ada6b336e9d5bcb101ff0c737acbd0"><div class="ttname"><a href="group__group-functional.html#ga41ada6b336e9d5bcb101ff0c737acbd0">boost::hana::capture</a></div><div class="ttdeci">constexpr auto capture</div><div class="ttdoc">Create a function capturing the given variables. </div><div class="ttdef"><b>Definition:</b> capture.hpp:45</div></div>
</div><!-- fragment -->
<p>Transform a function taking multiple arguments into a function that can be called with a compile-time <code>Foldable</code>. </p>
<p>This function is provided for convenience as a different way of calling <code>unpack</code>. Specifically, <code>fuse(f)</code> is a function such that </p><div class="fragment"><div class="line"><a class="code" href="group__group-Foldable.html#ga19fcf61d8d1179903952c0f564c538aa">fuse</a>(f)(foldable) == <a class="code" href="group__group-Foldable.html#ga7b0c23944364ce61136e10b978ae2170">unpack</a>(foldable, f)</div><div class="line">                  == f(x...)</div></div><!-- fragment --><p> where <code>x...</code> are the elements in the foldable. This function is useful when one wants to create a function that accepts a foldable which is not known yet.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not tag-dispatched; customize <code>unpack</code> instead.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fuse_8hpp.html">boost/hana/fuse.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">auto</span> tie = [](<span class="keyword">auto</span>&amp; ...vars) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__group-Foldable.html#ga19fcf61d8d1179903952c0f564c538aa">hana::fuse</a>([&amp;vars...](auto ...values) {</div><div class="line">        <span class="comment">// Using an initializer list to sequence the assignments.</span></div><div class="line">        int dummy[] = {0, ((void)(vars = values), 0)...};</div><div class="line">        (<span class="keywordtype">void</span>)dummy;</div><div class="line">    });</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">int</span> a = 0;</div><div class="line">    <span class="keywordtype">char</span> b = <span class="charliteral">&#39;\0&#39;</span>;</div><div class="line">    <span class="keywordtype">double</span> c = 0;</div><div class="line"></div><div class="line">    tie(a, b, c)(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3));</div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(a == 1 &amp;&amp; b == <span class="charliteral">&#39;2&#39;</span> &amp;&amp; c == 3.3);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaf0f8f717245620dc28cd7d7fa44d7475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::length</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2length_8hpp.html">boost/hana/fwd/length.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; xs) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Return the number of elements in a foldable structure.Given a <code>Foldable</code> <code>xs</code>, <code>length(xs)</code> must return an object of an unsigned integral type, or an <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="The IntegralConstant concept represents compile-time integral values. ">IntegralConstant</a></code> holding such an object, which represents the number of elements in the structure. </p>
<dl class="section note"><dt>Note</dt><dd>Since only compile-time <code>Foldable</code>s are supported in the library right now, <code>length</code> must always return an <code><a class="el" href="structboost_1_1hana_1_1IntegralConstant.html" title="The IntegralConstant concept represents compile-time integral values. ">IntegralConstant</a></code>.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="length_8hpp.html">boost/hana/length.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">hana::length</a>(hana::make_tuple()) == hana::size_c&lt;0&gt;);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">hana::length</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0)) == hana::size_c&lt;3&gt;);</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">hana::length</a>(hana::nothing) == hana::size_c&lt;0&gt;);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">hana::length</a>(hana::just(<span class="charliteral">&#39;x&#39;</span>)) == hana::size_c&lt;1&gt;);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaf3861a91607203b63a12708e18a4eac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::maximum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2maximum_8hpp.html">boost/hana/fwd/maximum.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; predicate]) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Return the greatest element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>.Given a non-empty structure and an optional binary predicate (<code>less</code> by default), <code>maximum</code> returns the greatest element of the structure, i.e. an element which is greater than or equal to every other element in the structure, according to the predicate. </p>
<p>If the structure contains heterogeneous objects, then the predicate must return a compile-time <code>Logical</code>. If no predicate is provided, the elements in the structure must be Orderable, or compile-time Orderable if the structure is heterogeneous.</p>
<h2>Signature </h2>
<p>Given a Foldable <code>F</code>, a Logical <code>Bool</code> and a predicate \( \mathtt{pred} : T \times T \to Bool \), <code>maximum</code> has the following signatures. For the variant with a provided predicate, </p><p class="formulaDsp">
\[ \mathtt{maximum} : F(T) \times (T \times T \to Bool) \to T \]
</p>
<p>for the variant without a custom predicate, <code>T</code> is required to be Orderable. The signature is then </p><p class="formulaDsp">
\[ \mathtt{maximum} : F(T) \to T \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to find the greatest element of.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x, y)</code>, where <code>x</code> and <code>y</code> are elements of the structure. <code>predicate</code> should be a strict weak ordering on the elements of the structure and its return value should be a Logical, or a compile-time Logical if the structure is heterogeneous.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="greater_8hpp.html">boost/hana/greater.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="maximum_8hpp.html">boost/hana/maximum.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// without a predicate</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Foldable.html#gaf3861a91607203b63a12708e18a4eac5">hana::maximum</a>(hana::tuple_c&lt;int, -1, 0, 2, -4, 6, 9&gt;) == hana::int_c&lt;9&gt;</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">// with a predicate</span></div><div class="line">    <span class="keyword">auto</span> smallest = <a class="code" href="group__group-Foldable.html#gaf3861a91607203b63a12708e18a4eac5">hana::maximum</a>(hana::tuple_c&lt;int, -1, 0, 2, -4, 6, 9&gt;, [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div><div class="line">        <span class="keywordflow">return</span> x &gt; y; <span class="comment">// order is reversed!</span></div><div class="line">    });</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(smallest == hana::int_c&lt;-4&gt;);</div><div class="line">}</div></div><!-- fragment --><h2>Syntactic sugar (<code>maximum.by</code>) </h2>
<p><code>maximum</code> can be called in a third way, which provides a nice syntax especially when working with the <code>ordering</code> combinator: </p><div class="fragment"><div class="line"><a class="code" href="group__group-Foldable.html#gaf3861a91607203b63a12708e18a4eac5">maximum</a>.by(predicate, xs) == <a class="code" href="group__group-Foldable.html#gaf3861a91607203b63a12708e18a4eac5">maximum</a>(xs, predicate)</div><div class="line"><a class="code" href="group__group-Foldable.html#gaf3861a91607203b63a12708e18a4eac5">maximum</a>.by(predicate) == <a class="code" href="group__group-Foldable.html#gaf3861a91607203b63a12708e18a4eac5">maximum</a>(-, predicate)</div></div><!-- fragment --><p>where <code>maximum(-, predicate)</code> denotes the partial application of <code>maximum</code> to <code>predicate</code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="length_8hpp.html">boost/hana/length.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="maximum_8hpp.html">boost/hana/maximum.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ordering_8hpp.html">boost/hana/ordering.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    static_assert(</div><div class="line">        <a class="code" href="group__group-Foldable.html#gaf3861a91607203b63a12708e18a4eac5">hana::maximum</a>.by(<a class="code" href="group__group-Orderable.html#gaf7e94ba859710cd6ba6152e5dc18977d">hana::ordering</a>(<a class="code" href="group__group-Foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">hana::length</a>), hana::make_tuple(</div><div class="line">            hana::make_tuple(),</div><div class="line">            hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>),</div><div class="line">            hana::make_tuple(3.3, <span class="keyword">nullptr</span>, 4)</div><div class="line">        ))</div><div class="line">        == hana::make_tuple(3.3, <span class="keyword">nullptr</span>, 4)</div><div class="line">    , <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><h2>Tag dispatching </h2>
<p>Both the non-predicated version and the predicated versions of <code>maximum</code> are tag-dispatched methods, and hence they can be customized independently. One reason for this is that some structures are able to provide a much more efficient implementation of <code>maximum</code> when the <code>less</code> predicate is used. Here is how the different versions of <code>maximum</code> are dispatched: </p><div class="fragment"><div class="line"><a class="code" href="group__group-Foldable.html#gaf3861a91607203b63a12708e18a4eac5">maximum</a>(xs) -&gt; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">maximum_impl&lt;tag of xs&gt;::apply</a>(xs)</div><div class="line">maximum(xs, pred) -&gt; maximum_pred_impl&lt;tag of xs&gt;::<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(xs, pred)</div></div><!-- fragment --><p>Also note that <code>maximum.by</code> is not tag-dispatched on its own, since it is just syntactic sugar for calling the corresponding <code>maximum</code>. </p>

</div>
</div>
<a class="anchor" id="ga347429451fdb15f9f7a7fc0de293be1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::minimum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2minimum_8hpp.html">boost/hana/fwd/minimum.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; predicate]) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Return the least element of a non-empty structure with respect to a <code>predicate</code>, by default <code>less</code>.Given a non-empty structure and an optional binary predicate (<code>less</code> by default), <code>minimum</code> returns the least element of the structure, i.e. an element which is less than or equal to every other element in the structure, according to the predicate. </p>
<p>If the structure contains heterogeneous objects, then the predicate must return a compile-time <code>Logical</code>. If no predicate is provided, the elements in the structure must be Orderable, or compile-time Orderable if the structure is heterogeneous.</p>
<h2>Signature </h2>
<p>Given a <code>Foldable</code> <code>F</code>, a Logical <code>Bool</code> and a predicate \( \mathtt{pred} : T \times T \to Bool \), <code>minimum</code> has the following signatures. For the variant with a provided predicate, </p><p class="formulaDsp">
\[ \mathtt{minimum} : F(T) \times (T \times T \to Bool) \to T \]
</p>
<p>for the variant without a custom predicate, <code>T</code> is required to be Orderable. The signature is then </p><p class="formulaDsp">
\[ \mathtt{minimum} : F(T) \to T \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to find the least element of.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x, y)</code>, where <code>x</code> and <code>y</code> are elements of the structure. <code>predicate</code> should be a strict weak ordering on the elements of the structure and its return value should be a Logical, or a compile-time Logical if the structure is heterogeneous.</td></tr>
  </table>
  </dd>
</dl>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="greater_8hpp.html">boost/hana/greater.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="minimum_8hpp.html">boost/hana/minimum.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// without a predicate</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Foldable.html#ga347429451fdb15f9f7a7fc0de293be1a">hana::minimum</a>(hana::tuple_c&lt;int, -1, 0, 2, -4, 6, 9&gt;) == hana::int_c&lt;-4&gt;</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">// with a predicate</span></div><div class="line">    <span class="keyword">auto</span> largest = <a class="code" href="group__group-Foldable.html#ga347429451fdb15f9f7a7fc0de293be1a">hana::minimum</a>(hana::tuple_c&lt;int, -1, 0, 2, -4, 6, 9&gt;, [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div><div class="line">        <span class="keywordflow">return</span> x &gt; y; <span class="comment">// order is reversed!</span></div><div class="line">    });</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(largest == hana::int_c&lt;9&gt;);</div><div class="line">}</div></div><!-- fragment --><h2>Syntactic sugar (<code>minimum.by</code>) </h2>
<p><code>minimum</code> can be called in a third way, which provides a nice syntax especially when working with the <code>ordering</code> combinator: </p><div class="fragment"><div class="line"><a class="code" href="group__group-Foldable.html#ga347429451fdb15f9f7a7fc0de293be1a">minimum</a>.by(predicate, xs) == <a class="code" href="group__group-Foldable.html#ga347429451fdb15f9f7a7fc0de293be1a">minimum</a>(xs, predicate)</div><div class="line"><a class="code" href="group__group-Foldable.html#ga347429451fdb15f9f7a7fc0de293be1a">minimum</a>.by(predicate) == <a class="code" href="group__group-Foldable.html#ga347429451fdb15f9f7a7fc0de293be1a">minimum</a>(-, predicate)</div></div><!-- fragment --><p>where <code>minimum(-, predicate)</code> denotes the partial application of <code>minimum</code> to <code>predicate</code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="length_8hpp.html">boost/hana/length.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="minimum_8hpp.html">boost/hana/minimum.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ordering_8hpp.html">boost/hana/ordering.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Foldable.html#ga347429451fdb15f9f7a7fc0de293be1a">hana::minimum</a>.by(<a class="code" href="group__group-Orderable.html#gaf7e94ba859710cd6ba6152e5dc18977d">hana::ordering</a>(<a class="code" href="group__group-Foldable.html#gaf0f8f717245620dc28cd7d7fa44d7475">hana::length</a>), hana::make_tuple(</div><div class="line">            hana::make_tuple(),</div><div class="line">            hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>),</div><div class="line">            hana::make_tuple(3.3, <span class="keyword">nullptr</span>, 4)</div><div class="line">        ))</div><div class="line">        == hana::make_tuple()</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --><h2>Tag dispatching </h2>
<p>Both the non-predicated version and the predicated versions of <code>minimum</code> are tag-dispatched methods, and hence they can be customized independently. One reason for this is that some structures are able to provide a much more efficient implementation of <code>minimum</code> when the <code>less</code> predicate is used. Here is how the different versions of <code>minimum</code> are dispatched: </p><div class="fragment"><div class="line"><a class="code" href="group__group-Foldable.html#ga347429451fdb15f9f7a7fc0de293be1a">minimum</a>(xs) -&gt; <a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">minimum_impl&lt;tag of xs&gt;::apply</a>(xs)</div><div class="line">minimum(xs, pred) -&gt; minimum_pred_impl&lt;tag of xs&gt;::<a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">apply</a>(xs, pred)</div></div><!-- fragment --><p>Also note that <code>minimum.by</code> is not tag-dispatched on its own, since it is just syntactic sugar for calling the corresponding <code>minimum</code>. </p>

</div>
</div>
<a class="anchor" id="gac14edbff755244aa02b57a6383dcebc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::monadic_fold_left</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2monadic__fold__left_8hpp.html">boost/hana/fwd/monadic_fold_left.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; state], <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Monadic left-fold of a structure with a binary operation and an optional initial reduction state. </p>
<dl class="section note"><dt>Note</dt><dd>This assumes the reader to be accustomed to non-monadic left-folds as explained by <code><a class="el" href="group__group-Foldable.html#ga38c6b3f6b1cbadb9b8432a05ff16b7d2" title="Left-fold of a structure using a binary operation and an optional initial reduction state...">hana::fold_left</a></code>, and to have read the <a class="el" href="group__group-Foldable.html#monadic-folds">primer</a> on monadic folds.</dd></dl>
<p><code>monadic_fold_left&lt;M&gt;</code> is a left-associative monadic fold. Given a <code>Foldable</code> with linearization <code>[x1, ..., xn]</code>, a function <code>f</code> and an optional initial state, <code>monadic_fold_left&lt;M&gt;</code> applies <code>f</code> as follows: </p><div class="fragment"><div class="line"><span class="comment">// with state</span></div><div class="line">((((f(state, x1) | f(-, x2)) | f(-, x3)) | ...) | f(-, xn))</div><div class="line"></div><div class="line"><span class="comment">// without state</span></div><div class="line">((((f(x1, x2) | f(-, x3)) | f(-, x4)) | ...) | f(-, xn))</div></div><!-- fragment --><p>where <code>f(-, xk)</code> denotes the partial application of <code>f</code> to <code>xk</code>, and <code>|</code> is just the operator version of the monadic <code>chain</code>.</p>
<p>When the structure is empty, one of two things may happen. If an initial state was provided, it is lifted to the given Monad and returned as-is. Otherwise, if the no-state version of the function was used, an error is triggered. When the stucture contains a single element and the no-state version of the function was used, that single element is lifted into the given Monad and returned as is.</p>
<h2>Signature </h2>
<p>Given a <code>Monad</code> <code>M</code>, a <code>Foldable</code> <code>F</code>, an initial state of tag <code>S</code>, and a function \( f : S \times T \to M(S) \), the signatures of <code>monadic_fold_left&lt;M&gt;</code> are </p><p class="formulaDsp">
\[ \mathtt{monadic\_fold\_left}_M : F(T) \times S \times (S \times T \to M(S)) \to M(S) \]
</p>
<p>for the version with an initial state, and </p><p class="formulaDsp">
\[ \mathtt{monadic\_fold\_left}_M : F(T) \times (T \times T \to M(T)) \to M(T) \]
</p>
<p>for the version without an initial state.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The Monad representing the monadic context in which the fold happens. The return type of <code>f</code> must be in that Monad.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding. If the structure is empty, this value is lifted in to the <code>M</code> Monad and then returned as-is.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. The function must return its result inside the <code>M</code> Monad.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="monadic__fold__left_8hpp.html">boost/hana/monadic_fold_left.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="traits_8hpp.html">boost/hana/traits.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">auto</span> builtin_common_t = hana::sfinae([](<span class="keyword">auto</span>&amp;&amp; t, <span class="keyword">auto</span>&amp;&amp; u) -&gt; hana::type&lt;</div><div class="line">    std::decay_t&lt;decltype(<span class="keyword">true</span> ? hana::traits::declval(t) : hana::traits::declval(u))&gt;</div><div class="line">&gt; { <span class="keywordflow">return</span> {}; });</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...T&gt;</div><div class="line"><span class="keyword">struct </span>common_type { };</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</div><div class="line"><span class="keyword">struct </span>common_type&lt;T, U&gt;</div><div class="line">    : std::conditional_t&lt;std::is_same&lt;std::decay_t&lt;T&gt;, T&gt;{} &amp;&amp;</div><div class="line">                         std::is_same&lt;std::decay_t&lt;U&gt;, U&gt;{},</div><div class="line">        decltype(builtin_common_t(hana::type_c&lt;T&gt;, hana::type_c&lt;U&gt;)),</div><div class="line">        common_type&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;</div><div class="line">    &gt;</div><div class="line">{ };</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> ...Tn&gt;</div><div class="line"><span class="keyword">struct </span>common_type&lt;T1, Tn...&gt;</div><div class="line">    : decltype(hana::monadic_fold_left&lt;hana::optional_tag&gt;(</div><div class="line">        hana::tuple_t&lt;Tn...&gt;,</div><div class="line">        hana::type_c&lt;std::decay_t&lt;T1&gt;&gt;,</div><div class="line">        hana::sfinae(hana::metafunction&lt;common_type&gt;)</div><div class="line">    ))</div><div class="line">{ };</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Ts&gt;</div><div class="line"><span class="keyword">using</span> common_type_t = <span class="keyword">typename</span> common_type&lt;Ts...&gt;::type;</div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">  builtin_common_t(hana::type_c&lt;int&gt;, hana::type_c&lt;float&gt;)</div><div class="line">    ==</div><div class="line">  hana::just(hana::type_c&lt;float&gt;)</div><div class="line">);</div><div class="line"></div><div class="line">static_assert(std::is_same&lt;</div><div class="line">    common_type_t&lt;char, short, char, short&gt;,</div><div class="line">    <span class="keywordtype">int</span></div><div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">static_assert(std::is_same&lt;</div><div class="line">    common_type_t&lt;char, double, short, char, short, double&gt;,</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">static_assert(std::is_same&lt;</div><div class="line">    common_type_t&lt;char, short, float, short&gt;,</div><div class="line">    <span class="keywordtype">float</span></div><div class="line">&gt;{}, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">static_assert(</div><div class="line">    hana::sfinae(hana::metafunction&lt;common_type&gt;)(</div><div class="line">        hana::type_c&lt;int&gt;, hana::type_c&lt;int&gt;, hana::type_c&lt;int*&gt;</div><div class="line">    ) == hana::nothing</div><div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa058d91f3e1294f0d3c71bedf33e2360"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::monadic_fold_right</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2monadic__fold__right_8hpp.html">boost/hana/fwd/monadic_fold_right.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; state], <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Monadic right-fold of a structure with a binary operation and an optional initial reduction state. </p>
<dl class="section note"><dt>Note</dt><dd>This assumes the reader to be accustomed to non-monadic right-folds as explained by <code><a class="el" href="group__group-Foldable.html#ga77d43badebd59b046cf93598733649b4" title="Right-fold of a structure using a binary operation and an optional initial reduction state...">hana::fold_right</a></code>, and to have read the <a class="el" href="group__group-Foldable.html#monadic-folds">primer</a> on monadic folds.</dd></dl>
<p><code>monadic_fold_right&lt;M&gt;</code> is a right-associative monadic fold. Given a structure containing <code>x1, ..., xn</code>, a function <code>f</code> and an optional initial state, <code>monadic_fold_right&lt;M&gt;</code> applies <code>f</code> as follows </p><div class="fragment"><div class="line"><span class="comment">// with state</span></div><div class="line">(f(x1, -) | (f(x2, -) | (f(x3, -) | (... | f(xn, state)))))</div><div class="line"></div><div class="line"><span class="comment">// without state</span></div><div class="line">(f(x1, -) | (f(x2, -) | (f(x3, -) | (... | f(xn-1, xn)))))</div></div><!-- fragment --><p>where <code>f(xk, -)</code> denotes the partial application of <code>f</code> to <code>xk</code>, and <code>|</code> is just the operator version of the monadic <code>chain</code>. It is worth noting that the order in which the binary function should expect its arguments is reversed from <code>monadic_fold_left&lt;M&gt;</code>.</p>
<p>When the structure is empty, one of two things may happen. If an initial state was provided, it is lifted to the given Monad and returned as-is. Otherwise, if the no-state version of the function was used, an error is triggered. When the stucture contains a single element and the no-state version of the function was used, that single element is lifted into the given Monad and returned as is.</p>
<h2>Signature </h2>
<p>Given a <code>Monad</code> <code>M</code>, a <code>Foldable</code> <code>F</code>, an initial state of tag <code>S</code>, and a function \( f : T \times S \to M(S) \), the signatures of <code>monadic_fold_right&lt;M&gt;</code> are </p><p class="formulaDsp">
\[ \mathtt{monadic\_fold\_right}_M : F(T) \times S \times (T \times S \to M(S)) \to M(S) \]
</p>
<p>for the version with an initial state, and </p><p class="formulaDsp">
\[ \mathtt{monadic\_fold\_right}_M : F(T) \times (T \times T \to M(T)) \to M(T) \]
</p>
<p>for the version without an initial state.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>The Monad representing the monadic context in which the fold happens. The return type of <code>f</code> must be in that Monad.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding. If the structure is empty, this value is lifted in to the <code>M</code> Monad and then returned as-is.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(x, state)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. The function must return its result inside the <code>M</code> Monad.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="div_8hpp.html">boost/hana/div.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="eval__if_8hpp.html">boost/hana/eval_if.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lazy_8hpp.html">boost/hana/lazy.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="monadic__fold__right_8hpp.html">boost/hana/monadic_fold_right.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> safe_div = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) {</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__group-Logical.html#gab64636f84de983575aac0208f5fa840c">hana::eval_if</a>(y == hana::int_c&lt;0&gt;,</div><div class="line">            hana::make_lazy(hana::nothing),</div><div class="line">            [=](<span class="keyword">auto</span> <a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>) {</div><div class="line">                <span class="keywordflow">return</span> hana::just(<a class="code" href="group__group-functional.html#gaefe9fd152cba94be71c2b5b9de689d23">_</a>(x) / y);</div><div class="line">            }</div><div class="line">        );</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// with an initial state</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        hana::monadic_fold_right&lt;hana::optional_tag&gt;(</div><div class="line">            hana::tuple_c&lt;int, 1000, 8, 4&gt;, hana::int_c&lt;2&gt;, safe_div</div><div class="line">        )</div><div class="line">            ==</div><div class="line">        hana::just(hana::int_c&lt;1000&gt; / (hana::int_c&lt;8&gt; / (hana::int_c&lt;4&gt; / hana::int_c&lt;2&gt;)))</div><div class="line">    );</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        hana::monadic_fold_right&lt;hana::optional_tag&gt;(</div><div class="line">            hana::tuple_c&lt;int, 1000, 8, 4&gt;, hana::int_c&lt;0&gt;, safe_div</div><div class="line">        )</div><div class="line">            ==</div><div class="line">        hana::nothing</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">// without an initial state</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        hana::monadic_fold_right&lt;hana::optional_tag&gt;(</div><div class="line">            hana::tuple_c&lt;int, 1000, 8, 4, 2&gt;, safe_div</div><div class="line">        )</div><div class="line">            ==</div><div class="line">        hana::just(hana::int_c&lt;1000&gt; / (hana::int_c&lt;8&gt; / (hana::int_c&lt;4&gt; / hana::int_c&lt;2&gt;)))</div><div class="line">    );</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        hana::monadic_fold_right&lt;hana::optional_tag&gt;(</div><div class="line">            hana::tuple_c&lt;int, 1000, 8, 4, 0&gt;, safe_div</div><div class="line">        )</div><div class="line">            ==</div><div class="line">        hana::nothing</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga17fe9c1982c882807f3358b4138c5744"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::product = see documentation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2product_8hpp.html">boost/hana/fwd/product.hpp</a>&gt;</code></p>

<p>Compute the product of the numbers of a structure.More generally, <code>product</code> will take any foldable structure containing objects forming a Ring and reduce them using the Ring's binary operation. The initial state for folding is the identity of the Ring's operation. It is sometimes necessary to specify the Ring to use; this is possible by using <code>product&lt;R&gt;</code>. If no Ring is specified, the structure will use the Ring formed by the elements it contains (if it knows it), or <code><a class="el" href="structboost_1_1hana_1_1integral__constant__tag.html" title="Tag representing hana::integral_constant. ">integral_constant_tag</a>&lt;int&gt;</code> otherwise. Hence,. </p>
<div class="fragment"><div class="line">product&lt;R&gt;(xs) = <a class="code" href="group__group-Foldable.html#ga38c6b3f6b1cbadb9b8432a05ff16b7d2">fold_left</a>(xs, one&lt;R or inferred Ring&gt;(), <a class="code" href="group__group-Ring.html#ga052d31c269a6a438cc8004c9ad1efdfa">mult</a>)</div><div class="line">product&lt;&gt; = <a class="code" href="group__group-Foldable.html#ga17fe9c1982c882807f3358b4138c5744">product</a>&lt;integral_constant_tag&lt;int&gt;&gt;</div></div><!-- fragment --><p>For numbers, this will just compute the product of the numbers in the <code>xs</code> structure.</p>
<dl class="section note"><dt>Note</dt><dd>The elements of the structure are not actually required to be in the same Ring, but it must be possible to perform <code>mult</code> on any two adjacent elements of the structure, which requires each pair of adjacent element to at least have a common Ring embedding. The meaning of "adjacent" as used here is that two elements of the structure <code>x</code> and <code>y</code> are adjacent if and only if they are adjacent in the linearization of that structure, as documented by the Iterable concept.</dd>
<dd>
See the documentation for <code>sum</code> to understand why the Ring must sometimes be specified explicitly.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="product_8hpp.html">boost/hana/product.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="range_8hpp.html">boost/hana/range.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        hana::product&lt;&gt;(hana::make_range(hana::int_c&lt;1&gt;, hana::int_c&lt;6&gt;)) == hana::int_c&lt;1 * 2 * 3 * 4 * 5&gt;</div><div class="line">    );</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div><div class="line">        hana::product&lt;&gt;(hana::make_tuple(1, hana::int_c&lt;3&gt;, hana::long_c&lt;-5&gt;, 9)) == 1 * 3 * -5 * 9</div><div class="line">    );</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div><div class="line">        hana::product&lt;unsigned long&gt;(hana::make_tuple(2ul, 3ul)) == 6ul</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga947602718a53bd7fcd5c20477694cdcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::reverse_fold</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2reverse__fold_8hpp.html">boost/hana/fwd/reverse_fold.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs[, <span class="keyword">auto</span>&amp;&amp; state], <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__group-Foldable.html#ga77d43badebd59b046cf93598733649b4">fold_right</a>(forwarded(xs), forwarded(state), <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(forwarded(f)));</div><div class="line">    }</div><div class="ttc" id="group__group-Foldable_html_ga77d43badebd59b046cf93598733649b4"><div class="ttname"><a href="group__group-Foldable.html#ga77d43badebd59b046cf93598733649b4">boost::hana::fold_right</a></div><div class="ttdeci">constexpr auto fold_right</div><div class="ttdoc">Right-fold of a structure using a binary operation and an optional initial reduction state...</div><div class="ttdef"><b>Definition:</b> fold_right.hpp:73</div></div>
<div class="ttc" id="group__group-functional_html_ga004f884cdbb85c2efe3383c1db450094"><div class="ttname"><a href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">boost::hana::flip</a></div><div class="ttdeci">constexpr auto flip</div><div class="ttdoc">Invoke a function with its two first arguments reversed. </div><div class="ttdef"><b>Definition:</b> flip.hpp:31</div></div>
</div><!-- fragment -->
<p>Equivalent to <code>reverse_fold</code> in Boost.Fusion and Boost.MPL.This method has the same semantics as <code>reverse_fold</code> in Boost.Fusion and Boost.MPL, with the extension that an initial state is not required. This method is equivalent to <code>fold_right</code>, except that the accumulating function must take its arguments in reverse order, to match the order used in Fusion. In other words,. </p>
<div class="fragment"><div class="line"><a class="code" href="group__group-Foldable.html#ga947602718a53bd7fcd5c20477694cdcd">reverse_fold</a>(sequence, state, f) == <a class="code" href="group__group-Foldable.html#ga77d43badebd59b046cf93598733649b4">fold_right</a>(sequence, state, <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(f))</div><div class="line"><a class="code" href="group__group-Foldable.html#ga947602718a53bd7fcd5c20477694cdcd">reverse_fold</a>(sequence, f) == <a class="code" href="group__group-Foldable.html#ga77d43badebd59b046cf93598733649b4">fold_right</a>(sequence, <a class="code" href="group__group-functional.html#ga004f884cdbb85c2efe3383c1db450094">flip</a>(f))</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This method is a convenience alias to <code>fold_right</code>. As an alias, <code>reverse_fold</code> is not tag-dispatched on its own and <code>fold_right</code> should be customized instead.</dd></dl>
<h2>Signature </h2>
<p>Given a <code>Foldable</code> <code>F</code> and an optional initial state of tag <code>S</code>, the signatures for <code>reverse_fold</code> are </p><p class="formulaDsp">
\[ \mathtt{reverse\_fold} : F(T) \times S \times (S \times T \to S) \to S \]
</p>
<p>for the variant with an initial state, and </p><p class="formulaDsp">
\[ \mathtt{reverse\_fold} : F(T) \times (T \times T \to T) \to T \]
</p>
<p>for the variant without an initial state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fold.</td></tr>
    <tr><td class="paramname">state</td><td>The initial value used for folding.</td></tr>
    <tr><td class="paramname">f</td><td>A binary function called as <code>f(state, x)</code>, where <code>state</code> is the result accumulated so far and <code>x</code> is an element in the structure. For reverse folds without an initial state, the function is called as <code>f(x1, x2)</code>, where <code>x1</code> and <code>x2</code> are elements of the structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="reverse__fold_8hpp.html">boost/hana/reverse_fold.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div><div class="line">    std::ostringstream ss;</div><div class="line">    ss &lt;&lt; x;</div><div class="line">    <span class="keywordflow">return</span> ss.str();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">auto</span> f = [=](std::string s, <span class="keyword">auto</span> element) {</div><div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;f(&quot;</span> + s + <span class="stringliteral">&quot;, &quot;</span> + to_string(element) + <span class="stringliteral">&quot;)&quot;</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// With an initial state</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Foldable.html#ga947602718a53bd7fcd5c20477694cdcd">hana::reverse_fold</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0, 4), <span class="stringliteral">&quot;5&quot;</span>, f)</div><div class="line">            ==</div><div class="line">        <span class="stringliteral">&quot;f(f(f(f(5, 4), 3), 2), 1)&quot;</span></div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">// Without an initial state</span></div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Foldable.html#ga947602718a53bd7fcd5c20477694cdcd">hana::reverse_fold</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0, 4, <span class="stringliteral">&quot;5&quot;</span>), f)</div><div class="line">            ==</div><div class="line">        <span class="stringliteral">&quot;f(f(f(f(5, 4), 3), 2), 1)&quot;</span></div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga8ec3ac9a6f5014db943f61ebc9e1e36e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::size = hana::length</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2size_8hpp.html">boost/hana/fwd/size.hpp</a>&gt;</code></p>

<p>Equivalent to <code>length</code>; provided for consistency with the standard library.This method is an alias to <code>length</code> provided for convenience and consistency with the standard library. As an alias, <code>size</code> is not tag-dispatched on its own and <code>length</code> should be customized instead. </p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="size_8hpp.html">boost/hana/size.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#ga8ec3ac9a6f5014db943f61ebc9e1e36e">hana::size</a>(hana::make_tuple()) == hana::size_c&lt;0&gt;);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#ga8ec3ac9a6f5014db943f61ebc9e1e36e">hana::size</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.0)) == hana::size_c&lt;3&gt;);</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#ga8ec3ac9a6f5014db943f61ebc9e1e36e">hana::size</a>(hana::nothing) == hana::size_c&lt;0&gt;);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Foldable.html#ga8ec3ac9a6f5014db943f61ebc9e1e36e">hana::size</a>(hana::just(<span class="charliteral">&#39;x&#39;</span>)) == hana::size_c&lt;1&gt;);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga650def4b2e98f4273d8b9b7aa5a2fc28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::sum = see documentation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2sum_8hpp.html">boost/hana/fwd/sum.hpp</a>&gt;</code></p>

<p>Compute the sum of the numbers of a structure.More generally, <code>sum</code> will take any foldable structure containing objects forming a Monoid and reduce them using the Monoid's binary operation. The initial state for folding is the identity of the Monoid. It is sometimes necessary to specify the Monoid to use; this is possible by using <code>sum&lt;M&gt;</code>. If no Monoid is specified, the structure will use the Monoid formed by the elements it contains (if it knows it), or <code><a class="el" href="structboost_1_1hana_1_1integral__constant__tag.html" title="Tag representing hana::integral_constant. ">integral_constant_tag</a>&lt;int&gt;</code> otherwise. Hence,. </p>
<div class="fragment"><div class="line">sum&lt;M&gt;(xs) = <a class="code" href="group__group-Foldable.html#ga38c6b3f6b1cbadb9b8432a05ff16b7d2">fold_left</a>(xs, zero&lt;M or inferred Monoid&gt;(), <a class="code" href="group__group-Monoid.html#gaeb5d4a1e967e319712f9e4791948896c">plus</a>)</div><div class="line">sum&lt;&gt; = <a class="code" href="group__group-Foldable.html#ga650def4b2e98f4273d8b9b7aa5a2fc28">sum</a>&lt;integral_constant_tag&lt;int&gt;&gt;</div></div><!-- fragment --><p>For numbers, this will just compute the sum of the numbers in the <code>xs</code> structure.</p>
<dl class="section note"><dt>Note</dt><dd>The elements of the structure are not actually required to be in the same Monoid, but it must be possible to perform <code>plus</code> on any two adjacent elements of the structure, which requires each pair of adjacent element to at least have a common Monoid embedding. The meaning of "adjacent" as used here is that two elements of the structure <code>x</code> and <code>y</code> are adjacent if and only if they are adjacent in the linearization of that structure, as documented by the Iterable concept.</dd></dl>
<h2>Why must we sometimes specify the <code>Monoid</code> by using <code>sum&lt;M&gt;</code>? </h2>
<p>This is because sequence tags like <code><a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples. ">tuple_tag</a></code> are not parameterized (by design). Hence, we do not know what kind of objects are in the sequence, so we can't know a <code>0</code> value of which type should be returned when the sequence is empty. Therefore, the type of the <code>0</code> to return in the empty case must be specified explicitly. Other foldable structures like <code><a class="el" href="structboost_1_1hana_1_1range.html" title="Compile-time half-open interval of hana::integral_constants. ">hana::range</a></code>s will ignore the suggested Monoid because they know the tag of the objects they contain. This inconsistent behavior is a limitation of the current design with non-parameterized tags, but we have no good solution for now.</p>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="range_8hpp.html">boost/hana/range.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sum_8hpp.html">boost/hana/sum.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(hana::sum&lt;&gt;(hana::make_range(hana::int_c&lt;1&gt;, hana::int_c&lt;6&gt;)) == hana::int_c&lt;15&gt;);</div><div class="line"></div><div class="line">static_assert(hana::sum&lt;&gt;(hana::make_tuple(1, hana::int_c&lt;3&gt;, hana::long_c&lt;-5&gt;, 9)) == 8, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">static_assert(hana::sum&lt;unsigned long&gt;(hana::make_tuple(1ul, 3ul)) == 4ul, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7b0c23944364ce61136e10b978ae2170"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::unpack</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2unpack_8hpp.html">boost/hana/fwd/unpack.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Invoke a function with the elements of a Foldable as arguments.Given a function and a foldable structure whose length can be known at compile-time, <code>unpack</code> invokes the function with the contents of that structure. In other words, <code>unpack(xs, f)</code> is equivalent to <code>f(x...)</code>, where <code>x...</code> are the elements of the structure. The length of the structure must be known at compile-time, because the version of <code>f</code>'s <code>operator()</code> that will be compiled depends on the number of arguments it is called with, which has to be known at compile-time. </p>
<p>To create a function that accepts a foldable instead of variadic arguments, see <code>fuse</code> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to expand into the function.</td></tr>
    <tr><td class="paramname">f</td><td>A function to be invoked as <code>f(x...)</code>, where <code>x...</code> are the elements of the structure as-if they had been linearized with <code>to&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples. ">tuple_tag</a>&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="unpack_8hpp.html">boost/hana/unpack.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y, <span class="keyword">auto</span> z) {</div><div class="line">        <span class="keywordflow">return</span> x + y + z;</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(<a class="code" href="group__group-Foldable.html#ga7b0c23944364ce61136e10b978ae2170">hana::unpack</a>(hana::make_tuple(1, 2, 3), add) == 6);</div><div class="line">}</div></div><!-- fragment --><h2>Rationale: <code>unpack</code>'s name and parameter order </h2>
<p>It has been suggested a couple of times that <code>unpack</code> be called <code>apply</code> instead, and that the parameter order be reversed to match that of the <a href="http://en.cppreference.com/w/cpp/experimental/apply">proposed std::apply function</a>. However, the name <code>apply</code> is already used to denote normal function application, an use which is consistent with the Boost MPL library and with the rest of the world, especially the functional programming community. Furthermore, the author of this library considers the proposed <code>std::apply</code> to have both an unfortunate name and an unfortunate parameter order. Indeed, taking the function as the first argument means that using <code>std::apply</code> with a lambda function looks like </p><div class="fragment"><div class="line"><a class="code" href="group__group-functional.html#ga30027c383676084be151ef3c6cf2829f">std::apply</a>([](<span class="keyword">auto</span> ...args) {</div><div class="line">    use(args...);</div><div class="line">}, tuple);</div></div><!-- fragment --><p>which is undeniably ugly because of the trailing <code>, tuple)</code> part on the last line. On the other hand, taking the function as a second argument allows one to write </p><div class="fragment"><div class="line"><a class="code" href="group__group-Foldable.html#ga7b0c23944364ce61136e10b978ae2170">hana::unpack</a>(tuple, [](<span class="keyword">auto</span> ...args) {</div><div class="line">    use(args...);</div><div class="line">});</div></div><!-- fragment --><p>which looks much nicer. Because of these observations, the author of this library feels justified to use <code>unpack</code> instead of <code>apply</code>, and to use a sane parameter order. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
