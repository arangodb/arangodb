<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Boost.Hana: Constant</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.5.0</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group-Constant.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Constant<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The <code>Constant</code> concept represents data that can be manipulated at compile-time. </p>
<p>At its core, <code>Constant</code> is simply a generalization of the principle behind <code><a class="el" href="structstd_1_1integral__constant.html" title="Adapter for std::integral_constants. ">std::integral_constant</a></code> to all types that can be constructed at compile-time, i.e. to all types with a <code>constexpr</code> constructor (also called <a href="http://en.cppreference.com/w/cpp/concept/LiteralType">Literal types</a>). More specifically, a <code>Constant</code> is an object from which a <code>constexpr</code> value may be obtained (through the <code>value</code> method) regardless of the <code>constexpr</code>ness of the object itself.</p>
<p>All <code>Constant</code>s must be somewhat equivalent, in the following sense. Let <code>C(T)</code> and <code>D(U)</code> denote the tags of <code>Constant</code>s holding objects of type <code>T</code> and <code>U</code>, respectively. Then, an object with tag <code>D(U)</code> must be convertible to an object with tag <code>C(T)</code> whenever <code>U</code> is convertible to <code>T</code>, as determined by <code><a class="el" href="structboost_1_1hana_1_1is__convertible.html" title="Returns whether there is a Hana-conversion from a data type to another. ">is_convertible</a></code>. The interpretation here is that a <code>Constant</code> is just a box holding an object of some type, and it should be possible to swap between boxes whenever the objects inside the boxes can be swapped.</p>
<p>Because of this last requirement, one could be tempted to think that specialized "boxes" like <code><a class="el" href="structstd_1_1integral__constant.html" title="Adapter for std::integral_constants. ">std::integral_constant</a></code> are prevented from being <code>Constant</code>s because they are not able to hold objects of any type <code>T</code> (<code><a class="el" href="structstd_1_1integral__constant.html" title="Adapter for std::integral_constants. ">std::integral_constant</a></code> may only hold integral types). This is false; the requirement should be interpreted as saying that whenever <code>C(T)</code> is <em>meaningful</em> (e.g. only when <code>T</code> is integral for <code><a class="el" href="structstd_1_1integral__constant.html" title="Adapter for std::integral_constants. ">std::integral_constant</a></code>) <em>and</em> there exists a conversion from <code>U</code> to <code>T</code>, then a conversion from <code>D(U)</code> to <code>C(T)</code> should also exist. The precise requirements for being a <code>Constant</code> are embodied in the following laws.</p>
<h2>Minimal complete definition </h2>
<p><code>value</code> and <code>to</code>, satisfying the laws below.</p>
<h2>Laws </h2>
<p>Let <code>c</code> be an object of with tag <code>C</code>, which represents a <code>Constant</code> holding an object with tag <code>T</code>. The first law ensures that the value of the wrapped object is always a constant expression by requiring the following to be well-formed: </p><div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> x = hana::value&lt;decltype(c)&gt;();</div></div><!-- fragment --><p>This means that the <code>value</code> function must return an object that can be constructed at compile-time. It is important to note how <code>value</code> only receives the type of the object and not the object itself. This is the core of the <code>Constant</code> concept; it means that the only information required to implement <code>value</code> must be stored in the <em>type</em> of its argument, and hence be available statically.</p>
<p>The second law that must be satisfied ensures that <code>Constant</code>s are basically dumb boxes, which makes it possible to provide models for many concepts without much work from the user. The law simply asks for the following expression to be valid: </p><div class="fragment"><div class="line">to&lt;C&gt;(i)</div></div><!-- fragment --><p> where, <code>i</code> is an <em>arbitrary</em> <code>Constant</code> holding an internal value with a tag that can be converted to <code>T</code>, as determined by the <code><a class="el" href="structboost_1_1hana_1_1is__convertible.html" title="Returns whether there is a Hana-conversion from a data type to another. ">hana::is_convertible</a></code> metafunction. In other words, whenever <code>U</code> is convertible to <code>T</code>, a <code>Constant</code> holding a <code>U</code> is convertible to a <code>Constant</code> holding a <code>T</code>, if such a <code>Constant</code> can be created.</p>
<p>Finally, the tag <code>C</code> must provide a nested <code>value_type</code> alias to <code>T</code>, which allows us to query the tag of the inner value held by objects with tag <code>C</code>. In other words, the following must be true for any object <code>c</code> with tag <code>C</code>: </p><div class="fragment"><div class="line">std::is_same&lt;</div><div class="line">    C::value_type,</div><div class="line">    tag_of&lt;decltype(hana::value(c))&gt;::type</div><div class="line">&gt;<a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">::value</a></div></div><!-- fragment --><h2>Refined concepts </h2>
<p>In certain cases, a <code>Constant</code> can automatically be made a model of another concept. In particular, if a <code>Constant</code> <code>C</code> is holding an object of tag <code>T</code>, and if <code>T</code> models a concept <code>X</code>, then <code>C</code> may in most cases model <code>X</code> by simply performing whatever operation is required on its underlying value, and then wrapping the result back in a <code>C</code>.</p>
<p>More specifically, if a <code>Constant</code> <code>C</code> has an underlying value (<code>C::value_type</code>) which is a model of <code>Comparable</code>, <code>Orderable</code>, <code>Logical</code>, or <code>Monoid</code> up to <code>EuclideanRing</code>, then <code>C</code> must also be a model of those concepts. In other words, when <code>C::value_type</code> models one of the listed concepts, <code>C</code> itself must also model that concept. However, note that free models are provided for all of those concepts, so no additional work must be done.</p>
<p>While it would be possible in theory to provide models for concepts like <code>Foldable</code> too, only a couple of concepts are useful to have as <code>Constant</code> in practice. Providing free models for the concepts listed above is useful because it allows various types of integral constants (<code><a class="el" href="structstd_1_1integral__constant.html" title="Adapter for std::integral_constants. ">std::integral_constant</a></code>, <code><a class="el" href="structboost_1_1mpl_1_1integral__c.html" title="Adapter for IntegralConstants from the Boost.MPL. ">mpl::integral_c</a></code>, etc...) to easily have models for them just by defining the <code>Constant</code> concept.</p>
<dl class="section remark"><dt>Remarks</dt><dd>An interesting observation is that <code>Constant</code> is actually the canonical embedding of the subcategory of <code>constexpr</code> things into the Hana category, which contains everything in this library. Hence, whatever is true in that subcategory is also true here, via this functor. This is why we can provide models of any concept that works on <code>constexpr</code> things for Constants, by simply passing them through that embedding.</dd></dl>
<h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1integral__constant.html" title="Compile-time value of an integral type. ">hana::integral_constant</a></code></p>
<h2>Provided conversion to the tag of the underlying value </h2>
<p>Any <code>Constant</code> <code>c</code> holding an underlying value of tag <code>T</code> is convertible to any tag <code>U</code> such that <code>T</code> is convertible to <code>U</code>. Specifically, the conversion is equivalent to </p><div class="fragment"><div class="line">to&lt;U&gt;(c) == to&lt;U&gt;(<a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>&lt;decltype(c)&gt;())</div></div><!-- fragment --><p>Also, those conversions are marked as an embedding whenever the conversion of underlying types is an embedding. This is to allow Constants to inter-operate with <code>constexpr</code> objects easily: </p><div class="fragment"><div class="line"><a class="code" href="group__group-Monoid.html#gaeb5d4a1e967e319712f9e4791948896c">plus</a>(int_c&lt;1&gt;, 1) == 2</div></div><!-- fragment --><p>Strictly speaking, <b>this is sometimes a violation</b> of what it means to be an embedding. Indeed, while there exists an embedding from any Constant to a <code>constexpr</code> object (since Constant is just the canonical inclusion), there is no embedding from a Constant to a runtime object since we would lose the ability to define the <code>value</code> method (the <code>constexpr</code>ness of the object would have been lost). Since there is no way to distinguish <code>constexpr</code> and non-<code>constexpr</code> objects based on their type, Hana has no way to know whether the conversion is to a <code>constexpr</code> object of not. In other words, the <code>to</code> method has no way to differentiate between </p><div class="fragment"><div class="line">constexpr <span class="keywordtype">int</span> i = hana::to&lt;int&gt;(int_c&lt;1&gt;);</div></div><!-- fragment --><p> which is an embedding, and </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = hana::to&lt;int&gt;(int_c&lt;1&gt;);</div></div><!-- fragment --><p>which isn't. To be on the safer side, we could mark the conversion as not-an-embedding. However, if e.g. the conversion from <code><a class="el" href="structboost_1_1hana_1_1integral__constant__tag.html" title="Tag representing hana::integral_constant. ">integral_constant_tag</a>&lt;int&gt;</code> to <code>int</code> was not marked as an embedding, we would have to write <code>plus(to&lt;int&gt;(int_c&lt;1&gt;), 1)</code> instead of just <code>plus(int_c&lt;1&gt;, 1)</code>, which is cumbersome. Hence, the conversion is marked as an embedding, but this also means that code like </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 1;</div><div class="line"><a class="code" href="group__group-Monoid.html#gaeb5d4a1e967e319712f9e4791948896c">plus</a>(int_c&lt;1&gt;, i);</div></div><!-- fragment --><p> will be considered valid, which implicitly loses the fact that <code>int_c&lt;1&gt;</code> is a Constant, and hence does not follow the usual rules for cross-type operations in Hana.</p>
<h2>Provided common data type </h2>
<p>Because of the requirement that <code>Constant</code>s be interchangeable when their contents are compatible, two <code>Constant</code>s <code>A</code> and <code>B</code> will have a common data type whenever <code>A::value_type</code> and <code>B::value_type</code> have one. Their common data type is an unspecified <code>Constant</code> <code>C</code> such that <code>C::value_type</code> is exactly <code>common_t&lt;A::value_type, B::value_type&gt;</code>. A specialization of the <code>common</code> metafunction is provided for <code>Constant</code>s to reflect this.</p>
<p>In the same vein, a common data type is also provided from any constant <code>A</code> to a type <code>T</code> such that <code>A::value_type</code> and <code>T</code> share a common type. The common type between <code>A</code> and <code>T</code> is obviously the common type between <code>A::value_type</code> and <code>T</code>. As explained above in the section on conversions, this is sometimes a violation of the definition of a common type, because there must be an embedding to the common type, which is not always the case. For the same reasons as explained above, this common type is still provided.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga1687520692a6b0c49e3a69de2980f388"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1687520692a6b0c49e3a69de2980f388"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">boost::hana::value</a></td></tr>
<tr class="memdesc:ga1687520692a6b0c49e3a69de2980f388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the compile-time value associated to a constant.This function returns the value associated to a <code>Constant</code>. That value is always a constant expression. The normal way of using <code>value</code> on an object <code>c</code> is.  <a href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">More...</a><br /></td></tr>
<tr class="separator:ga1687520692a6b0c49e3a69de2980f388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab46a092deeb205f2c92c335d4312a991"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Constant.html#gab46a092deeb205f2c92c335d4312a991">boost::hana::value_of</a></td></tr>
<tr class="memdesc:gab46a092deeb205f2c92c335d4312a991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>value</code>, but can be passed to higher-order algorithms.This function object is equivalent to <code>value</code>, except it can be passed to higher order algorithms because it is a function object. <code>value</code> can't be passed to higher-order algorithms because it is implemented as an overloaded function.  <a href="group__group-Constant.html#gab46a092deeb205f2c92c335d4312a991">More...</a><br /></td></tr>
<tr class="separator:gab46a092deeb205f2c92c335d4312a991"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga1687520692a6b0c49e3a69de2980f388"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2value_8hpp.html">boost/hana/fwd/value.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= []() -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Return the compile-time value associated to a constant.This function returns the value associated to a <code>Constant</code>. That value is always a constant expression. The normal way of using <code>value</code> on an object <code>c</code> is. </p>
<div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> result = hana::value&lt;decltype(c)&gt;();</div></div><!-- fragment --><p>However, for convenience, an overload of <code>value</code> is provided so that it can be called as: </p><div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> result = <a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">hana::value</a>(c);</div></div><!-- fragment --><p>This overload works by taking a <code>const&amp;</code> to its argument, and then forwarding to the first version of <code>value</code>. Since it does not use its argument, the result can still be a constant expression, even if the argument is not a constant expression.</p>
<dl class="section note"><dt>Note</dt><dd><code>value&lt;T&gt;()</code> is tag-dispatched as <code>value_impl&lt;C&gt;::apply&lt;T&gt;()</code>, where <code>C</code> is the tag of <code>T</code>.</dd>
<dd>
<code><a class="el" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388" title="Return the compile-time value associated to a constant.This function returns the value associated to ...">hana::value</a></code> is an overloaded function, not a function object. Hence, it can't be passed to higher-order algorithms. If you need an equivalent function object, use <code><a class="el" href="group__group-Constant.html#gab46a092deeb205f2c92c335d4312a991" title="Equivalent to value, but can be passed to higher-order algorithms.This function object is equivalent ...">hana::value_of</a></code> instead.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integral__constant_8hpp.html">boost/hana/integral_constant.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="value_8hpp.html">boost/hana/value.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">auto</span> i = hana::integral_c&lt;int, 3&gt;; <span class="comment">// notice no constexpr</span></div><div class="line">    static_assert(<a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">hana::value</a>&lt;decltype(i)&gt;() == 3, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">    static_assert(<a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">hana::value</a>(i) == 3, <span class="stringliteral">&quot;value(i) is always a constant expression!&quot;</span>);</div><div class="line">}</div></div><!-- fragment --> 
<p>Referenced by <a class="el" href="namespaceboost_1_1hana_1_1literals.html#a85ac3c47d02722a334181aab540e732c">boost::hana::literals::operator&quot;&quot;_c()</a>, <a class="el" href="namespaceboost_1_1hana_1_1literals.html#a325859c7db2c3f8e6a4bfab5a81a6dcb">boost::hana::literals::operator&quot;&quot;_s()</a>, and <a class="el" href="structboost_1_1hana_1_1optional.html#adf824827b5d6f8c87d23b9526b9f35d2">boost::hana::optional&lt; T &gt;::optional()</a>.</p>

</div>
</div>
<a class="anchor" id="gab46a092deeb205f2c92c335d4312a991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::value_of</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2value_8hpp.html">boost/hana/fwd/value.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> <span class="keyword">const</span>&amp; c) -&gt; decltype(<span class="keyword">auto</span>) {</div><div class="line">        <span class="keywordflow">return</span> hana::value(c);</div><div class="line">    }</div></div><!-- fragment -->
<p>Equivalent to <code>value</code>, but can be passed to higher-order algorithms.This function object is equivalent to <code>value</code>, except it can be passed to higher order algorithms because it is a function object. <code>value</code> can't be passed to higher-order algorithms because it is implemented as an overloaded function. </p>
<dl class="section note"><dt>Note</dt><dd>This function is a simple alias to <code>value</code>, and hence it is not tag-dispatched and can't be customized.</dd></dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transform_8hpp.html">boost/hana/transform.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="value_8hpp.html">boost/hana/value.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    constexpr <span class="keyword">auto</span> xs = hana::tuple_c&lt;int, 1, 2, 3, 4, 5&gt;;</div><div class="line">    constexpr <span class="keyword">auto</span> vs = <a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">hana::transform</a>(xs, <a class="code" href="group__group-Constant.html#gab46a092deeb205f2c92c335d4312a991">hana::value_of</a>);</div><div class="line">    static_assert(vs == hana::make_tuple(1, 2, 3, 4, 5), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
