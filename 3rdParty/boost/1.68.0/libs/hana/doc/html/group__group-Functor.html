<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Boost.Hana: Functor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
// Copyright Louis Dionne 2013-2017
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
MathJax.Hub.Config({
    "HTML-CSS": {
        linebreaks: {
            automatic: true,
            width: "75% container"
        }
    }
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Additional javascript for drawing charts. -->
<script type="text/javascript" src="highcharts.js"></script>
<script type="text/javascript" src="highcharts-data.js"></script>
<script type="text/javascript" src="highcharts-exporting.js"></script>
<script type="text/javascript" src="chart.js"></script>
<script type="text/javascript" src="hana.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Boost.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Hana
   &#160;<span id="projectnumber">1.5.0</span>
   </div>
   <div id="projectbrief">Your standard library for metaprogramming</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group-Functor.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Functor<div class="ingroups"><a class="el" href="group__group-concepts.html">Concepts</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The <code>Functor</code> concept represents types that can be mapped over. </p>
<p>Intuitively, a <a href="http://en.wikipedia.org/wiki/Functor">Functor</a> is some kind of box that can hold generic data and map a function over this data to create a new, transformed box. Because we are only interested in mapping a function over the contents of a black box, the only real requirement for being a functor is to provide a function which can do the mapping, along with a couple of guarantees that the mapping is well-behaved. Those requirements are made precise in the laws below. The pattern captured by <code>Functor</code> is very general, which makes it widely useful. A lot of objects can be made <code>Functor</code>s in one way or another, the most obvious example being sequences with the usual mapping of the function on each element. While this documentation will not go into much more details about the nature of functors, the <a href="https://wiki.haskell.org/Typeclassopedia#Functor">Typeclassopedia</a> is a nice Haskell-oriented resource for such information.</p>
<p>Functors are parametric data types which are parameterized over the data type of the objects they contain. Like everywhere else in Hana, this parametricity is only at the documentation level and it is not enforced.</p>
<p>In this library, the mapping function is called <code>transform</code> after the <code>std::transform</code> algorithm, but other programming languages have given it different names (usually <code>map</code>).</p>
<dl class="section note"><dt>Note</dt><dd>The word <em>functor</em> comes from functional programming, where the concept has been used for a while, notably in the Haskell programming language. Haskell people borrowed the term from <a href="http://en.wikipedia.org/wiki/Category_theory">category theory</a>, which, broadly speaking, is a field of mathematics dealing with abstract structures and transformations between those structures.</dd></dl>
<h2>Minimal complete definitions </h2>
<ol type="1">
<li><code>transform</code><br />
When <code>transform</code> is specified, <code>adjust_if</code> is defined analogously to <div class="fragment"><div class="line"><a class="code" href="group__group-Functor.html#gaa0490f57047c1b0d75fbe233688358f4">adjust_if</a>(xs, pred, f) = <a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(xs, [](x){</div><div class="line">    <span class="keywordflow">if</span> pred(x) <a class="code" href="group__group-Monad.html#gaaddd3789de43cf989babb10cdc0b447a">then</a> f(x) else x</div><div class="line">})</div></div><!-- fragment --></li>
<li><code>adjust_if</code><br />
When <code>adjust_if</code> is specified, <code>transform</code> is defined analogously to <div class="fragment"><div class="line"><a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(xs, f) = <a class="code" href="group__group-Functor.html#gaa0490f57047c1b0d75fbe233688358f4">adjust_if</a>(xs, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(<span class="keyword">true</span>), f)</div></div><!-- fragment --></li>
</ol>
<h2>Laws </h2>
<p>Let <code>xs</code> be a Functor with tag <code>F(A)</code>, \( f : A \to B \) and \( g : B \to C \). The following laws must be satisfied: </p><div class="fragment"><div class="line"><a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(xs, <span class="keywordtype">id</span>) == xs</div><div class="line"><a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(xs, <a class="code" href="group__group-functional.html#ga3b16146e53efcdf9ecbb9a7b21f8cd0b">compose</a>(g, f)) == <a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(<a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(xs, f), g)</div></div><!-- fragment --><p> The first line says that mapping the identity function should not do anything, which precludes the functor from doing something nasty behind the scenes. The second line states that mapping the composition of two functions is the same as mapping the first function, and then the second on the result. While the usual functor laws are usually restricted to the above, this library includes other convenience methods and they should satisfy the following equations. Let <code>xs</code> be a Functor with tag <code>F(A)</code>, \( f : A \to A \), \( \mathrm{pred} : A \to \mathrm{Bool} \) for some <code>Logical</code> <code>Bool</code>, and <code>oldval</code>, <code>newval</code>, <code>value</code> objects of tag <code>A</code>. Then, </p><div class="fragment"><div class="line"><a class="code" href="group__group-Functor.html#ga7cc731e67ebc1f5303be1a97b2d5e0cd">adjust</a>(xs, <a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>, f) == <a class="code" href="group__group-Functor.html#gaa0490f57047c1b0d75fbe233688358f4">adjust_if</a>(xs, <a class="code" href="group__group-Comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">equal</a>.to(<a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>), f)</div><div class="line"><a class="code" href="group__group-Functor.html#gaa0490f57047c1b0d75fbe233688358f4">adjust_if</a>(xs, pred, f) == <a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(xs, [](x){</div><div class="line">    <span class="keywordflow">if</span> pred(x) <a class="code" href="group__group-Monad.html#gaaddd3789de43cf989babb10cdc0b447a">then</a> f(x) else x</div><div class="line">})</div><div class="line"><a class="code" href="group__group-Functor.html#ga1d21b4bccd16367d164fbe0d9ef52150">replace_if</a>(xs, pred, <a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>) == <a class="code" href="group__group-Functor.html#gaa0490f57047c1b0d75fbe233688358f4">adjust_if</a>(xs, pred, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(<a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>))</div><div class="line"><a class="code" href="group__group-Functor.html#ga94cd3a75d59d70d77cfce144c4acf8ab">replace</a>(xs, oldval, newval) == <a class="code" href="group__group-Functor.html#ga1d21b4bccd16367d164fbe0d9ef52150">replace_if</a>(xs, <a class="code" href="group__group-Comparable.html#gacaf1ebea6b3ab96ac9dcb82f0e64e547">equal</a>.<a class="code" href="group__group-core.html#gadc70755c1d059139297814fb3bfeb91e">to</a>(oldval), newval)</div><div class="line"><a class="code" href="group__group-Functor.html#ga2ce68d315f981ef35751c4dc25ad5642">fill</a>(xs, <a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>)             == <a class="code" href="group__group-Functor.html#ga1d21b4bccd16367d164fbe0d9ef52150">replace_if</a>(xs, <a class="code" href="group__group-functional.html#ga835970cb25a0c8dc200f1e5f8943538b">always</a>(true), <a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>)</div></div><!-- fragment --><p> The default definition of the methods will satisfy these equations.</p>
<h2>Concrete models </h2>
<p><code><a class="el" href="structboost_1_1hana_1_1lazy.html" title="hana::lazy implements superficial laziness via a monadic interface. ">hana::lazy</a></code>, <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code>, <code><a class="el" href="structboost_1_1hana_1_1tuple.html" title="General purpose index-based heterogeneous sequence with a fixed length. ">hana::tuple</a></code></p>
<h2>Structure-preserving functions for Functors </h2>
<p>A mapping between two functors which also preserves the functor laws is called a natural transformation (the term comes from category theory). A natural transformation is a function <code>f</code> from a functor <code>F</code> to a functor <code>G</code> such that for every other function <code>g</code> with an appropriate signature and for every object <code>xs</code> of tag <code>F(X)</code>, </p><div class="fragment"><div class="line">f(<a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(xs, g)) == <a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(f(xs), g)</div></div><!-- fragment --><p>There are several examples of such transformations, like <code>to&lt;<a class="el" href="structboost_1_1hana_1_1tuple__tag.html" title="Tag representing hana::tuples. ">tuple_tag</a>&gt;</code> when applied to an optional value. Indeed, for any function <code>g</code> and <code><a class="el" href="structboost_1_1hana_1_1optional.html" title="Optional value whose optional-ness is known at compile-time. ">hana::optional</a></code> <code>opt</code>, </p><div class="fragment"><div class="line">to&lt;tuple_tag&gt;(<a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(opt, g)) == <a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">transform</a>(to&lt;tuple_tag&gt;(opt), g)</div></div><!-- fragment --><p>Of course, natural transformations are not limited to the <code>to&lt;...&gt;</code> functions. However, note that any conversion function between Functors should be natural for the behavior of the conversion to be intuitive.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga7cc731e67ebc1f5303be1a97b2d5e0cd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Functor.html#ga7cc731e67ebc1f5303be1a97b2d5e0cd">boost::hana::adjust</a></td></tr>
<tr class="memdesc:ga7cc731e67ebc1f5303be1a97b2d5e0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function on all the elements of a structure that compare equal to some value.  <a href="group__group-Functor.html#ga7cc731e67ebc1f5303be1a97b2d5e0cd">More...</a><br /></td></tr>
<tr class="separator:ga7cc731e67ebc1f5303be1a97b2d5e0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0490f57047c1b0d75fbe233688358f4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Functor.html#gaa0490f57047c1b0d75fbe233688358f4">boost::hana::adjust_if</a></td></tr>
<tr class="memdesc:gaa0490f57047c1b0d75fbe233688358f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function on all the elements of a structure satisfying a predicate.Given a Functor, a predicate <code>pred</code> and a function <code>f</code>, <code>adjust_if</code> will <em>adjust</em> the elements of the Functor that satisfy the predicate with the function <code>f</code>. In other words, <code>adjust_if</code> will return a new Functor equal to the original one, except that the elements satisfying the predicate will be transformed with the given function. Elements for which the predicate is not satisfied are left untouched, and they are kept as-is in the resulting Functor.  <a href="group__group-Functor.html#gaa0490f57047c1b0d75fbe233688358f4">More...</a><br /></td></tr>
<tr class="separator:gaa0490f57047c1b0d75fbe233688358f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce68d315f981ef35751c4dc25ad5642"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Functor.html#ga2ce68d315f981ef35751c4dc25ad5642">boost::hana::fill</a></td></tr>
<tr class="memdesc:ga2ce68d315f981ef35751c4dc25ad5642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all the elements of a structure with a fixed value.  <a href="group__group-Functor.html#ga2ce68d315f981ef35751c4dc25ad5642">More...</a><br /></td></tr>
<tr class="separator:ga2ce68d315f981ef35751c4dc25ad5642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94cd3a75d59d70d77cfce144c4acf8ab"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Functor.html#ga94cd3a75d59d70d77cfce144c4acf8ab">boost::hana::replace</a></td></tr>
<tr class="memdesc:ga94cd3a75d59d70d77cfce144c4acf8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all the elements of a structure that compare equal to some <code>value</code> with some new fixed value.  <a href="group__group-Functor.html#ga94cd3a75d59d70d77cfce144c4acf8ab">More...</a><br /></td></tr>
<tr class="separator:ga94cd3a75d59d70d77cfce144c4acf8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d21b4bccd16367d164fbe0d9ef52150"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Functor.html#ga1d21b4bccd16367d164fbe0d9ef52150">boost::hana::replace_if</a></td></tr>
<tr class="memdesc:ga1d21b4bccd16367d164fbe0d9ef52150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all the elements of a structure satisfying a <code>predicate</code> with a fixed value.  <a href="group__group-Functor.html#ga1d21b4bccd16367d164fbe0d9ef52150">More...</a><br /></td></tr>
<tr class="separator:ga1d21b4bccd16367d164fbe0d9ef52150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8975f6e55375d5b6038a9c36ee63e7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">boost::hana::transform</a></td></tr>
<tr class="memdesc:ga5a8975f6e55375d5b6038a9c36ee63e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a function over a <code>Functor</code>.  <a href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">More...</a><br /></td></tr>
<tr class="separator:ga5a8975f6e55375d5b6038a9c36ee63e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga7cc731e67ebc1f5303be1a97b2d5e0cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::adjust</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2adjust_8hpp.html">boost/hana/fwd/adjust.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>, <span class="keyword">auto</span>&amp;&amp; f) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div><div class="ttc" id="group__group-Constant_html_ga1687520692a6b0c49e3a69de2980f388"><div class="ttname"><a href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">boost::hana::value</a></div><div class="ttdeci">constexpr auto value</div><div class="ttdoc">Return the compile-time value associated to a constant.This function returns the value associated to ...</div><div class="ttdef"><b>Definition:</b> value.hpp:54</div></div>
</div><!-- fragment -->
<p>Apply a function on all the elements of a structure that compare equal to some value. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a Functor and <code>U</code> a type that can be compared with <code>T</code>'s, the signature is \( \mathtt{adjust} : F(T) \times U \times (T \to T) \to F(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to adjust with <code>f</code>.</td></tr>
    <tr><td class="paramname">value</td><td>An object that is compared with each element <code>x</code> of the structure. Elements of the structure that compare equal to <code>value</code> are adjusted with the <code>f</code> function.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> on the element(s) of the structure that compare equal to <code>value</code>.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="adjust_8hpp.html">boost/hana/adjust.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> <a class="code" href="group__group-Group.html#ga02e81002f40ba52eac4cf1974c7e0cdb">negate</a> = [](<span class="keyword">auto</span> x) {</div><div class="line">    <span class="keywordflow">return</span> -x;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Functor.html#ga7cc731e67ebc1f5303be1a97b2d5e0cd">hana::adjust</a>(hana::make_tuple(1, 4, 9, 2, 3, 4), 4, <a class="code" href="group__group-Group.html#ga02e81002f40ba52eac4cf1974c7e0cdb">negate</a>)</div><div class="line">        ==</div><div class="line">        hana::make_tuple(1, -4, 9, 2, 3, -4)</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa0490f57047c1b0d75fbe233688358f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::adjust_if</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2adjust__if_8hpp.html">boost/hana/fwd/adjust_if.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; pred, <span class="keyword">auto</span> <span class="keyword">const</span>&amp; f) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Apply a function on all the elements of a structure satisfying a predicate.Given a Functor, a predicate <code>pred</code> and a function <code>f</code>, <code>adjust_if</code> will <em>adjust</em> the elements of the Functor that satisfy the predicate with the function <code>f</code>. In other words, <code>adjust_if</code> will return a new Functor equal to the original one, except that the elements satisfying the predicate will be transformed with the given function. Elements for which the predicate is not satisfied are left untouched, and they are kept as-is in the resulting Functor. </p>
<h2>Signature </h2>
<p>Given a <code>Functor</code> <code>F</code> and a <code>Logical</code> <code>Bool</code>, the signature is \( \mathtt{adjust\_if} : F(T) \times (T \to Bool) \times (T \to T) \to F(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to adjust with <code>f</code>.</td></tr>
    <tr><td class="paramname">pred</td><td>A function called as <code>pred(x)</code> for each element of the Functor, and returning whether <code>f</code> should be applied on that element.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> on the element(s) of the Functor that satisfy the predicate.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="adjust__if_8hpp.html">boost/hana/adjust_if.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> negative = [](<span class="keyword">auto</span> x) {</div><div class="line">    <span class="keywordflow">return</span> x &lt; 0;</div><div class="line">};</div><div class="line"></div><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> <a class="code" href="group__group-Group.html#ga02e81002f40ba52eac4cf1974c7e0cdb">negate</a> = [](<span class="keyword">auto</span> x) {</div><div class="line">    <span class="keywordflow">return</span> -x;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Functor.html#gaa0490f57047c1b0d75fbe233688358f4">hana::adjust_if</a>(hana::make_tuple(-3, -2, -1, 0, 1, 2, 3), negative, <a class="code" href="group__group-Group.html#ga02e81002f40ba52eac4cf1974c7e0cdb">negate</a>)</div><div class="line">                ==</div><div class="line">        hana::make_tuple(3, 2, 1, 0, 1, 2, 3)</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga2ce68d315f981ef35751c4dc25ad5642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::fill</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2fill_8hpp.html">boost/hana/fwd/fill.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div><div class="ttc" id="group__group-Constant_html_ga1687520692a6b0c49e3a69de2980f388"><div class="ttname"><a href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">boost::hana::value</a></div><div class="ttdeci">constexpr auto value</div><div class="ttdoc">Return the compile-time value associated to a constant.This function returns the value associated to ...</div><div class="ttdef"><b>Definition:</b> value.hpp:54</div></div>
</div><!-- fragment -->
<p>Replace all the elements of a structure with a fixed value. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a Functor, the signature is \( \mathtt{fill} : F(T) \times U \to F(U) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to fill with a <code>value</code>.</td></tr>
    <tr><td class="paramname">value</td><td>A value by which every element <code>x</code> of the structure is replaced, unconditionally.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fill_8hpp.html">boost/hana/fill.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    static_assert(</div><div class="line">        <a class="code" href="group__group-Functor.html#ga2ce68d315f981ef35751c4dc25ad5642">hana::fill</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, 3.3, <span class="keyword">nullptr</span>), <span class="charliteral">&#39;x&#39;</span>)</div><div class="line">            ==</div><div class="line">        hana::make_tuple(<span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;x&#39;</span>, <span class="charliteral">&#39;x&#39;</span>)</div><div class="line">    , <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Functor.html#ga2ce68d315f981ef35751c4dc25ad5642">hana::fill</a>(hana::nothing, <span class="charliteral">&#39;x&#39;</span>) == hana::nothing);</div><div class="line">    static_assert(<a class="code" href="group__group-Functor.html#ga2ce68d315f981ef35751c4dc25ad5642">hana::fill</a>(hana::just(<span class="charliteral">&#39;y&#39;</span>), <span class="charliteral">&#39;x&#39;</span>) == hana::just(<span class="charliteral">&#39;x&#39;</span>), <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga94cd3a75d59d70d77cfce144c4acf8ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::replace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2replace_8hpp.html">boost/hana/fwd/replace.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; oldval, <span class="keyword">auto</span>&amp;&amp; newval) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Replace all the elements of a structure that compare equal to some <code>value</code> with some new fixed value. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a Functor and <code>U</code> a type that can be compared with <code>T</code>, the signature is \( \mathtt{replace} : F(T) \times U \times T \to F(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to replace elements of.</td></tr>
    <tr><td class="paramname">oldval</td><td>An object compared with each element of the structure. Elements of the structure that compare equal to <code>oldval</code> are replaced by <code>newval</code> in the new structure.</td></tr>
    <tr><td class="paramname">newval</td><td>A value by which every element <code>x</code> of the structure that compares equal to <code>oldval</code> is replaced.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="replace_8hpp.html">boost/hana/replace.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">static_assert(</div><div class="line">    <a class="code" href="group__group-Functor.html#ga94cd3a75d59d70d77cfce144c4acf8ab">hana::replace</a>(hana::make_tuple(1, 1, 1, 2, 3, 1, 4, 5), 1, 0)</div><div class="line">            ==</div><div class="line">    hana::make_tuple(0, 0, 0, 2, 3, 0, 4, 5)</div><div class="line">, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() { }</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga1d21b4bccd16367d164fbe0d9ef52150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::replace_if</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2replace__if_8hpp.html">boost/hana/fwd/replace_if.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; predicate, <span class="keyword">auto</span>&amp;&amp; <a class="code" href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">value</a>) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div><div class="ttc" id="group__group-Constant_html_ga1687520692a6b0c49e3a69de2980f388"><div class="ttname"><a href="group__group-Constant.html#ga1687520692a6b0c49e3a69de2980f388">boost::hana::value</a></div><div class="ttdeci">constexpr auto value</div><div class="ttdoc">Return the compile-time value associated to a constant.This function returns the value associated to ...</div><div class="ttdef"><b>Definition:</b> value.hpp:54</div></div>
</div><!-- fragment -->
<p>Replace all the elements of a structure satisfying a <code>predicate</code> with a fixed value. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a Functor and <code>Bool</code> a Logical, the signature is \( \mathtt{replace\_if} : F(T) \times (T \to Bool) \times T \to F(T) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to replace elements of.</td></tr>
    <tr><td class="paramname">predicate</td><td>A function called as <code>predicate(x)</code> for element(s) <code>x</code> of the structure and returning a <code>Logical</code> representing whether <code>x</code> should be replaced by <code>value</code>.</td></tr>
    <tr><td class="paramname">value</td><td>A value by which every element <code>x</code> of the structure for which <code>predicate</code> returns a true-valued <code>Logical</code> is replaced.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">boost/hana/config.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="replace__if_8hpp.html">boost/hana/replace_if.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"></div><div class="line"></div><div class="line">BOOST_HANA_CONSTEXPR_LAMBDA <span class="keyword">auto</span> negative = [](<span class="keyword">auto</span> x) {</div><div class="line">    <span class="keywordflow">return</span> x &lt; 0;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#gac7aafc41e4dcc7d1f1929fb00f010d2a">BOOST_HANA_CONSTEXPR_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Functor.html#ga1d21b4bccd16367d164fbe0d9ef52150">hana::replace_if</a>(hana::make_tuple(-3, -2, -1, 0, 1, 2, 3), negative, 0)</div><div class="line">                ==</div><div class="line">        hana::make_tuple(0, 0, 0, 0, 1, 2, 3)</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga5a8975f6e55375d5b6038a9c36ee63e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto boost::hana::transform</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fwd_2transform_8hpp.html">boost/hana/fwd/transform.hpp</a>&gt;</code></p>
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;&amp; xs, <span class="keyword">auto</span>&amp;&amp; f) {</div><div class="line">        <span class="keywordflow">return</span> tag-dispatched;</div><div class="line">    }</div></div><!-- fragment -->
<p>Map a function over a <code>Functor</code>. </p>
<h2>Signature </h2>
<p>Given <code>F</code> a Functor, the signature is \( \mathtt{transform} : F(T) \times (T \to U) \to F(U) \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs</td><td>The structure to map <code>f</code> over.</td></tr>
    <tr><td class="paramname">f</td><td>A function called as <code>f(x)</code> on element(s) <code>x</code> of the structure, and returning a new value to replace <code>x</code> in the structure.</td></tr>
  </table>
  </dd>
</dl>
<h2>Example </h2>
<div class="fragment"><div class="line"><span class="comment">// Copyright Louis Dionne 2013-2017</span></div><div class="line"><span class="comment">// Distributed under the Boost Software License, Version 1.0.</span></div><div class="line"><span class="comment">// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="assert_8hpp.html">boost/hana/assert.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="equal_8hpp.html">boost/hana/equal.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8hpp.html">boost/hana/optional.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transform_8hpp.html">boost/hana/transform.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tuple_8hpp.html">boost/hana/tuple.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type_8hpp.html">boost/hana/type.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div><div class="line"><span class="keyword">namespace </span>hana = <a class="code" href="namespaceboost_1_1hana.html">boost::hana</a>;</div><div class="line"><span class="keyword">using namespace </span>std::literals;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">auto</span> to_string = [](<span class="keyword">auto</span> x) {</div><div class="line">    std::ostringstream ss;</div><div class="line">    ss &lt;&lt; x;</div><div class="line">    <span class="keywordflow">return</span> ss.str();</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">hana::transform</a>(hana::make_tuple(1, <span class="charliteral">&#39;2&#39;</span>, <span class="stringliteral">&quot;345&quot;</span>, std::string{<span class="stringliteral">&quot;67&quot;</span>}), to_string)</div><div class="line">                ==</div><div class="line">        hana::make_tuple(<span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>, <span class="stringliteral">&quot;345&quot;</span>, <span class="stringliteral">&quot;67&quot;</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(<a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">hana::transform</a>(hana::nothing, to_string) == hana::nothing);</div><div class="line">    <a class="code" href="group__group-assertions.html#ga29b2b21ffa5513e5b706c50ffee980af">BOOST_HANA_RUNTIME_CHECK</a>(<a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">hana::transform</a>(hana::just(123), to_string) == hana::just(<span class="stringliteral">&quot;123&quot;</span>s));</div><div class="line"></div><div class="line">    <a class="code" href="group__group-assertions.html#ga4bf9e0c46c44e21fbe5c5fbb3ace8356">BOOST_HANA_CONSTANT_CHECK</a>(</div><div class="line">        <a class="code" href="group__group-Functor.html#ga5a8975f6e55375d5b6038a9c36ee63e7">hana::transform</a>(hana::tuple_t&lt;<span class="keywordtype">void</span>, <span class="keywordtype">int</span>(), <span class="keywordtype">char</span>[10]&gt;, hana::metafunction&lt;std::add_pointer&gt;)</div><div class="line">                ==</div><div class="line">        hana::tuple_t&lt;<span class="keywordtype">void</span>*, <span class="keywordtype">int</span>(*)(), <span class="keywordtype">char</span>(*)[10]&gt;</div><div class="line">    );</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Copyright Louis Dionne 2013-2017
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)
-->
<!-- boost-no-inspect -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
