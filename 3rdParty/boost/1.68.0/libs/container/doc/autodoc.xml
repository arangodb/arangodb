<?xml version="1.0" standalone="yes"?>
<library-reference id="boost_container_header_reference"><title>Boost.Container Header Reference</title><header name="boost/container/adaptive_pool.hpp">
<namespace name="boost">
<namespace name="container">
<class name="adaptive_pool"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type><default>ADP_nodes_per_block</default></template-nontype-parameter>
      <template-nontype-parameter name="MaxFreeBlocks"><type>std::size_t</type><default>ADP_max_free_blocks</default></template-nontype-parameter>
      <template-nontype-parameter name="OverheadPercent"><type>std::size_t</type><default>ADP_overhead_percent</default></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a modified DLMalloc as memory source.</para><para>This node allocator shares a segregated storage between all instances of <classname alt="boost::container::adaptive_pool">adaptive_pool</classname> with equal sizeof(T).</para><para>NodesPerBlock is the number of nodes allocated at once when the allocator needs runs out of nodes. MaxFreeBlocks is the maximum number of totally free blocks that the adaptive node pool will hold. The rest of the totally free blocks will be deallocated to the memory manager.</para><para>OverheadPercent is the (approximated) maximum size overhead (1-20%) of the allocator: (memory usable for nodes / total memory allocated from the memory allocator) </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <classname alt="boost::container::adaptive_pool">adaptive_pool</classname> from <classname alt="boost::container::adaptive_pool">adaptive_pool</classname> </para></description><typedef name="other"><type><classname>adaptive_pool</classname>&lt; T2, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef>
</struct><typedef name="allocation_type"><description><para>If Version is 1, the allocator is a STL conforming allocator. If Version is 2, the allocator offers advanced expand in place and burst allocation capabilities. </para></description><type>unsigned int</type></typedef>
<typedef name="self_t"><type><classname>adaptive_pool</classname>&lt; T, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<typedef name="pointer"><type>T *</type></typedef>
<typedef name="const_pointer"><type>const T *</type></typedef>
<typedef name="reference"><type>::boost::container::dtl::unvoid_ref&lt; T &gt;::type</type></typedef>
<typedef name="const_reference"><type>::boost::container::dtl::unvoid_ref&lt; const T &gt;::type</type></typedef>
<typedef name="size_type"><type>std::size_t</type></typedef>
<typedef name="difference_type"><type>std::ptrdiff_t</type></typedef>
<typedef name="version"><type>boost::container::dtl::version_type&lt; <classname>self_t</classname>, Version &gt;</type></typedef>
<data-member name="nodes_per_block" specifiers="static"><type>const std::size_t</type></data-member>
<data-member name="max_free_blocks" specifiers="static"><type>const std::size_t</type></data-member>
<data-member name="overhead_percent" specifiers="static"><type>const std::size_t</type></data-member>
<data-member name="real_nodes_per_block" specifiers="static"><type>const std::size_t</type></data-member>
<method-group name="public member functions">
<method name="BOOST_CONTAINER_DOCIGN"><type/><parameter name=""><paramtype>BOOST_STATIC_ASSERT((Version&lt;=2))</paramtype></parameter></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws std::bad_alloc if there is no enough memory </para></description></method>
<method name="deallocate" cv="noexcept"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method name="size" cv="const noexcept"><type>size_type</type><parameter name="p"><paramtype>pointer</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. </para></description></method>
<method name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws bad_alloc if there is no enough memory </para></description></method>
<method name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1. Elements must be individually deallocated with deallocate_one() </para></description></method>
<method name="deallocate_one" cv="noexcept"><type>void</type><parameter name="p"><paramtype>pointer</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method>
<method name="deallocate_individual" cv="noexcept"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter></method>
<method name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="n_elements"><paramtype>std::size_t</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size. Elements must be individually deallocated with deallocate() </para></description></method>
<method name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i] Elements must be individually deallocated with deallocate() </para></description></method>
<method name="deallocate_many" cv="noexcept"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter></method>
</method-group>
<constructor cv="noexcept"><purpose>Default constructor. </purpose></constructor>
<constructor cv="noexcept"><parameter name=""><paramtype>const <classname>adaptive_pool</classname> &amp;</paramtype></parameter><purpose>Copy constructor from other <classname alt="boost::container::adaptive_pool">adaptive_pool</classname>. </purpose></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name=""><paramtype>const <classname>adaptive_pool</classname>&lt; T2, NodesPerBlock, MaxFreeBlocks, OverheadPercent BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I Version)&gt; &amp;</paramtype></parameter><purpose>Copy constructor from related <classname alt="boost::container::adaptive_pool">adaptive_pool</classname>. </purpose></constructor>
<destructor><purpose>Destructor. </purpose></destructor>
<method-group name="public static functions">
<method name="deallocate_free_blocks" cv="noexcept" specifiers="static"><type>void</type><purpose>Deallocates all free blocks of the pool. </purpose></method>
</method-group>
<method-group name="friend functions">
<method name="swap" cv="noexcept"><type>friend void</type><parameter name=""><paramtype><classname>adaptive_pool</classname> &amp;</paramtype></parameter><parameter name=""><paramtype><classname>adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
<method name="operator==" cv="noexcept"><type>friend bool</type><parameter name=""><paramtype>const <classname>adaptive_pool</classname> &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>adaptive_pool</classname> &amp;</paramtype></parameter><description><para>An allocator always compares to true, as memory allocated with one instance can be deallocated by another instance </para></description></method>
<method name="operator!=" cv="noexcept"><type>friend bool</type><parameter name=""><paramtype>const <classname>adaptive_pool</classname> &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>adaptive_pool</classname> &amp;</paramtype></parameter><description><para>An allocator always compares to false, as memory allocated with one instance can be deallocated by another instance </para></description></method>
</method-group>
<method-group name="private member functions">
<method name="priv_allocation_command"><type>pointer</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>std::size_t</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse_ptr"><paramtype>pointer &amp;</paramtype></parameter></method>
</method-group>
</class><class name="private_adaptive_pool"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type><default>ADP_nodes_per_block</default></template-nontype-parameter>
      <template-nontype-parameter name="MaxFreeBlocks"><type>std::size_t</type><default>ADP_max_free_blocks</default></template-nontype-parameter>
      <template-nontype-parameter name="OverheadPercent"><type>std::size_t</type><default>ADP_overhead_percent</default></template-nontype-parameter>
      <template-nontype-parameter name="Version"><type>unsigned</type><default>2</default></template-nontype-parameter>
    </template><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <classname alt="boost::container::private_adaptive_pool">private_adaptive_pool</classname> from <classname alt="boost::container::private_adaptive_pool">private_adaptive_pool</classname> </para></description><typedef name="other"><type><classname>private_adaptive_pool</classname>&lt; T2, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef>
</struct><typedef name="allocation_type"><description><para>If Version is 1, the allocator is a STL conforming allocator. If Version is 2, the allocator offers advanced expand in place and burst allocation capabilities. </para></description><type>unsigned int</type></typedef>
<typedef name="self_t"><type><classname>private_adaptive_pool</classname>&lt; T, NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef>
<typedef name="pool_t"><type>dtl::private_adaptive_node_pool&lt; sizeof(T), NodesPerBlock, MaxFreeBlocks, OverheadPercent &gt;</type></typedef>
<typedef name="value_type"><type>T</type></typedef>
<typedef name="pointer"><type>T *</type></typedef>
<typedef name="const_pointer"><type>const T *</type></typedef>
<typedef name="reference"><type>::boost::container::dtl::unvoid_ref&lt; T &gt;::type</type></typedef>
<typedef name="const_reference"><type>::boost::container::dtl::unvoid_ref&lt; const T &gt;::type</type></typedef>
<typedef name="size_type"><type>std::size_t</type></typedef>
<typedef name="difference_type"><type>std::ptrdiff_t</type></typedef>
<typedef name="version"><type>boost::container::dtl::version_type&lt; <classname>self_t</classname>, Version &gt;</type></typedef>
<data-member name="nodes_per_block" specifiers="static"><type>const std::size_t</type></data-member>
<data-member name="max_free_blocks" specifiers="static"><type>const std::size_t</type></data-member>
<data-member name="overhead_percent" specifiers="static"><type>const std::size_t</type></data-member>
<data-member name="real_nodes_per_block" specifiers="static"><type>const std::size_t</type></data-member>
<data-member name="m_pool"><type>pool_t</type></data-member>
<method-group name="public member functions">
<method name="BOOST_CONTAINER_DOCIGN"><type/><parameter name=""><paramtype>BOOST_STATIC_ASSERT((Version&lt;=2))</paramtype></parameter></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws std::bad_alloc if there is no enough memory </para></description></method>
<method name="deallocate" cv="noexcept"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method name="size" cv="const noexcept"><type>size_type</type><parameter name="p"><paramtype>pointer</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. </para></description></method>
<method name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws bad_alloc if there is no enough memory </para></description></method>
<method name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1. Elements must be individually deallocated with deallocate_one() </para></description></method>
<method name="deallocate_one" cv="noexcept"><type>void</type><parameter name="p"><paramtype>pointer</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method>
<method name="deallocate_individual" cv="noexcept"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter></method>
<method name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="n_elements"><paramtype>std::size_t</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size. Elements must be individually deallocated with deallocate() </para></description></method>
<method name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i] Elements must be individually deallocated with deallocate() </para></description></method>
<method name="deallocate_many" cv="noexcept"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter></method>
<method name="deallocate_free_blocks" cv="noexcept"><type>void</type><purpose>Deallocates all free blocks of the pool. </purpose></method>
</method-group>
<constructor cv="noexcept"><purpose>Default constructor. </purpose></constructor>
<constructor cv="noexcept"><parameter name=""><paramtype>const <classname>private_adaptive_pool</classname> &amp;</paramtype></parameter><purpose>Copy constructor from other <classname alt="boost::container::private_adaptive_pool">private_adaptive_pool</classname>. </purpose></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name=""><paramtype>const <classname>private_adaptive_pool</classname>&lt; T2, NodesPerBlock, MaxFreeBlocks, OverheadPercent BOOST_CONTAINER_DOCIGN(BOOST_MOVE_I Version)&gt; &amp;</paramtype></parameter><purpose>Copy constructor from related <classname alt="boost::container::private_adaptive_pool">private_adaptive_pool</classname>. </purpose></constructor>
<destructor><purpose>Destructor. </purpose></destructor>
<method-group name="friend functions">
<method name="swap" cv="noexcept"><type>friend void</type><parameter name=""><paramtype><classname>private_adaptive_pool</classname> &amp;</paramtype></parameter><parameter name=""><paramtype><classname>private_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
<method name="operator==" cv="noexcept"><type>friend bool</type><parameter name=""><paramtype>const <classname>private_adaptive_pool</classname> &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>private_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>An allocator always compares to true, as memory allocated with one instance can be deallocated by another instance </para></description></method>
<method name="operator!=" cv="noexcept"><type>friend bool</type><parameter name=""><paramtype>const <classname>private_adaptive_pool</classname> &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>private_adaptive_pool</classname> &amp;</paramtype></parameter><description><para>An allocator always compares to false, as memory allocated with one instance can be deallocated by another instance </para></description></method>
</method-group>
<method-group name="private member functions">
<method name="priv_allocation_command"><type>pointer</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>std::size_t</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse_ptr"><paramtype>pointer &amp;</paramtype></parameter></method>
</method-group>
</class>

























































</namespace>
</namespace>
</header>
<header name="boost/container/allocator.hpp">
<namespace name="boost">
<namespace name="container">
<class name="allocator"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="Version"><type>unsigned</type><default>2</default></template-nontype-parameter>
      <template-nontype-parameter name="AllocationDisableMask"><type>unsigned int</type><default>0</default></template-nontype-parameter>
    </template><description><para>This class is an extended STL-compatible that offers advanced allocation mechanism (in-place expansion, shrinking, burst-allocation...)</para><para>This allocator is a wrapper around a modified DLmalloc. If Version is 1, the allocator is a STL conforming allocator. If Version is 2, the allocator offers advanced expand in place and burst allocation capabilities.</para><para>AllocationDisableMask works only if Version is 2 and it can be an inclusive OR of allocation types the user wants to disable. </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains an allocator that allocates objects of type T2 </para></description><typedef name="other"><type><classname>allocator</classname>&lt; T2, Version, AllocationDisableMask &gt;</type></typedef>
</struct><typedef name="value_type"><type>T</type></typedef>
<typedef name="pointer"><type>T *</type></typedef>
<typedef name="const_pointer"><type>const T *</type></typedef>
<typedef name="reference"><type>T &amp;</type></typedef>
<typedef name="const_reference"><type>const T &amp;</type></typedef>
<typedef name="size_type"><type>std::size_t</type></typedef>
<typedef name="difference_type"><type>std::ptrdiff_t</type></typedef>
<typedef name="version"><type>boost::container::dtl::version_type&lt; self_t, Version &gt;</type></typedef>
<method-group name="public member functions">
<method name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Allocates memory for an array of count elements. Throws std::bad_alloc if there is no enough memory If Version is 2, this allocated memory can only be deallocated with deallocate() or (for Version == 2) deallocate_many() </para></description></method>
<method name="deallocate" cv="noexcept"><type>void</type><parameter name="ptr"><paramtype>pointer</paramtype></parameter><parameter name=""><paramtype>size_type</paramtype></parameter><description><para>Deallocates previously allocated memory. Never throws </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para>Returns the maximum number of elements that could be allocated. Never throws </para></description></method>
<method name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter><description><para>An advanced function that offers in-place expansion shrink to fit and new allocation capabilities. Memory allocated with this function can only be deallocated with deallocate() or deallocate_many(). This function is available only with Version == 2 </para></description></method>
<method name="size" cv="const noexcept"><type>size_type</type><parameter name="p"><paramtype>pointer</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. Memory must not have been allocated with allocate_one or allocate_individual. This function is available only with Version == 2 </para></description></method>
<method name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws bad_alloc if there is no enough memory This function is available only with Version == 2 </para></description></method>
<method name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1. Elements must be individually deallocated with deallocate_one() This function is available only with Version == 2 </para></description></method>
<method name="deallocate_one" cv="noexcept"><type>void</type><parameter name="p"><paramtype>pointer</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one() or allocate_individual. </para></description></method>
<method name="deallocate_individual" cv="noexcept"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Deallocates memory allocated with allocate_one() or allocate_individual(). This function is available only with Version == 2 </para></description></method>
<method name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="n_elements"><paramtype>std::size_t</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size. Elements must be individually deallocated with deallocate() This function is available only with Version == 2 </para></description></method>
<method name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i] Elements must be individually deallocated with deallocate() This function is available only with Version == 2 </para></description></method>
<method name="deallocate_many" cv="noexcept"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Deallocates several elements allocated by allocate_many(), allocate(), or allocation_command(). This function is available only with Version == 2 </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Default constructor Never throws </para></description></constructor>
<constructor cv="noexcept"><parameter name=""><paramtype>const <classname>allocator</classname> &amp;</paramtype></parameter><description><para>Constructor from other allocator. Never throws </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name=""><paramtype>const <classname>allocator</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para>Constructor from related allocator. Never throws </para></description></constructor>
<method-group name="friend functions">
<method name="swap" cv="noexcept"><type>friend void</type><parameter name=""><paramtype>self_t &amp;</paramtype></parameter><parameter name=""><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps two allocators, does nothing because this allocator is stateless </para></description></method>
<method name="operator==" cv="noexcept"><type>friend bool</type><parameter name=""><paramtype>const <classname>allocator</classname> &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>allocator</classname> &amp;</paramtype></parameter><description><para>An allocator always compares to true, as memory allocated with one instance can be deallocated by another instance </para></description></method>
<method name="operator!=" cv="noexcept"><type>friend bool</type><parameter name=""><paramtype>const <classname>allocator</classname> &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>allocator</classname> &amp;</paramtype></parameter><description><para>An allocator always compares to false, as memory allocated with one instance can be deallocated by another instance </para></description></method>
</method-group>
<method-group name="private member functions">
<method name="priv_allocation_command"><type>pointer</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>std::size_t</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse_ptr"><paramtype>pointer &amp;</paramtype></parameter></method>
</method-group>
</class>

























































</namespace>
</namespace>
</header>
<header name="boost/container/allocator_traits.hpp">
<namespace name="boost">
<namespace name="container">
<struct name="allocator_traits"><template>
      <template-type-parameter name="Allocator"/>
    </template><description><para>The class template <classname alt="boost::container::allocator_traits">allocator_traits</classname> supplies a uniform interface to all allocator types. This class is a C++03-compatible implementation of std::allocator_traits </para></description><struct name="portable_rebind_alloc"><template>
      <template-type-parameter name="T"/>
    </template><description><para>Non-standard extension: Portable allocator rebind for C++03 and C++11 compilers. <computeroutput>type</computeroutput> is an allocator related to Allocator deduced deduced by rules explained in <computeroutput>rebind_alloc</computeroutput>. </para></description><typedef name="type"><type>see_documentation</type></typedef>
</struct><typedef name="allocator_type"><type>Allocator</type></typedef>
<typedef name="value_type"><type>allocator_type::value_type</type></typedef>
<typedef name="pointer"><description><para>Allocator::pointer if such a type exists; otherwise, value_type* </para></description><type>unspecified</type></typedef>
<typedef name="const_pointer"><description><para>Allocator::const_pointer if such a type exists ; otherwise, pointer_traits&lt;pointer&gt;::rebind&lt;const </para></description><type>see_documentation</type></typedef>
<typedef name="reference"><description><para>Non-standard extension Allocator::reference if such a type exists; otherwise, value_type&amp; </para></description><type>see_documentation</type></typedef>
<typedef name="const_reference"><description><para>Non-standard extension Allocator::const_reference if such a type exists ; otherwise, const value_type&amp; </para></description><type>see_documentation</type></typedef>
<typedef name="void_pointer"><description><para>Allocator::void_pointer if such a type exists ; otherwise, pointer_traits&lt;pointer&gt;::rebind&lt;void&gt;. </para></description><type>see_documentation</type></typedef>
<typedef name="const_void_pointer"><description><para>Allocator::const_void_pointer if such a type exists ; otherwis e, pointer_traits&lt;pointer&gt;::rebind&lt;const </para></description><type>see_documentation</type></typedef>
<typedef name="difference_type"><description><para>Allocator::difference_type if such a type exists ; otherwise, pointer_traits&lt;pointer&gt;::difference_type. </para></description><type>see_documentation</type></typedef>
<typedef name="size_type"><description><para>Allocator::size_type if such a type exists ; otherwise, make_unsigned&lt;difference_type&gt;::type </para></description><type>see_documentation</type></typedef>
<typedef name="propagate_on_container_copy_assignment"><description><para>Allocator::propagate_on_container_copy_assignment if such a type exists, otherwise a type with an internal constant static boolean member <computeroutput>value</computeroutput> == false. </para></description><type>see_documentation</type></typedef>
<typedef name="propagate_on_container_move_assignment"><description><para>Allocator::propagate_on_container_move_assignment if such a type exists, otherwise a type with an internal constant static boolean member <computeroutput>value</computeroutput> == false. </para></description><type>see_documentation</type></typedef>
<typedef name="propagate_on_container_swap"><description><para>Allocator::propagate_on_container_swap if such a type exists, otherwise a type with an internal constant static boolean member <computeroutput>value</computeroutput> == false. </para></description><type>see_documentation</type></typedef>
<typedef name="is_always_equal"><description><para>Allocator::is_always_equal if such a type exists, otherwise a type with an internal constant static boolean member <computeroutput>value</computeroutput> == is_empty&lt;Allocator&gt;::value </para></description><type>see_documentation</type></typedef>
<typedef name="is_partially_propagable"><description><para>Allocator::is_partially_propagable if such a type exists, otherwise a type with an internal constant static boolean member <computeroutput>value</computeroutput> == false <emphasis role="bold">Note</emphasis>: Non-standard extension used to implement <computeroutput><classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname></computeroutput>. </para></description><type>see_documentation</type></typedef>
<typedef name="rebind_alloc"><description><para>Defines an allocator: Allocator::rebind&lt;T&gt;::other if such a type exists; otherwise, Allocator&lt;T, Args&gt; if Allocator is a class template instantiation of the form Allocator&lt;U, Args&gt;, where Args is zero or more type arguments ; otherwise, the instantiation of rebind_alloc is ill-formed.</para><para>In C++03 compilers <computeroutput>rebind_alloc</computeroutput> is a struct derived from an allocator deduced by previously detailed rules. </para></description><type>see_documentation</type></typedef>
<typedef name="rebind_traits"><description><para>In C++03 compilers <computeroutput>rebind_traits</computeroutput> is a struct derived from <computeroutput>allocator_traits&lt;OtherAlloc&gt;</computeroutput>, where <computeroutput>OtherAlloc</computeroutput> is the allocator deduced by rules explained in <computeroutput>rebind_alloc</computeroutput>. </para></description><type><classname>allocator_traits</classname>&lt; rebind_alloc&lt; T &gt; &gt;</type></typedef>
<method-group name="public static functions">
<method name="allocate" specifiers="static"><type>pointer</type><parameter name="a"><paramtype>Allocator &amp;</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>a.allocate(n)</computeroutput> </para></description></method>
<method name="deallocate" specifiers="static"><type>void</type><parameter name="a"><paramtype>Allocator &amp;</paramtype></parameter><parameter name="p"><paramtype>pointer</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>a.deallocate(p, n)</computeroutput></para><para><emphasis role="bold">Throws</emphasis>: Nothing </para></description></method>
<method name="allocate" specifiers="static"><type>pointer</type><parameter name="a"><paramtype>Allocator &amp;</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="p"><paramtype>const_void_pointer</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: calls <computeroutput>a.allocate(n, p)</computeroutput> if that call is well-formed; otherwise, invokes <computeroutput>a.allocate(n)</computeroutput> </para></description></method>
<method name="destroy" cv="noexcept" specifiers="static"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="a"><paramtype>Allocator &amp;</paramtype></parameter><parameter name="p"><paramtype>T *</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: calls <computeroutput>a.destroy(p)</computeroutput> if that call is well-formed; otherwise, invokes <computeroutput>p-&gt;~T()</computeroutput>. </para></description></method>
<method name="max_size" cv="noexcept" specifiers="static"><type>size_type</type><parameter name="a"><paramtype>const Allocator &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>a.max_size()</computeroutput> if that expression is well-formed; otherwise, <computeroutput>numeric_limits&lt;size_type&gt;::max()</computeroutput>. </para></description></method>
<method name="select_on_container_copy_construction" specifiers="static"><type>Allocator</type><parameter name="a"><paramtype>const Allocator &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>a.select_on_container_copy_construction()</computeroutput> if that expression is well-formed; otherwise, a. </para></description></method>
<method name="construct" specifiers="static"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="a"><paramtype>Allocator &amp;</paramtype></parameter><parameter name="p"><paramtype>T *</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: calls <computeroutput>a.construct(p, std::forward&lt;Args&gt;(args)...)</computeroutput> if that call is well-formed; otherwise, invokes <computeroutput><computeroutput>placement new</computeroutput> (static_cast&lt;void*&gt;(p)) T(std::forward&lt;Args&gt;(args)...)</computeroutput> </para></description></method>
<method name="storage_is_unpropagable" cv="noexcept" specifiers="static"><type>bool</type><parameter name="a"><paramtype>const Allocator &amp;</paramtype></parameter><parameter name="p"><paramtype>pointer</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>a.storage_is_unpropagable(p)</computeroutput> if is_partially_propagable::value is true; otherwise, <computeroutput>false</computeroutput>. </para></description></method>
<method name="equal" cv="noexcept" specifiers="static"><type>bool</type><parameter name="a"><paramtype>const Allocator &amp;</paramtype></parameter><parameter name="b"><paramtype>const Allocator &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>true</computeroutput> if <computeroutput>is_always_equal::value == true</computeroutput>, otherwise, <computeroutput>a == b</computeroutput>. </para></description></method>
</method-group>
</struct>

























































</namespace>
</namespace>
</header>
<header name="boost/container/container_fwd.hpp">
<para>This header file forward declares the following containers:<itemizedlist>
<listitem><para><classname alt="boost::container::vector">boost::container::vector</classname></para></listitem><listitem><para><classname alt="boost::container::stable_vector">boost::container::stable_vector</classname></para></listitem><listitem><para><classname alt="boost::container::static_vector">boost::container::static_vector</classname></para></listitem><listitem><para><classname alt="boost::container::small_vector">boost::container::small_vector</classname></para></listitem><listitem><para><classname alt="boost::container::slist">boost::container::slist</classname></para></listitem><listitem><para><classname alt="boost::container::list">boost::container::list</classname></para></listitem><listitem><para><classname alt="boost::container::set">boost::container::set</classname></para></listitem><listitem><para><classname alt="boost::container::multiset">boost::container::multiset</classname></para></listitem><listitem><para><classname alt="boost::container::map">boost::container::map</classname></para></listitem><listitem><para><classname alt="boost::container::multimap">boost::container::multimap</classname></para></listitem><listitem><para><classname alt="boost::container::flat_set">boost::container::flat_set</classname></para></listitem><listitem><para><classname alt="boost::container::flat_multiset">boost::container::flat_multiset</classname></para></listitem><listitem><para><classname alt="boost::container::flat_map">boost::container::flat_map</classname></para></listitem><listitem><para><classname alt="boost::container::flat_multimap">boost::container::flat_multimap</classname></para></listitem><listitem><para><classname alt="boost::container::basic_string">boost::container::basic_string</classname></para></listitem><listitem><para>boost::container::string</para></listitem><listitem><para>boost::container::wstring</para></listitem></itemizedlist>
</para><para>Forward declares the following allocators:<itemizedlist>
<listitem><para><classname alt="boost::container::allocator">boost::container::allocator</classname></para></listitem><listitem><para><classname alt="boost::container::node_allocator">boost::container::node_allocator</classname></para></listitem><listitem><para><classname alt="boost::container::adaptive_pool">boost::container::adaptive_pool</classname></para></listitem></itemizedlist>
</para><para>Forward declares the following polymorphic resource classes:<itemizedlist>
<listitem><para><classname alt="boost::container::pmr::memory_resource">boost::container::pmr::memory_resource</classname></para></listitem><listitem><para><classname alt="boost::container::pmr::polymorphic_allocator">boost::container::pmr::polymorphic_allocator</classname></para></listitem><listitem><para><classname alt="boost::container::pmr::monotonic_buffer_resource">boost::container::pmr::monotonic_buffer_resource</classname></para></listitem><listitem><para><classname alt="boost::container::pmr::pool_options">boost::container::pmr::pool_options</classname></para></listitem><listitem><para><classname alt="boost::container::pmr::unsynchronized_pool_resource">boost::container::pmr::unsynchronized_pool_resource</classname></para></listitem><listitem><para><classname alt="boost::container::pmr::synchronized_pool_resource">boost::container::pmr::synchronized_pool_resource</classname></para></listitem></itemizedlist>
</para><para>And finally it defines the following types </para><namespace name="boost">
<namespace name="container">
<struct name="ordered_range_t"><description><para>Type used to tag that the input range is guaranteed to be ordered </para></description></struct><struct name="ordered_unique_range_t"><inherit access="public">boost::container::ordered_range_t</inherit><description><para>Type used to tag that the input range is guaranteed to be ordered and unique </para></description></struct><struct name="default_init_t"><description><para>Type used to tag that the inserted values should be default initialized </para></description></struct><data-member name="ordered_range" specifiers="static"><type>const <classname>ordered_range_t</classname></type><description><para>Value used to tag that the input range is guaranteed to be ordered </para></description></data-member>
<data-member name="ordered_unique_range" specifiers="static"><type>const <classname>ordered_unique_range_t</classname></type><description><para>Value used to tag that the input range is guaranteed to be ordered and unique </para></description></data-member>
<data-member name="default_init" specifiers="static"><type>const <classname>default_init_t</classname></type><description><para>Value used to tag that the inserted values should be default initialized </para></description></data-member>


























































</namespace>
</namespace>
</header>
<header name="boost/container/deque.hpp">
<namespace name="boost">
<namespace name="container">
<class name="deque"><template>
      <template-type-parameter name="T"><purpose><para>The type of object that is stored in the deque </para></purpose></template-type-parameter>
      <template-type-parameter name="Allocator"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt;T&gt;</default><purpose><para>The allocator used for all internal memory management </para></purpose></template-type-parameter>
    </template><inherit access="protected">deque_base&lt; Allocator &gt;</inherit><description><para>A double-ended queue is a sequence that supports random access to elements, constant time insertion and removal of elements at the end of the sequence, and linear time insertion and removal of elements in the middle.</para><para>
</para></description><typedef name="value_type"><type>T</type></typedef>
<typedef name="pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::pointer</type></typedef>
<typedef name="const_pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_pointer</type></typedef>
<typedef name="reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::reference</type></typedef>
<typedef name="const_reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_reference</type></typedef>
<typedef name="size_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::size_type</type></typedef>
<typedef name="difference_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::difference_type</type></typedef>
<typedef name="allocator_type"><type>Allocator</type></typedef>
<typedef name="stored_allocator_type"><type>implementation_defined</type></typedef>
<typedef name="iterator"><type>implementation_defined</type></typedef>
<typedef name="const_iterator"><type>implementation_defined</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="assign"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="val"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the n copies of val to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="assign"><type>void</type><template>
          <template-type-parameter name="InIt"/>
        </template><parameter name="first"><paramtype>InIt</paramtype></parameter><parameter name="last"><paramtype>InIt</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the the range [first, last) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's constructor from dereferencing InIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="assign"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the the range [il.begin(), il.end()) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's constructor from dereferencing std::initializer_list iterator throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to il.size(). </para></description></method>
<method name="get_allocator" cv="const noexcept"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: If allocator's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator" cv="const noexcept"><type>const stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="noexcept"><type>stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="begin" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="empty" cv="const noexcept"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the deque contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="resize"><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are value initialized.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method>
<method name="resize"><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are default initialized.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="resize"><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are copy constructed from x.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method>
<method name="shrink_to_fit"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Tries to deallocate the excess of memory created with previous allocations. The size of the deque is unchanged</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="front" cv="noexcept"><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="front" cv="const noexcept"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="back" cv="noexcept"><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the last element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="back" cv="const noexcept"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the last element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="operator[]" cv="noexcept"><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="operator[]" cv="const noexcept"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="nth" cv="noexcept"><type>iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="nth" cv="const noexcept"><type>const_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="noexcept"><type>size_type</type><parameter name="p"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="const noexcept"><type>size_type</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="at"><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: std::range_error if n &gt;= size()</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="at" cv="const"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: std::range_error if n &gt;= size()</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="emplace_front"><type>reference</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the beginning of the deque.</para><para><emphasis role="bold">Returns</emphasis>: A reference to the created object.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or the in-place constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time </para></description></method>
<method name="emplace_back"><type>reference</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the end of the deque.</para><para><emphasis role="bold">Returns</emphasis>: A reference to the created object.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or the in-place constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time </para></description></method>
<method name="emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... before p</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or the in-place constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: If p is end(), amortized constant time Linear time otherwise. </para></description></method>
<method name="push_front"><type>void</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x at the front of the deque.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="push_front"><type>void</type><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a new element in the front of the deque and moves the resources of x to this new element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="push_back"><type>void</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x at the end of the deque.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="push_back"><type>void</type><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a new element in the end of the deque and moves the resources of x to this new element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of x before p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or x's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: If p is end(), amortized constant time Linear time otherwise. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a new element before p with x's resources.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: If p is end(), amortized constant time Linear time otherwise. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert n copies of x before pos.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or pos if n is 0.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="insert"><type>iterator</type><template>
          <template-type-parameter name="InIt"/>
        </template><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="first"><paramtype>InIt</paramtype></parameter><parameter name="last"><paramtype>InIt</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [first, last) range before pos.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or pos if first == last.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced InIt throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to distance [first, last). </para></description></method>
<method name="insert"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [il.begin(), il.end()) range before pos.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or pos if il.begin() == il.end().</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced std::initializer_list throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to distance [il.begin(), il.end()). </para></description></method>
<method name="pop_front" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the first element from the deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time. </para></description></method>
<method name="pop_back" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the last element from the deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time. </para></description></method>
<method name="erase" cv="noexcept"><type>iterator</type><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element at p.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements between pos and the last element (if pos is near the end) or the first element if(pos is near the beginning). Constant if pos is the first or the last element. </para></description></method>
<method name="erase" cv="noexcept"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the elements pointed by [first, last).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the distance between first and last plus the elements between pos and the last element (if pos is near the end) or the first element if(pos is near the beginning). </para></description></method>
<method name="swap" cv="noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value))"><type>void</type><parameter name="x"><paramtype><classname>deque</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="clear" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the deque.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the deque. </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; Allocator &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Default constructors a deque.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a deque taking the allocator as parameter.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a deque and inserts n value initialized values.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's value initialization throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a deque and inserts n default initialized values.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's default initialization or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></constructor>
<constructor specifiers="explicit"><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a deque that will use a copy of allocator a and inserts n value initialized values.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's value initialization throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a deque that will use a copy of allocator a and inserts n default initialized values.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's default initialization or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="value"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a deque that will use a copy of allocator a and inserts n copies of value.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="value"><paramtype>const value_type &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a deque that will use a copy of allocator a and inserts n copies of value.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InIt"/>
        </template><parameter name="first"><paramtype>InIt</paramtype></parameter><parameter name="last"><paramtype>InIt</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a deque that will use a copy of allocator a and inserts a copy of the range [first, last) in the deque.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's constructor taking a dereferenced InIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [first, last). </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InIt"/>
        </template><parameter name="first"><paramtype>InIt</paramtype></parameter><parameter name="last"><paramtype>InIt</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a deque that will use a copy of allocator a and inserts a copy of the range [first, last) in the deque.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's constructor taking a dereferenced InIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [first, last). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a deque that will use a copy of allocator a and inserts a copy of the range [il.begin(), il.end()) in the deque.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's constructor taking a dereferenced std::initializer_list iterator throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [il.begin(), il.end()). </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a deque.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></constructor>
<constructor cv="noexcept"><parameter name="x"><paramtype><classname>deque</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor. Moves x's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a vector using the specified allocator.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>deque</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor using the specified allocator. Moves x's resources to *this if a == allocator_type(). Otherwise copies values from x to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocation or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant if a == x.get_allocator(), linear otherwise. </para></description></constructor>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Destroys the deque. All stored values are destroyed and used memory is deallocated.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements. </para></description></destructor>
<copy-assignment><type><classname>deque</classname> &amp;</type><parameter name="x"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this contain the same elements as x.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;size() == x.size(). *this contains a copy of each of x's elements.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in x. </para></description></copy-assignment>
<copy-assignment cv="noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value))"><type><classname>deque</classname> &amp;</type><parameter name="x"><paramtype><classname>deque</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move assignment. All x's values are transferred to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type's move constructor throws)</para><para><emphasis role="bold">Complexity</emphasis>: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this-&gt;get&gt;allocator() == x.get_allocator(). Linear otherwise. </para></description></copy-assignment>
<copy-assignment><type><classname>deque</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this contain the same elements as il.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;size() == il.size(). *this contains a copy of each of x's elements.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in il. </para></description></copy-assignment>
<method-group name="friend functions">
<method name="operator=="><type>friend bool</type><parameter name="x"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are equal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator!="><type>friend bool</type><parameter name="x"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are unequal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>deque</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="swap"><type>friend void</type><parameter name="x"><paramtype><classname>deque</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>deque</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y)</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
</method-group>
</class>

























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/deque.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<struct name="deque_of"><template>
      <template-type-parameter name="T"/>
    </template><description><para>A portable metafunction to obtain a deque that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::deque</classname>&lt; T, <classname>polymorphic_allocator</classname>&lt; T &gt; &gt;</type></typedef>
</struct><typedef name="deque"><type><classname>boost::container::deque</classname>&lt; T, <classname>polymorphic_allocator</classname>&lt; T &gt;&gt;</type></typedef>






</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/flat_map.hpp">
<namespace name="boost">
<namespace name="container">
<class name="flat_map"><template>
      <template-type-parameter name="Key"><purpose><para>is the key_type of the map </para></purpose></template-type-parameter>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default><purpose><para>is the ordering function for Keys (e.g. <emphasis>std::less&lt;Key&gt;</emphasis>). </para></purpose></template-type-parameter>
      <template-type-parameter name="AllocatorOrContainer"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt; std::pair&lt; Key, T&gt; &gt;</default><purpose><para>is either:<itemizedlist>
<listitem><para>The allocator to allocate <computeroutput>value_type</computeroutput>s (e.g. <emphasis>allocator&lt; std::pair&lt;Key, T&gt; &gt; </emphasis>). (in this case <emphasis>sequence_type</emphasis> will be vector&lt;value_type, AllocatorOrContainer&gt;)</para></listitem><listitem><para>The SequenceContainer to be used as the underlying <emphasis>sequence_type</emphasis>. It must be a vector-like sequence container with random-access iterators.. </para></listitem></itemizedlist>
</para></purpose></template-type-parameter>
    </template><description><para>A <classname alt="boost::container::flat_map">flat_map</classname> is a kind of associative container that supports unique keys (contains at most one of each key value) and provides for fast retrieval of values of another type T based on the keys.</para><para>A <classname alt="boost::container::flat_map">flat_map</classname> satisfies all of the requirements of a container, a reversible container and an associative container. A <classname alt="boost::container::flat_map">flat_map</classname> also provides most operations described for unique keys. For a flat_map&lt;Key,T&gt; the key_type is Key and the value_type is std::pair&lt;Key,T&gt; (unlike std::map&lt;Key, T&gt; which value_type is std::pair&lt;<emphasis role="bold">const</emphasis> Key, T&gt;).</para><para><classname alt="boost::container::flat_map">flat_map</classname> is similar to std::map but it's implemented by as an ordered sequence container. The underlying sequence container is by default <emphasis>vector</emphasis> but it can also work user-provided vector-like SequenceContainers (like <emphasis><classname alt="boost::container::static_vector">static_vector</classname></emphasis> or <emphasis><classname alt="boost::container::small_vector">small_vector</classname></emphasis>).</para><para>Using vector-like sequence containers means that inserting a new element into a <classname alt="boost::container::flat_map">flat_map</classname> might invalidate previous iterators and references (unless that sequence container is <emphasis><classname alt="boost::container::stable_vector">stable_vector</classname></emphasis> or a similar container that offers stable pointers and references). Similarly, erasing an element might invalidate iterators and references pointing to elements that come after (their keys are bigger) the erased element.</para><para>This container provides random-access iterators.</para><para>
</para></description><typedef name="key_type"><type>Key</type></typedef>
<typedef name="mapped_type"><type>T</type></typedef>
<typedef name="key_compare"><type>Compare</type></typedef>
<typedef name="value_type"><type>std::pair&lt; Key, T &gt;</type></typedef>
<typedef name="sequence_type"><type>implementation_defined</type></typedef>
<typedef name="allocator_type"><type>sequence_type::allocator_type</type></typedef>
<typedef name="allocator_traits_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; allocator_type &gt;</type></typedef>
<typedef name="pointer"><type>sequence_type::pointer</type></typedef>
<typedef name="const_pointer"><type>sequence_type::const_pointer</type></typedef>
<typedef name="reference"><type>sequence_type::reference</type></typedef>
<typedef name="const_reference"><type>sequence_type::const_reference</type></typedef>
<typedef name="size_type"><type>sequence_type::size_type</type></typedef>
<typedef name="difference_type"><type>sequence_type::difference_type</type></typedef>
<typedef name="stored_allocator_type"><type>implementation_defined</type></typedef>
<typedef name="value_compare"><type>implementation_defined</type></typedef>
<typedef name="iterator"><type>sequence_type::iterator</type></typedef>
<typedef name="const_iterator"><type>sequence_type::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>sequence_type::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>sequence_type::const_reverse_iterator</type></typedef>
<typedef name="movable_value_type"><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="BOOST_STATIC_ASSERT"><type/><parameter name=""><paramtype>(dtl::is_same&lt; std::pair&lt; Key, T &gt;, typename allocator_type::value_type &gt;::value)</paramtype></parameter></method>
<method name="get_allocator" cv="const noexcept"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator" cv="noexcept"><type>get_stored_allocator_noconst_return_t</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="const noexcept"><type>get_stored_allocator_const_return_t</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="begin" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="empty" cv="const noexcept"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="capacity" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="reserve"><type>void</type><parameter name="cnt"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If n is less than or equal to capacity(), or the underlying container has no <computeroutput>reserve</computeroutput> member, this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Note</emphasis>: If capacity() is less than "cnt", iterators and references to to values might be invalidated. </para></description></method>
<method name="shrink_to_fit"><type>void</type><purpose><emphasis role="bold">Effects</emphasis>: Tries to deallocate the excess of memory created </purpose><description><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size(). </para></description></method>
<method name="operator[]"><type>mapped_type &amp;</type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para>Effects: If there is no key equivalent to x in the <classname alt="boost::container::flat_map">flat_map</classname>, inserts value_type(x, T()) into the <classname alt="boost::container::flat_map">flat_map</classname>.</para><para>Returns: A reference to the mapped_type corresponding to x in *this.</para><para>Complexity: Logarithmic. </para></description></method>
<method name="operator[]"><type>mapped_type &amp;</type><parameter name="k"><paramtype>key_type &amp;&amp;</paramtype></parameter><description><para>Effects: If there is no key equivalent to x in the <classname alt="boost::container::flat_map">flat_map</classname>, inserts value_type(move(x), T()) into the <classname alt="boost::container::flat_map">flat_map</classname> (the key is move-constructed)</para><para>Returns: A reference to the mapped_type corresponding to x in *this.</para><para>Complexity: Logarithmic. </para></description></method>
<method name="insert_or_assign"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="M"/>
        </template><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="obj"><paramtype>M &amp;&amp;</paramtype></parameter><description><para>Effects: If a key equivalent to k already exists in the container, assigns forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert, constructing it from value_type(k, forward&lt;M&gt;(obj)).</para><para>No iterators or references are invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.</para><para>Returns: The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</para><para>Complexity: Logarithmic in the size of the container. </para></description></method>
<method name="insert_or_assign"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="M"/>
        </template><parameter name="k"><paramtype>key_type &amp;&amp;</paramtype></parameter><parameter name="obj"><paramtype>M &amp;&amp;</paramtype></parameter><description><para>Effects: If a key equivalent to k already exists in the container, assigns forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert, constructing it from value_type(k, move(obj)).</para><para>No iterators or references are invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.</para><para>Returns: The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</para><para>Complexity: Logarithmic in the size of the container. </para></description></method>
<method name="insert_or_assign"><type>iterator</type><template>
          <template-type-parameter name="M"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="obj"><paramtype>M &amp;&amp;</paramtype></parameter><description><para>Effects: If a key equivalent to k already exists in the container, assigns forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert, constructing it from value_type(k, forward&lt;M&gt;(obj)) and the new element to the container as close as possible to the position just before hint.</para><para>No iterators or references are invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.</para><para>Returns: The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</para><para>Complexity: Logarithmic in the size of the container in general, but amortized constant if the new element is inserted just before hint. </para></description></method>
<method name="insert_or_assign"><type>iterator</type><template>
          <template-type-parameter name="M"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="k"><paramtype>key_type &amp;&amp;</paramtype></parameter><parameter name="obj"><paramtype>M &amp;&amp;</paramtype></parameter><description><para>Effects: If a key equivalent to k already exists in the container, assigns forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert, constructing it from value_type(k, move(obj)) and the new element to the container as close as possible to the position just before hint.</para><para>No iterators or references are invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.</para><para>Returns: The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</para><para>Complexity: Logarithmic in the size of the container in general, but amortized constant if the new element is inserted just before hint. </para></description></method>
<method name="nth" cv="noexcept"><type>iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="nth" cv="const noexcept"><type>const_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="noexcept"><type>size_type</type><parameter name="p"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="const noexcept"><type>size_type</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="at"><type>T &amp;</type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para>Returns: A reference to the element whose key is equivalent to x.</para><para>Throws: An exception object of type out_of_range if no such element is present.</para><para>Complexity: logarithmic. </para></description></method>
<method name="at" cv="const"><type>const T &amp;</type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para>Returns: A reference to the element whose key is equivalent to x.</para><para>Throws: An exception object of type out_of_range if no such element is present.</para><para>Complexity: logarithmic. </para></description></method>
<method name="emplace"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object x of type T constructed with std::forward&lt;Args&gt;(args)... if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="emplace_hint"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the container if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="try_emplace"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value_type shall be EmplaceConstructible into map from piecewise_construct, forward_as_tuple(k), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Effects</emphasis>: If the map already contains an element whose key is equivalent to k, there is no effect. Otherwise inserts an object of type value_type constructed with piecewise_construct, forward_as_tuple(k), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion took place. The returned iterator points to the map element whose key is equivalent to k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="try_emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value_type shall be EmplaceConstructible into map from piecewise_construct, forward_as_tuple(k), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Effects</emphasis>: If the map already contains an element whose key is equivalent to k, there is no effect. Otherwise inserts an object of type value_type constructed with piecewise_construct, forward_as_tuple(k), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Returns</emphasis>: The returned iterator points to the map element whose key is equivalent to k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if value is inserted right before p. </para></description></method>
<method name="try_emplace"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="k"><paramtype>key_type &amp;&amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value_type shall be EmplaceConstructible into map from piecewise_construct, forward_as_tuple(move(k)), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Effects</emphasis>: If the map already contains an element whose key is equivalent to k, there is no effect. Otherwise inserts an object of type value_type constructed with piecewise_construct, forward_as_tuple(move(k)), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion took place. The returned iterator points to the map element whose key is equivalent to k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="try_emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="k"><paramtype>key_type &amp;&amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value_type shall be EmplaceConstructible into map from piecewise_construct, forward_as_tuple(move(k)), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Effects</emphasis>: If the map already contains an element whose key is equivalent to k, there is no effect. Otherwise inserts an object of type value_type constructed with piecewise_construct, forward_as_tuple(move(k)), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Returns</emphasis>: The returned iterator points to the map element whose key is equivalent to k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if value is inserted right before p. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value_type move constructed from the pair if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>movable_value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value_type move constructed from the pair if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an element move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>movable_value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an element move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first, last are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [first,last) if and only if there is no element with key equivalent to the key of that element.</para><para><emphasis role="bold">Complexity</emphasis>: N log(size()+N).</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first, last are not iterators into *this.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [first,last) if and only if there is no element with key equivalent to the key of that element. This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Complexity</emphasis>: Linear.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="insert"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [il.begin(), il.end()) if and only if there is no element with key equivalent to the key of that element.</para><para><emphasis role="bold">Complexity</emphasis>: N log(N).</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [il.begin(), il.end()) if and only if there is no element with key equivalent to the key of that element. This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Complexity</emphasis>: Linear.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_map</classname>&lt; Key, T, C2, AllocatorOrContainer &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_map</classname>&lt; Key, T, C2, AllocatorOrContainer &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_multimap</classname>&lt; Key, T, C2, AllocatorOrContainer &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_multimap</classname>&lt; Key, T, C2, AllocatorOrContainer &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="erase"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by p.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements with keys bigger than p</para><para><emphasis role="bold">Note</emphasis>: Invalidates elements with keys not less than the erased element. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: size()*N where N is the distance from first to last.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method>
<method name="swap" cv="noexcept(allocator_traits_type::is_always_equal::value &amp;&amp;boost::container::dtl::is_nothrow_swappable&lt; Compare &gt;::value))"><type>void</type><parameter name="x"><paramtype><classname>flat_map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="clear" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="find"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="extract_sequence"><type>sequence_type</type><description><para><emphasis role="bold">Effects</emphasis>: Extracts the internal sequence container.</para><para><emphasis role="bold">Complexity</emphasis>: Same as the move constructor of sequence_type, usually constant.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;empty()</para><para><emphasis role="bold">Throws</emphasis>: If secuence_type's move constructor throws </para></description></method>
<method name="adopt_sequence"><type>void</type><parameter name="seq"><paramtype>sequence_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Discards the internally hold sequence container and adopts the one passed externally using the move assignment. Erases non-unique elements.</para><para><emphasis role="bold">Complexity</emphasis>: Assuming O(1) move assignment, O(NlogN) with N = seq.size()</para><para><emphasis role="bold">Throws</emphasis>: If the comparison or the move constructor throws </para></description></method>
<method name="adopt_sequence"><type>void</type><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="seq"><paramtype>sequence_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: seq shall be ordered according to this-&gt;compare() and shall contain unique elements.</para><para><emphasis role="bold">Effects</emphasis>: Discards the internally hold sequence container and adopts the one passed externally using the move assignment.</para><para><emphasis role="bold">Complexity</emphasis>: Assuming O(1) move assignment, O(1)</para><para><emphasis role="bold">Throws</emphasis>: If the move assignment throws </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; AllocatorOrContainer &gt;::value &amp;&amp;dtl::is_nothrow_default_constructible&lt; Compare &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Default constructs an empty <classname alt="boost::container::flat_map">flat_map</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> and and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified comparison object and and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> and inserts elements from the ordered range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified comparison object and inserts elements from the ordered range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified comparison object and allocator, and inserts elements from the ordered range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> and inserts elements from the range [il.begin() ,il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified allocator, and inserts elements from the range [il.begin() ,il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified comparison object and inserts elements from the range [il.begin() ,il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified comparison object and allocator, and inserts elements from the range [il.begin() ,il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified comparison object and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified comparison object and allocator, and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a <classname alt="boost::container::flat_map">flat_map</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor cv="noexcept(boost::container::dtl::is_nothrow_move_constructible&lt; Compare &gt;::value))"><parameter name="x"><paramtype><classname>flat_map</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a <classname alt="boost::container::flat_map">flat_map</classname>. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a <classname alt="boost::container::flat_map">flat_map</classname> using the specified allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>flat_map</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a <classname alt="boost::container::flat_map">flat_map</classname> using the specified allocator. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant if x.get_allocator() == a, linear otherwise. </para></description></constructor>
<copy-assignment><type><classname>flat_map</classname> &amp;</type><parameter name="x"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment>
<copy-assignment cv="noexcept((allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value)&amp;&amp;boost::container::dtl::is_nothrow_move_assignable&lt; Compare &gt;::value))"><type><classname>flat_map</classname> &amp;</type><parameter name="x"><paramtype><classname>flat_map</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a <classname alt="boost::container::flat_map">flat_map</classname>. Constructs *this using x's resources.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type's move constructor throws)</para><para><emphasis role="bold">Complexity</emphasis>: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this-&gt;get&gt;allocator() == x.get_allocator(). Linear otherwise. </para></description></copy-assignment>
<copy-assignment><type><classname>flat_map</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><purpose><emphasis role="bold">Effects</emphasis>: Assign elements from il to *this </purpose></copy-assignment>
<method-group name="friend functions">
<method name="operator=="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are equal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator!="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are unequal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="swap"><type>friend void</type><parameter name="x"><paramtype><classname>flat_map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>flat_map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y)</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
</method-group>
</class><class name="flat_multimap"><template>
      <template-type-parameter name="Key"><purpose><para>is the key_type of the map </para></purpose></template-type-parameter>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default><purpose><para>is the ordering function for Keys (e.g. <emphasis>std::less&lt;Key&gt;</emphasis>). </para></purpose></template-type-parameter>
      <template-type-parameter name="AllocatorOrContainer"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt; std::pair&lt; Key, T&gt; &gt;</default><purpose><para>is either:<itemizedlist>
<listitem><para>The allocator to allocate <computeroutput>value_type</computeroutput>s (e.g. <emphasis>allocator&lt; std::pair&lt;Key, T&gt; &gt; </emphasis>). (in this case <emphasis>sequence_type</emphasis> will be vector&lt;value_type, AllocatorOrContainer&gt;)</para></listitem><listitem><para>The SequenceContainer to be used as the underlying <emphasis>sequence_type</emphasis>. It must be a vector-like sequence container with random-access iterators. </para></listitem></itemizedlist>
</para></purpose></template-type-parameter>
    </template><description><para>A <classname alt="boost::container::flat_multimap">flat_multimap</classname> is a kind of associative container that supports equivalent keys (possibly containing multiple copies of the same key value) and provides for fast retrieval of values of another type T based on the keys.</para><para>A <classname alt="boost::container::flat_multimap">flat_multimap</classname> satisfies all of the requirements of a container and of a reversible container and of an associative container. For a flat_multimap&lt;Key,T&gt; the key_type is Key and the value_type is std::pair&lt;Key,T&gt; (unlike std::multimap&lt;Key, T&gt; which value_type is std::pair&lt;<emphasis role="bold">const</emphasis> Key, T&gt;).</para><para><classname alt="boost::container::flat_multimap">flat_multimap</classname> is similar to std::multimap but it's implemented by as an ordered sequence container. The underlying sequence container is by default <emphasis>vector</emphasis> but it can also work user-provided vector-like SequenceContainers (like <emphasis><classname alt="boost::container::static_vector">static_vector</classname></emphasis> or <emphasis><classname alt="boost::container::small_vector">small_vector</classname></emphasis>).</para><para>Using vector-like sequence containers means that inserting a new element into a <classname alt="boost::container::flat_multimap">flat_multimap</classname> might invalidate previous iterators and references (unless that sequence container is <emphasis><classname alt="boost::container::stable_vector">stable_vector</classname></emphasis> or a similar container that offers stable pointers and references). Similarly, erasing an element might invalidate iterators and references pointing to elements that come after (their keys are bigger) the erased element.</para><para>This container provides random-access iterators.</para><para>
</para></description><typedef name="key_type"><type>Key</type></typedef>
<typedef name="mapped_type"><type>T</type></typedef>
<typedef name="key_compare"><type>Compare</type></typedef>
<typedef name="value_type"><type>std::pair&lt; Key, T &gt;</type></typedef>
<typedef name="sequence_type"><type>implementation_defined</type></typedef>
<typedef name="allocator_type"><type>sequence_type::allocator_type</type></typedef>
<typedef name="allocator_traits_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; allocator_type &gt;</type></typedef>
<typedef name="pointer"><type>sequence_type::pointer</type></typedef>
<typedef name="const_pointer"><type>sequence_type::const_pointer</type></typedef>
<typedef name="reference"><type>sequence_type::reference</type></typedef>
<typedef name="const_reference"><type>sequence_type::const_reference</type></typedef>
<typedef name="size_type"><type>sequence_type::size_type</type></typedef>
<typedef name="difference_type"><type>sequence_type::difference_type</type></typedef>
<typedef name="stored_allocator_type"><type>implementation_defined</type></typedef>
<typedef name="value_compare"><type>implementation_defined</type></typedef>
<typedef name="iterator"><type>sequence_type::iterator</type></typedef>
<typedef name="const_iterator"><type>sequence_type::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>sequence_type::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>sequence_type::const_reverse_iterator</type></typedef>
<typedef name="movable_value_type"><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="BOOST_STATIC_ASSERT"><type/><parameter name=""><paramtype>(dtl::is_same&lt; std::pair&lt; Key, T &gt;, typename AllocatorOrContainer::value_type &gt;::value)</paramtype></parameter></method>
<method name="get_allocator" cv="const noexcept"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator" cv="noexcept"><type>stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="const noexcept"><type>const stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="begin" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="empty" cv="const noexcept"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="capacity" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="reserve"><type>void</type><parameter name="cnt"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If n is less than or equal to capacity(), or the underlying container has no <computeroutput>reserve</computeroutput> member, this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Note</emphasis>: If capacity() is less than "cnt", iterators and references to to values might be invalidated. </para></description></method>
<method name="shrink_to_fit"><type>void</type><purpose><emphasis role="bold">Effects</emphasis>: Tries to deallocate the excess of memory created </purpose><description><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size(). </para></description></method>
<method name="nth" cv="noexcept"><type>iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="nth" cv="const noexcept"><type>const_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="noexcept"><type>size_type</type><parameter name="p"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="const noexcept"><type>size_type</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="emplace_hint"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant time if the value is to be inserted before p) plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value move-constructed from x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="x"><paramtype>impl_value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value move-constructed from x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant time if the value is to be inserted before p) plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a value move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant time if the value is to be inserted before p) plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>impl_value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a value move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant time if the value is to be inserted before p) plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first, last are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [first,last) .</para><para><emphasis role="bold">Complexity</emphasis>: N log(N).</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first, last are not iterators into *this.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [first,last) if and only if there is no element with key equivalent to the key of that element. This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Complexity</emphasis>: Linear.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="insert"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [il.begin(), il.end()) .</para><para><emphasis role="bold">Complexity</emphasis>: N log(N).</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [il.begin(), il.end()) if and only if there is no element with key equivalent to the key of that element. This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Complexity</emphasis>: Linear.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_multimap</classname>&lt; Key, T, C2, AllocatorOrContainer &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_multimap</classname>&lt; Key, T, C2, AllocatorOrContainer &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_map</classname>&lt; Key, T, C2, AllocatorOrContainer &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_map</classname>&lt; Key, T, C2, AllocatorOrContainer &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="erase"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by p.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements with keys bigger than p</para><para><emphasis role="bold">Note</emphasis>: Invalidates elements with keys not less than the erased element. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: size()*N where N is the distance from first to last.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method>
<method name="swap" cv="noexcept(allocator_traits_type::is_always_equal::value &amp;&amp;boost::container::dtl::is_nothrow_swappable&lt; Compare &gt;::value))"><type>void</type><parameter name="x"><paramtype><classname>flat_multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="clear" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="find"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="extract_sequence"><type>sequence_type</type><description><para><emphasis role="bold">Effects</emphasis>: Extracts the internal sequence container.</para><para><emphasis role="bold">Complexity</emphasis>: Same as the move constructor of sequence_type, usually constant.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;empty()</para><para><emphasis role="bold">Throws</emphasis>: If secuence_type's move constructor throws </para></description></method>
<method name="adopt_sequence"><type>void</type><parameter name="seq"><paramtype>sequence_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Discards the internally hold sequence container and adopts the one passed externally using the move assignment.</para><para><emphasis role="bold">Complexity</emphasis>: Assuming O(1) move assignment, O(NlogN) with N = seq.size()</para><para><emphasis role="bold">Throws</emphasis>: If the comparison or the move constructor throws </para></description></method>
<method name="adopt_sequence"><type>void</type><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="seq"><paramtype>sequence_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: seq shall be ordered according to this-&gt;compare().</para><para><emphasis role="bold">Effects</emphasis>: Discards the internally hold sequence container and adopts the one passed externally using the move assignment.</para><para><emphasis role="bold">Complexity</emphasis>: Assuming O(1) move assignment, O(1)</para><para><emphasis role="bold">Throws</emphasis>: If the move assignment throws </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; AllocatorOrContainer &gt;::value &amp;&amp;dtl::is_nothrow_default_constructible&lt; Compare &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Default constructs an empty <classname alt="boost::container::flat_map">flat_map</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multimap">flat_multimap</classname> using the specified allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multimap">flat_multimap</classname> using the specified comparison object .</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multimap">flat_multimap</classname> using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multimap">flat_multimap</classname> and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multimap">flat_multimap</classname> using the specified allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multimap">flat_multimap</classname> using the specified comparison object and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multimap">flat_multimap</classname> using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multimap">flat_multimap</classname> and inserts elements from the ordered range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multimap">flat_multimap</classname> using the specified comparison object and inserts elements from the ordered range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multimap">flat_multimap</classname> using the specified comparison object and allocator, and inserts elements from the ordered range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified comparison object and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_map">flat_map</classname> using the specified comparison object and allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multimap">flat_multimap</classname> and inserts elements from the ordered range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multimap">flat_multimap</classname> using the specified comparison object and inserts elements from the ordered range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multimap">flat_multimap</classname> using the specified comparison object and allocator, and inserts elements from the ordered range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a <classname alt="boost::container::flat_multimap">flat_multimap</classname>.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor cv="noexcept(boost::container::dtl::is_nothrow_move_constructible&lt; Compare &gt;::value))"><parameter name="x"><paramtype><classname>flat_multimap</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a <classname alt="boost::container::flat_multimap">flat_multimap</classname>. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a <classname alt="boost::container::flat_multimap">flat_multimap</classname> using the specified allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>flat_multimap</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a <classname alt="boost::container::flat_multimap">flat_multimap</classname> using the specified allocator. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant if a == x.get_allocator(), linear otherwise. </para></description></constructor>
<copy-assignment><type><classname>flat_multimap</classname> &amp;</type><parameter name="x"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment>
<copy-assignment cv="noexcept((allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value)&amp;&amp;boost::container::dtl::is_nothrow_move_assignable&lt; Compare &gt;::value))"><type><classname>flat_multimap</classname> &amp;</type><parameter name="x"><paramtype><classname>flat_multimap</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: this-&gt;swap(x.get()).</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></copy-assignment>
<copy-assignment><type><classname>flat_multimap</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assign content of il to *this</para><para><emphasis role="bold">Complexity</emphasis>: Linear in il.size(). </para></description></copy-assignment>
<method-group name="friend functions">
<method name="operator=="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are equal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator!="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are unequal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="swap"><type>friend void</type><parameter name="x"><paramtype><classname>flat_multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>flat_multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y)</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
</method-group>
</class>

























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/flat_map.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<struct name="flat_map_of"><template>
      <template-type-parameter name="Key"/>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default></template-type-parameter>
    </template><description><para>A portable metafunction to obtain a <classname alt="boost::container::flat_map">flat_map</classname> that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::flat_map</classname>&lt; Key, T, Compare, <classname>polymorphic_allocator</classname>&lt; std::pair&lt; Key, T &gt; &gt; &gt;</type></typedef>
</struct><struct name="flat_multimap_of"><template>
      <template-type-parameter name="Key"/>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default></template-type-parameter>
    </template><description><para>A portable metafunction to obtain a <classname alt="boost::container::flat_multimap">flat_multimap</classname> that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::flat_multimap</classname>&lt; Key, T, Compare, <classname>polymorphic_allocator</classname>&lt; std::pair&lt; Key, T &gt; &gt; &gt;</type></typedef>
</struct><typedef name="flat_map"><type><classname>boost::container::flat_map</classname>&lt; Key, T, Compare, <classname>polymorphic_allocator</classname>&lt; std::pair&lt; Key, T &gt; &gt; &gt;</type></typedef>
<typedef name="flat_multimap"><type><classname>boost::container::flat_multimap</classname>&lt; Key, T, Compare, <classname>polymorphic_allocator</classname>&lt; std::pair&lt; Key, T &gt; &gt; &gt;</type></typedef>






</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/flat_set.hpp">
<namespace name="boost">
<namespace name="container">
<class name="flat_set"><template>
      <template-type-parameter name="Key"><purpose><para>is the type to be inserted in the set, which is also the key_type </para></purpose></template-type-parameter>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default><purpose><para>is the comparison functor used to order keys </para></purpose></template-type-parameter>
      <template-type-parameter name="AllocatorOrContainer"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt;Key&gt;</default><purpose><para>is either:<itemizedlist>
<listitem><para>The allocator to allocate <computeroutput>value_type</computeroutput>s (e.g. <emphasis>allocator&lt; std::pair&lt;Key, T&gt; &gt; </emphasis>). (in this case <emphasis>sequence_type</emphasis> will be vector&lt;value_type, AllocatorOrContainer&gt;)</para></listitem><listitem><para>The SequenceContainer to be used as the underlying <emphasis>sequence_type</emphasis>. It must be a vector-like sequence container with random-access iterators. </para></listitem></itemizedlist>
</para></purpose></template-type-parameter>
    </template><description><para><classname alt="boost::container::flat_set">flat_set</classname> is a Sorted Associative Container that stores objects of type Key. It is also a Unique Associative Container, meaning that no two elements are the same.</para><para><classname alt="boost::container::flat_set">flat_set</classname> is similar to std::set but it's implemented by as an ordered sequence container. The underlying sequence container is by default <emphasis>vector</emphasis> but it can also work user-provided vector-like SequenceContainers (like <emphasis><classname alt="boost::container::static_vector">static_vector</classname></emphasis> or <emphasis><classname alt="boost::container::small_vector">small_vector</classname></emphasis>).</para><para>Using vector-like sequence containers means that inserting a new element into a <classname alt="boost::container::flat_set">flat_set</classname> might invalidate previous iterators and references (unless that sequence container is <emphasis><classname alt="boost::container::stable_vector">stable_vector</classname></emphasis> or a similar container that offers stable pointers and references). Similarly, erasing an element might invalidate iterators and references pointing to elements that come after (their keys are bigger) the erased element.</para><para>This container provides random-access iterators.</para><para>
</para></description><typedef name="key_type"><type>Key</type></typedef>
<typedef name="key_compare"><type>Compare</type></typedef>
<typedef name="value_type"><type>Key</type></typedef>
<typedef name="sequence_type"><type>implementation_defined</type></typedef>
<typedef name="allocator_type"><type>sequence_type::allocator_type</type></typedef>
<typedef name="allocator_traits_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; allocator_type &gt;</type></typedef>
<typedef name="pointer"><type>sequence_type::pointer</type></typedef>
<typedef name="const_pointer"><type>sequence_type::const_pointer</type></typedef>
<typedef name="reference"><type>sequence_type::reference</type></typedef>
<typedef name="const_reference"><type>sequence_type::const_reference</type></typedef>
<typedef name="size_type"><type>sequence_type::size_type</type></typedef>
<typedef name="difference_type"><type>sequence_type::difference_type</type></typedef>
<typedef name="stored_allocator_type"><type>implementation_defined</type></typedef>
<typedef name="value_compare"><type>implementation_defined</type></typedef>
<typedef name="iterator"><type>sequence_type::iterator</type></typedef>
<typedef name="const_iterator"><type>sequence_type::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>sequence_type::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>sequence_type::const_reverse_iterator</type></typedef>
<method-group name="public member functions">
<method name="get_allocator" cv="const noexcept"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator" cv="noexcept"><type>stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="const noexcept"><type>const stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="begin" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="empty" cv="const noexcept"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="capacity" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="reserve"><type>void</type><parameter name="cnt"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If n is less than or equal to capacity(), or the underlying container has no <computeroutput>reserve</computeroutput> member, this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Note</emphasis>: If capacity() is less than "cnt", iterators and references to to values might be invalidated. </para></description></method>
<method name="shrink_to_fit"><type>void</type><purpose><emphasis role="bold">Effects</emphasis>: Tries to deallocate the excess of memory created </purpose><description><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or Key's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size(). </para></description></method>
<method name="emplace"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object x of type Key constructed with std::forward&lt;Args&gt;(args)... if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="emplace_hint"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type Key constructed with std::forward&lt;Args&gt;(args)... in the container if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value_type move constructed from the pair if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an element move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first, last are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [first,last) if and only if there is no element with key equivalent to the key of that element.</para><para><emphasis role="bold">Complexity</emphasis>: N log(N).</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first, last are not iterators into *this and must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [first,last) .This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Complexity</emphasis>: Linear.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [il.begin(), il.end()) if and only if there is no element with key equivalent to the key of that element.</para><para><emphasis role="bold">Complexity</emphasis>: N log(N).</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Range [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [il.begin(), il.end()) .This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Complexity</emphasis>: Linear.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. If an element is inserted it might invalidate elements. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_set</classname>&lt; Key, C2, AllocatorOrContainer &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_set</classname>&lt; Key, C2, AllocatorOrContainer &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_multiset</classname>&lt; Key, C2, AllocatorOrContainer &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_multiset</classname>&lt; Key, C2, AllocatorOrContainer &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="erase"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by p.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements with keys bigger than p</para><para><emphasis role="bold">Note</emphasis>: Invalidates elements with keys not less than the erased element. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: size()*N where N is the distance from first to last.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method>
<method name="swap" cv="noexcept(allocator_traits_type::is_always_equal::value &amp;&amp;boost::container::dtl::is_nothrow_swappable&lt; Compare &gt;::value))"><type>void</type><parameter name="x"><paramtype><classname>flat_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="clear" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="find"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="nth" cv="noexcept"><type>iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="nth" cv="const noexcept"><type>const_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="noexcept"><type>size_type</type><parameter name="p"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="const noexcept"><type>size_type</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="extract_sequence"><type>sequence_type</type><description><para><emphasis role="bold">Effects</emphasis>: Extracts the internal sequence container.</para><para><emphasis role="bold">Complexity</emphasis>: Same as the move constructor of sequence_type, usually constant.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;empty()</para><para><emphasis role="bold">Throws</emphasis>: If secuence_type's move constructor throws </para></description></method>
<method name="adopt_sequence"><type>void</type><parameter name="seq"><paramtype>sequence_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Discards the internally hold sequence container and adopts the one passed externally using the move assignment. Erases non-unique elements.</para><para><emphasis role="bold">Complexity</emphasis>: Assuming O(1) move assignment, O(NlogN) with N = seq.size()</para><para><emphasis role="bold">Throws</emphasis>: If the comparison or the move constructor throws </para></description></method>
<method name="adopt_sequence"><type>void</type><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="seq"><paramtype>sequence_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: seq shall be ordered according to this-&gt;compare() and shall contain unique elements.</para><para><emphasis role="bold">Effects</emphasis>: Discards the internally hold sequence container and adopts the one passed externally using the move assignment.</para><para><emphasis role="bold">Complexity</emphasis>: Assuming O(1) move assignment, O(1)</para><para><emphasis role="bold">Throws</emphasis>: If the move assignment throws </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; AllocatorOrContainer &gt;::value &amp;&amp;dtl::is_nothrow_default_constructible&lt; Compare &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Default constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from the ordered unique range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and inserts elements from the ordered unique range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and allocator, and inserts elements from the ordered unique range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using comp and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using comp and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using comp and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using comp and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and allocator, and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor cv="noexcept(boost::container::dtl::is_nothrow_move_constructible&lt; Compare &gt;::value))"><parameter name="x"><paramtype><classname>flat_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs thecontainer. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a container using the specified allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>flat_set</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a container using the specified allocator. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant if a == x.get_allocator(), linear otherwise </para></description></constructor>
<copy-assignment><type><classname>flat_set</classname> &amp;</type><parameter name="x"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment>
<copy-assignment cv="noexcept((allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value)&amp;&amp;boost::container::dtl::is_nothrow_move_assignable&lt; Compare &gt;::value))"><type><classname>flat_set</classname> &amp;</type><parameter name="x"><paramtype><classname>flat_set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Throws</emphasis>: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type's move constructor throws)</para><para><emphasis role="bold">Complexity</emphasis>: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this-&gt;get&gt;allocator() == x.get_allocator(). Linear otherwise. </para></description></copy-assignment>
<copy-assignment><type><classname>flat_set</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy all elements from il to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in il.size(). </para></description></copy-assignment>
<method-group name="friend functions">
<method name="operator=="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are equal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator!="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are unequal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="swap"><type>friend void</type><parameter name="x"><paramtype><classname>flat_set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>flat_set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y)</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
</method-group>
</class><class name="flat_multiset"><template>
      <template-type-parameter name="Key"><purpose><para>is the type to be inserted in the multiset, which is also the key_type </para></purpose></template-type-parameter>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default><purpose><para>is the comparison functor used to order keys </para></purpose></template-type-parameter>
      <template-type-parameter name="AllocatorOrContainer"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt;Key&gt;</default><purpose><para>is either:<itemizedlist>
<listitem><para>The allocator to allocate <computeroutput>value_type</computeroutput>s (e.g. <emphasis>allocator&lt; std::pair&lt;Key, T&gt; &gt; </emphasis>). (in this case <emphasis>sequence_type</emphasis> will be vector&lt;value_type, AllocatorOrContainer&gt;)</para></listitem><listitem><para>The SequenceContainer to be used as the underlying <emphasis>sequence_type</emphasis>. It must be a vector-like sequence container with random-access iterators. </para></listitem></itemizedlist>
</para></purpose></template-type-parameter>
    </template><description><para><classname alt="boost::container::flat_multiset">flat_multiset</classname> is a Sorted Associative Container that stores objects of type Key and can store multiple copies of the same key value.</para><para><classname alt="boost::container::flat_multiset">flat_multiset</classname> is similar to std::multiset but it's implemented by as an ordered sequence container. The underlying sequence container is by default <emphasis>vector</emphasis> but it can also work user-provided vector-like SequenceContainers (like <emphasis><classname alt="boost::container::static_vector">static_vector</classname></emphasis> or <emphasis><classname alt="boost::container::small_vector">small_vector</classname></emphasis>).</para><para>Using vector-like sequence containers means that inserting a new element into a <classname alt="boost::container::flat_multiset">flat_multiset</classname> might invalidate previous iterators and references (unless that sequence container is <emphasis><classname alt="boost::container::stable_vector">stable_vector</classname></emphasis> or a similar container that offers stable pointers and references). Similarly, erasing an element might invalidate iterators and references pointing to elements that come after (their keys are bigger) the erased element.</para><para>This container provides random-access iterators.</para><para>
</para></description><typedef name="key_type"><type>Key</type></typedef>
<typedef name="key_compare"><type>Compare</type></typedef>
<typedef name="value_type"><type>Key</type></typedef>
<typedef name="sequence_type"><type>implementation_defined</type></typedef>
<typedef name="allocator_type"><type>sequence_type::allocator_type</type></typedef>
<typedef name="allocator_traits_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; allocator_type &gt;</type></typedef>
<typedef name="pointer"><type>sequence_type::pointer</type></typedef>
<typedef name="const_pointer"><type>sequence_type::const_pointer</type></typedef>
<typedef name="reference"><type>sequence_type::reference</type></typedef>
<typedef name="const_reference"><type>sequence_type::const_reference</type></typedef>
<typedef name="size_type"><type>sequence_type::size_type</type></typedef>
<typedef name="difference_type"><type>sequence_type::difference_type</type></typedef>
<typedef name="stored_allocator_type"><type>implementation_defined</type></typedef>
<typedef name="value_compare"><type>implementation_defined</type></typedef>
<typedef name="iterator"><type>sequence_type::iterator</type></typedef>
<typedef name="const_iterator"><type>sequence_type::const_iterator</type></typedef>
<typedef name="reverse_iterator"><type>sequence_type::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><type>sequence_type::const_reverse_iterator</type></typedef>
<method-group name="public member functions">
<method name="get_allocator" cv="const noexcept"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator" cv="noexcept"><type>stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="const noexcept"><type>const stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="begin" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="empty" cv="const noexcept"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="capacity" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="reserve"><type>void</type><parameter name="cnt"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If n is less than or equal to capacity(), or the underlying container has no <computeroutput>reserve</computeroutput> member, this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Note</emphasis>: If capacity() is less than "cnt", iterators and references to to values might be invalidated. </para></description></method>
<method name="shrink_to_fit"><type>void</type><purpose><emphasis role="bold">Effects</emphasis>: Tries to deallocate the excess of memory created </purpose><description><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or Key's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size(). </para></description></method>
<method name="emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type Key constructed with std::forward&lt;Args&gt;(args)... and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="emplace_hint"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type Key constructed with std::forward&lt;Args&gt;(args)... in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value_type move constructed from x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus linear insertion to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x.</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first, last are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [first,last) .</para><para><emphasis role="bold">Complexity</emphasis>: N log(N).</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first, last are not iterators into *this and must be ordered according to the predicate.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [first,last) .This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Complexity</emphasis>: Linear.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: N log(N).</para><para><emphasis role="bold">Note</emphasis>: If an element is inserted it might invalidate elements. </para></description></method>
<method name="insert"><type>void</type><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Range [il.begin(), il.end()) must be ordered according to the predicate.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Complexity</emphasis>: Linear.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. If an element is inserted it might invalidate elements. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_multiset</classname>&lt; Key, C2, AllocatorOrContainer &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_multiset</classname>&lt; Key, C2, AllocatorOrContainer &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_set</classname>&lt; Key, C2, AllocatorOrContainer &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>flat_set</classname>&lt; Key, C2, AllocatorOrContainer &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="erase"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by p.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements with keys bigger than p</para><para><emphasis role="bold">Note</emphasis>: Invalidates elements with keys not less than the erased element. </para></description></method>
<method name="erase"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: size()*N where N is the distance from first to last.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic search time plus erasure time linear to the elements with bigger keys. </para></description></method>
<method name="swap" cv="noexcept(allocator_traits_type::is_always_equal::value &amp;&amp;boost::container::dtl::is_nothrow_swappable&lt; Compare &gt;::value))"><type>void</type><parameter name="x"><paramtype><classname>flat_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="clear" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="find"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="nth" cv="noexcept"><type>iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="nth" cv="const noexcept"><type>const_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="noexcept"><type>size_type</type><parameter name="p"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="const noexcept"><type>size_type</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="extract_sequence"><type>sequence_type</type><description><para><emphasis role="bold">Effects</emphasis>: Extracts the internal sequence container.</para><para><emphasis role="bold">Complexity</emphasis>: Same as the move constructor of sequence_type, usually constant.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;empty()</para><para><emphasis role="bold">Throws</emphasis>: If secuence_type's move constructor throws </para></description></method>
<method name="adopt_sequence"><type>void</type><parameter name="seq"><paramtype>sequence_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Discards the internally hold sequence container and adopts the one passed externally using the move assignment.</para><para><emphasis role="bold">Complexity</emphasis>: Assuming O(1) move assignment, O(NlogN) with N = seq.size()</para><para><emphasis role="bold">Throws</emphasis>: If the comparison or the move constructor throws </para></description></method>
<method name="adopt_sequence"><type>void</type><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="seq"><paramtype>sequence_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: seq shall be ordered according to this-&gt;compare()</para><para><emphasis role="bold">Effects</emphasis>: Discards the internally hold sequence container and adopts the one passed externally using the move assignment.</para><para><emphasis role="bold">Complexity</emphasis>: Assuming O(1) move assignment, O(1)</para><para><emphasis role="bold">Throws</emphasis>: If the move assignment throws </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; AllocatorOrContainer &gt;::value &amp;&amp;dtl::is_nothrow_default_constructible&lt; Compare &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Default constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multiset">flat_multiset</classname> and inserts elements from the ordered range [first ,last ). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multiset">flat_multiset</classname> using the specified comparison object and inserts elements from the ordered range [first ,last ). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty <classname alt="boost::container::flat_multiset">flat_multiset</classname> using the specified comparison object and allocator, and inserts elements from the ordered range [first, last ). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Default constructs an empty container.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using comp and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using comp and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using comp and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty containerand inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty container using the specified comparison object and allocator, and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs the container.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor cv="noexcept(boost::container::dtl::is_nothrow_move_constructible&lt; Compare &gt;::value))"><parameter name="x"><paramtype><classname>flat_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs thecontainer. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a container using the specified allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>flat_multiset</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a container using the specified allocator. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant if a == x.get_allocator(), linear otherwise </para></description></constructor>
<copy-assignment><type><classname>flat_multiset</classname> &amp;</type><parameter name="x"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment>
<copy-assignment cv="noexcept((allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value)&amp;&amp;boost::container::dtl::is_nothrow_move_assignable&lt; Compare &gt;::value))"><type><classname>flat_multiset</classname> &amp;</type><parameter name="x"><paramtype><classname>flat_multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Throws</emphasis>: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type's move constructor throws)</para><para><emphasis role="bold">Complexity</emphasis>: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this-&gt;get&gt;allocator() == x.get_allocator(). Linear otherwise. </para></description></copy-assignment>
<copy-assignment><type><classname>flat_multiset</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy all elements from il to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in il.size(). </para></description></copy-assignment>
<method-group name="friend functions">
<method name="operator=="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are equal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator!="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are unequal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>flat_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="swap"><type>friend void</type><parameter name="x"><paramtype><classname>flat_multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>flat_multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y)</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
</method-group>
</class>

























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/flat_set.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<struct name="flat_set_of"><template>
      <template-type-parameter name="Key"/>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default></template-type-parameter>
    </template><description><para>A portable metafunction to obtain a <classname alt="boost::container::flat_set">flat_set</classname> that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::flat_set</classname>&lt; Key, Compare, <classname>polymorphic_allocator</classname>&lt; Key &gt; &gt;</type></typedef>
</struct><struct name="flat_multiset_of"><template>
      <template-type-parameter name="Key"/>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default></template-type-parameter>
    </template><description><para>A portable metafunction to obtain a <classname alt="boost::container::flat_multiset">flat_multiset</classname> that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::flat_multiset</classname>&lt; Key, Compare, <classname>polymorphic_allocator</classname>&lt; Key &gt; &gt;</type></typedef>
</struct><typedef name="flat_set"><type><classname>boost::container::flat_set</classname>&lt; Key, Compare, <classname>polymorphic_allocator</classname>&lt; Key &gt; &gt;</type></typedef>
<typedef name="flat_multiset"><type><classname>boost::container::flat_multiset</classname>&lt; Key, Compare, <classname>polymorphic_allocator</classname>&lt; Key &gt; &gt;</type></typedef>






</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/list.hpp">
<namespace name="boost">
<namespace name="container">
<class name="list"><template>
      <template-type-parameter name="T"><purpose><para>The type of object that is stored in the list </para></purpose></template-type-parameter>
      <template-type-parameter name="Allocator"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt;T&gt;</default><purpose><para>The allocator used for all internal memory management </para></purpose></template-type-parameter>
    </template><inherit access="protected">dtl::node_alloc_holder&lt; Allocator, dtl::intrusive_list_type&lt; Allocator &gt;::type &gt;</inherit><description><para>A list is a doubly linked list. That is, it is a Sequence that supports both forward and backward traversal, and (amortized) constant time insertion and removal of elements at the beginning or the end, or in the middle. Lists have the important property that insertion and splicing do not invalidate iterators to list elements, and that even removal invalidates only the iterators that point to the elements that are removed. The ordering of iterators may be changed (that is, list&lt;T&gt;::iterator might have a different predecessor or successor after a list operation than it did before), but the iterators themselves will not be invalidated or made to point to different elements unless that invalidation or mutation is explicit.</para><para>
</para></description><typedef name="value_type"><type>T</type></typedef>
<typedef name="pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::pointer</type></typedef>
<typedef name="const_pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_pointer</type></typedef>
<typedef name="reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::reference</type></typedef>
<typedef name="const_reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_reference</type></typedef>
<typedef name="size_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::size_type</type></typedef>
<typedef name="difference_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::difference_type</type></typedef>
<typedef name="allocator_type"><type>Allocator</type></typedef>
<typedef name="stored_allocator_type"><type>implementation_defined</type></typedef>
<typedef name="iterator"><type>implementation_defined</type></typedef>
<typedef name="const_iterator"><type>implementation_defined</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="assign"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="val"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the n copies of val to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="assign"><type>void</type><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the range [first, last) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's constructor from dereferencing InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="assign"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the range [il.begin(), il.end()) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's constructor from dereferencing std::initializer_list iterator throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="get_allocator" cv="const noexcept"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: If allocator's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator" cv="noexcept"><type>stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="const noexcept"><type>const stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="begin" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="empty" cv="const noexcept"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the list contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="resize"><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are value initialized.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method>
<method name="resize"><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are copy constructed from x.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method>
<method name="front" cv="noexcept"><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="front" cv="const noexcept"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="back" cv="noexcept"><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="back" cv="const noexcept"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="emplace_back"><type>reference</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the end of the list.</para><para><emphasis role="bold">Returns</emphasis>: A reference to the created object.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's in-place constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="emplace_front"><type>reference</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the beginning of the list.</para><para><emphasis role="bold">Returns</emphasis>: A reference to the created object.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's in-place constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="position"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... before p.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's in-place constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="push_front"><type>void</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x at the beginning of the list.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="push_front"><type>void</type><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a new element in the beginning of the list and moves the resources of x to this new element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="push_back"><type>void</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x at the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="push_back"><type>void</type><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a new element in the end of the list and moves the resources of x to this new element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of x before p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or x's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a new element before p with x's resources.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts n copies of x before p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or p if n is 0.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="insert"><type>iterator</type><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [first, last) range before p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or p if first == last.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to distance [first, last). </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [il.begin(), il.end()) range before p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or p if if.begin() == il.end().</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced std::initializer_list iterator throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to distance [il.begin(), il.end()). </para></description></method>
<method name="pop_front" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the first element from the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="pop_back" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the last element from the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="erase" cv="noexcept"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element at p.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="erase" cv="noexcept"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first and last must be valid iterator to elements in *this.</para><para><emphasis role="bold">Effects</emphasis>: Erases the elements pointed by [first, last).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the distance between first and last. </para></description></method>
<method name="swap" cv="noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value))"><type>void</type><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="clear" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the list. </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by the list. x != *this. this' allocator and x's allocator shall compare equal</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by the list. x != *this. this' allocator and x's allocator shall compare equal</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. i must point to an element contained in list x. this' allocator and x's allocator shall compare equal</para><para><emphasis role="bold">Effects</emphasis>: Transfers the value pointed by i, from list x to this list, before the element pointed by p. No destructors or copy constructors are called. If p == i or p == ++i, this function is a null operation.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;&amp;</paramtype></parameter><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. i must point to an element contained in list x. this' allocator and x's allocator shall compare equal.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the value pointed by i, from list x to this list, before the element pointed by p. No destructors or copy constructors are called. If p == i or p == ++i, this function is a null operation.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. first and last must point to elements contained in list x. this' allocator and x's allocator shall compare equal</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range pointed by first and last from list x to this list, before the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements transferred.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;&amp;</paramtype></parameter><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. first and last must point to elements contained in list x. this' allocator and x's allocator shall compare equal.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range pointed by first and last from list x to this list, before the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements transferred.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. first and last must point to elements contained in list x. n == distance(first, last). this' allocator and x's allocator shall compare equal</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range pointed by first and last from list x to this list, before the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>list</classname> &amp;&amp;</paramtype></parameter><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. first and last must point to elements contained in list x. n == distance(first, last). this' allocator and x's allocator shall compare equal</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range pointed by first and last from list x to this list, before the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="remove"><type>void</type><parameter name="value"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements that compare equal to value.</para><para><emphasis role="bold">Throws</emphasis>: If comparison throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="remove_if"><type>void</type><template>
          <template-type-parameter name="Pred"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements for which a specified predicate is satisfied.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() calls to the predicate.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="unique"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that are equal from the list.</para><para><emphasis role="bold">Throws</emphasis>: If comparison throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1 comparisons equality comparisons).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="unique"><type>void</type><template>
          <template-type-parameter name="BinaryPredicate"/>
        </template><parameter name="binary_pred"><paramtype>BinaryPredicate</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1 comparisons calls to pred()).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="merge"><type>void</type><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If comparison throws.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons. </para></description></method>
<method name="merge"><type>void</type><parameter name="x"><paramtype><classname>list</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If comparison throws.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="StrictWeakOrdering"/>
        </template><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><parameter name="comp"><paramtype>const StrictWeakOrdering &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If comp throws.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references to *this are not invalidated. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="StrictWeakOrdering"/>
        </template><parameter name="x"><paramtype><classname>list</classname> &amp;&amp;</paramtype></parameter><parameter name="comp"><paramtype>StrictWeakOrdering</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If comp throws.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references to *this are not invalidated. </para></description></method>
<method name="sort"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: If comparison throws.</para><para><emphasis role="bold">Notes</emphasis>: Iterators and references are not invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size. </para></description></method>
<method name="sort"><type>void</type><template>
          <template-type-parameter name="StrictWeakOrdering"/>
        </template><parameter name="comp"><paramtype>StrictWeakOrdering</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: If comp throws.</para><para><emphasis role="bold">Notes</emphasis>: Iterators and references are not invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size. </para></description></method>
<method name="reverse" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; Allocator &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Default constructs a list.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list taking the allocator as parameter.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list and inserts n value-initialized value_types.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list that will use a copy of allocator a and inserts n copies of value.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="value"><paramtype>const T &amp;</paramtype></parameter><parameter name="a"><paramtype>const Allocator &amp;</paramtype><default>Allocator()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list that will use a copy of allocator a and inserts n copies of value.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a list.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></constructor>
<constructor cv="noexcept"><parameter name="x"><paramtype><classname>list</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor. Moves x's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a list using the specified allocator.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>list</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor sing the specified allocator. Moves x's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocation or value_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant if a == x.get_allocator(), linear otherwise. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter><parameter name="a"><paramtype>const Allocator &amp;</paramtype><default>Allocator()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list that will use a copy of allocator a and inserts a copy of the range [first, last) in the list.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's constructor taking a dereferenced InIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [first, last). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const Allocator &amp;</paramtype><default>Allocator()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list that will use a copy of allocator a and inserts a copy of the range [il.begin(), il.end()) in the list.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's constructor taking a dereferenced std::initializer_list iterator throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [il.begin(), il.end()). </para></description></constructor>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Destroys the list. All stored values are destroyed and used memory is deallocated.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements. </para></description></destructor>
<copy-assignment><type><classname>list</classname> &amp;</type><parameter name="x"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this contain the same elements as x.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;size() == x.size(). *this contains a copy of each of x's elements.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in x. </para></description></copy-assignment>
<copy-assignment cv="noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value))"><type><classname>list</classname> &amp;</type><parameter name="x"><paramtype><classname>list</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move assignment. All x's values are transferred to *this.</para><para><emphasis role="bold">Postcondition</emphasis>: x.empty(). *this contains a the elements x had before the function.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type's move constructor throws)</para><para><emphasis role="bold">Complexity</emphasis>: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this-&gt;get&gt;allocator() == x.get_allocator(). Linear otherwise. </para></description></copy-assignment>
<copy-assignment><type><classname>list</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this contain the same elements as il.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;size() == il.size(). *this contains a copy of each of x's elements.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in x. </para></description></copy-assignment>
<method-group name="friend functions">
<method name="operator=="><type>friend bool</type><parameter name="x"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are equal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator!="><type>friend bool</type><parameter name="x"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are unequal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="swap"><type>friend void</type><parameter name="x"><paramtype><classname>list</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>list</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y)</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
</method-group>
</class>

























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/list.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<struct name="list_of"><template>
      <template-type-parameter name="T"/>
    </template><description><para>A portable metafunction to obtain a list that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::list</classname>&lt; T, <classname>polymorphic_allocator</classname>&lt; T &gt; &gt;</type></typedef>
</struct><typedef name="list"><type><classname>boost::container::list</classname>&lt; T, <classname>polymorphic_allocator</classname>&lt; T &gt;&gt;</type></typedef>






</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/map.hpp">
<namespace name="boost">
<namespace name="container">
<class name="map"><template>
      <template-type-parameter name="Key"><purpose><para>is the key_type of the map </para></purpose></template-type-parameter>
      <template-type-parameter name="T"><purpose><para>is the <computeroutput>mapped_type</computeroutput> </para></purpose></template-type-parameter>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default><purpose><para>is the ordering function for Keys (e.g. <emphasis>std::less&lt;Key&gt;</emphasis>). </para></purpose></template-type-parameter>
      <template-type-parameter name="Allocator"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt; std::pair&lt; const Key, T&gt; &gt;</default><purpose><para>is the allocator to allocate the <computeroutput>value_type</computeroutput>s (e.g. <emphasis>allocator&lt; std::pair&lt;const Key, T&gt; &gt; </emphasis>). </para></purpose></template-type-parameter>
      <template-type-parameter name="Options"><default>tree_assoc_defaults</default><purpose><para>is an packed option type generated using using <classname alt="boost::container::tree_assoc_options">boost::container::tree_assoc_options</classname>. </para></purpose></template-type-parameter>
    </template><description><para>A map is a kind of associative container that supports unique keys (contains at most one of each key value) and provides for fast retrieval of values of another type T based on the keys. The map class supports bidirectional iterators.</para><para>A map satisfies all of the requirements of a container and of a reversible container and of an associative container. The <computeroutput>value_type</computeroutput> stored by this container is the value_type is std::pair&lt;const Key, T&gt;.</para><para>
</para></description><typedef name="key_type"><type>Key</type></typedef>
<typedef name="allocator_traits_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;</type></typedef>
<typedef name="mapped_type"><type>T</type></typedef>
<typedef name="value_type"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::value_type</type></typedef>
<typedef name="pointer"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::pointer</type></typedef>
<typedef name="const_pointer"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_pointer</type></typedef>
<typedef name="reference"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::reference</type></typedef>
<typedef name="const_reference"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_reference</type></typedef>
<typedef name="size_type"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::size_type</type></typedef>
<typedef name="difference_type"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::difference_type</type></typedef>
<typedef name="allocator_type"><type>Allocator</type></typedef>
<typedef name="stored_allocator_type"><type>implementation_defined</type></typedef>
<typedef name="value_compare"><type>implementation_defined</type></typedef>
<typedef name="key_compare"><type>Compare</type></typedef>
<typedef name="iterator"><type>implementation_defined</type></typedef>
<typedef name="const_iterator"><type>implementation_defined</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="nonconst_value_type"><type>std::pair&lt; key_type, mapped_type &gt;</type></typedef>
<typedef name="movable_value_type"><type>implementation_defined</type></typedef>
<typedef name="node_type"><type>implementation_defined</type></typedef>
<typedef name="insert_return_type"><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="BOOST_STATIC_ASSERT"><type/><parameter name=""><paramtype>(dtl::is_same&lt; typename allocator_type::value_type, std::pair&lt; const Key, T &gt; &gt;::value)</paramtype></parameter></method>
<method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator" cv="noexcept"><type>stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="const noexcept"><type>const stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="begin" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="empty" cv="const noexcept"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="operator[]"><type>mapped_type &amp;</type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If there is no key equivalent to x in the map, inserts value_type(x, T()) into the map.</para><para><emphasis role="bold">Returns</emphasis>: A reference to the mapped_type corresponding to x in *this.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="operator[]"><type>mapped_type &amp;</type><parameter name="k"><paramtype>key_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If there is no key equivalent to x in the map, inserts value_type(boost::move(x), T()) into the map (the key is move-constructed)</para><para><emphasis role="bold">Returns</emphasis>: A reference to the mapped_type corresponding to x in *this.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert_or_assign"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="M"/>
        </template><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="obj"><paramtype>M &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If a key equivalent to k already exists in the container, assigns forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert, constructing it from value_type(k, forward&lt;M&gt;(obj)).</para><para>No iterators or references are invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.</para><para><emphasis role="bold">Returns</emphasis>: The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in the size of the container. </para></description></method>
<method name="insert_or_assign"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-type-parameter name="M"/>
        </template><parameter name="k"><paramtype>key_type &amp;&amp;</paramtype></parameter><parameter name="obj"><paramtype>M &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If a key equivalent to k already exists in the container, assigns forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert, constructing it from value_type(k, move(obj)).</para><para>No iterators or references are invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.</para><para><emphasis role="bold">Returns</emphasis>: The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in the size of the container. </para></description></method>
<method name="insert_or_assign"><type>iterator</type><template>
          <template-type-parameter name="M"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="obj"><paramtype>M &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If a key equivalent to k already exists in the container, assigns forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert, constructing it from value_type(k, forward&lt;M&gt;(obj)) and the new element to the container as close as possible to the position just before hint.</para><para>No iterators or references are invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.</para><para><emphasis role="bold">Returns</emphasis>: The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in the size of the container in general, but amortized constant if the new element is inserted just before hint. </para></description></method>
<method name="insert_or_assign"><type>iterator</type><template>
          <template-type-parameter name="M"/>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="k"><paramtype>key_type &amp;&amp;</paramtype></parameter><parameter name="obj"><paramtype>M &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If a key equivalent to k already exists in the container, assigns forward&lt;M&gt;(obj) to the mapped_type corresponding to the key k. If the key does not exist, inserts the new value as if by insert, constructing it from value_type(k, move(obj)) and the new element to the container as close as possible to the position just before hint.</para><para>No iterators or references are invalidated. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.</para><para><emphasis role="bold">Returns</emphasis>: The bool component is true if the insertion took place and false if the assignment took place. The iterator component is pointing at the element that was inserted or updated.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in the size of the container in general, but amortized constant if the new element is inserted just before hint. </para></description></method>
<method name="at"><type>T &amp;</type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A reference to the element whose key is equivalent to x. Throws: An exception object of type out_of_range if no such element is present. <emphasis role="bold">Complexity</emphasis>: logarithmic. </para></description></method>
<method name="at" cv="const"><type>const T &amp;</type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A reference to the element whose key is equivalent to x. Throws: An exception object of type out_of_range if no such element is present. <emphasis role="bold">Complexity</emphasis>: logarithmic. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>const nonconst_value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value_type created from the pair if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>nonconst_value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value_type move constructed from the pair if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>movable_value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value_type move constructed from the pair if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a new value from x if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>nonconst_value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a new value from x if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>movable_value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a new value from x if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const nonconst_value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an element move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first, last are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [first,last) if and only if there is no element with key equivalent to the key of that element.</para><para><emphasis role="bold">Complexity</emphasis>: At most N log(size()+N) (N is the distance from first to last) </para></description></method>
<method name="insert"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [il.begin(), il.end()) if and only if there is no element with key equivalent to the key of that element.</para><para><emphasis role="bold">Complexity</emphasis>: At most N log(size()+N) (N is the distance from il.begin() to il.end()) </para></description></method>
<method name="insert"><type>insert_return_type</type><parameter name="nh"><paramtype>node_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: nh is empty or this-&gt;get_allocator() == nh.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: If nh is empty, has no effect. Otherwise, inserts the element owned by nh if and only if there is no element in the container with a key equivalent to nh.key().</para><para><emphasis role="bold">Returns</emphasis>: If nh is empty, insert_return_type.inserted is false, insert_return_type.position is end(), and insert_return_type.node is empty. Otherwise if the insertion took place, insert_return_type.inserted is true, insert_return_type.position points to the inserted element, and insert_return_type.node is empty; if the insertion failed, insert_return_type.inserted is false, insert_return_type.node has the previous value of nh, and insert_return_type.position points to an element with a key equivalent to nh.key().</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="insert"><type>insert_return_type</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="nh"><paramtype>node_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as <computeroutput>insert(node_type &amp;&amp; nh)</computeroutput> but the element is inserted as close as possible to the position just prior to "hint".</para><para><emphasis role="bold">Complexity</emphasis>: logarithmic in general, but amortized constant if the element is inserted right before "hint". </para></description></method>
<method name="emplace"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object x of type T constructed with std::forward&lt;Args&gt;(args)... in the container if and only if there is no element in the container with an equivalent key. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="emplace_hint"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the container if and only if there is no element in the container with an equivalent key. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="try_emplace"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value_type shall be EmplaceConstructible into map from piecewise_construct, forward_as_tuple(k), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Effects</emphasis>: If the map already contains an element whose key is equivalent to k, there is no effect. Otherwise inserts an object of type value_type constructed with piecewise_construct, forward_as_tuple(k), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion took place. The returned iterator points to the map element whose key is equivalent to k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="try_emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value_type shall be EmplaceConstructible into map from piecewise_construct, forward_as_tuple(k), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Effects</emphasis>: If the map already contains an element whose key is equivalent to k, there is no effect. Otherwise inserts an object of type value_type constructed with piecewise_construct, forward_as_tuple(k), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Returns</emphasis>: The returned iterator points to the map element whose key is equivalent to k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if value is inserted right before p. </para></description></method>
<method name="try_emplace"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="k"><paramtype>key_type &amp;&amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value_type shall be EmplaceConstructible into map from piecewise_construct, forward_as_tuple(move(k)), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Effects</emphasis>: If the map already contains an element whose key is equivalent to k, there is no effect. Otherwise inserts an object of type value_type constructed with piecewise_construct, forward_as_tuple(move(k)), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion took place. The returned iterator points to the map element whose key is equivalent to k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="try_emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="k"><paramtype>key_type &amp;&amp;</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: value_type shall be EmplaceConstructible into map from piecewise_construct, forward_as_tuple(move(k)), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Effects</emphasis>: If the map already contains an element whose key is equivalent to k, there is no effect. Otherwise inserts an object of type value_type constructed with piecewise_construct, forward_as_tuple(move(k)), forward_as_tuple(forward&lt;Args&gt;(args)...).</para><para><emphasis role="bold">Returns</emphasis>: The returned iterator points to the map element whose key is equivalent to k.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if value is inserted right before p. </para></description></method>
<method name="erase" cv="noexcept"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by p.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time </para></description></method>
<method name="erase" cv="noexcept"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: log(size()) + count(k) </para></description></method>
<method name="erase" cv="noexcept"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+N where N is the distance from first to last. </para></description></method>
<method name="extract"><type>node_type</type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes the first element in the container with key equivalent to k.</para><para><emphasis role="bold">Returns</emphasis>: A node_type owning the element if found, otherwise an empty node_type.</para><para><emphasis role="bold">Complexity</emphasis>: log(a.size()). </para></description></method>
<method name="extract"><type>node_type</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes the element pointed to by "position".</para><para><emphasis role="bold">Returns</emphasis>: A node_type owning the element, otherwise an empty node_type.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>map</classname>&lt; Key, T, C2, Allocator, Options &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>map</classname>&lt; Key, T, C2, Allocator, Options &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>multimap</classname>&lt; Key, T, C2, Allocator, Options &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>multimap</classname>&lt; Key, T, C2, Allocator, Options &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="swap" cv="noexcept(allocator_traits_type::is_always_equal::value &amp;&amp;boost::container::dtl::is_nothrow_swappable&lt; Compare &gt;::value))"><type>void</type><parameter name="x"><paramtype><classname>map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. <emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="find"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="rebalance"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree. It's a no-op for Red-Black and AVL trees.</para><para><emphasis role="bold">Complexity</emphasis>: Linear </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; Allocator &gt;::value &amp;&amp;dtl::is_nothrow_default_constructible&lt; Compare &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Default constructs an empty map.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map and inserts elements from the ordered unique range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object and inserts elements from the ordered unique range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object and allocator, and inserts elements from the ordered unique range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted according to the predicate and otherwise N logN, where N is il.first() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is il.first() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is il.first() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object and allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is il.first() - il.end(). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object, and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object and allocator, and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a map.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor cv="noexcept(boost::container::dtl::is_nothrow_move_constructible&lt; Compare &gt;::value))"><parameter name="x"><paramtype><classname>map</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a map. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a map using the specified allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>map</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a map using the specified allocator. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant if x == x.get_allocator(), linear otherwise.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor>
<copy-assignment><type><classname>map</classname> &amp;</type><parameter name="x"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment>
<copy-assignment cv="noexcept((allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value)&amp;&amp;boost::container::dtl::is_nothrow_move_assignable&lt; Compare &gt;::value))"><type><classname>map</classname> &amp;</type><parameter name="x"><paramtype><classname>map</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: this-&gt;swap(x.get()).</para><para><emphasis role="bold">Throws</emphasis>: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type's move constructor throws)</para><para><emphasis role="bold">Complexity</emphasis>: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this-&gt;get&gt;allocator() == x.get_allocator(). Linear otherwise. </para></description></copy-assignment>
<copy-assignment><type><classname>map</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assign content of il to *this. </para></description></copy-assignment>
<method-group name="friend functions">
<method name="operator=="><type>friend bool</type><parameter name="x"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are equal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator!="><type>friend bool</type><parameter name="x"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are unequal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="swap"><type>friend void</type><parameter name="x"><paramtype><classname>map</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>map</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y)</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
</method-group>
</class><class name="multimap"><template>
      <template-type-parameter name="Key"><purpose><para>is the key_type of the map </para></purpose></template-type-parameter>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default><purpose><para>is the ordering function for Keys (e.g. <emphasis>std::less&lt;Key&gt;</emphasis>). </para></purpose></template-type-parameter>
      <template-type-parameter name="Allocator"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt; std::pair&lt; const Key, T&gt; &gt;</default><purpose><para>is the allocator to allocate the <computeroutput>value_type</computeroutput>s (e.g. <emphasis>allocator&lt; std::pair&lt;const Key, T&gt; &gt; </emphasis>). </para></purpose></template-type-parameter>
      <template-type-parameter name="Options"><default>tree_assoc_defaults</default><purpose><para>is an packed option type generated using using <classname alt="boost::container::tree_assoc_options">boost::container::tree_assoc_options</classname>. </para></purpose></template-type-parameter>
    </template><description><para>A multimap is a kind of associative container that supports equivalent keys (possibly containing multiple copies of the same key value) and provides for fast retrieval of values of another type T based on the keys. The multimap class supports bidirectional iterators.</para><para>A multimap satisfies all of the requirements of a container and of a reversible container and of an associative container. The <computeroutput>value_type</computeroutput> stored by this container is the value_type is std::pair&lt;const Key, T&gt;.</para><para>
</para></description><typedef name="key_type"><type>Key</type></typedef>
<typedef name="mapped_type"><type>T</type></typedef>
<typedef name="value_type"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::value_type</type></typedef>
<typedef name="pointer"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::pointer</type></typedef>
<typedef name="const_pointer"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_pointer</type></typedef>
<typedef name="reference"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::reference</type></typedef>
<typedef name="const_reference"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_reference</type></typedef>
<typedef name="size_type"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::size_type</type></typedef>
<typedef name="difference_type"><type><classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::difference_type</type></typedef>
<typedef name="allocator_type"><type>Allocator</type></typedef>
<typedef name="stored_allocator_type"><type>implementation_defined</type></typedef>
<typedef name="value_compare"><type>implementation_defined</type></typedef>
<typedef name="key_compare"><type>Compare</type></typedef>
<typedef name="iterator"><type>implementation_defined</type></typedef>
<typedef name="const_iterator"><type>implementation_defined</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="nonconst_value_type"><type>std::pair&lt; key_type, mapped_type &gt;</type></typedef>
<typedef name="movable_value_type"><type>implementation_defined</type></typedef>
<typedef name="node_type"><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="BOOST_STATIC_ASSERT"><type/><parameter name=""><paramtype>(dtl::is_same&lt; typename allocator_type::value_type, std::pair&lt; const Key, T &gt; &gt;::value)</paramtype></parameter></method>
<method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator"><type>stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="emplace_hint"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="x"><paramtype>const nonconst_value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value constructed from x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="x"><paramtype>nonconst_value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value move-constructed from x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="x"><paramtype>movable_value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value move-constructed from x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const nonconst_value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>nonconst_value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>movable_value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first, last are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [first,last) .</para><para><emphasis role="bold">Complexity</emphasis>: At most N log(size()+N) (N is the distance from first to last) </para></description></method>
<method name="insert"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [il.begin(), il.end().</para><para><emphasis role="bold">Complexity</emphasis>: At most N log(size()+N) (N is the distance from il.begin() to il.end()) </para></description></method>
<method name="insert"><type>iterator</type><parameter name="nh"><paramtype>node_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: nh is empty or this-&gt;get_allocator() == nh.get_allocator().</para><para><emphasis role="bold">Effects/Returns</emphasis>: If nh is empty, has no effect and returns end(). Otherwise, inserts the element owned by nh and returns an iterator pointing to the newly inserted element. If a range containing elements with keys equivalent to nh.key() exists, the element is inserted at the end of that range. nh is always emptied.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="nh"><paramtype>node_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as <computeroutput>insert(node_type &amp;&amp; nh)</computeroutput> but the element is inserted as close as possible to the position just prior to "hint".</para><para><emphasis role="bold">Complexity</emphasis>: logarithmic in general, but amortized constant if the element is inserted right before "hint". </para></description></method>
<method name="erase"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by p.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time </para></description></method>
<method name="erase"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: log(size()) + count(k) </para></description></method>
<method name="erase"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+N where N is the distance from first to last. </para></description></method>
<method name="extract"><type>node_type</type><parameter name="k"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes the first element in the container with key equivalent to k.</para><para><emphasis role="bold">Returns</emphasis>: A node_type owning the element if found, otherwise an empty node_type.</para><para><emphasis role="bold">Complexity</emphasis>: log(a.size()). </para></description></method>
<method name="extract"><type>node_type</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes the element pointed to by "position".</para><para><emphasis role="bold">Returns</emphasis>: A node_type owning the element, otherwise an empty node_type.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>multimap</classname>&lt; Key, T, C2, Allocator, Options &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>multimap</classname>&lt; Key, T, C2, Allocator, Options &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>map</classname>&lt; Key, T, C2, Allocator, Options &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>map</classname>&lt; Key, T, C2, Allocator, Options &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="swap" cv="noexcept(allocator_traits_type::is_always_equal::value &amp;&amp;boost::container::dtl::is_nothrow_swappable&lt; Compare &gt;::value))"><type>void</type><parameter name="x"><paramtype><classname>multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="clear" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="find"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="rebalance"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree. It's a no-op for Red-Black and AVL trees.</para><para><emphasis role="bold">Complexity</emphasis>: Linear </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; Allocator &gt;::value &amp;&amp;dtl::is_nothrow_default_constructible&lt; Compare &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Default constructs an empty multimap.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap using the specified allocator object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap using the specified comparison.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap using the specified comparison and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap using the specified allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap using the specified comparison object and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap and inserts elements from the ordered range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap using the specified comparison object and inserts elements from the ordered range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap using the specified comparison object and allocator, and inserts elements from the ordered range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap and and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is il.first() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap using the specified allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is il.first() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap using the specified comparison object and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is il.first() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multimap using the specified comparison object and allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is il.first() - il.end(). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map and inserts elements from the ordered range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map using the specified comparison object and inserts elements from the ordered range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty map and inserts elements from the ordered range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a multimap.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor cv="noexcept(boost::container::dtl::is_nothrow_move_constructible&lt; Compare &gt;::value))"><parameter name="x"><paramtype><classname>multimap</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a multimap. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a multimap.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>multimap</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a multimap using the specified allocator. Constructs *this using x's resources. <emphasis role="bold">Complexity</emphasis>: Constant if a == x.get_allocator(), linear otherwise.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor>
<copy-assignment><type><classname>multimap</classname> &amp;</type><parameter name="x"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment>
<copy-assignment cv="noexcept((allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value)&amp;&amp;boost::container::dtl::is_nothrow_move_assignable&lt; Compare &gt;::value))"><type><classname>multimap</classname> &amp;</type><parameter name="x"><paramtype><classname>multimap</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: this-&gt;swap(x.get()).</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></copy-assignment>
<copy-assignment><type><classname>multimap</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assign content of il to *this. </para></description></copy-assignment>
<method-group name="friend functions">
<method name="operator=="><type>friend bool</type><parameter name="x"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are equal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator!="><type>friend bool</type><parameter name="x"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are unequal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="swap"><type>friend void</type><parameter name="x"><paramtype><classname>multimap</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>multimap</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y)</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
</method-group>
</class>

























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/map.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<struct name="map_of"><template>
      <template-type-parameter name="Key"/>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default></template-type-parameter>
      <template-type-parameter name="Options"><default>void</default></template-type-parameter>
    </template><description><para>A portable metafunction to obtain a map that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::map</classname>&lt; Key, T, Compare, <classname>polymorphic_allocator</classname>&lt; std::pair&lt; const Key, T &gt; &gt;, Options &gt;</type></typedef>
</struct><struct name="multimap_of"><template>
      <template-type-parameter name="Key"/>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default></template-type-parameter>
      <template-type-parameter name="Options"><default>void</default></template-type-parameter>
    </template><description><para>A portable metafunction to obtain a multimap that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::multimap</classname>&lt; Key, T, Compare, <classname>polymorphic_allocator</classname>&lt; std::pair&lt; const Key, T &gt; &gt;, Options &gt;</type></typedef>
</struct><typedef name="map"><type><classname>boost::container::map</classname>&lt; Key, T, Compare, <classname>polymorphic_allocator</classname>&lt; std::pair&lt; const Key, T &gt; &gt;, Options &gt;</type></typedef>
<typedef name="multimap"><type><classname>boost::container::multimap</classname>&lt; Key, T, Compare, <classname>polymorphic_allocator</classname>&lt; std::pair&lt; const Key, T &gt; &gt;, Options &gt;</type></typedef>






</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/new_allocator.hpp">
<namespace name="boost">
<namespace name="container">
<class-specialization name="new_allocator"><template>
    </template><specialization><template-arg>void</template-arg></specialization><purpose>Specialization of <classname alt="boost::container::new_allocator">new_allocator</classname> for void types. </purpose><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains an <classname alt="boost::container::new_allocator">new_allocator</classname> that allocates objects of type T2 </para></description><typedef name="other"><type><classname>new_allocator</classname>&lt; T2 &gt;</type></typedef>
</struct><typedef name="value_type"><type>void</type></typedef>
<typedef name="pointer"><type>void *</type></typedef>
<typedef name="const_pointer"><type>const void *</type></typedef>
<typedef name="propagate_on_container_move_assignment"><purpose>A integral constant of type bool with value true. </purpose><type>implementation_defined</type></typedef>
<typedef name="is_always_equal"><purpose>A integral constant of type bool with value true. </purpose><type>implementation_defined</type></typedef>
<method-group name="public member functions">
</method-group>
<constructor cv="noexcept"><description><para>Default constructor Never throws </para></description></constructor>
<constructor cv="noexcept"><parameter name=""><paramtype>const <classname>new_allocator</classname> &amp;</paramtype></parameter><description><para>Constructor from other <classname alt="boost::container::new_allocator">new_allocator</classname>. Never throws </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name=""><paramtype>const <classname>new_allocator</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para>Constructor from related <classname alt="boost::container::new_allocator">new_allocator</classname>. Never throws </para></description></constructor>
<method-group name="friend functions">
<method name="swap" cv="noexcept"><type>friend void</type><parameter name=""><paramtype><classname>new_allocator</classname> &amp;</paramtype></parameter><parameter name=""><paramtype><classname>new_allocator</classname> &amp;</paramtype></parameter><description><para>Swaps two allocators, does nothing because this <classname alt="boost::container::new_allocator">new_allocator</classname> is stateless </para></description></method>
<method name="operator==" cv="noexcept"><type>friend bool</type><parameter name=""><paramtype>const <classname>new_allocator</classname> &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>new_allocator</classname> &amp;</paramtype></parameter><description><para>An <classname alt="boost::container::new_allocator">new_allocator</classname> always compares to true, as memory allocated with one instance can be deallocated by another instance </para></description></method>
<method name="operator!=" cv="noexcept"><type>friend bool</type><parameter name=""><paramtype>const <classname>new_allocator</classname> &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>new_allocator</classname> &amp;</paramtype></parameter><description><para>An <classname alt="boost::container::new_allocator">new_allocator</classname> always compares to false, as memory allocated with one instance can be deallocated by another instance </para></description></method>
</method-group>
</class-specialization><class name="new_allocator"><template>
      <template-type-parameter name="T"/>
    </template><purpose>This class is a reduced STL-compatible allocator that allocates memory using operator new. </purpose><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains an <classname alt="boost::container::new_allocator">new_allocator</classname> that allocates objects of type T2 </para></description><typedef name="other"><type><classname>new_allocator</classname>&lt; T2 &gt;</type></typedef>
</struct><typedef name="value_type"><type>T</type></typedef>
<typedef name="pointer"><type>T *</type></typedef>
<typedef name="const_pointer"><type>const T *</type></typedef>
<typedef name="reference"><type>T &amp;</type></typedef>
<typedef name="const_reference"><type>const T &amp;</type></typedef>
<typedef name="size_type"><type>std::size_t</type></typedef>
<typedef name="difference_type"><type>std::ptrdiff_t</type></typedef>
<typedef name="propagate_on_container_move_assignment"><purpose>A integral constant of type bool with value true. </purpose><type>implementation_defined</type></typedef>
<typedef name="is_always_equal"><purpose>A integral constant of type bool with value true. </purpose><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Allocates memory for an array of count elements. Throws std::bad_alloc if there is no enough memory </para></description></method>
<method name="deallocate" cv="noexcept"><type>void</type><parameter name="ptr"><paramtype>pointer</paramtype></parameter><parameter name=""><paramtype>size_type</paramtype></parameter><description><para>Deallocates previously allocated memory. Never throws </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para>Returns the maximum number of elements that could be allocated. Never throws </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para>Default constructor Never throws </para></description></constructor>
<constructor cv="noexcept"><parameter name=""><paramtype>const <classname>new_allocator</classname> &amp;</paramtype></parameter><description><para>Constructor from other <classname alt="boost::container::new_allocator">new_allocator</classname>. Never throws </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name=""><paramtype>const <classname>new_allocator</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para>Constructor from related <classname alt="boost::container::new_allocator">new_allocator</classname>. Never throws </para></description></constructor>
<method-group name="friend functions">
<method name="swap" cv="noexcept"><type>friend void</type><parameter name=""><paramtype><classname>new_allocator</classname> &amp;</paramtype></parameter><parameter name=""><paramtype><classname>new_allocator</classname> &amp;</paramtype></parameter><description><para>Swaps two allocators, does nothing because this <classname alt="boost::container::new_allocator">new_allocator</classname> is stateless </para></description></method>
<method name="operator==" cv="noexcept"><type>friend bool</type><parameter name=""><paramtype>const <classname>new_allocator</classname> &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>new_allocator</classname> &amp;</paramtype></parameter><description><para>An <classname alt="boost::container::new_allocator">new_allocator</classname> always compares to true, as memory allocated with one instance can be deallocated by another instance </para></description></method>
<method name="operator!=" cv="noexcept"><type>friend bool</type><parameter name=""><paramtype>const <classname>new_allocator</classname> &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>new_allocator</classname> &amp;</paramtype></parameter><description><para>An <classname alt="boost::container::new_allocator">new_allocator</classname> always compares to false, as memory allocated with one instance can be deallocated by another instance </para></description></method>
</method-group>
</class>

























































</namespace>
</namespace>
</header>
<header name="boost/container/node_allocator.hpp">
<namespace name="boost">
<namespace name="container">
<class name="node_allocator"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="NodesPerBlock"><type>std::size_t</type><default>NodeAlloc_nodes_per_block</default></template-nontype-parameter>
    </template><description><para>An STL node allocator that uses a modified DlMalloc as memory source.</para><para>This node allocator shares a segregated storage between all instances of <classname alt="boost::container::node_allocator">node_allocator</classname> with equal sizeof(T).</para><para>NodesPerBlock is the number of nodes allocated at once when the allocator runs out of nodes </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains <classname alt="boost::container::node_allocator">node_allocator</classname> from <classname alt="boost::container::node_allocator">node_allocator</classname> </para></description><typedef name="other"><type><classname>node_allocator</classname>&lt; T2, NodesPerBlock &gt;</type></typedef>
</struct><typedef name="value_type"><type>T</type></typedef>
<typedef name="pointer"><type>T *</type></typedef>
<typedef name="const_pointer"><type>const T *</type></typedef>
<typedef name="reference"><type>::boost::container::dtl::unvoid_ref&lt; T &gt;::type</type></typedef>
<typedef name="const_reference"><type>::boost::container::dtl::unvoid_ref&lt; const T &gt;::type</type></typedef>
<typedef name="size_type"><type>std::size_t</type></typedef>
<typedef name="difference_type"><type>std::ptrdiff_t</type></typedef>
<typedef name="version"><type>boost::container::dtl::version_type&lt; self_t, Version &gt;</type></typedef>
<method-group name="public member functions">
<method name="max_size" cv="const"><type>size_type</type><description><para>Returns the number of elements that could be allocated. Never throws </para></description></method>
<method name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype>const void *</paramtype><default>0</default></parameter><description><para>Allocate memory for an array of count elements. Throws std::bad_alloc if there is no enough memory </para></description></method>
<method name="deallocate" cv="noexcept"><type>void</type><parameter name="ptr"><paramtype>const pointer &amp;</paramtype></parameter><parameter name="count"><paramtype>size_type</paramtype></parameter><description><para>Deallocate allocated memory. Never throws </para></description></method>
<method name="allocation_command"><type>pointer</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>size_type</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
<method name="size" cv="const noexcept"><type>size_type</type><parameter name="p"><paramtype>pointer</paramtype></parameter><description><para>Returns maximum the number of objects the previously allocated memory pointed by p can hold. </para></description></method>
<method name="allocate_one"><type>pointer</type><description><para>Allocates just one object. Memory allocated with this function must be deallocated only with deallocate_one(). Throws bad_alloc if there is no enough memory </para></description></method>
<method name="allocate_individual"><type>void</type><parameter name="num_elements"><paramtype>std::size_t</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size == 1. Elements must be individually deallocated with deallocate_one() </para></description></method>
<method name="deallocate_one" cv="noexcept"><type>void</type><parameter name="p"><paramtype>pointer</paramtype></parameter><description><para>Deallocates memory previously allocated with allocate_one(). You should never use deallocate_one to deallocate memory allocated with other functions different from allocate_one(). Never throws </para></description></method>
<method name="deallocate_individual" cv="noexcept"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter></method>
<method name="allocate_many"><type>void</type><parameter name="elem_size"><paramtype>size_type</paramtype></parameter><parameter name="n_elements"><paramtype>std::size_t</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates many elements of size elem_size. Elements must be individually deallocated with deallocate() </para></description></method>
<method name="allocate_many"><type>void</type><parameter name="elem_sizes"><paramtype>const size_type *</paramtype></parameter><parameter name="n_elements"><paramtype>size_type</paramtype></parameter><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter><description><para>Allocates n_elements elements, each one of size elem_sizes[i] Elements must be individually deallocated with deallocate() </para></description></method>
<method name="deallocate_many" cv="noexcept"><type>void</type><parameter name="chain"><paramtype>multiallocation_chain &amp;</paramtype></parameter></method>
</method-group>
<constructor cv="noexcept"><purpose>Default constructor. </purpose></constructor>
<constructor cv="noexcept"><parameter name=""><paramtype>const <classname>node_allocator</classname> &amp;</paramtype></parameter><purpose>Copy constructor from other <classname alt="boost::container::node_allocator">node_allocator</classname>. </purpose></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="T2"/>
        </template><parameter name=""><paramtype>const <classname>node_allocator</classname>&lt; T2, NodesPerBlock &gt; &amp;</paramtype></parameter><purpose>Copy constructor from related <classname alt="boost::container::node_allocator">node_allocator</classname>. </purpose></constructor>
<destructor><purpose>Destructor. </purpose></destructor>
<method-group name="public static functions">
<method name="deallocate_free_blocks" cv="noexcept" specifiers="static"><type>void</type><purpose>Deallocates all free blocks of the pool. </purpose></method>
</method-group>
<method-group name="friend functions">
<method name="swap" cv="noexcept"><type>friend void</type><parameter name=""><paramtype>self_t &amp;</paramtype></parameter><parameter name=""><paramtype>self_t &amp;</paramtype></parameter><description><para>Swaps allocators. Does not throw. If each allocator is placed in a different memory segment, the result is undefined. </para></description></method>
<method name="operator==" cv="noexcept"><type>friend bool</type><parameter name=""><paramtype>const <classname>node_allocator</classname> &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>node_allocator</classname> &amp;</paramtype></parameter><description><para>An allocator always compares to true, as memory allocated with one instance can be deallocated by another instance </para></description></method>
<method name="operator!=" cv="noexcept"><type>friend bool</type><parameter name=""><paramtype>const <classname>node_allocator</classname> &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>node_allocator</classname> &amp;</paramtype></parameter><description><para>An allocator always compares to false, as memory allocated with one instance can be deallocated by another instance </para></description></method>
</method-group>
<method-group name="private member functions">
<method name="priv_allocation_command"><type>pointer</type><parameter name="command"><paramtype>allocation_type</paramtype></parameter><parameter name="limit_size"><paramtype>std::size_t</paramtype></parameter><parameter name="prefer_in_recvd_out_size"><paramtype>size_type &amp;</paramtype></parameter><parameter name="reuse"><paramtype>pointer &amp;</paramtype></parameter></method>
</method-group>
</class>

























































</namespace>
</namespace>
</header>
<header name="boost/container/node_handle.hpp">
<namespace name="boost">
<namespace name="container">
<class name="node_handle"><template>
      <template-type-parameter name="NodeAllocator"/>
      <template-type-parameter name="KeyMapped"><default>void</default></template-type-parameter>
    </template><description><para>A <classname alt="boost::container::node_handle">node_handle</classname> is an object that accepts ownership of a single element from an associative container. It may be used to transfer that ownership to another container with compatible nodes. Containers with compatible nodes have the same node handle type. Elements may be transferred in either direction between container types in the same row:.</para><para>Container types with compatible nodes</para><para>map&lt;K, T, C1, A&gt; &lt;-&gt; map&lt;K, T, C2, A&gt;</para><para>map&lt;K, T, C1, A&gt; &lt;-&gt; multimap&lt;K, T, C2, A&gt;</para><para>set&lt;K, C1, A&gt; &lt;-&gt; set&lt;K, C2, A&gt;</para><para>set&lt;K, C1, A&gt; &lt;-&gt; multiset&lt;K, C2, A&gt;</para><para>If a node handle is not empty, then it contains an allocator that is equal to the allocator of the container when the element was extracted. If a node handle is empty, it contains no allocator. </para></description><typedef name="value_type"><type>priv_value_t</type></typedef>
<typedef name="key_type"><type>keymapped_t::key_type</type></typedef>
<typedef name="mapped_type"><type>keymapped_t::mapped_type</type></typedef>
<typedef name="allocator_type"><type>nator_traits::template portable_rebind_alloc&lt; value_type &gt;::type</type></typedef>
<typedef name="container_node_type"><type>priv_node_t</type></typedef>
<method-group name="friend functions">
<method name="swap" cv="noexcept(BOOST_NOEXCEPT(x.swap(y))))"><type>friend void</type><parameter name="x"><paramtype><classname>node_handle</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>node_handle</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y). </para></description></method>
</method-group>
<method-group name="public member functions">
<method name="value" cv="const noexcept"><type>value_type &amp;</type><description><para><emphasis role="bold">Requires</emphasis>: empty() == false.</para><para><emphasis role="bold">Returns</emphasis>: A reference to the value_type subobject in the container_node_type object pointed to by m_ptr</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="key" cv="const noexcept"><type>key_type &amp;</type><description><para><emphasis role="bold">Requires</emphasis>: empty() == false.</para><para><emphasis role="bold">Returns</emphasis>: A non-const reference to the key_type member of the value_type subobject in the container_node_type object pointed to by m_ptr.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Requires</emphasis>: Modifying the key through the returned reference is permitted. </para></description></method>
<method name="mapped" cv="const noexcept"><type>mapped_type &amp;</type><description><para><emphasis role="bold">Requires</emphasis>: empty() == false.</para><para><emphasis role="bold">Returns</emphasis>: A reference to the mapped_type member of the value_type subobject in the container_node_type object pointed to by m_ptr</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Requires</emphasis>: empty() == false.</para><para><emphasis role="bold">Returns</emphasis>: A copy of the internally hold allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="conversion-operator" cv="const noexcept" specifiers="explicit"><type>bool</type><description><para><emphasis role="bold">Returns</emphasis>: m_ptr != nullptr. </para></description></method>
<method name="empty" cv="const noexcept"><type>bool</type><description><para><emphasis role="bold">Returns</emphasis>: m_ptr == nullptr. </para></description></method>
<method name="swap" cv="noexcept(nator_traits::propagate_on_container_swap::value||nator_traits::is_always_equal::value))"><type>void</type><parameter name="nh"><paramtype><classname>node_handle</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;empty(), or nh.empty(), or nator_traits::propagate_on_container_swap is true, or node_alloc() == nh.node_alloc().</para><para><emphasis role="bold">Effects</emphasis>: Calls swap(m_ptr, nh.m_ptr). If this-&gt;empty(), or nh.empty(), or nator_traits::propagate_on_- container_swap is true calls swap(node_alloc(), nh.node_alloc()). </para></description></method>
<method name="release" cv="noexcept"><type>node_pointer</type><description><para><emphasis role="bold">Effects</emphasis>: If this-&gt;empty() returns nullptr, otherwise returns m_ptr resets m_ptr to nullptr and destroys the internal allocator.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;empty()</para><para><emphasis role="bold">Note</emphasis>: Non-standard extensions </para></description></method>
<method name="get" cv="const noexcept"><type>node_pointer</type><description><para><emphasis role="bold">Effects</emphasis>: Returns m_ptr.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extensions </para></description></method>
<method name="node_alloc" cv="noexcept"><type>nallocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal node allocator.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extensions </para></description></method>
<method name="node_alloc" cv="const noexcept"><type>const nallocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal node allocator.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extensions </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para><emphasis role="bold">Effects</emphasis>: Initializes m_ptr to nullptr.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;empty() </para></description></constructor>
<constructor cv="noexcept"><parameter name="p"><paramtype>node_pointer</paramtype></parameter><parameter name="al"><paramtype>const nallocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::node_handle">node_handle</classname> object initializing internal pointer with p. If p != nullptr copy constructs internal allocator from al. </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="KeyMapped2"/>
        </template><parameter name="nh"><paramtype><classname>node_handle</classname>&lt; NodeAllocator, KeyMapped2 &gt; &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>typename dtl::enable_if_c&lt; ((unsigned) dtl::is_same&lt; KeyMapped, void &gt;::value+(unsigned) dtl::is_same&lt; KeyMapped2, void &gt;::value)==1u &gt;::type *</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::node_handle">node_handle</classname> object initializing internal pointer with a related nh's internal pointer and assigns nullptr to the later. If nh's internal pointer was not nullptr, move constructs internal allocator with nh's internal allocator and destroy nh's internal allocator.</para><para><emphasis role="bold">Postcondition</emphasis>: nh.empty()</para><para><emphasis role="bold">Note</emphasis>: Two <classname alt="boost::container::node_handle">node_handle</classname>'s are related if only one of KeyMapped template parameter of a node handle is void. </para></description></constructor>
<constructor cv="noexcept"><parameter name="nh"><paramtype><classname>node_handle</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::node_handle">node_handle</classname> object initializing internal pointer with nh's internal pointer and assigns nullptr to the later. If nh's internal pointer was not nullptr, move constructs internal allocator with nh's internal allocator and destroy nh's internal allocator.</para><para><emphasis role="bold">Postcondition</emphasis>: nh.empty() </para></description></constructor>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: If !this-&gt;empty(), destroys the value_type subobject in the container_node_type object pointed to by c by calling allocator_traits&lt;impl_defined&gt;::destroy, then deallocates m_ptr by calling nator_traits::rebind_traits&lt;container_node_type&gt;::deallocate. </para></description></destructor>
<copy-assignment cv="noexcept"><type><classname>node_handle</classname> &amp;</type><parameter name="nh"><paramtype><classname>node_handle</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Either this-&gt;empty(), or nator_traits::propagate_on_container_move_assignment is true, or node_alloc() == nh.node_alloc().</para><para><emphasis role="bold">Effects</emphasis>: If m_ptr != nullptr, destroys the value_type subobject in the container_node_type object pointed to by m_ptr by calling nator_traits::destroy, then deallocates m_ptr by calling nator_traits::deallocate. Assigns nh.m_ptr to m_ptr. If this-&gt;empty() or nator_traits::propagate_on_container_move_assignment is true, move assigns nh.node_alloc() to node_alloc(). Assigns nullptr to nh.m_ptr and assigns nullopt to nh.node_alloc().</para><para><emphasis role="bold">Returns</emphasis>: *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></copy-assignment>
</class><struct name="insert_return_type_base"><template>
      <template-type-parameter name="Iterator"/>
      <template-type-parameter name="NodeType"/>
    </template><description><para>A class template used to describe the results of inserting a Container::node_type in a Container with unique keys. Includes at least the following non-static public data members:</para><para><itemizedlist>
<listitem>
<para>bool inserted; </para></listitem>
<listitem>
<para>Iterator position; </para></listitem>
<listitem>
<para>NodeType node</para></listitem>
</itemizedlist>
</para><para>This type is MoveConstructible, MoveAssignable, DefaultConstructible, Destructible, and lvalues of that type are swappable </para></description><data-member name="inserted"><type>bool</type></data-member>
<data-member name="position"><type>Iterator</type></data-member>
<data-member name="node"><type>NodeType</type></data-member>
<method-group name="public member functions">
</method-group>
<constructor/>
<constructor><parameter name="other"><paramtype><classname>insert_return_type_base</classname> &amp;&amp;</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="RelatedIt"/>
          <template-type-parameter name="RelatedNode"/>
        </template><parameter name="insert"><paramtype>bool</paramtype></parameter><parameter name="it"><paramtype>RelatedIt</paramtype></parameter><parameter name="node"><paramtype>RelatedNode &amp;&amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>insert_return_type_base</classname> &amp;</type><parameter name="other"><paramtype><classname>insert_return_type_base</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
</struct>

























































</namespace>
</namespace>
</header>
<header name="boost/container/options.hpp">
<namespace name="boost">
<namespace name="container">
<struct name="tree_type"><template>
      <template-nontype-parameter name="TreeType"><type>tree_type_enum</type></template-nontype-parameter>
    </template><purpose>defined(BOOST_CONTAINER_DOXYGEN_INVOKED) </purpose><description><para>This option setter specifies the underlying tree type (red-black, AVL, Scapegoat or Splay) for ordered associative containers </para></description></struct><struct name="optimize_size"><template>
      <template-nontype-parameter name="Enabled"><type>bool</type></template-nontype-parameter>
    </template><description><para>This option setter specifies if node size is optimized storing rebalancing data masked into pointers for ordered associative containers </para></description></struct><struct name="tree_assoc_options"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to combine options into a single type to be used by <computeroutput><classname alt="boost::container::set">boost::container::set</classname></computeroutput>, <computeroutput><classname alt="boost::container::multiset">boost::container::multiset</classname></computeroutput> <computeroutput><classname alt="boost::container::map">boost::container::map</classname></computeroutput> and <computeroutput><classname alt="boost::container::multimap">boost::container::multimap</classname></computeroutput>. Supported options are: <computeroutput><classname alt="boost::container::optimize_size">boost::container::optimize_size</classname></computeroutput> and <computeroutput><classname alt="boost::container::tree_type">boost::container::tree_type</classname></computeroutput> </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><struct name="growth_factor_50"><purpose>defined(BOOST_CONTAINER_DOXYGEN_INVOKED) </purpose><description><para>This growth factor argument specifies that the container should increase it's capacity a 50% when existing capacity is exhausted. </para></description></struct><struct name="growth_factor_60"><description><para>This growth factor argument specifies that the container should increase it's capacity a 60% when existing capacity is exhausted. </para></description></struct><struct name="growth_factor_100"><description><para>This growth factor argument specifies that the container should increase it's capacity a 100% (doubling its capacity) when existing capacity is exhausted. </para></description></struct><struct name="growth_factor"><template>
      <template-type-parameter name="GrowthFactor"><purpose><para>A function object that has the following signature:<sbr/>
<sbr/>
 <computeroutput>template&lt;class SizeType&gt;</computeroutput><sbr/>
 <computeroutput>SizeType operator()(SizeType cur_cap, SizeType add_min_cap, SizeType max_cap) const;</computeroutput>.<sbr/>
<sbr/>
 <computeroutput>cur_cap</computeroutput> is the current capacity, <computeroutput>add_min_cap</computeroutput> is the minimum additional capacity we want to achieve and <computeroutput>max_cap</computeroutput> is the maximum capacity that the allocator or other factors allow. The implementation should return a value between <computeroutput>cur_cap</computeroutput> + <computeroutput>add_min_cap</computeroutput> and <computeroutput>max_cap</computeroutput>. <computeroutput>cur_cap</computeroutput> + <computeroutput>add_min_cap</computeroutput> is guaranteed not to overflow/wraparound, but the implementation should handle wraparound produced by the growth factor.</para></purpose></template-type-parameter>
    </template><purpose>defined(BOOST_CONTAINER_DOXYGEN_INVOKED) </purpose><description><para>This option setter specifies the growth factor strategy of the underlying vector.</para><para>
Predefined growth factors that can be passed as arguments to this option are: <computeroutput><classname alt="boost::container::growth_factor_50">boost::container::growth_factor_50</classname></computeroutput> <computeroutput><classname alt="boost::container::growth_factor_60">boost::container::growth_factor_60</classname></computeroutput> <computeroutput><classname alt="boost::container::growth_factor_100">boost::container::growth_factor_100</classname></computeroutput> </para><para>If this option is not specified, a default will be used by the container. </para></description></struct><struct name="stored_size"><template>
      <template-type-parameter name="StoredSizeType"><purpose><para>A unsigned integer type. It shall be smaller than than the size of the size_type deduced from <computeroutput><classname alt="boost::container::allocator_traits">allocator_traits</classname>&lt;A&gt;::size_type</computeroutput> or the same type.</para></purpose></template-type-parameter>
    </template><description><para>This option specifies the unsigned integer type that a user wants the container to use to hold size-related information inside a container (e.g. current size, current capacity).</para><para>
If the maximum capacity() to be used is limited, a user can try to use 8-bit, 16-bit (e.g. in 32-bit machines), or 32-bit size types (e.g. in a 64 bit machine) to see if some memory can be saved for empty vectors. This could potentially performance benefits due to better cache usage.</para><para>Note that alignment requirements can disallow theoritical space savings. Example: <computeroutput>vector</computeroutput> holds a pointer and two size types (for size and capacity), in a 32 bit machine a 8 bit size type (total size: 4 byte pointer + 2 x 1 byte sizes = 6 bytes) will not save space when comparing two 16-bit size types because usually a 32 bit alignment is required for vector and the size will be rounded to 8 bytes. In a 64-bit machine a 16 bit size type does not usually save memory when comparing to a 32-bit size type. Measure the size of the resulting container and do not assume a smaller <computeroutput><classname alt="boost::container::stored_size">stored_size</classname></computeroutput> will always lead to a smaller sizeof(container).</para><para>If a user tries to insert more elements than representable by <computeroutput><classname alt="boost::container::stored_size">stored_size</classname></computeroutput>, vector will throw a length_error.</para><para>If this option is not specified, <computeroutput><classname alt="boost::container::allocator_traits">allocator_traits</classname>&lt;A&gt;::size_type</computeroutput> (usually std::size_t) will be used to store size-related information inside the container. </para></description></struct><struct name="vector_options"><template>
      <template-nontype-parameter name="Options"><type>class...</type></template-nontype-parameter>
    </template><description><para>Helper metafunction to combine options into a single type to be used by <computeroutput><classname alt="boost::container::vector">boost::container::vector</classname></computeroutput>. Supported options are: <computeroutput><classname alt="boost::container::growth_factor">boost::container::growth_factor</classname></computeroutput> and <computeroutput><classname alt="boost::container::stored_size">boost::container::stored_size</classname></computeroutput> </para></description><typedef name="type"><type>implementation_defined</type></typedef>
</struct><enum name="tree_type_enum"><enumvalue name="red_black_tree"/><enumvalue name="avl_tree"/><enumvalue name="scapegoat_tree"/><enumvalue name="splay_tree"/><description><para>Enumeration used to configure ordered associative containers with a concrete tree implementation. </para></description></enum>
<typedef name="tree_assoc_options_t"><description><para>Helper alias metafunction to combine options into a single type to be used by tree-based associative containers </para></description><type>typename <classname>boost::container::tree_assoc_options</classname>&lt; Options...&gt;::type</type></typedef>
<typedef name="vector_options_t"><description><para>Helper alias metafunction to combine options into a single type to be used by <computeroutput><classname alt="boost::container::vector">boost::container::vector</classname></computeroutput>. Supported options are: <computeroutput><classname alt="boost::container::growth_factor">boost::container::growth_factor</classname></computeroutput> and <computeroutput><classname alt="boost::container::stored_size">boost::container::stored_size</classname></computeroutput> </para></description><type>typename <classname>boost::container::vector_options</classname>&lt; Options...&gt;::type</type></typedef>


























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/global_resource.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">


<function name="new_delete_resource"><type><classname>memory_resource</classname> *</type><description><para><emphasis role="bold">Returns</emphasis>: A pointer to a static-duration object of a type derived from <classname alt="boost::container::pmr::memory_resource">memory_resource</classname> that can serve as a resource for allocating memory using global <computeroutput>operator new</computeroutput> and global <computeroutput>operator delete</computeroutput>. The same value is returned every time this function is called. For return value p and memory resource r, p-&gt;is_equal(r) returns &amp;r == p. </para></description></function>
<function name="null_memory_resource"><type><classname>memory_resource</classname> *</type><description><para><emphasis role="bold">Returns</emphasis>: A pointer to a static-duration object of a type derived from <classname alt="boost::container::pmr::memory_resource">memory_resource</classname> for which allocate() always throws bad_alloc and for which deallocate() has no effect. The same value is returned every time this function is called. For return value p and memory resource r, p-&gt;is_equal(r) returns &amp;r == p. </para></description></function>
<function name="set_default_resource"><type><classname>memory_resource</classname> *</type><parameter name="r"><paramtype><classname>memory_resource</classname> *</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If r is non-null, sets the value of the default memory resource pointer to r, otherwise sets the default memory resource pointer to new_delete_resource().</para><para><emphasis role="bold">Postconditions</emphasis>: get_default_resource() == r.</para><para><emphasis role="bold">Returns</emphasis>: The previous value of the default memory resource pointer.</para><para><emphasis role="bold">Remarks</emphasis>: Calling the set_default_resource and get_default_resource functions shall not incur a data race. A call to the set_default_resource function shall synchronize with subsequent calls to the set_default_resource and get_default_resource functions. </para></description></function>
<function name="get_default_resource"><type><classname>memory_resource</classname> *</type><description><para><emphasis role="bold">Returns</emphasis>: The current value of the default memory resource pointer. </para></description></function>
</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/memory_resource.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<class name="memory_resource"><description><para>The <classname alt="boost::container::pmr::memory_resource">memory_resource</classname> class is an abstract interface to an unbounded set of classes encapsulating memory resources. </para></description><data-member name="max_align" specifiers="static"><type>constexpr std::size_t</type></data-member>
<method-group name="public member functions">
<method name="allocate"><type>void *</type><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><parameter name="alignment"><paramtype>std::size_t</paramtype><default>max_align</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to <computeroutput>return do_allocate(bytes, alignment);</computeroutput> </para></description></method>
<method name="deallocate"><type>void</type><parameter name="p"><paramtype>void *</paramtype></parameter><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><parameter name="alignment"><paramtype>std::size_t</paramtype><default>max_align</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to <computeroutput>return do_deallocate(bytes, alignment);</computeroutput> </para></description></method>
<method name="is_equal" cv="const noexcept"><type>bool</type><parameter name="other"><paramtype>const <classname>memory_resource</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to <computeroutput>return return do_is_equal(other);</computeroutput> </para></description></method>
</method-group>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Destroys this <classname alt="boost::container::pmr::memory_resource">memory_resource</classname>. </para></description></destructor>
<method-group name="friend functions">
<method name="operator==" cv="noexcept"><type>friend bool</type><parameter name="a"><paramtype>const <classname>memory_resource</classname> &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>memory_resource</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>&amp;a == &amp;b || a.is_equal(b)</computeroutput>. </para></description></method>
<method name="operator!=" cv="noexcept"><type>friend bool</type><parameter name="a"><paramtype>const <classname>memory_resource</classname> &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>memory_resource</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: !(a == b). </para></description></method>
</method-group>
<method-group name="protected member functions">
<method name="do_allocate" cv="= 0" specifiers="virtual"><type>void *</type><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><parameter name="alignment"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Alignment shall be a power of two.</para><para><emphasis role="bold">Returns</emphasis>: A derived class shall implement this function to return a pointer to allocated storage with a size of at least bytes. The returned storage is aligned to the specified alignment, if such alignment is supported; otherwise it is aligned to max_align.</para><para><emphasis role="bold">Throws</emphasis>: A derived class implementation shall throw an appropriate exception if it is unable to allocate memory with the requested size and alignment. </para></description></method>
<method name="do_deallocate" cv="= 0" specifiers="virtual"><type>void</type><parameter name="p"><paramtype>void *</paramtype></parameter><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><parameter name="alignment"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p shall have been returned from a prior call to <computeroutput>allocate(bytes, alignment)</computeroutput> on a memory resource equal to *this, and the storage at p shall not yet have been deallocated.</para><para><emphasis role="bold">Effects</emphasis>: A derived class shall implement this function to dispose of allocated storage.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="do_is_equal" cv="const = 0" specifiers="virtual"><type>bool</type><parameter name="other"><paramtype>const <classname>memory_resource</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A derived class shall implement this function to return true if memory allocated from this can be deallocated from other and vice-versa; otherwise it shall return false. <emphasis>[Note: The most-derived type of other might not match the type of this. For a derived class, D, a typical implementation of this function will compute <computeroutput>dynamic_cast&lt;const D*&gt;(&amp;other)</computeroutput> and go no further (i.e., return false) if it returns nullptr. - end note]</emphasis>. </para></description></method>
</method-group>
</class>





</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/monotonic_buffer_resource.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<class name="monotonic_buffer_resource"><inherit access="public">boost::container::pmr::memory_resource</inherit><description><para>A <classname alt="boost::container::pmr::monotonic_buffer_resource">monotonic_buffer_resource</classname> is a special-purpose memory resource intended for very fast memory allocations in situations where memory is used to build up a few objects and then is released all at once when the memory resource object is destroyed. It has the following qualities:</para><para><itemizedlist>
<listitem><para>A call to deallocate has no effect, thus the amount of memory consumed increases monotonically until the resource is destroyed.</para></listitem><listitem><para>The program can supply an initial buffer, which the allocator uses to satisfy memory requests.</para></listitem><listitem><para>When the initial buffer (if any) is exhausted, it obtains additional buffers from an upstream memory resource supplied at construction. Each additional buffer is larger than the previous one, following a geometric progression.</para></listitem><listitem><para>It is intended for access from one thread of control at a time. Specifically, calls to allocate and deallocate do not synchronize with one another.</para></listitem><listitem><para>It owns the allocated memory and frees it on destruction, even if deallocate has not been called for some of the allocated blocks. </para></listitem></itemizedlist>
</para></description><data-member name="initial_next_buffer_size" specifiers="static"><type>const std::size_t</type><description><para>The number of bytes that will be requested by the default in the first call to the upstream allocator</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></data-member>
<method-group name="public member functions">
<method name="release" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: <computeroutput>upstream_resource()-&gt;deallocate()</computeroutput> as necessary to release all allocated memory. [Note: memory is released back to <computeroutput>upstream_resource()</computeroutput> even if some blocks that were allocated from this have not been deallocated from this. - end note] </para></description></method>
<method name="upstream_resource" cv="const noexcept"><type><classname>memory_resource</classname> *</type><description><para><emphasis role="bold">Returns</emphasis>: The value of the internal resource. </para></description></method>
<method name="remaining_storage" cv="const noexcept"><type>std::size_t</type><parameter name="alignment"><paramtype>std::size_t</paramtype></parameter><parameter name="wasted_due_to_alignment"><paramtype>std::size_t &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of bytes of storage available for the specified alignment and the number of bytes wasted due to the requested alignment.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="remaining_storage" cv="const noexcept"><type>std::size_t</type><parameter name="alignment"><paramtype>std::size_t</paramtype><default>1u</default></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of bytes of storage available for the specified alignment.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="current_buffer" cv="const noexcept"><type>const void *</type><description><para><emphasis role="bold">Returns</emphasis>: The address pointing to the start of the current free storage.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="next_buffer_size" cv="const noexcept"><type>std::size_t</type><description><para><emphasis role="bold">Returns</emphasis>: The number of bytes that will be requested for the next buffer once the current one is exhausted.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
</method-group>
<constructor specifiers="explicit" cv="noexcept"><parameter name="upstream"><paramtype><classname>memory_resource</classname> *</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upstream</computeroutput> shall be the address of a valid memory resource or <computeroutput>nullptr</computeroutput></para><para><emphasis role="bold">Effects</emphasis>: If <computeroutput>upstream</computeroutput> is not nullptr, sets the internal resource to <computeroutput>upstream</computeroutput>, to get_default_resource() otherwise. Sets the internal <computeroutput>current_buffer</computeroutput> to <computeroutput>nullptr</computeroutput> and the internal <computeroutput>next_buffer_size</computeroutput> to an implementation-defined size. </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><parameter name="initial_size"><paramtype>std::size_t</paramtype></parameter><parameter name="upstream"><paramtype><classname>memory_resource</classname> *</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upstream</computeroutput> shall be the address of a valid memory resource or <computeroutput>nullptr</computeroutput> and <computeroutput>initial_size</computeroutput> shall be greater than zero.</para><para><emphasis role="bold">Effects</emphasis>: If <computeroutput>upstream</computeroutput> is not nullptr, sets the internal resource to <computeroutput>upstream</computeroutput>, to get_default_resource() otherwise. Sets the internal <computeroutput>current_buffer</computeroutput> to <computeroutput>nullptr</computeroutput> and <computeroutput>next_buffer_size</computeroutput> to at least <computeroutput>initial_size</computeroutput>. </para></description></constructor>
<constructor cv="noexcept"><parameter name="buffer"><paramtype>void *</paramtype></parameter><parameter name="buffer_size"><paramtype>std::size_t</paramtype></parameter><parameter name="upstream"><paramtype><classname>memory_resource</classname> *</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upstream</computeroutput> shall be the address of a valid memory resource or <computeroutput>nullptr</computeroutput>, <computeroutput>buffer_size</computeroutput> shall be no larger than the number of bytes in buffer.</para><para><emphasis role="bold">Effects</emphasis>: If <computeroutput>upstream</computeroutput> is not nullptr, sets the internal resource to <computeroutput>upstream</computeroutput>, to get_default_resource() otherwise. Sets the internal <computeroutput>current_buffer</computeroutput> to <computeroutput>buffer</computeroutput>, and <computeroutput>next_buffer_size</computeroutput> to <computeroutput>buffer_size</computeroutput> (but not less than an implementation-defined size), then increases <computeroutput>next_buffer_size</computeroutput> by an implementation-defined growth factor (which need not be integral). </para></description></constructor>
<constructor cv="= delete"><parameter name=""><paramtype>const <classname>monotonic_buffer_resource</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= delete"><type><classname>monotonic_buffer_resource</classname></type><parameter name=""><paramtype>const <classname>monotonic_buffer_resource</classname> &amp;</paramtype></parameter></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Calls <computeroutput>this-&gt;release()</computeroutput>. </para></description></destructor>
<method-group name="protected member functions">
<method name="do_allocate" specifiers="virtual"><type>void *</type><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><parameter name="alignment"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A pointer to allocated storage with a size of at least <computeroutput>bytes</computeroutput>. The size and alignment of the allocated memory shall meet the requirements for a class derived from <computeroutput><classname alt="boost::container::pmr::memory_resource">memory_resource</classname></computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: If the unused space in the internal <computeroutput>current_buffer</computeroutput> can fit a block with the specified bytes and alignment, then allocate the return block from the internal <computeroutput>current_buffer</computeroutput>; otherwise sets the internal <computeroutput>current_buffer</computeroutput> to <computeroutput>upstream_resource()-&gt;allocate(n, m)</computeroutput>, where <computeroutput>n</computeroutput> is not less than <computeroutput>max(bytes, next_buffer_size)</computeroutput> and <computeroutput>m</computeroutput> is not less than alignment, and increase <computeroutput>next_buffer_size</computeroutput> by an implementation-defined growth factor (which need not be integral), then allocate the return block from the newly-allocated internal <computeroutput>current_buffer</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless <computeroutput>upstream_resource()-&gt;allocate()</computeroutput> throws. </para></description></method>
<method name="do_deallocate" cv="noexcept" specifiers="virtual"><type>void</type><parameter name="p"><paramtype>void *</paramtype></parameter><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><parameter name="alignment"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: None</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Remarks</emphasis>: Memory used by this resource increases monotonically until its destruction. </para></description></method>
<method name="do_is_equal" cv="const noexcept" specifiers="virtual"><type>bool</type><parameter name="other"><paramtype>const <classname>memory_resource</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>this == dynamic_cast&lt;const monotonic_buffer_resource*&gt;(&amp;other)</computeroutput>. </para></description></method>
</method-group>
</class>





</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/polymorphic_allocator.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<class name="polymorphic_allocator"><template>
      <template-type-parameter name="T"/>
    </template><description><para>A specialization of class template <computeroutput><classname alt="boost::container::pmr::polymorphic_allocator">polymorphic_allocator</classname></computeroutput> conforms to the Allocator requirements. Constructed with different memory resources, different instances of the same specialization of <computeroutput><classname alt="boost::container::pmr::polymorphic_allocator">polymorphic_allocator</classname></computeroutput> can exhibit entirely different allocation behavior. This runtime polymorphism allows objects that use <classname alt="boost::container::pmr::polymorphic_allocator">polymorphic_allocator</classname> to behave as if they used different allocator types at run time even though they use the same static allocator type. </para></description><typedef name="value_type"><type>T</type></typedef>
<method-group name="public member functions">
<method name="allocate"><type>T *</type><parameter name="n"><paramtype>size_t</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: Equivalent to <computeroutput>static_cast&lt;T*&gt;(m_resource-&gt;allocate(n * sizeof(T), alignof(T)))</computeroutput>. </para></description></method>
<method name="deallocate"><type>void</type><parameter name="p"><paramtype>T *</paramtype></parameter><parameter name="n"><paramtype>size_t</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p was allocated from a memory resource, x, equal to *m_resource, using <computeroutput>x.allocate(n * sizeof(T), alignof(T))</computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to m_resource-&gt;deallocate(p, n * sizeof(T), alignof(T)).</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="construct"><type>void</type><template>
          <template-type-parameter name="U"/>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>U *</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: Uses-allocator construction of T with allocator <computeroutput>*this</computeroutput> and constructor arguments <computeroutput>std::forward&lt;Args&gt;(args)...</computeroutput> is well-formed. [Note: uses-allocator construction is always well formed for types that do not use allocators. - end note]</para><para><emphasis role="bold">Effects</emphasis>: Construct a T object at p by uses-allocator construction with allocator <computeroutput>*this</computeroutput> and constructor arguments <computeroutput>std::forward&lt;Args&gt;(args)...</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the constructor for T throws. </para></description></method>
<method name="destroy"><type>void</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="p"><paramtype>U *</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: p-&gt;~U(). </para></description></method>
<method name="select_on_container_copy_construction" cv="const"><type><classname>polymorphic_allocator</classname></type><description><para><emphasis role="bold">Returns</emphasis>: Equivalent to <computeroutput>polymorphic_allocator()</computeroutput>. </para></description></method>
<method name="resource" cv="const"><type><classname>memory_resource</classname> *</type><description><para><emphasis role="bold">Returns</emphasis>: m_resource. </para></description></method>
</method-group>
<constructor cv="noexcept"><description><para><emphasis role="bold">Effects</emphasis>: Sets m_resource to <computeroutput>get_default_resource()</computeroutput>. </para></description></constructor>
<constructor><parameter name="r"><paramtype><classname>memory_resource</classname> *</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: r is non-null.</para><para><emphasis role="bold">Effects</emphasis>: Sets m_resource to r.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Notes</emphasis>: This constructor provides an implicit conversion from memory_resource*. Non-standard extension: if r is null m_resource is set to get_default_resource(). </para></description></constructor>
<constructor><parameter name="other"><paramtype>const <classname>polymorphic_allocator</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Sets m_resource to other.resource(). </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="U"/>
        </template><parameter name="other"><paramtype>const <classname>polymorphic_allocator</classname>&lt; U &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Sets m_resource to other.resource(). </para></description></constructor>
<copy-assignment><type><classname>polymorphic_allocator</classname> &amp;</type><parameter name="other"><paramtype>const <classname>polymorphic_allocator</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Sets m_resource to other.resource(). </para></description></copy-assignment>
</class><function name="operator=="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="T2"/>
        </template><parameter name="a"><paramtype>const <classname>polymorphic_allocator</classname>&lt; T1 &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>polymorphic_allocator</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>*a.resource() == *b.resource()</computeroutput>. </para></description></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="T1"/>
          <template-type-parameter name="T2"/>
        </template><parameter name="a"><paramtype>const <classname>polymorphic_allocator</classname>&lt; T1 &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>polymorphic_allocator</classname>&lt; T2 &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>! (a == b)</computeroutput>. </para></description></function>




</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/pool_options.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<struct name="pool_options"><description><para>The members of <classname alt="boost::container::pmr::pool_options">pool_options</classname> comprise a set of constructor options for pool resources. The effect of each option on the pool resource behavior is described below:</para><para><itemizedlist>
<listitem><para><computeroutput>std::size_t max_blocks_per_chunk</computeroutput>: The maximum number of blocks that will be allocated at once from the upstream memory resource to replenish a pool. If the value of <computeroutput>max_blocks_per_chunk</computeroutput> is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose to use a smaller value than is specified in this field and may use different values for different pools.</para></listitem><listitem><para><computeroutput>std::size_t largest_required_pool_block</computeroutput>: The largest allocation size that is required to be fulfilled using the pooling mechanism. Attempts to allocate a single block larger than this threshold will be allocated directly from the upstream memory resource. If largest_required_pool_block is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose a pass-through threshold larger than specified in this field. </para></listitem></itemizedlist>
</para></description><data-member name="max_blocks_per_chunk"><type>std::size_t</type></data-member>
<data-member name="largest_required_pool_block"><type>std::size_t</type></data-member>
<method-group name="public member functions">
</method-group>
<constructor/>
</struct>





</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/resource_adaptor.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<class name="resource_adaptor_imp"><template>
      <template-type-parameter name="Allocator"/>
    </template><inherit access="public">boost::container::pmr::memory_resource</inherit><description><para>An instance of resource_adaptor&lt;Allocator&gt; is an adaptor that wraps a <classname alt="boost::container::pmr::memory_resource">memory_resource</classname> interface around Allocator. In order that resource_adaptor&lt;X&lt;T&gt;&gt; and resource_adaptor&lt;X&lt;U&gt;&gt; are the same type for any allocator template X and types T and U, resource_adaptor&lt;Allocator&gt; is rendered as an alias to this class template such that Allocator is rebound to a char value type in every specialization of the class template. The requirements on this class template are defined below. In addition to the Allocator requirements, the parameter to resource_adaptor shall meet the following additional requirements:</para><para><itemizedlist>
<listitem><para><computeroutput>typename <classname alt="boost::container::allocator_traits">allocator_traits</classname>&lt;Allocator&gt;:: pointer</computeroutput> shall be identical to <computeroutput>typename <classname alt="boost::container::allocator_traits">allocator_traits</classname>&lt;Allocator&gt;:: value_type*</computeroutput>.</para></listitem><listitem><para><computeroutput>typename <classname alt="boost::container::allocator_traits">allocator_traits</classname>&lt;Allocator&gt;:: const_pointer</computeroutput> shall be identical to <computeroutput>typename <classname alt="boost::container::allocator_traits">allocator_traits</classname>&lt;Allocator&gt;:: value_type const*</computeroutput>.</para></listitem><listitem><para><computeroutput>typename <classname alt="boost::container::allocator_traits">allocator_traits</classname>&lt;Allocator&gt;:: void_pointer</computeroutput> shall be identical to <computeroutput>void*</computeroutput>.</para></listitem><listitem><para><computeroutput>typename <classname alt="boost::container::allocator_traits">allocator_traits</classname>&lt;Allocator&gt;:: const_void_pointer</computeroutput> shall be identical to <computeroutput>void const*</computeroutput>. </para></listitem></itemizedlist>
</para></description><typedef name="allocator_type"><type>Allocator</type></typedef>
<method-group name="public member functions">
<method name="get_allocator"><type>allocator_type &amp;</type><purpose><emphasis role="bold">Effects</emphasis>: Returns m_alloc. </purpose></method>
<method name="get_allocator" cv="const"><type>const allocator_type &amp;</type><purpose><emphasis role="bold">Effects</emphasis>: Returns m_alloc. </purpose></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: Default constructs m_alloc. </para></description></constructor>
<constructor><parameter name="other"><paramtype>const <classname>resource_adaptor_imp</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs m_alloc. </para></description></constructor>
<constructor><parameter name="other"><paramtype><classname>resource_adaptor_imp</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs m_alloc. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="a2"><paramtype>const Allocator &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Initializes m_alloc with a2. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="a2"><paramtype>Allocator &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Initializes m_alloc with a2. </para></description></constructor>
<copy-assignment><type><classname>resource_adaptor_imp</classname> &amp;</type><parameter name="other"><paramtype>const <classname>resource_adaptor_imp</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy assigns m_alloc. </para></description></copy-assignment>
<copy-assignment><type><classname>resource_adaptor_imp</classname> &amp;</type><parameter name="other"><paramtype><classname>resource_adaptor_imp</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move assigns m_alloc. </para></description></copy-assignment>
<method-group name="protected member functions">
<method name="do_allocate" specifiers="virtual"><type>void *</type><parameter name="bytes"><paramtype>size_t</paramtype></parameter><parameter name="alignment"><paramtype>size_t</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: Allocated memory obtained by calling m_alloc.allocate. The size and alignment of the allocated memory shall meet the requirements for a class derived from <classname alt="boost::container::pmr::memory_resource">memory_resource</classname>. </para></description></method>
<method name="do_deallocate" specifiers="virtual"><type>void</type><parameter name="p"><paramtype>void *</paramtype></parameter><parameter name="bytes"><paramtype>size_t</paramtype></parameter><parameter name="alignment"><paramtype>size_t</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p was previously allocated using A.allocate, where A == m_alloc, and not subsequently deallocated.</para><para><emphasis role="bold">Effects</emphasis>: Returns memory to the allocator using m_alloc.deallocate(). </para></description></method>
<method name="do_is_equal" cv="const noexcept" specifiers="virtual"><type>bool</type><parameter name="other"><paramtype>const <classname>memory_resource</classname> &amp;</paramtype></parameter><description><para>Let p be dynamic_cast&lt;const resource_adaptor_imp*&gt;(&amp;other).</para><para><emphasis role="bold">Returns</emphasis>: false if p is null, otherwise the value of m_alloc == p-&gt;m_alloc. </para></description></method>
</method-group>
</class><typedef name="resource_adaptor"><description><para><computeroutput>resource_adaptor&lt;Allocator&gt;</computeroutput> is rendered as an alias to <classname alt="boost::container::pmr::resource_adaptor_imp">resource_adaptor_imp</classname> class template such that Allocator is rebound to a char value type. </para></description><type><classname>resource_adaptor_imp</classname>&lt; typename <classname>allocator_traits</classname>&lt; Allocator &gt;::template rebind_alloc&lt; char &gt; &gt;</type></typedef>






</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/synchronized_pool_resource.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<class name="synchronized_pool_resource"><inherit access="public">boost::container::pmr::memory_resource</inherit><description><para>A <classname alt="boost::container::pmr::synchronized_pool_resource">synchronized_pool_resource</classname> is a general-purpose memory resources having the following qualities:</para><para><itemizedlist>
<listitem><para>Each resource owns the allocated memory, and frees it on destruction, even if deallocate has not been called for some of the allocated blocks.</para></listitem><listitem><para>A pool resource consists of a collection of pools, serving requests for different block sizes. Each individual pool manages a collection of chunks that are in turn divided into blocks of uniform size, returned via calls to do_allocate. Each call to do_allocate(size, alignment) is dispatched to the pool serving the smallest blocks accommodating at least size bytes.</para></listitem><listitem><para>When a particular pool is exhausted, allocating a block from that pool results in the allocation of an additional chunk of memory from the upstream allocator (supplied at construction), thus replenishing the pool. With each successive replenishment, the chunk size obtained increases geometrically. [ Note: By allocating memory in chunks, the pooling strategy increases the chance that consecutive allocations will be close together in memory. - end note ]</para></listitem><listitem><para>Allocation requests that exceed the largest block size of any pool are fulfilled directly from the upstream allocator.</para></listitem><listitem><para>A <classname alt="boost::container::pmr::pool_options">pool_options</classname> struct may be passed to the pool resource constructors to tune the largest block size and the maximum chunk size.</para></listitem></itemizedlist>
</para><para>A <classname alt="boost::container::pmr::synchronized_pool_resource">synchronized_pool_resource</classname> may be accessed from multiple threads without external synchronization and may have thread-specific pools to reduce synchronization costs. </para></description><method-group name="public member functions">
<method name="release"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Calls Calls <computeroutput>upstream_resource()-&gt;deallocate()</computeroutput> as necessary to release all allocated memory. [ Note: memory is released back to <computeroutput>upstream_resource()</computeroutput> even if deallocate has not been called for some of the allocated blocks. - end note ] </para></description></method>
<method name="upstream_resource" cv="const"><type><classname>memory_resource</classname> *</type><description><para><emphasis role="bold">Returns</emphasis>: The value of the upstream argument provided to the constructor of this object. </para></description></method>
<method name="options" cv="const"><type><classname>pool_options</classname></type><description><para><emphasis role="bold">Returns</emphasis>: The options that control the pooling behavior of this resource. The values in the returned struct may differ from those supplied to the pool resource constructor in that values of zero will be replaced with implementation-defined defaults and sizes may be rounded to unspecified granularity. </para></description></method>
<method name="pool_count" cv="const"><type>std::size_t</type><description><para><emphasis role="bold">Returns</emphasis>: The number of pools that will be used in the pool resource.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="pool_index" cv="const"><type>std::size_t</type><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The index of the pool that will be used to serve the allocation of <computeroutput>bytes</computeroutput>. Returns <computeroutput>pool_count()</computeroutput> if <computeroutput>bytes</computeroutput> is bigger than <computeroutput>options().largest_required_pool_block</computeroutput> (no pool will be used to serve this).</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="pool_next_blocks_per_chunk" cv="const"><type>std::size_t</type><parameter name="pool_idx"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>pool_idx &lt; pool_index()</computeroutput></para><para><emphasis role="bold">Returns</emphasis>: The number blocks that will be allocated in the next chunk from the pool specified by <computeroutput>pool_idx</computeroutput>.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="pool_block" cv="const"><type>std::size_t</type><parameter name="pool_idx"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>pool_idx &lt; pool_index()</computeroutput></para><para><emphasis role="bold">Returns</emphasis>: The number of bytes of the block that the specified <computeroutput>pool_idx</computeroutput> pool manages.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="pool_cached_blocks" cv="const"><type>std::size_t</type><parameter name="pool_idx"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>pool_idx &lt; pool_index()</computeroutput></para><para><emphasis role="bold">Returns</emphasis>: The number of blocks that the specified <computeroutput>pool_idx</computeroutput> pool has cached and will be served without calling the upstream_allocator.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
</method-group>
<constructor cv="noexcept"><parameter name="opts"><paramtype>const <classname>pool_options</classname> &amp;</paramtype></parameter><parameter name="upstream"><paramtype><classname>memory_resource</classname> *</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upstream</computeroutput> is the address of a valid memory resource.</para><para><emphasis role="bold">Effects</emphasis>: Constructs a pool resource object that will obtain memory from upstream whenever the pool resource is unable to satisfy a memory request from its own internal data structures. The resulting object will hold a copy of upstream, but will not own the resource to which upstream points. [ Note: The intention is that calls to upstream-&gt;allocate() will be substantially fewer than calls to this-&gt;allocate() in most cases. - end note The behavior of the pooling mechanism is tuned according to the value of the opts argument.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless upstream-&gt;allocate() throws. It is unspecified if or under what conditions this constructor calls upstream-&gt;allocate(). </para></description></constructor>
<constructor cv="noexcept"><description><para><emphasis role="bold">Effects</emphasis>: Same as <computeroutput><classname alt="boost::container::pmr::unsynchronized_pool_resource">unsynchronized_pool_resource</classname>(pool_options(), get_default_resource())</computeroutput>. </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><parameter name="upstream"><paramtype><classname>memory_resource</classname> *</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as <computeroutput>unsynchronized_pool_resource(pool_options(), upstream)</computeroutput>. </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><parameter name="opts"><paramtype>const <classname>pool_options</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as <computeroutput>unsynchronized_pool_resource(opts, get_default_resource())</computeroutput>. </para></description></constructor>
<constructor cv="= delete"><parameter name=""><paramtype>const <classname>synchronized_pool_resource</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= delete"><type><classname>synchronized_pool_resource</classname></type><parameter name=""><paramtype>const <classname>synchronized_pool_resource</classname> &amp;</paramtype></parameter></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Calls <computeroutput>this-&gt;release()</computeroutput>. </para></description></destructor>
<method-group name="protected member functions">
<method name="do_allocate" specifiers="virtual"><type>void *</type><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><parameter name="alignment"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A pointer to allocated storage with a size of at least <computeroutput>bytes</computeroutput>. The size and alignment of the allocated memory shall meet the requirements for a class derived from <computeroutput><classname alt="boost::container::pmr::memory_resource">memory_resource</classname></computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: If the pool selected for a block of size bytes is unable to satisfy the memory request from its own internal data structures, it will call <computeroutput>upstream_resource()-&gt;allocate()</computeroutput> to obtain more memory. If <computeroutput>bytes</computeroutput> is larger than that which the largest pool can handle, then memory will be allocated using <computeroutput>upstream_resource()-&gt;allocate()</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless <computeroutput>upstream_resource()-&gt;allocate()</computeroutput> throws. </para></description></method>
<method name="do_deallocate" specifiers="virtual"><type>void</type><parameter name="p"><paramtype>void *</paramtype></parameter><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><parameter name="alignment"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Return the memory at p to the pool. It is unspecified if or under what circumstances this operation will result in a call to <computeroutput>upstream_resource()-&gt;deallocate()</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="do_is_equal" cv="const noexcept" specifiers="virtual"><type>bool</type><parameter name="other"><paramtype>const <classname>memory_resource</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>this == dynamic_cast&lt;const unsynchronized_pool_resource*&gt;(&amp;other)</computeroutput>. </para></description></method>
</method-group>
</class>





</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/unsynchronized_pool_resource.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<class name="unsynchronized_pool_resource"><inherit access="public">boost::container::pmr::memory_resource</inherit><description><para>A <classname alt="boost::container::pmr::unsynchronized_pool_resource">unsynchronized_pool_resource</classname> is a general-purpose memory resources having the following qualities:</para><para><itemizedlist>
<listitem><para>Each resource owns the allocated memory, and frees it on destruction, even if deallocate has not been called for some of the allocated blocks.</para></listitem><listitem><para>A pool resource consists of a collection of pools, serving requests for different block sizes. Each individual pool manages a collection of chunks that are in turn divided into blocks of uniform size, returned via calls to do_allocate. Each call to do_allocate(size, alignment) is dispatched to the pool serving the smallest blocks accommodating at least size bytes.</para></listitem><listitem><para>When a particular pool is exhausted, allocating a block from that pool results in the allocation of an additional chunk of memory from the upstream allocator (supplied at construction), thus replenishing the pool. With each successive replenishment, the chunk size obtained increases geometrically. [ Note: By allocating memory in chunks, the pooling strategy increases the chance that consecutive allocations will be close together in memory. - end note ]</para></listitem><listitem><para>Allocation requests that exceed the largest block size of any pool are fulfilled directly from the upstream allocator.</para></listitem><listitem><para>A <classname alt="boost::container::pmr::pool_options">pool_options</classname> struct may be passed to the pool resource constructors to tune the largest block size and the maximum chunk size.</para></listitem></itemizedlist>
</para><para>An <classname alt="boost::container::pmr::unsynchronized_pool_resource">unsynchronized_pool_resource</classname> class may not be accessed from multiple threads simultaneously and thus avoids the cost of synchronization entirely in single-threaded applications. </para></description><method-group name="public member functions">
<method name="release"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Calls Calls <computeroutput>upstream_resource()-&gt;deallocate()</computeroutput> as necessary to release all allocated memory. [ Note: memory is released back to <computeroutput>upstream_resource()</computeroutput> even if deallocate has not been called for some of the allocated blocks. - end note ] </para></description></method>
<method name="upstream_resource" cv="const"><type><classname>memory_resource</classname> *</type><description><para><emphasis role="bold">Returns</emphasis>: The value of the upstream argument provided to the constructor of this object. </para></description></method>
<method name="options" cv="const"><type><classname>pool_options</classname></type><description><para><emphasis role="bold">Returns</emphasis>: The options that control the pooling behavior of this resource. The values in the returned struct may differ from those supplied to the pool resource constructor in that values of zero will be replaced with implementation-defined defaults and sizes may be rounded to unspecified granularity. </para></description></method>
<method name="pool_count" cv="const"><type>std::size_t</type><description><para><emphasis role="bold">Returns</emphasis>: The number of pools that will be used in the pool resource.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="pool_index" cv="const"><type>std::size_t</type><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The index of the pool that will be used to serve the allocation of <computeroutput>bytes</computeroutput>. Returns <computeroutput>pool_count()</computeroutput> if <computeroutput>bytes</computeroutput> is bigger than <computeroutput>options().largest_required_pool_block</computeroutput> (no pool will be used to serve this).</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="pool_next_blocks_per_chunk" cv="const"><type>std::size_t</type><parameter name="pool_idx"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>pool_idx &lt; pool_index()</computeroutput></para><para><emphasis role="bold">Returns</emphasis>: The number blocks that will be allocated in the next chunk from the pool specified by <computeroutput>pool_idx</computeroutput>.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="pool_block" cv="const"><type>std::size_t</type><parameter name="pool_idx"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>pool_idx &lt; pool_index()</computeroutput></para><para><emphasis role="bold">Returns</emphasis>: The number of bytes of the block that the specified <computeroutput>pool_idx</computeroutput> pool manages.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="pool_cached_blocks" cv="const"><type>std::size_t</type><parameter name="pool_idx"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>pool_idx &lt; pool_index()</computeroutput></para><para><emphasis role="bold">Returns</emphasis>: The number of blocks that the specified <computeroutput>pool_idx</computeroutput> pool has cached and will be served without calling the upstream_allocator.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
</method-group>
<constructor cv="noexcept"><parameter name="opts"><paramtype>const <classname>pool_options</classname> &amp;</paramtype></parameter><parameter name="upstream"><paramtype><classname>memory_resource</classname> *</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: <computeroutput>upstream</computeroutput> is the address of a valid memory resource.</para><para><emphasis role="bold">Effects</emphasis>: Constructs a pool resource object that will obtain memory from upstream whenever the pool resource is unable to satisfy a memory request from its own internal data structures. The resulting object will hold a copy of upstream, but will not own the resource to which upstream points. [ Note: The intention is that calls to upstream-&gt;allocate() will be substantially fewer than calls to this-&gt;allocate() in most cases. - end note The behavior of the pooling mechanism is tuned according to the value of the opts argument.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless upstream-&gt;allocate() throws. It is unspecified if or under what conditions this constructor calls upstream-&gt;allocate(). </para></description></constructor>
<constructor cv="noexcept"><description><para><emphasis role="bold">Effects</emphasis>: Same as <computeroutput><classname alt="boost::container::pmr::unsynchronized_pool_resource">unsynchronized_pool_resource</classname>(pool_options(), get_default_resource())</computeroutput>. </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><parameter name="upstream"><paramtype><classname>memory_resource</classname> *</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as <computeroutput>unsynchronized_pool_resource(pool_options(), upstream)</computeroutput>. </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><parameter name="opts"><paramtype>const <classname>pool_options</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as <computeroutput>unsynchronized_pool_resource(opts, get_default_resource())</computeroutput>. </para></description></constructor>
<constructor cv="= delete"><parameter name=""><paramtype>const <classname>unsynchronized_pool_resource</classname> &amp;</paramtype></parameter></constructor>
<copy-assignment cv="= delete"><type><classname>unsynchronized_pool_resource</classname></type><parameter name=""><paramtype>const <classname>unsynchronized_pool_resource</classname> &amp;</paramtype></parameter></copy-assignment>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Calls <computeroutput>this-&gt;release()</computeroutput>. </para></description></destructor>
<method-group name="protected member functions">
<method name="do_allocate" specifiers="virtual"><type>void *</type><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><parameter name="alignment"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A pointer to allocated storage with a size of at least <computeroutput>bytes</computeroutput>. The size and alignment of the allocated memory shall meet the requirements for a class derived from <computeroutput><classname alt="boost::container::pmr::memory_resource">memory_resource</classname></computeroutput>.</para><para><emphasis role="bold">Effects</emphasis>: If the pool selected for a block of size bytes is unable to satisfy the memory request from its own internal data structures, it will call <computeroutput>upstream_resource()-&gt;allocate()</computeroutput> to obtain more memory. If <computeroutput>bytes</computeroutput> is larger than that which the largest pool can handle, then memory will be allocated using <computeroutput>upstream_resource()-&gt;allocate()</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless <computeroutput>upstream_resource()-&gt;allocate()</computeroutput> throws. </para></description></method>
<method name="do_deallocate" specifiers="virtual"><type>void</type><parameter name="p"><paramtype>void *</paramtype></parameter><parameter name="bytes"><paramtype>std::size_t</paramtype></parameter><parameter name="alignment"><paramtype>std::size_t</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Return the memory at p to the pool. It is unspecified if or under what circumstances this operation will result in a call to <computeroutput>upstream_resource()-&gt;deallocate()</computeroutput>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing. </para></description></method>
<method name="do_is_equal" cv="const noexcept" specifiers="virtual"><type>bool</type><parameter name="other"><paramtype>const <classname>memory_resource</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>this == dynamic_cast&lt;const unsynchronized_pool_resource*&gt;(&amp;other)</computeroutput>. </para></description></method>
</method-group>
</class>





</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/scoped_allocator.hpp">
<namespace name="boost">
<namespace name="container">
<class name="scoped_allocator_adaptor"><template>
      <template-type-parameter name="OuterAlloc"/>
      <template-nontype-parameter name="InnerAllocs"><type>typename...</type></template-nontype-parameter>
    </template><inherit access="public">dtl::scoped_allocator_adaptor_base&lt; OuterAlloc, InnerAllocs...&gt;</inherit><description><para>This class is a C++03-compatible implementation of std::scoped_allocator_adaptor. The class template <classname alt="boost::container::scoped_allocator_adaptor">scoped_allocator_adaptor</classname> is an allocator template that specifies the memory resource (the outer allocator) to be used by a container (as any other allocator does) and also specifies an inner allocator resource to be passed to the constructor of every element within the container.</para><para>This adaptor is instantiated with one outer and zero or more inner allocator types. If instantiated with only one allocator type, the inner allocator becomes the <classname alt="boost::container::scoped_allocator_adaptor">scoped_allocator_adaptor</classname> itself, thus using the same allocator resource for the container and every element within the container and, if the elements themselves are containers, each of their elements recursively. If instantiated with more than one allocator, the first allocator is the outer allocator for use by the container, the second allocator is passed to the constructors of the container's elements, and, if the elements themselves are containers, the third allocator is passed to the elements' elements, and so on. If containers are nested to a depth greater than the number of allocators, the last allocator is used repeatedly, as in the single-allocator case, for any remaining recursions.</para><para>[<emphasis role="bold">Note</emphasis>: The <classname alt="boost::container::scoped_allocator_adaptor">scoped_allocator_adaptor</classname> is derived from the outer allocator type so it can be substituted for the outer allocator type in most expressions. -end note]</para><para>In the construct member functions, <computeroutput>OUTERMOST(x)</computeroutput> is x if x does not have an <computeroutput>outer_allocator()</computeroutput> member function and <computeroutput>OUTERMOST(x.outer_allocator())</computeroutput> otherwise; <computeroutput>OUTERMOST_ALLOC_TRAITS(x)</computeroutput> is <computeroutput>allocator_traits&lt;decltype(OUTERMOST(x))&gt;</computeroutput>.</para><para>[<emphasis role="bold">Note</emphasis>: <computeroutput>OUTERMOST(x)</computeroutput> and <computeroutput>OUTERMOST_ALLOC_TRAITS(x)</computeroutput> are recursive operations. It is incumbent upon the definition of <computeroutput>outer_allocator()</computeroutput> to ensure that the recursion terminates. It will terminate for all instantiations of <classname alt="boost::container::scoped_allocator_adaptor">scoped_allocator_adaptor</classname>. -end note] </para></description><struct name="rebind"><template>
      <template-type-parameter name="U"/>
    </template><description><para>Type: Rebinds scoped allocator to <computeroutput>typedef <classname alt="boost::container::scoped_allocator_adaptor">scoped_allocator_adaptor</classname> &lt; typename outer_traits_type::template portable_rebind_alloc&lt;U&gt;::type , InnerAllocs... &gt;</computeroutput> </para></description><typedef name="other"><type><classname>scoped_allocator_adaptor</classname>&lt; typename outer_traits_type::template portable_rebind_alloc&lt; U &gt;::type, InnerAllocs...&gt;</type></typedef>
</struct><typedef name="outer_allocator_type"><type>OuterAlloc</type></typedef>
<typedef name="outer_traits_type"><description><para>Type: For exposition only </para></description><type><classname>allocator_traits</classname>&lt; OuterAlloc &gt;</type></typedef>
<typedef name="inner_allocator_type"><description><para>Type: <computeroutput>scoped_allocator_adaptor&lt;OuterAlloc&gt;</computeroutput> if <computeroutput>sizeof...(InnerAllocs)</computeroutput> is zero; otherwise, <computeroutput>scoped_allocator_adaptor&lt;InnerAllocs...&gt;</computeroutput>. </para></description><type>base_type::inner_allocator_type</type></typedef>
<typedef name="inner_traits_type"><type><classname>allocator_traits</classname>&lt; inner_allocator_type &gt;</type></typedef>
<typedef name="value_type"><type>outer_traits_type::value_type</type></typedef>
<typedef name="size_type"><type>outer_traits_type::size_type</type></typedef>
<typedef name="difference_type"><type>outer_traits_type::difference_type</type></typedef>
<typedef name="pointer"><type>outer_traits_type::pointer</type></typedef>
<typedef name="const_pointer"><type>outer_traits_type::const_pointer</type></typedef>
<typedef name="void_pointer"><type>outer_traits_type::void_pointer</type></typedef>
<typedef name="const_void_pointer"><type>outer_traits_type::const_void_pointer</type></typedef>
<typedef name="propagate_on_container_copy_assignment"><description><para>Type: A type with a constant boolean <computeroutput>value</computeroutput> == true if <computeroutput><classname alt="boost::container::allocator_traits">allocator_traits</classname>&lt;Allocator&gt;:: propagate_on_container_copy_assignment::value</computeroutput> is true for any <computeroutput>Allocator</computeroutput> in the set of <computeroutput>OuterAlloc</computeroutput> and <computeroutput>InnerAllocs...</computeroutput>, false otherwise. </para></description><type>base_type::propagate_on_container_copy_assignment</type></typedef>
<typedef name="propagate_on_container_move_assignment"><description><para>Type: A type with a constant boolean <computeroutput>value</computeroutput> == true if <computeroutput><classname alt="boost::container::allocator_traits">allocator_traits</classname>&lt;Allocator&gt;:: propagate_on_container_move_assignment::value</computeroutput> is true for any <computeroutput>Allocator</computeroutput> in the set of <computeroutput>OuterAlloc</computeroutput> and <computeroutput>InnerAllocs...</computeroutput>, false otherwise. </para></description><type>base_type::propagate_on_container_move_assignment</type></typedef>
<typedef name="propagate_on_container_swap"><description><para>Type: A type with a constant boolean <computeroutput>value</computeroutput> == true if <computeroutput><classname alt="boost::container::allocator_traits">allocator_traits</classname>&lt;Allocator&gt;:: propagate_on_container_swap::value</computeroutput> is true for any <computeroutput>Allocator</computeroutput> in the set of <computeroutput>OuterAlloc</computeroutput> and <computeroutput>InnerAllocs...</computeroutput>, false otherwise. </para></description><type>base_type::propagate_on_container_swap</type></typedef>
<typedef name="is_always_equal"><description><para>Type: A type with a constant boolean <computeroutput>value</computeroutput> == true if <computeroutput><classname alt="boost::container::allocator_traits">allocator_traits</classname>&lt;Allocator&gt;:: is_always_equal::value</computeroutput> is true for all <computeroutput>Allocator</computeroutput> in the set of <computeroutput>OuterAlloc</computeroutput> and <computeroutput>InnerAllocs...</computeroutput>, false otherwise. </para></description><type>base_type::is_always_equal</type></typedef>
<method-group name="public member functions">
<method name="swap"><type>void</type><parameter name="r"><paramtype><classname>scoped_allocator_adaptor</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: swaps *this with r. </para></description></method>
<method name="outer_allocator" cv="noexcept"><type>outer_allocator_type &amp;</type><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>static_cast&lt;OuterAlloc&amp;&gt;(*this)</computeroutput>. </para></description></method>
<method name="outer_allocator" cv="const noexcept"><type>const outer_allocator_type &amp;</type><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>static_cast&lt;const OuterAlloc&amp;&gt;(*this)</computeroutput>. </para></description></method>
<method name="inner_allocator" cv="noexcept"><type>inner_allocator_type &amp;</type><description><para><emphasis role="bold">Returns</emphasis>: *this if <computeroutput>sizeof...(InnerAllocs)</computeroutput> is zero; otherwise, inner. </para></description></method>
<method name="inner_allocator" cv="const noexcept"><type>inner_allocator_type const &amp;</type><description><para><emphasis role="bold">Returns</emphasis>: *this if <computeroutput>sizeof...(InnerAllocs)</computeroutput> is zero; otherwise, inner. </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>allocator_traits&lt;OuterAlloc&gt;:: max_size(outer_allocator())</computeroutput>. </para></description></method>
<method name="destroy" cv="noexcept"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="p"><paramtype>T *</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: calls <computeroutput>OUTERMOST_ALLOC_TRAITS(*this):: destroy(OUTERMOST(*this), p)</computeroutput>. </para></description></method>
<method name="allocate"><type>pointer</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>allocator_traits&lt;OuterAlloc&gt;::allocate(outer_allocator(), n)</computeroutput>. </para></description></method>
<method name="allocate"><type>pointer</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>const_void_pointer</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: <computeroutput>allocator_traits&lt;OuterAlloc&gt;::allocate(outer_allocator(), n, hint)</computeroutput>. </para></description></method>
<method name="deallocate"><type>void</type><parameter name="p"><paramtype>pointer</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: <computeroutput>allocator_traits&lt;OuterAlloc&gt;::deallocate(outer_allocator(), p, n)</computeroutput>. </para></description></method>
<method name="select_on_container_copy_construction" cv="const"><type><classname>scoped_allocator_adaptor</classname></type><description><para><emphasis role="bold">Returns</emphasis>: A new <classname alt="boost::container::scoped_allocator_adaptor">scoped_allocator_adaptor</classname> object where each allocator Allocator in the adaptor is initialized from the result of calling <computeroutput>allocator_traits&lt;Allocator&gt;::select_on_container_copy_construction()</computeroutput> on the corresponding allocator in *this. </para></description></method>
<method name="construct"><type>void</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>T *</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: 1) If <computeroutput>uses_allocator&lt;T, inner_allocator_type&gt;::value</computeroutput> is false calls <computeroutput>OUTERMOST_ALLOC_TRAITS(*this):: construct(OUTERMOST(*this), p, std::forward&lt;Args&gt;(args)...)</computeroutput>.</para><para>2) Otherwise, if <computeroutput>uses_allocator&lt;T, inner_allocator_type&gt;::value</computeroutput> is true and <computeroutput>is_constructible&lt;T, allocator_arg_t, inner_allocator_type, Args...&gt;:: value</computeroutput> is true, calls <computeroutput>OUTERMOST_ALLOC_TRAITS(*this):: construct(OUTERMOST(*this), p, allocator_arg, inner_allocator(), std::forward&lt;Args&gt;(args)...)</computeroutput>.</para><para>[<emphasis role="bold">Note</emphasis>: In compilers without advanced decltype SFINAE support, <computeroutput>is_constructible</computeroutput> can't be implemented so that condition will be replaced by constructible_with_allocator_prefix&lt;T&gt;::value. -end note]</para><para>3) Otherwise, if uses_allocator&lt;T, inner_allocator_type&gt;::value is true and <computeroutput>is_constructible&lt;T, Args..., inner_allocator_type&gt;:: value</computeroutput> is true, calls <computeroutput>OUTERMOST_ALLOC_TRAITS(*this):: construct(OUTERMOST(*this), p, std::forward&lt;Args&gt;(args)..., inner_allocator())</computeroutput>.</para><para>[<emphasis role="bold">Note</emphasis>: In compilers without advanced decltype SFINAE support, <computeroutput>is_constructible</computeroutput> can't be implemented so that condition will be replaced by <computeroutput>constructible_with_allocator_suffix&lt;T&gt;:: value</computeroutput>. -end note]</para><para>4) Otherwise, the program is ill-formed.</para><para>[<emphasis role="bold">Note</emphasis>: An error will result if <computeroutput><classname alt="boost::container::uses_allocator">uses_allocator</classname></computeroutput> evaluates to true but the specific constructor does not take an allocator. This definition prevents a silent failure to pass an inner allocator to a contained element. -end note] </para></description></method>
</method-group>
<constructor><description><para><emphasis role="bold">Effects</emphasis>: value-initializes the OuterAlloc base class and the inner allocator object. </para></description></constructor>
<destructor/>
<constructor><parameter name="other"><paramtype>const <classname>scoped_allocator_adaptor</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: initializes each allocator within the adaptor with the corresponding allocator from other. </para></description></constructor>
<constructor><parameter name="other"><paramtype><classname>scoped_allocator_adaptor</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: move constructs each allocator within the adaptor with the corresponding allocator from other. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="OuterA2"/>
        </template><parameter name="outerAlloc"><paramtype>OuterA2 &amp;&amp;</paramtype></parameter><parameter name="innerAllocs"><paramtype>const InnerAllocs &amp;...</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: OuterAlloc shall be constructible from OuterA2.</para><para><emphasis role="bold">Effects</emphasis>: initializes the OuterAlloc base class with boost::forward&lt;OuterA2&gt;(outerAlloc) and inner with innerAllocs...(hence recursively initializing each allocator within the adaptor with the corresponding allocator from the argument list). </para></description></constructor>
<constructor><template>
          <template-type-parameter name="OuterA2"/>
        </template><parameter name="other"><paramtype>const <classname>scoped_allocator_adaptor</classname>&lt; OuterA2, InnerAllocs...&gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: OuterAlloc shall be constructible from OuterA2.</para><para><emphasis role="bold">Effects</emphasis>: initializes each allocator within the adaptor with the corresponding allocator from other. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="OuterA2"/>
        </template><parameter name="other"><paramtype><classname>scoped_allocator_adaptor</classname>&lt; OuterA2, InnerAllocs...&gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: OuterAlloc shall be constructible from OuterA2.</para><para><emphasis role="bold">Effects</emphasis>: initializes each allocator within the adaptor with the corresponding allocator rvalue from other. </para></description></constructor>
<copy-assignment><type><classname>scoped_allocator_adaptor</classname> &amp;</type><parameter name="other"><paramtype>const <classname>scoped_allocator_adaptor</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>scoped_allocator_adaptor</classname> &amp;</type><parameter name="other"><paramtype><classname>scoped_allocator_adaptor</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<method-group name="friend functions">
<method name="swap"><type>friend void</type><parameter name="l"><paramtype><classname>scoped_allocator_adaptor</classname> &amp;</paramtype></parameter><parameter name="r"><paramtype><classname>scoped_allocator_adaptor</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: swaps *this with r. </para></description></method>
</method-group>
</class>























































<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="OuterA1"/>
          <template-type-parameter name="OuterA2"/>
          <template-nontype-parameter name=""><type>BOOST_CONTAINER_SCOPEDALLOC_ALLINNERCLASS</type></template-nontype-parameter>
        </template><parameter name="a"><paramtype>const <classname>scoped_allocator_adaptor</classname>&lt; OuterA1, InnerAllocs...&gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>scoped_allocator_adaptor</classname>&lt; OuterA2, InnerAllocs...&gt; &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="OuterA1"/>
          <template-type-parameter name="OuterA2"/>
          <template-nontype-parameter name=""><type>BOOST_CONTAINER_SCOPEDALLOC_ALLINNERCLASS</type></template-nontype-parameter>
        </template><parameter name="a"><paramtype>const <classname>scoped_allocator_adaptor</classname>&lt; OuterA1, InnerAllocs...&gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>scoped_allocator_adaptor</classname>&lt; OuterA2, InnerAllocs...&gt; &amp;</paramtype></parameter></function>
</namespace>
</namespace>
</header>
<header name="boost/container/scoped_allocator_fwd.hpp">
<para>This header file forward declares <classname alt="boost::container::scoped_allocator_adaptor">boost::container::scoped_allocator_adaptor</classname> </para><namespace name="boost">
<namespace name="container">


























































</namespace>
</namespace>
</header>
<header name="boost/container/set.hpp">
<namespace name="boost">
<namespace name="container">
<class name="set"><template>
      <template-type-parameter name="Key"><purpose><para>is the type to be inserted in the set, which is also the key_type </para></purpose></template-type-parameter>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default><purpose><para>is the comparison functor used to order keys </para></purpose></template-type-parameter>
      <template-type-parameter name="Allocator"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt;Key&gt;</default><purpose><para>is the allocator to be used to allocate memory for this container </para></purpose></template-type-parameter>
      <template-type-parameter name="Options"><default>void</default><purpose><para>is an packed option type generated using using <classname alt="boost::container::tree_assoc_options">boost::container::tree_assoc_options</classname>. </para></purpose></template-type-parameter>
    </template><description><para>A set is a kind of associative container that supports unique keys (contains at most one of each key value) and provides for fast retrieval of the keys themselves. Class set supports bidirectional iterators.</para><para>A set satisfies all of the requirements of a container and of a reversible container , and of an associative container. A set also provides most operations described in for unique keys.</para><para>
</para></description><typedef name="key_type"><type>Key</type></typedef>
<typedef name="value_type"><type>Key</type></typedef>
<typedef name="key_compare"><type>Compare</type></typedef>
<typedef name="value_compare"><type>Compare</type></typedef>
<typedef name="allocator_traits_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;</type></typedef>
<typedef name="pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::pointer</type></typedef>
<typedef name="const_pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_pointer</type></typedef>
<typedef name="reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::reference</type></typedef>
<typedef name="const_reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_reference</type></typedef>
<typedef name="size_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::size_type</type></typedef>
<typedef name="difference_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::difference_type</type></typedef>
<typedef name="allocator_type"><type>Allocator</type></typedef>
<typedef name="stored_allocator_type"><type>implementation_defined</type></typedef>
<typedef name="iterator"><type>implementation_defined</type></typedef>
<typedef name="const_iterator"><type>implementation_defined</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="node_type"><type>implementation_defined</type></typedef>
<typedef name="insert_return_type"><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator"><type>stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="emplace"><type>std::pair&lt; iterator, bool &gt;</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object x of type Key constructed with std::forward&lt;Args&gt;(args)... if and only if there is no element in the container with equivalent value. and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or Key's in-place constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="emplace_hint"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type Key constructed with std::forward&lt;Args&gt;(args)... if and only if there is no element in the container with equivalent value. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>std::pair&lt; iterator, bool &gt;</type><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a new value from x if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an element move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first, last are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [first,last) if and only if there is no element with key equivalent to the key of that element.</para><para><emphasis role="bold">Complexity</emphasis>: At most N log(size()+N) (N is the distance from first to last) </para></description></method>
<method name="insert"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [il.begin(),il.end()) if and only if there is no element with key equivalent to the key of that element.</para><para><emphasis role="bold">Complexity</emphasis>: At most N log(size()+N) (N is the distance from il.begin() to il.end()) </para></description></method>
<method name="insert"><type>insert_return_type</type><parameter name="nh"><paramtype>node_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value_type move constructed from the pair if and only if there is no element in the container with key equivalent to the key of x.</para><para><emphasis role="bold">Returns</emphasis>: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>insert_return_type</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="nh"><paramtype>node_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a new value from x if and only if there is no element in the container with key equivalent to the key of x. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>set</classname>&lt; Key, C2, Allocator, Options &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>set</classname>&lt; Key, C2, Allocator, Options &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>multiset</classname>&lt; Key, C2, Allocator, Options &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>multiset</classname>&lt; Key, C2, Allocator, Options &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Attempts to extract each element in source and insert it into a using the comparison object of *this. If there is an element in a with key equivalent to the key of an element from source, then that element is not extracted from source.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="erase"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by p.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time </para></description></method>
<method name="erase"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: log(size()) + count(k) </para></description></method>
<method name="erase"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+N where N is the distance from first to last. </para></description></method>
<method name="extract"><type>node_type</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes the element pointed to by "position".</para><para><emphasis role="bold">Returns</emphasis>: A node_type owning the element, otherwise an empty node_type.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant. </para></description></method>
<method name="extract"><type>node_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes the first element in the container with key equivalent to k.</para><para><emphasis role="bold">Returns</emphasis>: A node_type owning the element if found, otherwise an empty node_type.</para><para><emphasis role="bold">Complexity</emphasis>: log(a.size()). </para></description></method>
<method name="swap" cv="noexcept(allocator_traits_type::is_always_equal::value &amp;&amp;boost::container::dtl::is_nothrow_swappable&lt; Compare &gt;::value))"><type>void</type><parameter name="x"><paramtype><classname>set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="find"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="count"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="rebalance"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree. It's a no-op for Red-Black and AVL trees.</para><para><emphasis role="bold">Complexity</emphasis>: Linear </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; Allocator &gt;::value &amp;&amp;dtl::is_nothrow_default_constructible&lt; Compare &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Default constructs an empty set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified allocator object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set and inserts elements from the ordered unique range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and inserts elements from the ordered unique range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the ordered unique range [first ,last). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_unique_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a set.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor cv="noexcept(boost::container::dtl::is_nothrow_move_constructible&lt; Compare &gt;::value))"><parameter name="x"><paramtype><classname>set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a set. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a set using the specified allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>set</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a set using the specified allocator. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant if a == x.get_allocator(), linear otherwise. </para></description></constructor>
<copy-assignment><type><classname>set</classname> &amp;</type><parameter name="x"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment>
<copy-assignment cv="noexcept((allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value)&amp;&amp;boost::container::dtl::is_nothrow_move_assignable&lt; Compare &gt;::value))"><type><classname>set</classname> &amp;</type><parameter name="x"><paramtype><classname>set</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: this-&gt;swap(x.get()).</para><para><emphasis role="bold">Throws</emphasis>: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type's move constructor throws)</para><para><emphasis role="bold">Complexity</emphasis>: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this-&gt;get&gt;allocator() == x.get_allocator(). Linear otherwise. </para></description></copy-assignment>
<copy-assignment><type><classname>set</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy all elements from il to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in il.size(). </para></description></copy-assignment>
<method-group name="friend functions">
<method name="operator=="><type>friend bool</type><parameter name="x"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are equal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator!="><type>friend bool</type><parameter name="x"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are unequal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="swap"><type>friend void</type><parameter name="x"><paramtype><classname>set</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>set</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y)</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
</method-group>
</class><class name="multiset"><template>
      <template-type-parameter name="Key"><purpose><para>is the type to be inserted in the set, which is also the key_type </para></purpose></template-type-parameter>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default><purpose><para>is the comparison functor used to order keys </para></purpose></template-type-parameter>
      <template-type-parameter name="Allocator"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt;Key&gt;</default><purpose><para>is the allocator to be used to allocate memory for this container </para></purpose></template-type-parameter>
      <template-type-parameter name="Options"><default>tree_assoc_defaults</default><purpose><para>is an packed option type generated using using <classname alt="boost::container::tree_assoc_options">boost::container::tree_assoc_options</classname>. </para></purpose></template-type-parameter>
    </template><description><para>A multiset is a kind of associative container that supports equivalent keys (possibly contains multiple copies of the same key value) and provides for fast retrieval of the keys themselves. Class multiset supports bidirectional iterators.</para><para>A multiset satisfies all of the requirements of a container and of a reversible container, and of an associative container). multiset also provides most operations described for duplicate keys.</para><para>
</para></description><typedef name="key_type"><type>Key</type></typedef>
<typedef name="value_type"><type>Key</type></typedef>
<typedef name="key_compare"><type>Compare</type></typedef>
<typedef name="value_compare"><type>Compare</type></typedef>
<typedef name="allocator_traits_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;</type></typedef>
<typedef name="pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::pointer</type></typedef>
<typedef name="const_pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_pointer</type></typedef>
<typedef name="reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::reference</type></typedef>
<typedef name="const_reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_reference</type></typedef>
<typedef name="size_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::size_type</type></typedef>
<typedef name="difference_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::difference_type</type></typedef>
<typedef name="allocator_type"><type>Allocator</type></typedef>
<typedef name="stored_allocator_type"><type>implementation_defined</type></typedef>
<typedef name="iterator"><type>implementation_defined</type></typedef>
<typedef name="const_iterator"><type>implementation_defined</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="node_type"><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the allocator that was passed to the object's constructor.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator"><type>stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="const"><type>const stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="begin"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the container contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type Key constructed with std::forward&lt;Args&gt;(args)... and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="emplace_hint"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type Key constructed with std::forward&lt;Args&gt;(args)...</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>value_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a value move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="insert"><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first, last are not iterators into *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [first,last) .</para><para><emphasis role="bold">Complexity</emphasis>: At most N log(size()+N) (N is the distance from first to last) </para></description></method>
<method name="insert"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: inserts each element from the range [il.begin(),il.end()) if and only if there is no element with key equivalent to the key of that element.</para><para><emphasis role="bold">Complexity</emphasis>: At most N log(size()+N) (N is the distance from il.begin() to il.end()) </para></description></method>
<method name="insert"><type>iterator</type><parameter name="nh"><paramtype>node_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value move-constructed from x and returns the iterator pointing to the newly inserted element.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="hint"><paramtype>const_iterator</paramtype></parameter><parameter name="nh"><paramtype>node_type &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a new value move constructed from x in the container. p is a hint pointing to where the insert should start to search.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the element with key equivalent to the key of x.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic in general, but amortized constant if t is inserted right before p. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>multiset</classname>&lt; Key, C2, Allocator, Options &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>multiset</classname>&lt; Key, C2, Allocator, Options &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>set</classname>&lt; Key, C2, Allocator, Options &gt; &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="C2"/>
        </template><parameter name="source"><paramtype><classname>set</classname>&lt; Key, C2, Allocator, Options &gt; &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: this-&gt;get_allocator() == source.get_allocator().</para><para><emphasis role="bold">Effects</emphasis>: Extracts each element in source and insert it into a using the comparison object of *this.</para><para><emphasis role="bold">Postcondition</emphasis>: Pointers and references to the transferred elements of source refer to those same elements but as members of *this. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into *this, not into source.</para><para><emphasis role="bold">Throws</emphasis>: Nothing unless the comparison object throws.</para><para><emphasis role="bold">Complexity</emphasis>: N log(a.size() + N) (N has the value source.size()) </para></description></method>
<method name="erase"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element pointed to by p.</para><para><emphasis role="bold">Returns</emphasis>: Returns an iterator pointing to the element immediately following q prior to the element being erased. If no such element exists, returns end().</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time </para></description></method>
<method name="erase"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all elements in the container with key equivalent to x.</para><para><emphasis role="bold">Returns</emphasis>: Returns the number of erased elements.</para><para><emphasis role="bold">Complexity</emphasis>: log(size()) + count(k) </para></description></method>
<method name="erase"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements in the range [first, last).</para><para><emphasis role="bold">Returns</emphasis>: Returns last.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+N where N is the distance from first to last. </para></description></method>
<method name="extract"><type>node_type</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes the element pointed to by "position".</para><para><emphasis role="bold">Returns</emphasis>: A node_type owning the element, otherwise an empty node_type.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant. </para></description></method>
<method name="extract"><type>node_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes the first element in the container with key equivalent to k.</para><para><emphasis role="bold">Returns</emphasis>: A node_type owning the element if found, otherwise an empty node_type.</para><para><emphasis role="bold">Complexity</emphasis>: log(a.size()). </para></description></method>
<method name="swap" cv="noexcept(allocator_traits_type::is_always_equal::value &amp;&amp;boost::container::dtl::is_nothrow_swappable&lt; Compare &gt;::value))"><type>void</type><parameter name="x"><paramtype><classname>multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="clear" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: erase(a.begin(),a.end()).</para><para><emphasis role="bold">Postcondition</emphasis>: size() == 0.</para><para><emphasis role="bold">Complexity</emphasis>: linear in size(). </para></description></method>
<method name="key_comp" cv="const"><type>key_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the comparison object out of which a was constructed.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="value_comp" cv="const"><type>value_compare</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an object of value_compare constructed out of the comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="find"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="find" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic. </para></description></method>
<method name="count" cv="const"><type>size_type</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="count" cv="const"><type>size_type</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: The number of elements with key equivalent to x.</para><para><emphasis role="bold">Complexity</emphasis>: log(size())+count(k) </para></description></method>
<method name="lower_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="lower_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than k, or a.end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound"><type>iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound"><type>iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: An iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="upper_bound" cv="const"><type>const_iterator</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Returns</emphasis>: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found.</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><parameter name="x"><paramtype>const key_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range" cv="const"><type>std::pair&lt; const_iterator, const_iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="equal_range"><type>std::pair&lt; iterator, iterator &gt;</type><template>
          <template-type-parameter name="K"/>
        </template><parameter name="x"><paramtype>const K &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: This overload is available only if key_compare::is_transparent exists.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to std::make_pair(this-&gt;lower_bound(k), this-&gt;upper_bound(k)).</para><para><emphasis role="bold">Complexity</emphasis>: Logarithmic </para></description></method>
<method name="rebalance"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Rebalances the tree. It's a no-op for Red-Black and AVL trees.</para><para><emphasis role="bold">Complexity</emphasis>: Linear </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; Allocator &gt;::value &amp;&amp;dtl::is_nothrow_default_constructible&lt; Compare &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Default constructs an empty set.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified allocator object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the range [first ,last ).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [first ,last ) is already sorted using the predicate and otherwise N logN, where N is last - first. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multiset and and inserts elements from the ordered range [first ,last ). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multiset using the specified comparison object and inserts elements from the ordered range [first ,last ). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty multiset using the specified comparison object and allocator, and inserts elements from the ordered range [first ,last ). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [first ,last) must be ordered according to the predicate.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the range [il.begin(), il.end()).</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N if the range [il.begin(), il.end()) is already sorted using the predicate and otherwise N logN, where N is il.begin() - il.end(). </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name=""><paramtype><classname>ordered_range_t</classname></paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="comp"><paramtype>const Compare &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the ordered unique range [il.begin(), il.end()). This function is more efficient than the normal range creation for ordered ranges.</para><para><emphasis role="bold">Requires</emphasis>: [il.begin(), il.end()) must be ordered according to the predicate and must be unique values.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in N.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a set.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor cv="noexcept(boost::container::dtl::is_nothrow_move_constructible&lt; Compare &gt;::value))"><parameter name="x"><paramtype><classname>multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a set. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Postcondition</emphasis>: x is emptied. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a set using the specified allocator.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>multiset</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructs a set using the specified allocator. Constructs *this using x's resources.</para><para><emphasis role="bold">Complexity</emphasis>: Constant if a == x.get_allocator(), linear otherwise. </para></description></constructor>
<copy-assignment><type><classname>multiset</classname> &amp;</type><parameter name="x"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this a copy of x.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in x.size(). </para></description></copy-assignment>
<copy-assignment cv="noexcept((allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value)&amp;&amp;boost::container::dtl::is_nothrow_move_assignable&lt; Compare &gt;::value))"><type><classname>multiset</classname> &amp;</type><parameter name="x"><paramtype><classname>multiset</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: this-&gt;swap(x.get()).</para><para><emphasis role="bold">Throws</emphasis>: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type's move constructor throws)</para><para><emphasis role="bold">Complexity</emphasis>: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this-&gt;get&gt;allocator() == x.get_allocator(). Linear otherwise. </para></description></copy-assignment>
<copy-assignment><type><classname>multiset</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy all elements from il to *this.</para><para><emphasis role="bold">Complexity</emphasis>: Linear in il.size(). </para></description></copy-assignment>
<method-group name="friend functions">
<method name="operator=="><type>friend bool</type><parameter name="x"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are equal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator!="><type>friend bool</type><parameter name="x"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are unequal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="swap"><type>friend void</type><parameter name="x"><paramtype><classname>multiset</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>multiset</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y)</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
</method-group>
</class>

























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/set.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<struct name="set_of"><template>
      <template-type-parameter name="Key"/>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default></template-type-parameter>
      <template-type-parameter name="Options"><default>void</default></template-type-parameter>
    </template><description><para>A portable metafunction to obtain a set that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::set</classname>&lt; Key, Compare, <classname>polymorphic_allocator</classname>&lt; Key &gt;, Options &gt;</type></typedef>
</struct><struct name="multiset_of"><template>
      <template-type-parameter name="Key"/>
      <template-type-parameter name="Compare"><default>std::less&lt;Key&gt;</default></template-type-parameter>
      <template-type-parameter name="Options"><default>void</default></template-type-parameter>
    </template><description><para>A portable metafunction to obtain a multiset that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::multiset</classname>&lt; Key, Compare, <classname>polymorphic_allocator</classname>&lt; Key &gt;, Options &gt;</type></typedef>
</struct><typedef name="set"><type><classname>boost::container::set</classname>&lt; Key, Compare, <classname>polymorphic_allocator</classname>&lt; Key &gt;, Options &gt;</type></typedef>
<typedef name="multiset"><type><classname>boost::container::multiset</classname>&lt; Key, Compare, <classname>polymorphic_allocator</classname>&lt; Key &gt;, Options &gt;</type></typedef>






</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/slist.hpp">
<namespace name="boost">
<namespace name="container">
<class name="slist"><template>
      <template-type-parameter name="T"><purpose><para>The type of object that is stored in the list </para></purpose></template-type-parameter>
      <template-type-parameter name="Allocator"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt;T&gt;</default><purpose><para>The allocator used for all internal memory management </para></purpose></template-type-parameter>
    </template><inherit access="protected">dtl::node_alloc_holder&lt; Allocator, dtl::intrusive_slist_type&lt; Allocator &gt;::type &gt;</inherit><description><para>An slist is a singly linked list: a list where each element is linked to the next element, but not to the previous element. That is, it is a Sequence that supports forward but not backward traversal, and (amortized) constant time insertion and removal of elements. Slists, like lists, have the important property that insertion and splicing do not invalidate iterators to list elements, and that even removal invalidates only the iterators that point to the elements that are removed. The ordering of iterators may be changed (that is, slist&lt;T&gt;::iterator might have a different predecessor or successor after a list operation than it did before), but the iterators themselves will not be invalidated or made to point to different elements unless that invalidation or mutation is explicit.</para><para>The main difference between slist and list is that list's iterators are bidirectional iterators, while slist's iterators are forward iterators. This means that slist is less versatile than list; frequently, however, bidirectional iterators are unnecessary. You should usually use slist unless you actually need the extra functionality of list, because singly linked lists are smaller and faster than double linked lists.</para><para>Important performance note: like every other Sequence, slist defines the member functions insert and erase. Using these member functions carelessly, however, can result in disastrously slow programs. The problem is that insert's first argument is an iterator p, and that it inserts the new element(s) before p. This means that insert must find the iterator just before p; this is a constant-time operation for list, since list has bidirectional iterators, but for slist it must find that iterator by traversing the list from the beginning up to p. In other words: insert and erase are slow operations anywhere but near the beginning of the slist.</para><para>Slist provides the member functions insert_after and erase_after, which are constant time operations: you should always use insert_after and erase_after whenever possible. If you find that insert_after and erase_after aren't adequate for your needs, and that you often need to use insert and erase in the middle of the list, then you should probably use list instead of slist.</para><para>
</para></description><typedef name="value_type"><type>T</type></typedef>
<typedef name="pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::pointer</type></typedef>
<typedef name="const_pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_pointer</type></typedef>
<typedef name="reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::reference</type></typedef>
<typedef name="const_reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_reference</type></typedef>
<typedef name="size_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::size_type</type></typedef>
<typedef name="difference_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::difference_type</type></typedef>
<typedef name="allocator_type"><type>Allocator</type></typedef>
<typedef name="stored_allocator_type"><type>implementation_defined</type></typedef>
<typedef name="iterator"><type>implementation_defined</type></typedef>
<typedef name="const_iterator"><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="assign"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="val"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the n copies of val to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="assign"><type>void</type><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the range [first, last) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's constructor from dereferencing InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="assign"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the range [il.begin(), il.end()) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's constructor from dereferencing std::initializer_list iterator throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to range [il.begin(), il.end()). </para></description></method>
<method name="get_allocator" cv="const noexcept"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: If allocator's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator" cv="noexcept"><type>stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="const noexcept"><type>const stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="before_begin" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a non-dereferenceable iterator that, when incremented, yields begin(). This iterator may be used as the argument to insert_after, erase_after, etc.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="before_begin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a non-dereferenceable const_iterator that, when incremented, yields begin(). This iterator may be used as the argument to insert_after, erase_after, etc.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbefore_begin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a non-dereferenceable const_iterator that, when incremented, yields begin(). This iterator may be used as the argument to insert_after, erase_after, etc.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="previous" cv="noexcept"><type>iterator</type><parameter name="p"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The iterator to the element before i in the sequence. Returns the end-iterator, if either i is the begin-iterator or the sequence is empty.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before i.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="previous"><type>const_iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Returns</emphasis>: The const_iterator to the element before i in the sequence. Returns the end-const_iterator, if either i is the begin-const_iterator or the sequence is empty.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before i.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the list contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="resize"><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are value initialized.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method>
<method name="resize"><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are copy constructed from x.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method>
<method name="front"><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="front" cv="const"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the first element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="emplace_front"><type>reference</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the front of the list</para><para><emphasis role="bold">Returns</emphasis>: A reference to the created object.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="emplace_after"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="prev"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... after prev</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's in-place constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant </para></description></method>
<method name="push_front"><type>void</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x at the beginning of the list.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="push_front"><type>void</type><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a new element in the beginning of the list and moves the resources of x to this new element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="insert_after"><type>iterator</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of the value after prev_p.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references of previous values. </para></description></method>
<method name="insert_after"><type>iterator</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts a move constructed copy object from the value after the element pointed by prev_p.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references of previous values. </para></description></method>
<method name="insert_after"><type>iterator</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts n copies of x after prev_p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the last inserted element or prev_p if n is 0.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references of previous values. </para></description></method>
<method name="insert_after"><type>iterator</type><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the range pointed by [first, last) after prev_p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the last inserted element or prev_p if first == last.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references of previous values. </para></description></method>
<method name="insert_after"><type>iterator</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts the range pointed by [il.begin(), il.end()) after prev_p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the last inserted element or prev_p if il.begin() == il.end().</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced std::initializer_list iterator throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements inserted.</para><para><emphasis role="bold">Note</emphasis>: Does not affect the validity of iterators and references of previous values. </para></description></method>
<method name="pop_front"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the first element from the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="erase_after"><type>iterator</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element after the element pointed by prev_p of the list.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Does not invalidate iterators or references to non erased elements. </para></description></method>
<method name="erase_after"><type>iterator</type><parameter name="before_first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the range (before_first, last) from the list.</para><para><emphasis role="bold">Returns</emphasis>: the first element remaining beyond the removed elements, or end() if no such element exists.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of erased elements.</para><para><emphasis role="bold">Note</emphasis>: Does not invalidate iterators or references to non erased elements. </para></description></method>
<method name="swap" cv="noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value))"><type>void</type><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements on *this and x. </para></description></method>
<method name="clear"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the list. </para></description></method>
<method name="splice_after" cv="noexcept"><type>void</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by the list. x != *this</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, after the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: std::runtime_error if this' allocator and x's allocator are not equal.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in x.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice_after" cv="noexcept"><type>void</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by the list. x != *this</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, after the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: std::runtime_error if this' allocator and x's allocator are not equal.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements in x.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice_after" cv="noexcept"><type>void</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="prev"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_p must be a valid iterator of this. i must point to an element contained in list x. this' allocator and x's allocator shall compare equal.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the value pointed by i, from list x to this list, after the element pointed by prev_p. If prev_p == prev or prev_p == ++prev, this function is a null operation.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice_after" cv="noexcept"><type>void</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><parameter name="prev"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_p must be a valid iterator of this. i must point to an element contained in list x. this' allocator and x's allocator shall compare equal.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the value pointed by i, from list x to this list, after the element pointed by prev_p. If prev_p == prev or prev_p == ++prev, this function is a null operation.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice_after" cv="noexcept"><type>void</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="before_first"><paramtype>const_iterator</paramtype></parameter><parameter name="before_last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_p must be a valid iterator of this. before_first and before_last must be valid iterators of x. prev_p must not be contained in [before_first, before_last) range. this' allocator and x's allocator shall compare equal.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range [before_first + 1, before_last + 1) from list x to this list, after the element pointed by prev_p.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of transferred elements.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice_after" cv="noexcept"><type>void</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><parameter name="before_first"><paramtype>const_iterator</paramtype></parameter><parameter name="before_last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_p must be a valid iterator of this. before_first and before_last must be valid iterators of x. prev_p must not be contained in [before_first, before_last) range. this' allocator and x's allocator shall compare equal.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range [before_first + 1, before_last + 1) from list x to this list, after the element pointed by prev_p.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of transferred elements.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice_after" cv="noexcept"><type>void</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="before_first"><paramtype>const_iterator</paramtype></parameter><parameter name="before_last"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_p must be a valid iterator of this. before_first and before_last must be valid iterators of x. prev_p must not be contained in [before_first, before_last) range. n == distance(before_first, before_last). this' allocator and x's allocator shall compare equal.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range [before_first + 1, before_last + 1) from list x to this list, after the element pointed by prev_p.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice_after" cv="noexcept"><type>void</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><parameter name="before_first"><paramtype>const_iterator</paramtype></parameter><parameter name="before_last"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: prev_p must be a valid iterator of this. before_first and before_last must be valid iterators of x. prev_p must not be contained in [before_first, before_last) range. n == distance(before_first, before_last). this' allocator and x's allocator shall compare equal.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range [before_first + 1, before_last + 1) from list x to this list, after the element pointed by prev_p.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="remove"><type>void</type><parameter name="value"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements that compare equal to value.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() comparisons for equality.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="remove_if"><type>void</type><template>
          <template-type-parameter name="Pred"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes all the elements for which a specified predicate is satisfied.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time. It performs exactly size() calls to the predicate.</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="unique"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that are equal from the list.</para><para><emphasis role="bold">Throws</emphasis>: If comparison throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1 comparisons equality comparisons).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="unique"><type>void</type><template>
          <template-type-parameter name="Pred"/>
        </template><parameter name="pred"><paramtype>Pred</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list.</para><para><emphasis role="bold">Throws</emphasis>: If pred throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear time (size()-1 comparisons calls to pred()).</para><para><emphasis role="bold">Note</emphasis>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </para></description></method>
<method name="merge"><type>void</type><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If comparison throws.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons. </para></description></method>
<method name="merge"><type>void</type><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If comparison throws.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="StrictWeakOrdering"/>
        </template><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="comp"><paramtype>StrictWeakOrdering</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If comp throws.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references to *this are not invalidated. </para></description></method>
<method name="merge"><type>void</type><template>
          <template-type-parameter name="StrictWeakOrdering"/>
        </template><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><parameter name="comp"><paramtype>StrictWeakOrdering</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</para><para><emphasis role="bold">Effects</emphasis>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</para><para><emphasis role="bold">Throws</emphasis>: If comp throws.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time: it performs at most size() + x.size() - 1 comparisons.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references to *this are not invalidated. </para></description></method>
<method name="sort"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: If comparison throws.</para><para><emphasis role="bold">Notes</emphasis>: Iterators and references are not invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size. </para></description></method>
<method name="sort"><type>void</type><template>
          <template-type-parameter name="StrictWeakOrdering"/>
        </template><parameter name="comp"><paramtype>StrictWeakOrdering</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</para><para><emphasis role="bold">Throws</emphasis>: If comp throws.</para><para><emphasis role="bold">Notes</emphasis>: Iterators and references are not invalidated.</para><para><emphasis role="bold">Complexity</emphasis>: The number of comparisons is approximately N log N, where N is the list's size. </para></description></method>
<method name="reverse" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Reverses the order of elements in the list.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: This function is linear time.</para><para><emphasis role="bold">Note</emphasis>: Iterators and references are not invalidated </para></description></method>
<method name="emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... before p</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's in-place constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements before p </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of x before p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or x's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="prev_p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a new element before p with x's resources.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts n copies of x before p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or p if n == 0.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n plus linear to the elements before p. </para></description></method>
<method name="insert"><type>iterator</type><template>
          <template-type-parameter name="InIter"/>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="first"><paramtype>InIter</paramtype></parameter><parameter name="last"><paramtype>InIter</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [first, last) range before p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or p if first == last.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to distance [first, last) plus linear to the elements before p. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [il.begin(), il.end()) range before p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or p if il.begin() == il.end().</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced std::initializer_list iterator throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [il.begin(), il.end()) plus linear to the elements before p. </para></description></method>
<method name="erase" cv="noexcept"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Erases the element at p.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements before p. </para></description></method>
<method name="erase" cv="noexcept"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first and last must be valid iterator to elements in *this.</para><para><emphasis role="bold">Effects</emphasis>: Erases the elements pointed by [first, last).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the distance between first and last plus linear to the elements before first. </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by the list. x != *this. this' allocator and x's allocator shall compare equal</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Linear in distance(begin(), p), and linear in x.size().</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by the list. x != *this. this' allocator and x's allocator shall compare equal</para><para><emphasis role="bold">Effects</emphasis>: Transfers all the elements of list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Linear in distance(begin(), p), and linear in x.size().</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. i must point to an element contained in list x. this' allocator and x's allocator shall compare equal</para><para><emphasis role="bold">Effects</emphasis>: Transfers the value pointed by i, from list x to this list, before the element pointed by p. No destructors or copy constructors are called. If p == i or p == ++i, this function is a null operation.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Linear in distance(begin(), p), and in distance(x.begin(), i).</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><parameter name="i"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. i must point to an element contained in list x. this' allocator and x's allocator shall compare equal.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the value pointed by i, from list x to this list, before the element pointed by p. No destructors or copy constructors are called. If p == i or p == ++i, this function is a null operation.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Linear in distance(begin(), p), and in distance(x.begin(), i).</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. first and last must point to elements contained in list x.</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range pointed by first and last from list x to this list, before the element pointed by p. No destructors or copy constructors are called. this' allocator and x's allocator shall compare equal.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Linear in distance(begin(), p), in distance(x.begin(), first), and in distance(first, last).</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
<method name="splice" cv="noexcept"><type>void</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must point to an element contained by this list. first and last must point to elements contained in list x. this' allocator and x's allocator shall compare equal</para><para><emphasis role="bold">Effects</emphasis>: Transfers the range pointed by first and last from list x to this list, before the element pointed by p. No destructors or copy constructors are called.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Linear in distance(begin(), p), in distance(x.begin(), first), and in distance(first, last).</para><para><emphasis role="bold">Note</emphasis>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; Allocator &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list taking the allocator as parameter.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list taking the allocator as parameter.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list and inserts n value-initialized value_types.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list that will use a copy of allocator a and inserts n copies of value.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const value_type &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list that will use a copy of allocator a and inserts n copies of value.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InpIt"/>
        </template><parameter name="first"><paramtype>InpIt</paramtype></parameter><parameter name="last"><paramtype>InpIt</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list that will use a copy of allocator a and inserts a copy of the range [first, last) in the list.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's constructor taking a dereferenced InIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [first, last). </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a list that will use a copy of allocator a and inserts a copy of the range [il.begin(), il.end()) in the list.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's constructor taking a dereferenced std::initializer_list iterator throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [il.begin(), il.end()). </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a list. <emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></constructor>
<constructor cv="noexcept"><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor. Moves x's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a list using the specified allocator.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor using the specified allocator. Moves x's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocation or value_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant if a == x.get_allocator(), linear otherwise. </para></description></constructor>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Destroys the list. All stored values are destroyed and used memory is deallocated.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements. </para></description></destructor>
<copy-assignment><type><classname>slist</classname> &amp;</type><parameter name="x"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this contain the same elements as x.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;size() == x.size(). *this contains a copy of each of x's elements.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in x. </para></description></copy-assignment>
<copy-assignment cv="noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value))"><type><classname>slist</classname> &amp;</type><parameter name="x"><paramtype><classname>slist</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this contain the same elements as x.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;size() == x.size(). *this contains a copy of each of x's elements.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type's move constructor throws)</para><para><emphasis role="bold">Complexity</emphasis>: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this-&gt;get&gt;allocator() == x.get_allocator(). Linear otherwise. </para></description></copy-assignment>
<copy-assignment><type><classname>slist</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this contain the same elements as in il.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;size() == il.size(). *this contains a copy of each of il's elements.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type's move constructor throws) </para></description></copy-assignment>
<method-group name="friend functions">
<method name="operator=="><type>friend bool</type><parameter name="x"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are equal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator!="><type>friend bool</type><parameter name="x"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are unequal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="swap"><type>friend void</type><parameter name="x"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>slist</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y)</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
</method-group>
</class>

























































</namespace>
</namespace>
<namespace name="std">
<class-specialization name="insert_iterator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Allocator"/>
    </template><specialization><template-arg>boost::container::slist&lt; T</template-arg><template-arg>Allocator &gt;</template-arg></specialization><description><para>A specialization of insert_iterator that works with slist </para></description><typedef name="container_type"><type><classname>Container</classname></type></typedef>
<typedef name="iterator_category"><type>output_iterator_tag</type></typedef>
<typedef name="value_type"><type>void</type></typedef>
<typedef name="difference_type"><type>void</type></typedef>
<typedef name="pointer"><type>void</type></typedef>
<typedef name="reference"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator*"><type>insert_iterator&lt; <classname>Container</classname> &gt; &amp;</type></method>
<method name="operator++"><type>insert_iterator&lt; <classname>Container</classname> &gt; &amp;</type></method>
<method name="operator++"><type>insert_iterator&lt; <classname>Container</classname> &gt; &amp;</type><parameter name=""><paramtype>int</paramtype></parameter></method>
</method-group>
<constructor><parameter name="x"><paramtype><classname>Container</classname> &amp;</paramtype></parameter><parameter name="i"><paramtype>typename Container::iterator</paramtype></parameter><parameter name="is_previous"><paramtype>bool</paramtype><default>false</default></parameter></constructor>
<copy-assignment><type>insert_iterator&lt; <classname>Container</classname> &gt; &amp;</type><parameter name="value"><paramtype>const typename Container::value_type &amp;</paramtype></parameter></copy-assignment>
</class-specialization></namespace>
</header>
<header name="boost/container/pmr/slist.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<struct name="slist_of"><template>
      <template-type-parameter name="T"/>
    </template><description><para>A portable metafunction to obtain a slist that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::slist</classname>&lt; T, <classname>polymorphic_allocator</classname>&lt; T &gt; &gt;</type></typedef>
</struct><typedef name="slist"><type><classname>boost::container::slist</classname>&lt; T, <classname>polymorphic_allocator</classname>&lt; T &gt;&gt;</type></typedef>






</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/small_vector.hpp">
<namespace name="boost">
<namespace name="container">
<class name="small_vector_allocator"><template>
      <template-type-parameter name="Allocator"/>
    </template><inherit access="public">Allocator</inherit><description><para>A non-standard allocator used to implement <computeroutput><classname alt="boost::container::small_vector">small_vector</classname></computeroutput>. Users should never use it directly. It is described here for documentation purposes.</para><para>This allocator inherits from a standard-conforming allocator and forwards member functions to the standard allocator except when internal storage is being used as memory source.</para><para>This allocator is a "partially_propagable" allocator and defines <computeroutput>is_partially_propagable</computeroutput> as true_type.</para><para>A partially propagable allocator means that not all storage allocatod by an instance of <computeroutput><classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname></computeroutput> can be deallocated by another instance of this type, even if both instances compare equal or an instance is propagated to another one using the copy/move constructor or assignment. The storage that can never be propagated is identified by <computeroutput>storage_is_unpropagable(p)</computeroutput>.</para><para><computeroutput><classname alt="boost::container::vector">boost::container::vector</classname></computeroutput> supports partially propagable allocators fallbacking to deep copy/swap/move operations when internal storage is being used to store vector elements.</para><para><computeroutput><classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname></computeroutput> assumes that will be instantiated as <computeroutput><classname alt="boost::container::vector">boost::container::vector</classname>&lt; T, <classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname>&lt;Allocator&gt; &gt;</computeroutput> and internal storage can be obtained downcasting that vector to <computeroutput><classname alt="boost::container::small_vector_base">small_vector_base</classname>&lt;T&gt;</computeroutput>. </para></description><struct name="rebind"><template>
      <template-type-parameter name="T2"/>
    </template><description><para>Obtains an <classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname> that allocates objects of type T2 </para></description><typedef name="other"><type><classname>allocator_traits</classname>&lt; Allocator &gt;::template rebind_alloc&lt; T2 &gt;::type</type></typedef>
</struct><typedef name="value_type"><type><classname>allocator_traits</classname>&lt; Allocator &gt;::value_type</type></typedef>
<typedef name="pointer"><type><classname>allocator_traits</classname>&lt; Allocator &gt;::pointer</type></typedef>
<typedef name="const_pointer"><type><classname>allocator_traits</classname>&lt; Allocator &gt;::const_pointer</type></typedef>
<typedef name="reference"><type><classname>allocator_traits</classname>&lt; Allocator &gt;::reference</type></typedef>
<typedef name="const_reference"><type><classname>allocator_traits</classname>&lt; Allocator &gt;::const_reference</type></typedef>
<typedef name="size_type"><type><classname>allocator_traits</classname>&lt; Allocator &gt;::size_type</type></typedef>
<typedef name="difference_type"><type><classname>allocator_traits</classname>&lt; Allocator &gt;::difference_type</type></typedef>
<typedef name="void_pointer"><type><classname>allocator_traits</classname>&lt; Allocator &gt;::void_pointer</type></typedef>
<typedef name="const_void_pointer"><type><classname>allocator_traits</classname>&lt; Allocator &gt;::const_void_pointer</type></typedef>
<typedef name="propagate_on_container_copy_assignment"><type><classname>allocator_traits</classname>&lt; Allocator &gt;::propagate_on_container_copy_assignment</type></typedef>
<typedef name="propagate_on_container_move_assignment"><type><classname>allocator_traits</classname>&lt; Allocator &gt;::propagate_on_container_move_assignment</type></typedef>
<typedef name="propagate_on_container_swap"><type><classname>allocator_traits</classname>&lt; Allocator &gt;::propagate_on_container_swap</type></typedef>
<typedef name="is_always_equal"><purpose>An integral constant with member <computeroutput>value == false</computeroutput> </purpose><type>implementation_defined</type></typedef>
<typedef name="is_partially_propagable"><purpose>An integral constant with member <computeroutput>value == true</computeroutput> </purpose><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="allocate"><type>pointer</type><parameter name="count"><paramtype>size_type</paramtype></parameter><parameter name="hint"><paramtype>const_void_pointer</paramtype><default>const_void_pointer()</default></parameter><purpose>Allocates storage from the standard-conforming allocator. </purpose></method>
<method name="deallocate" cv="noexcept"><type>void</type><parameter name="ptr"><paramtype>pointer</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para>Deallocates previously allocated memory. Never throws </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para>Returns the maximum number of elements that could be allocated. Never throws </para></description></method>
<method name="select_on_container_copy_construction" cv="const"><type><classname>small_vector_allocator</classname></type></method>
<method name="storage_is_unpropagable" cv="const"><type>bool</type><parameter name="p"><paramtype>pointer</paramtype></parameter></method>
</method-group>
<constructor specifiers="explicit"><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><purpose>Constructor from arbitrary arguments. </purpose></constructor>
<constructor cv="noexcept"><parameter name="other"><paramtype>const <classname>small_vector_allocator</classname> &amp;</paramtype></parameter><description><para>Constructor from other <classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname>. Never throws </para></description></constructor>
<constructor cv="noexcept"><parameter name="other"><paramtype><classname>small_vector_allocator</classname> &amp;&amp;</paramtype></parameter><description><para>Move constructor from <classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname>. Never throws </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="OtherAllocator"/>
        </template><parameter name="other"><paramtype>const <classname>small_vector_allocator</classname>&lt; OtherAllocator &gt; &amp;</paramtype></parameter><description><para>Constructor from related <classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname>. Never throws </para></description></constructor>
<constructor cv="noexcept"><template>
          <template-type-parameter name="OtherAllocator"/>
        </template><parameter name="other"><paramtype><classname>small_vector_allocator</classname>&lt; OtherAllocator &gt; &amp;&amp;</paramtype></parameter><description><para>Move constructor from related <classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname>. Never throws </para></description></constructor>
<copy-assignment cv="noexcept"><type><classname>small_vector_allocator</classname> &amp;</type><parameter name="other"><paramtype>const <classname>small_vector_allocator</classname> &amp;</paramtype></parameter><description><para>Assignment from other <classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname>. Never throws </para></description></copy-assignment>
<copy-assignment cv="noexcept"><type><classname>small_vector_allocator</classname> &amp;</type><parameter name="other"><paramtype><classname>small_vector_allocator</classname> &amp;&amp;</paramtype></parameter><description><para>Move constructor from other <classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname>. Never throws </para></description></copy-assignment>
<copy-assignment cv="noexcept"><type><classname>small_vector_allocator</classname> &amp;</type><template>
          <template-type-parameter name="OtherAllocator"/>
        </template><parameter name="other"><paramtype>const <classname>small_vector_allocator</classname>&lt; OtherAllocator &gt; &amp;</paramtype></parameter><description><para>Assignment from related <classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname>. Never throws </para></description></copy-assignment>
<copy-assignment cv="noexcept"><type><classname>small_vector_allocator</classname> &amp;</type><template>
          <template-type-parameter name="OtherAllocator"/>
        </template><parameter name="other"><paramtype><classname>small_vector_allocator</classname>&lt; OtherAllocator &gt; &amp;&amp;</paramtype></parameter><description><para>Move assignment from related <classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname>. Never throws </para></description></copy-assignment>
<method-group name="friend functions">
<method name="swap" cv="noexcept"><type>friend void</type><parameter name="l"><paramtype><classname>small_vector_allocator</classname> &amp;</paramtype></parameter><parameter name="r"><paramtype><classname>small_vector_allocator</classname> &amp;</paramtype></parameter><description><para>Swaps two allocators, does nothing because this <classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname> is stateless </para></description></method>
<method name="operator==" cv="noexcept"><type>friend bool</type><parameter name="l"><paramtype>const <classname>small_vector_allocator</classname> &amp;</paramtype></parameter><parameter name="r"><paramtype>const <classname>small_vector_allocator</classname> &amp;</paramtype></parameter><description><para>An <classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname> always compares to true, as memory allocated with one instance can be deallocated by another instance (except for unpropagable storage) </para></description></method>
<method name="operator!=" cv="noexcept"><type>friend bool</type><parameter name="l"><paramtype>const <classname>small_vector_allocator</classname> &amp;</paramtype></parameter><parameter name="r"><paramtype>const <classname>small_vector_allocator</classname> &amp;</paramtype></parameter><description><para>An <classname alt="boost::container::small_vector_allocator">small_vector_allocator</classname> always compares to false, as memory allocated with one instance can be deallocated by another instance </para></description></method>
</method-group>
</class><class name="small_vector_base"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="SecondaryAllocator"/>
    </template><inherit access="public">boost::container::vector&lt; T, small_vector_allocator&lt; SecondaryAllocator &gt; &gt;</inherit><description><para>This class consists of common code from all small_vector&lt;T, N&gt; types that don't depend on the "N" template parameter. This class is non-copyable and non-destructible, so this class typically used as reference argument to functions that read or write small vectors. Since <computeroutput><classname alt="boost::container::small_vector">small_vector</classname>&lt;T, N&gt;</computeroutput> derives from <computeroutput><classname alt="boost::container::small_vector_base">small_vector_base</classname>&lt;T&gt;</computeroutput>, the conversion to <computeroutput><classname alt="boost::container::small_vector_base">small_vector_base</classname></computeroutput> is implicit </para><programlisting>//Clients can pass any small_vector&lt;Foo, N&gt;.
void read_any_small_vector_of_foo(const small_vector_base&lt;Foo&gt; &amp;in_parameter);

void modify_any_small_vector_of_foo(small_vector_base&lt;Foo&gt; &amp;in_out_parameter);

void some_function()
{

   small_vector&lt;Foo, 8&gt; myvector;

   read_any_small_vector_of_foo(myvector);   // Reads myvector

   modify_any_small_vector_of_foo(myvector); // Modifies myvector

}
</programlisting><para>All <computeroutput>boost::container:vector</computeroutput> member functions are inherited. See <computeroutput>vector</computeroutput> documentation for details. </para></description><method-group name="public member functions">
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>small_vector_base</classname> &amp;</paramtype></parameter></method>
</method-group>
<copy-assignment><type><classname>small_vector_base</classname> &amp;</type><parameter name="other"><paramtype>const <classname>small_vector_base</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>small_vector_base</classname> &amp;</type><parameter name="other"><paramtype><classname>small_vector_base</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
</class><class name="small_vector"><template>
      <template-type-parameter name="T"><purpose><para>The type of object that is stored in the <classname alt="boost::container::small_vector">small_vector</classname> </para></purpose></template-type-parameter>
      <template-nontype-parameter name="N"><type>std::size_t</type><purpose><para>The number of preallocated elements stored inside <classname alt="boost::container::small_vector">small_vector</classname>. It shall be less than Allocator::max_size(); </para></purpose></template-nontype-parameter>
      <template-type-parameter name="Allocator"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt;T&gt;</default><purpose><para>The allocator used for memory management when the number of elements exceeds N. </para></purpose></template-type-parameter>
    </template><inherit access="public">boost::container::small_vector_base&lt; T, Allocator &gt;</inherit><description><para><classname alt="boost::container::small_vector">small_vector</classname> is a vector-like container optimized for the case when it contains few elements. It contains some preallocated elements in-place, which can avoid the use of dynamic storage allocation when the actual number of elements is below that preallocated threshold.</para><para><computeroutput><classname alt="boost::container::small_vector">small_vector</classname>&lt;T, N, Allocator&gt;</computeroutput> is convertible to <computeroutput><classname alt="boost::container::small_vector_base">small_vector_base</classname>&lt;T, Allocator&gt;</computeroutput> that is independent from the preallocated element capacity, so client code does not need to be templated on that N argument.</para><para>All <computeroutput><classname alt="boost::container::vector">boost::container::vector</classname></computeroutput> member functions are inherited. See <computeroutput>vector</computeroutput> documentation for details.</para><para>
</para></description><method-group name="public member functions">
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>small_vector</classname> &amp;</paramtype></parameter></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; Allocator &gt;::value))"/>
<constructor specifiers="explicit"><parameter name="a"><paramtype>const <classname>allocator_type</classname> &amp;</paramtype></parameter></constructor>
<constructor specifiers="explicit"><parameter name="n"><paramtype>size_type</paramtype></parameter></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="a"><paramtype>const <classname>allocator_type</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><parameter name="a"><paramtype>const <classname>allocator_type</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="v"><paramtype>const value_type &amp;</paramtype></parameter></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="v"><paramtype>const value_type &amp;</paramtype></parameter><parameter name="a"><paramtype>const <classname>allocator_type</classname> &amp;</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="InIt"/>
        </template><parameter name="first"><paramtype>InIt</paramtype></parameter><parameter name="BOOST_CONTAINER_DOCIGN"><paramtype>InIt last </paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="InIt"/>
        </template><parameter name="first"><paramtype>InIt</paramtype></parameter><parameter name="last"><paramtype>InIt</paramtype></parameter><parameter name="BOOST_CONTAINER_DOCIGN"><paramtype>const <classname>allocator_type</classname> &amp;a </paramtype></parameter></constructor>
<constructor><parameter name="other"><paramtype>const <classname>small_vector</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="other"><paramtype>const <classname>small_vector</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const <classname>allocator_type</classname> &amp;</paramtype></parameter></constructor>
<constructor specifiers="explicit"><parameter name="other"><paramtype>const base_type &amp;</paramtype></parameter></constructor>
<constructor specifiers="explicit"><parameter name="other"><paramtype>base_type &amp;&amp;</paramtype></parameter></constructor>
<constructor><parameter name="other"><paramtype><classname>small_vector</classname> &amp;&amp;</paramtype></parameter></constructor>
<constructor><parameter name="other"><paramtype><classname>small_vector</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const <classname>allocator_type</classname> &amp;</paramtype></parameter></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const <classname>allocator_type</classname> &amp;</paramtype><default><classname alt="boost::container::small_vector_allocator">allocator_type</classname>()</default></parameter></constructor>
<copy-assignment><type><classname>small_vector</classname> &amp;</type><parameter name="other"><paramtype>const <classname>small_vector</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>small_vector</classname> &amp;</type><parameter name="other"><paramtype><classname>small_vector</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>small_vector</classname> &amp;</type><parameter name="other"><paramtype>const base_type &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>small_vector</classname> &amp;</type><parameter name="other"><paramtype>base_type &amp;&amp;</paramtype></parameter></copy-assignment>
</class>

























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/small_vector.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<struct name="small_vector_of"><template>
      <template-type-parameter name="T"/>
      <template-nontype-parameter name="N"><type>std::size_t</type></template-nontype-parameter>
    </template><description><para>A portable metafunction to obtain a <classname alt="boost::container::small_vector">small_vector</classname> that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::small_vector</classname>&lt; T, N, <classname>polymorphic_allocator</classname>&lt; T &gt; &gt;</type></typedef>
</struct><typedef name="small_vector"><type><classname>boost::container::small_vector</classname>&lt; T, N, <classname>polymorphic_allocator</classname>&lt; T &gt;&gt;</type></typedef>






</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/stable_vector.hpp">
<namespace name="boost">
<namespace name="container">
<class name="stable_vector"><template>
      <template-type-parameter name="T"><purpose><para>The type of object that is stored in the <classname alt="boost::container::stable_vector">stable_vector</classname> </para></purpose></template-type-parameter>
      <template-type-parameter name="Allocator"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt;T&gt;</default><purpose><para>The allocator used for all internal memory management </para></purpose></template-type-parameter>
    </template><description><para>Originally developed by Joaquin M. Lopez Munoz, <classname alt="boost::container::stable_vector">stable_vector</classname> is a std::vector drop-in replacement implemented as a node container, offering iterator and reference stability.</para><para>Here are the details taken from the author's blog (<ulink url="http://bannalia.blogspot.com/2008/09/introducing-stablevector.html">Introducing stable_vector</ulink>):</para><para>We present <classname alt="boost::container::stable_vector">stable_vector</classname>, a fully STL-compliant stable container that provides most of the features of std::vector except element contiguity.</para><para>General properties: <classname alt="boost::container::stable_vector">stable_vector</classname> satisfies all the requirements of a container, a reversible container and a sequence and provides all the optional operations present in std::vector. Like std::vector, iterators are random access. <classname alt="boost::container::stable_vector">stable_vector</classname> does not provide element contiguity; in exchange for this absence, the container is stable, i.e. references and iterators to an element of a <classname alt="boost::container::stable_vector">stable_vector</classname> remain valid as long as the element is not erased, and an iterator that has been assigned the return value of end() always remain valid until the destruction of the associated <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para>Operation complexity: The big-O complexities of <classname alt="boost::container::stable_vector">stable_vector</classname> operations match exactly those of std::vector. In general, insertion/deletion is constant time at the end of the sequence and linear elsewhere. Unlike std::vector, <classname alt="boost::container::stable_vector">stable_vector</classname> does not internally perform any value_type destruction, copy or assignment operations other than those exactly corresponding to the insertion of new elements or deletion of stored elements, which can sometimes compensate in terms of performance for the extra burden of doing more pointer manipulation and an additional allocation per element.</para><para>Exception safety: As <classname alt="boost::container::stable_vector">stable_vector</classname> does not internally copy elements around, some operations provide stronger exception safety guarantees than in std::vector.</para><para>
</para></description><typedef name="value_type"><type>T</type></typedef>
<typedef name="pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::pointer</type></typedef>
<typedef name="const_pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_pointer</type></typedef>
<typedef name="reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::reference</type></typedef>
<typedef name="const_reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_reference</type></typedef>
<typedef name="size_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::size_type</type></typedef>
<typedef name="difference_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::difference_type</type></typedef>
<typedef name="allocator_type"><type>Allocator</type></typedef>
<typedef name="stored_allocator_type"><type>node_allocator_type</type></typedef>
<typedef name="iterator"><type>implementation_defined</type></typedef>
<typedef name="const_iterator"><type>implementation_defined</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="assign"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="t"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the n copies of val to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="assign"><type>void</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the the range [first, last) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's constructor from dereferencing InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="assign"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the the range [il.begin(), il.end()) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's constructor from dereferencing initializer_list iterator throws. </para></description></method>
<method name="get_allocator" cv="const"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: If allocator's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator" cv="const noexcept"><type>const stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="noexcept"><type>stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="begin" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="empty" cv="const noexcept"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the <classname alt="boost::container::stable_vector">stable_vector</classname> contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="resize"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are value initialized.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's value initialization throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method>
<method name="resize"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are default initialized.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's default initialization throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="resize"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="t"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are copy constructed from x.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method>
<method name="capacity" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="reserve"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If n is less than or equal to capacity(), this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation allocation throws. </para></description></method>
<method name="shrink_to_fit"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Tries to deallocate the excess of memory created with previous allocations. The size of the <classname alt="boost::container::stable_vector">stable_vector</classname> is unchanged</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size(). </para></description></method>
<method name="front" cv="noexcept"><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="front" cv="const noexcept"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the first element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="back" cv="noexcept"><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the last element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="back" cv="const noexcept"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the last element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="operator[]" cv="noexcept"><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="operator[]" cv="const noexcept"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="nth" cv="noexcept"><type>iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="nth" cv="const noexcept"><type>const_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="noexcept"><type>size_type</type><parameter name="p"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="const noexcept"><type>size_type</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="at"><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: std::range_error if n &gt;= size()</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="at" cv="const"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: std::range_error if n &gt;= size()</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="emplace_back"><type>reference</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the end of the <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Returns</emphasis>: A reference to the created object.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or the in-place constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... before p</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or the in-place constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: If p is end(), amortized constant time Linear time otherwise. </para></description></method>
<method name="push_back"><type>void</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x at the end of the <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="push_back"><type>void</type><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a new element in the end of the <classname alt="boost::container::stable_vector">stable_vector</classname> and moves the resources of x to this new element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of x before p.</para><para><emphasis role="bold">Returns</emphasis>: An iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or x's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: If p is end(), amortized constant time Linear time otherwise. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a new element before p with x's resources.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the inserted element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: If p is end(), amortized constant time Linear time otherwise. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="t"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert n copies of x before p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or p if n is 0.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><purpose><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this. </purpose><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [il.begin(), il.end()) range before p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or p if first == last.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to distance [il.begin(), il.end()). </para></description></method>
<method name="insert"><type>iterator</type><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [first, last) range before p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or p if first == last.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced InpIt throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to distance [first, last). </para></description></method>
<method name="pop_back" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the last element from the <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time. </para></description></method>
<method name="erase" cv="noexcept"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element at p.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements between p and the last element. Constant if p is the last element. </para></description></method>
<method name="erase" cv="noexcept"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the elements pointed by [first, last).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the distance between first and last plus linear to the elements between p and the last element. </para></description></method>
<method name="swap" cv="noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value))"><type>void</type><parameter name="x"><paramtype><classname>stable_vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="clear" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the <classname alt="boost::container::stable_vector">stable_vector</classname>. </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; Allocator &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Default constructs a <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><parameter name="al"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::stable_vector">stable_vector</classname> taking the allocator as parameter.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::stable_vector">stable_vector</classname> and inserts n value initialized values.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::stable_vector">stable_vector</classname> and inserts n default initialized values.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></constructor>
<constructor specifiers="explicit"><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::stable_vector">stable_vector</classname> that will use a copy of allocator a and inserts n value initialized values.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::stable_vector">stable_vector</classname> that will use a copy of allocator a and inserts n default initialized values.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="t"><paramtype>const T &amp;</paramtype></parameter><parameter name="al"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::stable_vector">stable_vector</classname> that will use a copy of allocator a and inserts n copies of value.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's default or copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="first"><paramtype>InputIterator</paramtype></parameter><parameter name="last"><paramtype>InputIterator</paramtype></parameter><parameter name="al"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::stable_vector">stable_vector</classname> that will use a copy of allocator a and inserts a copy of the range [first, last) in the <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's constructor taking a dereferenced InIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [first, last). </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a <classname alt="boost::container::stable_vector">stable_vector</classname>.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="l"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::stable_vector">stable_vector</classname> that will use a copy of allocator a and inserts a copy of the range [il.begin(), il.last()) in the <classname alt="boost::container::stable_vector">stable_vector</classname></para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws or T's constructor taking a dereferenced initializer_list iterator throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [il.begin(), il.end()). </para></description></constructor>
<constructor cv="noexcept"><parameter name="x"><paramtype><classname>stable_vector</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor. Moves x's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a <classname alt="boost::container::stable_vector">stable_vector</classname> using the specified allocator.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>stable_vector</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor using the specified allocator. Moves x's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant if a == x.get_allocator(), linear otherwise </para></description></constructor>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Destroys the <classname alt="boost::container::stable_vector">stable_vector</classname>. All stored values are destroyed and used memory is deallocated.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements. </para></description></destructor>
<copy-assignment><type><classname>stable_vector</classname> &amp;</type><parameter name="x"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this contain the same elements as x.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;size() == x.size(). *this contains a copy of each of x's elements.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in x. </para></description></copy-assignment>
<copy-assignment cv="noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value))"><type><classname>stable_vector</classname> &amp;</type><parameter name="x"><paramtype><classname>stable_vector</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move assignment. All x's values are transferred to *this.</para><para><emphasis role="bold">Postcondition</emphasis>: x.empty(). *this contains a the elements x had before the function.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or T's move constructor throws)</para><para><emphasis role="bold">Complexity</emphasis>: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this-&gt;get&gt;allocator() == x.get_allocator(). Linear otherwise. </para></description></copy-assignment>
<copy-assignment><type><classname>stable_vector</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Make *this container contains elements from il.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [il.begin(), il.end()). </para></description></copy-assignment>
<method-group name="friend functions">
<method name="operator=="><type>friend bool</type><parameter name="x"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are equal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator!="><type>friend bool</type><parameter name="x"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are unequal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>stable_vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="swap"><type>friend void</type><parameter name="x"><paramtype><classname>stable_vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>stable_vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y)</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
</method-group>
</class>

























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/stable_vector.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<struct name="stable_vector_of"><template>
      <template-type-parameter name="T"/>
    </template><description><para>A portable metafunction to obtain a <classname alt="boost::container::stable_vector">stable_vector</classname> that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::stable_vector</classname>&lt; T, <classname>polymorphic_allocator</classname>&lt; T &gt; &gt;</type></typedef>
</struct><typedef name="stable_vector"><type><classname>boost::container::stable_vector</classname>&lt; T, <classname>polymorphic_allocator</classname>&lt; T &gt;&gt;</type></typedef>






</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/static_vector.hpp">
<namespace name="boost">
<namespace name="container">
<class name="static_vector"><template>
      <template-type-parameter name="Value"><purpose><para>The type of element that will be stored. </para></purpose></template-type-parameter>
      <template-nontype-parameter name="Capacity"><type>std::size_t</type><purpose><para>The maximum number of elements <classname alt="boost::container::static_vector">static_vector</classname> can store, fixed at compile time. </para></purpose></template-nontype-parameter>
    </template><inherit access="public">boost::container::vector&lt; Value, dtl::static_storage_allocator&lt; Value, Capacity &gt; &gt;</inherit><purpose>A variable-size array container with fixed capacity. </purpose><description><para><classname alt="boost::container::static_vector">static_vector</classname> is a sequence container like <classname alt="boost::container::vector">boost::container::vector</classname> with contiguous storage that can change in size, along with the static allocation, low overhead, and fixed capacity of boost::array.</para><para>A <classname alt="boost::container::static_vector">static_vector</classname> is a sequence that supports random access to elements, constant time insertion and removal of elements at the end, and linear time insertion and removal of elements at the beginning or in the middle. The number of elements in a <classname alt="boost::container::static_vector">static_vector</classname> may vary dynamically up to a fixed capacity because elements are stored within the object itself similarly to an array. However, objects are initialized as they are inserted into <classname alt="boost::container::static_vector">static_vector</classname> unlike C arrays or std::array which must construct all elements on instantiation. The behavior of <classname alt="boost::container::static_vector">static_vector</classname> enables the use of statically allocated elements in cases with complex object lifetime requirements that would otherwise not be trivially possible.</para><para><formalpara><title>Error Handling</title><para>Insertion beyond the capacity result in throwing std::bad_alloc() if exceptions are enabled or calling throw_bad_alloc() if not enabled.</para></formalpara>
std::out_of_range is thrown if out of bound access is performed in <computeroutput>at()</computeroutput> if exceptions are enabled, throw_out_of_range() if not enabled.</para><para>
</para></description><typedef name="value_type"><purpose>The type of elements stored in the container. </purpose><type>base_t::value_type</type></typedef>
<typedef name="size_type"><purpose>The unsigned integral type used by the container. </purpose><type>base_t::size_type</type></typedef>
<typedef name="difference_type"><purpose>The pointers difference type. </purpose><type>base_t::difference_type</type></typedef>
<typedef name="pointer"><purpose>The pointer type. </purpose><type>base_t::pointer</type></typedef>
<typedef name="const_pointer"><purpose>The const pointer type. </purpose><type>base_t::const_pointer</type></typedef>
<typedef name="reference"><purpose>The value reference type. </purpose><type>base_t::reference</type></typedef>
<typedef name="const_reference"><purpose>The value const reference type. </purpose><type>base_t::const_reference</type></typedef>
<typedef name="iterator"><purpose>The iterator type. </purpose><type>base_t::iterator</type></typedef>
<typedef name="const_iterator"><purpose>The const iterator type. </purpose><type>base_t::const_iterator</type></typedef>
<typedef name="reverse_iterator"><purpose>The reverse iterator type. </purpose><type>base_t::reverse_iterator</type></typedef>
<typedef name="const_reverse_iterator"><purpose>The const reverse iterator. </purpose><type>base_t::const_reverse_iterator</type></typedef>
<data-member name="static_capacity" specifiers="static"><type>const size_type</type><purpose>The capacity/max size of the container. </purpose></data-member>
<method-group name="public member functions">
<method name="swap"><type>void</type><parameter name="other"><paramtype><classname>static_vector</classname> &amp;</paramtype><description><para>The <classname alt="boost::container::static_vector">static_vector</classname> which content will be swapped with this one's content.</para></description></parameter><purpose>Swaps contents of the other <classname alt="boost::container::static_vector">static_vector</classname> and this one. </purpose><description><para>
<formalpara><title>Throws</title><para><itemizedlist>
<listitem><para>If <computeroutput>has_nothrow_move&lt;Value&gt;::value</computeroutput> is <computeroutput>true</computeroutput> and Value's move constructor or move assignment throws, </para></listitem>
<listitem><para>If <computeroutput>has_nothrow_move&lt;Value&gt;::value</computeroutput> is <computeroutput>false</computeroutput> and Value's copy constructor or copy assignment throws,</para></listitem>
</itemizedlist>
</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description></method>
<method name="swap"><type>void</type><template>
          <template-nontype-parameter name="C"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="other"><paramtype><classname>static_vector</classname>&lt; value_type, C &gt; &amp;</paramtype><description><para>The <classname alt="boost::container::static_vector">static_vector</classname> which content will be swapped with this one's content.</para></description></parameter><purpose>Swaps contents of the other <classname alt="boost::container::static_vector">static_vector</classname> and this one. </purpose><description><para>

<formalpara><title>Throws</title><para><itemizedlist>
<listitem><para>If <computeroutput>has_nothrow_move&lt;Value&gt;::value</computeroutput> is <computeroutput>true</computeroutput> and Value's move constructor or move assignment throws, </para></listitem>
<listitem><para>If <computeroutput>has_nothrow_move&lt;Value&gt;::value</computeroutput> is <computeroutput>false</computeroutput> and Value's copy constructor or copy assignment throws,</para></listitem>
</itemizedlist>
</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>other.size() &lt;= capacity() &amp;&amp; size() &lt;= other.capacity()</computeroutput></para></requires></method>
<method name="resize"><type>void</type><parameter name="count"><paramtype>size_type</paramtype><description><para>The number of elements which will be stored in the container.</para></description></parameter><purpose>Inserts or erases elements at the end such that the size becomes count. New elements are value initialized. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's value initialization throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>count &lt;= capacity()</computeroutput></para></requires></method>
<method name="resize"><type>void</type><parameter name="count"><paramtype>size_type</paramtype><description><para>The number of elements which will be stored in the container.</para></description></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><purpose>Inserts or erases elements at the end such that the size becomes count. New elements are default initialized. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's default initialization throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N).</para></formalpara>
<formalpara><title>Note</title><para>Non-standard extension </para></formalpara>
</para></description><requires><para><computeroutput>count &lt;= capacity()</computeroutput></para></requires></method>
<method name="resize"><type>void</type><parameter name="count"><paramtype>size_type</paramtype><description><para>The number of elements which will be stored in the container. </para></description></parameter><parameter name="value"><paramtype>value_type const &amp;</paramtype><description><para>The value used to copy construct the new element.</para></description></parameter><purpose>Inserts or erases elements at the end such that the size becomes count. New elements are copy constructed from value. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's copy constructor throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>count &lt;= capacity()</computeroutput></para></requires></method>
<method name="reserve" cv="noexcept"><type>void</type><parameter name="count"><paramtype>size_type</paramtype><description><para>The number of elements which the container should be able to contain.</para></description></parameter><purpose>This call has no effect because the Capacity of this container is constant. </purpose><description><para>

<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>count &lt;= capacity()</computeroutput></para></requires></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>value_type const &amp;</paramtype><description><para>The value used to copy construct the new element.</para></description></parameter><purpose>Adds a copy of value at the end. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's copy constructor throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>size() &lt; capacity()</computeroutput></para></requires></method>
<method name="push_back"><type>void</type><parameter name="value"><paramtype>value_type &amp;&amp;</paramtype><description><para>The value to move construct the new element.</para></description></parameter><purpose>Moves value to the end. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's move constructor throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>size() &lt; capacity()</computeroutput></para></requires></method>
<method name="pop_back"><type>void</type><purpose>Destroys last value and decreases the size. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing by default.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>!empty()</computeroutput></para></requires></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype><description><para>The position at which the new value will be inserted. </para></description></parameter><parameter name="value"><paramtype>value_type const &amp;</paramtype><description><para>The value used to copy construct the new element.</para></description></parameter><purpose>Inserts a copy of element at p. </purpose><description><para>

<formalpara><title>Throws</title><para><itemizedlist>
<listitem><para>If Value's copy constructor or copy assignment throws </para></listitem>
<listitem><para>If Value's move constructor or move assignment throws.</para></listitem>
</itemizedlist>
</para></formalpara>
<formalpara><title>Complexity</title><para>Constant or linear. </para></formalpara>
</para></description><requires><para><itemizedlist>
<listitem><para><computeroutput>p</computeroutput> must be a valid iterator of <computeroutput>*this</computeroutput> in range <computeroutput>[begin(), end()]</computeroutput>. </para></listitem>
<listitem><para><computeroutput>size() &lt; capacity()</computeroutput></para></listitem>
</itemizedlist>
</para></requires></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype><description><para>The position at which the new value will be inserted. </para></description></parameter><parameter name="value"><paramtype>value_type &amp;&amp;</paramtype><description><para>The value used to move construct the new element.</para></description></parameter><purpose>Inserts a move-constructed element at p. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's move constructor or move assignment throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant or linear. </para></formalpara>
</para></description><requires><para><itemizedlist>
<listitem><para><computeroutput>p</computeroutput> must be a valid iterator of <computeroutput>*this</computeroutput> in range <computeroutput>[begin(), end()]</computeroutput>. </para></listitem>
<listitem><para><computeroutput>size() &lt; capacity()</computeroutput></para></listitem>
</itemizedlist>
</para></requires></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype><description><para>The position at which new elements will be inserted. </para></description></parameter><parameter name="count"><paramtype>size_type</paramtype><description><para>The number of new elements which will be inserted. </para></description></parameter><parameter name="value"><paramtype>value_type const &amp;</paramtype><description><para>The value used to copy construct new elements.</para></description></parameter><purpose>Inserts a count copies of value at p. </purpose><description><para>

<formalpara><title>Throws</title><para><itemizedlist>
<listitem><para>If Value's copy constructor or copy assignment throws. </para></listitem>
<listitem><para>If Value's move constructor or move assignment throws.</para></listitem>
</itemizedlist>
</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><itemizedlist>
<listitem><para><computeroutput>p</computeroutput> must be a valid iterator of <computeroutput>*this</computeroutput> in range <computeroutput>[begin(), end()]</computeroutput>. </para></listitem>
<listitem><para><computeroutput>size() + count &lt;= capacity()</computeroutput></para></listitem>
</itemizedlist>
</para></requires></method>
<method name="insert"><type>iterator</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="p"><paramtype>const_iterator</paramtype><description><para>The position at which new elements will be inserted. </para></description></parameter><parameter name="first"><paramtype>Iterator</paramtype><description><para>The iterator to the first element of a range used to construct new elements. </para></description></parameter><parameter name="last"><paramtype>Iterator</paramtype><description><para>The iterator to the one after the last element of a range used to construct new elements.</para></description></parameter><purpose>Inserts a copy of a range <computeroutput>[first, last)</computeroutput> at p. </purpose><description><para>

<formalpara><title>Throws</title><para><itemizedlist>
<listitem><para>If Value's constructor and assignment taking a dereferenced <computeroutput>Iterator</computeroutput>. </para></listitem>
<listitem><para>If Value's move constructor or move assignment throws.</para></listitem>
</itemizedlist>
</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><itemizedlist>
<listitem><para><computeroutput>p</computeroutput> must be a valid iterator of <computeroutput>*this</computeroutput> in range <computeroutput>[begin(), end()]</computeroutput>. </para></listitem>
<listitem><para><computeroutput>distance(first, last) &lt;= capacity()</computeroutput> </para></listitem>
<listitem><para><computeroutput>Iterator</computeroutput> must meet the <computeroutput>ForwardTraversalIterator</computeroutput> concept.</para></listitem>
</itemizedlist>
</para></requires></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype><description><para>The position at which new elements will be inserted. </para></description></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype><description><para>The std::initializer_list which contains elements that will be inserted.</para></description></parameter><purpose>Inserts a copy of a range <computeroutput>[il.begin(), il.end())</computeroutput> at p. </purpose><description><para>

<formalpara><title>Throws</title><para><itemizedlist>
<listitem><para>If Value's constructor and assignment taking a dereferenced std::initializer_list iterator.</para></listitem>
</itemizedlist>
</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><itemizedlist>
<listitem><para><computeroutput>p</computeroutput> must be a valid iterator of <computeroutput>*this</computeroutput> in range <computeroutput>[begin(), end()]</computeroutput>. </para></listitem>
<listitem><para><computeroutput>distance(il.begin(), il.end()) &lt;= capacity()</computeroutput></para></listitem>
</itemizedlist>
</para></requires></method>
<method name="erase"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype><description><para>The position of the element which will be erased from the container.</para></description></parameter><purpose>Erases Value from p. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's move assignment throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>p</computeroutput> must be a valid iterator of <computeroutput>*this</computeroutput> in range <computeroutput>[begin(), end())</computeroutput></para></requires></method>
<method name="erase"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype><description><para>The position of the first element of a range which will be erased from the container. </para></description></parameter><parameter name="last"><paramtype>const_iterator</paramtype><description><para>The position of the one after the last element of a range which will be erased from the container.</para></description></parameter><purpose>Erases Values from a range <computeroutput>[first, last)</computeroutput>. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's move assignment throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><itemizedlist>
<listitem><para><computeroutput>first</computeroutput> and <computeroutput>last</computeroutput> must define a valid range </para></listitem>
<listitem><para>iterators must be in range <computeroutput>[begin(), end()]</computeroutput></para></listitem>
</itemizedlist>
</para></requires></method>
<method name="assign"><type>void</type><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="first"><paramtype>Iterator</paramtype><description><para>The iterator to the first element of a range used to construct new content of this container. </para></description></parameter><parameter name="last"><paramtype>Iterator</paramtype><description><para>The iterator to the one after the last element of a range used to construct new content of this container.</para></description></parameter><purpose>Assigns a range <computeroutput>[first, last)</computeroutput> of Values to this container. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's copy constructor or copy assignment throws,</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>distance(first, last) &lt;= capacity()</computeroutput></para></requires></method>
<method name="assign"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype><description><para>std::initializer_list with values used to construct new content of this container.</para></description></parameter><purpose>Assigns a range <computeroutput>[il.begin(), il.end())</computeroutput> of Values to this container. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's copy constructor or copy assignment throws,</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>distance(il.begin(), il.end()) &lt;= capacity()</computeroutput></para></requires></method>
<method name="assign"><type>void</type><parameter name="count"><paramtype>size_type</paramtype><description><para>The new number of elements which will be container in the container. </para></description></parameter><parameter name="value"><paramtype>value_type const &amp;</paramtype><description><para>The value which will be used to copy construct the new content.</para></description></parameter><purpose>Assigns a count copies of value to this container. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's copy constructor or copy assignment throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>count &lt;= capacity()</computeroutput></para></requires></method>
<method name="emplace_back"><type>reference</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype><description><para>The arguments of the constructor of the new element which will be created at the end of the container.</para></description></parameter><purpose>Inserts a Value constructed with <computeroutput>std::forward&lt;Args&gt;(args)</computeroutput>... in the end of the container. </purpose><description><para>


<formalpara><title>Throws</title><para>If in-place constructor throws or Value's move constructor throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>size() &lt; capacity()</computeroutput></para></requires><returns><para>A reference to the created object.</para></returns></method>
<method name="emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="p"><paramtype>const_iterator</paramtype><description><para>The position at which new elements will be inserted. </para></description></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype><description><para>The arguments of the constructor of the new element.</para></description></parameter><purpose>Inserts a Value constructed with <computeroutput>std::forward&lt;Args&gt;(args)</computeroutput>... before p. </purpose><description><para>

<formalpara><title>Throws</title><para>If in-place constructor throws or if Value's move constructor or move assignment throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant or linear. </para></formalpara>
</para></description><requires><para><itemizedlist>
<listitem><para><computeroutput>p</computeroutput> must be a valid iterator of <computeroutput>*this</computeroutput> in range <computeroutput>[begin(), end()]</computeroutput> </para></listitem>
<listitem><para><computeroutput>size() &lt; capacity()</computeroutput></para></listitem>
</itemizedlist>
</para></requires></method>
<method name="clear" cv="noexcept"><type>void</type><purpose>Removes all elements from the container. </purpose><description><para><formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description></method>
<method name="at"><type>reference</type><parameter name="i"><paramtype>size_type</paramtype><description><para>The element's index.</para></description></parameter><purpose>Returns reference to the i-th element. </purpose><description><para>


<formalpara><title>Throws</title><para><computeroutput>std::out_of_range</computeroutput> exception by default.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>i &lt; size()</computeroutput></para></requires><returns><para>reference to the i-th element from the beginning of the container.</para></returns></method>
<method name="at" cv="const"><type>const_reference</type><parameter name="i"><paramtype>size_type</paramtype><description><para>The element's index.</para></description></parameter><purpose>Returns const reference to the i-th element. </purpose><description><para>


<formalpara><title>Throws</title><para><computeroutput>std::out_of_range</computeroutput> exception by default.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>i &lt; size()</computeroutput></para></requires><returns><para>const reference to the i-th element from the beginning of the container.</para></returns></method>
<method name="operator[]"><type>reference</type><parameter name="i"><paramtype>size_type</paramtype><description><para>The element's index.</para></description></parameter><purpose>Returns reference to the i-th element. </purpose><description><para>


<formalpara><title>Throws</title><para>Nothing by default.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>i &lt; size()</computeroutput></para></requires><returns><para>reference to the i-th element from the beginning of the container.</para></returns></method>
<method name="operator[]" cv="const"><type>const_reference</type><parameter name="i"><paramtype>size_type</paramtype><description><para>The element's index.</para></description></parameter><purpose>Returns const reference to the i-th element. </purpose><description><para>


<formalpara><title>Throws</title><para>Nothing by default.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>i &lt; size()</computeroutput></para></requires><returns><para>const reference to the i-th element from the beginning of the container.</para></returns></method>
<method name="nth"><type>iterator</type><parameter name="i"><paramtype>size_type</paramtype><description><para>The element's index.</para></description></parameter><purpose>Returns a iterator to the i-th element. </purpose><description><para>


<formalpara><title>Throws</title><para>Nothing by default.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>i =&lt; size()</computeroutput></para></requires><returns><para>a iterator to the i-th element.</para></returns></method>
<method name="nth" cv="const"><type>const_iterator</type><parameter name="i"><paramtype>size_type</paramtype><description><para>The element's index.</para></description></parameter><purpose>Returns a const_iterator to the i-th element. </purpose><description><para>


<formalpara><title>Throws</title><para>Nothing by default.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>i =&lt; size()</computeroutput></para></requires><returns><para>a const_iterator to the i-th element.</para></returns></method>
<method name="index_of"><type>size_type</type><parameter name="p"><paramtype>iterator</paramtype><description><para>An iterator to the element.</para></description></parameter><purpose>Returns the index of the element pointed by p. </purpose><description><para>


<formalpara><title>Throws</title><para>Nothing by default.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>begin() &lt;= p &lt;= end()</computeroutput></para></requires><returns><para>The index of the element pointed by p.</para></returns></method>
<method name="index_of" cv="const"><type>size_type</type><parameter name="p"><paramtype>const_iterator</paramtype><description><para>A const_iterator to the element.</para></description></parameter><purpose>Returns the index of the element pointed by p. </purpose><description><para>


<formalpara><title>Throws</title><para>Nothing by default.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>begin() &lt;= p &lt;= end()</computeroutput></para></requires><returns><para>a const_iterator to the i-th element.</para></returns></method>
<method name="front"><type>reference</type><purpose>Returns reference to the first element. </purpose><description><para>

<formalpara><title>Throws</title><para>Nothing by default.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>!empty</computeroutput>()</para></requires><returns><para>reference to the first element from the beginning of the container.</para></returns></method>
<method name="front" cv="const"><type>const_reference</type><purpose>Returns const reference to the first element. </purpose><description><para>

<formalpara><title>Throws</title><para>Nothing by default.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>!empty</computeroutput>()</para></requires><returns><para>const reference to the first element from the beginning of the container.</para></returns></method>
<method name="back"><type>reference</type><purpose>Returns reference to the last element. </purpose><description><para>

<formalpara><title>Throws</title><para>Nothing by default.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>!empty</computeroutput>()</para></requires><returns><para>reference to the last element from the beginning of the container.</para></returns></method>
<method name="back" cv="const"><type>const_reference</type><purpose>Returns const reference to the first element. </purpose><description><para>

<formalpara><title>Throws</title><para>Nothing by default.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><requires><para><computeroutput>!empty</computeroutput>()</para></requires><returns><para>const reference to the last element from the beginning of the container.</para></returns></method>
<method name="data" cv="noexcept"><type>Value *</type><purpose>Pointer such that <computeroutput>[data(), data() + size())</computeroutput> is a valid range. For a non-empty vector <computeroutput>data() == &amp;front()</computeroutput>. </purpose><description><para><formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description></method>
<method name="data" cv="const noexcept"><type>const Value *</type><purpose>Const pointer such that <computeroutput>[data(), data() + size())</computeroutput> is a valid range. For a non-empty vector <computeroutput>data() == &amp;front()</computeroutput>. </purpose><description><para><formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description></method>
<method name="begin" cv="noexcept"><type>iterator</type><purpose>Returns iterator to the first element. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>iterator to the first element contained in the vector.</para></returns></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type><purpose>Returns const iterator to the first element. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>const_iterator to the first element contained in the vector.</para></returns></method>
<method name="cbegin" cv="const noexcept"><type>const_iterator</type><purpose>Returns const iterator to the first element. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>const_iterator to the first element contained in the vector.</para></returns></method>
<method name="end" cv="noexcept"><type>iterator</type><purpose>Returns iterator to the one after the last element. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>iterator pointing to the one after the last element contained in the vector.</para></returns></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><purpose>Returns const iterator to the one after the last element. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>const_iterator pointing to the one after the last element contained in the vector.</para></returns></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><purpose>Returns const iterator to the one after the last element. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>const_iterator pointing to the one after the last element contained in the vector.</para></returns></method>
<method name="rbegin" cv="noexcept"><type>reverse_iterator</type><purpose>Returns reverse iterator to the first element of the reversed container. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>reverse_iterator pointing to the beginning of the reversed <classname alt="boost::container::static_vector">static_vector</classname>.</para></returns></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><purpose>Returns const reverse iterator to the first element of the reversed container. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>const_reverse_iterator pointing to the beginning of the reversed <classname alt="boost::container::static_vector">static_vector</classname>.</para></returns></method>
<method name="crbegin" cv="const noexcept"><type>const_reverse_iterator</type><purpose>Returns const reverse iterator to the first element of the reversed container. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>const_reverse_iterator pointing to the beginning of the reversed <classname alt="boost::container::static_vector">static_vector</classname>.</para></returns></method>
<method name="rend" cv="noexcept"><type>reverse_iterator</type><purpose>Returns reverse iterator to the one after the last element of the reversed container. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>reverse_iterator pointing to the one after the last element of the reversed <classname alt="boost::container::static_vector">static_vector</classname>.</para></returns></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><purpose>Returns const reverse iterator to the one after the last element of the reversed container. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>const_reverse_iterator pointing to the one after the last element of the reversed <classname alt="boost::container::static_vector">static_vector</classname>.</para></returns></method>
<method name="crend" cv="const noexcept"><type>const_reverse_iterator</type><purpose>Returns const reverse iterator to the one after the last element of the reversed container. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>const_reverse_iterator pointing to the one after the last element of the reversed <classname alt="boost::container::static_vector">static_vector</classname>.</para></returns></method>
<method name="size" cv="const noexcept"><type>size_type</type><purpose>Returns the number of stored elements. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>Number of elements contained in the container.</para></returns></method>
<method name="empty" cv="const noexcept"><type>bool</type><purpose>Queries if the container contains elements. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>true if the number of elements contained in the container is equal to 0.</para></returns></method>
</method-group>
<constructor cv="noexcept"><purpose>Constructs an empty <classname alt="boost::container::static_vector">static_vector</classname>. </purpose><description><para><formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description></constructor>
<constructor specifiers="explicit"><parameter name="count"><paramtype>size_type</paramtype><description><para>The number of values which will be contained in the container.</para></description></parameter><purpose>Constructs a <classname alt="boost::container::static_vector">static_vector</classname> containing count value initialized values. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's value initialization throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>count &lt;= capacity()</computeroutput></para></requires></constructor>
<constructor><parameter name="count"><paramtype>size_type</paramtype><description><para>The number of values which will be contained in the container.</para></description></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><purpose>Constructs a <classname alt="boost::container::static_vector">static_vector</classname> containing count default initialized values. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's default initialization throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N).</para></formalpara>
<formalpara><title>Note</title><para>Non-standard extension </para></formalpara>
</para></description><requires><para><computeroutput>count &lt;= capacity()</computeroutput></para></requires></constructor>
<constructor><parameter name="count"><paramtype>size_type</paramtype><description><para>The number of copies of a values that will be contained in the container. </para></description></parameter><parameter name="value"><paramtype>value_type const &amp;</paramtype><description><para>The value which will be used to copy construct values.</para></description></parameter><purpose>Constructs a <classname alt="boost::container::static_vector">static_vector</classname> containing count copies of value. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's copy constructor throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>count &lt;= capacity()</computeroutput></para></requires></constructor>
<constructor><template>
          <template-type-parameter name="Iterator"/>
        </template><parameter name="first"><paramtype>Iterator</paramtype><description><para>The iterator to the first element in range. </para></description></parameter><parameter name="last"><paramtype>Iterator</paramtype><description><para>The iterator to the one after the last element in range.</para></description></parameter><purpose>Constructs a <classname alt="boost::container::static_vector">static_vector</classname> containing copy of a range <computeroutput>[first, last)</computeroutput>. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's constructor taking a dereferenced Iterator throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><itemizedlist>
<listitem><para><computeroutput>distance(first, last) &lt;= capacity()</computeroutput> </para></listitem>
<listitem><para>Iterator must meet the <computeroutput>ForwardTraversalIterator</computeroutput> concept.</para></listitem>
</itemizedlist>
</para></requires></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype><description><para>std::initializer_list with values to initialize vector.</para></description></parameter><purpose>Constructs a <classname alt="boost::container::static_vector">static_vector</classname> containing copy of a range <computeroutput>[il.begin(), il.end())</computeroutput>. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's constructor taking a dereferenced std::initializer_list throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><itemizedlist>
<listitem><para><computeroutput>distance(il.begin(), il.end()) &lt;= capacity()</computeroutput></para></listitem>
</itemizedlist>
</para></requires></constructor>
<constructor><parameter name="other"><paramtype><classname>static_vector</classname> const &amp;</paramtype><description><para>The <classname alt="boost::container::static_vector">static_vector</classname> which content will be copied to this one.</para></description></parameter><purpose>Constructs a copy of other <classname alt="boost::container::static_vector">static_vector</classname>. </purpose><description><para>
<formalpara><title>Throws</title><para>If Value's copy constructor throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description></constructor>
<constructor><parameter name="other"><paramtype><classname>static_vector</classname> const &amp;</paramtype></parameter><parameter name=""><paramtype>const allocator_type &amp;</paramtype></parameter></constructor>
<constructor cv="noexcept(boost::container::dtl::is_nothrow_move_constructible&lt; value_type &gt;::value))"><parameter name="other"><paramtype><classname>static_vector</classname> &amp;&amp;</paramtype></parameter><parameter name=""><paramtype>const allocator_type &amp;</paramtype></parameter></constructor>
<constructor specifiers="explicit"><parameter name=""><paramtype>const allocator_type &amp;</paramtype></parameter></constructor>
<constructor><template>
          <template-nontype-parameter name="C"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="other"><paramtype><classname>static_vector</classname>&lt; value_type, C &gt; const &amp;</paramtype><description><para>The <classname alt="boost::container::static_vector">static_vector</classname> which content will be copied to this one.</para></description></parameter><purpose>Constructs a copy of other <classname alt="boost::container::static_vector">static_vector</classname>. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's copy constructor throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>other.size() &lt;= capacity()</computeroutput>.</para></requires></constructor>
<constructor cv="noexcept(boost::container::dtl::is_nothrow_move_constructible&lt; value_type &gt;::value))"><parameter name="other"><paramtype><classname>static_vector</classname> &amp;&amp;</paramtype><description><para>The <classname alt="boost::container::static_vector">static_vector</classname> which content will be moved to this one.</para></description></parameter><purpose>Move constructor. Moves Values stored in the other <classname alt="boost::container::static_vector">static_vector</classname> to this one. </purpose><description><para>
<formalpara><title>Throws</title><para><itemizedlist>
<listitem><para>If <computeroutput>has_nothrow_move&lt;Value&gt;::value</computeroutput> is <computeroutput>true</computeroutput> and Value's move constructor throws. </para></listitem>
<listitem><para>If <computeroutput>has_nothrow_move&lt;Value&gt;::value</computeroutput> is <computeroutput>false</computeroutput> and Value's copy constructor throws.</para></listitem>
</itemizedlist>
</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description></constructor>
<constructor><template>
          <template-nontype-parameter name="C"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="other"><paramtype><classname>static_vector</classname>&lt; value_type, C &gt; &amp;&amp;</paramtype><description><para>The <classname alt="boost::container::static_vector">static_vector</classname> which content will be moved to this one.</para></description></parameter><purpose>Move constructor. Moves Values stored in the other <classname alt="boost::container::static_vector">static_vector</classname> to this one. </purpose><description><para>

<formalpara><title>Throws</title><para><itemizedlist>
<listitem><para>If <computeroutput>has_nothrow_move&lt;Value&gt;::value</computeroutput> is <computeroutput>true</computeroutput> and Value's move constructor throws. </para></listitem>
<listitem><para>If <computeroutput>has_nothrow_move&lt;Value&gt;::value</computeroutput> is <computeroutput>false</computeroutput> and Value's copy constructor throws.</para></listitem>
</itemizedlist>
</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>other.size() &lt;= capacity()</computeroutput></para></requires></constructor>
<copy-assignment><type><classname>static_vector</classname> &amp;</type><parameter name="other"><paramtype>const <classname>static_vector</classname> &amp;</paramtype><description><para>The <classname alt="boost::container::static_vector">static_vector</classname> which content will be copied to this one.</para></description></parameter><purpose>Copy assigns Values stored in the other <classname alt="boost::container::static_vector">static_vector</classname> to this one. </purpose><description><para>
<formalpara><title>Throws</title><para>If Value's copy constructor or copy assignment throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description></copy-assignment>
<copy-assignment><type><classname>static_vector</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype><description><para>The std::initializer_list which content will be copied to this one.</para></description></parameter><purpose>Copy assigns Values stored in std::initializer_list to *this. </purpose><description><para>
<formalpara><title>Throws</title><para>If Value's copy constructor or copy assignment throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description></copy-assignment>
<copy-assignment><type><classname>static_vector</classname> &amp;</type><template>
          <template-nontype-parameter name="C"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="other"><paramtype><classname>static_vector</classname>&lt; value_type, C &gt; const &amp;</paramtype><description><para>The <classname alt="boost::container::static_vector">static_vector</classname> which content will be copied to this one.</para></description></parameter><purpose>Copy assigns Values stored in the other <classname alt="boost::container::static_vector">static_vector</classname> to this one. </purpose><description><para>

<formalpara><title>Throws</title><para>If Value's copy constructor or copy assignment throws.</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>other.size() &lt;= capacity()</computeroutput></para></requires></copy-assignment>
<copy-assignment><type><classname>static_vector</classname> &amp;</type><parameter name="other"><paramtype><classname>static_vector</classname> &amp;&amp;</paramtype><description><para>The <classname alt="boost::container::static_vector">static_vector</classname> which content will be moved to this one.</para></description></parameter><purpose>Move assignment. Moves Values stored in the other <classname alt="boost::container::static_vector">static_vector</classname> to this one. </purpose><description><para>
<formalpara><title>Throws</title><para><itemizedlist>
<listitem><para>If <computeroutput>has_nothrow_move&lt;Value&gt;::value</computeroutput> is <computeroutput>true</computeroutput> and Value's move constructor or move assignment throws. </para></listitem>
<listitem><para>If <computeroutput>has_nothrow_move&lt;Value&gt;::value</computeroutput> is <computeroutput>false</computeroutput> and Value's copy constructor or copy assignment throws.</para></listitem>
</itemizedlist>
</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description></copy-assignment>
<copy-assignment><type><classname>static_vector</classname> &amp;</type><template>
          <template-nontype-parameter name="C"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="other"><paramtype><classname>static_vector</classname>&lt; value_type, C &gt; &amp;&amp;</paramtype><description><para>The <classname alt="boost::container::static_vector">static_vector</classname> which content will be moved to this one.</para></description></parameter><purpose>Move assignment. Moves Values stored in the other <classname alt="boost::container::static_vector">static_vector</classname> to this one. </purpose><description><para>

<formalpara><title>Throws</title><para><itemizedlist>
<listitem><para>If <computeroutput>has_nothrow_move&lt;Value&gt;::value</computeroutput> is <computeroutput>true</computeroutput> and Value's move constructor or move assignment throws. </para></listitem>
<listitem><para>If <computeroutput>has_nothrow_move&lt;Value&gt;::value</computeroutput> is <computeroutput>false</computeroutput> and Value's copy constructor or copy assignment throws.</para></listitem>
</itemizedlist>
</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><requires><para><computeroutput>other.size() &lt;= capacity()</computeroutput></para></requires></copy-assignment>
<destructor><purpose>Destructor. Destroys Values stored in this container. </purpose><description><para><formalpara><title>Throws</title><para>Nothing</para></formalpara>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description></destructor>
<method-group name="public static functions">
<method name="capacity" cv="noexcept" specifiers="static"><type>size_type</type><purpose>Returns container's capacity. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>container's capacity.</para></returns></method>
<method name="max_size" cv="noexcept" specifiers="static"><type>size_type</type><purpose>Returns container's capacity. </purpose><description><para>
<formalpara><title>Throws</title><para>Nothing.</para></formalpara>
<formalpara><title>Complexity</title><para>Constant O(1). </para></formalpara>
</para></description><returns><para>container's capacity.</para></returns></method>
</method-group>
</class>
















































<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-nontype-parameter name="C1"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="C2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>static_vector</classname>&lt; V, C1 &gt; const &amp;</paramtype><description><para>The first <classname alt="boost::container::static_vector">static_vector</classname>. </para></description></parameter><parameter name="y"><paramtype><classname>static_vector</classname>&lt; V, C2 &gt; const &amp;</paramtype><description><para>The second <classname alt="boost::container::static_vector">static_vector</classname>.</para></description></parameter><purpose>Checks if contents of two static_vectors are equal. </purpose><description><para>

<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><returns><para><computeroutput>true</computeroutput> if containers have the same size and elements in both containers are equal.</para></returns></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-nontype-parameter name="C1"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="C2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>static_vector</classname>&lt; V, C1 &gt; const &amp;</paramtype><description><para>The first <classname alt="boost::container::static_vector">static_vector</classname>. </para></description></parameter><parameter name="y"><paramtype><classname>static_vector</classname>&lt; V, C2 &gt; const &amp;</paramtype><description><para>The second <classname alt="boost::container::static_vector">static_vector</classname>.</para></description></parameter><purpose>Checks if contents of two static_vectors are not equal. </purpose><description><para>

<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><returns><para><computeroutput>true</computeroutput> if containers have different size or elements in both containers are not equal.</para></returns></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-nontype-parameter name="C1"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="C2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>static_vector</classname>&lt; V, C1 &gt; const &amp;</paramtype><description><para>The first <classname alt="boost::container::static_vector">static_vector</classname>. </para></description></parameter><parameter name="y"><paramtype><classname>static_vector</classname>&lt; V, C2 &gt; const &amp;</paramtype><description><para>The second <classname alt="boost::container::static_vector">static_vector</classname>.</para></description></parameter><purpose>Lexicographically compares static_vectors. </purpose><description><para>

<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><returns><para><computeroutput>true</computeroutput> if x compares lexicographically less than y.</para></returns></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-nontype-parameter name="C1"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="C2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>static_vector</classname>&lt; V, C1 &gt; const &amp;</paramtype><description><para>The first <classname alt="boost::container::static_vector">static_vector</classname>. </para></description></parameter><parameter name="y"><paramtype><classname>static_vector</classname>&lt; V, C2 &gt; const &amp;</paramtype><description><para>The second <classname alt="boost::container::static_vector">static_vector</classname>.</para></description></parameter><purpose>Lexicographically compares static_vectors. </purpose><description><para>

<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><returns><para><computeroutput>true</computeroutput> if y compares lexicographically less than x.</para></returns></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-nontype-parameter name="C1"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="C2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>static_vector</classname>&lt; V, C1 &gt; const &amp;</paramtype><description><para>The first <classname alt="boost::container::static_vector">static_vector</classname>. </para></description></parameter><parameter name="y"><paramtype><classname>static_vector</classname>&lt; V, C2 &gt; const &amp;</paramtype><description><para>The second <classname alt="boost::container::static_vector">static_vector</classname>.</para></description></parameter><purpose>Lexicographically compares static_vectors. </purpose><description><para>

<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><returns><para><computeroutput>true</computeroutput> if y don't compare lexicographically less than x.</para></returns></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="V"/>
          <template-nontype-parameter name="C1"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="C2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>static_vector</classname>&lt; V, C1 &gt; const &amp;</paramtype><description><para>The first <classname alt="boost::container::static_vector">static_vector</classname>. </para></description></parameter><parameter name="y"><paramtype><classname>static_vector</classname>&lt; V, C2 &gt; const &amp;</paramtype><description><para>The second <classname alt="boost::container::static_vector">static_vector</classname>.</para></description></parameter><purpose>Lexicographically compares static_vectors. </purpose><description><para>

<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description><returns><para><computeroutput>true</computeroutput> if x don't compare lexicographically less than y.</para></returns></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="V"/>
          <template-nontype-parameter name="C1"><type>std::size_t</type></template-nontype-parameter>
          <template-nontype-parameter name="C2"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype><classname>static_vector</classname>&lt; V, C1 &gt; &amp;</paramtype><description><para>The first <classname alt="boost::container::static_vector">static_vector</classname>. </para></description></parameter><parameter name="y"><paramtype><classname>static_vector</classname>&lt; V, C2 &gt; &amp;</paramtype><description><para>The second <classname alt="boost::container::static_vector">static_vector</classname>.</para></description></parameter><purpose>Swaps contents of two static_vectors. </purpose><description><para>This function calls static_vector::swap().</para><para>
<formalpara><title>Complexity</title><para>Linear O(N). </para></formalpara>
</para></description></function>


</namespace>
</namespace>
</header>
<header name="boost/container/string.hpp">
<namespace name="boost">
<namespace name="container">
<class name="basic_string"><template>
      <template-type-parameter name="CharT"><purpose><para>The type of character it contains. </para></purpose></template-type-parameter>
      <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default><purpose><para>The Character Traits type, which encapsulates basic character operations </para></purpose></template-type-parameter>
      <template-type-parameter name="Allocator"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt;CharT&gt;</default><purpose><para>The allocator, used for internal memory management. </para></purpose></template-type-parameter>
    </template><inherit access="private">dtl::basic_string_base&lt; Allocator &gt;</inherit><description><para>The <classname alt="boost::container::basic_string">basic_string</classname> class represents a Sequence of characters. It contains all the usual operations of a Sequence, and, additionally, it contains standard string operations such as search and concatenation.</para><para>The <classname alt="boost::container::basic_string">basic_string</classname> class is parameterized by character type, and by that type's Character Traits.</para><para>This class has performance characteristics very much like vector&lt;&gt;, meaning, for example, that it does not perform reference-count or copy-on-write, and that concatenation of two strings is an O(N) operation.</para><para>Some of <classname alt="boost::container::basic_string">basic_string</classname>'s member functions use an unusual method of specifying positions and ranges. In addition to the conventional method using iterators, many of <classname alt="boost::container::basic_string">basic_string</classname>'s member functions use a single value pos of type size_type to represent a position (in which case the position is begin() + pos, and many of <classname alt="boost::container::basic_string">basic_string</classname>'s member functions use two values, pos and n, to represent a range. In that case pos is the beginning of the range and n is its size. That is, the range is [begin() + pos, begin() + pos + n).</para><para>Note that the C++ standard does not specify the complexity of <classname alt="boost::container::basic_string">basic_string</classname> operations. In this implementation, <classname alt="boost::container::basic_string">basic_string</classname> has performance characteristics very similar to those of vector: access to a single character is O(1), while copy and concatenation are O(N).</para><para>In this implementation, begin(), end(), rbegin(), rend(), operator[], c_str(), and data() do not invalidate iterators. In this implementation, iterators are only invalidated by member functions that explicitly change the string's contents.</para><para>
</para></description><typedef name="traits_type"><type>Traits</type></typedef>
<typedef name="value_type"><type>CharT</type></typedef>
<typedef name="pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::pointer</type></typedef>
<typedef name="const_pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_pointer</type></typedef>
<typedef name="reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::reference</type></typedef>
<typedef name="const_reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_reference</type></typedef>
<typedef name="size_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::size_type</type></typedef>
<typedef name="difference_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::difference_type</type></typedef>
<typedef name="allocator_type"><type>Allocator</type></typedef>
<typedef name="stored_allocator_type"><type>implementation_defined</type></typedef>
<typedef name="iterator"><type>implementation_defined</type></typedef>
<typedef name="const_iterator"><type>implementation_defined</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined</type></typedef>
<data-member name="npos" specifiers="static"><type>const size_type</type></data-member>
<method-group name="public member functions">
<method name="get_allocator" cv="const noexcept"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: If allocator's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator" cv="noexcept"><type>stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="const noexcept"><type>const stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="begin" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="empty" cv="const noexcept"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the vector contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="length" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="resize"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are copy constructed from x.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method>
<method name="resize"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are value initialized.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method>
<method name="resize"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are uninitialized.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="capacity" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="reserve"><type>void</type><parameter name="res_arg"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If n is less than or equal to capacity(), this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation allocation throws </para></description></method>
<method name="shrink_to_fit"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Tries to deallocate the excess of memory created with previous allocations. The size of the string is unchanged</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size(). </para></description></method>
<method name="front" cv="noexcept"><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="front" cv="const noexcept"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the first element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="back" cv="noexcept"><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the last element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="back" cv="const noexcept"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the last element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="operator[]" cv="noexcept"><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="operator[]" cv="const noexcept"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="at"><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: std::range_error if n &gt;= size()</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="at" cv="const"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: std::range_error if n &gt;= size()</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="operator+="><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Calls append(str.data, str.size()).</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="operator+="><type><classname>basic_string</classname> &amp;</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as <computeroutput>return append(sv)</computeroutput>. </para></description></method>
<method name="operator+="><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Calls append(s).</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="operator+="><type><classname>basic_string</classname> &amp;</type><parameter name="c"><paramtype>CharT</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Calls append(1, c).</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="operator+="><type><classname>basic_string</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; CharT &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns append(il) </para></description></method>
<method name="append"><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Calls append(str.data(), str.size()).</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="append"><type><classname>basic_string</classname> &amp;</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as return append(sv.data(), sv.size()). </para></description></method>
<method name="append"><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos &lt;= str.size()</para><para><emphasis role="bold">Effects</emphasis>: Determines the effective length rlen of the string to append as the smaller of n and str.size() - pos and calls append(str.data() + pos, rlen).</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws and out_of_range if pos &gt; str.size()</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="append"><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least n elements of CharT.</para><para><emphasis role="bold">Effects</emphasis>: The function replaces the string controlled by *this with a string of length size() + n whose irst size() elements are a copy of the original string controlled by *this and whose remaining elements are a copy of the initial n elements of s.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws length_error if size() + n &gt; max_size().</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="append"><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least traits::length(s) + 1 elements of CharT.</para><para><emphasis role="bold">Effects</emphasis>: Calls append(s, traits::length(s)).</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="append"><type><classname>basic_string</classname> &amp;</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to append(basic_string(n, c)).</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="append"><type><classname>basic_string</classname> &amp;</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="first"><paramtype>InputIter</paramtype></parameter><parameter name="last"><paramtype>InputIter</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: [first,last) is a valid range.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to append(basic_string(first, last)).</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="append"><type><classname>basic_string</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; CharT &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns append(il.begin(), il.size()). </para></description></method>
<method name="push_back"><type>void</type><parameter name="c"><paramtype>CharT</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to append(static_cast&lt;size_type&gt;(1), c). </para></description></method>
<method name="assign"><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to assign(str, 0, npos).</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="assign"><type><classname>basic_string</classname> &amp;</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to return assign(sv.data(), sv.size()).</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="assign" cv="noexcept"><type><classname>basic_string</classname> &amp;</type><parameter name="ms"><paramtype><classname>basic_string</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: The function replaces the string controlled by *this with a string of length str.size() whose elements are a copy of the string controlled by str. Leaves str in a valid but unspecified state.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="assign"><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos &lt;= str.size()</para><para><emphasis role="bold">Effects</emphasis>: Determines the effective length rlen of the string to assign as the smaller of n and str.size() - pos and calls assign(str.data() + pos rlen).</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or out_of_range if pos &gt; str.size().</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="assign"><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least n elements of CharT.</para><para><emphasis role="bold">Effects</emphasis>: Replaces the string controlled by *this with a string of length n whose elements are a copy of those pointed to by s.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or length_error if n &gt; max_size().</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="assign"><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least traits::length(s) + 1 elements of CharT.</para><para><emphasis role="bold">Effects</emphasis>: Calls assign(s, traits::length(s)).</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="assign"><type><classname>basic_string</classname> &amp;</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to assign(basic_string(n, c)).</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="assign"><type><classname>basic_string</classname> &amp;</type><parameter name="first"><paramtype>const CharT *</paramtype></parameter><parameter name="last"><paramtype>const CharT *</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to assign(basic_string(first, last)). <emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="assign"><type><classname>basic_string</classname> &amp;</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="first"><paramtype>InputIter</paramtype></parameter><parameter name="last"><paramtype>InputIter</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to assign(basic_string(first, last)).</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="assign"><type><classname>basic_string</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; CharT &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns assign(il.begin(), il.size()). </para></description></method>
<method name="insert"><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos &lt;= size().</para><para><emphasis role="bold">Effects</emphasis>: Calls insert(pos, str.data(), str.size()).</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or out_of_range if pos &gt; size().</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="insert"><type><classname>basic_string</classname> &amp;</type><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos2"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos1 &lt;= size() and pos2 &lt;= str.size()</para><para><emphasis role="bold">Effects</emphasis>: Determines the effective length rlen of the string to insert as the smaller of n and str.size() - pos2 and calls insert(pos1, str.data() + pos2, rlen).</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or out_of_range if pos1 &gt; size() or pos2 &gt; str.size().</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="insert"><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least n elements of CharT and pos &lt;= size().</para><para><emphasis role="bold">Effects</emphasis>: Replaces the string controlled by *this with a string of length size() + n whose first pos elements are a copy of the initial elements of the original string controlled by *this and whose next n elements are a copy of the elements in s and whose remaining elements are a copy of the remaining elements of the original string controlled by *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, out_of_range if pos &gt; size() or length_error if size() + n &gt; max_size().</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="insert"><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos &lt;= size() and s points to an array of at least traits::length(s) + 1 elements of CharT</para><para><emphasis role="bold">Effects</emphasis>: Calls insert(pos, s, traits::length(s)).</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, out_of_range if pos &gt; size() length_error if size() &gt; max_size() - Traits::length(s)</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="insert"><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to insert(pos, basic_string(n, c)).</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, out_of_range if pos &gt; size() length_error if size() &gt; max_size() - n</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="insert"><type><classname>basic_string</classname> &amp;</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as <computeroutput>return insert(pos, sv.data(), sv.size())</computeroutput>. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a valid iterator on *this.</para><para><emphasis role="bold">Effects</emphasis>: inserts a copy of c before the character referred to by p.</para><para><emphasis role="bold">Returns</emphasis>: An iterator which refers to the copy of the inserted character. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a valid iterator on *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts n copies of c before the character referred to by p.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or p if n is 0. </para></description></method>
<method name="insert"><type>iterator</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="first"><paramtype>InputIter</paramtype></parameter><parameter name="last"><paramtype>InputIter</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p is a valid iterator on *this. [first,last) is a valid range.</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to insert(p - begin(), basic_string(first, last)).</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or p if first == last. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; CharT &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: As if by insert(p, il.begin(), il.end()).</para><para><emphasis role="bold">Returns</emphasis>: An iterator which refers to the copy of the first inserted character, or p if i1 is empty. </para></description></method>
<method name="pop_back" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the last element from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time. </para></description></method>
<method name="erase"><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><parameter name="n"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos &lt;= size()</para><para><emphasis role="bold">Effects</emphasis>: Determines the effective length xlen of the string to be removed as the smaller of n and size() - pos. The function then replaces the string controlled by *this with a string of length size() - xlen whose first pos elements are a copy of the initial elements of the original string controlled by *this, and whose remaining elements are a copy of the elements of the original string controlled by *this beginning at position pos + xlen.</para><para><emphasis role="bold">Throws</emphasis>: out_of_range if pos &gt; size().</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="erase" cv="noexcept"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Removes the character referred to by p.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: An iterator which points to the element immediately following p prior to the element being erased. If no such element exists, end() is returned. </para></description></method>
<method name="erase" cv="noexcept"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: first and last are valid iterators on *this, defining a range [first,last).</para><para><emphasis role="bold">Effects</emphasis>: Removes the characters in the range [first,last).</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: An iterator which points to the element pointed to by last prior to the other elements being erased. If no such element exists, end() is returned. </para></description></method>
<method name="clear" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the vector. </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="str"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos1 &lt;= size().</para><para><emphasis role="bold">Effects</emphasis>: Calls replace(pos1, n1, str.data(), str.size()).</para><para><emphasis role="bold">Throws</emphasis>: if memory allocation throws or out_of_range if pos1 &gt; size().</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Calls <computeroutput>return replace(pos1, n1, sv.data(), sv.size());</computeroutput>. </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="str"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos2"><paramtype>size_type</paramtype></parameter><parameter name="n2"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos1 &lt;= size() and pos2 &lt;= str.size().</para><para><emphasis role="bold">Effects</emphasis>: Determines the effective length rlen of the string to be inserted as the smaller of n2 and str.size() - pos2 and calls replace(pos1, n1, str.data() + pos2, rlen).</para><para><emphasis role="bold">Throws</emphasis>: if memory allocation throws, out_of_range if pos1 &gt; size() or pos2 &gt; str.size().</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="pos2"><paramtype>size_type</paramtype></parameter><parameter name="n2"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Throws</emphasis>: out_of_range if pos1 &gt; size() or pos2 &gt; sv.size().</para><para><emphasis role="bold">Effects</emphasis>: Determines the effective length rlen of the string to be inserted as the smaller of n2 and sv.size() - pos2 and calls <computeroutput>replace(pos1, n1, sv.data() + pos2, rlen)</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: *this. </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n2"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos1 &lt;= size() and s points to an array of at least n2 elements of CharT.</para><para><emphasis role="bold">Effects</emphasis>: Determines the effective length xlen of the string to be removed as the smaller of n1 and size() - pos1. If size() - xlen &gt;= max_size() - n2 throws length_error. Otherwise, the function replaces the string controlled by *this with a string of length size() - xlen + n2 whose first pos1 elements are a copy of the initial elements of the original string controlled by *this, whose next n2 elements are a copy of the initial n2 elements of s, and whose remaining elements are a copy of the elements of the original string controlled by *this beginning at position pos + xlen.</para><para><emphasis role="bold">Throws</emphasis>: if memory allocation throws, out_of_range if pos1 &gt; size() or length_error if the length of the resulting string would exceed max_size()</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos1 &lt;= size() and s points to an array of at least n2 elements of CharT.</para><para><emphasis role="bold">Effects</emphasis>: Determines the effective length xlen of the string to be removed as the smaller of n1 and size() - pos1. If size() - xlen &gt;= max_size() - n2 throws length_error. Otherwise, the function replaces the string controlled by *this with a string of length size() - xlen + n2 whose first pos1 elements are a copy of the initial elements of the original string controlled by *this, whose next n2 elements are a copy of the initial n2 elements of s, and whose remaining elements are a copy of the elements of the original string controlled by *this beginning at position pos + xlen.</para><para><emphasis role="bold">Throws</emphasis>: if memory allocation throws, out_of_range if pos1 &gt; size() or length_error if the length of the resulting string would exceed max_size()</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="n2"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos1 &lt;= size().</para><para><emphasis role="bold">Effects</emphasis>: Equivalent to replace(pos1, n1, basic_string(n2, c)).</para><para><emphasis role="bold">Throws</emphasis>: if memory allocation throws, out_of_range if pos1 &gt; size() or length_error if the length of the resulting string would exceed max_size()</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><parameter name="i1"><paramtype>const_iterator</paramtype></parameter><parameter name="i2"><paramtype>const_iterator</paramtype></parameter><parameter name="str"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: [begin(),i1) and [i1,i2) are valid ranges.</para><para><emphasis role="bold">Effects</emphasis>: Calls replace(i1 - begin(), i2 - i1, str).</para><para><emphasis role="bold">Throws</emphasis>: if memory allocation throws</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><parameter name="i1"><paramtype>const_iterator</paramtype></parameter><parameter name="i2"><paramtype>const_iterator</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: [begin(),i1) and [i1,i2) are valid ranges and s points to an array of at least n elements</para><para><emphasis role="bold">Effects</emphasis>: Calls replace(i1 - begin(), i2 - i1, s, n).</para><para><emphasis role="bold">Throws</emphasis>: if memory allocation throws</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><parameter name="i1"><paramtype>const_iterator</paramtype></parameter><parameter name="i2"><paramtype>const_iterator</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: [begin(),i1) and [i1,i2) are valid ranges and s points to an array of at least traits::length(s) + 1 elements of CharT.</para><para><emphasis role="bold">Effects</emphasis>: Calls replace(i1 - begin(), i2 - i1, s, traits::length(s)).</para><para><emphasis role="bold">Throws</emphasis>: if memory allocation throws</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><parameter name="i1"><paramtype>const_iterator</paramtype></parameter><parameter name="i2"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: [begin(),i1) and [i1,i2) are valid ranges.</para><para><emphasis role="bold">Effects</emphasis>: Calls replace(i1 - begin(), i2 - i1, basic_string(n, c)).</para><para><emphasis role="bold">Throws</emphasis>: if memory allocation throws</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="i1"><paramtype>const_iterator</paramtype></parameter><parameter name="i2"><paramtype>const_iterator</paramtype></parameter><parameter name="j1"><paramtype>InputIter</paramtype></parameter><parameter name="j2"><paramtype>InputIter</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: [begin(),i1), [i1,i2) and [j1,j2) are valid ranges.</para><para><emphasis role="bold">Effects</emphasis>: Calls replace(i1 - begin(), i2 - i1, basic_string(j1, j2)).</para><para><emphasis role="bold">Throws</emphasis>: if memory allocation throws</para><para><emphasis role="bold">Returns</emphasis>: *this </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="i1"><paramtype>const_iterator</paramtype></parameter><parameter name="i2"><paramtype>const_iterator</paramtype></parameter><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: [begin(), i1) and [i1, i2) are valid ranges.</para><para><emphasis role="bold">Effects</emphasis>: Calls <computeroutput>replace(i1 - begin(), i2 - i1, sv).</computeroutput>.</para><para><emphasis role="bold">Returns</emphasis>: *this. </para></description></method>
<method name="replace"><type><classname>basic_string</classname> &amp;</type><parameter name="i1"><paramtype>const_iterator</paramtype></parameter><parameter name="i2"><paramtype>const_iterator</paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; CharT &gt;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: [begin(), i1) and [i1, i2) are valid ranges.</para><para><emphasis role="bold">Effects</emphasis>: Calls replace(i1 - begin(), i2 - i1, il.begin(), il.size()).</para><para><emphasis role="bold">Returns</emphasis>: *this. </para></description></method>
<method name="copy" cv="const"><type>size_type</type><parameter name="s"><paramtype>CharT *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos &lt;= size()</para><para><emphasis role="bold">Effects</emphasis>: Determines the effective length rlen of the string to copy as the smaller of n and size() - pos. s shall designate an array of at least rlen elements. The function then replaces the string designated by s with a string of length rlen whose elements are a copy of the string controlled by *this beginning at position pos. The function does not append a null object to the string designated by s.</para><para><emphasis role="bold">Throws</emphasis>: if memory allocation throws, out_of_range if pos &gt; size().</para><para><emphasis role="bold">Returns</emphasis>: rlen </para></description></method>
<method name="swap" cv="noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value))"><type>void</type><parameter name="x"><paramtype><classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: *this contains the same sequence of characters that was in s, s contains the same sequence of characters that was in *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing </para></description></method>
<method name="c_str" cv="const noexcept"><type>const CharT *</type><description><para><emphasis role="bold">Requires</emphasis>: The program shall not alter any of the values stored in the character array.</para><para><emphasis role="bold">Returns</emphasis>: A pointer p such that p + i == &amp;operator[](i) for each i in [0,size()].</para><para><emphasis role="bold">Complexity</emphasis>: constant time. </para></description></method>
<method name="data" cv="const noexcept"><type>const CharT *</type><description><para><emphasis role="bold">Requires</emphasis>: The program shall not alter any of the values stored in the character array.</para><para><emphasis role="bold">Returns</emphasis>: A pointer p such that p + i == &amp;operator[](i) for each i in [0,size()].</para><para><emphasis role="bold">Complexity</emphasis>: constant time. </para></description></method>
<method name="data" cv="noexcept"><type>CharT *</type><description><para><emphasis role="bold">Returns</emphasis>: A pointer p such that p + i == &amp;operator[](i) for each i in [0,size()].</para><para><emphasis role="bold">Complexity</emphasis>: constant time. </para></description></method>
<method name="conversion-operator" cv="const noexcept"><type>BasicStringView&lt; CharT, Traits &gt;</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><description><para><emphasis role="bold">Returns</emphasis>: a string_view to the characters in the string.</para><para><emphasis role="bold">Complexity</emphasis>: constant time. </para></description></method>
<method name="to_view" cv="const noexcept"><type>BasicStringView</type><template>
          <template-type-parameter name="BasicStringView"/>
        </template><description><para><emphasis role="bold">Returns</emphasis>: a string_view to the characters in the string.</para><para><emphasis role="bold">Complexity</emphasis>: constant time.</para><para><emphasis role="bold">Note</emphasis>: This function is available to write portable code for compilers that don't support templated conversion operators. </para></description></method>
<method name="find" cv="const"><type>size_type</type><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Determines the lowest position xpos, if possible, such that both of the following conditions hold: 1) pos &lt;= xpos and xpos + str.size() &lt;= size(); 2) traits::eq(at(xpos+I), str.at(I)) for all elements I of the string controlled by str.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: xpos if the function can determine such a value for xpos. Otherwise, returns npos. </para></description></method>
<method name="find" cv="const"><type>size_type</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Determines the lowest position xpos, if possible, such that both of the following conditions hold: 1) pos &lt;= xpos and xpos + sv.size() &lt;= size(); 2) traits::eq(at(xpos+I), sv.at(I)) for all elements I of the string controlled by sv.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: xpos if the function can determine such a value for xpos. Otherwise, returns npos. </para></description></method>
<method name="find" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least n elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find(basic_string&lt;CharT,traits,Allocator&gt;(s,n),pos). </para></description></method>
<method name="find" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least traits::length(s) + 1 elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find(basic_string(s), pos). </para></description></method>
<method name="find" cv="const"><type>size_type</type><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find(basic_string&lt;CharT,traits,Allocator&gt;(1,c), pos). </para></description></method>
<method name="rfind" cv="const"><type>size_type</type><parameter name="str"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Determines the highest position xpos, if possible, such that both of the following conditions obtain: a) xpos &lt;= pos and xpos + str.size() &lt;= size(); b) traits::eq(at(xpos+I), str.at(I)) for all elements I of the string controlled by str.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: xpos if the function can determine such a value for xpos. Otherwise, returns npos. </para></description></method>
<method name="rfind" cv="const"><type>size_type</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Determines the highest position xpos, if possible, such that both of the following conditions obtain: a) xpos &lt;= pos and xpos + sv.size() &lt;= size(); b) traits::eq(at(xpos+I), sv.at(I)) for all elements I of the string controlled by sv.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: xpos if the function can determine such a value for xpos. Otherwise, returns npos. </para></description></method>
<method name="rfind" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least n elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: rfind(basic_string(s, n), pos). </para></description></method>
<method name="rfind" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos &lt;= size() and s points to an array of at least traits::length(s) + 1 elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: rfind(basic_string(s), pos). </para></description></method>
<method name="rfind" cv="const"><type>size_type</type><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: rfind(basic_string&lt;CharT,traits,Allocator&gt;(1,c),pos). </para></description></method>
<method name="find_first_of" cv="const"><type>size_type</type><parameter name="str"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Determines the lowest position xpos, if possible, such that both of the following conditions obtain: a) pos &lt;= xpos and xpos &lt; size(); b) traits::eq(at(xpos), str.at(I)) for some element I of the string controlled by str.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: xpos if the function can determine such a value for xpos. Otherwise, returns npos. </para></description></method>
<method name="find_first_of" cv="const"><type>size_type</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Determines the lowest position xpos, if possible, such that both of the following conditions obtain: a) pos &lt;= xpos and xpos &lt; size(); b) traits::eq(at(xpos), sv.at(I)) for some element I of the string controlled by sv.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: xpos if the function can determine such a value for xpos. Otherwise, returns npos. </para></description></method>
<method name="find_first_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least n elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find_first_of(basic_string(s, n), pos). </para></description></method>
<method name="find_first_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least traits::length(s) + 1 elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find_first_of(basic_string(s), pos). </para></description></method>
<method name="find_first_of" cv="const"><type>size_type</type><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least traits::length(s) + 1 elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find_first_of(basic_string&lt;CharT,traits,Allocator&gt;(1,c), pos). </para></description></method>
<method name="find_last_of" cv="const"><type>size_type</type><parameter name="str"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Determines the highest position xpos, if possible, such that both of the following conditions obtain: a) xpos &lt;= pos and xpos &lt; size(); b) traits::eq(at(xpos), str.at(I)) for some element I of the string controlled by str.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: xpos if the function can determine such a value for xpos. Otherwise, returns npos. </para></description></method>
<method name="find_last_of" cv="const"><type>size_type</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Determines the highest position xpos, if possible, such that both of the following conditions obtain: a) xpos &lt;= pos and xpos &lt; size(); b) traits::eq(at(xpos), str.at(I)) for some element I of the string controlled by str.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: xpos if the function can determine such a value for xpos. Otherwise, returns npos. </para></description></method>
<method name="find_last_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least n elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find_last_of(basic_string(s, n), pos). </para></description></method>
<method name="find_last_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least traits::length(s) + 1 elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find_last_of(basic_string&lt;CharT,traits,Allocator&gt;(1,c),pos). </para></description></method>
<method name="find_last_of" cv="const"><type>size_type</type><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find_last_of(basic_string(s), pos). </para></description></method>
<method name="find_first_not_of" cv="const"><type>size_type</type><parameter name="str"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Determines the lowest position xpos, if possible, such that both of the following conditions obtain: a) pos &lt;= xpos and xpos &lt; size(); b) traits::eq(at(xpos), str.at(I)) for no element I of the string controlled by str.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: xpos if the function can determine such a value for xpos. Otherwise, returns npos. </para></description></method>
<method name="find_first_not_of" cv="const"><type>size_type</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Determines the lowest position xpos, if possible, such that both of the following conditions obtain: a) pos &lt;= xpos and xpos &lt; size(); b) traits::eq(at(xpos), sv.at(I)) for no element I of the string controlled by sv.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: xpos if the function can determine such a value for xpos. Otherwise, returns npos. </para></description></method>
<method name="find_first_not_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least traits::length(s) + 1 elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find_first_not_of(basic_string(s, n), pos). </para></description></method>
<method name="find_first_not_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least traits::length(s) + 1 elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find_first_not_of(basic_string(s), pos). </para></description></method>
<method name="find_first_not_of" cv="const"><type>size_type</type><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><description><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find_first_not_of(basic_string(1, c), pos). </para></description></method>
<method name="find_last_not_of" cv="const"><type>size_type</type><parameter name="str"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Determines the highest position xpos, if possible, such that both of the following conditions obtain: a) xpos &lt;= pos and xpos &lt; size(); b) traits::eq(at(xpos), str.at(I)) for no element I of the string controlled by str.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: xpos if the function can determine such a value for xpos. Otherwise, returns npos. </para></description></method>
<method name="find_last_not_of" cv="const"><type>size_type</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Determines the highest position xpos, if possible, such that both of the following conditions obtain: a) xpos &lt;= pos and xpos &lt; size(); b) traits::eq(at(xpos), sv.at(I)) for no element I of the string controlled by sv.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: xpos if the function can determine such a value for xpos. Otherwise, returns npos. </para></description></method>
<method name="find_last_not_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least n elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find_last_not_of(basic_string(s, n), pos). </para></description></method>
<method name="find_last_not_of" cv="const"><type>size_type</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: s points to an array of at least traits::length(s) + 1 elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find_last_not_of(basic_string(s), pos). </para></description></method>
<method name="find_last_not_of" cv="const"><type>size_type</type><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: find_last_not_of(basic_string(1, c), pos). </para></description></method>
<method name="substr" cv="const"><type><classname>basic_string</classname></type><parameter name="pos"><paramtype>size_type</paramtype><default>0</default></parameter><parameter name="n"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: Requires: pos &lt;= size()</para><para><emphasis role="bold">Effects</emphasis>: Determines the effective length rlen of the string to copy as the smaller of n and size() - pos.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or out_of_range if pos &gt; size().</para><para><emphasis role="bold">Returns</emphasis>: basic_string&lt;CharT,traits,Allocator&gt;(data()+pos,rlen). </para></description></method>
<method name="compare" cv="const"><type>int</type><parameter name="str"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Determines the effective length rlen of the string to compare as the smaller of size() and str.size(). The function then compares the two strings by calling traits::compare(data(), str.data(), rlen).</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: The nonzero result if the result of the comparison is nonzero. Otherwise, returns a value &lt; 0 if size() &lt; str.size(), a 0 value if size() == str.size(), and value &gt; 0 if size() &gt; str.size() </para></description></method>
<method name="compare" cv="const"><type>int</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><description><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: compare(basic_string(sv)). </para></description></method>
<method name="compare" cv="const"><type>int</type><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="str"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos1 &lt;= size()</para><para><emphasis role="bold">Effects</emphasis>: Determines the effective length rlen of the string to compare as the smaller of (this-&gt;size() - pos1), n1 and str.size(). The function then compares the two strings by calling traits::compare(data()+pos1, str.data(), rlen).</para><para><emphasis role="bold">Throws</emphasis>: out_of_range if pos1 &gt; size()</para><para><emphasis role="bold">Returns</emphasis>:basic_string(*this,pos1,n1).compare(str). </para></description></method>
<method name="compare" cv="const"><type>int</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos1 &lt;= size()</para><para><emphasis role="bold">Throws</emphasis>: out_of_range if pos1 &gt; size()</para><para><emphasis role="bold">Returns</emphasis>:basic_string(*this,pos1,n1).compare(sv). </para></description></method>
<method name="compare" cv="const"><type>int</type><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="str"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos2"><paramtype>size_type</paramtype></parameter><parameter name="n2"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos1 &lt;= size() and pos2 &lt;= str.size()</para><para><emphasis role="bold">Effects</emphasis>: Determines the effective length rlen of the string to copy as the smaller of</para><para><emphasis role="bold">Throws</emphasis>: out_of_range if pos1 &gt; size() or pos2 &gt; str.size()</para><para><emphasis role="bold">Returns</emphasis>: basic_string(*this, pos1, n1).compare(basic_string(str, pos2, n2)). </para></description></method>
<method name="compare" cv="const"><type>int</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="pos2"><paramtype>size_type</paramtype></parameter><parameter name="n2"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos1 &lt;= size() and pos2 &lt;= str.size()</para><para><emphasis role="bold">Effects</emphasis>: Determines the effective length rlen of the string to copy as the smaller of</para><para><emphasis role="bold">Throws</emphasis>: out_of_range if pos1 &gt; size() or pos2 &gt; sv.size()</para><para><emphasis role="bold">Returns</emphasis>: basic_string(*this, pos1, n1).compare(BasicStringView&lt;CharT, Traits&gt;(sv, pos2, n2)). </para></description></method>
<method name="compare" cv="const"><type>int</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><description><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Returns</emphasis>: compare(basic_string(s)). </para></description></method>
<method name="compare" cv="const"><type>int</type><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n2"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos1 &gt; size() and s points to an array of at least n2 elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: out_of_range if pos1 &gt; size()</para><para><emphasis role="bold">Returns</emphasis>: basic_string(*this, pos, n1).compare(basic_string(s, n2)). </para></description></method>
<method name="compare" cv="const"><type>int</type><parameter name="pos1"><paramtype>size_type</paramtype></parameter><parameter name="n1"><paramtype>size_type</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: pos1 &gt; size() and s points to an array of at least traits::length(s) + 1 elements of CharT.</para><para><emphasis role="bold">Throws</emphasis>: out_of_range if pos1 &gt; size()</para><para><emphasis role="bold">Returns</emphasis>: basic_string(*this, pos, n1).compare(basic_string(s, n2)). </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; Allocator &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Default constructs a <classname alt="boost::container::basic_string">basic_string</classname>.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor throws. </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::basic_string">basic_string</classname> taking the allocator as parameter.</para><para><emphasis role="bold">Throws</emphasis>: Nothing </para></description></constructor>
<constructor><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a <classname alt="boost::container::basic_string">basic_string</classname>.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor or allocation throws. </para></description></constructor>
<constructor specifiers="explicit"><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="a"><paramtype>const Allocator &amp;</paramtype><default>Allocator()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as <classname alt="boost::container::basic_string">basic_string</classname>(sv.data(), sv.size(), a).</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's default constructor or allocation throws. </para></description></constructor>
<constructor cv="noexcept"><parameter name="s"><paramtype><classname>basic_string</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor. Moves s's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a <classname alt="boost::container::basic_string">basic_string</classname> using the specified allocator.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocation throws. </para></description></constructor>
<constructor><parameter name="s"><paramtype><classname>basic_string</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor using the specified allocator. Moves s's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant if a == s.get_allocator(), linear otherwise. </para></description></constructor>
<constructor><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype><default>npos</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::basic_string">basic_string</classname> with a default-constructed allocator, and is initialized by a specific number of characters of the s string. </para></description></constructor>
<constructor><parameter name="s"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><parameter name="pos"><paramtype>size_type</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::basic_string">basic_string</classname> taking the allocator as parameter, and is initialized by a specific number of characters of the s string. </para></description></constructor>
<constructor><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::basic_string">basic_string</classname> taking a default-constructed allocator, and is initialized by a specific number of characters of the s c-string. </para></description></constructor>
<constructor><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::basic_string">basic_string</classname> taking the allocator as parameter, and is initialized by a specific number of characters of the s c-string. </para></description></constructor>
<constructor><parameter name="s"><paramtype>const CharT *</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::basic_string">basic_string</classname> with a default-constructed allocator, and is initialized by the null-terminated s c-string. </para></description></constructor>
<constructor><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::basic_string">basic_string</classname> taking the allocator as parameter, and is initialized by the null-terminated s c-string. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::basic_string">basic_string</classname> with a default-constructed allocator, and is initialized by n copies of c. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::basic_string">basic_string</classname> taking the allocator as parameter, and is initialized by n copies of c. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::basic_string">basic_string</classname> with a default-constructed allocator, and is initialized by n default-initialized characters. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::basic_string">basic_string</classname> taking the allocator as parameter, and is initialized by n default-initialized characters. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="f"><paramtype>InputIterator</paramtype></parameter><parameter name="l"><paramtype>InputIterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::basic_string">basic_string</classname> with a default-constructed allocator, and a range of iterators. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InputIterator"/>
        </template><parameter name="f"><paramtype>InputIterator</paramtype></parameter><parameter name="l"><paramtype>InputIterator</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a <classname alt="boost::container::basic_string">basic_string</classname> taking the allocator as parameter, and a range of iterators. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Same as <classname alt="boost::container::basic_string">basic_string</classname>(il.begin(), il.end(), a). </para></description></constructor>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Destroys the <classname alt="boost::container::basic_string">basic_string</classname>. All used memory is deallocated.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></destructor>
<copy-assignment><type><classname>basic_string</classname> &amp;</type><parameter name="x"><paramtype>const <classname>basic_string</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a string.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></copy-assignment>
<copy-assignment cv="noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value))"><type><classname>basic_string</classname> &amp;</type><parameter name="x"><paramtype><classname>basic_string</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor. Moves x's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_traits_type::propagate_on_container_move_assignment is false and allocation throws</para><para><emphasis role="bold">Complexity</emphasis>: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this-&gt;get&gt;allocator() == x.get_allocator(). Linear otherwise. </para></description></copy-assignment>
<copy-assignment><type><classname>basic_string</classname> &amp;</type><parameter name="s"><paramtype>const CharT *</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assignment from a null-terminated c-string. </para></description></copy-assignment>
<copy-assignment><type><classname>basic_string</classname> &amp;</type><parameter name="c"><paramtype>CharT</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns *this = basic_string(1, c). </para></description></copy-assignment>
<copy-assignment><type><classname>basic_string</classname> &amp;</type><template>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="sv"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Equivalent to return assign(sv). </para></description></copy-assignment>
<copy-assignment><type><classname>basic_string</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; CharT &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns *this = basic_string(il); </para></description></copy-assignment>
</class><typedef name="string"><description><para>Typedef for a <classname alt="boost::container::basic_string">basic_string</classname> of narrow characters </para></description><type><classname>basic_string</classname>&lt; char,std::char_traits&lt; char &gt;,<classname>new_allocator</classname>&lt; char &gt; &gt;</type></typedef>
<typedef name="wstring"><description><para>Typedef for a <classname alt="boost::container::basic_string">basic_string</classname> of narrow characters </para></description><type><classname>basic_string</classname>&lt; wchar_t,std::char_traits&lt; wchar_t &gt;,<classname>new_allocator</classname>&lt; wchar_t &gt; &gt;</type></typedef>





<function name="operator+"><type><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator+"><type><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;&amp;</paramtype></parameter><parameter name="y"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;&amp;</paramtype></parameter></function>
<function name="operator+"><type><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;&amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator+"><type><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;&amp;</paramtype></parameter></function>
<function name="operator+"><type><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt;</paramtype></parameter></function>
<function name="operator+"><type><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function>
<function name="operator+"><type><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="c"><paramtype>CharT</paramtype></parameter><parameter name="y"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt;</paramtype></parameter></function>
<function name="operator+"><type><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt;</paramtype></parameter><parameter name="c"><paramtype>const CharT</paramtype></parameter></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="s"><paramtype>const CharT *</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const CharT *</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter><parameter name="y"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
          <template-nontype-parameter name="BasicStringView"><type>template&lt; class, class &gt; class</type></template-nontype-parameter>
        </template><parameter name="x"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype>BasicStringView&lt; CharT, Traits &gt;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="x"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; CharT, Traits &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; CharT, Traits &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype>const <classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="operator&gt;&gt;"><type>std::basic_istream&lt; CharT, Traits &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="is"><paramtype>std::basic_istream&lt; CharT, Traits &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="getline"><type>std::basic_istream&lt; CharT, Traits &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="is"><paramtype>std::istream &amp;</paramtype></parameter><parameter name="s"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter><parameter name="delim"><paramtype>CharT</paramtype></parameter></function>
<function name="getline"><type>std::basic_istream&lt; CharT, Traits &gt; &amp;</type><template>
          <template-type-parameter name="CharT"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="is"><paramtype>std::basic_istream&lt; CharT, Traits &gt; &amp;</paramtype></parameter><parameter name="s"><paramtype><classname>basic_string</classname>&lt; CharT, Traits, Allocator &gt; &amp;</paramtype></parameter></function>
<function name="hash_value"><type>std::size_t</type><template>
          <template-type-parameter name="Ch"/>
          <template-type-parameter name="Allocator"/>
        </template><parameter name="v"><paramtype><classname>basic_string</classname>&lt; Ch, std::char_traits&lt; Ch &gt;, Allocator &gt; const &amp;</paramtype></parameter></function>









</namespace>
</namespace>
</header>
<header name="boost/container/pmr/string.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<struct name="basic_string_of"><template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="Traits"><default>std::char_traits&lt;CharT&gt;</default></template-type-parameter>
    </template><description><para>A portable metafunction to obtain a <classname alt="boost::container::basic_string">basic_string</classname> that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::basic_string</classname>&lt; CharT, Traits, <classname>polymorphic_allocator</classname>&lt; CharT &gt; &gt;</type></typedef>
</struct><typedef name="basic_string"><type><classname>boost::container::basic_string</classname>&lt; CharT, Traits, <classname>polymorphic_allocator</classname>&lt; CharT &gt; &gt;</type></typedef>
<typedef name="string"><type><classname>basic_string_of</classname>&lt; char &gt;::type</type></typedef>
<typedef name="wstring"><type><classname>basic_string_of</classname>&lt; wchar_t &gt;::type</type></typedef>






</namespace>


























































</namespace>
</namespace>
</header>
<header name="boost/container/throw_exception.hpp">
<namespace name="boost">
<namespace name="container">
<function name="throw_bad_alloc"><type>void</type><description><para>Exception callback called by Boost.Container when fails to allocate the requested storage space. <itemizedlist>
<listitem>
<para>If BOOST_NO_EXCEPTIONS is NOT defined <computeroutput>std::bad_alloc()</computeroutput> is thrown.</para><para/></listitem>
<listitem>
<para>If BOOST_NO_EXCEPTIONS is defined and BOOST_CONTAINER_USER_DEFINED_THROW_CALLBACKS is NOT defined <computeroutput>BOOST_ASSERT(!"boost::container bad_alloc thrown")</computeroutput> is called and <computeroutput>std::abort()</computeroutput> if the former returns.</para><para/></listitem>
<listitem>
<para>If BOOST_NO_EXCEPTIONS and BOOST_CONTAINER_USER_DEFINED_THROW_CALLBACKS are defined the user must provide an implementation and the function should not return. </para></listitem>
</itemizedlist>
</para></description></function>
<function name="throw_out_of_range"><type>void</type><parameter name="str"><paramtype>const char *</paramtype></parameter><description><para>Exception callback called by Boost.Container to signal arguments out of range. <itemizedlist>
<listitem>
<para>If BOOST_NO_EXCEPTIONS is NOT defined <computeroutput>std::out_of_range(str)</computeroutput> is thrown.</para><para/></listitem>
<listitem>
<para>If BOOST_NO_EXCEPTIONS is defined and BOOST_CONTAINER_USER_DEFINED_THROW_CALLBACKS is NOT defined <computeroutput>BOOST_ASSERT_MSG(!"boost::container out_of_range thrown", str)</computeroutput> is called and <computeroutput>std::abort()</computeroutput> if the former returns.</para><para/></listitem>
<listitem>
<para>If BOOST_NO_EXCEPTIONS and BOOST_CONTAINER_USER_DEFINED_THROW_CALLBACKS are defined the user must provide an implementation and the function should not return. </para></listitem>
</itemizedlist>
</para></description></function>
<function name="throw_length_error"><type>void</type><parameter name="str"><paramtype>const char *</paramtype></parameter><description><para>Exception callback called by Boost.Container to signal errors resizing. <itemizedlist>
<listitem>
<para>If BOOST_NO_EXCEPTIONS is NOT defined <computeroutput>std::length_error(str)</computeroutput> is thrown.</para><para/></listitem>
<listitem>
<para>If BOOST_NO_EXCEPTIONS is defined and BOOST_CONTAINER_USER_DEFINED_THROW_CALLBACKS is NOT defined <computeroutput>BOOST_ASSERT_MSG(!"boost::container length_error thrown", str)</computeroutput> is called and <computeroutput>std::abort()</computeroutput> if the former returns.</para><para/></listitem>
<listitem>
<para>If BOOST_NO_EXCEPTIONS and BOOST_CONTAINER_USER_DEFINED_THROW_CALLBACKS are defined the user must provide an implementation and the function should not return. </para></listitem>
</itemizedlist>
</para></description></function>
<function name="throw_logic_error"><type>void</type><parameter name="str"><paramtype>const char *</paramtype></parameter><description><para>Exception callback called by Boost.Container to report errors in the internal logical of the program, such as violation of logical preconditions or class invariants. <itemizedlist>
<listitem>
<para>If BOOST_NO_EXCEPTIONS is NOT defined <computeroutput>std::logic_error(str)</computeroutput> is thrown.</para><para/></listitem>
<listitem>
<para>If BOOST_NO_EXCEPTIONS is defined and BOOST_CONTAINER_USER_DEFINED_THROW_CALLBACKS is NOT defined <computeroutput>BOOST_ASSERT_MSG(!"boost::container logic_error thrown", str)</computeroutput> is called and <computeroutput>std::abort()</computeroutput> if the former returns.</para><para/></listitem>
<listitem>
<para>If BOOST_NO_EXCEPTIONS and BOOST_CONTAINER_USER_DEFINED_THROW_CALLBACKS are defined the user must provide an implementation and the function should not return. </para></listitem>
</itemizedlist>
</para></description></function>
<function name="throw_runtime_error"><type>void</type><parameter name="str"><paramtype>const char *</paramtype></parameter><description><para>Exception callback called by Boost.Container to report errors that can only be detected during runtime. <itemizedlist>
<listitem>
<para>If BOOST_NO_EXCEPTIONS is NOT defined <computeroutput>std::runtime_error(str)</computeroutput> is thrown.</para><para/></listitem>
<listitem>
<para>If BOOST_NO_EXCEPTIONS is defined and BOOST_CONTAINER_USER_DEFINED_THROW_CALLBACKS is NOT defined <computeroutput>BOOST_ASSERT_MSG(!"boost::container runtime_error thrown", str)</computeroutput> is called and <computeroutput>std::abort()</computeroutput> if the former returns.</para><para/></listitem>
<listitem>
<para>If BOOST_NO_EXCEPTIONS and BOOST_CONTAINER_USER_DEFINED_THROW_CALLBACKS are defined the user must provide an implementation and the function should not return. </para></listitem>
</itemizedlist>
</para></description></function>





















































</namespace>
</namespace>
</header>
<header name="boost/container/uses_allocator.hpp">
<namespace name="boost">
<namespace name="container">
<struct name="constructible_with_allocator_suffix"><template>
      <template-type-parameter name="T"/>
    </template><description><para><emphasis role="bold">Remark</emphasis>: if a specialization constructible_with_allocator_suffix&lt;X&gt;::value is true, indicates that T may be constructed with an allocator as its last constructor argument. Ideally, all constructors of T (including the copy and move constructors) should have a variant that accepts a final argument of allocator_type.</para><para><emphasis role="bold">Requires</emphasis>: if a specialization constructible_with_allocator_suffix&lt;X&gt;::value is true, T must have a nested type, allocator_type and at least one constructor for which allocator_type is the last parameter. If not all constructors of T can be called with a final allocator_type argument, and if T is used in a context where a container must call such a constructor, then the program is ill-formed.</para><para><computeroutput> template &lt;class T, class Allocator = allocator&lt;T&gt; &gt; class Z { public: typedef Allocator allocator_type;</computeroutput></para><para><computeroutput> // Default constructor with optional allocator suffix Z(const allocator_type&amp; a = allocator_type());</computeroutput></para><para><computeroutput> // Copy constructor and allocator-extended copy constructor Z(const Z&amp; zz); Z(const Z&amp; zz, const allocator_type&amp; a); };</computeroutput></para><para><computeroutput>// Specialize trait for class template Z template &lt;class T, class Allocator = allocator&lt;T&gt; &gt; struct <classname alt="boost::container::constructible_with_allocator_suffix">constructible_with_allocator_suffix</classname>&lt;Z&lt;T,Allocator&gt; &gt; { static const bool value = true; }; </computeroutput></para><para><emphasis role="bold">Note</emphasis>: This trait is a workaround inspired by "N2554: The Scoped A Model (Rev 2)" (Pablo Halpern, 2008-02-29) to backport the scoped allocator model to C++03, as in C++03 there is no mechanism to detect if a type can be constructed from arbitrary arguments. Applications aiming portability with several compilers should always define this trait.</para><para>In conforming C++11 compilers or compilers supporting SFINAE expressions (when BOOST_NO_SFINAE_EXPR is NOT defined), this trait is ignored and C++11 rules will be used to detect if a type should be constructed with suffix or prefix allocator arguments. </para></description><data-member name="value" specifiers="static"><type>const bool</type></data-member>
</struct><struct name="constructible_with_allocator_prefix"><template>
      <template-type-parameter name="T"/>
    </template><description><para><emphasis role="bold">Remark</emphasis>: if a specialization constructible_with_allocator_prefix&lt;X&gt;::value is true, indicates that T may be constructed with allocator_arg and T::allocator_type as its first two constructor arguments. Ideally, all constructors of T (including the copy and move constructors) should have a variant that accepts these two initial arguments.</para><para><emphasis role="bold">Requires</emphasis>: specialization constructible_with_allocator_prefix&lt;X&gt;::value is true, T must have a nested type, allocator_type and at least one constructor for which allocator_arg_t is the first parameter and allocator_type is the second parameter. If not all constructors of T can be called with these initial arguments, and if T is used in a context where a container must call such a constructor, then the program is ill-formed.</para><para><computeroutput> template &lt;class T, class Allocator = allocator&lt;T&gt; &gt; class Y { public: typedef Allocator allocator_type;</computeroutput></para><para><computeroutput> // Default constructor with and allocator-extended default constructor Y(); Y(allocator_arg_t, const allocator_type&amp; a);</computeroutput></para><para><computeroutput> // Copy constructor and allocator-extended copy constructor Y(const Y&amp; yy); Y(allocator_arg_t, const allocator_type&amp; a, const Y&amp; yy);</computeroutput></para><para><computeroutput> // Variadic constructor and allocator-extended variadic constructor template&lt;class ...Args&gt; Y(Args&amp;&amp; args...); template&lt;class ...Args&gt; Y(allocator_arg_t, const allocator_type&amp; a, BOOST_FWD_REF(Args)... args); };</computeroutput></para><para><computeroutput>// Specialize trait for class template Y template &lt;class T, class Allocator = allocator&lt;T&gt; &gt; struct <classname alt="boost::container::constructible_with_allocator_prefix">constructible_with_allocator_prefix</classname>&lt;Y&lt;T,Allocator&gt; &gt; { static const bool value = true; };</computeroutput></para><para><computeroutput/></para><para><emphasis role="bold">Note</emphasis>: This trait is a workaround inspired by "N2554: The Scoped Allocator Model (Rev 2)" (Pablo Halpern, 2008-02-29) to backport the scoped allocator model to C++03, as in C++03 there is no mechanism to detect if a type can be constructed from arbitrary arguments. Applications aiming portability with several compilers should always define this trait.</para><para>In conforming C++11 compilers or compilers supporting SFINAE expressions (when BOOST_NO_SFINAE_EXPR is NOT defined), this trait is ignored and C++11 rules will be used to detect if a type should be constructed with suffix or prefix allocator arguments. </para></description><data-member name="value" specifiers="static"><type>const bool</type></data-member>
</struct><struct name="uses_allocator"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Allocator"/>
    </template><inherit access="public">dtl::uses_allocator_imp&lt; T, Allocator &gt;</inherit><description><para><emphasis role="bold">Remark</emphasis>: Automatically detects whether T has a nested allocator_type that is convertible from Allocator. Meets the BinaryTypeTrait requirements ([meta.rqmts] 20.4.1). A program may specialize this type to define uses_allocator&lt;X&gt;::value as true for a T of user-defined type if T does not have a nested allocator_type but is nonetheless constructible using the specified Allocator where either: the first argument of a constructor has type allocator_arg_t and the second argument has type Alloc or the last argument of a constructor has type Alloc.</para><para><emphasis role="bold">Result</emphasis>: uses_allocator&lt;T, Allocator&gt;::value== true if a type T::allocator_type exists and either is_convertible&lt;Alloc, T::allocator_type&gt;::value != false or T::allocator_type is an alias <computeroutput><classname alt="boost::container::erased_type">erased_type</classname></computeroutput>. False otherwise. </para></description></struct>

























































</namespace>
</namespace>
</header>
<header name="boost/container/uses_allocator_fwd.hpp">
<para>This header forward declares <classname alt="boost::container::constructible_with_allocator_prefix">boost::container::constructible_with_allocator_prefix</classname>, <classname alt="boost::container::constructible_with_allocator_suffix">boost::container::constructible_with_allocator_suffix</classname> and <classname alt="boost::container::uses_allocator">boost::container::uses_allocator</classname>. Also defines the following types: </para><namespace name="boost">
<namespace name="container">
<struct name="erased_type"><description><para>The <computeroutput><classname alt="boost::container::erased_type">erased_type</classname></computeroutput> struct is an empty struct that serves as a placeholder for a type T in situations where the actual type T is determined at runtime. For example, the nested type, <computeroutput>allocator_type</computeroutput>, is an alias for <computeroutput><classname alt="boost::container::erased_type">erased_type</classname></computeroutput> in classes that use type-erased allocators. </para></description></struct><typedef name="allocator_arg_t"><description><para>The allocator_arg_t struct is an empty structure type used as a unique type to disambiguate constructor and function overloading. Specifically, several types have constructors with allocator_arg_t as the first argument, immediately followed by an argument of a type that satisfies Allocator requirements </para></description><type>unspecified</type></typedef>
<data-member name="allocator_arg" specifiers="static"><type>allocator_arg_t</type><description><para>A instance of type allocator_arg_t </para></description></data-member>


























































</namespace>
</namespace>
</header>
<header name="boost/container/vector.hpp">
<namespace name="boost">
<namespace name="container">
<class name="vector"><template>
      <template-type-parameter name="T"><purpose><para>The type of object that is stored in the vector </para></purpose></template-type-parameter>
      <template-type-parameter name="Allocator"><default><classname alt="boost::container::new_allocator">new_allocator</classname>&lt;T&gt;</default><purpose><para>The allocator used for all internal memory management </para></purpose></template-type-parameter>
      <template-type-parameter name="Options"><default>void</default><purpose><para>A type produced from <computeroutput><classname alt="boost::container::vector_options">boost::container::vector_options</classname></computeroutput>. </para></purpose></template-type-parameter>
    </template><description><para>A vector is a sequence that supports random access to elements, constant time insertion and removal of elements at the end, and linear time insertion and removal of elements at the beginning or in the middle. The number of elements in a vector may vary dynamically; memory management is automatic.</para><para>
</para></description><typedef name="value_type"><type>T</type></typedef>
<typedef name="pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::pointer</type></typedef>
<typedef name="const_pointer"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_pointer</type></typedef>
<typedef name="reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::reference</type></typedef>
<typedef name="const_reference"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::const_reference</type></typedef>
<typedef name="size_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::size_type</type></typedef>
<typedef name="difference_type"><type>::<classname>boost::container::allocator_traits</classname>&lt; Allocator &gt;::difference_type</type></typedef>
<typedef name="allocator_type"><type>Allocator</type></typedef>
<typedef name="stored_allocator_type"><type>Allocator</type></typedef>
<typedef name="iterator"><type>implementation_defined</type></typedef>
<typedef name="const_iterator"><type>implementation_defined</type></typedef>
<typedef name="reverse_iterator"><type>implementation_defined</type></typedef>
<typedef name="const_reverse_iterator"><type>implementation_defined</type></typedef>
<method-group name="public member functions">
<method name="assign"><type>void</type><template>
          <template-type-parameter name="InIt"/>
        </template><parameter name="first"><paramtype>InIt</paramtype></parameter><parameter name="lastBOOST_CONTAINER_DOCIGN"><paramtype>InIt </paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the the range [first, last) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy/move constructor/assignment or T's constructor/assignment from dereferencing InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="assign"><type>void</type><parameter name="il"><paramtype>std::initializer_list&lt; T &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the the range [il.begin(), il.end()) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's constructor from dereferencing iniializer_list iterator throws. </para></description></method>
<method name="assign"><type>void</type><template>
          <template-type-parameter name="FwdIt"/>
        </template><parameter name="first"><paramtype>FwdIt</paramtype></parameter><parameter name="lastBOOST_CONTAINER_DOCIGN"><paramtype>FwdIt </paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the the range [first, last) to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy/move constructor/assignment or T's constructor/assignment from dereferencing InpIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="assign"><type>void</type><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Assigns the n copies of val to *this.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy/move constructor/assignment throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="get_allocator" cv="const noexcept"><type>allocator_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a copy of the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: If allocator's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="get_stored_allocator" cv="noexcept"><type>stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="get_stored_allocator" cv="const noexcept"><type>const stored_allocator_type &amp;</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the internal allocator.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="begin" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the first element contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="begin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="noexcept"><type>iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the end of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="end" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the beginning of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="noexcept"><type>reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a reverse_iterator pointing to the end of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="rend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cbegin" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the first element contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="cend" cv="const noexcept"><type>const_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the end of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crbegin" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the beginning of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="crend" cv="const noexcept"><type>const_reverse_iterator</type><description><para><emphasis role="bold">Effects</emphasis>: Returns a const_reverse_iterator pointing to the end of the reversed vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="empty" cv="const noexcept"><type>bool</type><description><para><emphasis role="bold">Effects</emphasis>: Returns true if the vector contains no elements.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the number of the elements contained in the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="max_size" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Returns the largest possible size of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="resize"><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are value initialized.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy/move or value initialization throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method>
<method name="resize"><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are default initialized.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy/move or default initialization throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="resize"><type>void</type><parameter name="new_size"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts or erases elements at the end such that the size becomes n. New elements are copy constructed from x.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy/move constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the difference between size() and new_size. </para></description></method>
<method name="capacity" cv="const noexcept"><type>size_type</type><description><para><emphasis role="bold">Effects</emphasis>: Number of elements for which memory has been allocated. capacity() is always greater than or equal to size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="reserve"><type>void</type><parameter name="new_cap"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: If n is less than or equal to capacity(), this call has no effect. Otherwise, it is a request for allocation of additional memory. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged. In either case, size() is unchanged.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation allocation throws or T's copy/move constructor throws. </para></description></method>
<method name="shrink_to_fit"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Tries to deallocate the excess of memory created with previous allocations. The size of the vector is unchanged</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, or T's copy/move constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to size(). </para></description></method>
<method name="front" cv="noexcept"><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the first element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="front" cv="const noexcept"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the first element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="back" cv="noexcept"><type>reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the last element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="back" cv="const noexcept"><type>const_reference</type><description><para><emphasis role="bold">Requires</emphasis>: !empty()</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the last element of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="operator[]" cv="noexcept"><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="operator[]" cv="const noexcept"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="nth" cv="noexcept"><type>iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns an iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="nth" cv="const noexcept"><type>const_iterator</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt;= n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const_iterator to the nth element from the beginning of the container. Returns end() if n == size().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="noexcept"><type>size_type</type><parameter name="p"><paramtype>iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="index_of" cv="const noexcept"><type>size_type</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: begin() &lt;= p &lt;= end().</para><para><emphasis role="bold">Effects</emphasis>: Returns the index of the element pointed by p and size() if p == end().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></method>
<method name="at"><type>reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: std::range_error if n &gt;= size()</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="at" cv="const"><type>const_reference</type><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: size() &gt; n.</para><para><emphasis role="bold">Effects</emphasis>: Returns a const reference to the nth element from the beginning of the container.</para><para><emphasis role="bold">Throws</emphasis>: std::range_error if n &gt;= size()</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="data" cv="noexcept"><type>T *</type><description><para><emphasis role="bold">Returns</emphasis>: A pointer such that [data(),data() + size()) is a valid range. For a non-empty vector, data() == &amp;front().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="data" cv="const noexcept"><type>const T *</type><description><para><emphasis role="bold">Returns</emphasis>: A pointer such that [data(),data() + size()) is a valid range. For a non-empty vector, data() == &amp;front().</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="emplace_back"><type>reference</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the end of the vector.</para><para><emphasis role="bold">Returns</emphasis>: A reference to the created object.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or the in-place constructor throws or T's copy/move constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="stable_emplace_back"><type>bool</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... in the end of the vector.</para><para><emphasis role="bold">Throws</emphasis>: If the in-place constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension. </para></description></method>
<method name="emplace"><type>iterator</type><template>
          <template-nontype-parameter name="Args"><type>class...</type></template-nontype-parameter>
        </template><parameter name="position"><paramtype>const_iterator</paramtype></parameter><parameter name="args"><paramtype>Args &amp;&amp;...</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: position must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Inserts an object of type T constructed with std::forward&lt;Args&gt;(args)... before position</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or the in-place constructor throws or T's copy/move constructor/assignment throws.</para><para><emphasis role="bold">Complexity</emphasis>: If position is end(), amortized constant time Linear time otherwise. </para></description></method>
<method name="push_back"><type>void</type><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Inserts a copy of x at the end of the vector.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy/move constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="push_back"><type>void</type><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a new element in the end of the vector and moves the resources of x to this new element.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy/move constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Amortized constant time. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: position must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of x before position.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy/move constructor/assignment throws.</para><para><emphasis role="bold">Complexity</emphasis>: If position is end(), amortized constant time Linear time otherwise. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><parameter name="x"><paramtype>T &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: position must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a new element before position with x's resources.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws.</para><para><emphasis role="bold">Complexity</emphasis>: If position is end(), amortized constant time Linear time otherwise. </para></description></method>
<method name="insert"><type>iterator</type><parameter name="p"><paramtype>const_iterator</paramtype></parameter><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="x"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert n copies of x before pos.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or p if n is 0.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy/move constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></method>
<method name="insert"><type>iterator</type><template>
          <template-type-parameter name="InIt"/>
        </template><parameter name="pos"><paramtype>const_iterator</paramtype></parameter><parameter name="first"><paramtype>InIt</paramtype></parameter><parameter name="last"><paramtype>InIt</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [first, last) range before pos.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or pos if first == last.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced InpIt throws or T's copy/move constructor/assignment throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to boost::container::iterator_distance [first, last). </para></description></method>
<method name="insert"><type>iterator</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Requires</emphasis>: p must be a valid iterator of *this. num, must be equal to boost::container::iterator_distance(first, last)</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [first, last) range before pos.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or pos if first == last.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws, T's constructor from a dereferenced InpIt throws or T's copy/move constructor/assignment throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to boost::container::iterator_distance [first, last).</para><para><emphasis role="bold">Note</emphasis>: This function avoids a linear operation to calculate boost::container::iterator_distance[first, last) for forward and bidirectional iterators, and a one by one insertion for input iterators. This is a a non-standard extension. <emphasis role="bold">Requires</emphasis>: position must be a valid iterator of *this.</para><para><emphasis role="bold">Effects</emphasis>: Insert a copy of the [il.begin(), il.end()) range before position.</para><para><emphasis role="bold">Returns</emphasis>: an iterator to the first inserted element or position if first == last.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [il.begin(), il.end()). </para></description></method>
<method name="pop_back" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Removes the last element from the container.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant time. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="position"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the element at position pos.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements between pos and the last element. Constant if pos is the last element. </para></description></method>
<method name="erase"><type>iterator</type><parameter name="first"><paramtype>const_iterator</paramtype></parameter><parameter name="last"><paramtype>const_iterator</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Erases the elements pointed by [first, last).</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the distance between first and last plus linear to the elements between pos and the last element. </para></description></method>
<method name="swap" cv="noexcept(((allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value)&amp;&amp;!dtl::is_version&lt; Allocator, 0 &gt;::value)))"><type>void</type><parameter name="x"><paramtype><classname>vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Swaps the contents of *this and x.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
<method name="clear" cv="noexcept"><type>void</type><description><para><emphasis role="bold">Effects</emphasis>: Erases all the elements of the vector.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
</method-group>
<constructor cv="noexcept(dtl::is_nothrow_default_constructible&lt; Allocator &gt;::value))"><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector taking the allocator as parameter.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit" cv="noexcept"><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector taking the allocator as parameter.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="n"><paramtype>size_type</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector and inserts n value initialized values.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's allocation throws or T's value initialization throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor specifiers="explicit"><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector that will use a copy of allocator a and inserts n value initialized values.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's allocation throws or T's value initialization throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector that will use a copy of allocator a and inserts n default initialized values.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's allocation throws or T's default initialization throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name=""><paramtype><classname>default_init_t</classname></paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector that will use a copy of allocator a and inserts n default initialized values.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's allocation throws or T's default initialization throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n.</para><para><emphasis role="bold">Note</emphasis>: Non-standard extension </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="value"><paramtype>const T &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector and inserts n copies of value.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><parameter name="n"><paramtype>size_type</paramtype></parameter><parameter name="value"><paramtype>const T &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector that will use a copy of allocator a and inserts n copies of value.</para><para><emphasis role="bold">Throws</emphasis>: If allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to n. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InIt"/>
        </template><parameter name="first"><paramtype>InIt</paramtype></parameter><parameter name="BOOST_CONTAINER_DOCIGN"><paramtype>InIt last </paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector and inserts a copy of the range [first, last) in the vector.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's allocation throws or T's constructor taking a dereferenced InIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [first, last). </para></description></constructor>
<constructor><template>
          <template-type-parameter name="InIt"/>
        </template><parameter name="first"><paramtype>InIt</paramtype></parameter><parameter name="last"><paramtype>InIt</paramtype></parameter><parameter name="BOOST_CONTAINER_DOCIGN"><paramtype>const allocator_type &amp;a </paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector that will use a copy of allocator a and inserts a copy of the range [first, last) in the vector.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's allocation throws or T's constructor taking a dereferenced InIt throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [first, last). </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a vector.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_type's allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></constructor>
<constructor cv="noexcept"><parameter name="x"><paramtype><classname>vector</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor. Moves x's resources to *this.</para><para><emphasis role="bold">Throws</emphasis>: Nothing</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></constructor>
<constructor><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype><default>allocator_type()</default></parameter><description><para><emphasis role="bold">Effects</emphasis>: Constructs a vector that will use a copy of allocator a and inserts a copy of the range [il.begin(), il.last()) in the vector</para><para><emphasis role="bold">Throws</emphasis>: If T's constructor taking a dereferenced initializer_list iterator throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [il.begin(), il.end()). </para></description></constructor>
<constructor><parameter name="x"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><purpose>defined(BOOST_CONTAINER_DOXYGEN_INVOKED) </purpose><description><para><emphasis role="bold">Effects</emphasis>: Copy constructs a vector using the specified allocator.</para><para><emphasis role="bold">Postcondition</emphasis>: x == *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocation throws or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the elements x contains. </para></description></constructor>
<constructor><parameter name="x"><paramtype><classname>vector</classname> &amp;&amp;</paramtype></parameter><parameter name="a"><paramtype>const allocator_type &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move constructor using the specified allocator. Moves x's resources to *this if a == allocator_type(). Otherwise copies values from x to *this.</para><para><emphasis role="bold">Throws</emphasis>: If allocation or T's copy constructor throws.</para><para><emphasis role="bold">Complexity</emphasis>: Constant if a == x.get_allocator(), linear otherwise. </para></description></constructor>
<destructor><description><para><emphasis role="bold">Effects</emphasis>: Destroys the vector. All stored values are destroyed and used memory is deallocated.</para><para><emphasis role="bold">Throws</emphasis>: Nothing.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements. </para></description></destructor>
<copy-assignment><type><classname>vector</classname> &amp;</type><parameter name="x"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Makes *this contain the same elements as x.</para><para><emphasis role="bold">Postcondition</emphasis>: this-&gt;size() == x.size(). *this contains a copy of each of x's elements.</para><para><emphasis role="bold">Throws</emphasis>: If memory allocation throws or T's copy/move constructor/assignment throws.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in x. </para></description></copy-assignment>
<copy-assignment><type><classname>vector</classname> &amp;</type><parameter name="il"><paramtype>std::initializer_list&lt; value_type &gt;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Make *this container contains elements from il.</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the range [il.begin(), il.end()). </para></description></copy-assignment>
<copy-assignment cv="noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value))"><type><classname>vector</classname> &amp;</type><parameter name="x"><paramtype><classname>vector</classname> &amp;&amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Move assignment. All x's values are transferred to *this.</para><para><emphasis role="bold">Postcondition</emphasis>: x.empty(). *this contains a the elements x had before the function.</para><para><emphasis role="bold">Throws</emphasis>: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type's move constructor throws)</para><para><emphasis role="bold">Complexity</emphasis>: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this-&gt;get&gt;allocator() == x.get_allocator(). Linear otherwise. </para></description></copy-assignment>
<method-group name="friend functions">
<method name="operator=="><type>friend bool</type><parameter name="x"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are equal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator!="><type>friend bool</type><parameter name="x"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x and y are unequal</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;"><type>friend bool</type><parameter name="x"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&lt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or less than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="operator&gt;="><type>friend bool</type><parameter name="x"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype>const <classname>vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: Returns true if x is equal or greater than y</para><para><emphasis role="bold">Complexity</emphasis>: Linear to the number of elements in the container. </para></description></method>
<method name="swap"><type>friend void</type><parameter name="x"><paramtype><classname>vector</classname> &amp;</paramtype></parameter><parameter name="y"><paramtype><classname>vector</classname> &amp;</paramtype></parameter><description><para><emphasis role="bold">Effects</emphasis>: x.swap(y)</para><para><emphasis role="bold">Complexity</emphasis>: Constant. </para></description></method>
</method-group>
</class>

























































</namespace>
</namespace>
</header>
<header name="boost/container/pmr/vector.hpp">
<namespace name="boost">
<namespace name="container">
<namespace name="pmr">
<struct name="vector_of"><template>
      <template-type-parameter name="T"/>
    </template><description><para>A portable metafunction to obtain a vector that uses a polymorphic allocator </para></description><typedef name="type"><type><classname>boost::container::vector</classname>&lt; T, <classname>polymorphic_allocator</classname>&lt; T &gt; &gt;</type></typedef>
</struct><typedef name="vector"><type><classname>boost::container::vector</classname>&lt; T, <classname>polymorphic_allocator</classname>&lt; T &gt;&gt;</type></typedef>






</namespace>


























































</namespace>
</namespace>
</header>
</library-reference>