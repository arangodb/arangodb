<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/xpressive/basic_regex.hpp">
<para>Contains the definition of the basic_regex&lt;&gt; class template and its associated helper functions. </para><namespace name="boost">
<namespace name="xpressive">
























































































<function name="swap"><type>void</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="left"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The first <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object. </para></description></parameter><parameter name="right"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The second <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object. </para></description></parameter><purpose>Swaps the contents of two <classname alt="boost::xpressive::basic_regex">basic_regex</classname> objects. </purpose><description><para>
<note><para>This is a shallow swap that does not do reference tracking. If you embed a <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object by reference in another regular expression and then swap its contents with another <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object, the change will not be visible to the enclosing regular expression. It is done this way to ensure that swap() cannot throw. </para></note>

</para></description><throws><simpara>Will not throw.</simpara></throws></function>
</namespace>
</namespace>
</header>
<header name="boost/xpressive/match_results.hpp">
<para>Contains the definition of the match_results type and associated helpers. The match_results type holds the results of a regex_match() or regex_search() operation. </para><namespace name="boost">
<namespace name="xpressive">

























































































</namespace>
</namespace>
</header>
<header name="boost/xpressive/regex_actions.hpp">
<para>Defines the syntax elements of xpressive's action expressions. </para><namespace name="boost">
<namespace name="xpressive">
<struct name="function"><template>
      <template-type-parameter name="PolymorphicFunctionObject"/>
    </template><purpose>A unary metafunction that turns an ordinary function object type into the type of a deferred function object for use in xpressive semantic actions. </purpose><description><para>Use <computeroutput><classname alt="boost::xpressive::function">xpressive::function</classname>&lt;&gt;</computeroutput> to turn an ordinary polymorphic function object type into a type that can be used to declare an object for use in xpressive semantic actions.</para><para>For example, the global object <computeroutput>xpressive::push_back</computeroutput> can be used to create deferred actions that have the effect of pushing a value into a container. It is defined with <computeroutput><classname alt="boost::xpressive::function">xpressive::function</classname>&lt;&gt;</computeroutput> as follows:<programlisting language="c++">xpressive::function&lt;xpressive::op::push_back&gt;::type const push_back = {};
</programlisting> where <computeroutput><classname alt="boost::xpressive::op::push_back">op::push_back</classname></computeroutput> is an ordinary function object that pushes its second argument into its first. Thus defined, <computeroutput>xpressive::push_back</computeroutput> can be used in semantic actions as follows:<programlisting language="c++">namespace xp = boost::xpressive;
using xp::_;
std::list&lt;int&gt; result;
std::string str("1 23 456 7890");
xp::sregex rx = (+_d)[ xp::push_back(xp::ref(result), xp::as&lt;int&gt;(_) ]
    &gt;&gt; *(' ' &gt;&gt; (+_d)[ xp::push_back(xp::ref(result), xp::as&lt;int&gt;(_) ) ]);
</programlisting> </para></description><typedef name="type"><type>proto::terminal&lt; PolymorphicFunctionObject &gt;::type</type></typedef>
</struct><namespace name="op">
<struct name="at"><purpose><computeroutput>at</computeroutput> is a PolymorphicFunctionObject for indexing into a sequence </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Cont"/>
      <template-type-parameter name="Idx"/>
    </template><specialization><template-arg>This(Cont &amp;</template-arg><template-arg>Idx)</template-arg></specialization><typedef name="type"><type>Cont::reference</type></typedef>
</struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Cont"/>
      <template-type-parameter name="Idx"/>
    </template><specialization><template-arg>This(Cont const &amp;</template-arg><template-arg>Idx)</template-arg></specialization><typedef name="type"><type>Cont::const_reference</type></typedef>
</struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Cont"/>
      <template-type-parameter name="Idx"/>
    </template><specialization><template-arg>This(Cont</template-arg><template-arg>Idx)</template-arg></specialization><typedef name="type"><type>Cont::const_reference</type></typedef>
</struct-specialization><method-group name="public member functions">
<method name="operator()" cv="const"><type>Cont::reference</type><template>
          <template-type-parameter name="Cont"/>
          <template-type-parameter name="Idx"/>
        </template><parameter name="c"><paramtype>Cont &amp;</paramtype><description><para>The RandomAccessSequence to index into </para></description></parameter><parameter name="idx"><paramtype>Idx</paramtype><description><para>The index </para></description></parameter><description><para>


</para></description><requires><para><computeroutput>Cont</computeroutput> is a model of RandomAccessSequence </para></requires><returns><para><computeroutput>c[idx]</computeroutput> </para></returns></method>
<method name="operator()" cv="const"><type>Cont::const_reference</type><template>
          <template-type-parameter name="Cont"/>
          <template-type-parameter name="Idx"/>
        </template><parameter name="c"><paramtype>Cont const &amp;</paramtype></parameter><parameter name="idx"><paramtype>Idx</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
</method-group>
</struct><struct name="push"><purpose><computeroutput>push</computeroutput> is a PolymorphicFunctionObject for pushing an element into a container. </purpose><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
          <template-type-parameter name="Value"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence into which the value should be pushed. </para></description></parameter><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to push into the sequence. </para></description></parameter><purpose>Equivalent to <computeroutput>seq.push(val)</computeroutput>. </purpose><description><para>

</para></description><returns><para><computeroutput>void</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="push_back"><purpose><computeroutput><classname alt="boost::xpressive::op::push_back">push_back</classname></computeroutput> is a PolymorphicFunctionObject for pushing an element into the back of a container. </purpose><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
          <template-type-parameter name="Value"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence into which the value should be pushed. </para></description></parameter><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to push into the sequence. </para></description></parameter><purpose>Equivalent to <computeroutput>seq.push_back(val)</computeroutput>. </purpose><description><para>

</para></description><returns><para><computeroutput>void</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="push_front"><purpose><computeroutput><classname alt="boost::xpressive::op::push_front">push_front</classname></computeroutput> is a PolymorphicFunctionObject for pushing an element into the front of a container. </purpose><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
          <template-type-parameter name="Value"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence into which the value should be pushed. </para></description></parameter><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to push into the sequence. </para></description></parameter><purpose>Equivalent to <computeroutput>seq.push_front(val)</computeroutput>. </purpose><description><para>

</para></description><returns><para><computeroutput>void</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="pop"><purpose><computeroutput>pop</computeroutput> is a PolymorphicFunctionObject for popping an element from a container. </purpose><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence from which to pop. </para></description></parameter><purpose>Equivalent to <computeroutput>seq.pop()</computeroutput>. </purpose><description><para>

</para></description><returns><para><computeroutput>void</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="pop_back"><purpose><computeroutput><classname alt="boost::xpressive::op::pop_back">pop_back</classname></computeroutput> is a PolymorphicFunctionObject for popping an element from the back of a container. </purpose><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence from which to pop. </para></description></parameter><purpose>Equivalent to <computeroutput>seq.pop_back()</computeroutput>. </purpose><description><para>

</para></description><returns><para><computeroutput>void</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="pop_front"><purpose><computeroutput><classname alt="boost::xpressive::op::pop_front">pop_front</classname></computeroutput> is a PolymorphicFunctionObject for popping an element from the front of a container. </purpose><typedef name="result_type"><type>void</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence from which to pop. </para></description></parameter><purpose>Equivalent to <computeroutput>seq.pop_front()</computeroutput>. </purpose><description><para>

</para></description><returns><para><computeroutput>void</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="front"><purpose><computeroutput>front</computeroutput> is a PolymorphicFunctionObject for fetching the front element of a container. </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>This(Sequence)</template-arg></specialization><typedef name="sequence_type"><type>remove_reference&lt; Sequence &gt;::type</type></typedef>
<typedef name="type"><type>mpl::if_c&lt; is_const&lt; sequence_type &gt;::<classname>value</classname>, typename sequence_type::const_reference, typename sequence_type::reference &gt;::type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>front</classname>(Sequence &amp;)&gt;::type</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence from which to fetch the front. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>seq.front()</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="back"><purpose><computeroutput>back</computeroutput> is a PolymorphicFunctionObject for fetching the back element of a container. </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>This(Sequence)</template-arg></specialization><typedef name="sequence_type"><type>remove_reference&lt; Sequence &gt;::type</type></typedef>
<typedef name="type"><type>mpl::if_c&lt; is_const&lt; sequence_type &gt;::<classname>value</classname>, typename sequence_type::const_reference, typename sequence_type::reference &gt;::type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>back</classname>(Sequence &amp;)&gt;::type</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence from which to fetch the back. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>seq.back()</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="top"><purpose><computeroutput>top</computeroutput> is a PolymorphicFunctionObject for fetching the top element of a stack. </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>This(Sequence)</template-arg></specialization><typedef name="sequence_type"><type>remove_reference&lt; Sequence &gt;::type</type></typedef>
<typedef name="type"><type>mpl::if_c&lt; is_const&lt; sequence_type &gt;::<classname>value</classname>, typename sequence_type::value_type const &amp;, typename sequence_type::value_type &amp; &gt;::type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>top</classname>(Sequence &amp;)&gt;::type</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="seq"><paramtype>Sequence &amp;</paramtype><description><para>The sequence from which to fetch the top. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>seq.top()</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="first"><purpose><computeroutput>first</computeroutput> is a PolymorphicFunctionObject for fetching the first element of a pair. </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Pair"/>
    </template><specialization><template-arg>This(Pair)</template-arg></specialization><typedef name="type"><type>remove_reference&lt; Pair &gt;::type::first_type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method name="operator()" cv="const"><type>Pair::first_type</type><template>
          <template-type-parameter name="Pair"/>
        </template><parameter name="p"><paramtype>Pair const &amp;</paramtype><description><para>The pair from which to fetch the first element. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>p.first</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="second"><purpose><computeroutput>second</computeroutput> is a PolymorphicFunctionObject for fetching the second element of a pair. </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Pair"/>
    </template><specialization><template-arg>This(Pair)</template-arg></specialization><typedef name="type"><type>remove_reference&lt; Pair &gt;::type::second_type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method name="operator()" cv="const"><type>Pair::second_type</type><template>
          <template-type-parameter name="Pair"/>
        </template><parameter name="p"><paramtype>Pair const &amp;</paramtype><description><para>The pair from which to fetch the second element. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>p.second</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="matched"><purpose><computeroutput>matched</computeroutput> is a PolymorphicFunctionObject for assessing whether a <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname></computeroutput> object matched or not. </purpose><typedef name="result_type"><type>bool</type></typedef>
<method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><template>
          <template-type-parameter name="Sub"/>
        </template><parameter name="sub"><paramtype>Sub const &amp;</paramtype><description><para>The <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname></computeroutput> object. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>sub.matched</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="length"><purpose><computeroutput>length</computeroutput> is a PolymorphicFunctionObject for fetching the length of <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname></computeroutput>. </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sub"/>
    </template><specialization><template-arg>This(Sub)</template-arg></specialization><typedef name="type"><type>remove_reference&lt; Sub &gt;::type::difference_type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method name="operator()" cv="const"><type>Sub::difference_type</type><template>
          <template-type-parameter name="Sub"/>
        </template><parameter name="sub"><paramtype>Sub const &amp;</paramtype><description><para>The <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname></computeroutput> object. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>sub.length()</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="str"><purpose><computeroutput>str</computeroutput> is a PolymorphicFunctionObject for turning a <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname></computeroutput> into an equivalent <computeroutput>std::string</computeroutput>. </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sub"/>
    </template><specialization><template-arg>This(Sub)</template-arg></specialization><typedef name="type"><type>remove_reference&lt; Sub &gt;::type::string_type</type></typedef>
</struct-specialization><method-group name="public member functions">
<method name="operator()" cv="const"><type>Sub::string_type</type><template>
          <template-type-parameter name="Sub"/>
        </template><parameter name="sub"><paramtype>Sub const &amp;</paramtype><description><para>The <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname></computeroutput> object. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>sub.str()</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="insert"><purpose><computeroutput>insert</computeroutput> is a PolymorphicFunctionObject for inserting a value or a sequence of values into a sequence container, an associative container, or a string. </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef>
</struct><method-group name="public member functions">
<method name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>insert</classname>(Cont &amp;, A0 const &amp;)&gt;::type</type><template>
          <template-type-parameter name="Cont"/>
          <template-type-parameter name="A0"/>
        </template><parameter name="cont"><paramtype>Cont &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>insert</classname>(Cont &amp;, A0 const &amp;, A1 const &amp;)&gt;::type</type><template>
          <template-type-parameter name="Cont"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="cont"><paramtype>Cont &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>insert</classname>(Cont &amp;, A0 const &amp;, A1 const &amp;, A2 const &amp;)&gt;::type</type><template>
          <template-type-parameter name="Cont"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="cont"><paramtype>Cont &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="operator()" cv="const"><type><classname>result</classname>&lt; <classname>insert</classname>(Cont &amp;, A0 const &amp;, A1 const &amp;, A2 const &amp;, A3 const &amp;)&gt;::type</type><template>
          <template-type-parameter name="Cont"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="cont"><paramtype>Cont &amp;</paramtype><description><para>The container into which to insert the element(s) </para></description></parameter><parameter name="a0"><paramtype>A0 const &amp;</paramtype><description><para>A value, iterator, or count </para></description></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype><description><para>A value, iterator, string, count, or character </para></description></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype><description><para>A value, iterator, or count </para></description></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype><description><para>A count </para></description></parameter><description><para>

</para></description><returns><para><itemizedlist>
<listitem><para>For the form <computeroutput>insert()(cont, a0)</computeroutput>, return <computeroutput>cont.insert(a0)</computeroutput>. </para></listitem>
<listitem><para>For the form <computeroutput>insert()(cont, a0, a1)</computeroutput>, return <computeroutput>cont.insert(a0, a1)</computeroutput>. </para></listitem>
<listitem><para>For the form <computeroutput>insert()(cont, a0, a1, a2)</computeroutput>, return <computeroutput>cont.insert(a0, a1, a2)</computeroutput>. </para></listitem>
<listitem><para>For the form <computeroutput>insert()(cont, a0, a1, a2, a3)</computeroutput>, return <computeroutput>cont.insert(a0, a1, a2, a3)</computeroutput>. </para></listitem>
</itemizedlist>
</para></returns></method>
</method-group>
</struct><struct name="make_pair"><purpose><computeroutput><classname alt="boost::xpressive::op::make_pair">make_pair</classname></computeroutput> is a PolymorphicFunctionObject for building a <computeroutput><classname alt="std::pair">std::pair</classname></computeroutput> out of two parameters </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="First"/>
      <template-type-parameter name="Second"/>
    </template><specialization><template-arg>This(First</template-arg><template-arg>Second)</template-arg></specialization><typedef name="first_type"><purpose>For exposition only. </purpose><type>decay&lt; First &gt;::type</type></typedef>
<typedef name="second_type"><purpose>For exposition only. </purpose><type>decay&lt; Second &gt;::type</type></typedef>
<typedef name="type"><type><classname>std::pair</classname>&lt; first_type, second_type &gt;</type></typedef>
</struct-specialization><method-group name="public member functions">
<method name="operator()" cv="const"><type><classname>std::pair</classname>&lt; First, Second &gt;</type><template>
          <template-type-parameter name="First"/>
          <template-type-parameter name="Second"/>
        </template><parameter name="first"><paramtype>First const &amp;</paramtype><description><para>The first element of the pair </para></description></parameter><parameter name="second"><paramtype>Second const &amp;</paramtype><description><para>The second element of the pair </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>std::make_pair(first, second)</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="unwrap_reference"><purpose><computeroutput><classname alt="boost::xpressive::op::unwrap_reference">unwrap_reference</classname></computeroutput> is a PolymorphicFunctionObject for unwrapping a <computeroutput>boost::reference_wrapper&lt;&gt;</computeroutput>. </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Ref"/>
    </template><specialization><template-arg>This(Ref &amp;)</template-arg></specialization><typedef name="type"><type>boost::unwrap_reference&lt; Ref &gt;::type &amp;</type></typedef>
</struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Ref"/>
    </template><specialization><template-arg>This(Ref)</template-arg></specialization><typedef name="type"><type>boost::unwrap_reference&lt; Ref &gt;::type &amp;</type></typedef>
</struct-specialization><method-group name="public member functions">
<method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="r"><paramtype>boost::reference_wrapper&lt; T &gt;</paramtype><description><para>The <computeroutput>boost::reference_wrapper&lt;T&gt;</computeroutput> to unwrap. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>static_cast&lt;T &amp;&gt;(r)</computeroutput> </para></returns></method>
</method-group>
</struct></namespace>
<data-member name="at"><type><classname>function</classname>&lt; <classname>op::at</classname> &gt;::type const</type><purpose><computeroutput>at</computeroutput> is a lazy PolymorphicFunctionObject for indexing into a sequence in an xpressive semantic action. </purpose></data-member>
<data-member name="push"><type><classname>function</classname>&lt; <classname>op::push</classname> &gt;::type const</type><purpose><computeroutput>push</computeroutput> is a lazy PolymorphicFunctionObject for pushing a value into a container in an xpressive semantic action. </purpose></data-member>
<data-member name="push_back"><type><classname>function</classname>&lt; <classname>op::push_back</classname> &gt;::type const</type><purpose><computeroutput>push_back</computeroutput> is a lazy PolymorphicFunctionObject for pushing a value into a container in an xpressive semantic action. </purpose></data-member>
<data-member name="push_front"><type><classname>function</classname>&lt; <classname>op::push_front</classname> &gt;::type const</type><purpose><computeroutput>push_front</computeroutput> is a lazy PolymorphicFunctionObject for pushing a value into a container in an xpressive semantic action. </purpose></data-member>
<data-member name="pop"><type><classname>function</classname>&lt; <classname>op::pop</classname> &gt;::type const</type><purpose><computeroutput>pop</computeroutput> is a lazy PolymorphicFunctionObject for popping the top element from a sequence in an xpressive semantic action. </purpose></data-member>
<data-member name="pop_back"><type><classname>function</classname>&lt; <classname>op::pop_back</classname> &gt;::type const</type><purpose><computeroutput>pop_back</computeroutput> is a lazy PolymorphicFunctionObject for popping the back element from a sequence in an xpressive semantic action. </purpose></data-member>
<data-member name="pop_front"><type><classname>function</classname>&lt; <classname>op::pop_front</classname> &gt;::type const</type><purpose><computeroutput>pop_front</computeroutput> is a lazy PolymorphicFunctionObject for popping the front element from a sequence in an xpressive semantic action. </purpose></data-member>
<data-member name="top"><type><classname>function</classname>&lt; <classname>op::top</classname> &gt;::type const</type><purpose><computeroutput>top</computeroutput> is a lazy PolymorphicFunctionObject for accessing the top element from a stack in an xpressive semantic action. </purpose></data-member>
<data-member name="back"><type><classname>function</classname>&lt; <classname>op::back</classname> &gt;::type const</type><purpose><computeroutput>back</computeroutput> is a lazy PolymorphicFunctionObject for fetching the back element of a sequence in an xpressive semantic action. </purpose></data-member>
<data-member name="front"><type><classname>function</classname>&lt; <classname>op::front</classname> &gt;::type const</type><purpose><computeroutput>front</computeroutput> is a lazy PolymorphicFunctionObject for fetching the front element of a sequence in an xpressive semantic action. </purpose></data-member>
<data-member name="first"><type><classname>function</classname>&lt; <classname>op::first</classname> &gt;::type const</type><purpose><computeroutput>first</computeroutput> is a lazy PolymorphicFunctionObject for accessing the first element of a <computeroutput><classname alt="std::pair">std::pair</classname>&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>
<data-member name="second"><type><classname>function</classname>&lt; <classname>op::second</classname> &gt;::type const</type><purpose><computeroutput>second</computeroutput> is a lazy PolymorphicFunctionObject for accessing the second element of a <computeroutput><classname alt="std::pair">std::pair</classname>&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>
<data-member name="matched"><type><classname>function</classname>&lt; <classname>op::matched</classname> &gt;::type const</type><purpose><computeroutput>matched</computeroutput> is a lazy PolymorphicFunctionObject for accessing the <computeroutput>matched</computeroutput> member of a <computeroutput><classname alt="boost::xpressive::sub_match">xpressive::sub_match</classname>&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>
<data-member name="length"><type><classname>function</classname>&lt; <classname>op::length</classname> &gt;::type const</type><purpose><computeroutput>length</computeroutput> is a lazy PolymorphicFunctionObject for computing the length of a <computeroutput><classname alt="boost::xpressive::sub_match">xpressive::sub_match</classname>&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>
<data-member name="str"><type><classname>function</classname>&lt; <classname>op::str</classname> &gt;::type const</type><purpose><computeroutput>str</computeroutput> is a lazy PolymorphicFunctionObject for converting a <computeroutput><classname alt="boost::xpressive::sub_match">xpressive::sub_match</classname>&lt;&gt;</computeroutput> to a <computeroutput>std::basic_string&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>
<data-member name="insert"><type><classname>function</classname>&lt; <classname>op::insert</classname> &gt;::type const</type><purpose><computeroutput>insert</computeroutput> is a lazy PolymorphicFunctionObject for inserting a value or a range of values into a sequence in an xpressive semantic action. </purpose></data-member>
<data-member name="make_pair"><type><classname>function</classname>&lt; <classname>op::make_pair</classname> &gt;::type const</type><purpose><computeroutput>make_pair</computeroutput> is a lazy PolymorphicFunctionObject for making a <computeroutput><classname alt="std::pair">std::pair</classname>&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>
<data-member name="unwrap_reference"><type><classname>function</classname>&lt; <classname>op::unwrap_reference</classname> &gt;::type const</type><purpose><computeroutput>unwrap_reference</computeroutput> is a lazy PolymorphicFunctionObject for unwrapping a <computeroutput>boost::reference_wrapper&lt;&gt;</computeroutput> in an xpressive semantic action. </purpose></data-member>














































































<function name="as"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"><purpose><para>The type to which to lexically cast the parameter. </para></purpose></template-type-parameter>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype><description><para>The lazy value to lexically cast. </para></description></parameter><purpose><computeroutput>as()</computeroutput> is a lazy funtion for lexically casting a parameter to a different type. </purpose><description><para>


</para></description><returns><para>A lazy object that, when evaluated, lexically casts its argument to the desired type. </para></returns></function>
<function name="static_cast_"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"><purpose><para>The type to which to statically cast the parameter. </para></purpose></template-type-parameter>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype><description><para>The lazy value to statically cast. </para></description></parameter><purpose><computeroutput>static_cast_</computeroutput> is a lazy funtion for statically casting a parameter to a different type. </purpose><description><para>


</para></description><returns><para>A lazy object that, when evaluated, statically casts its argument to the desired type. </para></returns></function>
<function name="dynamic_cast_"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"><purpose><para>The type to which to dynamically cast the parameter. </para></purpose></template-type-parameter>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype><description><para>The lazy value to dynamically cast. </para></description></parameter><purpose><computeroutput>dynamic_cast_</computeroutput> is a lazy funtion for dynamically casting a parameter to a different type. </purpose><description><para>


</para></description><returns><para>A lazy object that, when evaluated, dynamically casts its argument to the desired type. </para></returns></function>
<function name="const_cast_"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"><purpose><para>The type to which to const-cast the parameter. </para></purpose></template-type-parameter>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype><description><para>The lazy value to const-cast. </para></description></parameter><purpose><computeroutput>dynamic_cast_</computeroutput> is a lazy funtion for const-casting a parameter to a different type. </purpose><description><para>


</para></description><returns><para>A lazy object that, when evaluated, const-casts its argument to the desired type. </para></returns></function>
<function name="val"><type><classname>value</classname>&lt; T &gt; const</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter><purpose>Helper for constructing <computeroutput>value&lt;&gt;</computeroutput> objects. </purpose><description><para>
</para></description><returns><para><computeroutput>value&lt;T&gt;(t)</computeroutput> </para></returns></function>
<function name="ref"><type><classname>reference</classname>&lt; T &gt; const</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter><purpose>Helper for constructing <computeroutput>reference&lt;&gt;</computeroutput> objects. </purpose><description><para>
</para></description><returns><para><computeroutput>reference&lt;T&gt;(t)</computeroutput> </para></returns></function>
<function name="cref"><type><classname>reference</classname>&lt; T const  &gt; const</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter><purpose>Helper for constructing <computeroutput>reference&lt;&gt;</computeroutput> objects that store a reference to const. </purpose><description><para>
</para></description><returns><para><computeroutput>reference&lt;T const&gt;(t)</computeroutput> </para></returns></function>
<function name="check"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype><description><para>The UnaryPredicate object or Boolean semantic action.</para></description></parameter><purpose>For adding user-defined assertions to your regular expressions. </purpose><description><para>
A <link linkend="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.user_defined_assertions">user-defined assertion</link> is a kind of semantic action that evaluates a Boolean lambda and, if it evaluates to false, causes the match to fail at that location in the string. This will cause backtracking, so the match may ultimately succeed.</para><para>To use <computeroutput>check()</computeroutput> to specify a user-defined assertion in a regex, use the following syntax:<programlisting language="c++">sregex s = (_d &gt;&gt; _d)[check( XXX )]; // XXX is a custom assertion
</programlisting> The assertion is evaluated with a <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname>&lt;&gt;</computeroutput> object that delineates what part of the string matched the sub-expression to which the assertion was attached.</para><para><computeroutput>check()</computeroutput> can be used with an ordinary predicate that takes a <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname>&lt;&gt;</computeroutput> object as follows:<programlisting language="c++">// A predicate that is true IFF a sub-match is
// either 3 or 6 characters long.
struct three_or_six
{
    bool operator()(ssub_match const &amp;sub) const
    {
        return sub.length() == 3 || sub.length() == 6;
    }
};

// match words of 3 characters or 6 characters.
sregex rx = (bow &gt;&gt; +_w &gt;&gt; eow)[ check(three_or_six()) ] ;
</programlisting> Alternately, <computeroutput>check()</computeroutput> can be used to define inline custom assertions with the same syntax as is used to define semantic actions. The following code is equivalent to above:<programlisting language="c++">// match words of 3 characters or 6 characters.
sregex rx = (bow &gt;&gt; +_w &gt;&gt; eow)[ check(length(_)==3 || length(_)==6) ] ;
</programlisting> Within a custom assertion, <computeroutput>_</computeroutput> is a placeholder for the <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname>&lt;&gt;</computeroutput> That delineates the part of the string matched by the sub-expression to which the custom assertion was attached. </para></description></function>
<function name="let"><type><emphasis>unspecified</emphasis></type><template>
          <template-nontype-parameter name="ArgBindings"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>ArgBindings const &amp;...</paramtype><description><para>A set of argument bindings, where each argument binding is an assignment expression, the left hand side of which must be an instance of <computeroutput>placeholder&lt;X&gt;</computeroutput> for some <computeroutput>X</computeroutput>, and the right hand side is an lvalue of type <computeroutput>X</computeroutput>.</para></description></parameter><purpose>For binding local variables to placeholders in semantic actions when constructing a <computeroutput><classname alt="boost::xpressive::regex_iterator">regex_iterator</classname></computeroutput> or a <computeroutput><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator</classname></computeroutput>. </purpose><description><para>
<computeroutput>xpressive::let()</computeroutput> serves the same purpose as <computeroutput>match_results::let()</computeroutput>; that is, it binds a placeholder to a local value. The purpose is to allow a regex with semantic actions to be defined that refers to objects that do not yet exist. Rather than referring directly to an object, a semantic action can refer to a placeholder, and the value of the placeholder can be specified later with a <emphasis>let expression</emphasis>. The <emphasis>let expression</emphasis> created with <computeroutput>let()</computeroutput> is passed to the constructor of either <computeroutput><classname alt="boost::xpressive::regex_iterator">regex_iterator</classname></computeroutput> or <computeroutput><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator</classname></computeroutput>.</para><para>See the section <link linkend="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.referring_to_non_local_variables"> "Referring to Non-Local Variables"</link> in the Users' Guide for more discussion.</para><para><emphasis>Example:</emphasis> <programlisting language="c++">// Define a placeholder for a map object:
placeholder&lt;std::map&lt;std::string, int&gt; &gt; _map;

// Match a word and an integer, separated by =&gt;,
// and then stuff the result into a std::map&lt;&gt;
sregex pair = ( (s1= +_w) &gt;&gt; "=&gt;" &gt;&gt; (s2= +_d) )
    [ _map[s1] = as&lt;int&gt;(s2) ];

// The string to parse
std::string str("aaa=&gt;1 bbb=&gt;23 ccc=&gt;456");

// Here is the actual map to fill in:
std::map&lt;std::string, int&gt; result;

// Create a regex_iterator to find all the matches
sregex_iterator it(str.begin(), str.end(), pair, let(_map=result));
sregex_iterator end;

// step through all the matches, and fill in
// the result map
while(it != end)
    ++it;

std::cout &lt;&lt; result["aaa"] &lt;&lt; '\n';
std::cout &lt;&lt; result["bbb"] &lt;&lt; '\n';
std::cout &lt;&lt; result["ccc"] &lt;&lt; '\n';
</programlisting> The above code displays:<programlisting language="c++">1
23
456
</programlisting> </para></description></function>
<function name="construct"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"><purpose><para>The type of object to construct. </para></purpose></template-type-parameter>
          <template-nontype-parameter name="Args"><type>typename...</type></template-nontype-parameter>
        </template><parameter name="args"><paramtype>Args const &amp;...</paramtype><description><para>The arguments to the constructor. </para></description></parameter><purpose>A lazy funtion for constructing objects objects of the specified type. </purpose><description><para>


</para></description><returns><para>A lazy object that, when evaluated, returns <computeroutput>T(xs...)</computeroutput>, where <computeroutput>xs...</computeroutput> is the result of evaluating the lazy arguments <computeroutput>args...</computeroutput>. </para></returns></function>

</namespace>
</namespace>
</header>
<header name="boost/xpressive/regex_algorithms.hpp">
<para>Contains the regex_match(), regex_search() and regex_replace() algorithms. </para><namespace name="boost">
<namespace name="xpressive">






















































<overloaded-function name="regex_match"><signature><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the sequence. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the sequence. </para></description></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The <computeroutput><classname alt="boost::xpressive::match_results">match_results</classname></computeroutput> struct into which the sub_matches will be written </para></description></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regular expression object to use </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See <computeroutput>match_flag_type</computeroutput>.) </para></description></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="begin"><paramtype>Char *</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; Char * &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange &amp;</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange const &amp;</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="begin"><paramtype>Char *</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange const &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><purpose>See if a regex matches a sequence from beginning to end. </purpose><description><para>Determines whether there is an exact match between the regular expression <computeroutput>re</computeroutput>, and all of the sequence <computeroutput>[begin, end)</computeroutput>.</para><para>



</para></description><requires><para>Type <computeroutput>BidiIter</computeroutput> meets the requirements of a Bidirectional Iterator (24.1.4). </para><para><computeroutput>[begin,end)</computeroutput> denotes a valid iterator range. </para></requires><returns><para><computeroutput>true</computeroutput> if a match is found, <computeroutput>false</computeroutput> otherwise </para></returns><throws><simpara><classname>regex_error</classname> on stack exhaustion </simpara></throws></overloaded-function>







<overloaded-function name="regex_search"><signature><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the sequence </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the sequence </para></description></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The <computeroutput><classname alt="boost::xpressive::match_results">match_results</classname></computeroutput> struct into which the sub_matches will be written </para></description></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regular expression object to use </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See <computeroutput>match_flag_type</computeroutput>.) </para></description></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="begin"><paramtype>Char *</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; Char * &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange &amp;</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange const &amp;</paramtype></parameter><parameter name="what"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="begin"><paramtype>Char *</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>bool</type><template>
          <template-type-parameter name="BidiRange"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rng"><paramtype>BidiRange const &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><purpose>Determines whether there is some sub-sequence within <computeroutput>[begin,end)</computeroutput> that matches the regular expression <computeroutput>re</computeroutput>. </purpose><description><para>Determines whether there is some sub-sequence within <computeroutput>[begin,end)</computeroutput> that matches the regular expression <computeroutput>re</computeroutput>.</para><para>



</para></description><requires><para>Type <computeroutput>BidiIter</computeroutput> meets the requirements of a Bidirectional Iterator (24.1.4). </para><para><computeroutput>[begin,end)</computeroutput> denotes a valid iterator range. </para></requires><returns><para><computeroutput>true</computeroutput> if a match is found, <computeroutput>false</computeroutput> otherwise </para></returns><throws><simpara><classname>regex_error</classname> on stack exhaustion </simpara></throws></overloaded-function>







<overloaded-function name="regex_replace"><signature><type>OutIter</type><template>
          <template-type-parameter name="OutIter"/>
          <template-type-parameter name="BidiIter"/>
          <template-type-parameter name="Formatter"/>
        </template><parameter name="out"><paramtype>OutIter</paramtype><description><para>An output iterator into which the output sequence is written. </para></description></parameter><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the input sequence. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the input sequence. </para></description></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regular expression object to use. </para></description></parameter><parameter name="format"><paramtype>Formatter const &amp;</paramtype><description><para>The format string used to format the replacement sequence, or a formatter function, function object, or expression. </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See <computeroutput>match_flag_type</computeroutput>.) </para></description></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>OutIter</type><template>
          <template-type-parameter name="OutIter"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="out"><paramtype>OutIter</paramtype></parameter><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><signature><type>BidiContainer</type><template>
          <template-type-parameter name="BidiContainer"/>
          <template-type-parameter name="BidiIter"/>
          <template-type-parameter name="Formatter"/>
        </template><parameter name="str"><paramtype>BidiContainer &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>Formatter const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>BidiContainer</type><template>
          <template-type-parameter name="BidiContainer"/>
          <template-type-parameter name="BidiIter"/>
          <template-type-parameter name="Formatter"/>
        </template><parameter name="str"><paramtype>BidiContainer const &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>Formatter const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>std::basic_string&lt; typename remove_const&lt; Char &gt;::type &gt;</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name="Formatter"/>
        </template><parameter name="str"><paramtype>Char *</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>Formatter const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>BidiContainer</type><template>
          <template-type-parameter name="BidiContainer"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="str"><paramtype>BidiContainer &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>BidiContainer</type><template>
          <template-type-parameter name="BidiContainer"/>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="str"><paramtype>BidiContainer const &amp;</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter></signature><signature><type>std::basic_string&lt; typename remove_const&lt; Char &gt;::type &gt;</type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="str"><paramtype>Char *</paramtype></parameter><parameter name="re"><paramtype><classname>basic_regex</classname>&lt; Char * &gt; const &amp;</paramtype></parameter><parameter name="format"><paramtype>typename add_const&lt; Char &gt;::type *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></signature><purpose>Build an output sequence given an input sequence, a regex, and a format string or a formatter object, function, or expression. </purpose><description><para>Constructs a <computeroutput><classname alt="boost::xpressive::regex_iterator">regex_iterator</classname></computeroutput> object: <computeroutput><classname alt="boost::xpressive::regex_iterator">regex_iterator</classname>&lt; BidiIter &gt; i(begin, end, re, flags)</computeroutput>, and uses <computeroutput>i</computeroutput> to enumerate through all of the matches m of type <computeroutput><classname alt="boost::xpressive::match_results">match_results</classname>&lt; BidiIter &gt;</computeroutput> that occur within the sequence <computeroutput>[begin, end)</computeroutput>. If no such matches are found and <computeroutput>!(flags &amp; format_no_copy)</computeroutput> then calls <computeroutput>std::copy(begin, end, out)</computeroutput>. Otherwise, for each match found, if <computeroutput>!(flags &amp; format_no_copy)</computeroutput> calls <computeroutput>std::copy(m.prefix().first, m.prefix().second, out)</computeroutput>, and then calls <computeroutput>m.format(out, format, flags)</computeroutput>. Finally if <computeroutput>!(flags &amp; format_no_copy)</computeroutput> calls <computeroutput>std::copy(last_m.suffix().first, last_m.suffix().second, out)</computeroutput> where <computeroutput>last_m</computeroutput> is a copy of the last match found.</para><para>If <computeroutput>flags &amp; format_first_only</computeroutput> is non-zero then only the first match found is replaced.</para><para>



</para></description><requires><para>Type <computeroutput>BidiIter</computeroutput> meets the requirements of a Bidirectional Iterator (24.1.4). </para><para>Type <computeroutput>OutIter</computeroutput> meets the requirements of an Output Iterator (24.1.2). </para><para>Type <computeroutput>Formatter</computeroutput> models <computeroutput>ForwardRange</computeroutput>, <computeroutput>Callable&lt;<classname alt="boost::xpressive::match_results">match_results</classname>&lt;BidiIter&gt; &gt;</computeroutput>, <computeroutput>Callable&lt;<classname alt="boost::xpressive::match_results">match_results</classname>&lt;BidiIter&gt;, OutIter&gt;</computeroutput>, or <computeroutput>Callable&lt;<classname alt="boost::xpressive::match_results">match_results</classname>&lt;BidiIter&gt;, OutIter, regex_constants::match_flag_type&gt;</computeroutput>; or else it is a null-terminated format string, or an expression template representing a formatter lambda expression. </para><para><computeroutput>[begin,end)</computeroutput> denotes a valid iterator range. </para></requires><returns><para>The value of the output iterator after the output sequence has been written to it. </para></returns><throws><simpara><classname>regex_error</classname> on stack exhaustion or invalid format string. </simpara></throws></overloaded-function>


















</namespace>
</namespace>
</header>
<header name="boost/xpressive/regex_compiler.hpp">
<para>Contains the definition of regex_compiler, a factory for building regex objects from strings. </para><namespace name="boost">
<namespace name="xpressive">

























































































</namespace>
</namespace>
</header>
<header name="boost/xpressive/regex_constants.hpp">
<para>Contains definitions for the syntax_option_type, match_flag_type and error_type enumerations. </para><namespace name="boost">
<namespace name="xpressive">
<namespace name="regex_constants">
<enum name="syntax_option_type"><enumvalue name="ECMAScript"><default>= 0</default><description><para>Specifies that the grammar recognized by the regular expression engine uses its normal semantics: that is the same as that given in the ECMA-262, ECMAScript Language Specification, Chapter 15 part 10, RegExp (Regular Expression) Objects (FWD.1). </para></description></enumvalue><enumvalue name="icase"><default>= 1 &lt;&lt; 1</default><description><para>Specifies that matching of regular expressions against a character container sequence shall be performed without regard to case. </para></description></enumvalue><enumvalue name="nosubs"><default>= 1 &lt;&lt; 2</default><description><para>Specifies that when a regular expression is matched against a character container sequence, then no sub-expression matches are to be stored in the supplied <classname alt="boost::xpressive::match_results">match_results</classname> structure. </para></description></enumvalue><enumvalue name="optimize"><default>= 1 &lt;&lt; 3</default><description><para>Specifies that the regular expression engine should pay more attention to the speed with which regular expressions are matched, and less to the speed with which regular expression objects are constructed. Otherwise it has no detectable effect on the program output. </para></description></enumvalue><enumvalue name="collate"><default>= 1 &lt;&lt; 4</default><description><para>Specifies that character ranges of the form "[a-b]" should be locale sensitive. </para></description></enumvalue><enumvalue name="single_line"><default>= 1 &lt;&lt; 10</default><description><para>Specifies that the ^ and $ metacharacters DO NOT match at internal line breaks. Note that this is the opposite of the perl default. It is the inverse of perl's /m (multi-line) modifier. </para></description></enumvalue><enumvalue name="not_dot_null"><default>= 1 &lt;&lt; 11</default><description><para>Specifies that the . metacharacter does not match the null character \0. </para></description></enumvalue><enumvalue name="not_dot_newline"><default>= 1 &lt;&lt; 12</default><description><para>Specifies that the . metacharacter does not match the newline character \n. </para></description></enumvalue><enumvalue name="ignore_white_space"><default>= 1 &lt;&lt; 13</default><description><para>Specifies that non-escaped white-space is not significant. </para></description></enumvalue><description><para>Flags used to customize the regex syntax </para></description></enum>
<enum name="match_flag_type"><enumvalue name="match_default"><default>= 0</default><description><para>Specifies that matching of regular expressions proceeds without any modification of the normal rules used in ECMA-262, ECMAScript Language Specification, Chapter 15 part 10, RegExp (Regular Expression) Objects (FWD.1) </para></description></enumvalue><enumvalue name="match_not_bol"><default>= 1 &lt;&lt; 1</default><description><para>Specifies that the expression "^" should not be matched against the sub-sequence [first,first). </para></description></enumvalue><enumvalue name="match_not_eol"><default>= 1 &lt;&lt; 2</default><description><para>Specifies that the expression "\$" should not be matched against the sub-sequence [last,last). </para></description></enumvalue><enumvalue name="match_not_bow"><default>= 1 &lt;&lt; 3</default><description><para>Specifies that the expression "\\b" should not be matched against the sub-sequence [first,first). </para></description></enumvalue><enumvalue name="match_not_eow"><default>= 1 &lt;&lt; 4</default><description><para>Specifies that the expression "\\b" should not be matched against the sub-sequence [last,last). </para></description></enumvalue><enumvalue name="match_any"><default>= 1 &lt;&lt; 7</default><description><para>Specifies that if more than one match is possible then any match is an acceptable result. </para></description></enumvalue><enumvalue name="match_not_null"><default>= 1 &lt;&lt; 8</default><description><para>Specifies that the expression can not be matched against an empty sequence. </para></description></enumvalue><enumvalue name="match_continuous"><default>= 1 &lt;&lt; 10</default><description><para>Specifies that the expression must match a sub-sequence that begins at first. </para></description></enumvalue><enumvalue name="match_partial"><default>= 1 &lt;&lt; 11</default><description><para>Specifies that if no match can be found, then it is acceptable to return a match [from, last) where from != last, if there exists some sequence of characters [from,to) of which [from,last) is a prefix, and which would result in a full match. </para></description></enumvalue><enumvalue name="match_prev_avail"><default>= 1 &lt;&lt; 12</default><description><para>Specifies that –first is a valid iterator position, when this flag is set then the flags match_not_bol and match_not_bow are ignored by the regular expression algorithms (RE.7) and iterators (RE.8). </para></description></enumvalue><enumvalue name="format_default"><default>= 0</default><description><para>Specifies that when a regular expression match is to be replaced by a new string, that the new string is constructed using the rules used by the ECMAScript replace function in ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace. (FWD.1). In addition during search and replace operations then all non-overlapping occurrences of the regular expression are located and replaced, and sections of the input that did not match the expression, are copied unchanged to the output string. </para></description></enumvalue><enumvalue name="format_sed"><default>= 1 &lt;&lt; 13</default><description><para>Specifies that when a regular expression match is to be replaced by a new string, that the new string is constructed using the rules used by the Unix sed utility in IEEE Std 1003.1-2001, Portable Operating SystemInterface (POSIX), Shells and Utilities. </para></description></enumvalue><enumvalue name="format_perl"><default>= 1 &lt;&lt; 14</default><description><para>Specifies that when a regular expression match is to be replaced by a new string, that the new string is constructed using an implementation defined superset of the rules used by the ECMAScript replace function in ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace (FWD.1). </para></description></enumvalue><enumvalue name="format_no_copy"><default>= 1 &lt;&lt; 15</default><description><para>When specified during a search and replace operation, then sections of the character container sequence being searched that do match the regular expression, are not copied to the output string. </para></description></enumvalue><enumvalue name="format_first_only"><default>= 1 &lt;&lt; 16</default><description><para>When specified during a search and replace operation, then only the first occurrence of the regular expression is replaced. </para></description></enumvalue><enumvalue name="format_literal"><default>= 1 &lt;&lt; 17</default><description><para>Treat the format string as a literal. </para></description></enumvalue><enumvalue name="format_all"><default>= 1 &lt;&lt; 18</default><description><para>Specifies that all syntax extensions are enabled, including conditional (?ddexpression1:expression2) replacements. </para></description></enumvalue><description><para>Flags used to customize the behavior of the regex algorithms </para></description></enum>
<enum name="error_type"><enumvalue name="error_collate"><description><para>The expression contained an invalid collating element name. </para></description></enumvalue><enumvalue name="error_ctype"><description><para>The expression contained an invalid character class name. </para></description></enumvalue><enumvalue name="error_escape"><description><para>The expression contained an invalid escaped character, or a trailing escape. </para></description></enumvalue><enumvalue name="error_subreg"><description><para>The expression contained an invalid back-reference. </para></description></enumvalue><enumvalue name="error_brack"><description><para>The expression contained mismatched [ and ]. </para></description></enumvalue><enumvalue name="error_paren"><description><para>The expression contained mismatched ( and ). </para></description></enumvalue><enumvalue name="error_brace"><description><para>The expression contained mismatched { and }. </para></description></enumvalue><enumvalue name="error_badbrace"><description><para>The expression contained an invalid range in a {} expression. </para></description></enumvalue><enumvalue name="error_range"><description><para>The expression contained an invalid character range, for example [b-a]. </para></description></enumvalue><enumvalue name="error_space"><description><para>There was insufficient memory to convert the expression into a finite state machine. </para></description></enumvalue><enumvalue name="error_badrepeat"><description><para>One of *?+{ was not preceded by a valid regular expression. </para></description></enumvalue><enumvalue name="error_complexity"><description><para>The complexity of an attempted match against a regular expression exceeded a pre-set level. </para></description></enumvalue><enumvalue name="error_stack"><description><para>There was insufficient memory to determine whether the regular expression could match the specified character sequence. </para></description></enumvalue><enumvalue name="error_badref"><description><para>An nested regex is uninitialized. </para></description></enumvalue><enumvalue name="error_badmark"><description><para>An invalid use of a named capture. </para></description></enumvalue><enumvalue name="error_badlookbehind"><description><para>An attempt to create a variable-width look-behind assertion was detected. </para></description></enumvalue><enumvalue name="error_badrule"><description><para>An invalid use of a rule was detected. </para></description></enumvalue><enumvalue name="error_badarg"><description><para>An argument to an action was unbound. </para></description></enumvalue><enumvalue name="error_badattr"><description><para>Tried to read from an uninitialized attribute. </para></description></enumvalue><enumvalue name="error_internal"><description><para>An internal error has occurred. </para></description></enumvalue><description><para>Error codes used by the <classname alt="boost::xpressive::regex_error">regex_error</classname> type </para></description></enum>
</namespace>

























































































</namespace>
</namespace>
</header>
<header name="boost/xpressive/regex_error.hpp">
<para>Contains the definition of the regex_error exception class. </para><namespace name="boost">
<namespace name="xpressive">
<struct name="regex_error"><inherit access="public">std::runtime_error</inherit><inherit access="public">exception</inherit><purpose>The class <classname alt="boost::xpressive::regex_error">regex_error</classname> defines the type of objects thrown as exceptions to report errors during the conversion from a string representing a regular expression to a finite state machine. </purpose><method-group name="public member functions">
<method name="code" cv="const"><type>regex_constants::error_type</type><description><para>Accessor for the error_type value 

</para></description><returns><para>the error_type code passed to the constructor </para></returns><throws><simpara>Will not throw.</simpara></throws></method>
</method-group>
<constructor specifiers="explicit"><parameter name="code"><paramtype>regex_constants::error_type</paramtype><description><para>The error_type this <classname alt="boost::xpressive::regex_error">regex_error</classname> represents. </para></description></parameter><parameter name="str"><paramtype>char const *</paramtype><default>""</default><description><para>The message string of this <classname alt="boost::xpressive::regex_error">regex_error</classname>. </para></description></parameter><description><para>Constructs an object of class <classname alt="boost::xpressive::regex_error">regex_error</classname>. 

</para></description><postconditions><para>code() == code </para></postconditions></constructor>
<destructor><description><para>Destructor for class <classname alt="boost::xpressive::regex_error">regex_error</classname> 
</para></description><throws><simpara>Will not throw.</simpara></throws></destructor>
</struct>
























































































</namespace>
</namespace>
<macro name="BOOST_XPR_ENSURE_" kind="functionlike"><macro-parameter name="pred"/><macro-parameter name="code"/><macro-parameter name="msg"/></macro>
</header>
<header name="boost/xpressive/regex_iterator.hpp">
<para>Contains the definition of the regex_iterator type, an STL-compatible iterator for stepping through all the matches in a sequence. </para><namespace name="boost">
<namespace name="xpressive">

























































































</namespace>
</namespace>
</header>
<header name="boost/xpressive/regex_primitives.hpp">
<para>Contains the syntax elements for writing static regular expressions. </para><namespace name="boost">
<namespace name="xpressive">
<struct name="mark_tag"><purpose>Sub-match placeholder type, used to create named captures in static regexes. </purpose><description><para><computeroutput><classname alt="boost::xpressive::mark_tag">mark_tag</classname></computeroutput> is the type of the global sub-match placeholders <computeroutput>s0</computeroutput>, <computeroutput>s1</computeroutput>, etc.. You can use the <computeroutput><classname alt="boost::xpressive::mark_tag">mark_tag</classname></computeroutput> type to create your own sub-match placeholders with more meaningful names. This is roughly equivalent to the "named capture" feature of dynamic regular expressions.</para><para>To create a named sub-match placeholder, initialize it with a unique integer. The integer must only be unique within the regex in which the placeholder is used. Then you can use it within static regexes to created sub-matches by assigning a sub-expression to it, or to refer back to already created sub-matches.</para><para><programlisting language="c++">mark_tag number(1); // "number" is now equivalent to "s1"
// Match a number, followed by a space and the same number again
sregex rx = (number = +_d) &gt;&gt; ' ' &gt;&gt; number;
</programlisting></para><para>After a successful <computeroutput>regex_match()</computeroutput> or <computeroutput>regex_search()</computeroutput>, the sub-match placeholder can be used to index into the <computeroutput><classname alt="boost::xpressive::match_results">match_results</classname>&lt;&gt;</computeroutput> object to retrieve the corresponding sub-match. </para></description><method-group name="private static functions">
<method name="make_tag" specifiers="static"><type><emphasis>unspecified</emphasis></type><parameter name="mark_nbr"><paramtype>int</paramtype></parameter></method>
</method-group>
<method-group name="public member functions">
</method-group>
<constructor><parameter name="mark_nbr"><paramtype>int</paramtype><description><para>An integer that uniquely identifies this <computeroutput><classname alt="boost::xpressive::mark_tag">mark_tag</classname></computeroutput> within the static regexes in which this <computeroutput><classname alt="boost::xpressive::mark_tag">mark_tag</classname></computeroutput> will be used. </para></description></parameter><purpose>Initialize a <classname alt="boost::xpressive::mark_tag">mark_tag</classname> placeholder. </purpose><description><para>

</para></description><requires><para><computeroutput>mark_nbr &gt; 0</computeroutput> </para></requires></constructor>
</struct><data-member name="inf"><type>unsigned int const</type><purpose>For infinite repetition of a sub-expression. </purpose><description><para>Magic value used with the repeat&lt;&gt;() function template to specify an unbounded repeat. Use as: repeat&lt;17, inf&gt;('a'). The equivalent in perl is /a{17,}/. </para></description></data-member>
<data-member name="nil"><type><emphasis>unspecified</emphasis></type><purpose>Successfully matches nothing. </purpose><description><para>Successfully matches a zero-width sequence. nil always succeeds and never consumes any characters. </para></description></data-member>
<data-member name="alnum"><type><emphasis>unspecified</emphasis></type><purpose>Matches an alpha-numeric character. </purpose><description><para>The regex traits are used to determine which characters are alpha-numeric. To match any character that is not alpha-numeric, use ~alnum.</para><para><note><para>alnum is equivalent to /[[:alnum:]]/ in perl. ~alnum is equivalent to /[[:^alnum:]]/ in perl. </para></note>
</para></description></data-member>
<data-member name="alpha"><type><emphasis>unspecified</emphasis></type><purpose>Matches an alphabetic character. </purpose><description><para>The regex traits are used to determine which characters are alphabetic. To match any character that is not alphabetic, use ~alpha.</para><para><note><para>alpha is equivalent to /[[:alpha:]]/ in perl. ~alpha is equivalent to /[[:^alpha:]]/ in perl. </para></note>
</para></description></data-member>
<data-member name="blank"><type><emphasis>unspecified</emphasis></type><purpose>Matches a blank (horizonal white-space) character. </purpose><description><para>The regex traits are used to determine which characters are blank characters. To match any character that is not blank, use ~blank.</para><para><note><para>blank is equivalent to /[[:blank:]]/ in perl. ~blank is equivalent to /[[:^blank:]]/ in perl. </para></note>
</para></description></data-member>
<data-member name="cntrl"><type><emphasis>unspecified</emphasis></type><purpose>Matches a control character. </purpose><description><para>The regex traits are used to determine which characters are control characters. To match any character that is not a control character, use ~cntrl.</para><para><note><para>cntrl is equivalent to /[[:cntrl:]]/ in perl. ~cntrl is equivalent to /[[:^cntrl:]]/ in perl. </para></note>
</para></description></data-member>
<data-member name="digit"><type><emphasis>unspecified</emphasis></type><purpose>Matches a digit character. </purpose><description><para>The regex traits are used to determine which characters are digits. To match any character that is not a digit, use ~digit.</para><para><note><para>digit is equivalent to /[[:digit:]]/ in perl. ~digit is equivalent to /[[:^digit:]]/ in perl. </para></note>
</para></description></data-member>
<data-member name="graph"><type><emphasis>unspecified</emphasis></type><purpose>Matches a graph character. </purpose><description><para>The regex traits are used to determine which characters are graphable. To match any character that is not graphable, use ~graph.</para><para><note><para>graph is equivalent to /[[:graph:]]/ in perl. ~graph is equivalent to /[[:^graph:]]/ in perl. </para></note>
</para></description></data-member>
<data-member name="lower"><type><emphasis>unspecified</emphasis></type><purpose>Matches a lower-case character. </purpose><description><para>The regex traits are used to determine which characters are lower-case. To match any character that is not a lower-case character, use ~lower.</para><para><note><para>lower is equivalent to /[[:lower:]]/ in perl. ~lower is equivalent to /[[:^lower:]]/ in perl. </para></note>
</para></description></data-member>
<data-member name="print"><type><emphasis>unspecified</emphasis></type><purpose>Matches a printable character. </purpose><description><para>The regex traits are used to determine which characters are printable. To match any character that is not printable, use ~print.</para><para><note><para>print is equivalent to /[[:print:]]/ in perl. ~print is equivalent to /[[:^print:]]/ in perl. </para></note>
</para></description></data-member>
<data-member name="punct"><type><emphasis>unspecified</emphasis></type><purpose>Matches a punctuation character. </purpose><description><para>The regex traits are used to determine which characters are punctuation. To match any character that is not punctuation, use ~punct.</para><para><note><para>punct is equivalent to /[[:punct:]]/ in perl. ~punct is equivalent to /[[:^punct:]]/ in perl. </para></note>
</para></description></data-member>
<data-member name="space"><type><emphasis>unspecified</emphasis></type><purpose>Matches a space character. </purpose><description><para>The regex traits are used to determine which characters are space characters. To match any character that is not white-space, use ~space.</para><para><note><para>space is equivalent to /[[:space:]]/ in perl. ~space is equivalent to /[[:^space:]]/ in perl. </para></note>
</para></description></data-member>
<data-member name="upper"><type><emphasis>unspecified</emphasis></type><purpose>Matches an upper-case character. </purpose><description><para>The regex traits are used to determine which characters are upper-case. To match any character that is not upper-case, use ~upper.</para><para><note><para>upper is equivalent to /[[:upper:]]/ in perl. ~upper is equivalent to /[[:^upper:]]/ in perl. </para></note>
</para></description></data-member>
<data-member name="xdigit"><type><emphasis>unspecified</emphasis></type><purpose>Matches a hexadecimal digit character. </purpose><description><para>The regex traits are used to determine which characters are hex digits. To match any character that is not a hex digit, use ~xdigit.</para><para><note><para>xdigit is equivalent to /[[:xdigit:]]/ in perl. ~xdigit is equivalent to /[[:^xdigit:]]/ in perl. </para></note>
</para></description></data-member>
<data-member name="bos"><type><emphasis>unspecified</emphasis></type><purpose>Beginning of sequence assertion. </purpose><description><para>For the character sequence [begin, end), 'bos' matches the zero-width sub-sequence [begin, begin). </para></description></data-member>
<data-member name="eos"><type><emphasis>unspecified</emphasis></type><purpose>End of sequence assertion. </purpose><description><para>For the character sequence [begin, end), 'eos' matches the zero-width sub-sequence [end, end).</para><para><note><para>Unlike the perl end of sequence assertion $, 'eos' will not match at the position [end-1, end-1) if *(end-1) is '\n'. To get that behavior, use (!_n &gt;&gt; eos). </para></note>
</para></description></data-member>
<data-member name="bol"><type><emphasis>unspecified</emphasis></type><purpose>Beginning of line assertion. </purpose><description><para>'bol' matches the zero-width sub-sequence immediately following a logical newline sequence. The regex traits is used to determine what constitutes a logical newline sequence. </para></description></data-member>
<data-member name="eol"><type><emphasis>unspecified</emphasis></type><purpose>End of line assertion. </purpose><description><para>'eol' matches the zero-width sub-sequence immediately preceeding a logical newline sequence. The regex traits is used to determine what constitutes a logical newline sequence. </para></description></data-member>
<data-member name="bow"><type><emphasis>unspecified</emphasis></type><purpose>Beginning of word assertion. </purpose><description><para>'bow' matches the zero-width sub-sequence immediately following a non-word character and preceeding a word character. The regex traits are used to determine what constitutes a word character. </para></description></data-member>
<data-member name="eow"><type><emphasis>unspecified</emphasis></type><purpose>End of word assertion. </purpose><description><para>'eow' matches the zero-width sub-sequence immediately following a word character and preceeding a non-word character. The regex traits are used to determine what constitutes a word character. </para></description></data-member>
<data-member name="_b"><type><emphasis>unspecified</emphasis></type><purpose>Word boundary assertion. </purpose><description><para>'_b' matches the zero-width sub-sequence at the beginning or the end of a word. It is equivalent to (bow | eow). The regex traits are used to determine what constitutes a word character. To match a non-word boundary, use ~_b.</para><para><note><para>_b is like \b in perl. ~_b is like \B in perl. </para></note>
</para></description></data-member>
<data-member name="_w"><type><emphasis>unspecified</emphasis></type><purpose>Matches a word character. </purpose><description><para>'_w' matches a single word character. The regex traits are used to determine which characters are word characters. Use ~_w to match a character that is not a word character.</para><para><note><para>_w is like \w in perl. ~_w is like \W in perl. </para></note>
</para></description></data-member>
<data-member name="_d"><type><emphasis>unspecified</emphasis></type><purpose>Matches a digit character. </purpose><description><para>'_d' matches a single digit character. The regex traits are used to determine which characters are digits. Use ~_d to match a character that is not a digit character.</para><para><note><para>_d is like \d in perl. ~_d is like \D in perl. </para></note>
</para></description></data-member>
<data-member name="_s"><type><emphasis>unspecified</emphasis></type><purpose>Matches a space character. </purpose><description><para>'_s' matches a single space character. The regex traits are used to determine which characters are space characters. Use ~_s to match a character that is not a space character.</para><para><note><para>_s is like \s in perl. ~_s is like \S in perl. </para></note>
</para></description></data-member>
<data-member name="_n"><type>proto::terminal&lt; char &gt;::type const</type><purpose>Matches a literal newline character, '\n'. </purpose><description><para>'_n' matches a single newline character, '\n'. Use ~_n to match a character that is not a newline.</para><para><note><para>~_n is like '.' in perl without the /s modifier. </para></note>
</para></description></data-member>
<data-member name="_ln"><type><emphasis>unspecified</emphasis></type><purpose>Matches a logical newline sequence. </purpose><description><para>'_ln' matches a logical newline sequence. This can be any character in the line separator class, as determined by the regex traits, or the '\r\n' sequence. For the purpose of back-tracking, '\r\n' is treated as a unit. To match any one character that is not a logical newline, use ~_ln. </para></description></data-member>
<data-member name="_"><type><emphasis>unspecified</emphasis></type><purpose>Matches any one character. </purpose><description><para>Match any character, similar to '.' in perl syntax with the /s modifier. '_' matches any one character, including the newline.</para><para><note><para>To match any character except the newline, use ~_n </para></note>
</para></description></data-member>
<data-member name="self"><type><emphasis>unspecified</emphasis></type><purpose>Reference to the current regex object. </purpose><description><para>Useful when constructing recursive regular expression objects. The 'self' identifier is a short-hand for the current regex object. For instance, sregex rx = '(' &gt;&gt; (self | nil) &gt;&gt; ')'; will create a regex object that matches balanced parens such as "((()))". </para></description></data-member>
<data-member name="set"><type><emphasis>unspecified</emphasis></type><purpose>Used to create character sets. </purpose><description><para>There are two ways to create character sets with the 'set' identifier. The easiest is to create a comma-separated list of the characters in the set, as in (set= 'a','b','c'). This set will match 'a', 'b', or 'c'. The other way is to define the set as an argument to the set subscript operator. For instance, set[ 'a' | range('b','c') | digit ] will match an 'a', 'b', 'c' or a digit character.</para><para>To complement a set, apply the '~' operator. For instance, ~(set= 'a','b','c') will match any character that is not an 'a', 'b', or 'c'.</para><para>Sets can be composed of other, possibly complemented, sets. For instance, set[ ~digit | ~(set= 'a','b','c') ]. </para></description></data-member>
<data-member name="s0"><type><classname>mark_tag</classname> const</type><purpose>Sub-match placeholder, like $&amp; in Perl. </purpose></data-member>
<data-member name="s1"><type><classname>mark_tag</classname> const</type><purpose>Sub-match placeholder, like $1 in perl. </purpose><description><para>To create a sub-match, assign a sub-expression to the sub-match placeholder. For instance, (s1= _) will match any one character and remember which character was matched in the 1st sub-match. Later in the pattern, you can refer back to the sub-match. For instance, (s1= _) &gt;&gt; s1 will match any character, and then match the same character again.</para><para>After a successful regex_match() or regex_search(), the sub-match placeholders can be used to index into the <classname alt="boost::xpressive::match_results">match_results</classname>&lt;&gt; object to retrieve the Nth sub-match. </para></description></data-member>
<data-member name="s2"><type><classname>mark_tag</classname> const</type></data-member>
<data-member name="s3"><type><classname>mark_tag</classname> const</type></data-member>
<data-member name="s4"><type><classname>mark_tag</classname> const</type></data-member>
<data-member name="s5"><type><classname>mark_tag</classname> const</type></data-member>
<data-member name="s6"><type><classname>mark_tag</classname> const</type></data-member>
<data-member name="s7"><type><classname>mark_tag</classname> const</type></data-member>
<data-member name="s8"><type><classname>mark_tag</classname> const</type></data-member>
<data-member name="s9"><type><classname>mark_tag</classname> const</type></data-member>
<data-member name="a1"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member name="a2"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member name="a3"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member name="a4"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member name="a5"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member name="a6"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member name="a7"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member name="a8"><type><emphasis>unspecified</emphasis></type></data-member>
<data-member name="a9"><type><emphasis>unspecified</emphasis></type></data-member>










































<function name="icase"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><purpose>Makes a sub-expression case-insensitive. </purpose><description><para>Use icase() to make a sub-expression case-insensitive. For instance, "foo" &gt;&gt; icase(set['b'] &gt;&gt; "ar") will match "foo" exactly followed by "bar" irrespective of case. </para></description></function>
<function name="as_xpr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Literal"/>
        </template><parameter name="literal"><paramtype>Literal const &amp;</paramtype></parameter><purpose>Makes a literal into a regular expression. </purpose><description><para>Use as_xpr() to turn a literal into a regular expression. For instance, "foo" &gt;&gt; "bar" will not compile because both operands to the right-shift operator are const char*, and no such operator exists. Use as_xpr("foo") &gt;&gt; "bar" instead.</para><para>You can use as_xpr() with character literals in addition to string literals. For instance, as_xpr('a') will match an 'a'. You can also complement a character literal, as with ~as_xpr('a'). This will match any one character that is not an 'a'. </para></description></function>
<function name="by_ref"><type>proto::terminal&lt; reference_wrapper&lt; <classname>basic_regex</classname>&lt; BidiIter &gt; const  &gt; &gt;::type const</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object to embed by reference. </para></description></parameter><purpose>Embed a regex object by reference. </purpose><description><para>
</para></description></function>
<function name="range"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Char"/>
        </template><parameter name="ch_min"><paramtype>Char</paramtype><description><para>The lower end of the range to match. </para></description></parameter><parameter name="ch_max"><paramtype>Char</paramtype><description><para>The upper end of the range to match. </para></description></parameter><purpose>Match a range of characters. </purpose><description><para>Match any character in the range [ch_min, ch_max].</para><para>
</para></description></function>
<function name="optional"><type>proto::result_of::make_expr&lt; proto::tag::logical_not, proto::default_domain, Expr const &amp; &gt;::type const</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to make optional. </para></description></parameter><purpose>Make a sub-expression optional. Equivalent to !as_xpr(expr). </purpose><description><para>
</para></description></function>
<overloaded-function name="repeat"><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-nontype-parameter name="Min"><type>unsigned int</type></template-nontype-parameter>
          <template-nontype-parameter name="Max"><type>unsigned int</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to repeat. </para></description></parameter></signature><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-nontype-parameter name="Count"><type>unsigned int</type></template-nontype-parameter>
          <template-type-parameter name="Expr2"/>
        </template><parameter name="expr2"><paramtype>Expr2 const &amp;</paramtype></parameter></signature><purpose>Repeat a sub-expression multiple times. </purpose><description><para>There are two forms of the repeat&lt;&gt;() function template. To match a sub-expression N times, use repeat&lt;N&gt;(expr). To match a sub-expression from M to N times, use repeat&lt;M,N&gt;(expr).</para><para>The repeat&lt;&gt;() function creates a greedy quantifier. To make the quantifier non-greedy, apply the unary minus operator, as in -repeat&lt;M,N&gt;(expr).</para><para>
</para></description></overloaded-function>

<function name="keep"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to modify. </para></description></parameter><purpose>Create an independent sub-expression. </purpose><description><para>Turn off back-tracking for a sub-expression. Any branches or repeats within the sub-expression will match only one way, and no other alternatives are tried.</para><para><note><para>keep(expr) is equivalent to the perl (?&gt;...) extension.</para></note>

</para></description></function>
<function name="before"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to put in the look-ahead assertion. </para></description></parameter><purpose>Look-ahead assertion. </purpose><description><para>before(expr) succeeds if the expr sub-expression would match at the current position in the sequence, but expr is not included in the match. For instance, before("foo") succeeds if we are before a "foo". Look-ahead assertions can be negated with the bit-compliment operator.</para><para><note><para>before(expr) is equivalent to the perl (?=...) extension. ~before(expr) is a negative look-ahead assertion, equivalent to the perl (?!...) extension.</para></note>

</para></description></function>
<function name="after"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The sub-expression to put in the look-ahead assertion.</para></description></parameter><purpose>Look-behind assertion. </purpose><description><para>after(expr) succeeds if the expr sub-expression would match at the current position minus N in the sequence, where N is the width of expr. expr is not included in the match. For instance, after("foo") succeeds if we are after a "foo". Look-behind assertions can be negated with the bit-complement operator.</para><para><note><para>after(expr) is equivalent to the perl (?&lt;=...) extension. ~after(expr) is a negative look-behind assertion, equivalent to the perl (?&lt;!...) extension.</para></note>


</para></description><requires><para>expr cannot match a variable number of characters. </para></requires></function>
<function name="imbue"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Locale"/>
        </template><parameter name="loc"><paramtype>Locale const &amp;</paramtype><description><para>The std::locale or regex traits object. </para></description></parameter><purpose>Specify a regex traits or a std::locale. </purpose><description><para>imbue() instructs the regex engine to use the specified traits or locale when matching the regex. The entire expression must use the same traits/locale. For instance, the following specifies a locale for use with a regex: std::locale loc; sregex rx = imbue(loc)(+digit);</para><para>
</para></description></function>
<function name="skip"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Skip"/>
        </template><parameter name="skip"><paramtype>Skip const &amp;</paramtype><description><para>A regex that specifies which characters to skip. </para></description></parameter><purpose>Specify which characters to skip when matching a regex. </purpose><description><para><computeroutput>skip()</computeroutput> instructs the regex engine to skip certain characters when matching a regex. It is most useful for writing regexes that ignore whitespace. For instance, the following specifies a regex that skips whitespace and punctuation:</para><para><programlisting language="c++">// A sentence is one or more words separated by whitespace
// and punctuation.
sregex word = +alpha;
sregex sentence = skip(set[_s | punct])( +word );
</programlisting></para><para>The way it works in the above example is to insert <computeroutput>keep(*set[_s | punct])</computeroutput> before each primitive within the regex. A "primitive" includes terminals like strings, character sets and nested regexes. A final <computeroutput>*set[_s | punct]</computeroutput> is added to the end of the regex. The regex <computeroutput>sentence</computeroutput> specified above is equivalent to the following:</para><para><programlisting language="c++">sregex sentence = +( keep(*set[_s | punct]) &gt;&gt; word )
                       &gt;&gt; *set[_s | punct];
</programlisting></para><para><note><para>Skipping does not affect how nested regexes are handled because they are treated atomically. String literals are also treated atomically; that is, no skipping is done within a string literal. So <computeroutput>skip(_s)("this that")</computeroutput> is not the same as <computeroutput>skip(_s)("this" &gt;&gt; as_xpr("that"))</computeroutput>. The first will only match when there is only one space between "this" and "that". The second will skip any and all whitespace between "this" and "that".</para></note>

</para></description></function>



































</namespace>
</namespace>
</header>
<header name="boost/xpressive/regex_token_iterator.hpp">
<para>Contains the definition of regex_token_iterator, and STL-compatible iterator for tokenizing a string using a regular expression. </para><namespace name="boost">
<namespace name="xpressive">

























































































</namespace>
</namespace>
</header>
<header name="boost/xpressive/regex_traits.hpp">
<para>Includes the C regex traits or the CPP regex traits header file depending on the BOOST_XPRESSIVE_USE_C_TRAITS macro. </para><namespace name="boost">
<namespace name="xpressive">
<struct name="regex_traits_version_1_tag"><description><para>Tag used to denote that a traits class conforms to the version 1 traits interface. </para></description></struct><struct name="regex_traits_version_2_tag"><inherit access="public">boost::xpressive::regex_traits_version_1_tag</inherit><description><para>Tag used to denote that a traits class conforms to the version 2 traits interface. </para></description></struct>
























































































</namespace>
</namespace>
</header>
<header name="boost/xpressive/sub_match.hpp">
<para>Contains the definition of the class template sub_match&lt;&gt; and associated helper functions </para><namespace name="boost">
<namespace name="xpressive">
<overloaded-function name="range_begin"><signature><type>BidiIter</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="sub"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>the <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname>&lt;&gt;</computeroutput> object denoting the range </para></description></parameter></signature><signature><type>BidiIter</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="sub"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></signature><purpose><computeroutput>range_begin()</computeroutput> to make <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname>&lt;&gt;</computeroutput> a valid range </purpose><description><para>


</para></description><requires><para><computeroutput>sub.first</computeroutput> is not singular </para></requires><returns><para><computeroutput>sub.first</computeroutput> </para></returns></overloaded-function>

<overloaded-function name="range_end"><signature><type>BidiIter</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="sub"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>the <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname>&lt;&gt;</computeroutput> object denoting the range </para></description></parameter></signature><signature><type>BidiIter</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="sub"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></signature><purpose><computeroutput>range_end()</computeroutput> to make <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname>&lt;&gt;</computeroutput> a valid range </purpose><description><para>


</para></description><requires><para><computeroutput>sub.second</computeroutput> is not singular </para></requires><returns><para><computeroutput>sub.second</computeroutput> </para></returns></overloaded-function>

<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; Char, Traits &gt; &amp;</type><template>
          <template-type-parameter name="BidiIter"/>
          <template-type-parameter name="Char"/>
          <template-type-parameter name="Traits"/>
        </template><parameter name="sout"><paramtype>std::basic_ostream&lt; Char, Traits &gt; &amp;</paramtype><description><para>output stream. </para></description></parameter><parameter name="sub"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para><classname alt="boost::xpressive::sub_match">sub_match</classname> object to be written to the stream. </para></description></parameter><purpose>insertion operator for sending sub-matches to ostreams </purpose><description><para>

</para></description><returns><para>sout &lt;&lt; sub.str() </para></returns></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator=="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function name="operator!="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function name="operator&lt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function name="operator&gt;"><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function name="operator&gt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function name="operator&lt;="><type>bool</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter></function>
<function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter></function>
<function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename iterator_value&lt; BidiIter &gt;::type const *</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>
<function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="rhs"><paramtype>typename <classname>sub_match</classname>&lt; BidiIter &gt;::string_type const &amp;</paramtype></parameter></function>
<function name="operator+"><type><classname>sub_match</classname>&lt; BidiIter &gt;::string_type</type><template>
          <template-type-parameter name="BidiIter"/>
        </template><parameter name="lhs"><paramtype>typename <classname>sub_match</classname>&lt; BidiIter &gt;::string_type const &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>sub_match</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></function>















































</namespace>
</namespace>
</header>
<header name="boost/xpressive/traits/c_regex_traits.hpp">
<para>Contains the definition of the c_regex_traits&lt;&gt; template, which is a wrapper for the C locale functions that can be used to customize the behavior of static and dynamic regexes. </para><namespace name="boost">
<namespace name="xpressive">
<struct-specialization name="has_fold_case"><template>
    </template><specialization><template-arg>c_regex_traits&lt; char &gt;</template-arg></specialization><inherit access="public">true_</inherit></struct-specialization>
























































































</namespace>
</namespace>
</header>
<header name="boost/xpressive/traits/cpp_regex_traits.hpp">
<para>Contains the definition of the cpp_regex_traits&lt;&gt; template, which is a wrapper for std::locale that can be used to customize the behavior of static and dynamic regexes. </para><namespace name="boost">
<namespace name="xpressive">
<struct-specialization name="has_fold_case"><template>
    </template><specialization><template-arg>cpp_regex_traits&lt; char &gt;</template-arg></specialization><inherit access="public">true_</inherit></struct-specialization>
























































































</namespace>
</namespace>
</header>
<header name="boost/xpressive/traits/null_regex_traits.hpp">
<para>Contains the definition of the null_regex_traits&lt;&gt; template, which is a stub regex traits implementation that can be used by static and dynamic regexes for searching non-character data. </para><namespace name="boost">
<namespace name="xpressive">

























































































</namespace>
</namespace>
</header>
<header name="boost/xpressive/xpressive.hpp">
<para>Includes all of xpressive including support for both static and dynamic regular expressions. </para></header>
<header name="boost/xpressive/xpressive_dynamic.hpp">
<para>Includes everything you need to write and use dynamic regular expressions. </para></header>
<header name="boost/xpressive/xpressive_fwd.hpp">
<para>Forward declarations for all of xpressive's public data types. </para><namespace name="boost">
<namespace name="xpressive">
<struct name="cpp_regex_traits"><template>
      <template-type-parameter name="Char"/>
    </template><purpose>Encapsaulates a <computeroutput>std::locale</computeroutput> for use by the <computeroutput><classname alt="boost::xpressive::basic_regex">basic_regex</classname>&lt;&gt;</computeroutput> class template. </purpose><method-group name="public member functions">
<method name="operator==" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>cpp_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two <classname alt="boost::xpressive::cpp_regex_traits">cpp_regex_traits</classname> objects for equality</para><para>
</para></description><returns><para>this-&gt;getloc() == that.getloc(). </para></returns></method>
<method name="operator!=" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>cpp_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two <classname alt="boost::xpressive::cpp_regex_traits">cpp_regex_traits</classname> objects for inequality</para><para>
</para></description><returns><para>this-&gt;getloc() != that.getloc(). </para></returns></method>
<method name="widen" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char</paramtype><description><para>The source character. </para></description></parameter><description><para>Convert a char to a Char</para><para>

</para></description><returns><para>std::use_facet&lt;std::ctype&lt;char_type&gt; &gt;(this-&gt;getloc()).widen(ch). </para></returns></method>
<method name="translate_nocase" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to lower-case using the internally-stored std::locale.</para><para>

</para></description><returns><para>std::tolower(ch, this-&gt;getloc()). </para></returns></method>
<method name="tolower" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to lower-case using the internally-stored std::locale.</para><para>

</para></description><returns><para>std::tolower(ch, this-&gt;getloc()). </para></returns></method>
<method name="toupper" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to upper-case using the internally-stored std::locale.</para><para>

</para></description><returns><para>std::toupper(ch, this-&gt;getloc()). </para></returns></method>
<method name="fold_case" cv="const"><type>string_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a <computeroutput>string_type</computeroutput> containing all the characters that compare equal disregrarding case to the one passed in. This function can only be called if <computeroutput><classname alt="boost::xpressive::has_fold_case">has_fold_case</classname>&lt;<classname alt="boost::xpressive::cpp_regex_traits">cpp_regex_traits</classname>&lt;Char&gt; &gt;::value</computeroutput> is <computeroutput>true</computeroutput>.</para><para>

</para></description><returns><para><computeroutput>string_type</computeroutput> containing all chars which are equal to <computeroutput>ch</computeroutput> when disregarding case </para></returns></method>
<method name="in_range_nocase" cv="const"><type>bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range, irregardless of case.</para><para>

<note><para>The default implementation doesn't do proper Unicode case folding, but this is the best we can do with the standard ctype facet. </para></note>
</para></description><returns><para>in_range(first, last, ch) || in_range(first, last, tolower(ch, this-&gt;getloc())) || in_range(first, last, toupper(ch, this-&gt;getloc())) </para></returns></method>
<method name="transform_primary" cv="const"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name=""><paramtype>FwdIter</paramtype></parameter><parameter name=""><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) when character case is not considered then v.transform_primary(G1, G2) &lt; v.transform_primary(H1, H2).</para><para><note><para>Not currently used </para></note>
</para></description></method>
<method name="lookup_collatename" cv="const"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name=""><paramtype>FwdIter</paramtype></parameter><parameter name=""><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range [F1, F2). Returns an empty string if the character sequence is not a valid collating element.</para><para><note><para>Not currently used </para></note>
</para></description></method>
<method name="lookup_classname" cv="const"><type>char_class_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype><description><para>A forward iterator to the start of the character sequence representing the name of the character class. </para></description></parameter><parameter name="end"><paramtype>FwdIter</paramtype><description><para>The end of the character sequence. </para></description></parameter><parameter name="icase"><paramtype>bool</paramtype><description><para>Specifies whether the returned bitmask should represent the case-insensitive version of the character class. </para></description></parameter><description><para>For the character class name represented by the specified character sequence, return the corresponding bitmask representation.</para><para>

</para></description><returns><para>A bitmask representing the character class. </para></returns></method>
<method name="isctype" cv="const"><type>bool</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The character to test. </para></description></parameter><parameter name="mask"><paramtype>char_class_type</paramtype><description><para>The character class bitmask against which to test. </para></description></parameter><description><para>Tests a character against a character class bitmask.</para><para>


</para></description><requires><para>mask is a bitmask returned by lookup_classname, or is several such masks bit-or'ed together. </para></requires><returns><para>true if the character is a member of any of the specified character classes, false otherwise. </para></returns></method>
<method name="value" cv="const"><type>int</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The digit character. </para></description></parameter><parameter name="radix"><paramtype>int</paramtype><description><para>The radix to use for the conversion. </para></description></parameter><description><para>Convert a digit character into the integer it represents.</para><para>


</para></description><requires><para>radix is one of 8, 10, or 16. </para></requires><returns><para>-1 if ch is not a digit character, the integer value of the character otherwise. The conversion is performed by imbueing a std::stringstream with this-&gt;getloc(); setting the radix to one of oct, hex or dec; inserting ch into the stream; and extracting an int. </para></returns></method>
<method name="imbue"><type>locale_type</type><parameter name="loc"><paramtype>locale_type</paramtype><description><para>A std::locale. </para></description></parameter><description><para>Imbues *this with loc</para><para>

</para></description><returns><para>the previous std::locale used by *this. </para></returns></method>
<method name="getloc" cv="const"><type>locale_type</type><description><para>Returns the current std::locale used by *this. </para></description></method>
<method name="hash"><type>unsigned char</type><template>
        </template><parameter name="ch"><paramtype>unsigned char</paramtype></parameter></method>
<method name="hash"><type>unsigned char</type><template>
        </template><parameter name="ch"><paramtype>char</paramtype></parameter></method>
<method name="hash"><type>unsigned char</type><template>
        </template><parameter name="ch"><paramtype>signed char</paramtype></parameter></method>
<method name="hash"><type>unsigned char</type><template>
        </template><parameter name="ch"><paramtype>wchar_t</paramtype></parameter></method>
</method-group>
<constructor><parameter name="loc"><paramtype>locale_type const &amp;</paramtype><default>locale_type()</default></parameter><description><para>Initialize a <classname alt="boost::xpressive::cpp_regex_traits">cpp_regex_traits</classname> object to use the specified std::locale, or the global std::locale if none is specified. </para></description></constructor>
<method-group name="public static functions">
<method name="hash" specifiers="static"><type>unsigned char</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a hash value for a Char in the range [0, UCHAR_MAX]</para><para>

</para></description><returns><para>a value between 0 and UCHAR_MAX, inclusive. </para></returns></method>
<method name="translate" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>No-op</para><para>

</para></description><returns><para>ch </para></returns></method>
<method name="in_range" specifiers="static"><type>bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range.</para><para>

</para></description><returns><para>first &lt;= ch &amp;&amp; ch &lt;= last. </para></returns></method>
</method-group>
<method-group name="private static functions">
</method-group>
</struct><struct name="c_regex_traits"><template>
      <template-type-parameter name="Char"/>
    </template><purpose>Encapsaulates the standard C locale functions for use by the <computeroutput><classname alt="boost::xpressive::basic_regex">basic_regex</classname>&lt;&gt;</computeroutput> class template. </purpose><method-group name="public member functions">
<method name="operator==" cv="const"><type>bool</type><parameter name=""><paramtype><classname>c_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two <classname alt="boost::xpressive::c_regex_traits">c_regex_traits</classname> objects for equality</para><para>
</para></description><returns><para>true. </para></returns></method>
<method name="operator!=" cv="const"><type>bool</type><parameter name=""><paramtype><classname>c_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two <classname alt="boost::xpressive::c_regex_traits">c_regex_traits</classname> objects for inequality</para><para>
</para></description><returns><para>false. </para></returns></method>
<method name="fold_case" cv="const"><type>string_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a <computeroutput>string_type</computeroutput> containing all the characters that compare equal disregrarding case to the one passed in. This function can only be called if <computeroutput><classname alt="boost::xpressive::has_fold_case">has_fold_case</classname>&lt;<classname alt="boost::xpressive::c_regex_traits">c_regex_traits</classname>&lt;Char&gt; &gt;::value</computeroutput> is <computeroutput>true</computeroutput>.</para><para>

</para></description><returns><para><computeroutput>string_type</computeroutput> containing all chars which are equal to <computeroutput>ch</computeroutput> when disregarding case </para></returns></method>
<method name="imbue"><type>locale_type</type><parameter name="loc"><paramtype>locale_type</paramtype></parameter><description><para>No-op </para></description></method>
<method name="widen"><type>char</type><template>
        </template><parameter name="ch"><paramtype>char</paramtype></parameter></method>
<method name="widen"><type>wchar_t</type><template>
        </template><parameter name="ch"><paramtype>char</paramtype></parameter></method>
<method name="hash"><type>unsigned char</type><template>
        </template><parameter name="ch"><paramtype>char</paramtype></parameter></method>
<method name="hash"><type>unsigned char</type><template>
        </template><parameter name="ch"><paramtype>wchar_t</paramtype></parameter></method>
<method name="value"><type>int</type><template>
        </template><parameter name="ch"><paramtype>char</paramtype></parameter><parameter name="radix"><paramtype>int</paramtype></parameter></method>
<method name="value"><type>int</type><template>
        </template><parameter name="ch"><paramtype>wchar_t</paramtype></parameter><parameter name="radix"><paramtype>int</paramtype></parameter></method>
</method-group>
<constructor><parameter name="loc"><paramtype>locale_type const &amp;</paramtype><default>locale_type()</default></parameter><description><para>Initialize a <classname alt="boost::xpressive::c_regex_traits">c_regex_traits</classname> object to use the global C locale. </para></description></constructor>
<method-group name="public static functions">
<method name="widen" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char</paramtype><description><para>The source character. </para></description></parameter><description><para>Convert a char to a Char</para><para>

</para></description><returns><para>ch if Char is char, std::btowc(ch) if Char is wchar_t. </para></returns></method>
<method name="hash" specifiers="static"><type>unsigned char</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a hash value for a Char in the range [0, UCHAR_MAX]</para><para>

</para></description><returns><para>a value between 0 and UCHAR_MAX, inclusive. </para></returns></method>
<method name="translate" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>No-op</para><para>

</para></description><returns><para>ch </para></returns></method>
<method name="translate_nocase" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to lower-case using the current global C locale.</para><para>

</para></description><returns><para>std::tolower(ch) if Char is char, std::towlower(ch) if Char is wchar_t. </para></returns></method>
<method name="tolower" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to lower-case using the current global C locale.</para><para>

</para></description><returns><para>std::tolower(ch) if Char is char, std::towlower(ch) if Char is wchar_t. </para></returns></method>
<method name="toupper" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Converts a character to upper-case using the current global C locale.</para><para>

</para></description><returns><para>std::toupper(ch) if Char is char, std::towupper(ch) if Char is wchar_t. </para></returns></method>
<method name="in_range" specifiers="static"><type>bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range.</para><para>

</para></description><returns><para>first &lt;= ch &amp;&amp; ch &lt;= last. </para></returns></method>
<method name="in_range_nocase" specifiers="static"><type>bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range, irregardless of case.</para><para>

<note><para>The default implementation doesn't do proper Unicode case folding, but this is the best we can do with the standard C locale functions. </para></note>
</para></description><returns><para>in_range(first, last, ch) || in_range(first, last, tolower(ch)) || in_range(first, last, toupper(ch)) </para></returns></method>
<method name="transform" specifiers="static"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) then v.transform(G1, G2) &lt; v.transform(H1, H2).</para><para><note><para>Not currently used </para></note>
</para></description></method>
<method name="transform_primary" specifiers="static"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) when character case is not considered then v.transform_primary(G1, G2) &lt; v.transform_primary(H1, H2).</para><para><note><para>Not currently used </para></note>
</para></description></method>
<method name="lookup_collatename" specifiers="static"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range [F1, F2). Returns an empty string if the character sequence is not a valid collating element.</para><para><note><para>Not currently used </para></note>
</para></description></method>
<method name="lookup_classname" specifiers="static"><type>char_class_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype><description><para>A forward iterator to the start of the character sequence representing the name of the character class. </para></description></parameter><parameter name="end"><paramtype>FwdIter</paramtype><description><para>The end of the character sequence. </para></description></parameter><parameter name="icase"><paramtype>bool</paramtype><description><para>Specifies whether the returned bitmask should represent the case-insensitive version of the character class. </para></description></parameter><description><para>For the character class name represented by the specified character sequence, return the corresponding bitmask representation.</para><para>

</para></description><returns><para>A bitmask representing the character class. </para></returns></method>
<method name="isctype" specifiers="static"><type>bool</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The character to test. </para></description></parameter><parameter name="mask"><paramtype>char_class_type</paramtype><description><para>The character class bitmask against which to test. </para></description></parameter><description><para>Tests a character against a character class bitmask.</para><para>


</para></description><requires><para>mask is a bitmask returned by lookup_classname, or is several such masks bit-or'ed together. </para></requires><returns><para>true if the character is a member of any of the specified character classes, false otherwise. </para></returns></method>
<method name="value" specifiers="static"><type>int</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The digit character. </para></description></parameter><parameter name="radix"><paramtype>int</paramtype><description><para>The radix to use for the conversion. </para></description></parameter><description><para>Convert a digit character into the integer it represents.</para><para>


</para></description><requires><para>radix is one of 8, 10, or 16. </para></requires><returns><para>-1 if ch is not a digit character, the integer value of the character otherwise. If char_type is char, std::strtol is used for the conversion. If char_type is wchar_t, std::wcstol is used. </para></returns></method>
<method name="getloc" specifiers="static"><type>locale_type</type><description><para>No-op </para></description></method>
</method-group>
</struct><struct name="null_regex_traits"><template>
      <template-type-parameter name="Elem"/>
    </template><purpose>stub <classname alt="boost::xpressive::regex_traits">regex_traits</classname> for non-char data </purpose><method-group name="public member functions">
<method name="operator==" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>null_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two <classname alt="boost::xpressive::null_regex_traits">null_regex_traits</classname> objects for equality</para><para>
</para></description><returns><para>true. </para></returns></method>
<method name="operator!=" cv="const"><type>bool</type><parameter name="that"><paramtype><classname>null_regex_traits</classname>&lt; char_type &gt; const &amp;</paramtype></parameter><description><para>Checks two <classname alt="boost::xpressive::null_regex_traits">null_regex_traits</classname> objects for inequality</para><para>
</para></description><returns><para>false. </para></returns></method>
<method name="widen" cv="const"><type>char_type</type><parameter name="ch"><paramtype>char</paramtype><description><para>The source character. </para></description></parameter><description><para>Convert a char to a Elem</para><para>

</para></description><returns><para>Elem(ch). </para></returns></method>
</method-group>
<constructor><parameter name=""><paramtype>locale_type</paramtype><default>locale_type()</default></parameter><description><para>Initialize a <classname alt="boost::xpressive::null_regex_traits">null_regex_traits</classname> object. </para></description></constructor>
<method-group name="public static functions">
<method name="hash" specifiers="static"><type>unsigned char</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Returns a hash value for a Elem in the range [0, UCHAR_MAX]</para><para>

</para></description><returns><para>a value between 0 and UCHAR_MAX, inclusive. </para></returns></method>
<method name="translate" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>No-op</para><para>

</para></description><returns><para>ch </para></returns></method>
<method name="translate_nocase" specifiers="static"><type>char_type</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>No-op</para><para>

</para></description><returns><para>ch </para></returns></method>
<method name="in_range" specifiers="static"><type>bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range.</para><para>

</para></description><returns><para>first &lt;= ch &amp;&amp; ch &lt;= last. </para></returns></method>
<method name="in_range_nocase" specifiers="static"><type>bool</type><parameter name="first"><paramtype>char_type</paramtype><description><para>The bottom of the range, inclusive. </para></description></parameter><parameter name="last"><paramtype>char_type</paramtype><description><para>The top of the range, inclusive. </para></description></parameter><parameter name="ch"><paramtype>char_type</paramtype><description><para>The source character. </para></description></parameter><description><para>Checks to see if a character is within a character range.</para><para>

<note><para>Since the <classname alt="boost::xpressive::null_regex_traits">null_regex_traits</classname> does not do case-folding, this function is equivalent to in_range(). </para></note>
</para></description><returns><para>first &lt;= ch &amp;&amp; ch &lt;= last. </para></returns></method>
<method name="transform" specifiers="static"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) then v.transform(G1, G2) &lt; v.transform(H1, H2).</para><para><note><para>Not currently used </para></note>
</para></description></method>
<method name="transform_primary" specifiers="static"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) when character case is not considered then v.transform_primary(G1, G2) &lt; v.transform_primary(H1, H2).</para><para><note><para>Not currently used </para></note>
</para></description></method>
<method name="lookup_collatename" specifiers="static"><type>string_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype></parameter><parameter name="end"><paramtype>FwdIter</paramtype></parameter><description><para>Returns a sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range [F1, F2). Returns an empty string if the character sequence is not a valid collating element.</para><para><note><para>Not currently used </para></note>
</para></description></method>
<method name="lookup_classname" specifiers="static"><type>char_class_type</type><template>
          <template-type-parameter name="FwdIter"/>
        </template><parameter name="begin"><paramtype>FwdIter</paramtype><description><para>not used </para></description></parameter><parameter name="end"><paramtype>FwdIter</paramtype><description><para>not used </para></description></parameter><parameter name="icase"><paramtype>bool</paramtype><description><para>not used </para></description></parameter><description><para>The <classname alt="boost::xpressive::null_regex_traits">null_regex_traits</classname> does not have character classifications, so lookup_classname() is unused.</para><para>

</para></description><returns><para>static_cast&lt;char_class_type&gt;(0) </para></returns></method>
<method name="isctype" specifiers="static"><type>bool</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>not used </para></description></parameter><parameter name="mask"><paramtype>char_class_type</paramtype><description><para>not used </para></description></parameter><description><para>The <classname alt="boost::xpressive::null_regex_traits">null_regex_traits</classname> does not have character classifications, so isctype() is unused.</para><para>

</para></description><returns><para>false </para></returns></method>
<method name="value" specifiers="static"><type>int</type><parameter name="ch"><paramtype>char_type</paramtype><description><para>not used </para></description></parameter><parameter name="radix"><paramtype>int</paramtype><description><para>not used </para></description></parameter><description><para>The <classname alt="boost::xpressive::null_regex_traits">null_regex_traits</classname> recognizes no elements as digits, so value() is unused.</para><para>

</para></description><returns><para>-1 </para></returns></method>
<method name="imbue" specifiers="static"><type>locale_type</type><parameter name="loc"><paramtype>locale_type</paramtype><description><para>not used </para></description></parameter><description><para>Not used</para><para>

</para></description><returns><para>loc </para></returns></method>
<method name="getloc" specifiers="static"><type>locale_type</type><description><para>Returns locale_type().</para><para>
</para></description><returns><para>locale_type() </para></returns></method>
</method-group>
</struct><struct name="has_fold_case"><template>
      <template-type-parameter name="Trait"/>
    </template><inherit access="public">is_convertible&lt; Traits::version_tag *, regex_traits_version_1_case_fold_tag * &gt;</inherit><purpose>Trait used to denote that a traits class has the fold_case member function. </purpose></struct><struct name="basic_regex"><template>
      <template-type-parameter name="BidiIter"/>
    </template><purpose>Class template <classname alt="boost::xpressive::basic_regex">basic_regex</classname>&lt;&gt; is a class for holding a compiled regular expression. </purpose><method-group name="public member functions">
<method name="mark_count" cv="const"><type>std::size_t</type><description><para>Returns the count of capturing sub-expressions in this regular expression </para></description></method>
<method name="regex_id" cv="const"><type>regex_id_type</type><description><para>Returns a token which uniquely identifies this regular expression. </para></description></method>
<method name="swap"><type>void</type><parameter name="that"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The other <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object. </para></description></parameter><description><para>Swaps the contents of this <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object with another.</para><para>
<note><para>This is a shallow swap that does not do reference tracking. If you embed a <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object by reference in another regular expression and then swap its contents with another <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object, the change will not be visible to the enclosing regular expression. It is done this way to ensure that swap() cannot throw. </para></note>

</para></description><throws><simpara>Will not throw.</simpara></throws></method>
</method-group>
<constructor><description><para>
</para></description><postconditions><para>regex_id() == 0 </para><para>mark_count() == 0 </para></postconditions></constructor>
<constructor><parameter name="that"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object to copy. </para></description></parameter><description><para>

</para></description><postconditions><para>regex_id() == that.regex_id() </para><para>mark_count() == that.mark_count() </para></postconditions></constructor>
<copy-assignment><type><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</type><parameter name="that"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object to copy. </para></description></parameter><description><para>


</para></description><postconditions><para>regex_id() == that.regex_id() </para><para>mark_count() == that.mark_count() </para></postconditions><returns><para>*this </para></returns></copy-assignment>
<constructor><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The static regular expression </para></description></parameter><description><para>Construct from a static regular expression.</para><para>


</para></description><requires><para>Expr is the type of a static regular expression. </para></requires><postconditions><para>regex_id() != 0 </para><para>mark_count() &gt;= 0 </para></postconditions></constructor>
<copy-assignment><type><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The static regular expression. </para></description></parameter><description><para>Construct from a static regular expression.</para><para>




</para></description><requires><para>Expr is the type of a static regular expression. </para></requires><postconditions><para>regex_id() != 0 </para><para>mark_count() &gt;= 0 </para></postconditions><returns><para>*this </para></returns><throws><simpara><classname>std::bad_alloc</classname> on out of memory </simpara></throws></copy-assignment>
<method-group name="public static functions">
<method name="compile" specifiers="static"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="begin"><paramtype>InputIter</paramtype><description><para>The beginning of a range of characters representing the regular expression to compile. </para></description></parameter><parameter name="end"><paramtype>InputIter</paramtype><description><para>The end of a range of characters representing the regular expression to compile. </para></description></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default><description><para>Optional bitmask that determines how the pat string is interpreted. (See syntax_option_type.) </para></description></parameter><description><para>Factory method for building a regex object from a range of characters. Equivalent to <classname alt="boost::xpressive::regex_compiler">regex_compiler</classname>&lt; BidiIter &gt;().compile(begin, end, flags);</para><para>



</para></description><requires><para>[begin,end) is a valid range. </para><para>The range of characters specified by [begin,end) contains a valid string-based representation of a regular expression. </para></requires><returns><para>A <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object corresponding to the regular expression represented by the character range. </para></returns><throws><simpara><classname>regex_error</classname> when the range of characters has invalid regular expression syntax. </simpara></throws></method>
<method name="compile" specifiers="static"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><template>
          <template-type-parameter name="InputRange"/>
        </template><parameter name="pat"><paramtype>InputRange const &amp;</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="compile" specifiers="static"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><parameter name="begin"><paramtype>char_type const *</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="compile" specifiers="static"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><parameter name="begin"><paramtype>char_type const *</paramtype></parameter><parameter name="len"><paramtype>std::size_t</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
</method-group>
<method-group name="private member functions">
</method-group>
</struct><struct name="match_results"><template>
      <template-type-parameter name="BidiIter"/>
    </template><purpose>Class template <classname alt="boost::xpressive::match_results">match_results</classname>&lt;&gt; holds the results of a regex_match() or a regex_search() as a collection of <classname alt="boost::xpressive::sub_match">sub_match</classname> objects. </purpose><description><para>Class template <classname alt="boost::xpressive::match_results">match_results</classname>&lt;&gt; denotes a collection of sequences representing the result of a regular expression match. Storage for the collection is allocated and freed as necessary by the member functions of class <classname alt="boost::xpressive::match_results">match_results</classname>&lt;&gt;.</para><para>The class template <classname alt="boost::xpressive::match_results">match_results</classname>&lt;&gt; conforms to the requirements of a Sequence, as specified in (lib.sequence.reqmts), except that only operations defined for const-qualified Sequences are supported. </para></description><method-group name="public member functions">
<method name="size" cv="const"><type>size_type</type><description><para>Returns one plus the number of marked sub-expressions in the regular expression that was matched if *this represents the result of a successful match. Otherwise returns 0. </para></description></method>
<method name="empty" cv="const"><type>bool</type><description><para>Returns size() == 0. </para></description></method>
<method name="length" cv="const"><type>difference_type</type><parameter name="sub"><paramtype>size_type</paramtype><default>0</default></parameter><description><para>Returns (*this)[sub].length(). </para></description></method>
<method name="position" cv="const"><type>difference_type</type><parameter name="sub"><paramtype>size_type</paramtype><default>0</default></parameter><description><para>If !(*this)[sub].matched then returns -1. Otherwise returns std::distance(base, (*this)[sub].first), where base is the start iterator of the sequence that was searched. [Note - unless this is part of a repeated search with a <classname alt="boost::xpressive::regex_iterator">regex_iterator</classname> then base is the same as prefix().first - end note] </para></description></method>
<method name="str" cv="const"><type>string_type</type><parameter name="sub"><paramtype>size_type</paramtype><default>0</default></parameter><description><para>Returns (*this)[sub].str(). </para></description></method>
<method name="operator[]" cv="const"><type>const_reference</type><template>
          <template-type-parameter name="Sub"/>
        </template><parameter name="sub"><paramtype>Sub const &amp;</paramtype></parameter><description><para>Returns a reference to the <classname alt="boost::xpressive::sub_match">sub_match</classname> object representing the sequence that matched marked sub-expression sub. If sub == 0 then returns a reference to a <classname alt="boost::xpressive::sub_match">sub_match</classname> object representing the sequence that matched the whole regular expression. If sub &gt;= size() then returns a <classname alt="boost::xpressive::sub_match">sub_match</classname> object representing an unmatched sub-expression. </para></description></method>
<method name="prefix" cv="const"><type>const_reference</type><description><para>Returns a reference to the <classname alt="boost::xpressive::sub_match">sub_match</classname> object representing the character sequence from the start of the string being matched/searched, to the start of the match found.</para><para>
</para></description><requires><para>(*this)[0].matched is true </para></requires></method>
<method name="suffix" cv="const"><type>const_reference</type><description><para>Returns a reference to the <classname alt="boost::xpressive::sub_match">sub_match</classname> object representing the character sequence from the end of the match found to the end of the string being matched/searched.</para><para>
</para></description><requires><para>(*this)[0].matched is true </para></requires></method>
<method name="begin" cv="const"><type>const_iterator</type><description><para>Returns a starting iterator that enumerates over all the marked sub-expression matches stored in *this. </para></description></method>
<method name="end" cv="const"><type>const_iterator</type><description><para>Returns a terminating iterator that enumerates over all the marked sub-expression matches stored in *this. </para></description></method>
<method name="conversion-operator" cv="const"><type>bool_type</type><description><para>Returns a true value if (*this)[0].matched, else returns a false value. </para></description></method>
<method name="operator!" cv="const"><type>bool</type><description><para>Returns true if empty() || !(*this)[0].matched, else returns false. </para></description></method>
<method name="regex_id" cv="const"><type>regex_id_type</type><description><para>Returns the id of the <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object most recently used with this <classname alt="boost::xpressive::match_results">match_results</classname> object. </para></description></method>
<method name="nested_results" cv="const"><type>nested_results_type const &amp;</type><description><para>Returns a Sequence of nested <classname alt="boost::xpressive::match_results">match_results</classname> elements. </para></description></method>
<method name="format" cv="const"><type>OutputIterator</type><template>
          <template-type-parameter name="Format"/>
          <template-type-parameter name="OutputIterator"/>
        </template><parameter name="out"><paramtype>OutputIterator</paramtype></parameter><parameter name="fmt"><paramtype>Format const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::format_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>If <computeroutput>Format</computeroutput> models <computeroutput>ForwardRange</computeroutput> or is a null-terminated string, this function copies the character sequence in <computeroutput>fmt</computeroutput> to <computeroutput>OutputIterator</computeroutput> <computeroutput>out</computeroutput>. For each format specifier or escape sequence in <computeroutput>fmt</computeroutput>, replace that sequence with either the character(s) it represents, or the sequence within <computeroutput>*this</computeroutput> to which it refers. The bitmasks specified in flags determines what format specifiers or escape sequences are recognized. By default, this is the format used by ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;<classname alt="boost::xpressive::match_results">match_results</classname>&lt;BidiIter&gt;, OutputIterator, regex_constants::match_flag_type&gt;</computeroutput>, this function returns <computeroutput>fmt(*this, out, flags)</computeroutput>.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;<classname alt="boost::xpressive::match_results">match_results</classname>&lt;BidiIter&gt;, OutputIterator&gt;</computeroutput>, this function returns <computeroutput>fmt(*this, out)</computeroutput>.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;<classname alt="boost::xpressive::match_results">match_results</classname>&lt;BidiIter&gt; &gt;</computeroutput>, this function returns <computeroutput>std::copy(x.begin(), x.end(), out)</computeroutput>, where <computeroutput>x</computeroutput> is the result of calling <computeroutput>fmt(*this)</computeroutput>. </para></description></method>
<method name="format" cv="const"><type>OutputIterator</type><template>
          <template-type-parameter name="OutputIterator"/>
        </template><parameter name="out"><paramtype>OutputIterator</paramtype></parameter><parameter name="fmt"><paramtype>char_type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::format_default</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="format" cv="const"><type>string_type</type><template>
          <template-type-parameter name="Format"/>
          <template-type-parameter name="OutputIterator"/>
        </template><parameter name="fmt"><paramtype>Format const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::format_default</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>If <computeroutput>Format</computeroutput> models <computeroutput>ForwardRange</computeroutput> or is a null-terminated string, this function returns a copy of the character sequence <computeroutput>fmt</computeroutput>. For each format specifier or escape sequence in <computeroutput>fmt</computeroutput>, replace that sequence with either the character(s) it represents, or the sequence within <computeroutput>*this</computeroutput> to which it refers. The bitmasks specified in <computeroutput>flags</computeroutput> determines what format specifiers or escape sequences are recognized. By default this is the format used by ECMA-262, ECMAScript Language Specification, Chapter 15 part 5.4.11 String.prototype.replace.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;<classname alt="boost::xpressive::match_results">match_results</classname>&lt;BidiIter&gt;, OutputIterator, regex_constants::match_flag_type&gt;</computeroutput>, this function returns a <computeroutput>string_type</computeroutput> object <computeroutput>x</computeroutput> populated by calling <computeroutput>fmt(*this, out, flags)</computeroutput>, where <computeroutput>out</computeroutput> is a <computeroutput>back_insert_iterator</computeroutput> into <computeroutput>x</computeroutput>.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;<classname alt="boost::xpressive::match_results">match_results</classname>&lt;BidiIter&gt;, OutputIterator&gt;</computeroutput>, this function returns a <computeroutput>string_type</computeroutput> object <computeroutput>x</computeroutput> populated by calling <computeroutput>fmt(*this, out)</computeroutput>, where <computeroutput>out</computeroutput> is a <computeroutput>back_insert_iterator</computeroutput> into <computeroutput>x</computeroutput>.</para><para>Otherwise, if <computeroutput>Format</computeroutput> models <computeroutput>Callable&lt;<classname alt="boost::xpressive::match_results">match_results</classname>&lt;BidiIter&gt; &gt;</computeroutput>, this function returns <computeroutput>fmt(*this)</computeroutput>. </para></description></method>
<method name="format" cv="const"><type>string_type</type><parameter name="fmt"><paramtype>char_type const *</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::format_default</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="swap"><type>void</type><parameter name="that"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; &amp;</paramtype><description><para>The <classname alt="boost::xpressive::match_results">match_results</classname> object to swap with. </para></description></parameter><description><para>Swaps the contents of two <classname alt="boost::xpressive::match_results">match_results</classname> objects. Guaranteed not to throw. 


</para></description><postconditions><para>*this contains the sequence of matched sub-expressions that were in that, that contains the sequence of matched sub-expressions that were in *this. </para></postconditions><throws><simpara>Will not throw.</simpara></throws></method>
<method name="let"><type><classname>match_results</classname>&lt; BidiIter &gt; &amp;</type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter><description><para>TODO document me </para></description></method>
</method-group>
<constructor><description><para>
</para></description><postconditions><para>regex_id() == 0 </para><para>size() == 0 </para><para>empty() == true </para><para>str() == string_type() </para></postconditions></constructor>
<constructor><parameter name="that"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The <classname alt="boost::xpressive::match_results">match_results</classname> object to copy </para></description></parameter><description><para>

</para></description><postconditions><para>regex_id() == that.regex_id(). </para><para>size() == that.size(). </para><para>empty() == that.empty(). </para><para>str(n) == that.str(n) for all positive integers n &lt; that.size(). </para><para>prefix() == that.prefix(). </para><para>suffix() == that.suffix(). </para><para>(*this)[n] == that[n] for all positive integers n &lt; that.size(). </para><para>length(n) == that.length(n) for all positive integers n &lt; that.size(). </para><para>position(n) == that.position(n) for all positive integers n &lt; that.size(). </para></postconditions></constructor>
<destructor/>
<copy-assignment><type><classname>match_results</classname>&lt; BidiIter &gt; &amp;</type><parameter name="that"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The <classname alt="boost::xpressive::match_results">match_results</classname> object to copy. </para></description></parameter><description><para>

</para></description><postconditions><para>regex_id() == that.regex_id(). </para><para>size() == that.size(). </para><para>empty() == that.empty(). </para><para>str(n) == that.str(n) for all positive integers n &lt; that.size(). </para><para>prefix() == that.prefix(). </para><para>suffix() == that.suffix(). </para><para>(*this)[n] == that[n] for all positive integers n &lt; that.size(). </para><para>length(n) == that.length(n) for all positive integers n &lt; that.size(). </para><para>position(n) == that.position(n) for all positive integers n &lt; that.size(). </para></postconditions></copy-assignment>
</struct><struct name="regex_iterator"><template>
      <template-type-parameter name="BidiIter"/>
    </template><method-group name="public member functions">
<method name="operator*" cv="const"><type>value_type const &amp;</type></method>
<method name="operator-&gt;" cv="const"><type>value_type const *</type></method>
<method name="operator++"><type><classname>regex_iterator</classname>&lt; BidiIter &gt; &amp;</type><description><para>If what.prefix().first != what[0].second and if the element match_prev_avail is not set in flags then sets it. Then behaves as if by calling regex_search(what[0].second, end, what, *pre, flags), with the following variation: in the event that the previous match found was of zero length (what[0].length() == 0) then attempts to find a non-zero length match starting at what[0].second, only if that fails and provided what[0].second != suffix().second does it look for a (possibly zero length) match starting from what[0].second + 1. If no further match is found then sets *this equal to the end of sequence iterator. 
</para></description><postconditions><para>(*this)-&gt;size() == pre-&gt;mark_count() + 1 </para><para>(*this)-&gt;empty() == false </para><para>(*this)-&gt;prefix().first == An iterator denoting the end point of the previous match found </para><para>(*this)-&gt;prefix().last == (**this)[0].first </para><para>(*this)-&gt;prefix().matched == (*this)-&gt;prefix().first != (*this)-&gt;prefix().second </para><para>(*this)-&gt;suffix().first == (**this)[0].second </para><para>(*this)-&gt;suffix().last == end </para><para>(*this)-&gt;suffix().matched == (*this)-&gt;suffix().first != (*this)-&gt;suffix().second </para><para>(**this)[0].first == The starting iterator for this match. </para><para>(**this)[0].second == The ending iterator for this match. </para><para>(**this)[0].matched == true if a full match was found, and false if it was a partial match (found as a result of the match_partial flag being set). </para><para>(**this)[n].first == For all integers n &lt; (*this)-&gt;size(), the start of the sequence that matched sub-expression n. Alternatively, if sub-expression n did not participate in the match, then end. </para><para>(**this)[n].second == For all integers n &lt; (*this)-&gt;size(), the end of the sequence that matched sub-expression n. Alternatively, if sub-expression n did not participate in the match, then end. </para><para>(**this)[n].matched == For all integers n &lt; (*this)-&gt;size(), true if sub-expression n participated in the match, false otherwise. </para><para>(*this)-&gt;position() == The distance from the start of the original sequence being iterated, to the start of this match. </para></postconditions></method>
<method name="operator++"><type><classname>regex_iterator</classname>&lt; BidiIter &gt;</type><parameter name=""><paramtype>int</paramtype></parameter></method>
</method-group>
<constructor/>
<constructor><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></constructor>
<constructor><template>
          <template-type-parameter name="LetExpr"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype></parameter><parameter name="end"><paramtype>BidiIter</paramtype></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><parameter name="args"><paramtype><emphasis>unspecified</emphasis></paramtype></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default></parameter></constructor>
<constructor><parameter name="that"><paramtype><classname>regex_iterator</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></constructor>
<copy-assignment><type><classname>regex_iterator</classname>&lt; BidiIter &gt; &amp;</type><parameter name="that"><paramtype><classname>regex_iterator</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></copy-assignment>
<method-group name="private member functions">
</method-group>
</struct><struct name="regex_token_iterator"><template>
      <template-type-parameter name="BidiIter"/>
    </template><method-group name="public member functions">
<method name="operator*" cv="const"><type>value_type const &amp;</type></method>
<method name="operator-&gt;" cv="const"><type>value_type const *</type></method>
<method name="operator++"><type><classname>regex_token_iterator</classname>&lt; BidiIter &gt; &amp;</type><description><para>If N == -1 then sets *this equal to the end of sequence iterator. Otherwise if N+1 &lt; subs.size(), then increments N and sets result equal to ((subs[N] == -1) ? value_type(what.prefix().str()) : value_type(what[subs[N]].str())). Otherwise if what.prefix().first != what[0].second and if the element match_prev_avail is not set in flags then sets it. Then locates the next match as if by calling regex_search(what[0].second, end, what, *pre, flags), with the following variation: in the event that the previous match found was of zero length (what[0].length() == 0) then attempts to find a non-zero length match starting at what[0].second, only if that fails and provided what[0].second != suffix().second does it look for a (possibly zero length) match starting from what[0].second + 1. If such a match is found then sets N equal to zero, and sets result equal to ((subs[N] == -1) ? value_type(what.prefix().str()) : value_type(what[subs[N]].str())). Otherwise if no further matches were found, then let last_end be the endpoint of the last match that was found. Then if last_end != end and subs[0] == -1 sets N equal to -1 and sets result equal to value_type(last_end, end). Otherwise sets *this equal to the end of sequence iterator. </para></description></method>
<method name="operator++"><type><classname>regex_token_iterator</classname>&lt; BidiIter &gt;</type><parameter name=""><paramtype>int</paramtype></parameter></method>
</method-group>
<constructor><description><para>
</para></description><postconditions><para><computeroutput>*this</computeroutput> is the end of sequence iterator. </para></postconditions></constructor>
<constructor><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the character range to search. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the character range to search. </para></description></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regex pattern to search for. </para></description></parameter><description><para>

</para></description><requires><para><computeroutput/>[begin,end) is a valid range. </para></requires></constructor>
<constructor><template>
          <template-type-parameter name="LetExpr"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the character range to search. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the character range to search. </para></description></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regex pattern to search for. </para></description></parameter><parameter name="args"><paramtype><emphasis>unspecified</emphasis></paramtype><description><para>A let() expression with argument bindings for semantic actions. </para></description></parameter><description><para>

</para></description><requires><para><computeroutput/>[begin,end) is a valid range. </para></requires></constructor>
<constructor><template>
          <template-type-parameter name="Subs"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the character range to search. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the character range to search. </para></description></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regex pattern to search for. </para></description></parameter><parameter name="subs"><paramtype>Subs const &amp;</paramtype><description><para>A range of integers designating sub-matches to be treated as tokens. </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See match_flag_type.) </para></description></parameter><description><para>

</para></description><requires><para><computeroutput/>[begin,end) is a valid range. </para><para><computeroutput>subs</computeroutput> is either an integer greater or equal to -1, or else an array or non-empty <computeroutput>std::vector&lt;&gt;</computeroutput> of such integers. </para></requires></constructor>
<constructor><template>
          <template-type-parameter name="Subs"/>
          <template-type-parameter name="LetExpr"/>
        </template><parameter name="begin"><paramtype>BidiIter</paramtype><description><para>The beginning of the character range to search. </para></description></parameter><parameter name="end"><paramtype>BidiIter</paramtype><description><para>The end of the character range to search. </para></description></parameter><parameter name="rex"><paramtype><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</paramtype><description><para>The regex pattern to search for. </para></description></parameter><parameter name="subs"><paramtype>Subs const &amp;</paramtype><description><para>A range of integers designating sub-matches to be treated as tokens. </para></description></parameter><parameter name="args"><paramtype><emphasis>unspecified</emphasis></paramtype><description><para>A let() expression with argument bindings for semantic actions. </para></description></parameter><parameter name="flags"><paramtype>regex_constants::match_flag_type</paramtype><default>regex_constants::match_default</default><description><para>Optional match flags, used to control how the expression is matched against the sequence. (See match_flag_type.) </para></description></parameter><description><para>

</para></description><requires><para><computeroutput/>[begin,end) is a valid range. </para><para><computeroutput>subs</computeroutput> is either an integer greater or equal to -1, or else an array or non-empty <computeroutput>std::vector&lt;&gt;</computeroutput> of such integers. </para></requires></constructor>
<constructor><parameter name="that"><paramtype><classname>regex_token_iterator</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><description><para>
</para></description><postconditions><para><computeroutput>*this == that</computeroutput> </para></postconditions></constructor>
<copy-assignment><type><classname>regex_token_iterator</classname>&lt; BidiIter &gt; &amp;</type><parameter name="that"><paramtype><classname>regex_token_iterator</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter><description><para>
</para></description><postconditions><para><computeroutput>*this == that</computeroutput> </para></postconditions></copy-assignment>
<method-group name="private member functions">
</method-group>
</struct><struct name="regex_id_filter_predicate"><template>
      <template-type-parameter name="BidiIter"/>
    </template><method-group name="public member functions">
<method name="operator()" cv="const"><type>bool</type><parameter name="res"><paramtype><classname>match_results</classname>&lt; BidiIter &gt; const &amp;</paramtype></parameter></method>
</method-group>
<constructor><parameter name="regex_id"><paramtype>regex_id_type</paramtype></parameter></constructor>
</struct><struct name="sub_match"><template>
      <template-type-parameter name="BidiIter"/>
    </template><inherit access="public">std::pair&lt; BidiIter, BidiIter &gt;</inherit><purpose>Class template <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname></computeroutput> denotes the sequence of characters matched by a particular marked sub-expression. </purpose><description><para>When the marked sub-expression denoted by an object of type <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname>&lt;&gt;</computeroutput> participated in a regular expression match then member <computeroutput>matched</computeroutput> evaluates to <computeroutput>true</computeroutput>, and members <computeroutput>first</computeroutput> and <computeroutput>second</computeroutput> denote the range of characters <computeroutput>[first,second)</computeroutput> which formed that match. Otherwise <computeroutput>matched</computeroutput> is <computeroutput>false</computeroutput>, and members <computeroutput>first</computeroutput> and <computeroutput>second</computeroutput> contained undefined values.</para><para>If an object of type <computeroutput><classname alt="boost::xpressive::sub_match">sub_match</classname>&lt;&gt;</computeroutput> represents sub-expression 0 - that is to say the whole match - then member <computeroutput>matched</computeroutput> is always <computeroutput>true</computeroutput>, unless a partial match was obtained as a result of the flag <computeroutput>match_partial</computeroutput> being passed to a regular expression algorithm, in which case member <computeroutput>matched</computeroutput> is <computeroutput>false</computeroutput>, and members <computeroutput>first</computeroutput> and <computeroutput>second</computeroutput> represent the character range that formed the partial match. </para></description><method-group name="public member functions">
<method name="str" cv="const"><type>string_type</type></method>
<method name="conversion-operator" cv="const"><type>string_type</type></method>
<method name="length" cv="const"><type>difference_type</type></method>
<method name="conversion-operator" cv="const"><type>bool_type</type></method>
<method name="operator!" cv="const"><type>bool</type></method>
<method name="compare" cv="const"><type>int</type><parameter name="str"><paramtype>string_type const &amp;</paramtype><description><para>the string against which to compare </para></description></parameter><purpose>Performs a lexicographic string comparison. </purpose><description><para>

</para></description><returns><para>the results of <computeroutput>(*this).str().compare(str)</computeroutput> </para></returns></method>
<method name="compare" cv="const"><type>int</type><parameter name="sub"><paramtype><classname>sub_match</classname> const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="compare" cv="const"><type>int</type><parameter name="ptr"><paramtype>value_type const *</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
</method-group>
<constructor/>
<constructor><parameter name="first"><paramtype>BidiIter</paramtype></parameter><parameter name="second"><paramtype>BidiIter</paramtype></parameter><parameter name="matched_"><paramtype>bool</paramtype><default>false</default></parameter></constructor>
</struct><struct name="compiler_traits"><template>
      <template-type-parameter name="RegexTraits"/>
    </template></struct><struct name="regex_traits"><template>
      <template-type-parameter name="Char"/>
      <template-type-parameter name="Impl"><default>typename <classname alt="boost::xpressive::detail::default_regex_traits">detail::default_regex_traits</classname>&lt;Char&gt;::type</default></template-type-parameter>
    </template><inherit access="public">Impl</inherit><description><para>Thin wrapper around the default <classname alt="boost::xpressive::regex_traits">regex_traits</classname> implementation, either <classname alt="boost::xpressive::cpp_regex_traits">cpp_regex_traits</classname> or <classname alt="boost::xpressive::c_regex_traits">c_regex_traits</classname> </para></description><method-group name="public member functions">
</method-group>
<constructor/>
<constructor specifiers="explicit"><parameter name="loc"><paramtype>locale_type const &amp;</paramtype></parameter></constructor>
</struct><struct name="regex_compiler"><template>
      <template-type-parameter name="BidiIter"/>
      <template-type-parameter name="RegexTraits"><default><classname alt="boost::xpressive::regex_traits">regex_traits</classname>&lt;typename iterator_value&lt;BidiIter&gt;::type&gt;</default></template-type-parameter>
      <template-type-parameter name="CompilerTraits"><default><classname alt="boost::xpressive::compiler_traits">compiler_traits</classname>&lt;RegexTraits&gt;</default></template-type-parameter>
    </template><purpose>Class template <classname alt="boost::xpressive::regex_compiler">regex_compiler</classname> is a factory for building <classname alt="boost::xpressive::basic_regex">basic_regex</classname> objects from a string. </purpose><description><para>Class template <classname alt="boost::xpressive::regex_compiler">regex_compiler</classname> is used to construct a <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object from a string. The string should contain a valid regular expression. You can imbue a <classname alt="boost::xpressive::regex_compiler">regex_compiler</classname> object with a locale, after which all <classname alt="boost::xpressive::basic_regex">basic_regex</classname> objects created with that <classname alt="boost::xpressive::regex_compiler">regex_compiler</classname> object will use that locale. After creating a <classname alt="boost::xpressive::regex_compiler">regex_compiler</classname> object, and optionally imbueing it with a locale, you can call the compile() method to construct a <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object, passing it the string representing the regular expression. You can call compile() multiple times on the same <classname alt="boost::xpressive::regex_compiler">regex_compiler</classname> object. Two <classname alt="boost::xpressive::basic_regex">basic_regex</classname> objects compiled from the same string will have different regex_id's. </para></description><method-group name="public member functions">
<method name="imbue"><type>locale_type</type><parameter name="loc"><paramtype>locale_type</paramtype><description><para>The locale that this <classname alt="boost::xpressive::regex_compiler">regex_compiler</classname> should use. </para></description></parameter><description><para>Specify the locale to be used by a <classname alt="boost::xpressive::regex_compiler">regex_compiler</classname>.</para><para>

</para></description><returns><para>The previous locale. </para></returns></method>
<method name="getloc" cv="const"><type>locale_type</type><description><para>Get the locale used by a <classname alt="boost::xpressive::regex_compiler">regex_compiler</classname>.</para><para>
</para></description><returns><para>The locale used by this <classname alt="boost::xpressive::regex_compiler">regex_compiler</classname>. </para></returns></method>
<method name="compile"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><template>
          <template-type-parameter name="InputIter"/>
        </template><parameter name="begin"><paramtype>InputIter</paramtype><description><para>The beginning of a range of characters representing the regular expression to compile. </para></description></parameter><parameter name="end"><paramtype>InputIter</paramtype><description><para>The end of a range of characters representing the regular expression to compile. </para></description></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default><description><para>Optional bitmask that determines how the pat string is interpreted. (See syntax_option_type.) </para></description></parameter><description><para>Builds a <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object from a range of characters.</para><para>



</para></description><requires><para>InputIter is a model of the InputIterator concept. </para><para>[begin,end) is a valid range. </para><para>The range of characters specified by [begin,end) contains a valid string-based representation of a regular expression. </para></requires><returns><para>A <classname alt="boost::xpressive::basic_regex">basic_regex</classname> object corresponding to the regular expression represented by the character range. </para></returns><throws><simpara><classname>regex_error</classname> when the range of characters has invalid regular expression syntax. </simpara></throws></method>
<method name="compile"><type>disable_if&lt; is_pointer&lt; InputRange &gt;, <classname>basic_regex</classname>&lt; BidiIter &gt; &gt;::type</type><template>
          <template-type-parameter name="InputRange"/>
        </template><parameter name="pat"><paramtype>InputRange const &amp;</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="compile"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><parameter name="begin"><paramtype>char_type const *</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype><default>regex_constants::ECMAScript</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="compile"><type><classname>basic_regex</classname>&lt; BidiIter &gt;</type><parameter name="begin"><paramtype>char_type const *</paramtype></parameter><parameter name="size"><paramtype>std::size_t</paramtype></parameter><parameter name="flags"><paramtype>flag_type</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="operator[]"><type><classname>basic_regex</classname>&lt; BidiIter &gt; &amp;</type><parameter name="name"><paramtype>string_type const &amp;</paramtype><description><para>A std::string containing the name of the regular expression. </para></description></parameter><description><para>Return a reference to the named regular expression. If no such named regular expression exists, create a new regular expression and return a reference to it.</para><para>


</para></description><requires><para>The string is not empty. </para></requires><throws><simpara><classname>bad_alloc</classname> on allocation failure. </simpara></throws></method>
<method name="operator[]" cv="const"><type><classname>basic_regex</classname>&lt; BidiIter &gt; const &amp;</type><parameter name="name"><paramtype>string_type const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
</method-group>
<constructor specifiers="explicit"><parameter name="traits"><paramtype>RegexTraits const &amp;</paramtype><default>RegexTraits()</default></parameter></constructor>
<method-group name="private member functions">
<method name="is_upper_" cv="const"><type>bool</type><parameter name="ch"><paramtype>char_type</paramtype></parameter></method>
</method-group>
</struct><struct name="value"><template>
      <template-type-parameter name="T"><purpose><para>The type of the value to store.</para></purpose></template-type-parameter>
    </template><inherit access="public">proto::extends&lt; proto::terminal&lt; T &gt;::type, value&lt; T &gt; &gt;</inherit><purpose><computeroutput>value&lt;&gt;</computeroutput> is a lazy wrapper for a value that can be used in xpressive semantic actions. </purpose><description><para>
Below is an example that shows where <computeroutput><computeroutput>value&lt;&gt;</computeroutput></computeroutput> is useful.<programlisting language="c++">sregex good_voodoo(boost::shared_ptr&lt;int&gt; pi)
{
    using namespace boost::xpressive;
    // Use val() to hold the shared_ptr by value:
    <classname alt="boost::xpressive::basic_regex">sregex</classname> rex = +( _d [ ++*val(pi) ] &gt;&gt; '!' );
    // OK, rex holds a reference count to the integer.
    return rex;
}
</programlisting> In the above code, <computeroutput>xpressive::val()</computeroutput> is a function that returns a <computeroutput>value&lt;&gt;</computeroutput> object. Had <computeroutput>val()</computeroutput> not been used here, the operation <computeroutput>++*pi</computeroutput> would have been evaluated eagerly once, instead of lazily when the regex match happens. </para></description><method-group name="public member functions">
<method name="get"><type>T &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="get" cv="const"><type>T const &amp;</type><purpose>Fetch the stored value. </purpose></method>
</method-group>
<constructor><purpose>Store a default-constructed <computeroutput>T</computeroutput>. </purpose></constructor>
<constructor specifiers="explicit"><parameter name="t"><paramtype>T const &amp;</paramtype><description><para>The initial value. </para></description></parameter><purpose>Store a copy of <computeroutput>t</computeroutput>. </purpose><description><para>
</para></description></constructor>
</struct><struct name="reference"><template>
      <template-type-parameter name="T"><purpose><para>The type of the referent.</para></purpose></template-type-parameter>
    </template><inherit access="public">proto::extends&lt; proto::terminal&lt; reference_wrapper&lt; T &gt; &gt;::type, reference&lt; T &gt; &gt;</inherit><purpose><computeroutput>reference&lt;&gt;</computeroutput> is a lazy wrapper for a reference that can be used in xpressive semantic actions. </purpose><description><para>
Here is an example of how to use <computeroutput>reference&lt;&gt;</computeroutput> to create a lazy reference to an existing object so it can be read and written in an xpressive semantic action.<programlisting language="c++">using namespace boost::xpressive;
std::map&lt;std::string, int&gt; result;
<classname alt="boost::xpressive::reference">reference&lt;std::map&lt;std::string, int&gt;</classname> &gt; result_ref(result);

// Match a word and an integer, separated by =&gt;,
// and then stuff the result into a std::map&lt;&gt;
<classname alt="boost::xpressive::basic_regex">sregex</classname> pair = ( (s1= +_w) &gt;&gt; "=&gt;" &gt;&gt; (s2= +_d) )
    [ result_ref[s1] = as&lt;int&gt;(s2) ];
</programlisting> </para></description><method-group name="public member functions">
<method name="get" cv="const"><type>T &amp;</type><purpose>Fetch the stored value. </purpose></method>
</method-group>
<constructor specifiers="explicit"><parameter name="t"><paramtype>T &amp;</paramtype><description><para>Reference to object </para></description></parameter><purpose>Store a reference to <computeroutput>t</computeroutput>. </purpose><description><para>
</para></description></constructor>
</struct><struct name="local"><template>
      <template-type-parameter name="T"><purpose><para>The type of the local variable.</para></purpose></template-type-parameter>
    </template><inherit access="public">proto::terminal::type&lt; reference_wrapper&lt; T &gt; &gt;</inherit><purpose><computeroutput>local&lt;&gt;</computeroutput> is a lazy wrapper for a reference to a value that is stored within the local itself. It is for use within xpressive semantic actions. </purpose><description><para>
Below is an example of how to use <computeroutput>local&lt;&gt;</computeroutput> in semantic actions.<programlisting language="c++">using namespace boost::xpressive;
<classname alt="boost::xpressive::local">local&lt;int&gt;</classname> i(0);
std::string str("1!2!3?");
// count the exciting digits, but not the
// questionable ones.
<classname alt="boost::xpressive::basic_regex">sregex</classname> rex = +( _d [ ++i ] &gt;&gt; '!' );
regex_search(str, rex);
assert( i.get() == 2 );
</programlisting> <note><para>As the name "local" suggests, <computeroutput>local&lt;&gt;</computeroutput> objects and the regexes that refer to them should never leave the local scope. The value stored within the local object will be destroyed at the end of the <computeroutput>local&lt;&gt;'s</computeroutput> lifetime, and any regex objects still holding the <computeroutput>local&lt;&gt;</computeroutput> will be left with a dangling reference. </para></note>
</para></description><method-group name="public member functions">
<method name="get"><type>T &amp;</type><purpose>Fetch the wrapped value. </purpose></method>
<method name="get" cv="const"><type>T const &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
</method-group>
<constructor><purpose>Store a default-constructed value of type <computeroutput>T</computeroutput>. </purpose></constructor>
<constructor specifiers="explicit"><parameter name="t"><paramtype>T const &amp;</paramtype><description><para>The initial value. </para></description></parameter><purpose>Store a default-constructed value of type <computeroutput>T</computeroutput>. </purpose><description><para>
</para></description></constructor>
</struct><struct name="placeholder"><template>
      <template-type-parameter name="T"><purpose><para>The type of the object for which this placeholder stands in. </para></purpose></template-type-parameter>
      <template-nontype-parameter name="I"><type>int</type><default>0</default><purpose><para>An optional identifier that can be used to distinguish this placeholder from others that may be used in the same semantic action that happen to have the same type.</para></purpose></template-nontype-parameter>
      <template-type-parameter name="Dummy"><default>proto::is_proto_expr</default></template-type-parameter>
    </template><purpose>For defining a placeholder to stand in for a variable a semantic action. </purpose><description><para>Use <computeroutput>placeholder&lt;&gt;</computeroutput> to define a placeholder for use in semantic actions to stand in for real objects. The use of placeholders allows regular expressions with actions to be defined once and reused in many contexts to read and write from objects which were not available when the regex was defined.</para><para>
You can use <computeroutput>placeholder&lt;&gt;</computeroutput> by creating an object of type <computeroutput>placeholder&lt;T&gt;</computeroutput> and using that object in a semantic action exactly as you intend an object of type <computeroutput>T</computeroutput> to be used. <programlisting language="c++">placeholder&lt;int&gt; _i;
placeholder&lt;double&gt; _d;

sregex rex = ( some &gt;&gt; regex &gt;&gt; here )
    [ ++_i, _d *= _d ];
</programlisting> Then, when doing a pattern match with either <computeroutput>regex_search()</computeroutput>, <computeroutput>regex_match()</computeroutput> or <computeroutput>regex_replace()</computeroutput>, pass a <computeroutput><classname alt="boost::xpressive::match_results">match_results</classname>&lt;&gt;</computeroutput> object that contains bindings for the placeholders used in the regex object's semantic actions. You can create the bindings by calling <computeroutput>match_results::let</computeroutput> as follows: <programlisting language="c++">int i = 0;
double d = 3.14;

smatch what;
what.let(_i = i)
    .let(_d = d);

if(regex_match("some string", rex, what))
   // i and d mutated here
</programlisting> If a semantic action executes that contains an unbound placeholder, a exception of type <computeroutput><classname alt="boost::xpressive::regex_error">regex_error</classname></computeroutput> is thrown.</para><para>See the discussion for <computeroutput>xpressive::let()</computeroutput> and the  <link linkend="boost_xpressive.user_s_guide.semantic_actions_and_user_defined_assertions.referring_to_non_local_variables"> "Referring to Non-Local Variables"</link> section in the Users' Guide for more information.</para><para><emphasis>Example:</emphasis> <programlisting language="c++">// Define a placeholder for a map object:
placeholder&lt;std::map&lt;std::string, int&gt; &gt; _map;

// Match a word and an integer, separated by =&gt;,
// and then stuff the result into a std::map&lt;&gt;
sregex pair = ( (s1= +_w) &gt;&gt; "=&gt;" &gt;&gt; (s2= +_d) )
    [ _map[s1] = as&lt;int&gt;(s2) ];

// Match one or more word/integer pairs, separated
// by whitespace.
sregex rx = pair &gt;&gt; *(+_s &gt;&gt; pair);

// The string to parse
std::string str("aaa=&gt;1 bbb=&gt;23 ccc=&gt;456");

// Here is the actual map to fill in:
std::map&lt;std::string, int&gt; result;

// Bind the _map placeholder to the actual map
smatch what;
what.let( _map = result );

// Execute the match and fill in result map
if(regex_match(str, what, rx))
{
    std::cout &lt;&lt; result["aaa"] &lt;&lt; '\n';
    std::cout &lt;&lt; result["bbb"] &lt;&lt; '\n';
    std::cout &lt;&lt; result["ccc"] &lt;&lt; '\n';
}
</programlisting> </para></description><method-group name="public member functions">
</method-group>
<copy-assignment cv="const"><type><emphasis>unspecified</emphasis></type><parameter name="t"><paramtype>T &amp;</paramtype><description><para>The object to associate with this placeholder </para></description></parameter><description><para>

</para></description><returns><para>An object of unspecified type that records the association of <computeroutput>t</computeroutput> with <computeroutput>*this</computeroutput>. </para></returns></copy-assignment>
<copy-assignment cv="const"><type><emphasis>unspecified</emphasis></type><parameter name="t"><paramtype>T const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment>
</struct><namespace name="op">
<struct name="as"><template>
      <template-type-parameter name="T"><purpose><para>The type to which to lexically cast the parameter. </para></purpose></template-type-parameter>
    </template><purpose><computeroutput>as&lt;&gt;</computeroutput> is a PolymorphicFunctionObject for lexically casting a parameter to a different type. </purpose><description><para>
</para></description><method-group name="public member functions">
<method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="Value"/>
        </template><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to lexically cast. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>boost::lexical_cast&lt;T&gt;(val)</computeroutput> </para></returns></method>
</method-group>
<method-group name="private member functions">
</method-group>
</struct><struct name="static_cast_"><template>
      <template-type-parameter name="T"><purpose><para>The type to which to statically cast the parameter. </para></purpose></template-type-parameter>
    </template><purpose><computeroutput><classname alt="boost::xpressive::op::static_cast_">static_cast_</classname>&lt;&gt;</computeroutput> is a PolymorphicFunctionObject for statically casting a parameter to a different type. </purpose><description><para>
</para></description><method-group name="public member functions">
<method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="Value"/>
        </template><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to statically cast. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>static_cast&lt;T&gt;(val)</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="dynamic_cast_"><template>
      <template-type-parameter name="T"><purpose><para>The type to which to dynamically cast the parameter. </para></purpose></template-type-parameter>
    </template><purpose><computeroutput><classname alt="boost::xpressive::op::dynamic_cast_">dynamic_cast_</classname>&lt;&gt;</computeroutput> is a PolymorphicFunctionObject for dynamically casting a parameter to a different type. </purpose><description><para>
</para></description><method-group name="public member functions">
<method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="Value"/>
        </template><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to dynamically cast. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>dynamic_cast&lt;T&gt;(val)</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="const_cast_"><template>
      <template-type-parameter name="T"><purpose><para>The type to which to const-cast the parameter. </para></purpose></template-type-parameter>
    </template><purpose><computeroutput><classname alt="boost::xpressive::op::const_cast_">const_cast_</classname>&lt;&gt;</computeroutput> is a PolymorphicFunctionObject for const-casting a parameter to a cv qualification. </purpose><description><para>
</para></description><method-group name="public member functions">
<method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="Value"/>
        </template><parameter name="val"><paramtype>Value const &amp;</paramtype><description><para>The value to const-cast. </para></description></parameter><description><para>


</para></description><requires><para>Types <computeroutput>T</computeroutput> and <computeroutput>Value</computeroutput> differ only in cv-qualification. </para></requires><returns><para><computeroutput>const_cast&lt;T&gt;(val)</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="construct"><template>
      <template-type-parameter name="T"><purpose><para>The type of the object to construct. </para></purpose></template-type-parameter>
    </template><purpose><computeroutput>construct&lt;&gt;</computeroutput> is a PolymorphicFunctionObject for constructing a new object. </purpose><description><para>
</para></description><method-group name="public member functions">
<method name="operator()" cv="const"><type>T</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="operator()" cv="const"><type>T</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype><description><para>The first argument to the constructor </para></description></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype><description><para>The second argument to the constructor </para></description></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype><description><para>The third argument to the constructor </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>T(a0,a1,...)</computeroutput> </para></returns></method>
</method-group>
</struct><struct name="throw_"><template>
      <template-type-parameter name="Except"><purpose><para>The type of the object to throw. </para></purpose></template-type-parameter>
    </template><purpose><computeroutput><classname alt="boost::xpressive::op::throw_">throw_</classname>&lt;&gt;</computeroutput> is a PolymorphicFunctionObject for throwing an exception. </purpose><description><para>
</para></description><method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method>
<method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype><description><para>The first argument to the constructor </para></description></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype><description><para>The second argument to the constructor </para></description></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype><description><para>The third argument to the constructor </para></description></parameter><description><para>

<note><para>This function makes use of the <computeroutput>BOOST_THROW_EXCEPTION</computeroutput> macro to actually throw the exception. See the documentation for the Boost.Exception library. </para></note>
</para></description><throws><simpara><classname>&lt;tt&gt;Except(a0</classname> </simpara></throws></method>
</method-group>
</struct></namespace>
<typedef name="regex_id_type"><type>void const *</type></typedef>
<typedef name="sregex"><type><classname>basic_regex</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef name="cregex"><type><classname>basic_regex</classname>&lt; char const * &gt;</type></typedef>
<typedef name="wsregex"><type><classname>basic_regex</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef name="wcregex"><type><classname>basic_regex</classname>&lt; wchar_t const * &gt;</type></typedef>
<typedef name="ssub_match"><type><classname>sub_match</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef name="csub_match"><type><classname>sub_match</classname>&lt; char const * &gt;</type></typedef>
<typedef name="wssub_match"><type><classname>sub_match</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef name="wcsub_match"><type><classname>sub_match</classname>&lt; wchar_t const * &gt;</type></typedef>
<typedef name="sregex_compiler"><type><classname>regex_compiler</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef name="cregex_compiler"><type><classname>regex_compiler</classname>&lt; char const * &gt;</type></typedef>
<typedef name="wsregex_compiler"><type><classname>regex_compiler</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef name="wcregex_compiler"><type><classname>regex_compiler</classname>&lt; wchar_t const * &gt;</type></typedef>
<typedef name="sregex_iterator"><type><classname>regex_iterator</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef name="cregex_iterator"><type><classname>regex_iterator</classname>&lt; char const * &gt;</type></typedef>
<typedef name="wsregex_iterator"><type><classname>regex_iterator</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef name="wcregex_iterator"><type><classname>regex_iterator</classname>&lt; wchar_t const * &gt;</type></typedef>
<typedef name="sregex_token_iterator"><type><classname>regex_token_iterator</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef name="cregex_token_iterator"><type><classname>regex_token_iterator</classname>&lt; char const * &gt;</type></typedef>
<typedef name="wsregex_token_iterator"><type><classname>regex_token_iterator</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef name="wcregex_token_iterator"><type><classname>regex_token_iterator</classname>&lt; wchar_t const * &gt;</type></typedef>
<typedef name="smatch"><type><classname>match_results</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef name="cmatch"><type><classname>match_results</classname>&lt; char const * &gt;</type></typedef>
<typedef name="wsmatch"><type><classname>match_results</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef name="wcmatch"><type><classname>match_results</classname>&lt; wchar_t const * &gt;</type></typedef>
<typedef name="sregex_id_filter_predicate"><type><classname>regex_id_filter_predicate</classname>&lt; std::string::const_iterator &gt;</type></typedef>
<typedef name="cregex_id_filter_predicate"><type><classname>regex_id_filter_predicate</classname>&lt; char const * &gt;</type></typedef>
<typedef name="wsregex_id_filter_predicate"><type><classname>regex_id_filter_predicate</classname>&lt; std::wstring::const_iterator &gt;</type></typedef>
<typedef name="wcregex_id_filter_predicate"><type><classname>regex_id_filter_predicate</classname>&lt; wchar_t const * &gt;</type></typedef>

























































































</namespace>
</namespace>
<macro name="BOOST_PROTO_FUSION_V2"/>
<macro name="BOOST_XPRESSIVE_HAS_MS_STACK_GUARD"/>
</header>
<header name="boost/xpressive/xpressive_static.hpp">
<para>Includes everything you need to write static regular expressions and use them. </para></header>
<header name="boost/xpressive/xpressive_typeof.hpp">
<para>Type registrations so that xpressive can be used with the Boost.Typeof library. </para></header>
</library-reference>