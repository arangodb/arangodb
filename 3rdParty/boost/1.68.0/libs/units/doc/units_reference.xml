<?xml version="1.0" standalone="yes"?>
<library-reference id="units_reference"><title>Units Reference</title><header name="boost/units/absolute.hpp">
<para>Absolute units (points rather than vectors). </para><para>Operations between absolute units, and relative units like temperature differences. </para><namespace name="boost">
<namespace name="units">
<class name="absolute"><template>
      <template-type-parameter name="Y"/>
    </template><description><para>A wrapper to represent absolute units (points rather than vectors). Intended originally for temperatures, this class implements operators for absolute units so that addition of a relative unit to an absolute unit results in another absolute unit : absolute&lt;T&gt; +/- T -&gt; absolute&lt;T&gt; and subtraction of one absolute unit from another results in a relative unit : absolute&lt;T&gt; - absolute&lt;T&gt; -&gt; T. </para></description><typedef name="this_type"><type><classname>absolute</classname>&lt; Y &gt;</type></typedef>
<typedef name="value_type"><type>Y</type></typedef>
<method-group name="public member functions">
<method name="value" cv="const"><type>BOOST_CONSTEXPR const value_type &amp;</type></method>
<method name="operator+="><type>BOOST_CXX14_CONSTEXPR const this_type &amp;</type><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter></method>
<method name="operator-="><type>BOOST_CXX14_CONSTEXPR const this_type &amp;</type><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter></method>
</method-group>
<constructor/>
<constructor><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter></constructor>
<constructor><parameter name="source"><paramtype>const this_type &amp;</paramtype></parameter></constructor>
<copy-assignment><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><parameter name="source"><paramtype>const this_type &amp;</paramtype></parameter></copy-assignment>
</class>






















































































































<function name="operator+"><type>BOOST_CONSTEXPR <classname>absolute</classname>&lt; Y &gt;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="aval"><paramtype>const <classname>absolute</classname>&lt; Y &gt; &amp;</paramtype></parameter><parameter name="rval"><paramtype>const Y &amp;</paramtype></parameter><purpose>add a relative value to an absolute one </purpose></function>
<function name="operator+"><type>BOOST_CONSTEXPR <classname>absolute</classname>&lt; Y &gt;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="rval"><paramtype>const Y &amp;</paramtype></parameter><parameter name="aval"><paramtype>const <classname>absolute</classname>&lt; Y &gt; &amp;</paramtype></parameter><purpose>add a relative value to an absolute one </purpose></function>
<function name="operator-"><type>BOOST_CONSTEXPR <classname>absolute</classname>&lt; Y &gt;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="aval"><paramtype>const <classname>absolute</classname>&lt; Y &gt; &amp;</paramtype></parameter><parameter name="rval"><paramtype>const Y &amp;</paramtype></parameter><purpose>subtract a relative value from an absolute one </purpose></function>
<function name="operator-"><type>BOOST_CONSTEXPR Y</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="aval1"><paramtype>const <classname>absolute</classname>&lt; Y &gt; &amp;</paramtype></parameter><parameter name="aval2"><paramtype>const <classname>absolute</classname>&lt; Y &gt; &amp;</paramtype></parameter><purpose>subtracting two absolutes gives a difference </purpose></function>
<function name="operator*"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; <classname>absolute</classname>&lt; <classname>unit</classname>&lt; D, S &gt; &gt;, T &gt;</type><template>
          <template-type-parameter name="D"/>
          <template-type-parameter name="S"/>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>const T &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>absolute</classname>&lt; <classname>unit</classname>&lt; D, S &gt; &gt; &amp;</paramtype></parameter><purpose>creates a quantity from an absolute unit and a raw value </purpose></function>
<function name="operator*"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; <classname>absolute</classname>&lt; <classname>unit</classname>&lt; D, S &gt; &gt;, T &gt;</type><template>
          <template-type-parameter name="D"/>
          <template-type-parameter name="S"/>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>const <classname>absolute</classname>&lt; <classname>unit</classname>&lt; D, S &gt; &gt; &amp;</paramtype></parameter><parameter name="t"><paramtype>const T &amp;</paramtype></parameter><purpose>creates a quantity from an absolute unit and a raw value </purpose></function>
<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; Char, Traits &gt; &amp;</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; Char, Traits &gt; &amp;</paramtype></parameter><parameter name="aval"><paramtype>const <classname>absolute</classname>&lt; Y &gt; &amp;</paramtype></parameter><purpose>Print an absolute unit. </purpose></function>
</namespace>
</namespace>
<macro name="BOOST_UNITS_DEFINE_CONVERSION_OFFSET" kind="functionlike"><macro-parameter name="From"/><macro-parameter name="To"/><macro-parameter name="type_"/><macro-parameter name="value_"/><description><para>Macro to define the offset between two absolute units. Requires the value to be in the destination units e.g <programlisting language="c++">BOOST_UNITS_DEFINE_CONVERSION_OFFSET(celsius_base_unit, fahrenheit_base_unit, double, 32.0);
</programlisting> <computeroutput>BOOST_UNITS_DEFINE_CONVERSION_FACTOR</computeroutput> is also necessary to specify the conversion factor. Like <computeroutput>BOOST_UNITS_DEFINE_CONVERSION_FACTOR</computeroutput> this macro defines both forward and reverse conversions so defining, e.g., the conversion from celsius to fahrenheit as above will also define the inverse conversion from fahrenheit to celsius. </para></description></macro>
</header>
<header name="boost/units/base_dimension.hpp">
<para>base dimensions (mass, length, time...). </para><para>base dimension definition registration. </para><namespace name="boost">
<namespace name="units">
<class name="base_dimension"><template>
      <template-type-parameter name="Derived"/>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><inherit access="public">ordinal&lt; N &gt;</inherit><description><para>Defines a base dimension. To define a dimension you need to provide the derived class (CRTP) and a unique integer. <programlisting language="c++">struct my_dimension : <classname alt="boost::units::base_dimension">boost::units::base_dimension</classname>&lt;my_dimension, 1&gt; {};
</programlisting> It is designed so that you will get an error message if you try to use the same value in multiple definitions. </para></description><typedef name="dimension_type"><purpose>A convenience typedef. Equivalent to boost::units::derived_dimension&lt;Derived,1&gt;::type. </purpose><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="type"><purpose>Provided for mpl compatability. </purpose><type>Derived</type></typedef>
<method-group name="friend functions">
</method-group>
</class>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/base_unit.hpp">
<para>base unit (meter, kg, sec...). </para><para>base unit definition registration. </para><namespace name="boost">
<namespace name="units">
<class name="base_unit"><template>
      <template-type-parameter name="Derived"/>
      <template-type-parameter name="Dim"/>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><inherit access="public">ordinal&lt; N &gt;</inherit><description><para>Defines a base unit. To define a unit you need to provide the derived class (CRTP), a dimension list and a unique integer. <programlisting language="c++">struct my_unit : <classname alt="boost::units::base_unit">boost::units::base_unit</classname>&lt;my_unit, length_dimension, 1&gt; {};
</programlisting> It is designed so that you will get an error message if you try to use the same value in multiple definitions. </para></description><typedef name="dimension_type"><purpose>The dimensions of this base unit. </purpose><type>Dim</type></typedef>
<typedef name="type"><purpose>Provided for mpl compatability. </purpose><type>Derived</type></typedef>
<typedef name="unit_type"><purpose>The unit corresponding to this base unit. </purpose><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="friend functions">
</method-group>
</class>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/cmath.hpp">
<para>Overloads of functions in &lt;cmath&gt; for quantities. </para><para>Only functions for which a dimensionally-correct result type can be determined are overloaded. All functions work with dimensionless quantities. </para><namespace name="boost">
<namespace name="units">







































































<function name="isfinite"><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="isinf"><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="isnan"><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="isnormal"><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="isgreater"><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="isgreaterequal"><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="isless"><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="islessequal"><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="islessgreater"><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="isunordered"><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="abs"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="ceil"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="copysign"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="fabs"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="floor"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="fdim"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="fmax"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="fmin"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="fpclassify"><type>BOOST_CONSTEXPR int</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="hypot"><type>BOOST_CONSTEXPR <classname>root_typeof_helper</classname>&lt; typename <classname>add_typeof_helper</classname>&lt; typename <classname>power_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, Y &gt;, <classname>static_rational</classname>&lt; 2 &gt; &gt;::type, typename <classname>power_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, Y &gt;, <classname>static_rational</classname>&lt; 2 &gt; &gt;::type &gt;::type, <classname>static_rational</classname>&lt; 2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="nextafter"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="nexttoward"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="round"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="signbit"><type>BOOST_CONSTEXPR int</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="trunc"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="fmod"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="modf"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype><classname>quantity</classname>&lt; Unit, Y &gt; *</paramtype></parameter></function>
<function name="frexp"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="Int"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="ex"><paramtype>Int *</paramtype></parameter></function>
<function name="pow"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt;</type><template>
          <template-type-parameter name="S"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q1"><paramtype>const <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt; &amp;</paramtype></parameter><parameter name="q2"><paramtype>const <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt; &amp;</paramtype></parameter><description><para>For non-dimensionless quantities, integral and rational powers and roots can be computed by <computeroutput>pow&lt;Ex&gt;</computeroutput> and <computeroutput>root&lt;Rt&gt;</computeroutput> respectively. </para></description></function>
<function name="exp"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt;</type><template>
          <template-type-parameter name="S"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt; &amp;</paramtype></parameter></function>
<function name="ldexp"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; Unit, Y &gt;</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="Int"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="ex"><paramtype>const Int &amp;</paramtype></parameter></function>
<function name="log"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt;</type><template>
          <template-type-parameter name="S"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt; &amp;</paramtype></parameter></function>
<function name="log10"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt;</type><template>
          <template-type-parameter name="S"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(S), Y &gt; &amp;</paramtype></parameter></function>
<function name="sqrt"><type>BOOST_CONSTEXPR <classname>root_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, Y &gt;, <classname>static_rational</classname>&lt; 2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter></function>
<function name="cos"><type>BOOST_CONSTEXPR <classname>dimensionless_quantity</classname>&lt; si::system, Y &gt;::type</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="theta"><paramtype>const <classname>quantity</classname>&lt; si::plane_angle, Y &gt; &amp;</paramtype></parameter><purpose>cos of theta in radians </purpose></function>
<function name="sin"><type>BOOST_CONSTEXPR <classname>dimensionless_quantity</classname>&lt; si::system, Y &gt;::type</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="theta"><paramtype>const <classname>quantity</classname>&lt; si::plane_angle, Y &gt; &amp;</paramtype></parameter><purpose>sin of theta in radians </purpose></function>
<function name="tan"><type>BOOST_CONSTEXPR <classname>dimensionless_quantity</classname>&lt; si::system, Y &gt;::type</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="theta"><paramtype>const <classname>quantity</classname>&lt; si::plane_angle, Y &gt; &amp;</paramtype></parameter><purpose>tan of theta in radians </purpose></function>
<function name="cos"><type>BOOST_CONSTEXPR <classname>dimensionless_quantity</classname>&lt; System, Y &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="theta"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, System &gt;, Y &gt; &amp;</paramtype></parameter><purpose>cos of theta in other angular units </purpose></function>
<function name="sin"><type>BOOST_CONSTEXPR <classname>dimensionless_quantity</classname>&lt; System, Y &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="theta"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, System &gt;, Y &gt; &amp;</paramtype></parameter><purpose>sin of theta in other angular units </purpose></function>
<function name="tan"><type>BOOST_CONSTEXPR <classname>dimensionless_quantity</classname>&lt; System, Y &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="theta"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, System &gt;, Y &gt; &amp;</paramtype></parameter><purpose>tan of theta in other angular units </purpose></function>
<function name="acos"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt;</type><template>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="System"/>
        </template><parameter name="val"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt; &amp;</paramtype></parameter><purpose>acos of dimensionless quantity returning angle in same system </purpose></function>
<function name="acos"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; angle::radian_base_unit::unit_type, Y &gt;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="val"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, heterogeneous_dimensionless_system &gt;, Y &gt; &amp;</paramtype></parameter><purpose>acos of dimensionless quantity returning angle in radians </purpose></function>
<function name="asin"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt;</type><template>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="System"/>
        </template><parameter name="val"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt; &amp;</paramtype></parameter><purpose>asin of dimensionless quantity returning angle in same system </purpose></function>
<function name="asin"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; angle::radian_base_unit::unit_type, Y &gt;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="val"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, heterogeneous_dimensionless_system &gt;, Y &gt; &amp;</paramtype></parameter><purpose>asin of dimensionless quantity returning angle in radians </purpose></function>
<function name="atan"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt;</type><template>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="System"/>
        </template><parameter name="val"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt; &amp;</paramtype></parameter><purpose>atan of dimensionless quantity returning angle in same system </purpose></function>
<function name="atan"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; angle::radian_base_unit::unit_type, Y &gt;</type><template>
          <template-type-parameter name="Y"/>
        </template><parameter name="val"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, heterogeneous_dimensionless_system &gt;, Y &gt; &amp;</paramtype></parameter><purpose>atan of dimensionless quantity returning angle in radians </purpose></function>
<function name="atan2"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; <classname>unit</classname>&lt; plane_angle_dimension, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt;</type><template>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="Dimension"/>
          <template-type-parameter name="System"/>
        </template><parameter name="y"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; Dimension, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt; &amp;</paramtype></parameter><parameter name="x"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; Dimension, <classname>homogeneous_system</classname>&lt; System &gt; &gt;, Y &gt; &amp;</paramtype></parameter><purpose>atan2 of <computeroutput>value_type</computeroutput> returning angle in radians </purpose></function>
<function name="atan2"><type>BOOST_CONSTEXPR <classname>quantity</classname>&lt; angle::radian_base_unit::unit_type, Y &gt;</type><template>
          <template-type-parameter name="Y"/>
          <template-type-parameter name="Dimension"/>
          <template-type-parameter name="System"/>
        </template><parameter name="y"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; Dimension, <classname>heterogeneous_system</classname>&lt; System &gt; &gt;, Y &gt; &amp;</paramtype></parameter><parameter name="x"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; Dimension, <classname>heterogeneous_system</classname>&lt; System &gt; &gt;, Y &gt; &amp;</paramtype></parameter><purpose>atan2 of <computeroutput>value_type</computeroutput> returning angle in radians </purpose></function>







</namespace>
</namespace>
</header>
<header name="boost/units/config.hpp">
<macro name="BOOST_UNITS_REQUIRE_LAYOUT_COMPATIBILITY"><description><para>If defined will trigger a static assertion if quantity&lt;Unit, T&gt; is not layout compatible with T </para></description></macro>
<macro name="BOOST_UNITS_NO_COMPILER_CHECK"><description><para>If defined will disable a preprocessor check that the compiler is able to handle the library. </para></description></macro>
<macro name="BOOST_UNITS_CHECK_HOMOGENEOUS_UNITS"><description><para>Enable checking to verify that a homogeneous system is actually capable of representing all the dimensions that it is used with. Off by default. </para></description></macro>
</header>
<header name="boost/units/conversion.hpp">
<para>Template for defining conversions between quantities. </para><namespace name="boost">
<namespace name="units">
<struct name="conversion_helper"><template>
      <template-type-parameter name="From"/>
      <template-type-parameter name="To"/>
    </template><description><para>Template for defining conversions between quantities. This template should be specialized for every quantity that allows conversions. For example, if you have a two units called pair and dozen you would write <programlisting language="c++">namespace boost {
namespace units {
template&lt;class T0, class T1&gt;
struct conversion_helper&lt;quantity&lt;dozen, T0&gt;, quantity&lt;pair, T1&gt; &gt;
{
    static quantity&lt;pair, T1&gt; convert(const quantity&lt;dozen, T0&gt;&amp; source)
    {
        return(quantity&lt;pair, T1&gt;::from_value(6 * source.value()));
    }
};
}
}
</programlisting></para><para>In most cases, the predefined specializations for <computeroutput>unit</computeroutput> and <computeroutput>absolute</computeroutput> should be sufficient, so users should rarely need to use this. </para></description><method-group name="public static functions">
<method name="convert" specifiers="static"><type>BOOST_CONSTEXPR To</type><parameter name=""><paramtype>const From &amp;</paramtype></parameter></method>
</method-group>
</struct>





































































<function name="conversion_factor"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="FromUnit"/>
          <template-type-parameter name="ToUnit"/>
        </template><parameter name=""><paramtype>const FromUnit &amp;</paramtype></parameter><parameter name=""><paramtype>const ToUnit &amp;</paramtype></parameter><purpose>Find the conversion factor between two units. </purpose></function>























































</namespace>
</namespace>
<macro name="BOOST_UNITS_DEFINE_CONVERSION_FACTOR" kind="functionlike"><macro-parameter name="Source"/><macro-parameter name="Destination"/><macro-parameter name="type_"/><macro-parameter name="value_"/><description><para>Defines the conversion factor from a base unit to any unit or to another base unit with the correct dimensions. Uses of this macro must appear at global scope. If the destination unit is a base unit or a unit that contains only one base unit which is raised to the first power (e.g. feet-&gt;meters) the reverse (meters-&gt;feet in this example) need not be defined explicitly. </para></description></macro>
<macro name="BOOST_UNITS_DEFINE_CONVERSION_FACTOR_TEMPLATE" kind="functionlike"><macro-parameter name="Params"/><macro-parameter name="Source"/><macro-parameter name="Destination"/><macro-parameter name="type_"/><macro-parameter name="value_"/><description><para>Defines the conversion factor from a base unit to any other base unit with the same dimensions. Params should be a Boost.Preprocessor Seq of template parameters, such as (class T1)(class T2) All uses of must appear at global scope. The reverse conversion will be defined automatically. This macro is a little dangerous, because, unlike the non-template form, it will silently fail if either base unit is scaled. This is probably not an issue if both the source and destination types depend on the template parameters, but be aware that a generic conversion to kilograms is not going to work. </para></description></macro>
<macro name="BOOST_UNITS_DEFAULT_CONVERSION" kind="functionlike"><macro-parameter name="Source"/><macro-parameter name="Dest"/><description><para>Specifies the default conversion to be applied when no direct conversion is available. Source is a base unit. Dest is any unit with the same dimensions. </para></description></macro>
<macro name="BOOST_UNITS_DEFAULT_CONVERSION_TEMPLATE" kind="functionlike"><macro-parameter name="Params"/><macro-parameter name="Source"/><macro-parameter name="Dest"/><description><para>Specifies the default conversion to be applied when no direct conversion is available. Params is a PP Sequence of template arguments. Source is a base unit. Dest is any unit with the same dimensions. The source must not be a scaled base unit. </para></description></macro>
</header>
<header name="boost/units/derived_dimension.hpp">
<namespace name="boost">
<namespace name="units">
<struct name="derived_dimension"><template>
      <template-type-parameter name="DT1"><default><classname alt="boost::units::dimensionless_type">dimensionless_type</classname></default></template-type-parameter>
      <template-nontype-parameter name="E1"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT2"><default><classname alt="boost::units::dimensionless_type">dimensionless_type</classname></default></template-type-parameter>
      <template-nontype-parameter name="E2"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT3"><default><classname alt="boost::units::dimensionless_type">dimensionless_type</classname></default></template-type-parameter>
      <template-nontype-parameter name="E3"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT4"><default><classname alt="boost::units::dimensionless_type">dimensionless_type</classname></default></template-type-parameter>
      <template-nontype-parameter name="E4"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT5"><default><classname alt="boost::units::dimensionless_type">dimensionless_type</classname></default></template-type-parameter>
      <template-nontype-parameter name="E5"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT6"><default><classname alt="boost::units::dimensionless_type">dimensionless_type</classname></default></template-type-parameter>
      <template-nontype-parameter name="E6"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT7"><default><classname alt="boost::units::dimensionless_type">dimensionless_type</classname></default></template-type-parameter>
      <template-nontype-parameter name="E7"><type>long</type><default>0</default></template-nontype-parameter>
      <template-type-parameter name="DT8"><default><classname alt="boost::units::dimensionless_type">dimensionless_type</classname></default></template-type-parameter>
      <template-nontype-parameter name="E8"><type>long</type><default>0</default></template-nontype-parameter>
    </template><purpose>A utility class for defining composite dimensions with integer powers. </purpose><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef>
</struct>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/dim.hpp">
<para>Handling of fundamental dimension/exponent pairs. </para><namespace name="boost">
<namespace name="units">
<struct name="dim"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="V"/>
    </template><purpose>Dimension tag/exponent pair for a single fundamental dimension. </purpose><description><para>The dim class represents a single dimension tag/dimension exponent pair. That is, <computeroutput>dim&lt;tag_type,value_type&gt;</computeroutput> is a pair where <computeroutput>tag_type</computeroutput> represents the fundamental dimension being represented and <computeroutput>value_type</computeroutput> represents the exponent of that fundamental dimension as a <computeroutput><classname alt="boost::units::static_rational">static_rational</classname></computeroutput>. <computeroutput>tag_type</computeroutput> must be a derived from a specialization of <computeroutput><classname alt="boost::units::base_dimension">base_dimension</classname></computeroutput>. Specialization of the following Boost.MPL metafunctions are provided - @c mpl::plus for two @c dims
- @c mpl::minus for two @c dims
- @c mpl::negate for a @c dim
</para><para>These metafunctions all operate on the exponent, and require that the <computeroutput>dim</computeroutput> operands have the same base dimension tag. In addition, multiplication and division by <computeroutput><classname alt="boost::units::static_rational">static_rational</classname></computeroutput> is supported. - @c mpl::times for a @c static_rational and a @c dim in either order
- @c mpl::divides for a @c static_rational and a @c dim in either order
</para><para>These metafunctions likewise operate on the exponent only. </para></description><typedef name="type"><type><classname>dim</classname></type></typedef>
<typedef name="tag"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="tag_type"><type>T</type></typedef>
<typedef name="value_type"><type>V</type></typedef>
</struct>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/dimension.hpp">
<para>Core metaprogramming utilities for compile-time dimensional analysis. </para><namespace name="boost">
<namespace name="units">
<struct name="make_dimension_list"><template>
      <template-type-parameter name="Seq"/>
    </template><description><para>Reduce dimension list to cardinal form. This algorithm collapses duplicate base dimension tags and sorts the resulting list by the tag ordinal value. Dimension lists that resolve to the same dimension are guaranteed to be represented by an identical type.</para><para>The argument should be an MPL forward sequence containing instances of the <computeroutput>dim</computeroutput> template.</para><para>The result is also an MPL forward sequence. It also supports the following metafunctions to allow use as a dimension.</para><para><itemizedlist>
<listitem><para><computeroutput>mpl::plus</computeroutput> is defined only on two equal dimensions and returns the argument unchanged.</para></listitem><listitem><para><computeroutput>mpl::minus</computeroutput> is defined only for two equal dimensions and returns the argument unchanged.</para></listitem><listitem><para><computeroutput>mpl::negate</computeroutput> will return its argument unchanged.</para></listitem><listitem><para><computeroutput>mpl::times</computeroutput> is defined for any dimensions and adds corresponding exponents.</para></listitem><listitem><para><computeroutput>mpl::divides</computeroutput> is defined for any dimensions and subtracts the exponents of the right had argument from the corresponding exponents of the left had argument. Missing base dimension tags are assumed to have an exponent of zero.</para></listitem><listitem><para><computeroutput><classname alt="boost::units::static_power">static_power</classname></computeroutput> takes a dimension and a <classname alt="boost::units::static_rational">static_rational</classname> and multiplies all the exponents of the dimension by the <classname alt="boost::units::static_rational">static_rational</classname>.</para></listitem><listitem><para><computeroutput><classname alt="boost::units::static_root">static_root</classname></computeroutput> takes a dimension and a <classname alt="boost::units::static_rational">static_rational</classname> and divides all the exponents of the dimension by the <classname alt="boost::units::static_rational">static_rational</classname>. </para></listitem></itemizedlist>
</para></description><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef>
</struct>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/dimensionless_quantity.hpp">
<para>Utility class to simplify construction of dimensionless quantities. </para><namespace name="boost">
<namespace name="units">
<struct name="dimensionless_quantity"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Y"/>
    </template><purpose>Utility class to simplify construction of dimensionless quantities. </purpose><typedef name="type"><type><classname>quantity</classname>&lt; typename <classname>dimensionless_unit</classname>&lt; System &gt;::type, Y &gt;</type></typedef>
</struct>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/dimensionless_type.hpp">
<para>Dimension lists in which all exponents resolve to zero reduce to <computeroutput>dimensionless_type</computeroutput>. </para><namespace name="boost">
<namespace name="units">
<struct name="dimensionless_type"><purpose>Dimension lists in which all exponents resolve to zero reduce to <computeroutput><classname alt="boost::units::dimensionless_type">dimensionless_type</classname></computeroutput>. </purpose><typedef name="type"><type><classname>dimensionless_type</classname></type></typedef>
<typedef name="tag"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="size"><type>mpl::long_&lt; 0 &gt;</type></typedef>
</struct>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/dimensionless_unit.hpp">
<para>Utility class to simplify construction of dimensionless units in a system. </para><namespace name="boost">
<namespace name="units">
<struct name="dimensionless_unit"><template>
      <template-type-parameter name="System"/>
    </template><purpose>Utility class to simplify construction of dimensionless units in a system. </purpose><typedef name="type"><type><classname>unit</classname>&lt; <classname>dimensionless_type</classname>, System &gt;</type></typedef>
</struct>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/get_dimension.hpp">
<para>Get the dimension of a unit, absolute unit and quantity. </para><namespace name="boost">
<namespace name="units">
<struct name="get_dimension"><template>
      <template-type-parameter name="T"/>
    </template></struct><struct-specialization name="get_dimension"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><purpose>Get the dimension of a unit. </purpose><typedef name="type"><type>Dim</type></typedef>
</struct-specialization><struct-specialization name="get_dimension"><template>
      <template-type-parameter name="Unit"/>
    </template><specialization><template-arg>absolute&lt; Unit &gt;</template-arg></specialization><purpose>Get the dimension of an absolute unit. </purpose><typedef name="type"><type><classname>get_dimension</classname>&lt; Unit &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="get_dimension"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg></specialization><purpose>Get the dimension of a quantity. </purpose><typedef name="type"><type><classname>get_dimension</classname>&lt; Unit &gt;::type</type></typedef>
</struct-specialization>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/get_system.hpp">
<para>Get the system of a unit, absolute unit or quantity. </para><namespace name="boost">
<namespace name="units">
<struct name="get_system"><template>
      <template-type-parameter name="T"/>
    </template></struct><struct-specialization name="get_system"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><purpose>Get the system of a unit. </purpose><typedef name="type"><type>System</type></typedef>
</struct-specialization><struct-specialization name="get_system"><template>
      <template-type-parameter name="Unit"/>
    </template><specialization><template-arg>absolute&lt; Unit &gt;</template-arg></specialization><purpose>Get the system of an absolute unit. </purpose><typedef name="type"><type><classname>get_system</classname>&lt; Unit &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="get_system"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg></specialization><purpose>Get the system of a quantity. </purpose><typedef name="type"><type><classname>get_system</classname>&lt; Unit &gt;::type</type></typedef>
</struct-specialization>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/heterogeneous_system.hpp">
<para>A heterogeneous system is a sorted list of base unit/exponent pairs. </para><namespace name="boost">
<namespace name="mpl">
</namespace>
<namespace name="units">






























































































































</namespace>
</namespace>
</header>
<header name="boost/units/homogeneous_system.hpp">
<namespace name="boost">
<namespace name="units">
<struct name="homogeneous_system"><template>
      <template-type-parameter name="L"/>
    </template><description><para>A system that can uniquely represent any unit which can be composed from a linearly independent set of base units. It is safe to rebind a unit with such a system to different dimensions.</para><para>Do not construct this template directly. Use <classname alt="boost::units::make_system">make_system</classname> instead. </para></description></struct><struct name="static_power"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="E"/>
    </template><purpose>Raise a dimension list to a scalar power. </purpose></struct><struct name="static_root"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="R"/>
    </template><purpose>Take a scalar root of a dimension list. </purpose></struct>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/io.hpp">
<para>Stream input and output for rationals, units and quantities. </para><para>Functions and manipulators for output and input of units and quantities. symbol and name format, and engineering and binary autoprefix. Serialization output is also supported. </para><namespace name="boost">
<namespace name="serialization">
<function name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
        </template><parameter name=""><paramtype>Archive &amp;</paramtype></parameter><parameter name=""><paramtype><classname>boost::units::unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><parameter name="int"><paramtype>const unsigned</paramtype></parameter><purpose>Boost Serialization library support for units. </purpose></function>
<function name="serialize"><type>void</type><template>
          <template-type-parameter name="Archive"/>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="ar"><paramtype>Archive &amp;</paramtype></parameter><parameter name="q"><paramtype><classname>boost::units::quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="int"><paramtype>const unsigned</paramtype></parameter><purpose>Boost Serialization library support for quantities. </purpose></function>
</namespace>
<namespace name="units">
<enum name="format_mode"><enumvalue name="symbol_fmt"><default>= 0</default></enumvalue><enumvalue name="name_fmt"><default>= 1</default><purpose>default - reduces unit names to known symbols for both base and derived units. </purpose></enumvalue><enumvalue name="raw_fmt"><default>= 2</default><purpose>output full unit names for base and derived units, for example "meter". </purpose></enumvalue><enumvalue name="typename_fmt"><default>= 3</default><purpose>output only symbols for base units (but not derived units), for example "m". </purpose></enumvalue><enumvalue name="fmt_mask"><default>= 3</default><purpose>output demangled typenames (useful only for diagnosis). </purpose></enumvalue><purpose>format of output of units, for example "m" or "meter". </purpose></enum>
<enum name="autoprefix_mode"><enumvalue name="autoprefix_none"><default>= 0</default></enumvalue><enumvalue name="autoprefix_engineering"><default>= 4</default><purpose>No automatic prefix. </purpose></enumvalue><enumvalue name="autoprefix_binary"><default>= 8</default><purpose>Scale and prefix with 10^3 multiples, 1234.5 m output as 1.2345 km. </purpose></enumvalue><enumvalue name="autoprefix_mask"><default>= 12</default><purpose>Scale and prefix with 2^10 (1024) multiples, 1024 as 1 kb. </purpose></enumvalue><purpose>automatic scaling and prefix (controlled by value of quantity) a, if any, </purpose></enum>















































<function name="to_string"><type>std::string</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>const T &amp;</paramtype></parameter></function>
<function name="to_string"><type>std::string</type><template>
          <template-nontype-parameter name="N"><type>integer_type</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>static_rational</classname>&lt; N &gt; &amp;</paramtype></parameter><purpose>get string representation of integral-valued <computeroutput><classname alt="boost::units::static_rational">static_rational</classname></computeroutput>. </purpose></function>
<function name="to_string"><type>std::string</type><template>
          <template-nontype-parameter name="N"><type>integer_type</type></template-nontype-parameter>
          <template-nontype-parameter name="D"><type>integer_type</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>static_rational</classname>&lt; N, D &gt; &amp;</paramtype></parameter><purpose>get string representation of <computeroutput><classname alt="boost::units::static_rational">static_rational</classname></computeroutput>. </purpose></function>
<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; Char, Traits &gt; &amp;</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name="Traits"/>
          <template-nontype-parameter name="N"><type>integer_type</type></template-nontype-parameter>
          <template-nontype-parameter name="D"><type>integer_type</type></template-nontype-parameter>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; Char, Traits &gt; &amp;</paramtype></parameter><parameter name="r"><paramtype>const <classname>static_rational</classname>&lt; N, D &gt; &amp;</paramtype></parameter><purpose>Write <computeroutput><classname alt="boost::units::static_rational">static_rational</classname></computeroutput> to <computeroutput>std::basic_ostream</computeroutput>. </purpose></function>
<function name="get_flags"><type>long</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><parameter name="mask"><paramtype>long</paramtype></parameter><purpose>returns flags controlling output. </purpose></function>
<function name="set_flags"><type>void</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><parameter name="new_flags"><paramtype>long</paramtype></parameter><parameter name="mask"><paramtype>long</paramtype></parameter><purpose>Set new flags controlling output format. </purpose></function>
<function name="get_format"><type>format_mode</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><purpose>returns flags controlling output format. </purpose></function>
<function name="set_format"><type>void</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><parameter name="new_mode"><paramtype>format_mode</paramtype></parameter><purpose>Set new flags controlling output format. </purpose></function>
<function name="typename_format"><type>std::ios_base &amp;</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><purpose>Set new flags for type_name output format. </purpose></function>
<function name="raw_format"><type>std::ios_base &amp;</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><purpose>set new flag for raw format output, for example "m". </purpose></function>
<function name="symbol_format"><type>std::ios_base &amp;</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><purpose>set new format flag for symbol output, for example "m". </purpose></function>
<function name="name_format"><type>std::ios_base &amp;</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><purpose>set new format for name output, for example "meter". </purpose></function>
<function name="get_autoprefix"><type>autoprefix_mode</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><purpose>get autoprefix flags for output. </purpose></function>
<function name="set_autoprefix"><type>void</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><parameter name="new_mode"><paramtype>autoprefix_mode</paramtype></parameter><purpose>Get format for output. </purpose></function>
<function name="no_prefix"><type>std::ios_base &amp;</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><purpose>Clear autoprefix flags. </purpose></function>
<function name="engineering_prefix"><type>std::ios_base &amp;</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><purpose>Set flag for engineering prefix, so 1234.5 m displays as "1.2345 km". </purpose></function>
<function name="binary_prefix"><type>std::ios_base &amp;</type><parameter name="ios"><paramtype>std::ios_base &amp;</paramtype></parameter><purpose>Set flag for binary prefix, so 1024 byte displays as "1 Kib". </purpose></function>
<function name="autoprefix_norm"><type>double</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="arg"><paramtype>const T &amp;</paramtype></parameter><description><para>ADL customization point for automatic prefixing. Returns a non-negative value. Implemented as std::abs for built-in types. </para></description></function>
<function name="typename_string"><type>std::string</type><template>
          <template-type-parameter name="Dimension"/>
          <template-type-parameter name="System"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dimension, System &gt; &amp;</paramtype></parameter></function>
<function name="symbol_string"><type>std::string</type><template>
          <template-type-parameter name="Dimension"/>
          <template-type-parameter name="System"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dimension, System &gt; &amp;</paramtype></parameter></function>
<function name="name_string"><type>std::string</type><template>
          <template-type-parameter name="Dimension"/>
          <template-type-parameter name="System"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dimension, System &gt; &amp;</paramtype></parameter></function>
<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; Char, Traits &gt; &amp;</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Dimension"/>
          <template-type-parameter name="System"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; Char, Traits &gt; &amp;</paramtype></parameter><parameter name="u"><paramtype>const <classname>unit</classname>&lt; Dimension, System &gt; &amp;</paramtype></parameter><description><para>Print a <computeroutput>unit</computeroutput> as a list of base units and their exponents. for @c symbol_format outputs e.g. "m s^-1" or "J".
for @c name_format  outputs e.g. "meter second^-1" or "joule".
for @c raw_format  outputs e.g. "m s^-1" or "meter kilogram^2 second^-2".
for @c typename_format  outputs the typename itself (currently demangled only on GCC).   </para></description></function>
<function name="operator&lt;&lt;"><type>std::basic_ostream&lt; Char, Traits &gt; &amp;</type><template>
          <template-type-parameter name="Char"/>
          <template-type-parameter name="Traits"/>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="T"/>
        </template><parameter name="os"><paramtype>std::basic_ostream&lt; Char, Traits &gt; &amp;</paramtype></parameter><parameter name="q"><paramtype>const <classname>quantity</classname>&lt; Unit, T &gt; &amp;</paramtype></parameter><purpose>Print a <computeroutput>quantity</computeroutput>. </purpose><description><para>Prints the value followed by the unit. If the engineering_prefix, or binary_prefix is set, tries to scale the value appropriately. For example, it might print 12.345 km instead of 12345 m. (Note does <emphasis role="bold">not</emphasis> attempt to automatically scale scalars like double, float...) </para></description></function>
























































</namespace>
</namespace>
</header>
<header name="boost/units/is_dim.hpp">
<para>Check that a type is a valid <computeroutput>dim</computeroutput>. </para><namespace name="boost">
<namespace name="units">
<struct name="is_dim"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">false_</inherit><purpose>Check that a type is a valid <computeroutput>dim</computeroutput>. </purpose></struct><struct-specialization name="is_dim"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="V"/>
    </template><specialization><template-arg>dim&lt; T</template-arg><template-arg>V &gt;</template-arg></specialization><inherit access="public">true_</inherit></struct-specialization>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/is_dimension_list.hpp">
<para>Check that a type is a valid dimension list. </para><namespace name="boost">
<namespace name="units">
<struct name="is_dimension_list"><template>
      <template-type-parameter name="Seq"/>
    </template><inherit access="public">false_</inherit><purpose>Check that a type is a valid dimension list. </purpose></struct><struct-specialization name="is_dimension_list"><template>
      <template-type-parameter name="Item"/>
      <template-type-parameter name="Next"/>
    </template><specialization><template-arg>list&lt; Item</template-arg><template-arg>Next &gt;</template-arg></specialization><inherit access="public">true_</inherit></struct-specialization><struct-specialization name="is_dimension_list"><template>
    </template><specialization><template-arg>dimensionless_type</template-arg></specialization><inherit access="public">true_</inherit></struct-specialization>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/is_dimensionless.hpp">
<para>Check if a unit or quantity is dimensionless. </para><namespace name="boost">
<namespace name="units">
<struct name="is_dimensionless"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">false_</inherit></struct><struct-specialization name="is_dimensionless"><template>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; dimensionless_type</template-arg><template-arg>System &gt;</template-arg></specialization><inherit access="public">true_</inherit><purpose>Check if a unit is dimensionless. </purpose></struct-specialization><struct-specialization name="is_dimensionless"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg></specialization><inherit access="public">boost::units::is_dimensionless&lt; Unit &gt;</inherit><purpose>Check if a quantity is dimensionless. </purpose></struct-specialization>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/is_dimensionless_quantity.hpp">
<para>check that a type is a dimensionless quantity </para><namespace name="boost">
<namespace name="units">
<struct name="is_dimensionless_quantity"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::units::is_quantity_of_dimension&lt; T, dimensionless_type &gt;</inherit><purpose>Check that a type is a dimensionless quantity. </purpose></struct>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/is_dimensionless_unit.hpp">
<para>Check that a type is a dimensionless unit. </para><namespace name="boost">
<namespace name="units">
<struct name="is_dimensionless_unit"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::units::is_unit_of_dimension&lt; T, dimensionless_type &gt;</inherit><purpose>Check that a type is a dimensionless unit. </purpose></struct>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/is_quantity.hpp">
<para>Check that a type is a quantity. </para><namespace name="boost">
<namespace name="units">
<struct name="is_quantity"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">false_</inherit><purpose>Check that a type is a quantity. </purpose></struct><struct-specialization name="is_quantity"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg></specialization><inherit access="public">true_</inherit></struct-specialization>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/is_quantity_of_dimension.hpp">
<para>Check that a type is a quantity of the specified dimension. </para><namespace name="boost">
<namespace name="units">
<struct name="is_quantity_of_dimension"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Dim"/>
    </template><inherit access="public">false_</inherit><purpose>Check that a type is a quantity of the specified dimension. </purpose></struct><struct-specialization name="is_quantity_of_dimension"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
      <template-type-parameter name="Dim"/>
    </template><specialization><template-arg>quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg><template-arg>Dim</template-arg></specialization><inherit access="public">boost::units::is_unit_of_dimension&lt; Unit, Dim &gt;</inherit></struct-specialization>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/is_quantity_of_system.hpp">
<para>Check that a type is a quantity in a specified system. </para><namespace name="boost">
<namespace name="units">
<struct name="is_quantity_of_system"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="System"/>
    </template><inherit access="public">false_</inherit><purpose>Check that a type is a quantity in a specified system. </purpose></struct><struct-specialization name="is_quantity_of_system"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg><template-arg>System</template-arg></specialization><inherit access="public">boost::units::is_unit_of_system&lt; Unit, System &gt;</inherit></struct-specialization>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/is_unit.hpp">
<para>Check that a type is a unit. </para><namespace name="boost">
<namespace name="units">
<struct name="is_unit"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">false_</inherit><purpose>Check that a type is a unit. </purpose></struct><struct-specialization name="is_unit"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><inherit access="public">true_</inherit></struct-specialization>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/is_unit_of_dimension.hpp">
<para>Check that a type is a unit of the specified dimension. </para><namespace name="boost">
<namespace name="units">
<struct name="is_unit_of_dimension"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Dim"/>
    </template><inherit access="public">false_</inherit><purpose>Check that a type is a unit of the specified dimension. </purpose></struct><struct-specialization name="is_unit_of_dimension"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>Dim</template-arg></specialization><inherit access="public">true_</inherit></struct-specialization><struct-specialization name="is_unit_of_dimension"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>absolute&lt; unit&lt; Dim</template-arg><template-arg>System &gt; &gt;</template-arg><template-arg>Dim</template-arg></specialization><inherit access="public">true_</inherit></struct-specialization>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/is_unit_of_system.hpp">
<para>Check that a type is a unit in a specified system. </para><namespace name="boost">
<namespace name="units">
<struct name="is_unit_of_system"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="System"/>
    </template><inherit access="public">false_</inherit><purpose>Check that a type is a unit in a specified system. </purpose></struct><struct-specialization name="is_unit_of_system"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>System</template-arg></specialization><inherit access="public">true_</inherit></struct-specialization><struct-specialization name="is_unit_of_system"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>absolute&lt; unit&lt; Dim</template-arg><template-arg>System &gt; &gt;</template-arg><template-arg>System</template-arg></specialization><inherit access="public">true_</inherit></struct-specialization>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/lambda.hpp">
<para>Definitions to ease the usage of Boost.Units' quantity, unit, and absolute types in functors created with the Boost.Lambda library. </para><para><para>Torsten Maehne </para>
<para>2008-06-16</para>
Boost.Lambda's return type deduction system is extented to make use of Boost.Units' typeof_helper trait classes for Boost.Units' quantity, absolute, and unit template classes. </para><namespace name="boost">
<namespace name="lambda">
<struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>Y</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim, System&gt; * Y. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt;, Y &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>Y</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim, System&gt; / Y. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt;, Y &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>Y</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action Y * unit&lt;Dim, System&gt;. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; Y, <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>Y</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action Y / unit&lt;Dim, System&gt;. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; Y, <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="X"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit</template-arg><template-arg>X &gt;</template-arg><template-arg>X</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit, X&gt; * X. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit, X &gt;, X &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="X"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>X</template-arg><template-arg>boost::units::quantity&lt; Unit</template-arg><template-arg>X &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action X * quantity&lt;Unit, X&gt;. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; X, <classname>boost::units::quantity</classname>&lt; Unit, X &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="X"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit</template-arg><template-arg>X &gt;</template-arg><template-arg>X</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit, X&gt; / X. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit, X &gt;, X &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="X"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>X</template-arg><template-arg>boost::units::quantity&lt; Unit</template-arg><template-arg>X &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action X / quantity&lt;Unit, X&gt;. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; X, <classname>boost::units::quantity</classname>&lt; Unit, X &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="Unit2"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit2</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim1, System1&gt; * quantity&lt;Unit2, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim1, System1 &gt;, <classname>boost::units::quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="Unit2"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit2</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim1, System1&gt; / quantity&lt;Unit2, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim1, System1 &gt;, <classname>boost::units::quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit1"/>
      <template-type-parameter name="Y"/>
      <template-type-parameter name="System2"/>
      <template-type-parameter name="Dim2"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit1</template-arg><template-arg>Y &gt;</template-arg><template-arg>boost::units::unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit1, Y&gt; * unit&lt;Dim2, System2&gt;. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit1, Y &gt;, <classname>boost::units::unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit1"/>
      <template-type-parameter name="Y"/>
      <template-type-parameter name="System2"/>
      <template-type-parameter name="Dim2"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit1</template-arg><template-arg>Y &gt;</template-arg><template-arg>boost::units::unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit1, Y&gt; / unit&lt;Dim2, System2&gt;. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit1, Y &gt;, <classname>boost::units::unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_1"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>unary_arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action +quantity&lt;Unit, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::unary_plus_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit, Y &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_1"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>unary_arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action -quantity&lt;Unit, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::unary_minus_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit, Y &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit1"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Unit2"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit1</template-arg><template-arg>X &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit2</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit1, X&gt; + quantity&lt;Unit2, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::add_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit1, X &gt;, <classname>boost::units::quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>boost::units::quantity&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(System)</template-arg><template-arg>X &gt;</template-arg><template-arg>Y</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;dimensionless, X&gt; + Y. </para></description><typedef name="type"><type><classname>boost::units::add_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(System), X &gt;, Y &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>X</template-arg><template-arg>boost::units::quantity&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(System)</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action X + quantity&lt;dimensionless, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::add_typeof_helper</classname>&lt; X, <classname>boost::units::quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(System), Y &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit1"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Unit2"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit1</template-arg><template-arg>X &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit2</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit1, X&gt; - quantity&lt;Unit2, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::subtract_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit1, X &gt;, <classname>boost::units::quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>boost::units::quantity&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(System)</template-arg><template-arg>X &gt;</template-arg><template-arg>Y</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;dimensionless, X&gt; - Y. </para></description><typedef name="type"><type><classname>boost::units::subtract_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(System), X &gt;, Y &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>X</template-arg><template-arg>boost::units::quantity&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(System)</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action X - quantity&lt;dimensionless, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::subtract_typeof_helper</classname>&lt; X, <classname>boost::units::quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(System), Y &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit1"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Unit2"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit1</template-arg><template-arg>X &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit2</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit1, X&gt; * quantity&lt;Unit2, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit1, X &gt;, <classname>boost::units::quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Unit1"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Unit2"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit1</template-arg><template-arg>X &gt;</template-arg><template-arg>boost::units::quantity&lt; Unit2</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action quantity&lt;Unit1, X&gt; / quantity&lt;Unit2, Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; <classname>boost::units::quantity</classname>&lt; Unit1, X &gt;, <classname>boost::units::quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_1"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unary_arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action +unit&lt;Dim, System&gt;. </para></description><typedef name="type"><type><classname>boost::units::unary_plus_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_1"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unary_arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action -unit&lt;Dim, System&gt;. </para></description><typedef name="type"><type><classname>boost::units::unary_minus_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="Dim2"/>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="System2"/>
    </template><specialization><template-arg>arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>boost::units::unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim1, System1&gt; + unit&lt;Dim2, System2&gt;. </para></description><typedef name="type"><type><classname>boost::units::add_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim1, System1 &gt;, <classname>boost::units::unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="Dim2"/>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="System2"/>
    </template><specialization><template-arg>arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>boost::units::unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim1, System1&gt; - unit&lt;Dim2, System2&gt;. </para></description><typedef name="type"><type><classname>boost::units::subtract_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim1, System1 &gt;, <classname>boost::units::unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="Dim2"/>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="System2"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>boost::units::unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim1, System1&gt; * unit&lt;Dim2, System2&gt;. </para></description><typedef name="type"><type><classname>boost::units::multiply_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim1, System1 &gt;, <classname>boost::units::unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="Dim2"/>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="System2"/>
    </template><specialization><template-arg>arithmetic_action&lt; divide_action &gt;</template-arg><template-arg>boost::units::unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>boost::units::unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action unit&lt;Dim1, System1&gt; / unit&lt;Dim2, System2&gt;. </para></description><typedef name="type"><type><classname>boost::units::divide_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim1, System1 &gt;, <classname>boost::units::unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>boost::units::absolute&lt; Y &gt;</template-arg><template-arg>Y</template-arg></specialization><description><para>Partial specialization of return type trait for action absolute&lt;Y&gt; + Y. </para></description><typedef name="type"><type><classname>boost::units::absolute</classname>&lt; Y &gt;</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; plus_action &gt;</template-arg><template-arg>Y</template-arg><template-arg>boost::units::absolute&lt; Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action Y + absolute&lt;Y&gt;. </para></description><typedef name="type"><type><classname>boost::units::absolute</classname>&lt; Y &gt;</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>boost::units::absolute&lt; Y &gt;</template-arg><template-arg>Y</template-arg></specialization><description><para>Partial specialization of return type trait for action absolute&lt;Y&gt; - Y. </para></description><typedef name="type"><type><classname>boost::units::absolute</classname>&lt; Y &gt;</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>arithmetic_action&lt; minus_action &gt;</template-arg><template-arg>boost::units::absolute&lt; Y &gt;</template-arg><template-arg>boost::units::absolute&lt; Y &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action absolute&lt;Y&gt; - absolute&lt;Y&gt;. </para></description><typedef name="type"><type>Y</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="D"/>
      <template-type-parameter name="S"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>T</template-arg><template-arg>boost::units::absolute&lt; boost::units::unit&lt; D</template-arg><template-arg>S &gt; &gt;</template-arg></specialization><description><para>Partial specialization of return type trait for action T * absolute&lt;unit&lt;D, S&gt; &gt;. </para></description><typedef name="type"><type><classname>boost::units::quantity</classname>&lt; <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; D, S &gt; &gt;, T &gt;</type></typedef>
</struct-specialization><struct-specialization name="plain_return_type_2"><template>
      <template-type-parameter name="D"/>
      <template-type-parameter name="S"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>arithmetic_action&lt; multiply_action &gt;</template-arg><template-arg>boost::units::absolute&lt; boost::units::unit&lt; D</template-arg><template-arg>S &gt; &gt;</template-arg><template-arg>T</template-arg></specialization><description><para>Partial specialization of return type trait for action absolute&lt;unit&lt;D, S&gt; &gt; * T. </para></description><typedef name="type"><type><classname>boost::units::quantity</classname>&lt; <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; D, S &gt; &gt;, T &gt;</type></typedef>
</struct-specialization></namespace>
<namespace name="units">
<struct-specialization name="multiply_typeof_helper"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Arg"/>
    </template><specialization><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>boost::lambda::lambda_functor&lt; Arg &gt;</template-arg></specialization><typedef name="type"><type>boost::lambda::lambda_functor&lt; boost::lambda::lambda_functor_base&lt; boost::lambda::arithmetic_action&lt; boost::lambda::multiply_action &gt;, tuple&lt; typename boost::lambda::const_copy_argument&lt; const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type, boost::lambda::lambda_functor&lt; Arg &gt; &gt; &gt; &gt;</type></typedef>
</struct-specialization><struct-specialization name="divide_typeof_helper"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Arg"/>
    </template><specialization><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>boost::lambda::lambda_functor&lt; Arg &gt;</template-arg></specialization><typedef name="type"><type>boost::lambda::lambda_functor&lt; boost::lambda::lambda_functor_base&lt; boost::lambda::arithmetic_action&lt; boost::lambda::divide_action &gt;, tuple&lt; typename boost::lambda::const_copy_argument&lt; const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type, boost::lambda::lambda_functor&lt; Arg &gt; &gt; &gt; &gt;</type></typedef>
</struct-specialization><struct-specialization name="multiply_typeof_helper"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Arg"/>
    </template><specialization><template-arg>boost::lambda::lambda_functor&lt; Arg &gt;</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><typedef name="type"><type>boost::lambda::lambda_functor&lt; boost::lambda::lambda_functor_base&lt; boost::lambda::arithmetic_action&lt; boost::lambda::multiply_action &gt;, tuple&lt; boost::lambda::lambda_functor&lt; Arg &gt;, typename boost::lambda::const_copy_argument&lt; const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type &gt; &gt; &gt;</type></typedef>
</struct-specialization><struct-specialization name="divide_typeof_helper"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Arg"/>
    </template><specialization><template-arg>boost::lambda::lambda_functor&lt; Arg &gt;</template-arg><template-arg>boost::units::unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><typedef name="type"><type>boost::lambda::lambda_functor&lt; boost::lambda::lambda_functor_base&lt; boost::lambda::arithmetic_action&lt; boost::lambda::divide_action &gt;, tuple&lt; boost::lambda::lambda_functor&lt; Arg &gt;, typename boost::lambda::const_copy_argument&lt; const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type &gt; &gt; &gt;</type></typedef>
</struct-specialization><struct-specialization name="multiply_typeof_helper"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Arg"/>
    </template><specialization><template-arg>boost::lambda::lambda_functor&lt; Arg &gt;</template-arg><template-arg>boost::units::absolute&lt; boost::units::unit&lt; Dim</template-arg><template-arg>System &gt; &gt;</template-arg></specialization><typedef name="type"><type>boost::lambda::lambda_functor&lt; boost::lambda::lambda_functor_base&lt; boost::lambda::arithmetic_action&lt; boost::lambda::multiply_action &gt;, tuple&lt; boost::lambda::lambda_functor&lt; Arg &gt;, typename boost::lambda::const_copy_argument&lt; const <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt; &gt;::type &gt; &gt; &gt;</type></typedef>
</struct-specialization><struct-specialization name="multiply_typeof_helper"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="Arg"/>
    </template><specialization><template-arg>boost::units::absolute&lt; boost::units::unit&lt; Dim</template-arg><template-arg>System &gt; &gt;</template-arg><template-arg>boost::lambda::lambda_functor&lt; Arg &gt;</template-arg></specialization><typedef name="type"><type>boost::lambda::lambda_functor&lt; boost::lambda::lambda_functor_base&lt; boost::lambda::arithmetic_action&lt; boost::lambda::multiply_action &gt;, tuple&lt; typename boost::lambda::const_copy_argument&lt; const <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt; &gt;::type, boost::lambda::lambda_functor&lt; Arg &gt; &gt; &gt; &gt;</type></typedef>
</struct-specialization>








































<function name="operator*"><type>const <classname>multiply_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt;, boost::lambda::lambda_functor&lt; Arg &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Arg"/>
        </template><parameter name="a"><paramtype>const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const boost::lambda::lambda_functor&lt; Arg &gt; &amp;</paramtype></parameter><description><para>Disambiguating overload for action unit&lt;Dim, System&gt; * lambda_functor&lt;Arg&gt; based on &lt;boost/lambda/detail/operators.hpp&gt;. </para></description></function>
<function name="operator/"><type>const <classname>divide_typeof_helper</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt;, boost::lambda::lambda_functor&lt; Arg &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Arg"/>
        </template><parameter name="a"><paramtype>const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const boost::lambda::lambda_functor&lt; Arg &gt; &amp;</paramtype></parameter><description><para>Disambiguating overload for action unit&lt;Dim, System&gt; / lambda_functor&lt;Arg&gt; based on &lt;boost/lambda/detail/operators.hpp&gt;. </para></description></function>
<function name="operator*"><type>const <classname>multiply_typeof_helper</classname>&lt; boost::lambda::lambda_functor&lt; Arg &gt;, <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Arg"/>
        </template><parameter name="a"><paramtype>const boost::lambda::lambda_functor&lt; Arg &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><description><para>Disambiguating overload for action lambda_functor&lt;Arg&gt; * unit&lt;Dim, System&gt; based on &lt;boost/lambda/detail/operators.hpp&gt;. </para></description></function>
<function name="operator/"><type>const <classname>divide_typeof_helper</classname>&lt; boost::lambda::lambda_functor&lt; Arg &gt;, <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Arg"/>
        </template><parameter name="a"><paramtype>const boost::lambda::lambda_functor&lt; Arg &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>boost::units::unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><description><para>Disambiguating overload for action lambda_functor&lt;Arg&gt; / unit&lt;Dim, System&gt; based on &lt;boost/lambda/detail/operators.hpp&gt;. </para></description></function>
<function name="operator*"><type>const <classname>multiply_typeof_helper</classname>&lt; boost::lambda::lambda_functor&lt; Arg &gt;, <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Arg"/>
        </template><parameter name="a"><paramtype>const boost::lambda::lambda_functor&lt; Arg &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt; &amp;</paramtype></parameter><description><para>Disambiguating overload for action lambda_functor&lt;Arg&gt; * absolute&lt;unit&lt;Dim, System&gt; &gt; based on &lt;boost/lambda/detail/operators.hpp&gt;. </para></description></function>
<function name="operator*"><type>const <classname>multiply_typeof_helper</classname>&lt; <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt;, boost::lambda::lambda_functor&lt; Arg &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Arg"/>
        </template><parameter name="a"><paramtype>const <classname>boost::units::absolute</classname>&lt; <classname>boost::units::unit</classname>&lt; Dim, System &gt; &gt; &amp;</paramtype></parameter><parameter name="b"><paramtype>const boost::lambda::lambda_functor&lt; Arg &gt; &amp;</paramtype></parameter><description><para>Disambiguating overload for action absolute&lt;unit&lt;Dim, System&gt; &gt; * lambda_functor&lt;Arg&gt; based on &lt;boost/lambda/detail/operators.hpp&gt;. </para></description></function>















































































</namespace>
</namespace>
</header>
<header name="boost/units/limits.hpp">
<para>specialize std::numeric_limits for units. </para><namespace name="std">
<class-specialization name="numeric_limits"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>::boost::units::quantity&lt; Unit</template-arg><template-arg>T &gt;</template-arg></specialization><typedef name="quantity_type"><type>::<classname>boost::units::quantity</classname>&lt; Unit, T &gt;</type></typedef>
<data-member name="is_specialized"><type>BOOST_STATIC_CONSTEXPR bool</type></data-member>
<data-member name="digits"><type>BOOST_STATIC_CONSTEXPR int</type></data-member>
<data-member name="digits10"><type>BOOST_STATIC_CONSTEXPR int</type></data-member>
<data-member name="max_digits10"><type>BOOST_STATIC_CONSTEXPR int</type></data-member>
<data-member name="is_signed"><type>BOOST_STATIC_CONSTEXPR bool</type></data-member>
<data-member name="is_integer"><type>BOOST_STATIC_CONSTEXPR bool</type></data-member>
<data-member name="is_exact"><type>BOOST_STATIC_CONSTEXPR bool</type></data-member>
<data-member name="radix"><type>BOOST_STATIC_CONSTEXPR int</type></data-member>
<data-member name="min_exponent"><type>BOOST_STATIC_CONSTEXPR int</type></data-member>
<data-member name="min_exponent10"><type>BOOST_STATIC_CONSTEXPR int</type></data-member>
<data-member name="max_exponent"><type>BOOST_STATIC_CONSTEXPR int</type></data-member>
<data-member name="max_exponent10"><type>BOOST_STATIC_CONSTEXPR int</type></data-member>
<data-member name="has_infinity"><type>BOOST_STATIC_CONSTEXPR bool</type></data-member>
<data-member name="has_quiet_NaN"><type>BOOST_STATIC_CONSTEXPR bool</type></data-member>
<data-member name="has_signaling_NaN"><type>BOOST_STATIC_CONSTEXPR bool</type></data-member>
<data-member name="has_denorm_loss"><type>BOOST_STATIC_CONSTEXPR bool</type></data-member>
<data-member name="is_iec559"><type>BOOST_STATIC_CONSTEXPR bool</type></data-member>
<data-member name="is_bounded"><type>BOOST_STATIC_CONSTEXPR bool</type></data-member>
<data-member name="is_modulo"><type>BOOST_STATIC_CONSTEXPR bool</type></data-member>
<data-member name="traps"><type>BOOST_STATIC_CONSTEXPR bool</type></data-member>
<data-member name="tinyness_before"><type>BOOST_STATIC_CONSTEXPR bool</type></data-member>
<data-member name="has_denorm"><type>BOOST_STATIC_CONSTEXPR float_denorm_style</type></data-member>
<data-member name="round_style"><type>BOOST_STATIC_CONSTEXPR float_round_style</type></data-member>
<method-group name="public static functions">
<method name="min" specifiers="static"><type>BOOST_CONSTEXPR quantity_type()</type></method>
<method name="max" specifiers="static"><type>BOOST_CONSTEXPR quantity_type()</type></method>
<method name="lowest" specifiers="static"><type>BOOST_CONSTEXPR quantity_type()</type></method>
<method name="epsilon" specifiers="static"><type>BOOST_CONSTEXPR quantity_type</type></method>
<method name="round_error" specifiers="static"><type>BOOST_CONSTEXPR quantity_type</type></method>
<method name="infinity" specifiers="static"><type>BOOST_CONSTEXPR quantity_type</type></method>
<method name="quiet_NaN" specifiers="static"><type>BOOST_CONSTEXPR quantity_type</type></method>
<method name="signaling_NaN" specifiers="static"><type>BOOST_CONSTEXPR quantity_type</type></method>
<method name="denorm_min" specifiers="static"><type>BOOST_CONSTEXPR quantity_type</type></method>
</method-group>
</class-specialization></namespace>
</header>
<header name="boost/units/make_scaled_unit.hpp">
<namespace name="boost">
<namespace name="units">
<struct name="make_scaled_unit"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Scale"/>
    </template><typedef name="type"><type><classname>make_scaled_unit</classname>&lt; typename <classname>reduce_unit</classname>&lt; Unit &gt;::type, Scale &gt;::type</type></typedef>
</struct><struct-specialization name="make_scaled_unit"><template>
      <template-type-parameter name="Dimension"/>
      <template-type-parameter name="UnitList"/>
      <template-type-parameter name="OldScale"/>
      <template-type-parameter name="Scale"/>
    </template><specialization><template-arg>unit&lt; Dimension</template-arg><template-arg>heterogeneous_system&lt; heterogeneous_system_impl&lt; UnitList</template-arg><template-arg>Dimension</template-arg><template-arg>OldScale &gt; &gt; &gt;</template-arg><template-arg>Scale</template-arg></specialization><typedef name="type"><type><classname>unit</classname>&lt; Dimension, <classname>heterogeneous_system</classname>&lt; <classname>heterogeneous_system_impl</classname>&lt; UnitList, Dimension, typename mpl::times&lt; OldScale, list&lt; scale_list_dim&lt; Scale &gt;, <classname>dimensionless_type</classname> &gt; &gt;::type &gt; &gt; &gt;</type></typedef>
</struct-specialization><struct-specialization name="make_scaled_unit"><template>
      <template-type-parameter name="Dimension"/>
      <template-type-parameter name="UnitList"/>
      <template-type-parameter name="OldScale"/>
      <template-nontype-parameter name="Base"><type>long</type></template-nontype-parameter>
    </template><specialization><template-arg>unit&lt; Dimension</template-arg><template-arg>heterogeneous_system&lt; heterogeneous_system_impl&lt; UnitList</template-arg><template-arg>Dimension</template-arg><template-arg>OldScale &gt; &gt; &gt;</template-arg><template-arg>scale&lt; Base</template-arg><template-arg>static_rational&lt; 0 &gt; &gt;</template-arg></specialization><typedef name="type"><type><classname>unit</classname>&lt; Dimension, <classname>heterogeneous_system</classname>&lt; <classname>heterogeneous_system_impl</classname>&lt; UnitList, Dimension, OldScale &gt; &gt; &gt;</type></typedef>
</struct-specialization>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/make_system.hpp">
<para>Metafunction returning a homogeneous system that can represent any combination of the base units. </para><para>Metafunction make_system returning a homogeneous system that can represent any combination of the base units. There must be no way to represent any of the base units in terms of the others. make_system&lt;foot_base_unit, meter_base_unit&gt;::type is not allowed, for example. </para><namespace name="boost">
<namespace name="units">
<struct name="make_system"><template>
      <template-type-parameter name="BaseUnit0"/>
      <template-type-parameter name="BaseUnit1"/>
      <template-type-parameter name="BaseUnit2"/>
      <template-nontype-parameter name=""><type>...</type></template-nontype-parameter>
      <template-type-parameter name="BaseUnitN"/>
    </template><description><para>Metafunction returning a homogeneous system that can represent any combination of the base units. There must be no way to represent any of the base units in terms of the others. make_system&lt;foot_base_unit, meter_base_unit&gt;::type is not allowed, for example. </para></description><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef>
</struct>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/operators.hpp">
<para>Compile time operators and typeof helper classes. </para><para>These operators declare the compile-time operators needed to support dimensional analysis algebra. They require the use of Boost.Typeof, emulation or native. Typeof helper classes define result type for heterogeneous operators on value types. These must be defined through specialization for powers and roots. </para><namespace name="boost">
<namespace name="units">
<struct name="unary_plus_typeof_helper"><template>
      <template-type-parameter name="X"/>
    </template><method-group name="public member functions">
<method name="typeof"><type>typedef</type><parameter name=""><paramtype>(+typeof_::make&lt; X &gt;())</paramtype></parameter></method>
</method-group>
</struct><struct name="unary_minus_typeof_helper"><template>
      <template-type-parameter name="X"/>
    </template><method-group name="public member functions">
<method name="typeof"><type>typedef</type><parameter name=""><paramtype>(-typeof_::make&lt; X &gt;())</paramtype></parameter></method>
</method-group>
</struct><struct name="add_typeof_helper"><template>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><method-group name="public member functions">
<method name="typeof"><type>typedef</type><parameter name=""><paramtype>(typeof_::make&lt; X &gt;()+typeof_::make&lt; Y &gt;())</paramtype></parameter></method>
</method-group>
</struct><struct name="subtract_typeof_helper"><template>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><method-group name="public member functions">
<method name="typeof"><type>typedef</type><parameter name=""><paramtype>(typeof_::make&lt; X &gt;()-typeof_::make&lt; Y &gt;())</paramtype></parameter></method>
</method-group>
</struct><struct name="multiply_typeof_helper"><template>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><method-group name="public member functions">
<method name="typeof"><type>typedef</type><parameter name=""><paramtype>(typeof_::make&lt; X &gt;()*typeof_::make&lt; Y &gt;())</paramtype></parameter></method>
</method-group>
</struct><struct name="divide_typeof_helper"><template>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><method-group name="public member functions">
<method name="typeof"><type>typedef</type><parameter name=""><paramtype>(typeof_::make&lt; X &gt;()/typeof_::make&lt; Y &gt;())</paramtype></parameter></method>
</method-group>
</struct><struct name="power_typeof_helper"><template>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><description><para>A helper used by <computeroutput>pow</computeroutput> to raise a runtime object to a compile time known exponent. This template is intended to be specialized. All specializations must conform to the interface shown here. <computeroutput>Exponent</computeroutput> will be either the exponent passed to <computeroutput>pow</computeroutput> or <computeroutput>static_rational&lt;N&gt;</computeroutput> for and integer argument, N. </para></description><typedef name="type"><purpose>specifies the result type </purpose><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="public static functions">
<method name="value" specifiers="static"><type>BOOST_CONSTEXPR type</type><parameter name="base"><paramtype>const BaseType &amp;</paramtype></parameter><purpose>Carries out the runtime calculation. </purpose></method>
</method-group>
</struct><struct name="root_typeof_helper"><template>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><description><para>A helper used by <computeroutput>root</computeroutput> to take a root of a runtime object using a compile time known index. This template is intended to be specialized. All specializations must conform to the interface shown here. <computeroutput>Index</computeroutput> will be either the type passed to <computeroutput>pow</computeroutput> or <computeroutput>static_rational&lt;N&gt;</computeroutput> for and integer argument, N. </para></description><typedef name="type"><purpose>specifies the result type </purpose><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="public static functions">
<method name="value" specifiers="static"><type>BOOST_CONSTEXPR type</type><parameter name="base"><paramtype>const Radicand &amp;</paramtype></parameter><purpose>Carries out the runtime calculation. </purpose></method>
</method-group>
</struct>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/pow.hpp">
<para>Raise values to exponents known at compile-time. </para><namespace name="boost">
<namespace name="units">





































<function name="pow"><type>BOOST_CONSTEXPR <classname>power_typeof_helper</classname>&lt; Y, Rat &gt;::type</type><template>
          <template-type-parameter name="Rat"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="x"><paramtype>const Y &amp;</paramtype></parameter><purpose>raise a value to a <computeroutput><classname alt="boost::units::static_rational">static_rational</classname></computeroutput> power. </purpose></function>
<function name="pow"><type>BOOST_CONSTEXPR <classname>power_typeof_helper</classname>&lt; Y, <classname>static_rational</classname>&lt; N &gt; &gt;::type</type><template>
          <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Y"/>
        </template><parameter name="x"><paramtype>const Y &amp;</paramtype></parameter><purpose>raise a value to an integer power. </purpose></function>
<function name="root"><type>BOOST_CONSTEXPR <classname>root_typeof_helper</classname>&lt; Y, Rat &gt;::type</type><template>
          <template-type-parameter name="Rat"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="x"><paramtype>const Y &amp;</paramtype></parameter><purpose>take the <computeroutput><classname alt="boost::units::static_rational">static_rational</classname></computeroutput> root of a value. </purpose></function>
<function name="root"><type>BOOST_CONSTEXPR <classname>root_typeof_helper</classname>&lt; Y, <classname>static_rational</classname>&lt; N &gt; &gt;::type</type><template>
          <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Y"/>
        </template><parameter name="x"><paramtype>const Y &amp;</paramtype></parameter><purpose>take the integer root of a value. </purpose></function>





















































































</namespace>
</namespace>
</header>
<header name="boost/units/quantity.hpp">
<namespace name="boost">
<namespace name="units">
<class name="quantity"><template>
      <template-type-parameter name="Unit"/>
      <template-type-parameter name="Y"/>
    </template><purpose>class declaration </purpose><typedef name="this_type"><type><classname>quantity</classname>&lt; Unit, Y &gt;</type></typedef>
<typedef name="value_type"><type>Y</type></typedef>
<typedef name="unit_type"><type>Unit</type></typedef>
<method-group name="private member functions">
<method name="BOOST_MPL_ASSERT_NOT"><type/><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype></parameter></method>
</method-group>
<method-group name="public member functions">
<method name="value" cv="const"><type>BOOST_CONSTEXPR const value_type &amp;</type><purpose>constant accessor to value </purpose><description><para>can add a quantity of the same type if add_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </para></description></method>
<method name="operator+="><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter><purpose>can subtract a quantity of the same type if subtract_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </purpose></method>
<method name="operator-="><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter></method>
<method name="operator*="><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter></method>
<method name="operator/="><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter><purpose>can multiply a quantity by a scalar value_type if multiply_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </purpose></method>
<method name="operator*="><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><parameter name="source"><paramtype>const value_type &amp;</paramtype></parameter><purpose>can divide a quantity by a scalar value_type if divide_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </purpose></method>
<method name="operator/="><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><parameter name="source"><paramtype>const value_type &amp;</paramtype></parameter></method>
</method-group>
<constructor/>
<constructor><parameter name=""><paramtype>unspecified_null_pointer_constant_type</paramtype></parameter></constructor>
<constructor><parameter name="source"><paramtype>const this_type &amp;</paramtype></parameter></constructor>
<copy-assignment><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><parameter name="source"><paramtype>const this_type &amp;</paramtype></parameter></copy-assignment>
<constructor><template>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit, YY &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between value types is allowed if allowed for value types themselves </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit, YY &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between value types is not allowed if not allowed for value types themselves </purpose></constructor>
<copy-assignment><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><template>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit, YY &gt; &amp;</paramtype></parameter><purpose>implicit assignment between value types is allowed if allowed for value types themselves </purpose></copy-assignment>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>explicit conversion between different unit systems is allowed if implicit conversion is disallowed </purpose></constructor>
<constructor><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between different unit systems is allowed if each fundamental dimension is implicitly convertible </purpose></constructor>
<copy-assignment><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><template>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; Unit2, YY &gt; &amp;</paramtype></parameter><purpose>implicit assignment between different unit systems is allowed if each fundamental dimension is implicitly convertible </purpose></copy-assignment>
<method-group name="public static functions">
<method name="from_value" specifiers="static"><type>BOOST_CONSTEXPR this_type</type><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter><purpose>Construct quantity directly from <computeroutput>value_type</computeroutput> (potentially dangerous). </purpose></method>
</method-group>
<method-group name="protected member functions">
</method-group>
<constructor specifiers="explicit"><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></constructor>
</class><class-specialization name="quantity"><template>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>BOOST_UNITS_DIMENSIONLESS_UNIT(System)</template-arg><template-arg>Y</template-arg></specialization><description><para>Specialization for dimensionless quantities. Implicit conversions between unit systems are allowed because all dimensionless quantities are equivalent. Implicit construction and assignment from and conversion to <computeroutput>value_type</computeroutput> is also allowed. </para></description><typedef name="this_type"><type><classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, System &gt;, Y &gt;</type></typedef>
<typedef name="value_type"><type>Y</type></typedef>
<typedef name="system_type"><type>System</type></typedef>
<typedef name="dimension_type"><type><classname>dimensionless_type</classname></type></typedef>
<typedef name="unit_type"><type><classname>unit</classname>&lt; dimension_type, system_type &gt;</type></typedef>
<method-group name="public member functions">
<method name="operator value_type" cv="const"><type>BOOST_CONSTEXPR</type><purpose>implicit conversion to <computeroutput>value_type</computeroutput> is allowed </purpose></method>
<method name="value" cv="const"><type>BOOST_CONSTEXPR const value_type &amp;</type><purpose>constant accessor to value </purpose><description><para>can add a quantity of the same type if add_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </para></description></method>
<method name="operator+="><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><parameter name="source"><paramtype>const this_type &amp;</paramtype></parameter><purpose>can subtract a quantity of the same type if subtract_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </purpose></method>
<method name="operator-="><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><parameter name="source"><paramtype>const this_type &amp;</paramtype></parameter><purpose>can multiply a quantity by a scalar value_type if multiply_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </purpose></method>
<method name="operator*="><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter><purpose>can divide a quantity by a scalar value_type if divide_typeof_helper&lt;value_type,value_type&gt;::type is convertible to value_type </purpose></method>
<method name="operator/="><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter></method>
</method-group>
<constructor/>
<constructor><parameter name="val"><paramtype>value_type</paramtype></parameter><purpose>construction from raw <computeroutput>value_type</computeroutput> is allowed </purpose></constructor>
<constructor><parameter name="source"><paramtype>const this_type &amp;</paramtype></parameter></constructor>
<copy-assignment><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><parameter name="source"><paramtype>const this_type &amp;</paramtype></parameter></copy-assignment>
<constructor><template>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; dimension_type, system_type &gt;, YY &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between value types is allowed if allowed for value types themselves </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; dimension_type, system_type &gt;, YY &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between value types is not allowed if not allowed for value types themselves </purpose></constructor>
<copy-assignment><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><template>
          <template-type-parameter name="YY"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; dimension_type, system_type &gt;, YY &gt; &amp;</paramtype></parameter><purpose>implicit assignment between value types is allowed if allowed for value types themselves </purpose></copy-assignment>
<constructor><template>
          <template-type-parameter name="System2"/>
          <template-type-parameter name="Y2"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, System2 &gt;, Y2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between different unit systems is allowed </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="System2"/>
          <template-type-parameter name="Y2"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, System2 &gt;, Y2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><purpose>implicit conversion between different unit systems is allowed </purpose></constructor>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="System2"/>
          <template-type-parameter name="Y2"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; <classname>unit</classname>&lt; <classname>dimensionless_type</classname>, System2 &gt;, Y2 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>conversion between different unit systems is explicit when the units are not equivalent. </para></description></constructor>
<copy-assignment><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><template>
          <template-type-parameter name="System2"/>
        </template><parameter name="source"><paramtype>const <classname>quantity</classname>&lt; BOOST_UNITS_DIMENSIONLESS_UNIT(System2), Y &gt; &amp;</paramtype></parameter><purpose>implicit assignment between different unit systems is allowed </purpose></copy-assignment>
<method-group name="public static functions">
<method name="from_value" specifiers="static"><type>BOOST_CONSTEXPR this_type</type><parameter name="val"><paramtype>const value_type &amp;</paramtype></parameter><purpose>Construct quantity directly from <computeroutput>value_type</computeroutput>. </purpose></method>
</method-group>
</class-specialization><struct-specialization name="add_typeof_helper"><template>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="Dim2"/>
      <template-type-parameter name="System2"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>X &gt;</template-arg><template-arg>quantity&lt; unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg><template-arg>Y &gt;</template-arg></specialization><description><para>for sun CC we need to invoke SFINAE at the top level, otherwise it will silently return int. </para></description></struct-specialization><struct-specialization name="add_typeof_helper"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>X &gt;</template-arg><template-arg>quantity&lt; unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>Y &gt;</template-arg></specialization><typedef name="value_type"><type><classname>add_typeof_helper</classname>&lt; X, Y &gt;::type</type></typedef>
<typedef name="unit_type"><type><classname>unit</classname>&lt; Dim, System &gt;</type></typedef>
<typedef name="type"><type><classname>quantity</classname>&lt; unit_type, value_type &gt;</type></typedef>
</struct-specialization><struct-specialization name="subtract_typeof_helper"><template>
      <template-type-parameter name="Dim1"/>
      <template-type-parameter name="System1"/>
      <template-type-parameter name="Dim2"/>
      <template-type-parameter name="System2"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; unit&lt; Dim1</template-arg><template-arg>System1 &gt;</template-arg><template-arg>X &gt;</template-arg><template-arg>quantity&lt; unit&lt; Dim2</template-arg><template-arg>System2 &gt;</template-arg><template-arg>Y &gt;</template-arg></specialization></struct-specialization><struct-specialization name="subtract_typeof_helper"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
      <template-type-parameter name="X"/>
      <template-type-parameter name="Y"/>
    </template><specialization><template-arg>quantity&lt; unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>X &gt;</template-arg><template-arg>quantity&lt; unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>Y &gt;</template-arg></specialization><typedef name="value_type"><type><classname>subtract_typeof_helper</classname>&lt; X, Y &gt;::type</type></typedef>
<typedef name="unit_type"><type><classname>unit</classname>&lt; Dim, System &gt;</type></typedef>
<typedef name="type"><type><classname>quantity</classname>&lt; unit_type, value_type &gt;</type></typedef>
</struct-specialization>










<function name="quantity_cast"><type>BOOST_CONSTEXPR X</type><template>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="source"><paramtype>Y &amp;</paramtype></parameter><purpose>quantity_cast provides mutating access to underlying quantity value_type </purpose></function>
<function name="quantity_cast"><type>BOOST_CONSTEXPR X</type><template>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="source"><paramtype>const Y &amp;</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype><classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype><classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>swap quantities </purpose></function>
<function name="operator/"><type>BOOST_CONSTEXPR <classname>divide_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim, System &gt;, Y &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Y"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const Y &amp;</paramtype></parameter><purpose>runtime unit divided by scalar </purpose></function>
<function name="operator*"><type>BOOST_CONSTEXPR <classname>multiply_typeof_helper</classname>&lt; Y, <classname>unit</classname>&lt; Dim, System &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const Y &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><purpose>runtime scalar times unit </purpose></function>
<function name="operator/"><type>BOOST_CONSTEXPR <classname>divide_typeof_helper</classname>&lt; Y, <classname>unit</classname>&lt; Dim, System &gt; &gt;::type</type><template>
          <template-type-parameter name="System"/>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const Y &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><purpose>runtime scalar divided by unit </purpose></function>
<function name="operator*"><type>BOOST_CONSTEXPR <classname>multiply_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, X &gt;, X &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const X &amp;</paramtype></parameter><purpose>runtime quantity times scalar </purpose></function>
<function name="operator*"><type>BOOST_CONSTEXPR <classname>multiply_typeof_helper</classname>&lt; X, <classname>quantity</classname>&lt; Unit, X &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
        </template><parameter name="lhs"><paramtype>const X &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><purpose>runtime scalar times quantity </purpose></function>
<function name="operator/"><type>BOOST_CONSTEXPR <classname>divide_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, X &gt;, X &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const X &amp;</paramtype></parameter><purpose>runtime quantity divided by scalar </purpose></function>
<function name="operator/"><type>BOOST_CONSTEXPR <classname>divide_typeof_helper</classname>&lt; X, <classname>quantity</classname>&lt; Unit, X &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
        </template><parameter name="lhs"><paramtype>const X &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><purpose>runtime scalar divided by quantity </purpose></function>
<function name="operator*"><type>BOOST_CONSTEXPR <classname>multiply_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim1, System1 &gt;, <classname>quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="Y"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit2, Y &gt; &amp;</paramtype></parameter><purpose>runtime unit times quantity </purpose></function>
<function name="operator/"><type>BOOST_CONSTEXPR <classname>divide_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim1, System1 &gt;, <classname>quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="Y"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit2, Y &gt; &amp;</paramtype></parameter><purpose>runtime unit divided by quantity </purpose></function>
<function name="operator*"><type>BOOST_CONSTEXPR <classname>multiply_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit1, Y &gt;, <classname>unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit1"/>
          <template-type-parameter name="System2"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit1, Y &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>runtime quantity times unit </purpose></function>
<function name="operator/"><type>BOOST_CONSTEXPR <classname>divide_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit1, Y &gt;, <classname>unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit1"/>
          <template-type-parameter name="System2"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit1, Y &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>runtime quantity divided by unit </purpose></function>
<function name="operator+"><type>BOOST_CONSTEXPR <classname>unary_plus_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime unary plus quantity </purpose></function>
<function name="operator-"><type>BOOST_CONSTEXPR <classname>unary_minus_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime unary minus quantity </purpose></function>
<function name="operator+"><type>BOOST_CONSTEXPR <classname>add_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit1, X &gt;, <classname>quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit1"/>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit1, X &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit2, Y &gt; &amp;</paramtype></parameter><purpose>runtime quantity plus quantity </purpose></function>
<function name="operator-"><type>BOOST_CONSTEXPR <classname>subtract_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit1, X &gt;, <classname>quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit1"/>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit1, X &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit2, Y &gt; &amp;</paramtype></parameter><purpose>runtime quantity minus quantity </purpose></function>
<function name="operator*"><type>BOOST_CONSTEXPR <classname>multiply_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit1, X &gt;, <classname>quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit1"/>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit1, X &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit2, Y &gt; &amp;</paramtype></parameter><purpose>runtime quantity times quantity </purpose></function>
<function name="operator/"><type>BOOST_CONSTEXPR <classname>divide_typeof_helper</classname>&lt; <classname>quantity</classname>&lt; Unit1, X &gt;, <classname>quantity</classname>&lt; Unit2, Y &gt; &gt;::type</type><template>
          <template-type-parameter name="Unit1"/>
          <template-type-parameter name="Unit2"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="lhs"><paramtype>const <classname>quantity</classname>&lt; Unit1, X &gt; &amp;</paramtype></parameter><parameter name="rhs"><paramtype>const <classname>quantity</classname>&lt; Unit2, Y &gt; &amp;</paramtype></parameter><purpose>runtime quantity divided by quantity </purpose></function>
<function name="operator=="><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val1"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="val2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime operator== </purpose></function>
<function name="operator!="><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val1"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="val2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime operator!= </purpose></function>
<function name="operator&lt;"><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val1"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="val2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime operator&lt; </purpose></function>
<function name="operator&lt;="><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val1"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="val2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime operator&lt;= </purpose></function>
<function name="operator&gt;"><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val1"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="val2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime operator&gt; </purpose></function>
<function name="operator&gt;="><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Unit"/>
          <template-type-parameter name="X"/>
          <template-type-parameter name="Y"/>
        </template><parameter name="val1"><paramtype>const <classname>quantity</classname>&lt; Unit, X &gt; &amp;</paramtype></parameter><parameter name="val2"><paramtype>const <classname>quantity</classname>&lt; Unit, Y &gt; &amp;</paramtype></parameter><purpose>runtime operator&gt;= </purpose></function>

























































































</namespace>
</namespace>
</header>
<header name="boost/units/reduce_unit.hpp">
<para>Returns a unique type for every unit. </para><namespace name="boost">
<namespace name="units">
<struct name="reduce_unit"><template>
      <template-type-parameter name="Unit"/>
    </template><purpose>Returns a unique type for every unit. </purpose><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef>
</struct>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/scale.hpp">
<para>10^3 Engineering &amp; 2^10 binary scaling factors for autoprefixing. </para><namespace name="boost">
<namespace name="units">
<struct name="scale"><template>
      <template-nontype-parameter name="Base"><type>long</type></template-nontype-parameter>
      <template-type-parameter name="Exponent"/>
    </template><description><para>class representing a scaling factor such as 10^3 The exponent must be a static rational. </para></description><typedef name="exponent"><type>Exponent</type></typedef>
<typedef name="value_type"><type>double</type></typedef>
<data-member name="base"><type>BOOST_STATIC_CONSTEXPR long</type></data-member>
<method-group name="public static functions">
<method name="value" specifiers="static"><type>BOOST_CONSTEXPR value_type</type></method>
</method-group>
</struct>








<function name="symbol_string"><type>std::string</type><template>
          <template-nontype-parameter name="Base"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Exponent"/>
        </template><parameter name=""><paramtype>const <classname>scale</classname>&lt; Base, Exponent &gt; &amp;</paramtype></parameter></function>
<function name="name_string"><type>std::string</type><template>
          <template-nontype-parameter name="Base"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Exponent"/>
        </template><parameter name=""><paramtype>const <classname>scale</classname>&lt; Base, Exponent &gt; &amp;</paramtype></parameter></function>



















































































































</namespace>
</namespace>
</header>
<header name="boost/units/scaled_base_unit.hpp">
<namespace name="boost">
<namespace name="units">
<struct name="heterogeneous_system"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">T</inherit><description><para>A system that can represent any possible combination of units at the expense of not preserving information about how it was created. Do not create specializations of this template directly. Instead use <computeroutput><classname alt="boost::units::reduce_unit">reduce_unit</classname></computeroutput> and <computeroutput>base_unit&lt;...&gt;::unit_type</computeroutput>. </para></description></struct><struct name="base_unit_info"><template>
      <template-type-parameter name="T"/>
    </template><purpose>traits template for unit names. </purpose><method-group name="public static functions">
<method name="name" specifiers="static"><type>std::string</type><purpose>The full name of the unit (returns BaseUnit::name() by default) </purpose></method>
<method name="symbol" specifiers="static"><type>std::string</type><purpose>The symbol for the base unit (Returns BaseUnit::symbol() by default) </purpose><description><para>
</para></description><returns><para>BaseUnit::symbol(), for example "m" </para></returns></method>
</method-group>
</struct><struct name="scaled_base_unit"><template>
      <template-type-parameter name="S"/>
      <template-type-parameter name="Scale"/>
    </template><typedef name="type"><type><classname>scaled_base_unit</classname></type></typedef>
<typedef name="tag"><type><classname>scaled_base_unit_tag</classname></type></typedef>
<typedef name="system_type"><type>S</type></typedef>
<typedef name="scale_type"><type>Scale</type></typedef>
<typedef name="dimension_type"><type>S::dimension_type</type></typedef>
<typedef name="unit_type"><type><emphasis>unspecified</emphasis></type></typedef>
<method-group name="public static functions">
<method name="symbol" specifiers="static"><type>std::string</type></method>
<method name="name" specifiers="static"><type>std::string</type></method>
</method-group>
</struct>





























































































































</namespace>
</namespace>
</header>
<header name="boost/units/static_constant.hpp">
<macro name="BOOST_UNITS_STATIC_CONSTANT" kind="functionlike"><macro-parameter name="name"/><macro-parameter name="type"/><description><para>A convenience macro that allows definition of static constants in headers in an ODR-safe way. </para></description></macro>
</header>
<header name="boost/units/static_rational.hpp">
<para>Compile-time rational numbers and operators. </para><namespace name="boost">
<namespace name="units">
<struct name="static_abs"><template>
      <template-nontype-parameter name="Value"><type>integer_type</type></template-nontype-parameter>
    </template><purpose>Compile time absolute value. </purpose><method-group name="public member functions">
<method name="BOOST_STATIC_CONSTANT"><type/><parameter name=""><paramtype>integer_type</paramtype></parameter></method>
</method-group>
</struct><class name="static_rational"><template>
      <template-nontype-parameter name="N"><type>integer_type</type></template-nontype-parameter>
      <template-nontype-parameter name="D"><type>integer_type</type><default>1</default></template-nontype-parameter>
    </template><description><para>This is an implementation of a compile time rational number, where <computeroutput>static_rational&lt;N,D&gt;</computeroutput> represents a rational number with numerator <computeroutput>N</computeroutput> and denominator <computeroutput>D</computeroutput>. Because of the potential for ambiguity arising from multiple equivalent values of <computeroutput><classname alt="boost::units::static_rational">static_rational</classname></computeroutput> (e.g. <computeroutput>static_rational&lt;6,2&gt;==static_rational&lt;3&gt;</computeroutput>), static rationals should always be accessed through <computeroutput>static_rational&lt;N,D&gt;::type</computeroutput>. Template specialization prevents instantiation of zero denominators (i.e. <computeroutput>static_rational&lt;N,0&gt;</computeroutput>). The following compile-time arithmetic operators are provided for <classname alt="boost::units::static_rational">static_rational</classname> variables only (no operators are defined between long and <classname alt="boost::units::static_rational">static_rational</classname>):<itemizedlist>
<listitem><para><computeroutput>mpl::negate</computeroutput> </para></listitem><listitem><para><computeroutput>mpl::plus</computeroutput> </para></listitem><listitem><para><computeroutput>mpl::minus</computeroutput> </para></listitem><listitem><para><computeroutput>mpl::times</computeroutput> </para></listitem><listitem><para><computeroutput>mpl::divides</computeroutput> </para></listitem></itemizedlist>
</para><para>Neither <computeroutput><classname alt="boost::units::static_power">static_power</classname></computeroutput> nor <computeroutput><classname alt="boost::units::static_root">static_root</classname></computeroutput> are defined for <computeroutput><classname alt="boost::units::static_rational">static_rational</classname></computeroutput>. This is because template types may not be floating point values, while powers and roots of rational numbers can produce floating point values. </para></description><typedef name="tag"><type><emphasis>unspecified</emphasis></type></typedef>
<typedef name="type"><purpose>static_rational&lt;N,D&gt; reduced by GCD </purpose><type><classname>static_rational</classname>&lt; Numerator, Denominator &gt;</type></typedef>
<data-member name="Numerator"><type>BOOST_STATIC_CONSTEXPR integer_type</type></data-member>
<data-member name="Denominator"><type>BOOST_STATIC_CONSTEXPR integer_type</type></data-member>
<method-group name="public static functions">
<method name="numerator" specifiers="static"><type>BOOST_CONSTEXPR integer_type</type></method>
<method name="denominator" specifiers="static"><type>BOOST_CONSTEXPR integer_type</type></method>
</method-group>
<method-group name="public member functions">
</method-group>
<constructor/>
</class><typedef name="integer_type"><type>long</type></typedef>








<function name="value"><type>BOOST_CONSTEXPR <classname>divide_typeof_helper</classname>&lt; T, T &gt;::type</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="N"><type>integer_type</type></template-nontype-parameter>
          <template-nontype-parameter name="D"><type>integer_type</type></template-nontype-parameter>
        </template><parameter name=""><paramtype>const <classname>static_rational</classname>&lt; N, D &gt; &amp;</paramtype></parameter><purpose>get decimal value of <computeroutput><classname alt="boost::units::static_rational">static_rational</classname></computeroutput> </purpose></function>





















































































































</namespace>
</namespace>
</header>
<header name="boost/units/unit.hpp">
<namespace name="boost">
<namespace name="units">
<class name="unit"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
      <template-type-parameter name="Enable"/>
    </template><purpose>class representing a model-dependent unit with no associated value </purpose><description><para>(e.g. meters, Kelvin, feet, etc...) </para></description><typedef name="unit_type"><type><classname>unit</classname>&lt; Dim, System &gt;</type></typedef>
<typedef name="this_type"><type><classname>unit</classname>&lt; Dim, System &gt;</type></typedef>
<typedef name="dimension_type"><type>Dim</type></typedef>
<typedef name="system_type"><type>System</type></typedef>
<method-group name="public member functions">
</method-group>
<constructor/>
<constructor><parameter name=""><paramtype>const this_type &amp;</paramtype></parameter></constructor>
<copy-assignment><type>BOOST_CXX14_CONSTEXPR this_type &amp;</type><parameter name=""><paramtype>const this_type &amp;</paramtype></parameter></copy-assignment>
</class><struct-specialization name="reduce_unit"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg></specialization><purpose>Returns a unique type for every unit. </purpose><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef>
</struct-specialization><struct-specialization name="power_typeof_helper"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
      <template-nontype-parameter name="D"><type>long</type></template-nontype-parameter>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>static_rational&lt; N</template-arg><template-arg>D &gt;</template-arg></specialization><purpose>raise unit to a <computeroutput><classname alt="boost::units::static_rational">static_rational</classname></computeroutput> power </purpose><typedef name="type"><type><classname>unit</classname>&lt; typename <classname>static_power</classname>&lt; Dim, <classname>static_rational</classname>&lt; N, D &gt; &gt;::type, typename <classname>static_power</classname>&lt; System, <classname>static_rational</classname>&lt; N, D &gt; &gt;::type &gt;</type></typedef>
<method-group name="public static functions">
<method name="value" specifiers="static"><type>BOOST_CONSTEXPR type</type><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><struct-specialization name="root_typeof_helper"><template>
      <template-type-parameter name="Dim"/>
      <template-type-parameter name="System"/>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
      <template-nontype-parameter name="D"><type>long</type></template-nontype-parameter>
    </template><specialization><template-arg>unit&lt; Dim</template-arg><template-arg>System &gt;</template-arg><template-arg>static_rational&lt; N</template-arg><template-arg>D &gt;</template-arg></specialization><purpose>take the <computeroutput><classname alt="boost::units::static_rational">static_rational</classname></computeroutput> root of a unit </purpose><typedef name="type"><type><classname>unit</classname>&lt; typename <classname>static_root</classname>&lt; Dim, <classname>static_rational</classname>&lt; N, D &gt; &gt;::type, typename <classname>static_root</classname>&lt; System, <classname>static_rational</classname>&lt; N, D &gt; &gt;::type &gt;</type></typedef>
<method-group name="public static functions">
<method name="value" specifiers="static"><type>BOOST_CONSTEXPR type</type><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter></method>
</method-group>
</struct-specialization><function name="operator+"><type>BOOST_CONSTEXPR <classname>unary_plus_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim, System &gt; &gt;::type</type><template>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="System"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><purpose>unit runtime unary plus </purpose></function>
<function name="operator-"><type>BOOST_CONSTEXPR <classname>unary_minus_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim, System &gt; &gt;::type</type><template>
          <template-type-parameter name="Dim"/>
          <template-type-parameter name="System"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim, System &gt; &amp;</paramtype></parameter><purpose>unit runtime unary minus </purpose></function>
<function name="operator+"><type>BOOST_CONSTEXPR <classname>add_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim1, System1 &gt;, <classname>unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="System2"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>runtime add two units </purpose></function>
<function name="operator-"><type>BOOST_CONSTEXPR <classname>subtract_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim1, System1 &gt;, <classname>unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="System2"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>runtime subtract two units </purpose></function>
<function name="operator*"><type>BOOST_CONSTEXPR <classname>multiply_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim1, System1 &gt;, <classname>unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="System2"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>runtime multiply two units </purpose></function>
<function name="operator/"><type>BOOST_CONSTEXPR <classname>divide_typeof_helper</classname>&lt; <classname>unit</classname>&lt; Dim1, System1 &gt;, <classname>unit</classname>&lt; Dim2, System2 &gt; &gt;::type</type><template>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="System2"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>runtime divide two units </purpose></function>
<function name="operator=="><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="System2"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>unit runtime <computeroutput>operator==</computeroutput> </purpose></function>
<function name="operator!="><type>BOOST_CONSTEXPR bool</type><template>
          <template-type-parameter name="Dim1"/>
          <template-type-parameter name="Dim2"/>
          <template-type-parameter name="System1"/>
          <template-type-parameter name="System2"/>
        </template><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim1, System1 &gt; &amp;</paramtype></parameter><parameter name=""><paramtype>const <classname>unit</classname>&lt; Dim2, System2 &gt; &amp;</paramtype></parameter><purpose>unit runtime <computeroutput>operator!=</computeroutput> </purpose></function>






















































































































</namespace>
</namespace>
</header>
<header name="boost/units/units_fwd.hpp">
<para>Forward declarations of library components. </para><para>Forward declarations of units library - dimensions, systems, quantity and string components. </para></header>
</library-reference>